# xpSaiValidationArrayGen.py
#
#/*******************************************************************************
#* Copyright (c) 2021 Marvell. All rights reserved. The following file is       *
#* subject to the limited use license agreement by and between Marvell and you, *
#* your employer or other entity on behalf of whom you act. In the absence of   *
#* such license agreement the following file is subject to Marvell`s standard   *
#* Limited Use License Agreement.                                               *
#********************************************************************************/

# This script parses the sai header files to generate validation arrays which
# contain only the attributes supported by xdk. The attributes not supported by
#xdk should be included in xpSaiNotSupported.txt file. The validation arrays are
#written into xpSaiValidationArrays.h file in util/include

import argparse
import os.path

parser = argparse.ArgumentParser(description='This script generates input arrays for SAI attribute validator.',
                                 epilog='SAI validation utility uses attribute arrays to define attributes verification on create and set operations. These arrays are autogenerated by xpSaiValidationArrayGen.py script and stored in xpSaiValidationArrays.h file. As a fact, attributes flags and usage conditions depend on SAI headers version. Also, we have to take into account that XPS layer does not support all SAI attributes.\nPlease note, we have to run this script after SAI headers modification or xpSaiNotSupported.txt file modification.\nPlease follow SAI/xpSai/saiShell/README.txt prior to running the script.\nList of unsupported attributes is stored in SAI/xpSai/util/xpSaiNotSupported.txt document.\n',
                                 formatter_class=argparse.RawTextHelpFormatter)

args = parser.parse_args()

import sys
import os
from xml.etree import ElementTree

file_name = '../../xpSai/sai/xml/all.xml'
full_file = os.path.join('',file_name)

# Verify all.xml file is present
if not os.path.isfile(full_file):
    print "Failed to find all.xml file.\nPlease see README.txt for details."
    exit()

dom = ElementTree.parse(full_file)

root= dom.getroot()

cond_val_type_map ={}
cond_val_type_map['bool'] = 'XP_SAI_TYPE_BOOL'
#cond_val_type_map['char'] = 'XP_SAI_TYPE_'
cond_val_type_map['sai_uint8_t'] = 'XP_SAI_TYPE_U8'
cond_val_type_map['sai_int8_t'] = 'XP_SAI_TYPE_S8'
cond_val_type_map['sai_uint16_t'] = 'XP_SAI_TYPE_U16'
cond_val_type_map['sai_int16_t'] = 'XP_SAI_TYPE_S16'
cond_val_type_map['sai_uint32_t'] = 'XP_SAI_TYPE_U32'
cond_val_type_map['sai_int32_t'] = 'XP_SAI_TYPE_S32'
cond_val_type_map['sai_uint64_t'] = 'XP_SAI_TYPE_U64'
cond_val_type_map['sai_int64_t'] = 'XP_SAI_TYPE_S64'
#cond_val_type_map['sai_pointer_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_mac_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_ip4_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_ip6_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_ip_address_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_ip_prefix_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_object_id_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_object_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_u8_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_s8_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_u16_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_s16_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_u32_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_s32_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_u32_range_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_s32_range_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_vlan_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_qos_map_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_map_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_acl_field_data_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_acl_action_data_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_acl_capability_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_acl_resource_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_tlv_list_t'] = 'XP_SAI_TYPE_'
#cond_val_type_map['sai_segment_list_t'] = 'XP_SAI_TYPE_'

# Defined strings for functions
keystr = 'sai_status_t'
create = 'sai_create_'
remove = 'sai_remove_'
saiset = 'sai_set_'
saiget = 'sai_get_'
apikey = '_api_t'

# Declare dictionaries 
file_list ={}
list_struct_dict ={}
union_membrs = {}
api_structures ={}
api_enums = {}
enum_db = {}
supported_attrib_count = {}

# Define Strings for attributes
keystr = "_attr_t"

#Each attribute-id has a flag associated with it which defines the scope of that attribute.If the flag is READ-ONLY then the attribute can only be read,If CREATE-AND-SET then the attribute can be used while creating an object and also can be modified later and so on.. SAI 1.0 has six types of flags which are stated below.
#TODO UPDATE Required if new flags introduced
readonly = ['READ-ONLY', 'READ_ONLY']
readwrite =['READ-WRITE', 'READ_WRITE']
createset = ['CREATE_AND_SET', 'CREATE-AND-SET']
mand_on_create_only =['MANDATORY_ON_CREATE|CREATE_ONLY', 'MANDATORY_ON_CREATE | CREATE_ONLY']
mand_on_create_and_set = ['MANDATORY_ON_CREATE | CREATE_AND_SET','MANDATORY_ON_CREATE|CREATE_AND_SET', 'CREATE_AND_SET|MANDATORY_ON_CREATE', 'CREATE_AND_SET | MANDATORY_ON_CREATE']

createonly = ['CREATE_ONLY','CREATE-ONLY']

def getEnumDbFromxml():
	
	for child in root:
	    # Search for child of kind file in the xml file
	    if child.attrib['kind'] == 'file':
		# File name is present in element compoundname.text
		filename = (child.find('compoundname').text).replace('.h','')
				
		# Each compound has multiple sections
		sections = child.findall('sectiondef')
	
		# Search for sections of kind enum
		for x in sections:
		    if x.attrib['kind'] == 'enum':
			# Section of kind enum has all the defined enums as its members
		        for y in x:
			    enum_name = y.find('name').text
			    enum_name = enum_name[1:]
                            #print enum_name
			    enum_members = []
			    for z in y:
				# Element y has the all attributes as its members 
		                # Check if member is of type 'enumvalue'
		            	if z.tag == 'enumvalue':
		                    enum_member = z.find('name').text
		                    enum_members.append(enum_member)
			    enum_db[enum_name] = enum_members
                            #print enum_members
def getAttrDSFromxml():
	# Define Strings for attributes
	keystr = "_attr_t"
	typeset = "NO"
	flagset = "NO"
	nameset = "NO"
	
	attr_proprty = {}
        objct_list = {}
	objct_attr_list = {}
	objct_modules ={}

	for child in root:
	    # Search for child of kind file in the xml file
	    if child.attrib['kind'] == 'file':
		# File name is present in element compoundname.text
		filename = (child.find('compoundname').text).replace('.h','')
				
		# Each compound has multiple sections
		sections = child.findall('sectiondef')
	
		# Search for sections of kind enum
		for x in sections:
		    if x.attrib['kind'] == 'enum':
			# Section of kind enum has all the defined enums as its members
		        for y in x:
			    # Check if enum y  is that of attributes 
		            string = y.find('name').text
			    # keystr = "_attr_t" if keystr present in string then the enum is defined for attribute_list 
		            if keystr in string:
		                # Framing the object name from enum name
				objctname = string.replace('_sai_','').replace(keystr,'').strip()
				for z in y:
				    # Element y has the all attributes as its members 
				    # Check if member is of type 'enumvalue'
		                    if z.tag == 'enumvalue':
		                        attr_id = z.find('name').text
		                        attr_proprty['attr_id']=attr_id
		                        detail = z.find('detaileddescription') # Element 'detaileddescription' has the properties of the attributes as its children
					flagset = "NO"
                                        conditionset = "NO"
					# Iterate through the children of detaileddescription to know the property of the attrributes
					for ab in detail:
					    
		                            for ppty in ab:
					
						# Check if the child is defined "Flag" property of the attribute
		                                if ((ppty.tag == 'simplesect') and (ppty.find('title').text) == "Flags:"):
						    flag_string = ''
		                                    flag_string = ppty.find('para').text
						
						    if flagset == "NO":
							    for a in readonly:
								if a in flag_string  :
				                                	attr_proprty['mandatory_on_create'] ='false'
				                                	attr_proprty['valid_for_create'] ='false'
				                                	attr_proprty['valid_for_set'] ='false'
									attr_proprty['valid_for_get'] ='true'
				                                	flagset = "YES"
									break
						    if flagset == "NO":
							    for a in  readwrite :
				                        	if a in flag_string:
									attr_proprty['mandatory_on_create'] ='false'
				                                	attr_proprty['valid_for_create'] ='false'
				                               		attr_proprty['valid_for_set'] ='true'
				                                	attr_proprty['valid_for_get'] ='true'
				                                	flagset = "YES"
									break 
						    if flagset == "NO":
							    for a in mand_on_create_only :
								if a in flag_string:
				                                	attr_proprty['mandatory_on_create'] ='true'
				                                	attr_proprty['valid_for_create'] ='true'
				                                	attr_proprty['valid_for_set'] ='false'
				                                	attr_proprty['valid_for_get'] ='true'
				                                	flagset = "YES"
									break
						    if flagset == "NO":
							    for a in mand_on_create_and_set : 
								if a in flag_string:
									attr_proprty['mandatory_on_create'] ='true'
				                                	attr_proprty['valid_for_create'] ='true'
				                                	attr_proprty['valid_for_set'] ='true'
				                                	attr_proprty['valid_for_get'] ='true'
				                                	flagset = "YES"
									break
						    if flagset == "NO":
							    for a in createset :
								if a in flag_string :
		                                                	attr_proprty['mandatory_on_create'] ='false'
		                                                	attr_proprty['valid_for_create'] ='true'
		                                                	attr_proprty['valid_for_set'] ='true'
		                                                	attr_proprty['valid_for_get'] ='true'
		                                                	flagset = "YES"
		                                                	break
						
						    if flagset == "NO":
							    for a in createonly:
								if a in flag_string :
									attr_proprty['mandatory_on_create'] ='false'
				                                	attr_proprty['valid_for_create'] ='true'
				                                	attr_proprty['valid_for_set'] ='false'
				                                	attr_proprty['valid_for_get'] ='true'
				                                	flagset = "YES"
							    		break

                                                elif (((ppty.tag == 'simplesect') and (ppty.find('title').text) == "Condition:") or
                                                      ((ppty.tag == 'simplesect') and (ppty.find('title').text) == "Valid only when:")) :
                                                    condition_string = ''
                                                    condition_string = ppty.find('para').text
                                                    condition_string = condition_string.replace('@@condition','')
                                                    condition_string = condition_string.replace('@@validonly','')
                                                    condition_string = condition_string.strip(' ')
                                                    condition_string = condition_string.strip(')')
                                                    condition_string = condition_string.strip('(')
                                                    #print condition_string
                                                    conditions = condition_string.split(" or ")
                                                    condition_list = []
                                                    condition_value = []
                                                    for eachcondition in conditions:
                                                        condition_list.append(eachcondition.split('==')[0])
                                                        condition_value.append(eachcondition.split('==')[1])
                                                    #print condition_list
                                                    #print condition_value
                                                    attr_proprty['condition_type'] = condition_list
                                                    attr_proprty['condition_value'] = condition_value
                                                    conditionset = "YES"

                                                else:
						    continue  
				        if flagset =="NO":
		                      	    attr_proprty['mandatory_on_create'] ='false'
		                            attr_proprty['valid_for_create'] ='false'
		                            attr_proprty['valid_for_set'] ='false'
		                            attr_proprty['valid_for_get'] ='false'
		                        
				        if conditionset == "NO":
                                            attr_proprty['condition_type'] = ['XP_SAI_NO_CONDITION']
                                            attr_proprty['condition_value'] = ['XP_SAI_NO_CONDITION']

					# Build the attribute name from attr_id
                                        attr_proprty['attrib_name'] = attr_id
		                        nameset = "YES"

					# Parse to find the attribute type

					detail = z.find('detaileddescription')
		                        for ab in detail:
		                            for ppty in ab:
		                                if ((ppty.tag == 'simplesect') and (ppty.find('title').text) == "Value Type:"):
		                                    type_string = ppty.find('para').text
						    type_list = type_string.replace('@@type','').strip().split(' ')
		                                    attr_proprty['attrib_type'] = type_list[0]
						    #attr_proprty['attrib_type'] = type_string.replace('@@type','').strip()
		                                    typeset = "YES"
		                        if typeset == "NO":
		                            attr_proprty['attrib_type'] = 'undetermined'
		                            
		                        typeset = "NO"
					
					if ((not attr_id.endswith('START')) and not (attr_id.endswith('END'))):#Should Discard the START and END attributes
		                        	objct_attr_list[attr_id] = attr_proprty
		                        attr_proprty = {}
				
				objct_modules['attr_list'] = objct_attr_list
				objct_modules['fn_list'] = {}
				objct_list[objctname] = objct_modules
	#			objct_list[objctname]= [objct_attr_list]
		                objct_attr_list = {}
		                objct_modules = {}
		file_list[filename]=objct_list
		objct_list = {}	

def genUnionDSFromXml():
        key_str = 'sai_attribute_value_t'
        for child in root:
            if child.attrib['kind'] == 'union':
                if key_str in (child.find('compoundname').text):

                    union_name  = child.find('compoundname').text
                    section = child.find('sectiondef')
                    members = section.findall('memberdef')

                    for member in members:
                        memberdef = member.find('definition').text
                        union_membrs[memberdef.split(' ')[0]] = member.find('name').text
        

# Func:  genCustomerRelatedCode
def genCustomerRelatedCode(fns):
    return

def printDS():

        fns = open('../../xpSai/util/include/xpSaiValidationArrays.h','w')

        #Writing the cpoyright to the headerfile
        fns.write('/********************************************************************************/\n')
        fns.write('/* Copyright (c) 2021 Marvell. All rights reserved. The following file is       */\n')
        fns.write('/* subject to the limited use license agreement by and between Marvell and you, */\n')
        fns.write('/* your employer or other entity on behalf of whom you act. In the absence of   */\n')
        fns.write('/* such license agreement the following file is subject to Marvell`s standard   */\n')
        fns.write('/* Limited Use License Agreement.                                               */\n')
        fns.write('/********************************************************************************/\n')

        #Writing the purpose of the script and typical usage examples
        fns.write('/*\n')
        fns.write(' * Each SAI object has some number of attributes. Each attribute has some properties (MANDATORY_ON_CREATE, CREATE_ONLY, CREATE_AND_SET)\n')
        fns.write(' * that has to be validated on SAI object create or set attribute operation. To unify verification approach and describe attributes\n')
        fns.write(' * intercannections we are using feature specific arrays. Arrays are defined in xpSaiValidationArrays.h file.\n')
        fns.write(' * The meaning of the array is:\n')
        fns.write(' *    id;                -- sai_attr_id_t -- attribute id\n')
        fns.write(' *    attrValue;         -- int           -- attribute value. If all values are supported, please use XP_SAI_ATTR_ANY\n')
        fns.write(' *    xpSaiSupport;      -- bool          -- is attribute supported by SAI Adapter?\n')
        fns.write(' *    mandatoryOnCreate; -- bool          -- is attribute mandatory on create?\n')
        fns.write(' *    validForCreate;    -- bool          -- is attribute valid for create?\n')
        fns.write(' *    validForSet;       -- bool          -- is attribute valid for set?\n')
        fns.write(' *    validForGet;       -- bool          -- is attribute valid for get?\n')
        fns.write(' *    *name;             -- char          -- attribute name. Used on error display.\n')
        fns.write(' *    conditionType;     -- sai_attr_id_t -- condition to verify parameter on. Please use XP_SAI_NO_CONDITION if no condition should apply.\n')
        fns.write(' *    conditionValue;    -- int           -- condition value. Please use XP_SAI_NO_CONDITION if no condition should apply.\n *\n *\n')
        fns.write(' * Please note, some of the attributes are not supported. List of such attributes is located in xpSaiNotSupported.txt file.\n')
        fns.write(' */\n')

        fns.write('\n#ifndef _xpSaiValidationArrays_h_\n#define _xpSaiValidationArrays_h_\n\n')
        fns.write('#ifdef __cplusplus\nextern "C" {\n#endif  /*__cplusplus*/\n\n')
        fns.write('#include "sai.h"\n')
        fns.write('#include "xpSaiUtil.h"\n')

        genCustomerRelatedCode(fns)

	for key in file_list.keys():
    	    file_a = file_list[key]
    	    for objects in file_a.keys() :
                fns.write("\n\nstatic const xpSaiAttrEntry_t "+objects+'_attribs[] = {')
                modules = file_a[objects]
                attr_list = modules['attr_list']
                supportflag = True
                count = 0
        	for attribute in attr_list.keys():
                    supportflag = True
                    enumflag = True
                    with open('../../xpSai/util/xpSaiNotSupported.txt','r') as ns:
                        for line in ns:
                            line = line.replace(' ','').replace(',','').replace(';','')
                            line = line.strip("/\n")
                            line.strip("/\t")
                            if (attribute in line) and (line in attribute):
                                supportflag = False
                                enumflag = False
                                break
                    #print supportflag
                    attr_property = attr_list[attribute]
                    #print union_membrs.keys()
                    if attr_property['attrib_type'] in union_membrs.keys():
                        conditions = attr_property['condition_type']
                        for x in range(len(conditions)):
                            cond = attr_property['condition_type'][x].strip()
                            cond_val = attr_property['condition_value'][x].strip().split(' ')[0]
                            cond_val_type = 'XP_SAI_TYPE_INVALID'
                            if cond != 'XP_SAI_NO_CONDITION':
                                cond_attr_property = attr_list[cond]
                                cond_val_type = cond_attr_property['attrib_type'].strip()
                                if cond_val_type in cond_val_type_map.keys():
                                    cond_val_type = cond_val_type_map[cond_val_type]
                                else:
                                    cond_val_type = 'XP_SAI_TYPE_S32'
                            fns.write('\n\t{ %-55s %-40s, %5s, %-5s, %-5s, %-5s, %-5s, %-55s %-30s %-30s %-30s},' % (attribute + ',', 'XP_SAI_ATTR_ANY', str(supportflag).lower(), attr_property['mandatory_on_create'], attr_property['valid_for_create'], attr_property['valid_for_set'], attr_property['valid_for_get'], '"' + attr_property['attr_id'] + '",', cond + ',', cond_val + ',', cond_val_type))
                            count = count+1
                    elif attr_property['attrib_type'] != 'undetermined':
                        enum_list = enum_db[attr_property['attrib_type']]
                        attr_property = attr_list[attribute]
                        for each_enum in enum_list:
                            supportflag = True
                            with open('../../xpSai/util/xpSaiNotSupported.txt','r') as ns:
                                for line in ns:
                                    line = line.replace(' ','').replace(',','').replace(';','')
                                    line = line.strip("/\n")
                                    line = line.strip("/\t")
                                    if each_enum in line and line in each_enum:
                                        supportflag = False
                                        break
                                    supportflag = supportflag and enumflag
                            conditions = attr_property['condition_type']
                            for x in range(len(conditions)):
                                cond = attr_property['condition_type'][x].strip()
                                cond_val = attr_property['condition_value'][x].strip().split(' ')[0]
                                cond_val_type = 'XP_SAI_TYPE_INVALID'
                                if cond != 'XP_SAI_NO_CONDITION':
                                    cond_attr_property = attr_list[cond]
                                    cond_val_type = cond_attr_property['attrib_type'].strip()
                                    if cond_val_type in cond_val_type_map.keys():
                                        cond_val_type = cond_val_type_map[cond_val_type]
                                    else:
                                        cond_val_type = 'XP_SAI_TYPE_S32'
                                fns.write('\n\t{ %-55s %-40s, %5s, %-5s, %-5s, %-5s, %-5s, %-55s %-30s %-30s %-30s},' % (attribute + ',', each_enum, str(supportflag).lower(), attr_property['mandatory_on_create'], attr_property['valid_for_create'], attr_property['valid_for_set'], attr_property['valid_for_get'], '"' + attr_property['attr_id'] + '",', cond + ',', cond_val + ',', cond_val_type))
                                count = count+1
                
                fns.write('\n};\n')
                supported_attrib_count[objects] = count
                obj_str = ''
                obj_str = objects.strip()
                obj_str = obj_str.upper()
                fns.write('\n#define '+obj_str+'_VALIDATION_ARRAY_SIZE ('+str(count)+')')

        fns.write('\n\n#ifdef __cplusplus\n}\n#endif /*__cplusplus*/\n\n#endif /*_xpSaiUtil_h_*/\n')
        fns.close()

if __name__ == "__main__":

    genUnionDSFromXml()
    getEnumDbFromxml()
    getAttrDSFromxml()
    printDS()	

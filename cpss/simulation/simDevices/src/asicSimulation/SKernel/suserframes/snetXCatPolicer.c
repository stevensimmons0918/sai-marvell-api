/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
*/
/**
********************************************************************************
* @file snetXCatPolicer.c
*
* @brief (XCat) Policing Engine processing for frame -- simulation
*
* @version   55
********************************************************************************
*/

#include <asicSimulation/SKernel/skernel.h>
#include <asicSimulation/SKernel/smem/smemCheetah.h>
#include <asicSimulation/SKernel/suserframes/snet.h>
#include <asicSimulation/SKernel/suserframes/snetLion2Oam.h>
#include <asicSimulation/SKernel/cheetahCommon/sregCheetah.h>
#include <common/Utils/Math/sMath.h>
#include <asicSimulation/SKernel/suserframes/snetXCatPolicer.h>
#include <asicSimulation/SLog/simLog.h>
#include <asicSimulation/SKernel/suserframes/snetXCat.h>

/* remark entry size in bits for egress policer */
#define SNET_XCAT_POLICER_EGR_REMARK_ENTRY_SIZE_CNS 17

/* Policer Counting modes GET */
#define SNET_XCAT_POLICER_COUNTING_MODE_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 1, 2)
/* Policer Counter Color Mode GET */
#define SNET_XCAT_POLICER_COUNT_COLOR_MODE_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 7, 1)

/* Enable IPfix aging */
#define SNET_XCAT_POLICER_IPFIX_AGE_ENABLE_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 22, 1)
/* VLAN Counting Mode */
#define SNET_XCAT_POLICER_VLAN_COUNT_MODE_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 3, 1)

/* IPFIX Control Enable dropped packets counting GET */
#define SNET_XCAT_POLICER_IPFIX_DROP_COUNT_EN_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 8, 1)

/* IPFIX Control IPfix Wrap Around Action GET */
#define SNET_XCAT_POLICER_IPFIX_WA_ACTION_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 9, 1)

/* IPFIX Control IPfix Base Flow-ID GET */
#define SNET_XCAT_POLICER_IPFIX_BASE_FLOW_ID_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 16, 16)

/* IPFIX CPU code GET */
#define SNET_XCAT_POLICER_IPFIX_CPU_CODE_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 0, 6)

#define SNET_CHT3_POLICER_COLOR_MODE_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[6], 2, 1) : \
        SMEM_U32_GET_FIELD(entry[4], 1, 1)

static GT_BOOL ipfixFirstNResolvedCpuCodeTable[8][5] =
{
  /* OldCmd 1StNCmd FORWARD,   MIRROR,   TRAP,     HARD_DROP, SOFT_DROP */
  /*FORWARD*/       {GT_FALSE, GT_TRUE,  GT_TRUE,  GT_TRUE, GT_TRUE},
  /*MIRROR*/        {GT_FALSE, GT_FALSE, GT_TRUE,  GT_TRUE, GT_FALSE},
  /*TRAP*/          {GT_FALSE, GT_FALSE, GT_FALSE, GT_TRUE, GT_FALSE},
  /*HARD_DROP*/     {GT_FALSE, GT_FALSE, GT_FALSE, GT_TRUE, GT_FALSE},
  /*SOFT_DROP*/     {GT_FALSE, GT_TRUE,  GT_TRUE,  GT_TRUE, GT_TRUE},
  /*TO_TRG_SNIF*/   {GT_FALSE, GT_FALSE, GT_FALSE, GT_TRUE, GT_FALSE},
  /*TO_CPU*/        {GT_FALSE, GT_FALSE, GT_FALSE, GT_TRUE, GT_FALSE},
  /*FROM_CPU*/      {GT_FALSE, GT_FALSE, GT_FALSE, GT_TRUE, GT_FALSE}
};

/* Enumeration and structures */

/* Enumeration of Policer Counting modes */
typedef enum {
    SNET_XCAT_POLICER_COUNTING_DISABLE_E = 0,
    SNET_XCAT_POLICER_COUNTING_BILLING_E,
    SNET_XCAT_POLICER_COUNTING_POLICY_E,
    SNET_XCAT_POLICER_COUNTING_VLAN_E
} SNET_XCAT_POLICER_COUNTING_MODE_ENT;

/* Enumeration of Policer Meter modes */
typedef enum {
    SNET_XCAT_POLICER_METER_PORT_E = 0,
    SNET_XCAT_POLICER_METER_FLOW_E
}SNET_XCAT_POLICER_METER_MODE_ENT;

/* Enumeration of E_ARCH (Eport/Evlan) Policer Meter modes */
typedef enum {
    E_ARCH_POLICER_METER_DISABLED_E = 0,
    E_ARCH_POLICER_METER_EPORT_USED_E,
    E_ARCH_POLICER_METER_EVLAN_USED_E,
    E_ARCH_POLICER_METER_NOT_SUPPORTED_E
}E_ARCH_POLICER_METER_MODE_ENT;



/* Enumeration of Policer Meter modes */
typedef enum {
    SNET_XCAT_POLICER_METER_UCAST_E = 0,
    SNET_XCAT_POLICER_METER_UNK_UCAST_E,
    SNET_XCAT_POLICER_METER_REG_MCAST_E,
    SNET_XCAT_POLICER_METER_UNREG_MCAST_E,
    SNET_XCAT_POLICER_METER_BCAST_E,
    SNET_XCAT_POLICER_METER_TCP_SYN_E
}SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT;

/* Enumeration of Policer IPFix Sampling modes */
typedef enum {
    SNET_XCAT_POLICER_SAMPLE_MODE_DISABLE_E = 0,
    SNET_XCAT_POLICER_SAMPLE_MODE_PCKT_E,
    SNET_XCAT_POLICER_SAMPLE_MODE_BYTE_E,
    SNET_XCAT_POLICER_SAMPLE_MODE_TIME_E
}SNET_XCAT_POLICER_IPFIX_SAMPLE_MODE_ENT;

/* Enumeration of IPFIX PHA Metadata Mode */
typedef enum {
    SNET_XCAT_POLICER_IPFIX_PHA_METADATA_MODE_DISABLE_E,
    SNET_XCAT_POLICER_IPFIX_PHA_METADATA_MODE_COUNTER_E,
    SNET_XCAT_POLICER_IPFIX_PHA_METADATA_MODE_RANDOM_E,
    SNET_XCAT_POLICER_IPFIX_PHA_METADATA_MODE_RESERVE_E
}SNET_XCAT_POLICER_IPFIX_PHA_METADATA_MODE_ENT;

/* Enumeration of Ingress/Egress Policer Interrupts */
typedef enum {
    SNET_XCAT_POLICER_INTR_DATA_ERROR_E     = (1<<1),
    SNET_XCAT_POLICER_INTR_ADDR_OUT_MEM_E   = (1<<2),
    SNET_XCAT_POLICER_INTR_IPFIX_WRAP_E     = (1<<3),
    SNET_XCAT_POLICER_INTR_IPFIX_ALARM_E    = (1<<4),
    SNET_XCAT_POLICER_INTR_IPFIX_ALARM_ENTRIES_FIFO_WA_E = (1<<5)
}SNET_XCAT_POLICER_INTR_ENT;

/* Enumeration of IPFix Sampling action */
typedef enum {
    SNET_XCAT_POLICER_IPFIX_SAMPLE_ALARM_E,
    SNET_XCAT_POLICER_IPFIX_SAMPLE_MIRROR_E
}SNET_XCAT_POLICER_IPFIX_SAMPLE_ACTION_ENT;

/* Structure of Policer IPFix Sampling related info */
typedef struct {
    GT_U64 lastSampleValue64;
    GT_BIT randomEnable;
    GT_U32 randomOffset;
    GT_U32 sampleRange;
    GT_U64 sampleWindow64;
    GT_U32 sampleAction;
    GT_U32 cpuSubCode;
}SNET_XCAT_POLICER_IPFIX_SAMPLE_STC;

/* Structure of SIP6_10 Policer IPFix Sampling related info */
typedef struct {
    GT_U32                                        firstPacketsCounter;
    GT_U32                                        numberOfFirstPacketsToMirror;
    SNET_XCAT_POLICER_IPFIX_PHA_METADATA_MODE_ENT phaMetadataMode;
    GT_U32                                        firstTimestamp;
    GT_BOOL                                       firstTimestampValid;
    SKERNEL_EXT_PACKET_CMD_ENT                    lastPacketCommand;
    GT_U32                                        lastCpuOrDropCode;
}SNET_XCAT_SIP6_10_POLICER_IPFIX_SAMPLE_STC;

#define SMEM_LION3_PLR_METERING_TABLE_FIELDS_NAME                                     \
     STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_LAST_UPDATE_TIME0                        )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_LAST_UPDATE_TIME1                        )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_WRAP_AROUND_INDICATOR0                   )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_WRAP_AROUND_INDICATOR1                   )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0                             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1                             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE0                               )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE1                               )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE0                                    )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE1                                    )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE0                          )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE1                          )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_COLOR_MODE                               )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_POLICER_MODE                             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_MG_COUNTERS_SET_EN                       )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BILLING_PTR                              )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_PACKET_SIZE_MODE                         )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD                  )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE                    )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE              )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_RED_CMD                          )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_YELLOW_CMD                       )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_GREEN_CMD                        )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_MODIFY_DSCP                      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_MODIFY_UP                        )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_QOS_PROFILE                      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_REMARK_MODE                       )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_DROP_RED                          )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP                     )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP                    )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_TC                      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_UP                      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DP                      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_RANK                             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_RANK                             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_COLOR                            )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_COLOR                            )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_COUPLING_FLAG                            )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_COUPLING_FLAG0                           )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_RATE_INDEX                           )


char * lion3PlrMeteringFieldsTableNames[
    SMEM_LION3_PLR_METERING_TABLE_FIELDS___LAST_VALUE___E]=
    {SMEM_LION3_PLR_METERING_TABLE_FIELDS_NAME};


SNET_ENTRY_FORMAT_TABLE_STC lion3PlrMeteringTableFieldsFormat[
    SMEM_LION3_PLR_METERING_TABLE_FIELDS___LAST_VALUE___E]=
{
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_LAST_UPDATE_TIME0                            */
    STANDARD_FIELD_MAC(28),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_LAST_UPDATE_TIME1                            */
    STANDARD_FIELD_MAC(28),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_WRAP_AROUND_INDICATOR0                       */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_WRAP_AROUND_INDICATOR1                       */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0                                 */
    STANDARD_FIELD_MAC(32),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1                                 */
    STANDARD_FIELD_MAC(32),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE0                                   */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE1                                   */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE0                                        */
    STANDARD_FIELD_MAC(17),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE1                                        */
    STANDARD_FIELD_MAC(17),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE0                              */
    STANDARD_FIELD_MAC(16),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE1                              */
    STANDARD_FIELD_MAC(16),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_COLOR_MODE                                   */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_POLICER_MODE                                 */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_MG_COUNTERS_SET_EN                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BILLING_PTR                                  */
    STANDARD_FIELD_MAC(16),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE                 */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_PACKET_SIZE_MODE                             */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE          */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD                      */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE                        */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE                  */
    STANDARD_FIELD_MAC(1),

/* ingress only fields */

/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_RED_CMD                              */
    {FIELD_SET_IN_RUNTIME_CNS,
     2,
     SMEM_LION3_PLR_METERING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE},
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_YELLOW_CMD                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_GREEN_CMD                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_MODIFY_DSCP                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_MODIFY_UP                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_QOS_PROFILE                          */
    STANDARD_FIELD_MAC(10),

/* egress only fields */

/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_REMARK_MODE                           */
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_LION3_PLR_METERING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE},
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_DROP_RED                              */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP                         */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP                        */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_TC                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_UP                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DP                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING                 */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_RANK                                 */
    {FIELD_SET_IN_RUNTIME_CNS,
     3,
     SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE1},
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_RANK                                 */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_COLOR                                */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_COLOR                                */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_COUPLING_FLAG                                */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_COUPLING_FLAG0                               */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_RATE_INDEX                               */
    STANDARD_FIELD_MAC(7)

};

#define SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_NAME                                       \
     STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_COLOR_MODE_E                         )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E                       )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MG_COUNTERS_SET_EN_E                 )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BILLING_PTR_E                        )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE_E       )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_PACKET_SIZE_MODE_E                   )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E)\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E            )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E              )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E        )\
         /* ingress only fields*/                                                            \
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_RED_CMD_E                    )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_YELLOW_CMD_E                 )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_GREEN_CMD_E                  )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_DSCP_E                )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_UP_E                  )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E                )\
         /* egress only fields*/                                                             \
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_REMARK_MODE_E                 )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_DROP_RED_E                    )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP_E               )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP_E              )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_TC_E                )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_UP_E                )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DP_E                )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING_E       )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MEF_10_3_ENV_SIZE_E                  )

#define SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_NAME                                         \
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_NAME                                          \
    ,STR(SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_GREEN_MIRROR_TO_ANALYZER_ENABLE_E  )\
    ,STR(SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_YELLOW_MIRROR_TO_ANALYZER_ENABLE_E )\
    ,STR(SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_RED_MIRROR_TO_ANALYZER_ENABLE_E    )\
    ,STR(SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_MEF_10_3_ENV_SIZE_E                 )\
    ,STR(SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_GREEN_MIRROR_TO_ANALYZER_ENABLE_E   )\
    ,STR(SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_YELLOW_MIRROR_TO_ANALYZER_ENABLE_E  )\
    ,STR(SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_RED_MIRROR_TO_ANALYZER_ENABLE_E     )

static char * sip5_15PlrMeteringConfigFieldsTableNames[
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_NAME};

/* new table in sip 5_15 that was not in sip5 */
static SNET_ENTRY_FORMAT_TABLE_STC sip5_15PlrMeteringConfigTableFieldsFormat[
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS___LAST_VALUE___E]=
{
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_COLOR_MODE_E                                   */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E                                 */
    STANDARD_FIELD_MAC(3),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MG_COUNTERS_SET_EN_E                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BILLING_PTR_E                                  */
    STANDARD_FIELD_MAC(16),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE_E                 */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_PACKET_SIZE_MODE_E                             */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E                      */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E                        */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E                  */
    STANDARD_FIELD_MAC(1),

/* ingress only fields */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_RED_CMD_E                              */
    {FIELD_SET_IN_RUNTIME_CNS,
     2,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E},
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_YELLOW_CMD_E                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_GREEN_CMD_E                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_DSCP_E                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_UP_E                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E                          */
    STANDARD_FIELD_MAC(10),

/* egress only fields */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_REMARK_MODE_E                           */
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E},
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_DROP_RED_E                              */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP_E                         */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP_E                        */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_TC_E                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_UP_E                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DP_E                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING_E                 */
    STANDARD_FIELD_MAC(1),

/* field common to ingress and to egress */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MEF_10_3_ENV_SIZE_E                           */
    {FIELD_SET_IN_RUNTIME_CNS,
     3,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E}
};

/* new table in sip 5_15 that was not in sip5 */
static SNET_ENTRY_FORMAT_TABLE_STC sip5_20PlrMeteringConfigTableFieldsFormat[
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS___LAST_VALUE___E]=
{
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_COLOR_MODE_E                                   */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E                                 */
    STANDARD_FIELD_MAC(3),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MG_COUNTERS_SET_EN_E                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BILLING_PTR_E                                  */
    STANDARD_FIELD_MAC(17),/*was 16 in sip 5_15 */
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE_E                 */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_PACKET_SIZE_MODE_E                             */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E                      */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E                        */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E                  */
    STANDARD_FIELD_MAC(1),

/* ingress only fields */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_RED_CMD_E                              */
    {FIELD_SET_IN_RUNTIME_CNS,
     2,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E},
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_YELLOW_CMD_E                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_GREEN_CMD_E                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_DSCP_E                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_UP_E                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E                          */
    STANDARD_FIELD_MAC(10),

/* egress only fields */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_REMARK_MODE_E                           */
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E},
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_DROP_RED_E                              */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP_E                         */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP_E                        */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_TC_E                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_UP_E                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DP_E                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING_E                 */
    STANDARD_FIELD_MAC(1),

/* field common to ingress and to egress */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MEF_10_3_ENV_SIZE_E                           */
    {FIELD_SET_IN_RUNTIME_CNS,
     3,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E}
};

static char * sip6PlrMeteringConfigFieldsTableNames[
    SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_NAME};

/* new table in sip6 (more fields from sip 5.20) */
static SNET_ENTRY_FORMAT_TABLE_STC sip6PlrMeteringConfigTableFieldsFormat[
    SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS___LAST_VALUE___E]=
{
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_COLOR_MODE_E                                   */
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E                                 */
    STANDARD_FIELD_MAC(3),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MG_COUNTERS_SET_EN_E                           */
    STANDARD_FIELD_MAC(2),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BILLING_PTR_E                                  */
    STANDARD_FIELD_MAC(17),/*was 16 in sip 5_15 */
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE_E                 */
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_PACKET_SIZE_MODE_E                             */
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E          */
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E                      */
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E                        */
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E                  */
    STANDARD_FIELD_MAC(1),

    /* ingress only fields */

    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_RED_CMD_E                              */
    {FIELD_SET_IN_RUNTIME_CNS,
    2,
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E},
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_YELLOW_CMD_E                           */
    STANDARD_FIELD_MAC(2),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_GREEN_CMD_E                            */
    STANDARD_FIELD_MAC(2),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_DSCP_E                          */
    STANDARD_FIELD_MAC(2),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_UP_E                            */
    STANDARD_FIELD_MAC(2),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E                          */
    STANDARD_FIELD_MAC(10),

    /* egress only fields */

    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_REMARK_MODE_E                           */
    {FIELD_SET_IN_RUNTIME_CNS,
    1,
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E},
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_DROP_RED_E                              */
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP_E                         */
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP_E                        */
    STANDARD_FIELD_MAC(2),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_TC_E                          */
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_UP_E                          */
    STANDARD_FIELD_MAC(2),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DP_E                          */
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING_E                 */
    STANDARD_FIELD_MAC(1),

    /* field common to ingress and to egress */

    /*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MEF_10_3_ENV_SIZE_E                           */
    {FIELD_SET_IN_RUNTIME_CNS,
    3,
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E},

    /*SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_GREEN_MIRROR_TO_ANALYZER_ENABLE_E*/
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_YELLOW_MIRROR_TO_ANALYZER_ENABLE_E*/
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_RED_MIRROR_TO_ANALYZER_ENABLE_E*/
    STANDARD_FIELD_MAC(1),

    /*SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_MEF_10_3_ENV_SIZE_E                           */
    {FIELD_SET_IN_RUNTIME_CNS,
    3,
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING_E},

    /*SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_GREEN_MIRROR_TO_ANALYZER_ENABLE_E*/
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_YELLOW_MIRROR_TO_ANALYZER_ENABLE_E*/
    STANDARD_FIELD_MAC(1),
    /*SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_RED_MIRROR_TO_ANALYZER_ENABLE_E*/
    STANDARD_FIELD_MAC(1)
};

#define SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_NAME                                  \
     STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_METERING_ENABLE_E              )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_COUNTING_ENABLE_E              )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_POLICER_PTR_E                  )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_KNOWN_UNICAST_OFFSET_E         )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNKNOWN_UNICAST_OFFSET_E       )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_REGISTERED_MULTICAST_OFFSET_E  )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNREGISTERED_MULTICAST_OFFSET_E)\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_BROADCAST_OFFSET_E             )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_TCP_SYN_OFFSET_E               )

char * lion3PlrEAttributesFieldsTableNames[
    SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC lion3PlrEAttributesTableFieldsFormat[
    SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS___LAST_VALUE___E] =
{
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_METERING_ENABLE_E               */
     STANDARD_FIELD_MAC(1)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_COUNTING_ENABLE_E               */
    ,STANDARD_FIELD_MAC(1)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_POLICER_PTR_E                   */
    ,STANDARD_FIELD_MAC(16)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_KNOWN_UNICAST_OFFSET_E          */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNKNOWN_UNICAST_OFFSET_E        */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_REGISTERED_MULTICAST_OFFSET_E   */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNREGISTERED_MULTICAST_OFFSET_E */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_BROADCAST_OFFSET_E              */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_TCP_SYN_OFFSET_E                */
    ,STANDARD_FIELD_MAC(3)
};

SNET_ENTRY_FORMAT_TABLE_STC falconPlrEAttributesTableFieldsFormat[
    SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS___LAST_VALUE___E] =
{
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_METERING_ENABLE_E               */
     STANDARD_FIELD_MAC(1)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_COUNTING_ENABLE_E               */
    ,STANDARD_FIELD_MAC(1)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_POLICER_PTR_E                   */
    ,STANDARD_FIELD_MAC(12)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_KNOWN_UNICAST_OFFSET_E          */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNKNOWN_UNICAST_OFFSET_E        */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_REGISTERED_MULTICAST_OFFSET_E   */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNREGISTERED_MULTICAST_OFFSET_E */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_BROADCAST_OFFSET_E              */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_TCP_SYN_OFFSET_E                */
    ,STANDARD_FIELD_MAC(3)
};

#define SMEM_LION3_PLR_BILLING_TABLE_FIELDS_NAME                                  \
     STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_E                        )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_YELLOW_COUNTER_E                       )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RED_COUNTER_E                          )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_E                             )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNTERS_MODE_E                )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNT_ALL_EN_E                 )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_LM_COUNTER_CAPTURE_MODE_E              )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_E               )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_VALID_E         )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_PACKET_SIZE_MODE_E                     )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E  )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E              )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E                )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E          )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_1_E                           )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_COUNTER_MODE_E                         )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_2_E                           )


static char * lion3PlrBillingFieldsTableNames[
    SMEM_LION3_PLR_BILLING_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_PLR_BILLING_TABLE_FIELDS_NAME};

static SNET_ENTRY_FORMAT_TABLE_STC lion3PlrBillingTableFieldsFormat[
    SMEM_LION3_PLR_BILLING_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_E                         */
     STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_YELLOW_COUNTER_E                        */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RED_COUNTER_E                           */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_E                              */
    ,STANDARD_FIELD_MAC(14)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNTERS_MODE_E                 */
    ,STANDARD_FIELD_MAC(2)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNT_ALL_EN_E                  */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_LM_COUNTER_CAPTURE_MODE_E               */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_E                */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_VALID_E          */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_PACKET_SIZE_MODE_E                      */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E   */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E               */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E                 */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E           */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_1_E                            */
    ,STANDARD_FIELD_MAC(36)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_COUNTER_MODE_E                          */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_2_E                            */
    ,STANDARD_FIELD_MAC(12)
};

static SNET_ENTRY_FORMAT_TABLE_STC sip5_15PlrBillingTableFieldsFormat[
    SMEM_LION3_PLR_BILLING_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_E                         */
     STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_YELLOW_COUNTER_E                        */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RED_COUNTER_E                           */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_E                              */
    ,STANDARD_FIELD_MAC(14)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNTERS_MODE_E                 */
    ,STANDARD_FIELD_MAC(2)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNT_ALL_EN_E                  */
    ,STANDARD_FIELD_MAC(2)/* increment by 1 */
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_LM_COUNTER_CAPTURE_MODE_E               */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_E                */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_VALID_E          */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_PACKET_SIZE_MODE_E                      */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E   */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E               */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E                 */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E           */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_1_E                            */
    ,STANDARD_FIELD_MAC(35)/* reduced by 1 */
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_COUNTER_MODE_E                          */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_2_E                            */
    ,STANDARD_FIELD_MAC(0)/* removed */
};


#define SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_NAME                                   \
     STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_BYTE_COUNT_E                         )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_PACKET_COUNT_E                       )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_TIME_STAMP_E                         )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_MODE_E                      )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_FLAG_E                        )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LOG_SAMPLING_RANGE_E                 )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_ACTION_E                    )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_CPU_SUB_CODE_E                       )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_WINDOW_E                    )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LAST_SAMPLED_VALUE_E                 )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_OFFSET_E                      )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_DROP_COUNTER_E                       )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_COUNTER_MODE_E                       )

char * lion3PlrIpfixFieldsTableNames[
    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC lion3PlrIpfixTableFieldsFormat[
    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_BYTE_COUNT_E                          */
     STANDARD_FIELD_MAC(36),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_PACKET_COUNT_E                        */
     STANDARD_FIELD_MAC(30),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_TIME_STAMP_E                          */
     STANDARD_FIELD_MAC(16),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_MODE_E                       */
     STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_FLAG_E                         */
     STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LOG_SAMPLING_RANGE_E                  */
     STANDARD_FIELD_MAC(6),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_ACTION_E                     */
     STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_CPU_SUB_CODE_E                        */
     STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_WINDOW_E                     */
     STANDARD_FIELD_MAC(36),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LAST_SAMPLED_VALUE_E                  */
     STANDARD_FIELD_MAC(36),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_OFFSET_E                       */
     STANDARD_FIELD_MAC(32),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_DROP_COUNTER_E                        */
     STANDARD_FIELD_MAC(30),
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_COUNTER_MODE_E                        */
     STANDARD_FIELD_MAC(1)
};


#define SMEM_SIP_6_10_PLR_IPFIX_TABLE_FIELDS_NAME   \
    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_NAME          \
    ,STR(SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_PACKETS_COUNTER_E            )\
    ,STR(SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_NUMBER_OF_FIRST_PACKETS_TO_MIRROR_E)\
    ,STR(SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_PHA_METADATA_MODE_E                )\
    ,STR(SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_TIMESTAMP_VALID_E            )\
    ,STR(SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_TIMESTAMP_E                  )\
    ,STR(SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_LAST_PACKET_COMMAND_E              )\
    ,STR(SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_LAST_CPU_OR_DROP_CODE_E            )\

char * sip6_10_PlrIpfixFieldsTableNames[
    SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_SIP_6_10_PLR_IPFIX_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC sip6_10_PlrIpfixTableFieldsFormat[
    SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_BYTE_COUNT_E          */
     STANDARD_FIELD_MAC(36)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_PACKET_COUNT_E        */
    ,STANDARD_FIELD_MAC(30)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_TIME_STAMP_E          */
    ,STANDARD_FIELD_MAC(16)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_MODE_E       */
    ,STANDARD_FIELD_MAC(2)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_FLAG_E         */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LOG_SAMPLING_RANGE_E  */
    ,STANDARD_FIELD_MAC(6)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_ACTION_E     */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_CPU_SUB_CODE_E        */
    ,STANDARD_FIELD_MAC(2)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_WINDOW_E     */
    ,STANDARD_FIELD_MAC(36)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LAST_SAMPLED_VALUE_E  */
    ,STANDARD_FIELD_MAC(36)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_OFFSET_E       */
    ,STANDARD_FIELD_MAC(32)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_DROP_COUNTER_E        */
    ,STANDARD_FIELD_MAC(30)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_COUNTER_MODE_E        */
    ,STANDARD_FIELD_MAC(1)

/*sampling_mode="Disable"*/
    /*SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_PACKETS_COUNTER_E [115:84]*/
    ,{FIELD_SET_IN_RUNTIME_CNS,
    32,
    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_MODE_E}
    /*SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_NUMBER_OF_FIRST_PACKETS_TO_MIRROR_E [147:116]*/
    ,STANDARD_FIELD_MAC(32)
    /*SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_PHA_METADATA_MODE_E [149:148]*/
    ,STANDARD_FIELD_MAC(2)
    /*SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_TIMESTAMP_VALID_E [150]*/
    ,STANDARD_FIELD_MAC(1)
    /*SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_TIMESTAMP_E [166:151]*/
    ,STANDARD_FIELD_MAC(16)
    /*SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_LAST_PACKET_COMMAND_E [169:167]*/
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_LAST_CPU_OR_DROP_CODE_E [177:170]*/
    ,STANDARD_FIELD_MAC(8)

};

#define SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_NAME                             \
     STR(SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_POLICER_PTR_E                  )\
    ,STR(SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_METERING_ENABLE_E              )\
    ,STR(SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_COUNTING_ENABLE_E              )

char * lion3PlrHierarchicalFieldsTableNames[
    SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC lion3PlrHierarchicalTableFieldsFormat[
    SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS___LAST_VALUE___E] =
{
    /*SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_POLICER_PTR_E                   */
     STANDARD_FIELD_MAC(16),
    /*SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_METERING_ENABLE_E               */
     STANDARD_FIELD_MAC(1),
    /*SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_COUNTING_ENABLE_E               */
     STANDARD_FIELD_MAC(1)
};

SNET_ENTRY_FORMAT_TABLE_STC falconPlrHierarchicalTableFieldsFormat[
    SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS___LAST_VALUE___E] =
{
    /*SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_POLICER_PTR_E                   */
     STANDARD_FIELD_MAC(12),
    /*SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_METERING_ENABLE_E               */
     STANDARD_FIELD_MAC(1),
    /*SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_COUNTING_ENABLE_E               */
     STANDARD_FIELD_MAC(1)
};

/* Function prototypes */

static GT_VOID snetXCatPolicerPolicyCounterIncrement(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 bytes
);

static GT_VOID snetXCatPolicerVlanCounterIncrement(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 bytes
);

static GT_VOID snetXCatPolicerStormRateTypeGet(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT * pcktTypePtr
);

static void snetXcatPolicerIpfixDropWaCheck(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_BIT dropCountEn,
    IN GT_U32 * dropPcktsPtr,
    GT_U32 treshold,
    GT_BIT wrapAction,
    GT_BOOL * wrapTriggeredPtr
);

static void snetXcatPolicerIpfixGoodPcktWaCheck(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * goodPcktsPtr,
    IN GT_U32 treshold,
    IN GT_BIT wrapAction,
    INOUT GT_BOOL * wrapTriggeredPtr
);

static void snetXcatPolicerIpfixBytesWaCheck(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT GT_U64 * bytesCntPtr,
    IN GT_U32 bytes,
    IN GT_U64 * treshold64Ptr,
    IN GT_BIT wrapAction,
    OUT GT_BOOL * wrapTriggeredPtr
);

static GT_BOOL snetLion2PolicerOamLmCounterIncrement(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 policerCntIndex,
    GT_U64 increment64
);

/* print packetCmd enum value */
extern GT_VOID simLogPacketDescrPacketCmdDump
(
    IN SKERNEL_DEVICE_OBJECT const *devObjPtr,
    IN SKERNEL_EXT_PACKET_CMD_ENT packetCmd
);

extern GT_U32 snetChtPktCmdResolution
(
    IN SKERNEL_EXT_PACKET_CMD_ENT prevCmd,
    IN SKERNEL_EXT_PACKET_CMD_ENT currCmd
);

/**
* @internal snetLion3PolicerPacketSizeGet function
* @endinternal
*
* @brief   Sip5 : Traffic Packet Size for Metering and Counting.
*         Get number of bytes for metering/billing/other .
*/
GT_VOID snetLion3PolicerPacketSizeGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN SNET_LION3_POLICER_PACKET_SIZE_MODE_ENT packetSizeMode,
    IN GT_U32           *entryPtr,
    OUT GT_U32          *bytesCountPtr
)
{
    DECLARE_FUNC_NAME(snetLion3PolicerPacketSizeGet);

    GT_U32  entryIndex;
    GT_U32 * policerCtrlRegPtr;         /* egress policer control data */
    GT_U32  packet_size_mode;
    GT_U32  tunnel_termination_packet_size_mode;
    GT_U32  include_layer1_overhead;
    GT_U32  dsa_tag_counting_mode;
    GT_U32  timestamp_tag_counting_mode;
    GT_U32  finalByteCount;
    GT_U32  tmpBytes;
    GT_BIT  marvellTagged;
    SKERNEL_EXT_DSA_TAG_TYPE_ENT    dsaTagType;
    GT_BIT  dsaReplacesVlan;
    GT_BIT timestampTagged;
    GT_BIT  isTunnel;
    GT_U32  l2Valid,l2HeaderSize,l2HeaderSizeTunnel,l2NumBytesToRemove;
    GT_U32  byteCount,byteCountTunnel,byteCountToUse;
    GT_BIT  useGlobalModes = 0;

    if(packetSizeMode == SNET_LION3_POLICER_PACKET_SIZE_FROM_METER_ENTRY_E && entryPtr != NULL)
    {
        __LOG(("Calc Byte count for Metering \n"));

        entryIndex = descrPtr->policerActuallAccessedIndex;
        if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
        {
            packet_size_mode  =
                SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                    descrPtr->policerMeterConfigEntryMemoryPtr,
                    entryIndex,
                    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_PACKET_SIZE_MODE_E);
            tunnel_termination_packet_size_mode  =
                SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                    descrPtr->policerMeterConfigEntryMemoryPtr,
                    entryIndex,
                    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E);
            include_layer1_overhead  =
                SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                    descrPtr->policerMeterConfigEntryMemoryPtr,
                    entryIndex,
                    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E);
            dsa_tag_counting_mode  =
                SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                    descrPtr->policerMeterConfigEntryMemoryPtr,
                    entryIndex,
                    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E);
            timestamp_tag_counting_mode  =
                SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                    descrPtr->policerMeterConfigEntryMemoryPtr,
                    entryIndex,
                    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E);
        }
        else
        {
            packet_size_mode  =
                SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    entryIndex,
                    SMEM_LION3_PLR_METERING_TABLE_FIELDS_PACKET_SIZE_MODE);
            tunnel_termination_packet_size_mode  =
                SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    entryIndex,
                    SMEM_LION3_PLR_METERING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE);
            include_layer1_overhead  =
                SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    entryIndex,
                    SMEM_LION3_PLR_METERING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD);
            dsa_tag_counting_mode  =
                SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    entryIndex,
                    SMEM_LION3_PLR_METERING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE);
            timestamp_tag_counting_mode  =
                SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    entryIndex,
                    SMEM_LION3_PLR_METERING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE);
        }
    }
    else
    if(packetSizeMode == SNET_LION3_POLICER_PACKET_SIZE_FROM_BILLING_ENTRY_E && entryPtr != NULL)
    {
        __LOG(("Calc Byte count for Billing \n"));

        entryIndex = descrPtr->countingActuallAccessedIndex;

        packet_size_mode  =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                entryIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_PACKET_SIZE_MODE_E);
        tunnel_termination_packet_size_mode  =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                entryIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E);
        include_layer1_overhead  =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                entryIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E);
        dsa_tag_counting_mode  =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E);
        timestamp_tag_counting_mode  =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                entryIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E);
    }
    else
    {
        if(descrPtr->policerCounterGlobalNumBytes)
        {
            *bytesCountPtr = descrPtr->policerCounterGlobalNumBytes;
            __LOG(("Final Byte count: [%d] bytes (already calculated according to global modes) \n",
                *bytesCountPtr));
            return;
        }

        useGlobalModes = 1;
        __LOG(("Calc Byte count for non-meter , non-billing purpose \n"));

        policerCtrlRegPtr =
            smemMemGet(devObjPtr, SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,descrPtr->policerCycle));

        packet_size_mode             = SMEM_U32_GET_FIELD(policerCtrlRegPtr[0], 16, 1);
        include_layer1_overhead      = SMEM_U32_GET_FIELD(policerCtrlRegPtr[0], 17, 1);
        dsa_tag_counting_mode        = SMEM_U32_GET_FIELD(policerCtrlRegPtr[0], 23, 1);
        tunnel_termination_packet_size_mode  = SMEM_U32_GET_FIELD(policerCtrlRegPtr[0], 24, 1);
        timestamp_tag_counting_mode  = SMEM_U32_GET_FIELD(policerCtrlRegPtr[0], 4, 1);
    }

    __LOG_PARAM(packet_size_mode);
    __LOG_PARAM(include_layer1_overhead);
    __LOG_PARAM(dsa_tag_counting_mode);
    __LOG_PARAM(tunnel_termination_packet_size_mode);
    __LOG_PARAM(timestamp_tag_counting_mode);

    if(direction == SMAIN_DIRECTION_INGRESS_E)
    {
        isTunnel = descrPtr->tunnelTerminated;
        l2Valid = descrPtr->l2Valid;

        if(isTunnel)
        {
            l2HeaderSizeTunnel = descrPtr->origInfoBeforeTunnelTermination.originalL3Ptr -
                descrPtr->origInfoBeforeTunnelTermination.originalL2Ptr;

            __LOG(("Tunnel : for tunnel mode : Num bytes to remove to get L3 from L2: is[%d] bytes \n",
                l2HeaderSizeTunnel));

            byteCountTunnel = descrPtr->origByteCount;
            __LOG(("Tunnel : for tunnel mode : Num bytes for L2: is[%d] bytes \n",
                byteCountTunnel));

            /* num bytes to decrement from byte count of passenger to be with L3 only */
            if(l2Valid)
            {
                l2HeaderSize = descrPtr->l3StartOffsetPtr - descrPtr->macDaPtr;
                __LOG(("Tunnel : for passenger mode : Num bytes to remove to get L3 from L2: when L2 valid , is[%d] bytes \n",
                    l2HeaderSize));
            }
            else
            {
                l2HeaderSize = 0;
                __LOG(("Tunnel : for passenger mode : Num bytes to remove to get L3 from L2: when L2 NOT valid , is 0 bytes \n"));
            }

            byteCount = descrPtr->byteCount;
            __LOG(("Tunnel : for passenger mode : Num bytes for L2: is[%d] bytes \n",
                byteCount));

        }
        else
        {
            l2HeaderSize       = descrPtr->l2HeaderSize;
            l2HeaderSizeTunnel = l2HeaderSize;

            __LOG(("No Tunnel : Num bytes to remove to get L3 from L2: is[%d] bytes \n",
                l2HeaderSize));

            byteCount = descrPtr->byteCount;
            byteCountTunnel = byteCount;

            __LOG(("No Tunnel : Num bytes for L2: is[%d] bytes \n",
                byteCount));
        }
    }
    else
    {
        isTunnel = descrPtr->tunnelStart;
        /*for TS that is not with ethernet passenger this is NULL */
        /*for TS that is     with ethernet passenger this is the mac da of the passenger */
        /*for non-TS that this is the mac da of the packet */
        l2Valid = descrPtr->haToEpclInfo.macDaSaPtr ? 1 : 0;

        if(isTunnel)
        {
            l2HeaderSizeTunnel = descrPtr->haToEpclInfo.tunnelStartL3StartOffsetPtr -
                           descrPtr->haToEpclInfo.tunnelStartL2StartOffsetPtr;
            __LOG(("Tunnel : for tunnel mode : Num bytes to remove to get L3 from L2: is[%d] bytes \n",
                l2HeaderSizeTunnel));

            byteCountTunnel = descrPtr->egressByteCount;
            __LOG(("Tunnel : for tunnel mode : Num bytes for L2: is[%d] bytes \n",
                byteCountTunnel));

            if(l2Valid)
            {
                l2HeaderSize = descrPtr->haToEpclInfo.l3StartOffsetPtr - descrPtr->haToEpclInfo.macDaSaPtr;
                __LOG(("Tunnel : for passenger mode : Num bytes to remove to get L3 from L2: when L2 valid , is[%d] bytes \n",
                    l2HeaderSize));

                byteCount = descrPtr->haToEpclInfo.macDaSaPtr - devObjPtr->egressBuffer;
                __LOG(("Tunnel : for passenger mode : Num bytes for L2: when L2 valid , is[%d] bytes \n",
                    byteCount));
            }
            else
            {
                l2HeaderSize = 0;
                __LOG(("Tunnel : for passenger mode : Num bytes to remove to get L3 from L2: when L2 NOT valid , is 0 bytes \n"));

                byteCount = descrPtr->haToEpclInfo.l3StartOffsetPtr - devObjPtr->egressBuffer;
                __LOG(("Tunnel : for passenger mode : Num bytes for L2: when L2 valid , is[%d] bytes \n",
                    byteCount));
            }

        }
        else
        {
            l2HeaderSize = descrPtr->haToEpclInfo.l3StartOffsetPtr -
                           descrPtr->haToEpclInfo.macDaSaPtr;
            l2HeaderSizeTunnel = l2HeaderSize;

            __LOG(("No Tunnel : Num bytes to remove to get L3 from L2: is[%d] bytes \n",
                l2HeaderSize));

            byteCount       = descrPtr->egressByteCount;
            byteCountTunnel = byteCount;

            __LOG(("No Tunnel : Num bytes for L2: is[%d] bytes \n",
                byteCount));
        }
    }

    if(isTunnel && tunnel_termination_packet_size_mode == 1/*Passenger*/)
    {
        __LOG(("Tunnel : byte count of the 'passenger and not the tunnel' \n"));

        l2NumBytesToRemove = l2HeaderSize;
        byteCountToUse = byteCount;
    }
    else
    if (isTunnel)
    {
        __LOG(("Tunnel : byte count of the 'tunnel and not the passenger' \n"));

        l2NumBytesToRemove = l2HeaderSizeTunnel;
        byteCountToUse = byteCountTunnel;
    }
    else
    {
        __LOG(("Non Tunnel : byte count of the packet \n"));
        l2NumBytesToRemove = l2HeaderSize;
        byteCountToUse = byteCount;
    }
    __LOG_PARAM(byteCountToUse);

    if(packet_size_mode == SNET_CHT3_LAYER3_PCKT_SIZE_E)/*L3*/
    {
        finalByteCount = byteCountToUse - l2NumBytesToRemove - 4/*CRC*/;

        __LOG(("count L3 bytes :[%d] \n",
            finalByteCount));
    }
    else /*L2*/
    {
        finalByteCount = byteCountToUse;
        __LOG(("count L2 bytes :[%d] \n",
            finalByteCount));
        if(include_layer1_overhead)
        {
            /* Packet byte count includes 20 bytes of layer-1 overhead */
            __LOG(("include LAYER1 (20 bytes) \n"));
            finalByteCount += 20;
        }
        else
        {
            __LOG(("NOT including LAYER1 (20 bytes) \n"));
        }

        if(direction == SMAIN_DIRECTION_INGRESS_E)
        {
            marvellTagged = descrPtr->marvellTagged;
            dsaTagType = descrPtr->marvellTaggedExtended;
            dsaReplacesVlan = descrPtr->origSrcTagged;
        }
        else
        {
            marvellTagged = descrPtr->egrMarvellTagType != MTAG_TYPE_NONE_E ? 1 : 0;
            dsaTagType    = descrPtr->egrMarvellTagType;
            dsaReplacesVlan = descrPtr->origSrcTagged;SIM_TBD_BOOKMARK /*descrPtr->eArchExtInfo.haInfo.dsaReplacesVlan*/
        }

        /* Enable Compensation of DSA Tag added byte count when metering and counting
           packets received via DSA-enabled ports */
        if (dsa_tag_counting_mode && marvellTagged)
        {
            /* decrement the bytes of the DSA tag */
            tmpBytes = (dsaTagType + 1)*4;

            __LOG(("decrement the bytes of the DSA tag (remove [%d] bytes) \n",
                tmpBytes));
            if(dsaReplacesVlan)
            {
                /* add the bytes of the original tag (that used in first word of the DSA tag) */
                __LOG(("add the 4 bytes of the original tag (that used in first word of the DSA tag)"));
                tmpBytes -= 4;
            }

            finalByteCount -= tmpBytes;
        }
        else
        if(marvellTagged)
        {
            __LOG(("DSA tagged packet but Compensation on DSA tag bytes is disabled \n"));
        }

        timestampTagged = descrPtr->timestampTagged[direction];

        if(timestamp_tag_counting_mode && timestampTagged !=  SKERNEL_TIMESTAMP_TAG_TYPE_UNTAGGED_E)
        {
            if (timestampTagged ==  SKERNEL_TIMESTAMP_TAG_TYPE_NON_EXTENDED_E)
            {
                finalByteCount -= 8;
                __LOG(("Timestamp Tag NON_EXTENDED - packet Timestamp Tag Compensation is 8 bytes \n"));
            }
            else if (timestampTagged ==  SKERNEL_TIMESTAMP_TAG_TYPE_EXTENDED_E)
            {
                finalByteCount -= 16;
                __LOG(("Timestamp Tag EXTENDED - packet Timestamp Tag Compensation is 16 bytes \n"));
            }
            else
            {
                __LOG(("Timestamp Tagged packet but Compensation on Timestamp Tagged bytes NOT implemented \n"));
            }
        }
        else
        if(timestampTagged !=  SKERNEL_TIMESTAMP_TAG_TYPE_UNTAGGED_E)
        {
            __LOG(("Timestamp Tagged packet but Compensation on Timestamp Tagged bytes is disabled \n"));
        }

        if(direction == SMAIN_DIRECTION_EGRESS_E &&
           devObjPtr->errata.eplrNotCountCrc)/* CRC not relevant to L3 counting */
        {
            GT_U32  numBytesRemoved;
            GT_U32  diffTo64Bytes;

            __LOG_PARAM(finalByteCount);

            diffTo64Bytes = finalByteCount >= 64 ? (finalByteCount - 64) : 0;

            if(diffTo64Bytes >= 4)
            {
                __LOG(("WARNING : Errata : The EPLR do wrong calc of packet length (not using 4 bytes CRC) \n"));
                numBytesRemoved = 4;
            }
            else
            {
                __LOG(("WARNING : Errata : The EPLR do minimal 64 bytes calc , so remove [%d] bytes from <finalByteCount> (not full 4 bytes of CRC) \n",
                    diffTo64Bytes));

                numBytesRemoved = diffTo64Bytes;
            }

            /* remove the needed bytes */
            finalByteCount -= numBytesRemoved;

            __LOG_PARAM(finalByteCount);
        }
    }

    if(finalByteCount < 64)
    {
        /*POLICER-1382 - The PLR do minimal count of 64 bytes.(regardless to IPLR/EPLR , count mode : L1,L2,L3)*/

        __LOG(("The Policer unit count minimal 64 bytes so modified from [%d]\n",
            finalByteCount));
        finalByteCount = 64;
    }

    if(useGlobalModes)
    {
        /* save this value for it may be needed again by other counter */
        descrPtr->policerCounterGlobalNumBytes = finalByteCount;
    }

    *bytesCountPtr = finalByteCount;
    __LOG(("Final Byte count: [%d] bytes \n",
        *bytesCountPtr));
    return;

}


/**
* @internal reduceCommonDenominator function
* @endinternal
*
* @brief   divide to values by their common denominator.
*/
void reduceCommonDenominator
(
    IN GT_U32  value1,
    IN GT_U32  value2,
    OUT GT_U32  *updatedValue1Ptr,
    OUT GT_U32  *updatedValue2Ptr
)
{
    /* list from http://astrospiker.com/MATHCOACH/primes.html */
    GT_U32  primeNumbersArr[] = {
          2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,  41,
          43,  47,  53,  59,  61,  67,  71,  73,  79,  83,  89,  97, 101,

         103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,
         173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239,

         241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
         317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,

         401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467,
         479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569,

         571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,
         647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733,

         739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823,
         827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,

         919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997,
         SMAIN_NOT_VALID_CNS};
    GT_U32  updatedValue1 = value1;
    GT_U32  updatedValue2 = value2;
    GT_U32  index;
    GT_U32  primeValue;

    for(index = 0 ; primeNumbersArr[index] != SMAIN_NOT_VALID_CNS ; index++)
    {
        primeValue = primeNumbersArr[index];
        if(updatedValue1 < primeValue)
            break;
        if(updatedValue2 < primeValue)
            break;

        if((updatedValue1 % primeValue) == 0 &&
           (updatedValue2 % primeValue) == 0)
        {
            /* both numbers can be divided by this number */
            updatedValue1 /= primeValue;
            updatedValue2 /= primeValue;

            index--;/* make sure to repeat this prim number */
        }
    }

    *updatedValue1Ptr = updatedValue1;
    *updatedValue2Ptr = updatedValue2;

    return;
}

/**
* @internal snetLion3PolicerCalcNumByteAddToToken function
* @endinternal
*
* @brief   Sip5_15 : calculate max tokens that need to be added to buken due to
*         time passed from last packet in this entry
*/
static void snetLion3PolicerCalcNumByteAddToToken
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32  rate,
    IN GT_U32  rate_type,
    OUT GT_U32  *maxTokensToAddPtr
)
{
    GT_CHAR     *timeUnitNames[SKERNEL_TIME_UNITS__LAST__E] = {
        STR(SKERNEL_TIME_UNITS_NOT_VALID_E),
        STR(SKERNEL_TIME_UNITS_MILI_SECONDS_E),
        STR(SKERNEL_TIME_UNITS_MICRO_SECONDS_E),
        STR(SKERNEL_TIME_UNITS_NANO_SECONDS_E),
        STR(SKERNEL_TIME_UNITS_PICO_SECONDS_E)};
    GT_U32  rateFactors[] = /* values in kilo (1000) bits per second */
                            {1,     10,     100,
                             1*1000,10*1000,100*1000};
    GT_U32  timeFactors[] = /* values in 1/x milliSeconds */
                             {  1/*N/A*/,       1,       1000/*micro*/,
                             1000*1000/*nano*/, 1000*1000*1000};
    GT_U32 timeFactor;
    GT_U32 bytesRateFactor;/* /8 from rateFactors[] */
    GT_U32 updatedTimeFactor;
    GT_U32 updatedRateFactor;
    GT_U32 bytesToAddToken;
    GT_U32 timeBetweenPackets;
    GT_U32 rateFactor;
    GT_U32 tmpValue;


    if(skernelUserDebugInfo.enhancedPolicerIfgTime.timeUnit == SKERNEL_TIME_UNITS_NOT_VALID_E)
    {
        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("SIMULATION : support of filling of Tokens is disabled \n"));
        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("if needed see simulation API : skernelPolicerInterFramGapInfoSet(...) \n"));

        *maxTokensToAddPtr = 0;

        return;
    }

    timeBetweenPackets = skernelUserDebugInfo.enhancedPolicerIfgTime.timeBetweenPackets;

    __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("time from the last packet in units of [%s] and value[%d] \n",
        timeUnitNames[skernelUserDebugInfo.enhancedPolicerIfgTime.timeUnit],
        timeBetweenPackets));

    rateFactor = rateFactors[rate_type];
    __LOG_PARAM_NO_LOCATION_META_DATA(rateFactor);

    timeFactor = timeFactors[skernelUserDebugInfo.enhancedPolicerIfgTime.timeUnit];
    __LOG_PARAM_NO_LOCATION_META_DATA(timeFactor);

    bytesRateFactor = (1000/*from Kbits*/ * rateFactor) / 8;
    __LOG_PARAM_NO_LOCATION_META_DATA(bytesRateFactor);

    reduceCommonDenominator(bytesRateFactor,timeFactor ,
            &updatedRateFactor,&updatedTimeFactor);
    __LOG_PARAM_NO_LOCATION_META_DATA(updatedRateFactor);

    /* 'max bytes' = (rate * factor) * (time * timeUnit) */
    /* (rate * factor) in units of 'Kbps' */
    /* (time * timeUnit) in units of 'milliSec' */
    tmpValue = (rate * updatedRateFactor)/(updatedTimeFactor);
    bytesToAddToken = (tmpValue * timeBetweenPackets) / 1000/*from millisec */;

    __LOG_PARAM_NO_LOCATION_META_DATA(bytesToAddToken);

    *maxTokensToAddPtr = bytesToAddToken;

    return;
}


/* sip5_15 : SrTCM decision for conformance level */
#define SIP5_15_SR_TCM_CONF_LEVEL_GET(initialDp,bTb0SignPos,bTb1SignPos)                     \
  (bTb0SignPos && (initialDp == SKERNEL_CONFORM_GREEN))         ? SKERNEL_CONFORM_GREEN :    \
  (bTb1SignPos && ((initialDp == SKERNEL_CONFORM_GREEN) ||                                   \
                   (initialDp == SKERNEL_CONFORM_YELLOW)))      ? SKERNEL_CONFORM_YELLOW :   \
                                                                  SKERNEL_CONFORM_RED

/* sip5_15 : TrTCM decision for conformance level */
#define SIP5_15_TR_TCM_CONF_LEVEL_GET(initialDp,bTb0SignPos,bTb1SignPos)                     \
  ((bTb1SignPos==0) || (initialDp == SKERNEL_CONFORM_RED))      ? SKERNEL_CONFORM_RED :      \
  ((bTb0SignPos==0) || (initialDp == SKERNEL_CONFORM_YELLOW))   ? SKERNEL_CONFORM_YELLOW :   \
                                                                  SKERNEL_CONFORM_GREEN

/* calc sign of bit in table 'Metering Conformance Level Sign Memory' (without byte count considerations)*/
#define SIP_5_15_CONF_SIGN_CALC(bucket_size,mru)  \
        ((bucket_size > mru) ? 1 : 0)

/* calc sign of bit in table 'Metering Conformance Level Sign Memory' , with byte count considerations */
#define SIP_5_15_CONF_SIGN_CALC_WITH_BYTE_COUNT(bucket_size,mru,byteCount)  \
        ((bucket_size > byteCount && bucket_size > mru) ? 1 : 0)


/**
* @internal sip5_15_srTcm_calcUpdatedTokenBucket function
* @endinternal
*
* @brief   Sip5_15 : SrTCM : calculate updated values for token buckets 0,1.
*/
static void sip5_15_srTcm_calcUpdatedTokenBucket(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_CONFORMANCE_LEVEL_ENT conformanceLevel,
    IN GT_U32                       meteredValue,
    IN GT_U32                       max_burst_size0,
    IN GT_U32                       max_burst_size1,
    IN GT_U32                       bucket_size0,
    IN GT_U32                       bucket_size1,
    IN GT_U32                       rate0,
    IN GT_U32                       rate1,
    IN GT_U32                       rate_type0,
    IN GT_U32                       rate_type1,
    OUT GT_U32                       *finalBucketSize0Ptr,
    OUT GT_U32                       *finalBucketSize1Ptr
)
{
    GT_U32 maxTokensToAdd0,maxTokensToAdd1;

    __LOG_NO_LOCATION_META_DATA(("SrTcm calculation \n"));

    __LOG_NO_LOCATION_META_DATA(("calc max Tokens To Add bucket 0 \n"));
    snetLion3PolicerCalcNumByteAddToToken(devObjPtr,rate0,rate_type0,&maxTokensToAdd0);

    __LOG_PARAM_NO_LOCATION_META_DATA(maxTokensToAdd0);

    if (max_burst_size0 < (bucket_size0 + maxTokensToAdd0))
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 0 , till it's max value (and not possible[%d] tokens) \n",
            max_burst_size0 - bucket_size0 , maxTokensToAdd0));

        bucket_size0 = max_burst_size0;

        __LOG_NO_LOCATION_META_DATA(("max Tokens To Add bucket 1 derive from this of bucket 0 \n"));

        maxTokensToAdd1 = maxTokensToAdd0 - (max_burst_size0 - bucket_size0);
        __LOG_PARAM_NO_LOCATION_META_DATA(maxTokensToAdd1);

        if((max_burst_size0 - bucket_size0) > maxTokensToAdd0)
        {
            /* we are getting 'negative' value ?! */
            skernelFatalError("sip5_15_srTcm_calcUpdatedTokenBucket : max Tokens To Add bucket 1 calculated with negative value [%d] ! \n",
                maxTokensToAdd1);
        }

        if (max_burst_size1 < (bucket_size1 + maxTokensToAdd1))
        {
            __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 1 , till it's max value (and not possible[%d] tokens) \n",
                max_burst_size1 - bucket_size1 , maxTokensToAdd1));

            bucket_size1 = max_burst_size1;
        }
        else
        {
            __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 1 \n",
                maxTokensToAdd1));
            bucket_size1 += maxTokensToAdd1;
        }
    }
    else
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 0 only \n",
            maxTokensToAdd0));
        bucket_size0 += maxTokensToAdd0;
    }

    __LOG_PARAM_NO_LOCATION_META_DATA(bucket_size0);
    __LOG_PARAM_NO_LOCATION_META_DATA(bucket_size1);

    if (conformanceLevel == SKERNEL_CONFORM_GREEN)
    {
        __LOG_NO_LOCATION_META_DATA(("For Green conformance : reduce from token bucket 0 the meter byte/packet count (until reach 0) \n"));
        *finalBucketSize0Ptr = (bucket_size0 > meteredValue) ? bucket_size0 - meteredValue : 0;
        __LOG_NO_LOCATION_META_DATA(("For Green conformance : do not update token bucket 1 (keep previous values) \n"));
        *finalBucketSize1Ptr = bucket_size1;
    }
    else if (conformanceLevel == SKERNEL_CONFORM_YELLOW)
    {
        __LOG_NO_LOCATION_META_DATA(("For Yellow conformance : do not update token bucket 0 (keep previous values) \n"));
        *finalBucketSize0Ptr = bucket_size0;
        __LOG_NO_LOCATION_META_DATA(("For Yellow conformance : reduce from token bucket 1 the meter byte/packet count (until reach 0) \n"));
        *finalBucketSize1Ptr = (bucket_size1 > meteredValue) ? bucket_size1 - meteredValue : 0;
    }
    else /* SKERNEL_CONFORM_RED */
    {
        __LOG_NO_LOCATION_META_DATA(("For Red conformance : do not update token bucket 0 (keep previous values) \n"));
        __LOG_NO_LOCATION_META_DATA(("For Red conformance : do not update token bucket 1 (keep previous values) \n"));
        *finalBucketSize0Ptr = bucket_size0;
        *finalBucketSize1Ptr = bucket_size1;
    }
}

/**
* @internal sip5_15_trTcm_calcUpdatedTokenBucket function
* @endinternal
*
* @brief   Sip5_15 : TrTCM : calculate updated values for token buckets 0,1.
*/
static void sip5_15_trTcm_calcUpdatedTokenBucket(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_CONFORMANCE_LEVEL_ENT conformanceLevel,
    IN GT_U32                       meteredValue,
    IN GT_U32                       max_burst_size0,
    IN GT_U32                       max_burst_size1,
    IN GT_U32                       bucket_size0,
    IN GT_U32                       bucket_size1,
    IN GT_U32                       rate0,
    IN GT_U32                       rate1,
    IN GT_U32                       rate_type0,
    IN GT_U32                       rate_type1,
    OUT GT_U32                       *finalBucketSize0Ptr,
    OUT GT_U32                       *finalBucketSize1Ptr
)
{
    GT_U32 maxTokensToAdd0,maxTokensToAdd1;

    __LOG_NO_LOCATION_META_DATA(("TrTcm calculation \n"));

    __LOG_NO_LOCATION_META_DATA(("calc max Tokens To Add bucket 0 \n"));
    snetLion3PolicerCalcNumByteAddToToken(devObjPtr,rate0,rate_type0,&maxTokensToAdd0);

    __LOG_NO_LOCATION_META_DATA(("calc max Tokens To Add bucket 1 \n"));
    snetLion3PolicerCalcNumByteAddToToken(devObjPtr,rate1,rate_type1,&maxTokensToAdd1);

    __LOG_PARAM_NO_LOCATION_META_DATA(maxTokensToAdd0);
    __LOG_PARAM_NO_LOCATION_META_DATA(maxTokensToAdd1);

    if (max_burst_size0 < (bucket_size0 + maxTokensToAdd0))
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 0 , till it's max value (and not possible[%d] tokens) \n",
            max_burst_size0 - bucket_size0 , maxTokensToAdd0));

        bucket_size0 = max_burst_size0;
    }
    else
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 0 \n",
            maxTokensToAdd0));
        bucket_size0 += maxTokensToAdd0;
    }

    if (max_burst_size1 < (bucket_size1 + maxTokensToAdd1))
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 1 , till it's max value (and not possible[%d] tokens) \n",
            max_burst_size1 - bucket_size1 , maxTokensToAdd1));

        bucket_size1 = max_burst_size1;
    }
    else
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 1 \n",
            maxTokensToAdd1));
        bucket_size1 = bucket_size1 + maxTokensToAdd1;
    }

    __LOG_PARAM_NO_LOCATION_META_DATA(bucket_size0);
    __LOG_PARAM_NO_LOCATION_META_DATA(bucket_size1);


    if (conformanceLevel == SKERNEL_CONFORM_RED)
    {
        __LOG_NO_LOCATION_META_DATA(("For Red conformance : do not update token bucket 0 (keep previous values) \n"));
        __LOG_NO_LOCATION_META_DATA(("For Red conformance : do not update token bucket 1 (keep previous values) \n"));
        *finalBucketSize0Ptr = bucket_size0;
        *finalBucketSize1Ptr = bucket_size1;
    }
    else if (conformanceLevel == SKERNEL_CONFORM_YELLOW)
    {
        __LOG_NO_LOCATION_META_DATA(("For Yellow conformance : do not update token bucket 0 (keep previous values) \n"));
        *finalBucketSize0Ptr = bucket_size0;
        __LOG_NO_LOCATION_META_DATA(("For Yellow conformance : reduce from token bucket 1 the meter byte/packet count (until reach 0) \n"));
        *finalBucketSize1Ptr = (bucket_size1 > meteredValue) ? bucket_size1 - meteredValue : 0;
    }
    else /*SKERNEL_CONFORM_GREEN*/
    {
        __LOG_NO_LOCATION_META_DATA(("For Green conformance : reduce from token bucket 0 the meter byte/packet count (until reach 0) \n"));
        __LOG_NO_LOCATION_META_DATA(("For Green conformance : reduce from token bucket 1 the meter byte/packet count (until reach 0) \n"));
        *finalBucketSize0Ptr = (bucket_size0 > meteredValue) ? bucket_size0 - meteredValue : 0;
        *finalBucketSize1Ptr = (bucket_size1 > meteredValue) ? bucket_size1 - meteredValue : 0;
    }
}

/**
* @internal sip5_15_calcUpdatedTokenBucket function
* @endinternal
*
* @brief   Sip5_15 : calculate updated values for token buckets 0,1.
*/
static void sip5_15_calcUpdatedTokenBucket(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SNET_LION3_POLICER_METERING_MODE_ENT  policer_mode,
    IN SKERNEL_CONFORMANCE_LEVEL_ENT conformanceLevel,
    IN GT_U32                       meteredValue,
    IN GT_U32                       max_burst_size0,
    IN GT_U32                       max_burst_size1,
    IN GT_U32                       bucket_size0,
    IN GT_U32                       bucket_size1,
    IN GT_U32                       rate0,
    IN GT_U32                       rate1,
    IN GT_U32                       rate_type0,
    IN GT_U32                       rate_type1,
    IN GT_U32                       policerMru,
    OUT GT_U32                       *finalBucketSize0Ptr,
    OUT GT_U32                       *finalBucketSize1Ptr
)
{
    GT_U32  unified_max_burst_size0;/* convert from rate_type0 and max_burst_size0 */
    GT_U32  unified_max_burst_size1;/* convert from rate_type1 and max_burst_size1 */
    GT_U32  bytesFactor0 , bytesFactor1;

    *finalBucketSize0Ptr = 0;
    *finalBucketSize1Ptr = 0;

    if(SMEM_CHT_IS_SIP6_GET(devObjPtr))
    {
        bytesFactor0 = (rate_type0 == 0) ? 4 : 1 << (3*rate_type0);/*8^rate_type0;*/ /*4,8,64,512,4K,32K */
        bytesFactor1 = (rate_type1 == 0) ? 4 : 1 << (3*rate_type1);/*8^rate_type1;*/ /*4,8,64,512,4K,32K */
    }
    else
    {
        bytesFactor0 = 1 << (3*rate_type0);/*8^rate_type0;*/ /*1,8,64,512,4K,32K */
        bytesFactor1 = 1 << (3*rate_type1);/*8^rate_type1;*/ /*1,8,64,512,4K,32K */
    }

    unified_max_burst_size0 = max_burst_size0 * bytesFactor0;
    unified_max_burst_size1 = max_burst_size1 * bytesFactor1;

    if(SMEM_CHT_IS_SIP6_10_GET(devObjPtr))
    {
        unified_max_burst_size0 += policerMru;
        unified_max_burst_size1 += policerMru;
        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("sip6.10 : the policerMru[%d] is internally added for max burst size. final unified_max_burst_size0[%d]\n",policerMru,unified_max_burst_size0));
        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("sip6.10 : the policerMru[%d] is internally added for max burst size. final unified_max_burst_size1[%d]\n",policerMru,unified_max_burst_size1));
    }
    else
    {
        __LOG_PARAM_NO_LOCATION_META_DATA(unified_max_burst_size0);
        __LOG_PARAM_NO_LOCATION_META_DATA(unified_max_burst_size1);
    }

    switch(policer_mode)
    {
        case SNET_LION3_POLICER_METERING_MODE_SrTCM_E:
        case SNET_LION3_POLICER_METERING_MODE_MEF0_E:
        case SNET_LION3_POLICER_METERING_MODE_MEF1_E:
        case SNET_LION3_POLICER_METERING_MODE_MEF10_3_START_E:
        case SNET_LION3_POLICER_METERING_MODE_MEF10_3_NOT_START_E:
            sip5_15_srTcm_calcUpdatedTokenBucket(devObjPtr,conformanceLevel,meteredValue,
                    unified_max_burst_size0,unified_max_burst_size1,
                    bucket_size0,bucket_size1,
                    rate0,rate1,rate_type0,rate_type1,
                    finalBucketSize0Ptr,finalBucketSize1Ptr);
            break;
        case SNET_LION3_POLICER_METERING_MODE_TrTCM_E:
            sip5_15_trTcm_calcUpdatedTokenBucket(devObjPtr,conformanceLevel,meteredValue,
                    unified_max_burst_size0,unified_max_burst_size1,
                    bucket_size0,bucket_size1,
                    rate0,rate1,rate_type0,rate_type1,
                    finalBucketSize0Ptr,finalBucketSize1Ptr);
            break;
        default:
            __LOG_NO_LOCATION_META_DATA(("ERROR: policer mode [%d] was not implemented \n",
                policer_mode));
            break;
    }

}

/**
* @internal snetLion3PolicerMeterSinglePacketTokenBucketApply function
* @endinternal
*
* @brief   Sip5 : Add logic for meter packet byte count compare and token bucket state.
*         The current state of the bucket is in the "Bucket Size0" and "Bucket Size1" fields.
*         Device updates these field automatically according to "Max Burst Size0" and "Max Burst Size1"
*         The logic is valid with assumption that single packet is used for testing.
*/
GT_VOID snetLion3PolicerMeterSinglePacketTokenBucketApply
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN SNET_LION3_POLICER_METERING_DATA_STC *meteringDataPtr,
    OUT SNET_CHT3_POLICER_QOS_INFO_STC * qosProfileInfoPtr
)
{
    DECLARE_FUNC_NAME(snetLion3PolicerMeterSinglePacketTokenBucketApply);

    GT_U32  entryIndex;
    GT_U32  byte_or_packet_counting_mode;
    GT_U32  bytesCount;
    GT_U32  bucket_size0,bucket_size1;
    GT_U32  rate0,rate1,rate_type0,rate_type1;
    GT_U32  max_burst_size0,max_burst_size1;
    GT_U32  policerMru;
    GT_BIT  conforming0,conforming1;
    GT_BIT  conformingFinally = 1;
    GT_U32  meteredValue;
    SNET_LION3_POLICER_METERING_MODE_ENT  policer_mode;
    GT_CHAR *conformanceNamesArr[3] = {"GREEN","YELLOW","RED"};
    GT_U32 regAddr;                     /* register address */
    GT_BIT doStatisticalMeter;/* sip 5_15 do we work with statistical metering */
    GT_U32  value;
    GT_BIT tokenBucket0MoreThanCount,tokenBucket1MoreThanCount;/* sip 5_15 : is token bucket 0,1 more than meter count for this packet */
    GT_U32  finalBucketSize0,finalBucketSize1;/* the updated value for token buckets 0,1 */
    GT_U32           *meterEntryPtr;

    /* for SIP5_15 buckets entry - not used */
    meterEntryPtr = meteringDataPtr->meterGreenBucketEntryPtr;

    if(qosProfileInfoPtr->initialDp > SKERNEL_CONFORM_RED)
    {
        skernelFatalError("snetXcatPolicerBillingCounterWrite: initialDp[%d] > [%d] \n",
            qosProfileInfoPtr->initialDp,SKERNEL_CONFORM_RED);
        return;
    }

    __LOG(("initialDp is [%s] \n",
        conformanceNamesArr[qosProfileInfoPtr->initialDp]));

    entryIndex = descrPtr->policerActuallAccessedIndex;

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        policer_mode =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                entryIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E);
    }
    else
    {
        policer_mode =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,meterEntryPtr,entryIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_POLICER_MODE);
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        byte_or_packet_counting_mode  =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                entryIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE_E);
    }
    else
    {
        byte_or_packet_counting_mode  =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,meterEntryPtr,entryIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE);
    }

    if(byte_or_packet_counting_mode == 0/*bytes*/)
    {
        /* byte count will be calculated when needed */
        __LOG(("meter mode : working with bits per second \n"));

        __LOG(("Calc num bytes needed for [%s] purpose \n",
            "Metering Token Bucket"));
        snetLion3PolicerPacketSizeGet(devObjPtr, descrPtr,direction,
                                     SNET_LION3_POLICER_PACKET_SIZE_FROM_METER_ENTRY_E,
                                     meterEntryPtr,
                                     &bytesCount);

        meteredValue = bytesCount;
    }
    else
    {
        __LOG(("meter mode : working with packets per second \n"));
        meteredValue = 1;
    }

    regAddr = SMEM_XCAT_POLICER_MRU_REG(devObjPtr,descrPtr->policerCycle);
    smemRegFldGet(devObjPtr, regAddr, 0,
        SMEM_CHT_IS_SIP5_15_GET(devObjPtr) ? 32 : 16 ,
        &policerMru);

    __LOG_PARAM(policerMru);
    __LOG_PARAM(meteredValue);

    /* bucket size0-1 contain amount of allowed bytes                        */
    /* the conversion from max_bucket_size0-1 (using rate0-1 type/resolution */
    /* done at entry writing process                                         */
    bucket_size0  =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterGreenBucketEntryPtr,
            meteringDataPtr->meterGreenBucketEntryIndex,
            ((meteringDataPtr->meterGreenBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1));
    bucket_size1  =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterYellowBucketEntryPtr,
            meteringDataPtr->meterYellowBucketEntryIndex,
            ((meteringDataPtr->meterYellowBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1));

    rate0  =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterGreenBucketEntryPtr,
            meteringDataPtr->meterGreenBucketEntryIndex,
            ((meteringDataPtr->meterGreenBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE1));
    rate1  =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterYellowBucketEntryPtr,
            meteringDataPtr->meterYellowBucketEntryIndex,
            ((meteringDataPtr->meterYellowBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE1));

     rate_type0 =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterGreenBucketEntryPtr,
            meteringDataPtr->meterGreenBucketEntryIndex,
            ((meteringDataPtr->meterGreenBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE1));
     rate_type1 =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterYellowBucketEntryPtr,
            meteringDataPtr->meterYellowBucketEntryIndex,
            ((meteringDataPtr->meterYellowBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE1));

     max_burst_size0 =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterGreenBucketEntryPtr,
            meteringDataPtr->meterGreenBucketEntryIndex,
            ((meteringDataPtr->meterGreenBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE1));
     max_burst_size1 =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterYellowBucketEntryPtr,
            meteringDataPtr->meterYellowBucketEntryIndex,
            ((meteringDataPtr->meterYellowBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE1));

    __LOG_PARAM(bucket_size0);
    __LOG_PARAM(bucket_size1);

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        regAddr = SMEM_SIP5_15_POLICER_STATISTICAL_METERING_CONFIG_0_REG(devObjPtr,descrPtr->policerCycle);

        /*<Statistical_Metering_Disable>*/
        smemRegFldGet(devObjPtr, regAddr, 0 ,1 ,&value);

        doStatisticalMeter = value ? 0 : 1;

        if(doStatisticalMeter)
        {
            __LOG(("Working in statistical meter mode \n"));
            __LOG(("NOTE: 'current' conformance level is not depend on current packet count bytes/packet !!! \n"));
            __LOG(("      this is different than legacy devices \n"));

            /* 'current' conformance level is not depend on current
                packet count bytes/packet !!! */

            __LOG(("get the conformance level sign from the values restored in the memory (ignore bucket size and MRU !!!) \n"));
            tokenBucket0MoreThanCount = snetFieldValueGet(descrPtr->policerConformanceLevelSignEntryMemoryPtr, 0 ,1);
            tokenBucket1MoreThanCount = snetFieldValueGet(descrPtr->policerConformanceLevelSignEntryMemoryPtr, 1 ,1);

            __LOG(("Read Metering Conformance Level Sign Table cycle[%d] index[%d] more0[%d] more1[%d]\n",
                   descrPtr->policerCycle, descrPtr->policerActuallAccessedIndex,
                   tokenBucket0MoreThanCount, tokenBucket1MoreThanCount));
        }
        else
        {
            __LOG(("Working in non statistical meter mode (BWC mode) \n"));

            __LOG(("calculate the conformance level sign according to current bucket size and MRU \n"));
            /* we need to take into account this packet count bytes/packet for
               'current' conformance level */
            tokenBucket0MoreThanCount = SIP_5_15_CONF_SIGN_CALC_WITH_BYTE_COUNT(bucket_size0,policerMru,meteredValue);
            tokenBucket1MoreThanCount = SIP_5_15_CONF_SIGN_CALC_WITH_BYTE_COUNT(bucket_size1,policerMru,meteredValue);
            __LOG_PARAM(tokenBucket0MoreThanCount);
            __LOG_PARAM(tokenBucket1MoreThanCount);
        }


        switch(policer_mode)
        {
            case SNET_LION3_POLICER_METERING_MODE_SrTCM_E:
            case SNET_LION3_POLICER_METERING_MODE_MEF0_E:
            case SNET_LION3_POLICER_METERING_MODE_MEF1_E:
            case SNET_LION3_POLICER_METERING_MODE_MEF10_3_START_E:
            case SNET_LION3_POLICER_METERING_MODE_MEF10_3_NOT_START_E:
                qosProfileInfoPtr->cl =
                    SIP5_15_SR_TCM_CONF_LEVEL_GET(qosProfileInfoPtr->initialDp,
                                                    tokenBucket0MoreThanCount,
                                                    tokenBucket1MoreThanCount);
                break;
            case SNET_LION3_POLICER_METERING_MODE_TrTCM_E:
                qosProfileInfoPtr->cl =
                    SIP5_15_TR_TCM_CONF_LEVEL_GET(qosProfileInfoPtr->initialDp,
                                                    tokenBucket0MoreThanCount,
                                                    tokenBucket1MoreThanCount);
                break;
            default:
                qosProfileInfoPtr->cl = qosProfileInfoPtr->initialDp;
                __LOG(("ERROR: policer mode [%d] was not implemented \n",
                    policer_mode));
                break;
        }

        __LOG_PARAM(qosProfileInfoPtr->cl);
        __LOG(("Final Meter conformance level is [%s] \n",
            conformanceNamesArr[qosProfileInfoPtr->cl]));

        __LOG(("Calculate the needed update for the token buckets \n"));

        SCIB_SEM_TAKE;/* 'lock' for LOG purpose */

        sip5_15_calcUpdatedTokenBucket(devObjPtr,policer_mode,
            qosProfileInfoPtr->cl,meteredValue,
            max_burst_size0,max_burst_size1,
            bucket_size0,bucket_size1,
            rate0,rate1,rate_type0,rate_type1,
            policerMru,
            &finalBucketSize0,&finalBucketSize1);

        SCIB_SEM_SIGNAL;

        __LOG_PARAM(finalBucketSize0);
        __LOG_PARAM(finalBucketSize1);

        __LOG(("Update the meter entry with the new token buckets \n"));

        SMEM_LION3_PLR_METERING_ENTRY_FIELD_SET(
            devObjPtr,
            meteringDataPtr->meterGreenBucketEntryPtr,
            meteringDataPtr->meterGreenBucketEntryIndex,
            ((meteringDataPtr->meterGreenBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1),
            finalBucketSize0);

        SMEM_LION3_PLR_METERING_ENTRY_FIELD_SET(
            devObjPtr,
            meteringDataPtr->meterYellowBucketEntryPtr,
            meteringDataPtr->meterYellowBucketEntryIndex,
            ((meteringDataPtr->meterYellowBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1),
            finalBucketSize1);

        __LOG(("calculate updated values for entry of 'Metering Conformance Level Sign Memory' \n"));
        __LOG(("NOTE: 'Metering Conformance Level Sign Memory' token bucket compared to MRU only without current byte count \n"));
        tokenBucket0MoreThanCount = SIP_5_15_CONF_SIGN_CALC(finalBucketSize0,policerMru);
        tokenBucket1MoreThanCount = SIP_5_15_CONF_SIGN_CALC(finalBucketSize1,policerMru);

        snetFieldValueSet(descrPtr->policerConformanceLevelSignEntryMemoryPtr, 0 ,1 , tokenBucket0MoreThanCount);
        snetFieldValueSet(descrPtr->policerConformanceLevelSignEntryMemoryPtr, 1 ,1 , tokenBucket1MoreThanCount);

        __LOG(("Update Metering Conformance Level Sign Table cycle[%d] index[%d] more0[%d] more1[%d] addr[0x%X]\n",
               descrPtr->policerCycle, descrPtr->policerActuallAccessedIndex,
               tokenBucket0MoreThanCount, tokenBucket1MoreThanCount,
               descrPtr->policerConformanceLevelSignEntryMemoryPtr));

        return;
    }

    /*When the number of tokens in the bucket is less than or equal this value, a packet is marked as non-conforming.*/
    if(meteredValue >= bucket_size0)
    {
        /* to avoid (bucket_size0 - meteredValue) with negative value */
        conforming0 = 0;
    }
    else
    if(bucket_size0 > policerMru)
    {
        conforming0 = 1;
    }
    else
    {
        conforming0 = 0;
    }

    /*When the number of tokens in the bucket is less than  or equal this value, a packet is marked as non-conforming.*/
    if(meteredValue >= bucket_size1)
    {
        /* to avoid (bucket_size1 - meteredValue) with negative value */
        conforming1 = 0;
    }
    else
    if(bucket_size1 > policerMru)
    {
        conforming1 = 1;
    }
    else
    {
        conforming1 = 0;
    }

    __LOG_PARAM(conforming0);
    __LOG_PARAM(conforming1);

    /* implement the 'color blind' and the 'color aware' as single logic as the
       qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN for the 'color blind' */

    qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;/* init for compiler only */
    switch(policer_mode)
    {
        case SNET_LION3_POLICER_METERING_MODE_SrTCM_E:
            __LOG(("metering mode : SrTCM \n"));
modeSrTCM_lbl:
            /* implement the 'color blind' and the 'color aware' as single logic as the
               qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN for the 'color blind' */

            /*TB (CIR, CBS) confirming AND initial color = Green?*/
            if(conforming0 &&
               qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN)
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;
            }
            else
            /*TB (CIR, EBS) confirming AND initial color = Green/Yellow?*/
            if(conforming1  &&
               qosProfileInfoPtr->initialDp != SKERNEL_CONFORM_RED)
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_YELLOW;
            }
            else
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_RED;
            }

            conformingFinally = 1;

            break;
        case SNET_LION3_POLICER_METERING_MODE_TrTCM_E:
            __LOG(("metering mode : TrTCM \n"));

            /*TB (PIR, PBS) confirming AND initial color = GREEN/YELLOW?*/
            if(conforming1 &&
               qosProfileInfoPtr->initialDp != SKERNEL_CONFORM_RED)
            {
                /*TB (CIR, CBS) confirming AND initial color = GREEN?*/
                if(conforming0 &&
                   qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN)
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;
                }
                else
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_YELLOW;
                }
            }
            else
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_RED;
            }

            conformingFinally = 0;

            break;
        case SNET_LION3_POLICER_METERING_MODE_MEF0_E:
            __LOG(("metering mode : MEF0 \n"));
modeMEF0_lbl:
            __LOG(("for simulation this is like SrTCM mode ! \n"));
            goto modeSrTCM_lbl;
        default:
            __LOG(("metering mode : MEF1 \n"));
            __LOG(("for simulation this is like MEF0 mode ! \n"));
            goto modeMEF0_lbl;
    }

    __LOG(("Final Meter conformance level is [%s] \n",
        conformanceNamesArr[qosProfileInfoPtr->cl]));

    /* update leaky buckets */
    if (conforming0 != 0 && (qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN))
    {
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_SET(
            devObjPtr,meterEntryPtr,entryIndex,
            SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0,
            (bucket_size0 - meteredValue));
    }

    if ((conforming0 != conformingFinally) && (conforming1 != 0) &&
        (qosProfileInfoPtr->initialDp != SKERNEL_CONFORM_RED))
    {
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_SET(
            devObjPtr,meterEntryPtr,entryIndex,
            SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1,
            (bucket_size1 - meteredValue));
    }

    return;
}

/**
* @internal snetXcatPolicerIpfixWaCheck function
* @endinternal
*
* @brief   32 bits counters wraparound indications and action
*
* @param[in] devObjPtr                - pointer to device object
* @param[in] descrPtr                 - pointer to frame descriptor
* @param[in] counterType              - IPFIX counter type
* @param[in] pcktsPtr                 - pointer to 32 bit counter value
* @param[in] treshold                 - 32 bit  value
* @param[in] action                   - wrap around action: clear counter or no action
*
* @param[out] triggerPtr               - pointer wrap around trigger
*                                      RETURN:
*/
static GT_VOID snetXcatPolicerIpfixWaCheck
(
    SKERNEL_DEVICE_OBJECT * devObjPtr,
    SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    SNET_XCAT_POLICER_IPFIX_COUNT_E counterType,
    GT_U32 * pcktsPtr,
    GT_U32 treshold,
    GT_U32 action,
    GT_BOOL * triggerPtr
)
{
    DECLARE_FUNC_NAME(snetXcatPolicerIpfixWaCheck);

    if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
    {
        /* Save unchanged packets counter for use in workaround of erratum */
        __LOG(("Save unchanged packets counter for use in workaround of erratum"));
        descrPtr->ipfixErrataData.prevPckts[counterType] = *pcktsPtr;
    }

    /* Check treshold */
    __LOG(("Check treshold"));
    if(treshold)
    {
        /* Increment counter */
        *pcktsPtr += 1;

        if(*pcktsPtr >= treshold) {
           if(action) {
               /* Counter wraps around back to zero, and continues to be updated */
               __LOG(("Counter wraps around back to zero, and continues to be updated"));
               *pcktsPtr %= treshold;
           } else {
               /* Freeze the counter at the threshold value */
               __LOG(("Freeze the counter at the threshold value"));
               *pcktsPtr = treshold;

               if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
               {
                   descrPtr->ipfixErrataData.freezeCounter = counterType;
               }
           }

           *triggerPtr = GT_TRUE;
        }
    }
    else /* treshhold == 0 */
    {
        __LOG(("treshold set to zero! counters will not be incremented"));
    }
}

/**
* @internal snetXcatPolicerIpfixWa64Check function
* @endinternal
*
* @brief   64 bits counters wraparound indications and action
*
* @param[in] devObjPtr                - pointer to device object
* @param[in] descrPtr                 - pointer to frame descriptor
* @param[in] counterType              - IPFIX counter type
* @param[in] bytes                    - increment value in bytes
* @param[in] bytes                    - increment value in bytes
* @param[in] tresholdPtr              - pointer to 64 bit treshold value
* @param[in] action                   - wrap around action: clear counter or no action
*
* @param[out] triggerPtr               - pointer wrap around trigger
*                                      RETURN:
*/
static GT_VOID snetXcatPolicerIpfixWa64Check
(
    SKERNEL_DEVICE_OBJECT * devObjPtr,
    SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    SNET_XCAT_POLICER_IPFIX_COUNT_E counterType,
    GT_U64 * bytesPtr,
    GT_U32 bytes,
    GT_U64 * tresholdPtr,
    GT_U32 action,
    GT_BOOL * triggerPtr
)
{
    DECLARE_FUNC_NAME(snetXcatPolicerIpfixWa64Check);

    GT_U64 bytes64;

    if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
    {
        /* Save unchanged bytes counter for use in workaround of erratum */
        __LOG(("Save unchanged bytes counter for use in workaround of erratum"));
        descrPtr->ipfixErrataData.prevBytesCnt = *bytesPtr;
    }

    CNV_U32_TO_U64(bytes, bytes64);
    /* Increment counter */
    *bytesPtr = prvSimMathAdd64(*bytesPtr, bytes64);

    /* Check treshold */
    if(tresholdPtr->l[0] || tresholdPtr->l[1]) {
        if(COMPARE_TWO_U64_VALUES_MAC(*bytesPtr, *tresholdPtr) >= 0) {
            if(action) {
                /* Low word less than subtracted one */
                __LOG(("Low word less than subtracted one"));
                if(bytesPtr->l[0] < tresholdPtr->l[0])
                {
                    /* Borrow 1 from Hi word */
                    bytesPtr->l[1] -= 1;
                    /* Subtract 1 from Lo word before inversion */
                    bytesPtr->l[0] -= 1;
                }
                bytesPtr->l[0] -= tresholdPtr->l[0];
                bytesPtr->l[1] -= tresholdPtr->l[1];

            }
            else {
                bytesPtr->l[0] = tresholdPtr->l[0];
                bytesPtr->l[1] = tresholdPtr->l[1];

                if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
                {
                    descrPtr->ipfixErrataData.freezeCounter = counterType;
                }
            }

            *triggerPtr = GT_TRUE;
        }
    }
}

/**
* @internal snetXcatPolicerIsIpfix function
* @endinternal
*
* @brief   Function checks if IPFIX should be performed or not
*/
GT_BOOL snetXcatPolicerIsIpfix
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    GT_U32                    regAddr;                /* Register address */
    GT_U32                  * regPtr;               /* Register pointer */
    GT_BOOL                   dropPktCnt;
    GT_U32                    enableBillingStatus;
    GT_BOOL                   ipfixEnPktCmd;
    GT_BOOL                   isIpfix;

    regAddr    = SMEM_XCAT_POLICER_IPFIX_CTRL_REG(devObjPtr, descrPtr->policerCycle);
    regPtr     = smemMemGet(devObjPtr, regAddr);
    dropPktCnt = SNET_XCAT_POLICER_IPFIX_DROP_COUNT_EN_GET_MAC(regPtr);

    regAddr  = SMEM_XCAT_POLICER_GLB1_CONF_REG(devObjPtr,descrPtr->policerCycle);
    smemRegFldGet(devObjPtr, regAddr, 5, 1, &enableBillingStatus);

    ipfixEnPktCmd = ((descrPtr->packetCmd  == SKERNEL_EXT_PKT_CMD_FORWARD_E)       ||
                     (descrPtr->packetCmd  == SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E) ||
                     ((descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E)   &&
                      (enableBillingStatus))                                       ||
                     (((descrPtr->packetCmd  == SKERNEL_EXT_PKT_CMD_HARD_DROP_E)   ||
                      (descrPtr->packetCmd  == SKERNEL_EXT_PKT_CMD_SOFT_DROP_E))   &&
                      (dropPktCnt)));

    isIpfix = ipfixEnPktCmd ? GT_TRUE : GT_FALSE;

    return isIpfix;
}

/**
* @internal snetXcatPolicerIpfixSip6_10SampleValuesGet function
* @endinternal
*
* @brief   Get IPFIX sample value for sip6_10 devices when sample mode is disable
*
* @param[in] entryPtr                 - pointer to IPFix entry
* @param[in,out] dataPtr                  - pointer to policer IPFix sampling related info
* @param[in,out] dataPtr                  - pointer to policer IPFix sampling related info
*                                      RETURN:
*/
static void snetXcatPolicerIpfixSip6_10SampleValuesGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * entryPtr,
    INOUT SNET_XCAT_SIP6_10_POLICER_IPFIX_SAMPLE_STC * dataPtr
)
{
    dataPtr->firstPacketsCounter =
        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_PACKETS_COUNTER_E);
    dataPtr->numberOfFirstPacketsToMirror =
        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_NUMBER_OF_FIRST_PACKETS_TO_MIRROR_E);
    dataPtr->phaMetadataMode =
        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_PHA_METADATA_MODE_E);
    dataPtr->firstTimestampValid =
        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_TIMESTAMP_VALID_E);
    dataPtr->firstTimestamp =
        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_TIMESTAMP_E);
    dataPtr->lastPacketCommand =
        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_LAST_PACKET_COMMAND_E);
    dataPtr->lastCpuOrDropCode =
        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_LAST_CPU_OR_DROP_CODE_E);
}

/**
* @internal snetXcatPolicerIpfixSampleValuesGet function
* @endinternal
*
* @brief   Get IPFIX sample value
*
* @param[in] entryPtr                 - pointer to IPFix entry
* @param[in,out] dataPtr                  - pointer to policer IPFix sampling related info
* @param[in,out] dataPtr                  - pointer to policer IPFix sampling related info
*                                      RETURN:
*/
static void snetXcatPolicerIpfixSampleValuesGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * entryPtr,
    INOUT SNET_XCAT_POLICER_IPFIX_SAMPLE_STC * dataPtr
)
{
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        dataPtr->randomEnable =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_FLAG_E);

        dataPtr->sampleRange =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LOG_SAMPLING_RANGE_E);

        dataPtr->sampleAction =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_ACTION_E);

        dataPtr->cpuSubCode =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_CPU_SUB_CODE_E);

        SMEM_LION3_PLR_IPFIX_ENTRY_LARGE_FIELD_GET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_WINDOW_E,
                    &dataPtr->sampleWindow64.l[0]);

        SMEM_LION3_PLR_IPFIX_ENTRY_LARGE_FIELD_GET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LAST_SAMPLED_VALUE_E,
                    &dataPtr->lastSampleValue64.l[0]);

        dataPtr->randomOffset =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_OFFSET_E);

    }
    else
    {
        dataPtr->randomEnable =
            SMEM_U32_GET_FIELD(entryPtr[2], 20, 1);
        dataPtr->sampleRange =
            SMEM_U32_GET_FIELD(entryPtr[2], 21, 6);
        dataPtr->sampleAction =
            SMEM_U32_GET_FIELD(entryPtr[2], 27, 1);
        dataPtr->cpuSubCode =
            SMEM_U32_GET_FIELD(entryPtr[2], 28, 2);
        dataPtr->sampleWindow64.l[0] =
            SMEM_U32_GET_FIELD(entryPtr[2], 30, 2) |
            SMEM_U32_GET_FIELD(entryPtr[3], 0, 30) << 2;
        dataPtr->sampleWindow64.l[1] =
            SMEM_U32_GET_FIELD(entryPtr[3], 30, 2) |
            SMEM_U32_GET_FIELD(entryPtr[4], 0, 2) << 2;
        dataPtr->lastSampleValue64.l[0] =
            SMEM_U32_GET_FIELD(entryPtr[4], 2, 30) |
            SMEM_U32_GET_FIELD(entryPtr[5], 0, 2) << 30;
        dataPtr->lastSampleValue64.l[1] =
            SMEM_U32_GET_FIELD(entryPtr[5], 2, 4);
        dataPtr->randomOffset =
            SMEM_U32_GET_FIELD(entryPtr[5], 6, 26) |
            SMEM_U32_GET_FIELD(entryPtr[6], 0, 6) << 26;
    }
}

/**
* @internal snetXcatPolicerIpfixSip6_10SampleValuesSet function
* @endinternal
*
* @brief   Set IPFix sampling data for sip6_10 when sampling mode is disable
*
* @param[in] entryPtr                 - pointer to IPFix entry
*
* @param[out] dataPtr                  - pointer to policer IPFix sampling related info
*                                      RETURN:
*/
static void snetXcatPolicerIpfixSip6_10SampleValuesSet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * entryPtr,
    OUT SNET_XCAT_SIP6_10_POLICER_IPFIX_SAMPLE_STC * dataPtr
)
{
    SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,entryPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_PACKETS_COUNTER_E,
                dataPtr->firstPacketsCounter);

    SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,entryPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_NUMBER_OF_FIRST_PACKETS_TO_MIRROR_E,
                dataPtr->numberOfFirstPacketsToMirror);

    SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,entryPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_PHA_METADATA_MODE_E,
                dataPtr->phaMetadataMode);

    SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,entryPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_TIMESTAMP_VALID_E,
                dataPtr->firstTimestampValid);

    SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,entryPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_TIMESTAMP_E,
                dataPtr->firstTimestamp);

    SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,entryPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_LAST_PACKET_COMMAND_E,
                dataPtr->lastPacketCommand);

    SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,entryPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_LAST_CPU_OR_DROP_CODE_E,
                dataPtr->lastCpuOrDropCode);
}

/**
* @internal snetXcatPolicerIpfixSampleValuesSet function
* @endinternal
*
* @brief   Set IPFix sampling data
*
* @param[in] entryPtr                 - pointer to IPFix entry
*
* @param[out] dataPtr                  - pointer to policer IPFix sampling related info
*                                      RETURN:
*/
static void snetXcatPolicerIpfixSampleValuesSet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * entryPtr,
    OUT SNET_XCAT_POLICER_IPFIX_SAMPLE_STC * dataPtr
)
{
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* only next field may actually changed */
        SMEM_LION3_PLR_IPFIX_ENTRY_LARGE_FIELD_SET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LAST_SAMPLED_VALUE_E,
                    &dataPtr->lastSampleValue64.l[0]);

        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_OFFSET_E,
                    dataPtr->randomOffset);
    }
    else
    {
        SMEM_U32_SET_FIELD(entryPtr[2], 20, 1, dataPtr->randomEnable);
        SMEM_U32_SET_FIELD(entryPtr[2], 21, 6, dataPtr->sampleRange);
        SMEM_U32_SET_FIELD(entryPtr[2], 27, 1, dataPtr->sampleAction);
        SMEM_U32_SET_FIELD(entryPtr[2], 28, 2, dataPtr->cpuSubCode);
        SMEM_U32_SET_FIELD(entryPtr[2], 30, 2, dataPtr->sampleWindow64.l[0] & 0x3);
        SMEM_U32_SET_FIELD(entryPtr[3], 0, 30, dataPtr->sampleWindow64.l[0] >> 2);
        SMEM_U32_SET_FIELD(entryPtr[3], 30, 2, dataPtr->sampleWindow64.l[1] & 0x3);
        SMEM_U32_SET_FIELD(entryPtr[4], 0, 2,  dataPtr->sampleWindow64.l[1] >> 2);
        SMEM_U32_SET_FIELD(entryPtr[4], 2, 30, dataPtr->lastSampleValue64.l[0]);
        SMEM_U32_SET_FIELD(entryPtr[5], 0, 2,  dataPtr->lastSampleValue64.l[0] >> 30);
        SMEM_U32_SET_FIELD(entryPtr[5], 2, 4,  dataPtr->lastSampleValue64.l[1]);
        SMEM_U32_SET_FIELD(entryPtr[5], 6, 26, dataPtr->randomOffset);
        SMEM_U32_SET_FIELD(entryPtr[6], 0, 6,  dataPtr->randomOffset >> 26);
    }
}

/**
* @internal snetXcatPolicerBillingCounterWrite function
* @endinternal
*
* @brief   Set packets/data units billing counter value
*
* @param[in] entryPtr                 - pointer to policer billing counter entry
* @param[in] dp                       - the packet's DP 0..2
* @param[in] dataPtr                  - pointer to 64 bits increment
*/
static void snetXcatPolicerBillingCounterWrite
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * entryPtr,
    IN GT_U32   dp,
    IN GT_U64 * dataPtr
)
{
    GT_U32 startBit;

    if(dp > 2)
    {
        skernelFatalError("snetXcatPolicerBillingCounterWrite: dp[%d] > 2 \n",
            dp);
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        SMEM_LION3_PLR_BILLING_ENTRY_LARGE_FIELD_SET(devObjPtr,entryPtr,
            descrPtr->countingActuallAccessedIndex,
            ((dp == 0)  ? SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_E  :
             (dp == 1)  ? SMEM_LION3_PLR_BILLING_TABLE_FIELDS_YELLOW_COUNTER_E :
                          SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RED_COUNTER_E),
             &dataPtr->l[0]);
    }
    else
    {
        startBit = (dp * 42);

        snetFieldValueSet(entryPtr, startBit +  0, 32 , dataPtr->l[0]);
        snetFieldValueSet(entryPtr, startBit + 32, 10 , dataPtr->l[1]);
    }
}

/**
* @internal snetXcatPolicerBillingCounterRead function
* @endinternal
*
* @brief   Get packets/data units billing counter value
*
* @param[in] entryPtr                 - pointer to policer billing counter entry
* @param[in] dp                       - the packet's DP  0..2
* @param[in] dataPtr                  - pointer to 64 bits increment
*/
static void snetXcatPolicerBillingCounterRead
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * entryPtr,
    IN GT_U32 dp,
    OUT GT_U64 * dataPtr
)
{
    GT_U32 startBit;

    if(dp > 2)
    {
        skernelFatalError("snetXcatPolicerBillingCounterRead: dp[%d] > 2 \n",
            dp);
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        SMEM_LION3_PLR_BILLING_ENTRY_LARGE_FIELD_GET(devObjPtr,entryPtr,
            descrPtr->countingActuallAccessedIndex,
            ((dp == 0)  ? SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_E  :
             (dp == 1)  ? SMEM_LION3_PLR_BILLING_TABLE_FIELDS_YELLOW_COUNTER_E :
                          SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RED_COUNTER_E),
             &dataPtr->l[0]);
    }
    else
    {
        startBit = (dp * 42);

        dataPtr->l[0] = snetFieldValueGet(entryPtr, startBit +  0, 32);
        dataPtr->l[1] = snetFieldValueGet(entryPtr, startBit + 32, 10);
    }
}

/**
* @internal snetXcatPolicerMngCounterRead function
* @endinternal
*
* @brief   Get data units management counter value
*
* @param[in] entryPtr                 - pointer to policer billing counter entry
* @param[in] dp                       - the packet's DP
* @param[in] dataPtr                  - pointer to 64 bits increment
*/
static void snetXcatPolicerMngCounterRead
(
    IN GT_U32 * entryPtr,
    IN GT_U32 dp,
    OUT GT_U64 * dataPtr
)
{
    GT_U32 startBit;
    GT_U32 multiplier = 0;

    if(dp == SKERNEL_CONFORM_GREEN){
        multiplier = 0;
    } else if(dp == SKERNEL_CONFORM_YELLOW){
        multiplier = 1;
    } else if(dp == SKERNEL_CONFORM_RED){
        multiplier = 2;
    } else if(dp == SKERNEL_CONFORM_DROP){
        multiplier = 3;
    }

    startBit = 0 + (multiplier * 128); /* 128 bits alignment */
    dataPtr->l[0] = snetFieldValueGet(entryPtr, startBit +  0, 32);
    dataPtr->l[1] = snetFieldValueGet(entryPtr, startBit + 32, 10);
}


/**
* @internal snetXcatPolicerMngCounterWrite function
* @endinternal
*
* @brief   Set data units management counter value
*
* @param[in] entryPtr                 - pointer to policer billing counter entry
* @param[in] dp                       - the packet's DP
* @param[in] dataPtr                  - pointer to 64 bits increment
*/
static void snetXcatPolicerMngCounterWrite
(
    IN GT_U32 * entryPtr,
    IN GT_U32 dp,
    IN GT_U64 * dataPtr
)
{
    GT_U32 startBit;
    GT_U32 multiplier = 0;

    if(dp == SKERNEL_CONFORM_GREEN){
        multiplier = 0;
    } else if(dp == SKERNEL_CONFORM_YELLOW){
        multiplier = 1;
    } else if(dp == SKERNEL_CONFORM_RED){
        multiplier = 2;
    } else if(dp == SKERNEL_CONFORM_DROP){
        multiplier = 3;
    }

    startBit = 0 + (multiplier * 128); /* 128 bits alignment */

    snetFieldValueSet(entryPtr, startBit +  0, 32 , dataPtr->l[0]);
    snetFieldValueSet(entryPtr, startBit + 32, 10 , dataPtr->l[1]);
}

/**
* @internal snetXcatPolicerMngCounterPktIncrement function
* @endinternal
*
* @brief   Increment packets management counter value
*
* @param[in] entryPtr                 - pointer to policer billing counter entry
* @param[in] dp                       - the packet's DP
*/
static void snetXcatPolicerMngCounterPktIncrement
(
    IN GT_U32 *entryPtr,
    IN GT_U32 dp
)
{
    GT_U32 data;
    GT_U32 startBit;
    GT_U32 multiplier = 0;

    if(dp == SKERNEL_CONFORM_GREEN){
        multiplier = 0;
    } else if(dp == SKERNEL_CONFORM_YELLOW){
        multiplier = 1;
    } else if(dp == SKERNEL_CONFORM_RED){
        multiplier = 2;
    } else if(dp == SKERNEL_CONFORM_DROP){
        multiplier = 3;
    }

    startBit = 42 + (multiplier * 128); /* 128 bits alignment */

    data = snetFieldValueGet(entryPtr,  startBit, 32);
    data ++;/* increment the counter */
    snetFieldValueSet(entryPtr,  startBit, 32, data);
}

/**
* @internal snetXcatPolicerIpfixCounterRead function
* @endinternal
*
* @brief   Get packets/data units IPFix counter value
*
* @param[in] entryPtr                 - pointer to policer billing counter entry
*
* @param[out] bytesCntPtr              - pointer to bytes counter value
* @param[out] packetsPtr               - pointer to good packets value
* @param[out] stampPtr                 - pointer to time stamp value
* @param[out] dropsPtr                 - pointer to drop packets value
*                                      RETURN:
*/
static void snetXcatPolicerIpfixCounterRead
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32   * entryPtr,
    OUT GT_U64 * bytesCntPtr,
    OUT GT_U32 * packetsPtr,
    OUT GT_U32 * stampPtr,
    OUT GT_U32 * dropsPtr
)
{

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        SMEM_LION3_PLR_IPFIX_ENTRY_LARGE_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_BYTE_COUNT_E,
                        &bytesCntPtr->l[0]);

        *packetsPtr = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_PACKET_COUNT_E);

        *stampPtr = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_TIME_STAMP_E);

        *dropsPtr = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_DROP_COUNTER_E);
    }
    else
    {
        bytesCntPtr->l[0] = entryPtr[0];
        bytesCntPtr->l[1] = SMEM_U32_GET_FIELD(entryPtr[1], 0, 4);
        *packetsPtr =
            SMEM_U32_GET_FIELD(entryPtr[1], 4, 28) |
            SMEM_U32_GET_FIELD(entryPtr[2], 0, 2) << 28;
        *stampPtr = SMEM_U32_GET_FIELD(entryPtr[2], 2, 16);
        *dropsPtr =
            SMEM_U32_GET_FIELD(entryPtr[6], 6, 26) |
            SMEM_U32_GET_FIELD(entryPtr[7], 0, 4) << 26;
    }
}

/**
* @internal snetXcatPolicerPortPointerIndexGet function
* @endinternal
*
* @brief   devObjPtr  - pointer to device object.
*         Storm type port metering index
* @param[in] regValue                 - value of register relate to 'port' - see Port%p and Packet Type Translation Table
* @param[in] pcktType                 - packet type
* @param[in] port                     - port
*/
static GT_U32 snetXcatPolicerPortPointerIndexGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 regValue,
    IN SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT pcktType,
    GT_U32 port
)
{
    GT_U32  offset = (pcktType*2);
    if(SMEM_CHT_IS_SIP6_GET(devObjPtr))
    {
        offset += 1;/*bit 0 is '<Port_Metering_Enable>'*/
    }
    else
    if((!SMEM_CHT_IS_SIP5_20_GET(devObjPtr)) && (port & 1))
    {
        offset += 12;
    }

    return   SMEM_U32_GET_FIELD(regValue, offset, 2);
}

/**
* @internal snetXCatPolicerMngCounterIncrement function
* @endinternal
*
* @brief   Increment Management Counters
*/
GT_VOID snetXCatPolicerMngCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 address,
    IN GT_U32 dp,
    IN GT_U32 increment
)
{
    GT_U32 *regPtr;
    GT_U64 val64, increment64;

    __LOG_NO_LOCATION_META_DATA(("update management counters at address [0x%8.8x] for counter index[%d] by value [%d] \n",
        address,dp,increment));

    regPtr = smemMemGet(devObjPtr, address);

    /* Increment data units counter */
    snetXcatPolicerMngCounterRead(regPtr, dp, &val64);
    CNV_U32_TO_U64(increment, increment64);
    val64 = prvSimMathAdd64(val64, increment64);
    snetXcatPolicerMngCounterWrite(regPtr, dp, &val64);

    /* Increment packets counter */
    snetXcatPolicerMngCounterPktIncrement(regPtr, dp);
}

/**
* @internal snetXCatEgressPolicerTriggeringCheck function
* @endinternal
*
* @brief   Check if need to do policer
*/
static GT_BOOL snetXCatEgressPolicerTriggeringCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 egressPort,
    OUT GT_U32 ** policerMeterEntryPtrPtr
)
{
    DECLARE_FUNC_NAME(snetXCatEgressPolicerTriggeringCheck);

    GT_U32 regAddr;                     /* register address */
    GT_U32 fldValue;                    /* register entry field */
    GT_U32 policerIdx = 0;              /* policer entry offset */
    GT_U32 meterBaseAddr;               /* metering table base address */
    GT_U32 meterMemoryCycle;            /* policer stage for meter tables access */
    GT_BOOL skipPhysicalPort = GT_FALSE;

    /* initialize the trigger mode */
    __LOG(("initialize the trigger mode"));
    descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_NONE_E;
    __LOG_PARAM(descrPtr->policerTriggerMode);

    /* All packets are processed by Egress Policer for SIP5 devices */
    if(!SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        if (descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_FORWARD_E &&
            descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E)
        {
            return GT_FALSE;
        }
    }

    if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
    {
        regAddr = SMEM_XCAT_POLICER_GLB1_CONF_REG(devObjPtr, 2);
        smemRegFldGet(devObjPtr, regAddr, 6, 1, &fldValue);
        if(fldValue)
        {
            __LOG(("EPLR bypass enabled. Bypassing"));
            return GT_FALSE;
        }
    }
    regAddr = SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,
                                                descrPtr->policerCycle/*2*/);
    smemRegFldGet(devObjPtr, regAddr, 0, 1, &fldValue);
    /* Metering Disabled */
    if(fldValue == 0)
    {
        __LOG(("Metering Globally Disabled \n"));
        return GT_FALSE;
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        if(GT_TRUE == snetLion2PolicerEArchIndexGet(devObjPtr, descrPtr,
                                      SMAIN_DIRECTION_EGRESS_E, 0 , &policerIdx))
        {
            /* the eport/evlan/ flow needs metering/counting */
            if (descrPtr->policerTriggerMode == SKERNEL_POLICER_TRIGGER_MODE_NONE_E)
            {
                /* although eport/evlan used , still forced 'no meter' */
                __LOG(("when eArch (eport/evlan metering is used , then the per physical port registers are not used"));
                return GT_FALSE;
            }

            if(descrPtr->policerActuallAccessedIndex == SMAIN_NOT_VALID_CNS)
            {
                /* restore to 0 , so no indication in the LOG */
                descrPtr->policerActuallAccessedIndex = 0;
                __LOG(("Counting only , Metering not needed \n"));

                return GT_FALSE;
            }

            /* from here we need to check the 'physical port' logic */
            skipPhysicalPort = GT_TRUE;
        }

        descrPtr->policerActuallAccessedIndex = 0;
    }

    if(skipPhysicalPort == GT_FALSE)
    {
        regAddr = SMEM_CHT3_POLICER_PORT_METER_REG(devObjPtr,
            descrPtr->policerCycle/*2*/ ,egressPort);
        if(SMEM_CHT_IS_SIP6_GET(devObjPtr))
        {
            /* each port with it's own register */
            smemRegFldGet(devObjPtr, regAddr, 0, 1, &fldValue);
        }
        else
        {
            smemRegFldGet(devObjPtr, regAddr, egressPort % 32, 1, &fldValue);
        }
        if (fldValue)
        {
            /* state the trigger was by 'port mode' */
            __LOG(("state the trigger was by 'port mode'"));
            descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_PORT_E;
            __LOG_PARAM(descrPtr->policerTriggerMode);

            /* Per port - First 28 policers can be triggered per port configuration */
            __LOG(("Per port - First 28 policers can be triggered per port configuration"));
            policerIdx = egressPort;
        }
        else
        {
            /* PCL trigger */
            __LOG(("PCL trigger"));
            if (descrPtr->policerEgressEn == 0)
            {
                return GT_FALSE;
            }

            /* state the trigger was by 'flow mode' */
            __LOG(("state the trigger was by 'flow mode'"));
            descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_FLOW_E;
            __LOG_PARAM(descrPtr->policerTriggerMode);
        }

        snetXCatPolicerOverrideMeterIndex(devObjPtr, descrPtr,
                                          SMAIN_DIRECTION_EGRESS_E, &policerIdx,egressPort);
    }

    if (descrPtr->policerTriggerMode == SKERNEL_POLICER_TRIGGER_MODE_NONE_E)
    {
        return GT_FALSE;
    }

    descrPtr->policerActuallAccessedIndex = policerIdx;
    meterMemoryCycle = descrPtr->policerCycle;

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        /* metering base address is used to get absolute index in memory starting from SIP 5.15 (BobK).*/
        meterBaseAddr = SMEM_LION3_POLICER_METERING_BASE_ADDR____FROM_DB(devObjPtr,descrPtr->policerCycle);
        policerIdx += meterBaseAddr;

        if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
        {
            /* use IPLR0 unit for meter memories access for ALL PLR processing */
            __LOG(("Use metering memory of IPLR[%d] index %d\n", 0, policerIdx));
        }
        else
        {
            __LOG(("Use metering memory of EPLR index %d\n", policerIdx));
        }
    }

    regAddr = SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM(devObjPtr,SMAIN_DIRECTION_EGRESS_E,
                meterMemoryCycle/*2*/ ,policerIdx);

    /* Copy Policer Table entry to buffer */
    (*policerMeterEntryPtrPtr) = smemMemGet(devObjPtr, regAddr);

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        regAddr = SMEM_SIP5_15_POLICER_CONFIG_ENTRY_TBL_MEM(devObjPtr, meterMemoryCycle/*2*/, policerIdx);
        /* Get Policer config Table entry to buffer */
        descrPtr->policerMeterConfigEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);

        /* each PLR unit has it's own instance of the sign table */
        regAddr = SMEM_SIP5_15_POLICER_METERING_CONFORMANCE_LEVEL_SIGN_TBL_MEM(devObjPtr, descrPtr->policerCycle/*2*/, policerIdx);
        /* Get Policer Metering Conformance Level Sign Table entry to buffer */
        descrPtr->policerConformanceLevelSignEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);
    }


    return GT_TRUE;
}

/**
* @internal snetXCatCommonPolicerMeteringEnvelopeDataGet function
* @endinternal
*
* @brief   Get metering data for envelope of entries
*         Relevant for both ingeress and egress policer.
*/
GT_STATUS snetXCatCommonPolicerMeteringEnvelopeDataGet
(
    IN  SKERNEL_DEVICE_OBJECT                *devObjPtr,
    IN  SKERNEL_FRAME_CHEETAH_DESCR_STC      *descrPtr,
    IN  GT_U32                               *policerMeterEntryPtr,
    IN  GT_U32                               isEgress,
    OUT SNET_LION3_POLICER_METERING_DATA_STC *meteringDataPtr
)
{
    DECLARE_FUNC_NAME(snetXCatCommonPolicerMeteringEnvelopeDataGet);

    GT_U32 regAddr;
    GT_U32 policerIndex;
    GT_U32 policerStep;
    GT_U32 *policerBase;
    GT_U32 priorityAccessBase;
    GT_U32 flowBaseMask;
    GT_U32 envelopeBaseIndex;
    GT_U32 packetRank; /*rank range 0-7*/
    GT_U32 qosProfileIndex;
    GT_U32 val;
    GT_U32 *meterCfgEntryPtr;
    GT_U32 *meterBucketEntryPtr;
    GT_U32 policer_mode;
    GT_U32 envelopeSize;
    GT_U32 i, bucketColor, bucketRank;
    GT_BOOL greenFound, yellowFound;
    GT_U32 meterMemoryCycle;            /* policer stage for meter tables access */

    GT_U32 meterMemoryCfgCycle;            /* policer stage for meter cfg tables access */
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_ENT fieldId;

    /* init to be overriden */
    memset(meteringDataPtr, 0, sizeof(SNET_LION3_POLICER_METERING_DATA_STC));
    meteringDataPtr->valid = GT_FALSE;

    if(! SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        __LOG(("device in not SIP5_15\n"));
        return GT_FAIL;
    }
    if (policerMeterEntryPtr == NULL)
    {
        __LOG(("Trigger for metering not found: policerMeterConfigEntryMemoryPtr == NULL\n"));
        return GT_FAIL;
    }

    /*  Meter memories became shared between IPLR0 and IPLR1 starting from SIP 5.15 (BobK).
        Direct access done through IPLR0.
        Use IPLR0 unit for meter memories access for IPLR1 processing */
    meterMemoryCycle = (descrPtr->policerCycle == 1) ? 0 : descrPtr->policerCycle;

    __LOG(("Use metering memory of PLR[%d]\n", meterMemoryCycle));

    regAddr =
        SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM_ANY(
            devObjPtr, meterMemoryCycle, 0 /*policerIdx*/);
    policerBase = (GT_U32*)smemMemGet(devObjPtr, regAddr);
    regAddr =
        SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM_ANY(
            devObjPtr, meterMemoryCycle, 1 /*policerIdx*/);
    policerStep = /* address difference in words */
        (GT_U32*)smemMemGet(devObjPtr, regAddr) - (GT_U32*)policerBase;
    policerIndex =
        (policerMeterEntryPtr - policerBase) / policerStep;

    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->
        PLR[descrPtr->policerCycle].meteringAddressingModeConfiguration0;
    smemRegGet(devObjPtr, regAddr, &val);
    priorityAccessBase = (val & 0x1FFFF);

    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->
        PLR[descrPtr->policerCycle].meteringAddressingModeConfiguration1;
    smemRegGet(devObjPtr, regAddr, &val);
    flowBaseMask = (val & 0x1FFFF);

    if (policerIndex < priorityAccessBase)
    {
        /* flow based access */
        envelopeBaseIndex = policerIndex & flowBaseMask;
        packetRank        = policerIndex - envelopeBaseIndex;
    }
    else
    {
        /* priority based access */
        envelopeBaseIndex = policerIndex;

        if(SMEM_CHT_IS_SIP6_GET(devObjPtr))
        {
            regAddr = SMEM_SIP6_POLICER_QOS_ATTRIBUTE_TBL_MEM(devObjPtr,
                    descrPtr->policerCycle ,
                    descrPtr->qos.qosProfile / 4);
            /* 5 bits for each profile . the field start at bit 0 */
            smemRegFldGet(devObjPtr, regAddr ,
                0 + 5 * (descrPtr->qos.qosProfile % 4) ,
                3,
                &packetRank);
        }
        else
        {
            regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[descrPtr->policerCycle].
                qosProfileToPriority_tab;
            qosProfileIndex = descrPtr->qos.qosProfile;
            smemRegGet(devObjPtr, (regAddr + (4 * (qosProfileIndex / 8))), &val);
            packetRank = ((val >> (qosProfileIndex % 8)) & 0x0F);
        }
    }
    meteringDataPtr->envelopeBaseIndex = envelopeBaseIndex;
    meteringDataPtr->packetRank = packetRank;

    if (devObjPtr->policerSupport.isMeterConfigTableShared[descrPtr->policerCycle] == GT_TRUE)
    {
        meterMemoryCfgCycle = meterMemoryCycle;
    }
    else
    {
        meterMemoryCfgCycle =  descrPtr->policerCycle;
    }

    regAddr = SMEM_SIP5_15_POLICER_CONFIG_ENTRY_TBL_MEM(
        devObjPtr, meterMemoryCfgCycle, envelopeBaseIndex);

    meterCfgEntryPtr = smemMemGet(devObjPtr, regAddr);

    regAddr = SMEM_SIP5_15_POLICER_CONFIG_ENTRY_TBL_MEM(
        devObjPtr, meterMemoryCfgCycle, (envelopeBaseIndex + packetRank));
    meteringDataPtr->meterCfgEntryPtr = smemMemGet(devObjPtr, regAddr);

    policer_mode =
        SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
            meterCfgEntryPtr,
            envelopeBaseIndex,
            SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E);
    if (policer_mode != SNET_LION3_POLICER_METERING_MODE_MEF10_3_START_E)
    {
        __LOG(("Base metering CFG entry mode is not MEF10_3_START\n"));
        return GT_FAIL;
    }

    fieldId = (isEgress && SMEM_CHT_IS_SIP6_GET(devObjPtr))
        ? SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_MEF_10_3_ENV_SIZE_E
        : SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MEF_10_3_ENV_SIZE_E;
    envelopeSize =
        SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
            meterCfgEntryPtr,
            envelopeBaseIndex,
            fieldId);
    meteringDataPtr->envelopeSize = (envelopeSize + 1);
    if (envelopeSize < packetRank)
    {
        __LOG(("Packet runk more than envelope size\n"));
        return GT_FAIL;
    }

    if (packetRank != 0)
    {
        policer_mode =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                meteringDataPtr->meterCfgEntryPtr,
                (envelopeBaseIndex + packetRank),
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E);
        if (policer_mode != SNET_LION3_POLICER_METERING_MODE_MEF10_3_NOT_START_E)
        {
            __LOG(("Packet rank!= 0 metering CFG entry mode is not MEF10_3_NOT_START\n"));
            return GT_FAIL;
        }
    }

    /* each PLR unit has it's own instance of the sign table */
    regAddr = SMEM_SIP5_15_POLICER_METERING_CONFORMANCE_LEVEL_SIGN_TBL_MEM(
        devObjPtr, descrPtr->policerCycle, (envelopeBaseIndex + packetRank));
    meteringDataPtr->meterConformSignLevelPtr = smemMemGet(devObjPtr, regAddr);

    greenFound  = GT_FALSE;
    yellowFound = GT_FALSE;
    for (i = 0; (i <= envelopeSize); i++)
    {
        regAddr = SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM_ANY(
            devObjPtr, meterMemoryCycle, (envelopeBaseIndex + i));
        meterBucketEntryPtr = smemMemGet(devObjPtr, regAddr);

        /* bucket 0 */
        bucketRank = SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr, meterBucketEntryPtr, (envelopeBaseIndex + i),
            SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_RANK);
        if (bucketRank == packetRank)
        {
            bucketColor = SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
                devObjPtr, meterBucketEntryPtr, (envelopeBaseIndex + i),
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_COLOR);
            if (bucketColor == 0)
            {
                /* green */
                if (greenFound != GT_FALSE)
                {
                    __LOG(("duplicate green bucket of the same range, ignored\n"));
                }
                else
                {
                    greenFound = GT_TRUE;
                    meteringDataPtr->meterGreenBucketEntryIndex = (envelopeBaseIndex + i);
                    meteringDataPtr->meterGreenBucketNumber = 0;
                    meteringDataPtr->meterGreenBucketEntryPtr = meterBucketEntryPtr;
                }
            }
            else
            {
                /* yellow */
                if (yellowFound != GT_FALSE)
                {
                    __LOG(("duplicate yellow bucket of the same range, ignored"));
                }
                else
                {
                    yellowFound = GT_TRUE;
                    meteringDataPtr->meterYellowBucketEntryIndex = (envelopeBaseIndex + i);
                    meteringDataPtr->meterYellowBucketNumber = 0;
                    meteringDataPtr->meterYellowBucketEntryPtr = meterBucketEntryPtr;
                }
            }
        }

        /* bucket 1 */
        bucketRank = SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr, meterBucketEntryPtr, (envelopeBaseIndex + i),
            SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_RANK);
        if (bucketRank == packetRank)
        {
            bucketColor = SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
                devObjPtr, meterBucketEntryPtr, (envelopeBaseIndex + i),
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_COLOR);
            if (bucketColor == 0)
            {
                /* green */
                if (greenFound != GT_FALSE)
                {
                    __LOG(("duplicate green bucket of the same range, ignored"));
                }
                else
                {
                    greenFound = GT_TRUE;
                    meteringDataPtr->meterGreenBucketEntryIndex = (envelopeBaseIndex + i);
                    meteringDataPtr->meterGreenBucketNumber = 1;
                    meteringDataPtr->meterGreenBucketEntryPtr = meterBucketEntryPtr;
                }
            }
            else
            {
                /* yellow */
                if (yellowFound != GT_FALSE)
                {
                    __LOG(("duplicate yellow bucket of the same range, ignored"));
                }
                else
                {
                    yellowFound = GT_TRUE;
                    meteringDataPtr->meterYellowBucketEntryIndex = (envelopeBaseIndex + i);
                    meteringDataPtr->meterYellowBucketNumber = 1;
                    meteringDataPtr->meterYellowBucketEntryPtr = meterBucketEntryPtr;
                }
            }
        }

        if ((greenFound != GT_FALSE) && (yellowFound != GT_FALSE))
        {
            break;
        }
    }

    if ((greenFound == GT_FALSE) || (yellowFound == GT_FALSE))
    {
        __LOG(("Not both buckets for packet rank found\n"));
        return GT_FAIL;
    }

    meteringDataPtr->valid = GT_TRUE;

    __LOG(("meteringData: cycle[%d]", descrPtr->policerCycle));
    __LOG(("meteringData: envelop size[%d] base[%d] packetRank[%d] greenBucket[%d/%d] yellowBucket[%d/%d]\n",
           meteringDataPtr->envelopeSize, meteringDataPtr->envelopeBaseIndex,
           meteringDataPtr->packetRank,
           meteringDataPtr->meterGreenBucketEntryIndex, meteringDataPtr->meterGreenBucketNumber,
           meteringDataPtr->meterYellowBucketEntryIndex, meteringDataPtr->meterYellowBucketNumber));
    /* pointers in memory not adding any actual info ...
        and just make difference between 2 different images on the same scenario
    __LOG(("meteringData: descrPtr->policerMeterConfigEntryMemoryPtr old[0x%X] new[0x%X]\n",
           descrPtr->policerMeterConfigEntryMemoryPtr,
           meteringDataPtr->meterCfgEntryPtr));
    __LOG(("meteringData: descrPtr->policerConformanceLevelSignEntryMemoryPtr old[0x%X] new[0x%X]\n",
           descrPtr->policerConformanceLevelSignEntryMemoryPtr,
           meteringDataPtr->meterConformSignLevelPtr));
    */
    __LOG(("meteringData: descrPtr->policerActuallAccessedIndex old[%d] new[%d]\n",
           descrPtr->policerActuallAccessedIndex,
           (meteringDataPtr->envelopeBaseIndex + meteringDataPtr->packetRank)));

    return GT_OK;
}

/**
* @internal snetXCatCommonPolicerMeteringSingleDataGet function
* @endinternal
*
* @brief   Get metering data for single entry.
*         Relevant for both ingeress and egress policer.
*/
GT_VOID snetXCatCommonPolicerMeteringSingleDataGet
(
    IN  SKERNEL_DEVICE_OBJECT                *devObjPtr,
    IN  SKERNEL_FRAME_CHEETAH_DESCR_STC      *descrPtr,
    IN  GT_U32                               *policerMeterEntryPtr,
    OUT SNET_LION3_POLICER_METERING_DATA_STC *meteringDataPtr
)
{
    DECLARE_FUNC_NAME(snetXCatCommonPolicerMeteringSingleDataGet);
    GT_U32 meterMemoryCycle;            /* policer stage for meter tables access */
    GT_U32 meterMemoryCfgCycle;
    GT_U32 regAddr;
    GT_U32 policerIndex;
    GT_U32 policerStep;
    GT_U32 *policerBase;

    __LOG(("Building metering data for single entry\n"));

    memset(meteringDataPtr, 0, sizeof(SNET_LION3_POLICER_METERING_DATA_STC));
    if (policerMeterEntryPtr == NULL)
    {
        meteringDataPtr->valid = GT_FALSE;
        return;
    }
    meteringDataPtr->valid = GT_TRUE;

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        /*  Meter memories became shared between IPLR0 and IPLR1 starting from SIP 5.15 (BobK).
            Direct access done through IPLR0.
            Use IPLR0 unit for meter memories access for IPLR1 processing */
         meterMemoryCycle = (descrPtr->policerCycle == 1) ? 0 : descrPtr->policerCycle;
    }
    else
    {
        meterMemoryCycle = descrPtr->policerCycle;
    }

    if (devObjPtr->policerSupport.isMeterConfigTableShared[descrPtr->policerCycle] == GT_TRUE)
    {
        meterMemoryCfgCycle = meterMemoryCycle;
    }
    else
    {
        meterMemoryCfgCycle = descrPtr->policerCycle;
    }

 __LOG(("Use metering memory of PLR[%d]\n", meterMemoryCycle));
    regAddr = SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM_ANY(
        devObjPtr, meterMemoryCycle, 0 /*policerIdx*/);
    policerBase = smemMemGet(devObjPtr, regAddr);
    regAddr = SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM_ANY(
        devObjPtr, meterMemoryCycle, 1 /*policerIdx*/);
    policerStep = /* address difference in words */
        (GT_U32*)smemMemGet(devObjPtr, regAddr) - (GT_U32*)policerBase;

    policerIndex =
        (policerMeterEntryPtr - (GT_U32*)policerBase)
        / policerStep;


    meteringDataPtr->envelopeSize = 1;
    meteringDataPtr->envelopeBaseIndex = policerIndex;
    meteringDataPtr->packetRank = 0;
    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        regAddr = SMEM_SIP5_15_POLICER_METERING_CONFORMANCE_LEVEL_SIGN_TBL_MEM(
            devObjPtr, descrPtr->policerCycle, policerIndex);
        meteringDataPtr->meterConformSignLevelPtr = smemMemGet(devObjPtr, regAddr);
        regAddr = SMEM_SIP5_15_POLICER_CONFIG_ENTRY_TBL_MEM(
            devObjPtr, meterMemoryCfgCycle, policerIndex);
        meteringDataPtr->meterCfgEntryPtr = smemMemGet(devObjPtr, regAddr);
    }
    else
    {
        meteringDataPtr->meterConformSignLevelPtr = NULL;
        meteringDataPtr->meterCfgEntryPtr = NULL;
    }
    meteringDataPtr->meterGreenBucketNumber = 0;
    meteringDataPtr->meterGreenBucketEntryIndex = policerIndex;
    meteringDataPtr->meterGreenBucketEntryPtr = policerMeterEntryPtr;
    meteringDataPtr->meterYellowBucketNumber = 1;
    meteringDataPtr->meterYellowBucketEntryIndex = policerIndex;
    meteringDataPtr->meterYellowBucketEntryPtr = policerMeterEntryPtr;
}

/**
* @internal snetXCatPolicerMeterExecute function
* @endinternal
*
* @brief   Execute metering algorithm and get conformance level
*/
static GT_VOID snetXCatPolicerMeterExecute
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * policerMeterEntryPtr,
    OUT SNET_CHT3_POLICER_QOS_INFO_STC * qosProfileInfoPtr
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerMeterExecute);

    GT_U32 colorMode;                   /* Color Mode:
                                           0 = Color Blind, 1 = Color Aware */
    GT_U32 meteringAlgorithm;           /* Metering Algorithm:
                                           0 = SrTCM, 1 = TrTCM*/

    /*NOTE : sip5 not reach here*/
    colorMode = SMEM_U32_GET_FIELD(policerMeterEntryPtr[6], 2, 1);
    meteringAlgorithm = SMEM_U32_GET_FIELD(policerMeterEntryPtr[6], 3, 1);

    if (meteringAlgorithm)
    {
        __LOG(("Two-rate Three Color Marking \n"));
        if (colorMode)
        { /* Color Aware */
            /* TB (PIR, EBS) confirming AND initial color = GREEN/YELLOW?*/
            if ((skernelUserDebugInfo.policerConformanceLevel != SKERNEL_CONFORM_RED) &&
                (qosProfileInfoPtr->initialDp != SKERNEL_CONFORM_RED))
            {
                /* TB (CIR, CBS) confirming AND initial color = GREEN? */
                if ((skernelUserDebugInfo.policerConformanceLevel == SKERNEL_CONFORM_GREEN) &&
                    (qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN))
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;
                }
                else
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_YELLOW;
                }
            }
            else
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_RED;
            }
        }
        else
        { /* Color Blind */
            qosProfileInfoPtr->cl = skernelUserDebugInfo.policerConformanceLevel;
        }
    }
    else
    {
        __LOG(("Single-rate Three Color Marking \n"));
        if (colorMode)
        { /* Color Aware */
            /* TB (CIR, CBS) confirming Mark GREEN AND initial color = GREEN? */
            if ((skernelUserDebugInfo.policerConformanceLevel == SKERNEL_CONFORM_GREEN) &&
                (qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN))
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;
            }
            else
            {
                /* TB (CIR, EBS) confirming AND initial color = GREEN/YELLOW? */
                if ((skernelUserDebugInfo.policerConformanceLevel == SKERNEL_CONFORM_YELLOW) &&
                    (qosProfileInfoPtr->initialDp != SKERNEL_CONFORM_RED))
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_YELLOW;
                }
                else
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_RED;
                }
            }
        }
        else
        { /* Color Blind */
            qosProfileInfoPtr->cl = skernelUserDebugInfo.policerConformanceLevel;
        }
    }

    if(colorMode)
    {
        __LOG(("Color Aware \n"));
        __LOG_PARAM(qosProfileInfoPtr->initialDp);
    }
    else
    {
        __LOG(("Color Blind \n"));
    }
    __LOG_PARAM(skernelUserDebugInfo.policerConformanceLevel);

    __LOG(("Final Conformance level decision: \n"));
    __LOG_PARAM(qosProfileInfoPtr->cl);

}

/**
* @internal snetXCatEgressPolicerConformanceLevelGet function
* @endinternal
*
* @brief   Get conformance level and QoSProfile for out-of-profile traffic
*/
static GT_VOID snetXCatEgressPolicerConformanceLevelGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SNET_LION3_POLICER_METERING_DATA_STC *meteringDataPtr,
    OUT SNET_CHT3_POLICER_QOS_INFO_STC * qosProfileInfoPtr
)
{
    DECLARE_FUNC_NAME(snetXCatEgressPolicerConformanceLevelGet);

    GT_U32 fldValue;                    /* register's entry field */
    GT_U32 regAddr;                     /* register's address */
    GT_U32 * regPtr;                    /* register's entry pointer */
    GT_U32 word, offset;
    GT_U32 * policerMeterEntryPtr;      /* pointer to metering entry */

    /* for SIP5_15 buckets entry - not used */
    policerMeterEntryPtr = meteringDataPtr->meterGreenBucketEntryPtr;

    /* Set init values */
    memset(qosProfileInfoPtr, 0, sizeof(SNET_CHT3_POLICER_QOS_INFO_STC));

    /* check QoS model of EPLR in the Policer Control0, bit 21 Qos Model */
    regAddr = SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,
                                                 descrPtr->policerCycle/*2*/);
    smemRegFldGet(devObjPtr, regAddr, 21, 1, &fldValue);
    if(fldValue != 0)
    {   /* the ERLR must work with Full QoS parameters */
        skernelFatalError("snetXCatEgressPolicerConformanceLevelGet: QoS Model is wrong");
        return;
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        if(descrPtr->qos.ingressExtendedMode)
        {
            __LOG(("EPLR QoS profile to initial DP table is skipped in extended QoS mode"));
            qosProfileInfoPtr->initialDp = descrPtr->dp;
            qosProfileInfoPtr->tc        = descrPtr->tc;
        }
        else
        {
            if(SMEM_CHT_IS_SIP6_GET(devObjPtr))
            {
                /* 4 qos profiles in entry */
                regAddr =
                    SMEM_SIP6_POLICER_QOS_ATTRIBUTE_TBL_MEM(devObjPtr,
                        descrPtr->policerCycle ,/*2*/
                        descrPtr->qos.qosProfile / 4);
                /* 5 bits for each profile . the field start at bit 3*/
                smemRegFldGet(devObjPtr, regAddr ,
                    3 + 5* (descrPtr->qos.qosProfile % 4) ,
                    2,
                    &fldValue);
                qosProfileInfoPtr->initialDp = fldValue;
            }
            else
            {
                /* Intial DP */
                regAddr =
                    SMEM_CHT3_POLICER_INITIAL_DP_REG(devObjPtr, descrPtr->policerCycle , 0);
                regPtr = smemMemGet(devObjPtr, regAddr);
                /* get the 2 bits that associated with the QOS profile index */
                qosProfileInfoPtr->initialDp = snetFieldValueGet(regPtr, 2 * descrPtr->qos.qosProfile, 2);
            }

            /* logic for TC unknown yet */
            qosProfileInfoPtr->tc = 0;
        }
    }
    else
    {
        /* ERLR gets DP from EPCL, EPCL get DP from QosProfile to DP Register<%n> */
        regAddr = SMEM_XCAT_HA_QOS_PROFILE_TO_DP_REG(devObjPtr);
        regPtr = smemMemGet(devObjPtr, regAddr);
        word = descrPtr->qos.qosProfile / 16;
        offset = descrPtr->qos.qosProfile % 16;

        qosProfileInfoPtr->initialDp =
            SMEM_U32_GET_FIELD(regPtr[word], 2 * offset, 2);

        descrPtr->dp = qosProfileInfoPtr->initialDp;
        /* ERLR gets TC from EPCL, but EPCL use constant 0.
           The Egress remarking by TC does not works. */
        qosProfileInfoPtr->tc = 0;
    }

    /* set conformance level to be green for not metered packets */
    __LOG(("set conformance level to be green for not metered packets"));
    qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;

    if(policerMeterEntryPtr == NULL)
    {
        return;
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_COLOR_MODE_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_COLOR_MODE);

    }
    else
    {
        fldValue = SNET_CHT3_POLICER_COLOR_MODE_GET_MAC(devObjPtr, policerMeterEntryPtr);
    }

    if (fldValue == 0)
    {
        /* When color blind we are always GREEN */
        __LOG(("Color Mode : BLIND : When color blind we are always GREEN \n"));
        qosProfileInfoPtr->initialDp = SKERNEL_CONFORM_GREEN;
    }
    else
    {
        __LOG(("Color Mode : AWARE \n"));
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* do simple 'Token bucket' for current packet , without considering
           time/other previous packets */
        snetLion3PolicerMeterSinglePacketTokenBucketApply(devObjPtr, descrPtr,
                                      SMAIN_DIRECTION_EGRESS_E,
                                      meteringDataPtr,
                                      qosProfileInfoPtr);
    }
    else
    {
        /* execute metering and get final conformance level */
        __LOG(("execute metering and get final conformance level"));
        snetXCatPolicerMeterExecute(devObjPtr, descrPtr, policerMeterEntryPtr,
                                    qosProfileInfoPtr);
    }
}

/**
* @internal snetXCatEgressPolicerCountersUpdate function
* @endinternal
*
* @brief   Count the bytes of packets in the policer
*/
static GT_VOID snetXCatEgressPolicerCountersUpdate
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_BOOL forward,
    IN SNET_CHT3_POLICER_QOS_INFO_STC   * qosProfileInfoPtr,
    IN GT_U32 egressPort,
    OUT SNET_CHT3_POLICER_MNG_COUNT_STC * mngCountDataPtr
)
{
    DECLARE_FUNC_NAME(snetXCatEgressPolicerCountersUpdate);

    GT_U32 fldValue;                    /* register's entry field */
    GT_U32 fldOffset;                   /* register field offset */
    GT_U32 regAddr;                     /* register's address */
    GT_U32 bytesCount = 0;              /* number of bytes in packet */
    GT_U32 unitSizeCount;               /* number of unit size to add to counter */
    GT_U32 * policerCtrlRegPtr;         /* egress policer control data */
    GT_U32 mngCntrDp;                   /* management counter dp */

    policerCtrlRegPtr =
        smemMemGet(devObjPtr, SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,descrPtr->policerCycle/*2*/));

    /* Increment Policer Billing/Policy/VLAN Counters */
    __LOG(("Increment Policer Billing/Policy/VLAN Counters"));
    snetXCatPolicerCounterIncrement(devObjPtr, descrPtr,
                                SMAIN_DIRECTION_EGRESS_E,
                                policerCtrlRegPtr, policerMeterEntryPtr,
                                egressPort,
                                qosProfileInfoPtr->cl,
                                &bytesCount);

    if(policerMeterEntryPtr == 0)
    {
        return;
    }

    /* Set number 0-2 and enable of the Management Counters */
    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        mngCountDataPtr->countSet =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MG_COUNTERS_SET_EN_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        mngCountDataPtr->countSet =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_MG_COUNTERS_SET_EN);
    }
    else
    {
        mngCountDataPtr->countSet = SMEM_U32_GET_FIELD(policerMeterEntryPtr[6], 4, 2);
    }

    if (mngCountDataPtr->countSet != SNET_CHT3_MNG_SET_DISABLE_E)
    {
        fldOffset =
            SNET_CHT3_POLICER_MNG_COUNT_FLD_OFFSET_GET_MAC(mngCountDataPtr->countSet);

        mngCountDataPtr->countScale =
            SMEM_U32_GET_FIELD(*policerCtrlRegPtr, fldOffset, 1);

        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            /* byte count will be calculated when needed */
            __LOG(("Calc num bytes needed for [%s] purpose \n",
                "Management counters"));
            snetLion3PolicerPacketSizeGet(devObjPtr, descrPtr,SMAIN_DIRECTION_EGRESS_E,
                                         SNET_LION3_POLICER_PACKET_SIZE_FROM_GLOBAL_CONFIG_E,
                                         NULL,
                                         &bytesCount);
        }

        mngCountDataPtr->countByteSize = bytesCount;

        /* Convert byte size to acceptable counter resolution 1 byte/16 byte */
        __LOG(("Convert byte size to acceptable counter resolution 1 byte/16 byte"));
        unitSizeCount = SNET_CHT3_PCKT_SIZE_RESOLVE(mngCountDataPtr->countByteSize,
                                                    mngCountDataPtr->countScale);
        /* Update management counter table */
        __LOG(("Update management counter table"));
        regAddr = SMEM_XCAT_POLICER_MNG_CNT_TBL_MEM(devObjPtr,descrPtr->policerCycle/*2*/,
                                                        mngCountDataPtr->countSet);
        if (forward == GT_FALSE)
        {
            mngCntrDp = SKERNEL_CONFORM_DROP;
        }
        else
        {
            /* Increment Green/Yellow/Red counters based on packets
              conformance level or DP. Selection between DP and CL is based
              on a <Counter Color Mode> configuration in the Policer Control0
              Register */
            fldValue = SNET_XCAT_POLICER_COUNT_COLOR_MODE_GET_MAC(policerCtrlRegPtr);
            mngCntrDp = (fldValue) ? descrPtr->dp : qosProfileInfoPtr->cl;
        }

        snetXCatPolicerMngCounterIncrement(devObjPtr, regAddr, mngCntrDp,
                                           unitSizeCount);
    }
}

/**
* @internal snetXCatEgressPolicerQosRemark function
* @endinternal
*
* @brief   remark QoS parameters - only for out-of-profile traffic !!!
*         Out-of-profile packets are subject to out-of-profile commands
*         and may be discarded or have their packet QoS information remarked.
*/
static GT_BOOL snetXCatEgressPolicerQosRemark
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * policerMeterEntryPtr,
    IN SNET_CHT3_POLICER_QOS_INFO_STC * qosProfileInfoPtr,
    IN SNET_CHT3_POLICER_MNG_COUNT_STC * mngCountDataPtr
)
{
    DECLARE_FUNC_NAME(snetXCatEgressPolicerQosRemark);

    GT_U32 fldValue;                    /* register's entry field */
    GT_U32 regAddr;                     /* Register address */
    GT_U32 *regPtr;                     /* pointer to memory of register */
    GT_U32 entryIndex;                  /* remarking table entry index */
    GT_U32 startBit;                    /* start bit of entry in the memory */
    GT_U32 entry;                       /* remarking entry */
    struct _TMP_REMARK_STC{
        GT_U32  tc;
        GT_U32  dp;
        GT_U32  dscp;
        GT_U32  up;
        GT_U32  exp;
    }remark;

    /* make remarking for metered packets only */
    if(policerMeterEntryPtr == 0)
    {
        __LOG(("no remarking for non metered packets \n"));
        return GT_TRUE;
    }

    /* check remarking for Green packet */
    __LOG(("check remarking for Green packet"));
    if (qosProfileInfoPtr->cl == SKERNEL_CONFORM_GREEN)
    {
        /* check Enable Qos updated for conforming packets */
        smemRegFldGet(devObjPtr, SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,descrPtr->policerCycle/*2*/),
                      31, 1, &fldValue);
        if (fldValue == 0)
        {
            /* there is no remarking for conforming packets */
            __LOG(("there is no remarking for conforming packets \n"));
            return GT_TRUE;
        }
        __LOG(("there is remarking for conforming packets \n"));
    }
    else
    {
         /* check Drop Red in the MX Non Conforming Packet Command */
        if (qosProfileInfoPtr->cl == SKERNEL_CONFORM_RED)
        {
            if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
            {
                fldValue =
                    SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                        descrPtr->policerMeterConfigEntryMemoryPtr,
                        descrPtr->policerActuallAccessedIndex,
                        SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_DROP_RED_E);
            }
            else
            if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
            {
                fldValue =
                    SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                        descrPtr->policerActuallAccessedIndex,
                        SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_DROP_RED);
            }
            else
            {
                fldValue = (SMEM_U32_GET_FIELD(policerMeterEntryPtr[6], 23, 1));
            }

            if (fldValue)
            {
                if (SMEM_CHT_IS_SIP6_GET(devObjPtr))
                {
                    /* Type of the policer out-of-profile drop action */
                    __LOG(("Type of the policer out-of-profile drop action"));
                    smemRegFldGet(devObjPtr,
                    SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr, descrPtr->policerCycle),
                          5, 1, &fldValue);

                    /* Apply packet command */
                    __LOG(("Apply packet command"));
                    descrPtr->packetCmd = snetChtPktCmdResolution(descrPtr->packetCmd,
                                            fldValue ?
                                            SKERNEL_EXT_PKT_CMD_HARD_DROP_E :
                                            SKERNEL_EXT_PKT_CMD_SOFT_DROP_E);
                    descrPtr->packetCmdAssignedByEgress = 1;

                    if (descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_HARD_DROP_E)
                    {
                        __LOG(("Drop Red in the Non Conforming Packet Command"));
                        return GT_FALSE;
                    }
                }
                else
                {
                    __LOG(("Drop Red in the Non Conforming Packet Command"));
                    return GT_FALSE;
                }
            }
        }
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_REMARK_MODE_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_REMARK_MODE);
    }
    else
    {
        fldValue = SMEM_U32_GET_FIELD(policerMeterEntryPtr[6], 22, 1);
    }


    /* select remarking table */
    /* Is packet IP or MPLS  AND <IP/MPLS RemarkMode> == L3*/
    if ((descrPtr->isIp || descrPtr->mpls) &&
        (fldValue))
    {
        /* Is packet IP?*/
        if (descrPtr->isIp)
        {
            /* use {DSCP,CL} remarking table */
            entryIndex = descrPtr->dscp;
            __LOG(("packet IP use DSCP[%d] \n",
                entryIndex));
        }
        else
        {
            /* use {EXP,CL} remarking table */
            entryIndex = descrPtr->exp1 + 64;
            __LOG(("packet MPLS use exp1[%d]+ 64 = [%d] \n",
                descrPtr->exp1,
                entryIndex));
        }
    }
    else
    {
        /* check <L2RemarkModel> in the Policer Control0 Register */
        smemRegFldGet(devObjPtr, SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,descrPtr->policerCycle/*2*/),
                      18, 1, &fldValue);

        if (fldValue == 0)
        {
            /* Access to L2 remarking table is based on
             {Conformance Level, Traffic Class}.*/
            entryIndex = qosProfileInfoPtr->tc + 72;
            __LOG(("use tc[%d]+ 72 = [%d] \n",
                qosProfileInfoPtr->tc,
                entryIndex));
        }
        else
        {
            /* Access to L2 remarking table is based on
             {Conformance Level, User Priority}.*/
            entryIndex = descrPtr->up + 72;
            __LOG(("use up[%d]+ 72 = [%d] \n",
                descrPtr->up,
                entryIndex));
        }
    }

    /* get remarking entry for conformance level */
    __LOG(("get remarking entry for conformance level"));
    regAddr = SMEM_CHT_POLICER_QOS_TBL_MEM(devObjPtr,descrPtr->policerCycle/*2*/,entryIndex);
    regPtr = smemMemGet(devObjPtr, regAddr);
    startBit = qosProfileInfoPtr->cl * SNET_XCAT_POLICER_EGR_REMARK_ENTRY_SIZE_CNS;
    entry = snetFieldValueGet(regPtr, startBit,
                              SNET_XCAT_POLICER_EGR_REMARK_ENTRY_SIZE_CNS);

    remark.tc   = (entry >> 8) & 0x7;
    remark.dp   = (entry >> 6) & 0x3;
    remark.dscp = entry & 0x3f;
    remark.up   = (entry >> 11) & 0x7;
    remark.exp  = (entry >> 14) & 0x7;


    /* DSCP for IP packets only and if MX En Modify DSCP is 1 */
    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP);
    }
    else
    {
        fldValue = snetFieldValueGet(policerMeterEntryPtr, 217, 1);
    }

    if (fldValue)
    {
        /* perform remarking of DSCP, UP and DP */
        __LOG(("Enable modify DSCP , new DSCP[%d]\n ",
            remark.dscp));

        descrPtr->eplrAction.dscp = remark.dscp;
        descrPtr->eplrAction.modifyDscp = fldValue;

        descrPtr->dscp = descrPtr->eplrAction.dscp;
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_UP_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_UP);
    }
    else
    {
        fldValue = snetFieldValueGet(policerMeterEntryPtr, 219, 1);
    }

    if (fldValue)
    {
        /* UP if MX En Modify UP is 1 */
        __LOG(("Enable modify UP mode [%d] , new UP[%d]\n ",
            fldValue,remark.up));

        descrPtr->eplrAction.up = remark.up;
        descrPtr->eplrAction.modifyUp = fldValue;

        descrPtr->up = descrPtr->eplrAction.up;
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DP_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DP);
    }
    else
    {
        fldValue = snetFieldValueGet(policerMeterEntryPtr, 220, 1);
    }

    if (fldValue)
    {
        /* DP if MX En Modify DP is 1 */
        __LOG(("Enable modify DP , new DP[%d]\n ",
            remark.dp));

        descrPtr->eplrAction.dp = remark.dp;
        descrPtr->eplrAction.modifyDp = 1;

        descrPtr->dp = descrPtr->eplrAction.dp;
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_TC_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_TC);
    }
    else
    {
        fldValue = snetFieldValueGet(policerMeterEntryPtr, 218, 1);
    }

    if (fldValue)
    {
        /* DP if MX En Modify TC is 1 */
        __LOG(("Enable modify TC , new TC[%d]\n ",
            remark.tc));

        descrPtr->eplrAction.tc = remark.tc;
        descrPtr->eplrAction.modifyTc = 1;

        descrPtr->tc = descrPtr->eplrAction.tc;
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP);
    }
    else
    {
        fldValue = snetFieldValueGet(policerMeterEntryPtr, 216, 1);
    }

    if (fldValue)
    {
        /* DP if MX En Modify EXP is 1 */
        __LOG(("Enable modify EXP , new EXP[%d]\n ",
            remark.exp));
        descrPtr->eplrAction.exp = remark.exp;
        descrPtr->eplrAction.modifyExp = 1;

        descrPtr->exp1 = descrPtr->eplrAction.exp;
    }

    if(descrPtr->qos.ingressExtendedMode &&
      (descrPtr->eplrAction.modifyTc || descrPtr->eplrAction.modifyDp))
    {
        __LOG(("ingress Extended Mode : when EPLR modifies TC and/or DP, update the value of outDesc<QoS Profile> with {5b0, TC, DP} \n"));
        descrPtr->qos.qosProfile = (descrPtr->tc << 2) | descrPtr->dp;
        __LOG_PARAM(descrPtr->qos.qosProfile);
    }

    return GT_TRUE;
}

/**
* @internal snetXCatEgressEcnUpdate function
* @endinternal
*
* @brief   Update explicit congestion notification field
*/
static GT_VOID snetXCatEgressEcnUpdate
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SNET_CHT3_POLICER_QOS_INFO_STC * qosProfileInfoPtr
)
{
    DECLARE_FUNC_NAME(snetXCatEgressEcnUpdate);

    GT_U32 * meteringEntryPtr;
    GT_U32 regAddress;
    GT_BIT yellowEcnEnabled;

    if(descrPtr->outGoingMtagCmd != SKERNEL_MTAG_CMD_FORWARD_E &&
        descrPtr->outGoingMtagCmd != SKERNEL_MTAG_CMD_FROM_CPU_E)
    {
        __LOG(("Egress packet not subject to ECN modification, because not "
            "FORWARD/FROM_CPU \n"));
        return;
    }
    else
    if(descrPtr->ecnCapable == 0) /* Only for ECN capable senders and receivers */
    {
        __LOG(("Egress packet not subject to ECN modification, because "
            "<ecnCapable> == 0 \n"));
        return;
    }
    else
    if(qosProfileInfoPtr->cl != SKERNEL_CONFORM_YELLOW)
    {
        __LOG(("Egress packet not subject to ECN modification, because "
            "conformance level is [%d] (not yellow)\n", qosProfileInfoPtr->cl));
        return;
    }

    if (SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        meteringEntryPtr = descrPtr->policerMeterConfigEntryMemoryPtr;

        yellowEcnEnabled = SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(
            devObjPtr,
            meteringEntryPtr,
            descrPtr->policerActuallAccessedIndex,
            SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING_E);
    }
    else
    {
        regAddress = SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM(devObjPtr,
            SMAIN_DIRECTION_EGRESS_E,
            descrPtr->policerCycle/*2*/ ,
            descrPtr->policerActuallAccessedIndex);

        meteringEntryPtr = smemMemGet(devObjPtr, regAddress);
        yellowEcnEnabled = SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringEntryPtr,
            descrPtr->policerActuallAccessedIndex,
            SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING);
    }

    /* Mark congestion if needed */
    descrPtr->markEcn = yellowEcnEnabled;
}

/**
* @internal snetPlrCountingModeBillingIpfixCheck function
* @endinternal
*
* @brief Check if the PLR stage counting mode is BILLING/IPFIX
*
* @retval GT_TRUE  - counting mode is BILLING/IPFIX
* @retval GT_FALSE - counting mode is not BILLING/IPFIX
*/
static GT_BOOL snetPlrCountingModeBillingIpfixCheck
(
    IN    SKERNEL_DEVICE_OBJECT           * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetPlrCountingModeBillingIpfixCheck);

    GT_U32                                        * policerCtrlRegPtr;    /* policer control data */
    SNET_XCAT_POLICER_COUNTING_MODE_ENT           counterMode;            /* policer counting mode */
    GT_BOOL                                       rc;                     /* return code */

    policerCtrlRegPtr =
        smemMemGet(devObjPtr, SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,descrPtr->policerCycle));

    /* Get Policer Counting mode */
    counterMode = SNET_XCAT_POLICER_COUNTING_MODE_GET_MAC(policerCtrlRegPtr);
    switch(counterMode)
    {
        case SNET_XCAT_POLICER_COUNTING_BILLING_E:
            rc = GT_TRUE;
            break;

        default:
        /*
            case SNET_XCAT_POLICER_COUNTING_DISABLE_E:
            case SNET_XCAT_POLICER_COUNTING_POLICY_E:
            case SNET_XCAT_POLICER_COUNTING_VLAN_E:
        */
            __LOG(("Policer counting in disabled mode"));
            rc = GT_FALSE;
            break;
    }

    return rc;
}

/**
* @internal snetPlrEntryTypeCheck function
* @endinternal
*
* @brief Check if the entry type is IPFIX or not
*/
static GT_BOOL snetPlrEntryTypeCheck
(
    IN    SKERNEL_DEVICE_OBJECT           * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    GT_U32                                policerCntIndex,
    IN SMAIN_DIRECTION_ENT                direction
)
{
    DECLARE_FUNC_NAME(snetPlrEntryTypeCheck);
    GT_U32 *policerBillingCounterRegPtr;    /* register pointer */
    GT_U32 fieldVal;                        /* register entry field */
    GT_U32 regAddr;                         /* Register address */

    /* Billing counter entry pointer */
    __LOG(("Access the Counting memory : Get the Billing counter entry index [0x%x]\n",
          policerCntIndex));

    regAddr = SMEM_XCAT_POLICER_CNT_ENTRY_TBL_MEM(devObjPtr, direction,
                                                  descrPtr->policerCycle,
                                                  policerCntIndex);

    descrPtr->policerCounterEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);
    policerBillingCounterRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    /* Counter Mode */
    fieldVal = snetFieldValueGet(policerBillingCounterRegPtr, 228, 1);
    return fieldVal;
}

/**
* @internal snetPlrFirstNPacketsFirstTimestampUpdate function
* @endinternal
*
* @brief Update First Timestamp field of the IPFIX entry for First N Packets in the IPLR/EPLR
*/
static GT_VOID snetPlrFirstNPacketsFirstTimestampUpdate
(
    IN    SKERNEL_DEVICE_OBJECT           * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN    GT_U32                          * policerIpfixRegPtr
)
{
    GT_U32                                        timeStamp;              /* current timestamp */
    GT_U32                                        clockVal;               /* number of clock ticks */

    DECLARE_FUNC_NAME(snetPlrFirstNPacketsFirstTimestampUpdate);

    clockVal = SNET_XCAT_IPFIX_TOD_CLOCK_GET_MAC(devObjPtr, descrPtr->policerCycle);

    /* Convert clock value in ticks to time stamp format */
    __LOG(("Convert clock value in ticks to time stamp format"));
    snetXcatIpfixTimestampFormat(devObjPtr, clockVal, &timeStamp);

    /* set the timestamp for the first packet of a flow */
    SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr, policerIpfixRegPtr,
        descrPtr->countingActuallAccessedIndex,
        SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_TIMESTAMP_E,
        timeStamp);

    /* set the first time stamp valid bit */
    SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr, policerIpfixRegPtr,
        descrPtr->countingActuallAccessedIndex,
        SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_TIMESTAMP_VALID_E,
        GT_TRUE);
}

/**
* @internal snetMirrorPacketsForwardingStatusSet function
* @endinternal
*
* @brief Set IPFIX entry forwarding status for 1st N packets
*/
static GT_VOID snetMirrorPacketsForwardingStatusSet
(
    IN    SKERNEL_DEVICE_OBJECT              * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC    * descrPtr,
    IN    GT_U32                             * policerIpfixRegPtr,
    IN    SMAIN_DIRECTION_ENT                  direction
)
{
    DECLARE_FUNC_NAME(snetMirrorPacketsForwardingStatusSet);

    /* Forwarding Status for 1st N packets if egress logic assigned packetCmd */
    /* set the packet command */
    if((descrPtr->packetCmdAssignedByEgress && direction == SMAIN_DIRECTION_EGRESS_E) || (direction == SMAIN_DIRECTION_INGRESS_E))
    {
        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr, policerIpfixRegPtr,
            descrPtr->countingActuallAccessedIndex,
            SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_LAST_PACKET_COMMAND_E,
            descrPtr->packetCmd);

        if((descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_HARD_DROP_E) ||
           (descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_SOFT_DROP_E) ||
           (descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E) ||
           (descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E))
        {
            /* set the cpu code */
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr, policerIpfixRegPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_LAST_CPU_OR_DROP_CODE_E,
                descrPtr->cpuCode);
        }
        else
        {
            __LOG(("Descriptor packet command %d different than supported\n", descrPtr->packetCmd));
            return;
        }
    }
}

/**
* @internal snetPlrIpfixFirstNPacketsCpuCodeAssign function
* @endinternal
*
* @brief Set Packet CPU Code for First N Packets in the IPLR/EPLR
*/
GT_BOOL snetPlrIpfixFirstNPacketsCpuCodeAssign
(
    IN    SKERNEL_DEVICE_OBJECT           * devObjPtr,
    SKERNEL_EXT_PACKET_CMD_ENT            oldPacketCmd,
    SKERNEL_EXT_PACKET_CMD_ENT            firstNPacketCmd
)
{
    DECLARE_FUNC_NAME(snetPlrIpfixFirstNPacketsCpuCodeAssign);

    __LOG(("\noldPacketCmd\n"));
    simLogPacketDescrPacketCmdDump(devObjPtr, oldPacketCmd);
    __LOG(("\nfirstNPacketCmd\n"));
    simLogPacketDescrPacketCmdDump(devObjPtr, firstNPacketCmd);

    if (oldPacketCmd > SKERNEL_EXT_PKT_CMD_SOFT_DROP_E)
    {
        __LOG(("ipfixFirstNResolvedCpuCodeTable: unsupported new command: %d\n", oldPacketCmd));
        return GT_FALSE;
    }
    else
    {
        return ipfixFirstNResolvedCpuCodeTable[oldPacketCmd][firstNPacketCmd];
    }
}

/**
* @internal snetPlrIpfixFirstNPacketsCmdOvrd function
* @endinternal
*
* @brief Set Packet Command and CPU Code for First N Packets in the IPLR/EPLR
*/
GT_VOID snetPlrIpfixFirstNPacketsCmdOvrd
(
    IN    SKERNEL_DEVICE_OBJECT           * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN    SMAIN_DIRECTION_ENT               direction,
    IN    GT_BOOL                           setMirrorFirstPackets
)
{
    GT_U32                     regAddr;      /* Register address */
    GT_U32                     fldValue;     /* register field value */
    SKERNEL_EXT_PACKET_CMD_ENT packetCmd;    /* Packet command for first packet of a flow */
    SNET_CHEETAH_CPU_CODE_ENT  cpuCode;      /* CPU code for first packet of a flow */
    SKERNEL_EXT_PACKET_CMD_ENT packetCmdRes; /* Packet command resolution based on descriptor pktCmd and configured first pktCmd */

    DECLARE_FUNC_NAME(snetPlrIpfixFirstNPacketsCmdOvrd);

    /* IPFIX First N packet command and cpu code in Cfg0 Register */
    regAddr = SMEM_SIP6_10_POLICER_IPFIX_FIRST_N_PACKETS_CONFIG0_REG(devObjPtr, descrPtr->policerCycle);
    smemRegGet(devObjPtr, regAddr, &fldValue);

    packetCmd = SMEM_U32_GET_FIELD(fldValue, 0, 3);
    cpuCode   = SMEM_U32_GET_FIELD(fldValue, 3, 8);
    __LOG(("\nFirstNPktCmd\n"));
    simLogPacketDescrPacketCmdDump(devObjPtr, packetCmd);
    __LOG(("\nDescriptorPktCmd\n"));
    simLogPacketDescrPacketCmdDump(devObjPtr, descrPtr->packetCmd);
    __LOG(("\ncpuCode %d\n", cpuCode));

    if(setMirrorFirstPackets == GT_TRUE)
    {
        if((packetCmd != SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E) &&
         (packetCmd != SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E))
        {
            __LOG(("FirstNPktCmd should be MIRROR or TRAP\n"));
            return;
        }

        /* Apply packet new command */
        __LOG(("Apply packet new command"));
        packetCmdRes = snetChtPktCmdResolution(descrPtr->packetCmd, packetCmd);
        __LOG(("\nFirstNPktCmdAfterMatrixResolution\n"));
        simLogPacketDescrPacketCmdDump(devObjPtr, packetCmdRes);

        if(snetPlrIpfixFirstNPacketsCpuCodeAssign(devObjPtr, descrPtr->packetCmd, packetCmd) == GT_TRUE)
        {
            if(descrPtr->lmuEn)
            {
                __LOG(("Mirror FirstNPacketCmdOvrd: LmCaptureFailed CPU code\n"));
            }
            else
            {
                descrPtr->cpuCode = cpuCode;
                __LOG(("Set CpuCode to FirstNCpuCode: %d\n", cpuCode));
            }
        }
        descrPtr->packetCmd = packetCmdRes;
    }
    else
    {
        __LOG(("Mirroring of 1st N packets is not allowed\n"));
    }
}

/**
* @internal snetPlrIpfixLookup1FirstNPacketsEntrySet function
* @endinternal
*
* @brief Set IPFIX entry for First N Packets in the IPLR/EPLR
*/
GT_VOID snetPlrIpfixLookup1FirstNPacketsEntrySet
(
    IN    SKERNEL_DEVICE_OBJECT           * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN    SMAIN_DIRECTION_ENT               direction,
    OUT   GT_BOOL                         * setMirrorFirstPacketsPtr
)
{

    GT_U32                                        regAddr;                /* Register address */
    GT_U32                                        * regPtr;               /* Register pointer */
    GT_U32                                        ipfixBaseFlowId;        /* IPFIX base flow-id */
    GT_U32                                        policerCntIndex = 0;    /* IPFIX entry index */
    SNET_XCAT_POLICER_IPFIX_SAMPLE_MODE_ENT       sampleMode;             /* IPFIX Sampling mode */
    GT_U32                                        * policerIpfixRegPtr;   /* pointer to IPFix entry */
    GT_U32                                        firstPacketsCounter;    /* First packets counter */
    GT_BOOL                                       firstTimestampValid;    /* first timestamp valid flag */
    GT_U32                                        numFirstPacketsToMirror;/* number of first packets to mirror */
    GT_U32                                        mirrorFirstPackets;     /* flag to denote mirror packets */
    GT_BOOL                                       ipfixEntry;             /* check if entry type is IPFIX */
    GT_BOOL                                       retVal;                 /* return value */
    GT_U32                                        bytesCount;             /* IPFIX byte count */
    GT_BOOL                                       plrCounterMode;         /* policer counting mode disabled or not*/

    DECLARE_FUNC_NAME(snetPlrIpfixLookup1FirstNPacketsEntrySet);

    /* check the entry type */
    plrCounterMode = snetPlrCountingModeBillingIpfixCheck(devObjPtr, descrPtr);
    if(!plrCounterMode)
    {
        __LOG(("Policer stage [%d] BILLING/IPFIX mode in disabed mode\n", descrPtr->policerCycle));
        return;
    }

    /* For AC5P when ipfixEnable is set then index to IPFIX table is computed as below */
    /* ipfixEnable field is used only by IPLR0 and EPLR */
    if(descrPtr->ipfixEnable)
    {
        /* IPFIX En is supported in IPLR0 and EPLR*/
        if((descrPtr->policerCycle == 0/*IPLR0*/ || descrPtr->policerCycle == 2/*EPLR*/))
        {
            regAddr = SMEM_XCAT_POLICER_IPFIX_CTRL_REG(devObjPtr, descrPtr->policerCycle);
            regPtr = smemMemGet(devObjPtr, regAddr);

            /* Compute the ipfix entry index */
            ipfixBaseFlowId = SNET_XCAT_POLICER_IPFIX_BASE_FLOW_ID_GET_MAC(regPtr);
            policerCntIndex = descrPtr->flowId >= ipfixBaseFlowId ? (descrPtr->flowId - ipfixBaseFlowId) : 0;

            if(descrPtr->flowId < ipfixBaseFlowId)
            {
                __LOG(("Misconfiguration: Desc Flow id %d cannot be less than IPFIX base flow id %d\n",
                      descrPtr->flowId, ipfixBaseFlowId));
                return;
            }

            /* update the actual counting index */
            descrPtr->countingActuallAccessedIndex = policerCntIndex;
        }
        else
        {
            __LOG(("IPFIX En is supported only in IPLR0 and EPLR\n"));
            return;
        }
    }
    else
    {
        __LOG(("IPFIX En is not set, legacy IPFIX access\n"));
        return;
    }

    /* ipfix entry pointer */
    regAddr = SMEM_XCAT_POLICER_CNT_ENTRY_TBL_MEM(devObjPtr, direction,
                                                  descrPtr->policerCycle,
                                                  policerCntIndex);

    descrPtr->policerCounterEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);
    policerIpfixRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    /* check the entry type */
    ipfixEntry = snetPlrEntryTypeCheck(devObjPtr, descrPtr, policerCntIndex, direction);

    /* IPfix */
    /* For AC5P devices, IPFIX table is accessed using ipfixEnable field as well as part of lookup1 in same PLR unit */
    if(ipfixEntry)
    {
        __LOG(("The Counter entry is 'IPFIX' format \n"));

        /* Check IPFix counters state  */
        retVal = snetXCatPolicerIPFixCountersFreezeCheck(devObjPtr, descrPtr);
        /* IPFix counters in freeze state */
        if(retVal == GT_FALSE)
        {
            return;
        }

        /* we only now how to calc the byte count for the billing/ipfix calculation */
        __LOG(("Calc num bytes needed for IPFIX purpose , index[0x%x] \n",
            policerCntIndex));
        snetLion3PolicerPacketSizeGet(devObjPtr, descrPtr, direction,
                                     ipfixEntry ?
                                     /*IPfix*/ SNET_LION3_POLICER_PACKET_SIZE_FROM_GLOBAL_CONFIG_E :
                                     SNET_LION3_POLICER_PACKET_SIZE_FROM_BILLING_ENTRY_E,
                                     policerIpfixRegPtr,
                                     &bytesCount);

        /* IPFIX Per-Flow Packet Counters */
        retVal = snetXCatPolicerIPFixCounterIncrement(devObjPtr, descrPtr,
                                                      policerCntIndex,
                                                      bytesCount);

        /* IPFix counters successfully incremented */
        if(retVal == GT_TRUE)
        {
            /* IPFIX Per-Flow Packet Sampling */
            snetXCatPolicerIPFixSampling(devObjPtr, descrPtr,
                                         policerCntIndex);
        }
    }
    else
    {
        __LOG(("The entry is not of IPFIX type\n"));
        return;
    }

    sampleMode = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,policerIpfixRegPtr,
                                                      descrPtr->countingActuallAccessedIndex,
                                                      SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_MODE_E);

    /* Update timestamp and forwarding status for the IPFIX entry */
    if(sampleMode == SNET_XCAT_POLICER_SAMPLE_MODE_DISABLE_E)
    {
        firstTimestampValid = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,policerIpfixRegPtr,
            descrPtr->countingActuallAccessedIndex,
            SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_TIMESTAMP_VALID_E);
        /* First Timestamp */
        if(!firstTimestampValid)
        {
            /* Update first timestamp field of IPFIX entry for First N Packets */
            snetPlrFirstNPacketsFirstTimestampUpdate(devObjPtr, descrPtr, policerIpfixRegPtr);
        }
        else
        {
            __LOG(("First Timestamp Valid set\n"));
        }
        /* Update the forwarding Status for 1st N packets */
        /* set the forwarding Status for 1st N packets */
        snetMirrorPacketsForwardingStatusSet(devObjPtr, descrPtr, policerIpfixRegPtr, direction);

        firstPacketsCounter = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,policerIpfixRegPtr,
                                                                   descrPtr->countingActuallAccessedIndex,
                                                                   SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_PACKETS_COUNTER_E);
        firstPacketsCounter++;
        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,policerIpfixRegPtr,
                                             descrPtr->countingActuallAccessedIndex,
                                             SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_PACKETS_COUNTER_E,
                                             firstPacketsCounter);
        regAddr =
            SMEM_SIP6_10_POLICER_IPFIX_FIRST_N_PACKETS_TBL_MEM(devObjPtr,
                                                               descrPtr->policerCycle,
                                                               descrPtr->flowId);
        regPtr = smemMemGet(devObjPtr, regAddr);
        /* Check mirror bit for a flow */
        __LOG(("Check mirror bit of a flow"));
        mirrorFirstPackets = SMEM_U32_GET_FIELD(regPtr[0], (descrPtr->flowId % 32), 1);

        if(mirrorFirstPackets)
        {
            numFirstPacketsToMirror = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,policerIpfixRegPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_NUMBER_OF_FIRST_PACKETS_TO_MIRROR_E);
            firstPacketsCounter = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,policerIpfixRegPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_PACKETS_COUNTER_E);

            if(firstPacketsCounter <= numFirstPacketsToMirror)
            {
                *setMirrorFirstPacketsPtr = GT_TRUE;
            }
        }

    }
    else
    {
        __LOG(("Mirroring of First N Packets is allowed only with sampling mode as disabled\n"));
        return;
    }
}

/**
* @internal snetEPlrIpfixLookup1PhaMetadataSet function
* @endinternal
*
* @brief Set PHA metadata in the EPLR
*/
static GT_VOID snetEPlrIpfixLookup1PhaMetadataSet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN    SMAIN_DIRECTION_ENT               direction
)
{
    DECLARE_FUNC_NAME(snetEPlrIpfixLookup1PhaMetadataSet);

    GT_U32                                        regAddr;                /* Register address */
    GT_U32                                        * regPtr;               /* Register pointer */
    GT_U32                                        ipfixBaseFlowId;        /* IPFIX base flow-id */
    GT_U32                                        policerCntIndex;        /* IPFIX entry index */
    SNET_XCAT_POLICER_IPFIX_SAMPLE_MODE_ENT       sampleMode;             /* IPFIX Sampling mode */
    SNET_XCAT_POLICER_IPFIX_PHA_METADATA_MODE_ENT phaMetadataMode;        /* PHA Metadata mode */
    GT_U32                                        * policerIpfixRegPtr;   /* pointer to IPFix entry */
    GT_U64                                        phaMetadata;            /* PHA metadata mode */
    GT_U32                                        firstPacketsCounter;    /* First packets counter */
    GT_U64                                        phaMetadataCounterMask; /* PHA metadata counter mask */
    GT_U16                                        phaMetadataTemp;        /* PHA metadata temporary variable */
    GT_U64                                        outDesc;                /* temporary output descriptor */
    GT_BOOL                                       mirrorFirstPackets;     /* mirror first n packets */
    GT_U32                                        fldValue;               /* register field value */
    GT_BOOL                                       ipfixEntry;             /* check if entry type is IPFIX */
    GT_BOOL                                       plrCounterMode;         /* policer counting mode disabled or not*/

    /* check the entry type */
    plrCounterMode = snetPlrCountingModeBillingIpfixCheck(devObjPtr, descrPtr);
    if(!plrCounterMode)
    {
        __LOG(("Policer stage [%d] BILLING/IPFIX mode in disabed mode\n", descrPtr->policerCycle));
        return;
    }

    phaMetadata.l[0] = 0;
    phaMetadata.l[1] = 0;
    regAddr = SMEM_XCAT_POLICER_IPFIX_CTRL_REG(devObjPtr, descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);

    if(descrPtr->ipfixEnable)
    {
        /* Compute the ipfix entry index */
        ipfixBaseFlowId = SNET_XCAT_POLICER_IPFIX_BASE_FLOW_ID_GET_MAC(regPtr);
        policerCntIndex = descrPtr->flowId > ipfixBaseFlowId ? (descrPtr->flowId - ipfixBaseFlowId) : 0;

        /* update the actual counting index */
        descrPtr->countingActuallAccessedIndex = policerCntIndex;
        /* ipfix entry pointer */
        regAddr = SMEM_XCAT_POLICER_CNT_ENTRY_TBL_MEM(devObjPtr, direction,
                                                      descrPtr->policerCycle,
                                                      policerCntIndex);

        descrPtr->policerCounterEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);
        policerIpfixRegPtr = descrPtr->policerCounterEntryMemoryPtr;
        /* check the entry type */
        ipfixEntry = snetPlrEntryTypeCheck(devObjPtr, descrPtr, policerCntIndex, direction);
        if(!ipfixEntry)
        {
            __LOG(("The entry is not of IPFIX type\n"));
            return;
        }

        sampleMode = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,policerIpfixRegPtr,
                                                          descrPtr->countingActuallAccessedIndex,
                                                          SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_MODE_E);

        regAddr =
            SMEM_SIP6_10_POLICER_IPFIX_FIRST_N_PACKETS_TBL_MEM(devObjPtr,
                                                               descrPtr->policerCycle,
                                                               descrPtr->flowId);
        regPtr = smemMemGet(devObjPtr, regAddr);

        /* Check mirror bit for a flow */
        __LOG(("Check mirror bit of a flow"));
        mirrorFirstPackets = SMEM_U32_GET_FIELD(regPtr[0], (descrPtr->flowId % 32), 1);

        /* IPFIX entry fetched and sampling mode DISABLE */
        if(policerIpfixRegPtr && sampleMode == SNET_XCAT_POLICER_SAMPLE_MODE_DISABLE_E)
        {
            phaMetadataMode = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,policerIpfixRegPtr,
                                                              descrPtr->countingActuallAccessedIndex,
                                                              SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_PHA_METADATA_MODE_E);

            if(phaMetadataMode == SNET_XCAT_POLICER_IPFIX_PHA_METADATA_MODE_COUNTER_E ||
               phaMetadataMode == SNET_XCAT_POLICER_IPFIX_PHA_METADATA_MODE_RANDOM_E)
            {
                firstPacketsCounter = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,policerIpfixRegPtr,
                                               descrPtr->countingActuallAccessedIndex,
                                               SMEM_SIP6_10_PLR_IPFIX_TABLE_FIELDS_FIRST_PACKETS_COUNTER_E);

                phaMetadata.l[0] = (phaMetadataMode == SNET_XCAT_POLICER_IPFIX_PHA_METADATA_MODE_COUNTER_E) ? firstPacketsCounter : rand() % 10000;
                phaMetadata.l[1] = 0xFFFF;

                /* PHA Metadata Counter Mask High(16b) in Cfg0 Register */
                regAddr = SMEM_SIP6_10_POLICER_IPFIX_FIRST_N_PACKETS_CONFIG1_REG(devObjPtr, descrPtr->policerCycle);
                smemRegGet(devObjPtr, regAddr, &fldValue);
                phaMetadataCounterMask.l[0] = SMEM_U32_GET_FIELD(fldValue, 11, 16);

                /* PHA Metadata Counter Mask Low(32b) in Cfg1 Register */
                regAddr = SMEM_SIP6_10_POLICER_IPFIX_FIRST_N_PACKETS_CONFIG0_REG(devObjPtr, descrPtr->policerCycle);
                smemRegGet(devObjPtr, regAddr, &fldValue);
                phaMetadataCounterMask.l[1] = fldValue;

                phaMetadataTemp = descrPtr->pha.pha_metadata_ext[1];
                phaMetadataTemp = (phaMetadataTemp << 8) | descrPtr->pha.pha_metadata_ext[0];
                outDesc.l[0] = (descrPtr->pha.pha_metadata[0] & phaMetadataCounterMask.l[0]) |
                               (phaMetadata.l[0] & ~phaMetadataCounterMask.l[0]);
                outDesc.l[1] = (phaMetadataTemp & phaMetadataCounterMask.l[1]) |
                               (phaMetadataTemp & ~phaMetadataCounterMask.l[1]);

                descrPtr->pha.pha_metadata[0] = outDesc.l[0];
                descrPtr->pha.pha_metadata_ext[0] = (GT_U8)(outDesc.l[1] & 0xFF);
                descrPtr->pha.pha_metadata_ext[1] = (GT_U8)((outDesc.l[1] & 0xFF00) >> 8);
            }
        }
        else/* IPFIX entry not successfully fetched */
        {
            __LOG(("IPFIX Entry was not fetched\n"));
            if(!mirrorFirstPackets)
            {
                __LOG(("FLOW mirroring is not enabled\n"));
                return;
            }
        }
    }
    else
    {
        __LOG(("IPFIX Enable not set\n"));
        return;
    }
}


/**
* @internal snetXCatEgressPolicer function
* @endinternal
*
* @brief   Egress Policer Processing, Policer Counters updates
*/
void snetXCatEgressPolicer
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 localEgressPort
)
{
    DECLARE_FUNC_NAME(snetXCatEgressPolicer);

    GT_U32 * policerMeterEntryPtr = NULL;   /* Policers Metering Entry Pointer */
    SNET_CHT3_POLICER_QOS_INFO_STC qosProfileInfo;
                                    /* Initial conformance level,
                                       qos profile (index) for out-of-profile
                                       traffic */

    SNET_CHT3_POLICER_MNG_COUNT_STC mngCountData;
                                    /* Management counters data for dropped  packets */
    GT_BOOL forward;                /* GT_TRUE - forward, GT_FALSE - drop packet */
    GT_BOOL isTrigger;
    GT_STATUS retVal;
    GT_U32  eplrTargetPort;          /* target port for EPLR processing */
    GT_U32  regAddr;                 /* register address */
    GT_U32  fieldVal;                /* field's value */
    GT_BIT  skipEplr = 0;            /* skip metering and counting for specific traffic */
    SNET_LION3_POLICER_METERING_DATA_STC meteringData;
    GT_BOOL setMirrorFirstPackets = GT_FALSE;/* SIP6.10: if set, mirror of 1st N packets happens */

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* EPLR physical port is global one. */
        /* For SIP5 the "local egress port" is the global. */
        __LOG(("EPLR physical port is global one"));
        eplrTargetPort = localEgressPort;
    }
    else
    {
        /* EPLR physical port is 6 bits of global one */
        __LOG(("EPLR physical port is 6 bits of global one"));
        eplrTargetPort = (SMEM_CHT_GLOBAL_PORT_FROM_LOCAL_PORT_MAC(devObjPtr, localEgressPort) & 0x3F);
    }

    /* Egress policer - is named 'cycle' 2 */
    descrPtr->policerCycle = 2;

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* Egress OAM processing */
        __LOG(("Egress OAM processing \n"));
        snetLion2EOamProcess(devObjPtr, descrPtr);

        if(SMEM_CHT_IS_SIP5_10_GET(devObjPtr))
        {
            regAddr = SMEM_XCAT_POLICER_GLB1_CONF_REG(devObjPtr,descrPtr->policerCycle);

            if (descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_TO_CPU_E)
            {
                /* En To Cpu Meter And Count  */
                smemRegFldGet(devObjPtr, regAddr, 10, 1, &fieldVal);
                if (fieldVal == 0)
                {
                    skipEplr = 1;
                    __LOG(("TO CPU: Skip EPLR Meter and Count\n"));
                }
            }
            else if (descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_TO_TRG_SNIFFER_E)
            {
                /* En To Analyzer Meter And Count  */
                smemRegFldGet(devObjPtr, regAddr, 11, 1, &fieldVal);
                if (fieldVal == 0)
                {
                    skipEplr = 1;
                    __LOG(("TO ANALYZER: Skip EPLR Meter and Count\n"));
                }
            }
        }
    }

    if (!skipEplr)
    {
        /* Check if policer needed */
        __LOG(("Check if policer needed \n"));
        isTrigger = snetXCatEgressPolicerTriggeringCheck(devObjPtr, descrPtr,
                                                      eplrTargetPort,
                                                      &policerMeterEntryPtr);

        if(isTrigger == GT_FALSE)
        {
            policerMeterEntryPtr = NULL;
        }

        retVal = snetXCatCommonPolicerMeteringEnvelopeDataGet(
            devObjPtr, descrPtr, policerMeterEntryPtr, 1/*isEgress*/, &meteringData);
        if (retVal == GT_OK)
        {
            /* for SIP5_15 policerMeterEntryPtr not relevant for any algorithm */
            /* it points buckets entry only                                    */
            /* for metering MEF10.3 envelope fields below should be updated    */
            descrPtr->policerMeterConfigEntryMemoryPtr          =
                meteringData.meterCfgEntryPtr;
            descrPtr->policerConformanceLevelSignEntryMemoryPtr =
                meteringData.meterConformSignLevelPtr;
            descrPtr->policerActuallAccessedIndex =
                (meteringData.envelopeBaseIndex + meteringData.packetRank);
        }
        else
        {
            snetXCatCommonPolicerMeteringSingleDataGet(
                devObjPtr, descrPtr, policerMeterEntryPtr, &meteringData);
        }

        /* Get conformance level and qos profile for out-of-profile traffic */
        __LOG(("Get conformance level and qos profile for out-of-profile traffic \n"));
        snetXCatEgressPolicerConformanceLevelGet(devObjPtr, descrPtr,
                                                 &meteringData,
                                                 &qosProfileInfo);

        /* Update ECN fields in IP packets */
        __LOG(("Update ECN fields in IP packets \n"));
        snetXCatEgressEcnUpdate(devObjPtr, descrPtr, &qosProfileInfo);

        /* Remark out-of-profile traffic */
        __LOG(("Remark out-of-profile traffic \n"));
        forward = snetXCatEgressPolicerQosRemark(devObjPtr, descrPtr, policerMeterEntryPtr,
                                       &qosProfileInfo, &mngCountData);

        /* Update policer counters */
        __LOG(("Update policer counters \n"));
        snetXCatEgressPolicerCountersUpdate(devObjPtr, descrPtr,
                                            policerMeterEntryPtr, forward,
                                            &qosProfileInfo,
                                            eplrTargetPort,
                                            &mngCountData);

        if(SMEM_CHT_IS_SIP6_GET(devObjPtr))
        {
            /* call PLR to update 'per meter' mirroring to analyzer */
            snetSip6PolicerMeterMirrorCheck(devObjPtr, descrPtr, &qosProfileInfo , GT_TRUE/*egress*/);
        }

        if(forward == GT_FALSE)
        {
            /* will cause to drop the packet */
            __LOG(("will cause to drop the packet \n"));
            descrPtr->eplrAction.drop = SKERNEL_EXT_PKT_CMD_HARD_DROP_E;
        }

        if(SMEM_CHT_IS_SIP6_10_GET(devObjPtr))
        {
            if(snetXcatPolicerIsIpfix(devObjPtr, descrPtr) == GT_TRUE)
            {
                /* call EPLR to set IPFIX entry for 1st N packets */
                snetPlrIpfixLookup1FirstNPacketsEntrySet(devObjPtr, descrPtr, SMAIN_DIRECTION_EGRESS_E, &setMirrorFirstPackets);

                /* call EPLR to set PHA metadata */
                __LOG(("Update PHA metadata \n"));
                snetEPlrIpfixLookup1PhaMetadataSet(devObjPtr, descrPtr, SMAIN_DIRECTION_EGRESS_E);

                /* call EPLR to set mirror of 1st N packets */
                __LOG(("Set Mirror 1st N Packet \n"));
                snetPlrIpfixFirstNPacketsCmdOvrd(devObjPtr, descrPtr, SMAIN_DIRECTION_EGRESS_E, setMirrorFirstPackets);
            }
        }
    }

    descrPtr->policerCounterGlobalNumBytes = 0;

    return ;
}

/**
* @internal snetXCatPolicerIPFixCntWrapCheck function
* @endinternal
*
* @brief   Check counters wraparounds for configurable pre-wraparound threshold.
*/
static GT_BOOL snetXCatPolicerIPFixCntWrapCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT GT_U32 * goodPcktsPtr,
    INOUT GT_U32 * dropPcktsPtr,
    INOUT GT_U64 * bytesCntPtr,
    IN GT_U32 bytes
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixCntWrapCheck);

    GT_U32 regAddr;                         /* Register address */
    GT_U32 * regPtr;                        /* Register pointer */
    GT_U32 treshold;                        /* Wrap around treshold */
    GT_U64 treshold64;                      /* Wrap around treshold - 64 Bits */
    GT_BIT wrapAction;                      /* Wrap around action freeze/clear */
    GT_BOOL wrapTriggered;                  /* Wrap around trigger */
    GT_BIT dropCountEn;                     /* Enable dropped packets counting */

    wrapTriggered = GT_FALSE;

    if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
    {
        descrPtr->ipfixErrataData.freezeCounter = SNET_XCAT_POLICER_IPFIX_UNKNOWN_COUNT_E;
    }

    /* IPFIX Control */
    __LOG(("IPFIX Control"));
    regAddr = SMEM_XCAT_POLICER_IPFIX_CTRL_REG(devObjPtr,
                                                   descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);

    wrapAction = SNET_XCAT_POLICER_IPFIX_WA_ACTION_GET_MAC(regPtr);
    dropCountEn = SNET_XCAT_POLICER_IPFIX_DROP_COUNT_EN_GET_MAC(regPtr);

    /* Drop packet wrap around treshold */
    regAddr = SMEM_XCAT_POLICER_IPFIX_DROP_CNT_WA_TRESH_REG(devObjPtr,
                                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold = regPtr[0];
    __LOG(("Drop packet wrap around threshold \n"));
    __LOG_PARAM(treshold);

    /* Wrap around check - DROP packets counter */
    __LOG(("Wrap around check - DROP packets counter"));
    snetXcatPolicerIpfixDropWaCheck(devObjPtr, descrPtr,
                                    dropCountEn, dropPcktsPtr, treshold,
                                    wrapAction, &wrapTriggered);

    /* Good packet wrap around treshold */
    regAddr = SMEM_XCAT_POLICER_IPFIX_PCKT_CNT_WA_TRESH_REG(devObjPtr,
                                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold = regPtr[0];
    __LOG(("Good packet wrap around threshold \n"));
    __LOG_PARAM(treshold);

    /* Wrap around check - GOOD packets counter */
    __LOG(("Wrap around check - GOOD packets counter"));
    snetXcatPolicerIpfixGoodPcktWaCheck(devObjPtr, descrPtr,
                                              goodPcktsPtr, treshold,
                                        wrapAction, &wrapTriggered);

    /* Byte count wrap around threshold LSB */
    regAddr = SMEM_XCAT_POLICER_IPFIX_BYTE_CNT_LSB_WA_TRESH_REG(devObjPtr,
                                                                    descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold64.l[0] = regPtr[0];
    treshold64.l[1] = regPtr[1];
    __LOG(("Byte count wrap around threshold \n"));
    __LOG_PARAM(treshold64.l[0]);
    __LOG_PARAM(treshold64.l[1]);

    /* Wrap around check - BYTES counter */
    __LOG(("Wrap around check - BYTES counter"));
    snetXcatPolicerIpfixBytesWaCheck(devObjPtr, descrPtr,
                                     bytesCntPtr, bytes, &treshold64,
                                     wrapAction, &wrapTriggered);

    if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
    {
        switch (descrPtr->ipfixErrataData.freezeCounter)
        {
            case SNET_XCAT_POLICER_IPFIX_DROP_PKTS_COUNT_E:
                *goodPcktsPtr =
                    descrPtr->ipfixErrataData.prevPckts[SNET_XCAT_POLICER_IPFIX_GOOD_PKTS_COUNT_E];
                *bytesCntPtr =
                    descrPtr->ipfixErrataData.prevBytesCnt;
                break;
            case SNET_XCAT_POLICER_IPFIX_GOOD_PKTS_COUNT_E:
                *bytesCntPtr =
                    descrPtr->ipfixErrataData.prevBytesCnt;
                *dropPcktsPtr =
                    descrPtr->ipfixErrataData.prevPckts[SNET_XCAT_POLICER_IPFIX_DROP_PKTS_COUNT_E];
                break;
            case SNET_XCAT_POLICER_IPFIX_BYTES_COUNT_E:
                *goodPcktsPtr =
                    descrPtr->ipfixErrataData.prevPckts[SNET_XCAT_POLICER_IPFIX_GOOD_PKTS_COUNT_E];
                *dropPcktsPtr =
                    descrPtr->ipfixErrataData.prevPckts[SNET_XCAT_POLICER_IPFIX_DROP_PKTS_COUNT_E];
                break;
            default:
                break;
        }
    }

    return wrapTriggered;
}

/**
* @internal snetXcatPolicerIPFixSampleLogSet function
* @endinternal
*
* @brief   IPFIX entries that have triggered Alarm events are stored in
*         IPFIX Sample Entry Log
* @param[in] devObjPtr                - pointer to device object.
* @param[in] sampleLogPtr             - pointer to IPFIX Sample Entry Log
* @param[in] policerCntIndex          - policer IPFix entry index
*/
static GT_VOID snetXcatPolicerIPFixSampleLogSet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 * sampleLogPtr,
    IN GT_U32 policerCntIndex
)
{
    DECLARE_FUNC_NAME(snetXcatPolicerIPFixSampleLogSet);

    GT_U32 i;
    GT_U32 entryArr[4];
    GT_U32 firstNonUsedIndex = SMAIN_NOT_VALID_CNS;
    GT_U32 updatedIndex;
    GT_U32 startBit;

    /* NOTE:
        word 0 bits  0..15 --> index 0 (most recent)
        word 1 bits 16..31 --> index 1
        word 2 bits  0..15 --> index 2
        word 3 bits 16..31 --> index 3 (least recent)
    */

    /* Loop over 4 Sample Log entries and find first invalid entry */
    for(i = 0; i < 4; i++)
    {
        startBit = 16*i;
        entryArr[i] = snetFieldValueGet(sampleLogPtr,startBit,16);

        if(entryArr[i] == 0 && firstNonUsedIndex == SMAIN_NOT_VALID_CNS)
        {
            /* first non used index */
            firstNonUsedIndex = i;
        }
    }

    if(firstNonUsedIndex < 4)
    {
        updatedIndex = firstNonUsedIndex;

        startBit = 16*updatedIndex;

        /*set the empty index */
        snetFieldValueSet(sampleLogPtr, 0 + startBit,15,policerCntIndex);
        /*valid bit*/
        snetFieldValueSet(sampleLogPtr,15 + startBit, 1,      1);

        __LOG(("wrote new info to index[%d] about policerCntIndex[0x%x]\n",
            updatedIndex , policerCntIndex));
    }
    else
    {
        /* push the 3 existing values : 0-->1 , 1-->2 , 2-->3 */
        for(updatedIndex = 1 ; updatedIndex < 4 ; updatedIndex++)
        {
            startBit = 16*updatedIndex;
            snetFieldValueSet(sampleLogPtr, startBit,16,entryArr[updatedIndex-1]);
        }

        updatedIndex = 0;
        startBit = 16*updatedIndex;
        /*set the first index */
        snetFieldValueSet(sampleLogPtr, 0 + startBit,15,policerCntIndex);
        /*valid bit*/
        snetFieldValueSet(sampleLogPtr,15 + startBit, 1,      1);

        __LOG(("wrote new info to index[%d] about policerCntIndex[0x%x] (and pushed 3 others) \n",
            updatedIndex , policerCntIndex));
    }
}

/**
* @internal snetXCatPolicerIPFixSampleAlarm function
* @endinternal
*
* @brief   IPFIX Sampling Alarm action
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in] descrPtr                 - packet descriptor
* @param[in] policerCntIndex          - policer IPFix entry index
*/
static GT_VOID snetXCatPolicerIPFixSampleAlarm
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 policerCntIndex
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixSampleAlarm);

    GT_U32 regAddr;                 /* Register address */
    GT_U32 * sampleLogPtr;          /* pointer to IPFIX Sample Entry Log */

    /* Sample Entry Log0 */
    regAddr =
        SMEM_XCAT_POLICER_IPFIX_SAMPLE_LOG0_REG(devObjPtr,
                                                    descrPtr->policerCycle);
    sampleLogPtr = smemMemGet(devObjPtr, regAddr);

    /* The index of the IPFIX entry that triggered the alarm is stored in a CPU-readable register */
    __LOG(("The index of the IPFIX entry that triggered the alarm is stored in a CPU-readable register"));
    snetXcatPolicerIPFixSampleLogSet(devObjPtr, sampleLogPtr, policerCntIndex);

    /* Interrupt is sent to the CPU */
    __LOG(("Interrupt is sent to the CPU \n"));
    snetChetahDoInterrupt(devObjPtr,
          SMEM_XCAT_POLICER_IPFIX_INT_CAUSE_REG(devObjPtr,  descrPtr->policerCycle),
          SMEM_XCAT_POLICER_IPFIX_INT_MASK_REG(devObjPtr, descrPtr->policerCycle),
          SNET_XCAT_POLICER_INTR_IPFIX_ALARM_E,
          (descrPtr->policerCycle == 0) ?
                          SNET_XCAT_INGR_POLICER0_INTR_SUM_E(devObjPtr) :
                          SNET_XCAT_INGR_POLICER1_INTR_SUM_E(devObjPtr));
}

/**
* @internal snetXCatPolicerIPFixSampleActionApply function
* @endinternal
*
* @brief   IPFIX Sampling action apply
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in] descrPtr                 - packet descriptor
* @param[in] policerCntIndex          - policer IPFix entry index
* @param[in] sampleMode               - sampling mode
* @param[in,out] ipFixSampleDataPtr       - pointer to IPFix sampling related data
* @param[in,out] ipFixSampleDataPtr       - pointer to IPFix sampling related data
*                                      RETURN:
*/
static GT_VOID snetXCatPolicerIPFixSampleActionApply
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 policerCntIndex,
    IN SNET_XCAT_POLICER_IPFIX_SAMPLE_MODE_ENT sampleMode,
    INOUT SNET_XCAT_POLICER_IPFIX_SAMPLE_STC * ipFixSampleDataPtr
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixSampleActionApply);

    GT_U32 regAddr;                 /* Register address */
    GT_U32 * ipfixCtrlRegPtr;       /* IPFIX control register data */
    GT_U32 ipFixTimeStampValue;     /* IPFIX time stamp value */

    __LOG(("IPFIX Sampling action apply : start \n"));

    /* Get current time stamp value */
    ipFixTimeStampValue =
        SNET_XCAT_IPFIX_TOD_CLOCK_GET_MAC(devObjPtr, descrPtr->policerCycle);

    /* IPFIX Control */
    regAddr = SMEM_XCAT_POLICER_IPFIX_CTRL_REG(devObjPtr,
                                                   descrPtr->policerCycle);
    ipfixCtrlRegPtr = smemMemGet(devObjPtr, regAddr);

    switch(ipFixSampleDataPtr->sampleAction)
    {
        case SNET_XCAT_POLICER_IPFIX_SAMPLE_ALARM_E:
            __LOG(("IPFIX_SAMPLE_ALARM_E : start \n"));
            snetXCatPolicerIPFixSampleAlarm(devObjPtr, descrPtr, policerCntIndex);
            __LOG(("IPFIX_SAMPLE_ALARM_E : end \n"));
            break;
        case SNET_XCAT_POLICER_IPFIX_SAMPLE_MIRROR_E:
            if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FORWARD_E)
            {
                __LOG(("IPFIX_SAMPLE_MIRROR_E : modify packet command from 'FORWARD' to 'MIRROR_TO_CPU' \n"));
                descrPtr->packetCmd = SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E;
            }
            else
            if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_SOFT_DROP_E)
            {
                __LOG(("IPFIX_SAMPLE_MIRROR_E : modify packet command from 'SOFT_DROP' to 'TRAP_TO_CPU' \n"));
                descrPtr->packetCmd = SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E;
            }
            else
            {
                /* don't change command */
                __LOG(("IPFIX_SAMPLE_MIRROR_E : don't change command \n"));
                break;
            }
            /* CPU code for sampled packets */
            descrPtr->cpuCode = ipFixSampleDataPtr->cpuSubCode |
                (SNET_XCAT_POLICER_IPFIX_CPU_CODE_GET_MAC(ipfixCtrlRegPtr) << 2);
            /* Timestamp of the last reception of a packet from the corresponding flow */
            descrPtr->ipFixTimeStampValue = ipFixTimeStampValue;
            break;
        default:
            break;
    }

    if(ipFixSampleDataPtr->randomEnable)
    {
        /* Updated every time a packet is marked for sampling */
        ipFixSampleDataPtr->randomOffset =
            rand() % ipFixSampleDataPtr->sampleRange;
    }

    if (sampleMode == SNET_XCAT_POLICER_SAMPLE_MODE_TIME_E)
    {
        /* First time last sample value updated by current time stamp */
        if (ipFixSampleDataPtr->lastSampleValue64.l[0] == 0)
        {
            ipFixSampleDataPtr->lastSampleValue64.l[0] = ipFixTimeStampValue;
        }
    }

    /* Updated every time a packet is marked for sampling */
    ipFixSampleDataPtr->lastSampleValue64 =
            prvSimMathAdd64(ipFixSampleDataPtr->lastSampleValue64,
                            ipFixSampleDataPtr->sampleWindow64);


    __LOG(("IPFIX Sampling action apply : end \n"));

}

/**
* @internal snetXCatPolicerIPFixSampling function
* @endinternal
*
* @brief   IPFIX Per-Flow Packet Sampling
*/
GT_VOID snetXCatPolicerIPFixSampling
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 policerCntIndex
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixSampling);

    SNET_XCAT_POLICER_IPFIX_SAMPLE_MODE_ENT sampleMode; /* Sampling mode */
    GT_U64 currSampleValue64;                   /* Current Sampled Value */
    GT_U64 refSampleValue64;                    /* Reference Sampled Value */
    GT_U64 bytesCnt;                            /* bytes counter value */
    GT_U32 goodPckts, timeStamp, dropPckts;     /* good packets, drop packets value */
    GT_32 retVal;                               /* return value */
    GT_U32 * policerIpfixRegPtr;                /* pointer to IPFix entry */
    SNET_XCAT_POLICER_IPFIX_SAMPLE_STC  ipFixSampleData; /* Policer IPFix Sampling related info */
    SNET_XCAT_SIP6_10_POLICER_IPFIX_SAMPLE_STC  ipFixSip6_10SampleData; /* Policer IPFix Sip6_10 Sampling related info */

    /* Billing counter entry pointer */
    policerIpfixRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        sampleMode =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,policerIpfixRegPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_MODE_E);
    }
    else
    {
        sampleMode = SMEM_U32_GET_FIELD(policerIpfixRegPtr[2], 18, 2);
    }

    currSampleValue64.l[0] = currSampleValue64.l[1] = 0;

    /* Read IPFIX flow counters: packet counter, byte counter, drop counter */
    snetXcatPolicerIpfixCounterRead(devObjPtr,descrPtr,policerIpfixRegPtr,
                             &bytesCnt, &goodPckts, &timeStamp, &dropPckts);

    switch(sampleMode)
    {
        case SNET_XCAT_POLICER_SAMPLE_MODE_PCKT_E:
            currSampleValue64.l[0] = goodPckts;
            break;
        case SNET_XCAT_POLICER_SAMPLE_MODE_BYTE_E:
            currSampleValue64.l[0] = bytesCnt.l[0];
            currSampleValue64.l[1] = bytesCnt.l[1];
            break;
        case SNET_XCAT_POLICER_SAMPLE_MODE_TIME_E:
            currSampleValue64.l[0] = timeStamp;
            break;
        case SNET_XCAT_POLICER_SAMPLE_MODE_DISABLE_E:
            break;
        default:
            /* Illegal Sampling Counting Mode */
            __LOG(("Illegal Sampling Counting Mode [%d] \n",
                sampleMode));
            return;

    }
    /* Get all sampling relevant fields from IPFIX entry */
    __LOG(("Get all sampling relevant fields from IPFIX entry \n"));
    if(SMEM_CHT_IS_SIP6_10_GET(devObjPtr) && (sampleMode == SNET_XCAT_POLICER_SAMPLE_MODE_DISABLE_E))
    {
        snetXcatPolicerIpfixSip6_10SampleValuesGet(devObjPtr,descrPtr,policerIpfixRegPtr, &ipFixSip6_10SampleData);
        /* Set sampling relevant fields to IPFIX entry */
        __LOG(("Set sampling relevant fields to IPFIX entry \n"));
        snetXcatPolicerIpfixSip6_10SampleValuesSet(devObjPtr,descrPtr,policerIpfixRegPtr, &ipFixSip6_10SampleData);
    }
    else
    {
        snetXcatPolicerIpfixSampleValuesGet(devObjPtr,descrPtr,policerIpfixRegPtr, &ipFixSampleData);
        /* Calculate reference sample value */
        __LOG(("Calculate reference sample value"));
        refSampleValue64 = prvSimMathAdd64(ipFixSampleData.lastSampleValue64,
                                           ipFixSampleData.sampleWindow64);
        if(ipFixSampleData.randomOffset)
        {
            GT_U64 val64;
            CNV_U32_TO_U64(ipFixSampleData.randomOffset, val64);
            refSampleValue64 = prvSimMathAdd64(refSampleValue64, val64);
        }

        /* Compare current sample and reference sample values */
        __LOG(("Compare current sample and reference sample values \n"));
        retVal = COMPARE_TWO_U64_VALUES_MAC(currSampleValue64, refSampleValue64);
        if(retVal > 0)
        {
            snetXCatPolicerIPFixSampleActionApply(devObjPtr, descrPtr,
                                                  policerCntIndex,
                                                  sampleMode,
                                                  &ipFixSampleData);
        }
        /* Set sampling relevant fields to IPFIX entry */
        __LOG(("Set sampling relevant fields to IPFIX entry \n"));
        snetXcatPolicerIpfixSampleValuesSet(devObjPtr,descrPtr,policerIpfixRegPtr, &ipFixSampleData);
    }
}

/**
* @internal snetXCatPolicerIPFixCounterIncrement function
* @endinternal
*
* @brief   Increment Policer IPFix Counters
*/
GT_BOOL snetXCatPolicerIPFixCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 policerCntIndex,
    IN GT_U32 bytes
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixCounterIncrement);

    GT_U64 bytesCnt;                        /* bytes counter value */
    GT_U32 goodPckts, timeStamp, dropPckts; /* good packets, time stamp, drop packets value */
    GT_BOOL wrapTriggered;                  /* wrap around has(not) been triggered */
    GT_U32 regAddr;                         /* register address */
    GT_U32 * regPtr;                        /* register pointer */
    GT_U32 fieldVal;                        /* register field value */
    GT_U32 * policerIpfixRegPtr;            /* pointer to IPFix entry */
    GT_U32 clockVal;                        /* number of clock ticks */
    GT_BIT aging;                           /* IPfix aging enable bit */


    /* Policers Counters Table Entry */
    policerIpfixRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    /* Read IPFIX flow counters: packet counter, byte counter, drop counter */
    __LOG(("Read IPFIX flow counters: packet counter, byte counter, drop counter"));
    snetXcatPolicerIpfixCounterRead(devObjPtr,descrPtr,policerIpfixRegPtr,
                             &bytesCnt, &goodPckts, &timeStamp, &dropPckts);

    clockVal = SNET_XCAT_IPFIX_TOD_CLOCK_GET_MAC(devObjPtr, descrPtr->policerCycle);

    /* Convert clock value in ticks to time stamp format */
    __LOG(("Convert clock value in ticks to time stamp format"));
    snetXcatIpfixTimestampFormat(devObjPtr, clockVal, &timeStamp);

    /* Check counters wraparounds for configurable pre-wraparound threshold */
    __LOG(("Check counters wraparounds for configurable pre-wraparound threshold"));
    wrapTriggered = snetXCatPolicerIPFixCntWrapCheck(devObjPtr, descrPtr,
                                                     &goodPckts,
                                                     &dropPckts,
                                                     &bytesCnt, bytes);

    /* When the wrap around indication is set (by any of the three counters),
    there is no IPFix Sampling/Alarm */
    if (wrapTriggered)
    {
        /* IPFIX wrap around alert Memory */
        __LOG(("IPFIX wrap around alert Memory"));
        regAddr =
            SMEM_XCAT_POLICER_IPFIX_WA_ALERT_TBL_MEM(devObjPtr,
                                                     descrPtr->policerCycle,
                                                     policerCntIndex);
        regPtr = smemMemGet(devObjPtr, regAddr);
        /* Check wraparound indication bit */
        __LOG(("Check wraparound indication bit"));
        fieldVal = SMEM_U32_GET_FIELD(regPtr[0], (policerCntIndex % 32), 1);
        if(fieldVal == 0)
        {
            snetChetahDoInterrupt(devObjPtr,
                SMEM_XCAT_POLICER_IPFIX_INT_CAUSE_REG(devObjPtr,  descrPtr->policerCycle),
                SMEM_XCAT_POLICER_IPFIX_INT_MASK_REG(devObjPtr,  descrPtr->policerCycle),
                SNET_XCAT_POLICER_INTR_IPFIX_WRAP_E,
                (descrPtr->policerCycle == 0) ?
                              SNET_XCAT_INGR_POLICER0_INTR_SUM_E(devObjPtr) :
                              SNET_XCAT_INGR_POLICER1_INTR_SUM_E(devObjPtr));
            /* Set wraparound indication bit */
            __LOG(("Set wraparound indication bit"));
            SMEM_U32_SET_FIELD(regPtr[0], (policerCntIndex % 32), 1, 1);
        }
    }

    /* Write IPFIX flow counters: packet counter, byte counter, drop counter */
    snetXcatIpfixCounterWrite(devObjPtr, descrPtr , policerIpfixRegPtr, &bytesCnt, goodPckts,
                              timeStamp, dropPckts);

    /* Ingress/Egress Policer Control0 address */
    regAddr = SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,
                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    aging =
        SNET_XCAT_POLICER_IPFIX_AGE_ENABLE_GET_MAC(regPtr);

    /* Enables the activation of aging for IPfix */
    if(aging)
    {
        /* IPFIX aging alert Memory */
        __LOG(("IPFIX aging alert Memory"));
        regAddr =
            SMEM_XCAT_POLICER_IPFIX_AGING_ALERT_TBL_MEM(devObjPtr,
                                                        descrPtr->policerCycle,
                                                        policerCntIndex);
        regPtr = smemMemGet(devObjPtr, regAddr);
        fieldVal = SMEM_U32_GET_FIELD(regPtr[0], (policerCntIndex % 32), 1);
        /* Check aging indication bit */
        __LOG(("aging indication bit [%d] \n",
            fieldVal));
        if(fieldVal == 0)
        {
            /* Set aging indication bit */
            __LOG(("Set aging indication bit \n"));
            SMEM_U32_SET_FIELD(regPtr[0], (policerCntIndex % 32), 1, 1);
        }
        else
        {
            __LOG(("Aging indication bit already '1' \n"));
        }
    }

    return !(wrapTriggered);
}

/**
* @internal snetXCatPolicerIPFixCountersFreezeCheck function
* @endinternal
*
* @brief   Check IPFix counters freeze state
*/
GT_BOOL snetXCatPolicerIPFixCountersFreezeCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixCountersFreezeCheck);

    GT_U64 bytesCnt;                        /* bytes counter value */
    GT_U32 goodPckts, timeStamp, dropPckts; /* good packets, time stamp, drop packets value */
    GT_U32 treshold;                        /* wrap around treshold */
    GT_U64 treshold64;                      /* wrap around treshold - 64 Bits */
    GT_U32 regAddr;                         /* register address */
    GT_U32 * regPtr;                        /* register pointer */
    GT_BIT wrapAction;                      /* wrap around action freeze/clear */

    /* IPFIX Control */
    regAddr = SMEM_XCAT_POLICER_IPFIX_CTRL_REG(devObjPtr,
                                                   descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);

    wrapAction = SNET_XCAT_POLICER_IPFIX_WA_ACTION_GET_MAC(regPtr);
    /* Wrap around action NOT in freeze mode */
    if(wrapAction)
    {
        return GT_TRUE;
    }

    /* Read IPFIX flow counters: packet counter, byte counter, drop counter */
    __LOG(("Read IPFIX flow counters: packet counter, byte counter, drop counter"));
    snetXcatPolicerIpfixCounterRead(devObjPtr,descrPtr,descrPtr->policerCounterEntryMemoryPtr,
                             &bytesCnt, &goodPckts, &timeStamp, &dropPckts);

    /* Drop packet wrap around threshold */
    regAddr = SMEM_XCAT_POLICER_IPFIX_DROP_CNT_WA_TRESH_REG(devObjPtr,
                                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold = regPtr[0];
    __LOG(("Drop packet wrap around threshold \n"));
    __LOG_PARAM(treshold);
    if(treshold && (treshold == dropPckts))
    {
        return GT_FALSE;
    }
    /* Good packet wrap around threshold */
    regAddr = SMEM_XCAT_POLICER_IPFIX_PCKT_CNT_WA_TRESH_REG(devObjPtr,
                                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold = regPtr[0];
    __LOG(("Good packet wrap around threshold \n"));
    __LOG_PARAM(treshold);
    if(treshold && (treshold == goodPckts))
    {
        return GT_FALSE;
    }

    /* Byte count wrap around threshold LSB */
    regAddr = SMEM_XCAT_POLICER_IPFIX_BYTE_CNT_LSB_WA_TRESH_REG(devObjPtr,
                                                                    descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold64.l[0] = regPtr[0];
    treshold64.l[1] = regPtr[1];
    __LOG(("Byte count wrap around threshold \n"));
    __LOG_PARAM(treshold64.l[0]);
    __LOG_PARAM(treshold64.l[1]);

    if(treshold64.l[0] || treshold64.l[1])
    {
        if((treshold64.l[0] == bytesCnt.l[0]) &&
           (treshold64.l[1] == bytesCnt.l[1]))
        {
            return GT_FALSE;
        }
    }

    return GT_TRUE;
}

/**
* @internal snetLion3PolicerBillingFlowBaseIndexGet function
* @endinternal
*
* @brief   get the index for 'flow based' (from descrPtr->policerPtr or descrPtr->flowId(sip5))
*/
static GT_U32 snetLion3PolicerBillingFlowBaseIndexGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32                   oldIndex,
    OUT GT_BOOL                *isFlowIdBasedPtr /* caller set it to be GT_FALSE */
)
{
    DECLARE_FUNC_NAME(snetLion3PolicerBillingFlowBaseIndexGet);

    GT_U32  newIndex;
    GT_U32  regAddr;/* register address */
    GT_U32  regValue;
    GT_U32  billingBaseIndexForFlowIdAccess,billingMaxFlowId,billingMinFlowId;

    regAddr = SMEM_LION3_POLICER_GLOBAL_BILLING_CNTR_INDEXING_MODE_CONFIG_0_REG(devObjPtr,
                                                 descrPtr->policerCycle);

    smemRegGet(devObjPtr, regAddr,&regValue);

    if(0 == SMEM_U32_GET_FIELD(regValue, 0, 1))
    {
        __LOG(("Billing Index Mode : Standard: The Billing index is determined by the <Policer Index> from "
            "the IPCL/TTI/EPCL or by the index from the Metering table \n"));

        return oldIndex;
    }

    __LOG(("Billing Index Mode : FlowID: If the Flow-ID is in the configured range, the Billing index is "
        "determined by the packets Flow-ID. Otherwise, the index is determined in the standard way \n"));

    billingBaseIndexForFlowIdAccess = SMEM_U32_GET_FIELD(regValue, 16, 16);
    __LOG_PARAM(billingBaseIndexForFlowIdAccess);

    regAddr = SMEM_LION3_POLICER_GLOBAL_BILLING_CNTR_INDEXING_MODE_CONFIG_1_REG(devObjPtr,
                                                 descrPtr->policerCycle);
    smemRegGet(devObjPtr, regAddr,&regValue);

    billingMaxFlowId = SMEM_U32_GET_FIELD(regValue, 16, 16);
    billingMinFlowId = SMEM_U32_GET_FIELD(regValue,  0, 16);
    __LOG_PARAM(billingMaxFlowId);
    __LOG_PARAM(billingMinFlowId);
    __LOG_PARAM(descrPtr->flowId);

    if(descrPtr->flowId >= billingMinFlowId && (descrPtr->flowId < billingMaxFlowId))
    {
        *isFlowIdBasedPtr = GT_TRUE;

        /*Index to Billing =  <Billing-Base-Index-Flow-ID> + <Flow-ID> - <Billing-Min-Flow-ID>*/
        newIndex =  (descrPtr->flowId - billingMinFlowId) + billingBaseIndexForFlowIdAccess;

        __LOG(("New billing index [0x%x](%d) \n",
            newIndex,newIndex));
    }
    else
    {
        /* keep using the 'Standard mode' */
        newIndex = oldIndex;

        if(descrPtr->flowId < billingMinFlowId)
        {
            __LOG(("NOTE: not use flowId because: descrPtr->flowId[0x%x] < billingMinFlowId[0x%x] \n" ,
                descrPtr->flowId , billingMinFlowId));
        }
        else
        {
            __LOG(("NOTE: not use flowId because: descrPtr->flowId[0x%x] >= billingMaxFlowId[0x%x] \n" ,
                descrPtr->flowId , billingMaxFlowId));
        }
    }

    return newIndex;
}


/**
* @internal snetXCatPolicerBillingCounterIncrement function
* @endinternal
*
* @brief   Increment Billing Policer Counters
*/
GT_VOID snetXCatPolicerBillingCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 egressPort,
    IN SKERNEL_CONFORMANCE_LEVEL_ENT cl,
    IN GT_U32 bytesCount
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerBillingCounterIncrement);

    GT_U32 *policerBillingCounterRegPtr;    /* register pointer */
    GT_U32 regAddr;                         /* register address */
    GT_U32 countMode;                       /* Billing Counters Mode: 1 Byte/16 Bytes/1 Packet */
    GT_U64 val64, increment64;              /* counter 64 bits increment */
    GT_U32 fieldVal;                        /* register entry field */
    GT_U32 increment;                       /* counter 32 bits increment */
    GT_U32 policerCntIndex;                 /* policer counter index */
    GT_BOOL retVal;                         /* return value */
    GT_U32  enableCountingTriggerByPort;
    GT_U32  countingEntryFormat;            /* Long or Short counting entry format */
    GT_U32  portNum;                        /* local source or global target port number */
    GT_U32  cntIndexType;                   /* 0 - Conformance level, 1 - Drop Precedence */
    GT_U32  cntIndex;                       /* counter index in billing entry             */
    GT_U32  *policerCtrlRegPtr;             /* register pointer                           */
    GT_BOOL isFlowIdBased;                  /* is index based on Flow Id                  */


    policerCntIndex = 0;
    isFlowIdBased = GT_FALSE;

    /* when eArch (eport/evlan metering is used , then the per physical port registers are not used */
    if(descrPtr->policerEArchCounterEnabled == GT_TRUE)
    {
        /* indication the meter is needed */
        if(descrPtr->policerActuallAccessedIndex != SMAIN_NOT_VALID_CNS)
        {
            /* Policy Counter Index extracted from meter entry */
            __LOG(("Policy Counter Index extracted from meter entry"));
            if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
            {
                policerCntIndex =
                    SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                        descrPtr->policerMeterConfigEntryMemoryPtr,
                        descrPtr->policerActuallAccessedIndex,
                        SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BILLING_PTR_E);
            }
            else
            if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
            {
                policerCntIndex =
                    SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                        descrPtr->policerActuallAccessedIndex,
                        SMEM_LION3_PLR_METERING_TABLE_FIELDS_BILLING_PTR);
            }
            else
            {
                policerCntIndex = snetFieldValueGet(policerMeterEntryPtr, 198, 16);
            }
            __LOG(("Calc Billing Pointer, Metering [0x%x]\n", policerCntIndex));
        }
        else
        {
            policerCntIndex = descrPtr->policerEArchPointer;
            __LOG(("Calc Billing Pointer, no Metering [0x%x]\n", policerCntIndex));
        }
    }
    else
    {
        /* check billing/IPFIX trigger */
        if (devObjPtr->policerSupport.supportPolicerEnableCountingTriggerByPort)
        {
            /* Ingress/Egress Policer Control0 */
            regAddr = SMEM_XCAT_PLR_HIERARCHICAL_POLICER_CTRL_REG(devObjPtr,
                                                         descrPtr->policerCycle);
            /*<Enable Counting Trigger by Port>*/
            smemRegFldGet(devObjPtr, regAddr, 3, 1, &enableCountingTriggerByPort);

            /* If "Enable Counting Trigger by Port" in "Hierarchical Policer control Register"
               is disabled, then count only packets triggered by PCL */
            if (enableCountingTriggerByPort == 0)
            {
                /* if reg disabled, count only PCL triggered packets */
                __LOG(("Counting Trigger by Port is disabled, (allow count only PCL triggered packets) \n"));
                if(GT_FALSE == SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(devObjPtr,descrPtr, direction))
                {
                    return;
                }
            }
            else
            {
                /* The device ignores PCL counting trigger in this mode.
                   The device checks metering by port condition. And billing is done
                   only if metering by port is enabled. But metering may be done
                   by PCL Policer index in this case too.
                   Therefore check metering by port state in register but not actual
                   descrPtr->policerTriggerMode. */
                if (direction == SMAIN_DIRECTION_EGRESS_E)
                {
                    portNum = egressPort;
                }
                else
                {
                    portNum = descrPtr->localDevSrcPort;
                }

                regAddr = SMEM_CHT3_POLICER_PORT_METER_REG(devObjPtr,
                                                                descrPtr->policerCycle,
                                                                portNum);
                if(SMEM_CHT_IS_SIP6_GET(devObjPtr))
                {
                    /* each port with it's own register */
                    smemRegFldGet(devObjPtr, regAddr, 0, 1, &fieldVal);
                }
                else
                {
                    smemRegFldGet(devObjPtr, regAddr, portNum % 32, 1, &fieldVal);
                }

                if (fieldVal == 0)
                {
                    /* there is NO billing/IPFIX in this case */
                    __LOG(("Billing/IPFIX disabled per port[%d] \n",
                        portNum));
                    return;
                }

                /* according to HW design :The Errata :
                    billing enable in flow mode is conditioned by,
                    ( stg1_desc_en_billing == TRUE) &&
                    (rf_counting_trigger_by_rf_en == FALSE ) &&
                    (rf_meter_mode == METER_FLOW_MODE) */
                if(devObjPtr->errata.iplrPolicerBillingForPerPhysicalPortMeteringDoesNotWorksInFlowMode)
                {
                    /* Ingress/Egress Policer Control0 */
                    regAddr = SMEM_XCAT_PLR_HIERARCHICAL_POLICER_CTRL_REG(devObjPtr,
                                                                 descrPtr->policerCycle);
                    /* <Policer Meter Mode> */
                    smemRegFldGet(devObjPtr, regAddr, 0, 1, &fieldVal);
                    if(fieldVal == SNET_XCAT_POLICER_METER_FLOW_E)
                    {
                        __LOG(("WARNING : ERRATA : no counting(billing) performed , because Policer Billing for Per Physical Port metering does not works in FLOW MODE \n"));

                        return;
                    }
                }

            }
        }
        else
        {
            /* count only packets triggered by PCL */
            __LOG(("count only packets triggered by PCL"));
            if(GT_FALSE == SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(devObjPtr,descrPtr, direction))
            {
                return;
            }
        }

        /* billing/IPFIX entry index is taken from meter entry if metering
           is enabled. Otherwise index is taken from PCL/TTI Policer pointer. */
        if (policerMeterEntryPtr == NULL)
        {
            /* Check policy counting trigger */
            __LOG(("Check policy counting trigger"));
            if (GT_FALSE == SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(
                devObjPtr, descrPtr, direction))
            {
                /* this case may be only when (see check billing/IPFIX trigger code):
                   devObjPtr->supportPolicerEnableCountingTriggerByPort device AND
                   enableCountingTriggerByPort == 1 AND
                   metering by port is enabled AND
                   policerMeterEntryPtr == NULL
                   This means that simulation has bug in the policerMeterEntryPtr
                   resolution logic. */
                 skernelFatalError("snetXCatPolicerBillingCounterIncrement: NULL policerMeterEntryPtr\n");
            }
            else
            {
                /* Policy Counter Index extracted in PCL action  */
                __LOG(("Policy Counter Index extracted in PCL action"));
                policerCntIndex = descrPtr->policerPtr;
            }
        }
        else
        {
            /* Policy Counter Index extracted from meter entry */
            __LOG(("Policy Counter Index extracted from meter entry"));
            if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
            {
                policerCntIndex =
                    SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                        descrPtr->policerMeterConfigEntryMemoryPtr,
                        descrPtr->policerActuallAccessedIndex,
                        SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BILLING_PTR_E);
            }
            else
            if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
            {
                policerCntIndex =
                    SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                        descrPtr->policerActuallAccessedIndex,
                        SMEM_LION3_PLR_METERING_TABLE_FIELDS_BILLING_PTR);
            }
            else
            {
                policerCntIndex = snetFieldValueGet(policerMeterEntryPtr, 198, 16);
            }
        }

        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            /* check flowId use instead of 'the IPCL/TTI/EPCL or by the index from the Metering table' */
            policerCntIndex =
                snetLion3PolicerBillingFlowBaseIndexGet(devObjPtr,descrPtr,policerCntIndex, &isFlowIdBased);
        }
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
         /* counting base address is used to get absolute index in memory starting from SIP 5.15 (BobK).*/
         GT_U32 countingBaseAddr =
            SMEM_LION3_POLICER_COUNTING_BASE_ADDR____FROM_DB(devObjPtr,descrPtr->policerCycle);

         /* Flow Id based index for SIP_5_20 already absolute one. Don't add base address in this case. */
         if((isFlowIdBased == GT_FALSE) || (!SMEM_CHT_IS_SIP5_20_GET(devObjPtr)))
         {
             policerCntIndex += countingBaseAddr;
         }
         else
         {
             __LOG(("Flow Id based index for SIP_5_20 already absolute one. Don't add base address in this case. \n"));
         }

         if(countingBaseAddr)
         {
             __LOG_PARAM(countingBaseAddr);
             __LOG_PARAM(policerCntIndex);
         }
    }

    /* Billing counter entry pointer */
    __LOG(("Access the Counting memory : Get the Billing counter entry index [0x%x]\n",
        policerCntIndex));

    regAddr = SMEM_XCAT_POLICER_CNT_ENTRY_TBL_MEM(devObjPtr, direction,
                                                  descrPtr->policerCycle,
                                                  policerCntIndex);
    descrPtr->policerCounterEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);

    descrPtr->countingActuallAccessedIndex = policerCntIndex;
    __LOG_PARAM(descrPtr->countingActuallAccessedIndex);
    policerBillingCounterRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    countingEntryFormat =
        snetXCatPolicerCountingEntryFormatGet(devObjPtr, direction, descrPtr->policerCycle);
    if (countingEntryFormat)    /* Short entry format */
    {
        fieldVal = 0;  /* set Billing mode in "short" format, IPFix not supported */
    }
    else    /* Full entry format */
    {
        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            fieldVal =
                SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,policerBillingCounterRegPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_LION3_PLR_BILLING_TABLE_FIELDS_COUNTER_MODE_E);
        }
        else
        {
            /* Counter Mode */
            fieldVal = snetFieldValueGet(policerBillingCounterRegPtr, 228, 1);
        }
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* we only now how to calc the byte count for the billing/ipfix calculation */
        __LOG(("Calc num bytes needed for [%s] purpose , index[0x%x] \n",
            fieldVal ? "IPFIX" : "BILLING",
            policerCntIndex));
        snetLion3PolicerPacketSizeGet(devObjPtr, descrPtr, direction,
                                     fieldVal ?
                                     /*IPfix*/ SNET_LION3_POLICER_PACKET_SIZE_FROM_GLOBAL_CONFIG_E :
                                     SNET_LION3_POLICER_PACKET_SIZE_FROM_BILLING_ENTRY_E,
                                     policerBillingCounterRegPtr,
                                     &bytesCount);
    }

    /* IPfix */
    /* For AC5P devices, IPFIX table is accessed using ipfixEnable field which has got priority over the legacy access */
    if(fieldVal)
    {
       if(descrPtr->ipfixEnable)
       {
           __LOG(("Can't have IPFIX from both Descriptor and Counting entry!\n"));
           return;
       }

        __LOG(("The Counter entry is 'IPFIX' format \n"));

        /* Check IPFix counters state  */
        retVal = snetXCatPolicerIPFixCountersFreezeCheck(devObjPtr, descrPtr);
        /* IPFix counters in freeze state */
        if(retVal == GT_FALSE)
        {
            return;
        }

        /* IPFIX Per-Flow Packet Counters */
        retVal = snetXCatPolicerIPFixCounterIncrement(devObjPtr, descrPtr,
                                                      policerCntIndex,
                                                      bytesCount);

        /* IPFix counters successfully incremented */
        if(retVal == GT_TRUE)
        {
            /* IPFIX Per-Flow Packet Sampling */
            snetXCatPolicerIPFixSampling(devObjPtr, descrPtr,
                                         policerCntIndex);
        }

        return;
    }

    __LOG(("The Counter entry is 'Billing' format \n"));


    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        countMode =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,policerBillingCounterRegPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNTERS_MODE_E);
    }
    else
    {
        /* Billing Counters Mode: 1 Byte/16 Bytes/1 Packet */
        if (countingEntryFormat)    /* Short entry format */
        {
            countMode = snetFieldValueGet(policerBillingCounterRegPtr, 126, 2);
        }
        else
        {
            countMode = snetFieldValueGet(policerBillingCounterRegPtr, 140, 2);
        }
    }

    /* Increment Policer Billing Counters */
    increment = SNET_CHT3_PCKT_SIZE_RESOLVE(bytesCount, countMode);
    CNV_U32_TO_U64(increment, increment64);

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        retVal = snetLion2PolicerOamLmCounterIncrement(devObjPtr, descrPtr,
                                                       direction, policerCntIndex,
                                                       increment64);
        if(retVal == GT_TRUE)
        {
            return;
        }
    }

    policerCtrlRegPtr =
        smemMemGet(devObjPtr, SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr, descrPtr->policerCycle/*2*/));

    cntIndexType = SNET_XCAT_POLICER_COUNT_COLOR_MODE_GET_MAC(policerCtrlRegPtr);

    if (cntIndexType == 0)
    {
        cntIndex = cl;
    }
    else
    {
        cntIndex = descrPtr->dp;
    }

    snetXcatPolicerBillingCounterRead(devObjPtr, descrPtr,policerBillingCounterRegPtr,
                                       cntIndex, &val64);

    val64 = prvSimMathAdd64(val64, increment64);

    snetXcatPolicerBillingCounterWrite(devObjPtr, descrPtr,policerBillingCounterRegPtr,
                                        cntIndex, &val64);
}

/**
* @internal snetXCatPolicerCountingEntryFormatGet function
* @endinternal
*
* @brief   Return format of counting entry - Full or Short.
*         If device do not support counting entry format select - this mean "Full" format.
*         See Policer Control1 register, "Counting Entry Format Select" field
*/
GT_U32 snetXCatPolicerCountingEntryFormatGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 cycle
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerCountingEntryFormatGet);

    GT_U32  countingEntryFormat;

    if (devObjPtr->policerSupport.supportCountingEntryFormatSelect)
    {
        /* read countingEntryFormat - control1 reg, bits 4:4 */
        smemRegFldGet(devObjPtr,
                      SMEM_XCAT_POLICER_GLB1_CONF_REG(devObjPtr, cycle),
                      4, 1, &countingEntryFormat);

        if ( (countingEntryFormat == 0) &&
             (devObjPtr->policerSupport.supportOnlyShortCountingEntryFormat) )
        {
            skernelFatalError("snetXCatPolicerCountingEntryFormatGet: Full counting entry format is not supported!\n"
                              "Check Policer Control1 register, 'Counting Entry Format Select' field\n");
        }
    }
    else
    {
        countingEntryFormat = 0; /* Full entry format */
    }

    if(countingEntryFormat)
    {
        __LOG(("global config : the counter entry format is 'Compressed' (short) \n"));
    }
    else
    {
        __LOG(("global config : the counter entry format is 'Full' (Long) \n"));
    }


    return countingEntryFormat;
}

/**
* @internal snetXCatPolicerCounterIncrement function
* @endinternal
*
* @brief   Increment Policer Billing/Policy/VLAN Counters
*/
GT_VOID snetXCatPolicerCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerCtrlRegPtr,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 egressPort,
    IN SKERNEL_CONFORMANCE_LEVEL_ENT cl,
    OUT GT_U32 * bytesCountPtr
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerCounterIncrement);

    SNET_XCAT_POLICER_COUNTING_MODE_ENT counterMode;  /* counting mode */
    GT_U32 bytesCount;

    ASSERT_PTR(bytesCountPtr);

    /* Get Policer Counting mode */
    counterMode = SNET_XCAT_POLICER_COUNTING_MODE_GET_MAC(policerCtrlRegPtr);

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* will be calculated when needed */
        bytesCount = 0;
    }
    else
    {
        /* Get packet size based on packet size mode.
          byteCount is used for management counters too.
          Need to evaluate it if counting is disabled also. */
        snetCht3PolicerPacketSizeGet(devObjPtr, descrPtr,
                                     direction,
                                     policerCtrlRegPtr, &bytesCount);
    }

    *bytesCountPtr = bytesCount;

    if(counterMode == SNET_XCAT_POLICER_COUNTING_DISABLE_E)
    {
        /* Policer counting in disabled mode */
        __LOG(("Policer counting in disabled mode"));
        return;
    }

    switch(counterMode)
    {
        case SNET_XCAT_POLICER_COUNTING_BILLING_E:
            snetXCatPolicerBillingCounterIncrement(devObjPtr, descrPtr, direction,
                                                   policerMeterEntryPtr,
                                                   egressPort,
                                                   cl,
                                                   bytesCount);
            break;
        case SNET_XCAT_POLICER_COUNTING_POLICY_E:
            if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
            {
                __LOG(("ERROR : the device not supports the 'policy' counting mode in PLR unit \n"));
                return;
            }
            snetXCatPolicerPolicyCounterIncrement(devObjPtr, descrPtr, direction,
                                                  policerMeterEntryPtr,
                                                  bytesCount);
            break;
        case SNET_XCAT_POLICER_COUNTING_VLAN_E:
            if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
            {
                __LOG(("ERROR : the device not supports the 'vlan' counting mode in PLR unit \n"));
                return;
            }
            snetXCatPolicerVlanCounterIncrement(devObjPtr, descrPtr, direction,
                                                policerMeterEntryPtr,
                                                bytesCount);
            break;
        default:
            /* Illegal Policer Counting mode */
            __LOG(("Illegal Policer Counting mode"));
            return;
    }
}

/**
* @internal snetXCatPolicerPolicyCounterIncrement function
* @endinternal
*
* @brief   Increment Policer Policy Counters
*/
static GT_VOID snetXCatPolicerPolicyCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 bytes
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerPolicyCounterIncrement);

    GT_U32 regAddr;
    GT_U32 * policerPolicyCounterRegPtr;
    GT_U32 policerCntIndex;
    GT_U32 pcktCnt;
    GT_U32 countingEntryFormat; /* Full or short counting entry format */

    /* Check policy counting trigger */
    if(GT_FALSE == SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(
        devObjPtr, descrPtr, direction))
    {
        return;
    }

    /* policerMeterEntryPtr not used - metering table contents */
    /* ignored in SNET_XCAT_POLICER_COUNTING_POLICY_E mode     */
    /* Policy Counter Index extracted in PCL action            */
    policerCntIndex = descrPtr->policerPtr >> 3;
    pcktCnt         = descrPtr->policerPtr & 0x7;

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
         /* counting base address is used to get absolute index in memory starting from SIP 5.15 (BobK).*/
         GT_U32 countingBaseAddr =
            SMEM_LION3_POLICER_COUNTING_BASE_ADDR____FROM_DB(devObjPtr,descrPtr->policerCycle);

         policerCntIndex += countingBaseAddr;
         if(countingBaseAddr)
         {
             __LOG_PARAM(countingBaseAddr);
             __LOG_PARAM(policerCntIndex);
         }
    }

    /* Policer counter entry pointer */
    __LOG(("Access the Counting memory : Get the Policy counter entry index [0x%x]\n",
        policerCntIndex));

    regAddr = SMEM_XCAT_POLICER_CNT_ENTRY_TBL_MEM(devObjPtr, direction,
                                                  descrPtr->policerCycle,
                                                  policerCntIndex);
    descrPtr->policerCounterEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);

    descrPtr->countingActuallAccessedIndex = policerCntIndex;
    __LOG_PARAM(descrPtr->countingActuallAccessedIndex);
    policerPolicyCounterRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    countingEntryFormat =
        snetXCatPolicerCountingEntryFormatGet(devObjPtr, direction, descrPtr->policerCycle);

    if (pcktCnt > (GT_U32)(countingEntryFormat ? 3 : 5) )
    {
        skernelFatalError("snetXCatPolicerPolicyCounterIncrement: Policer Policy counter index is not valid.\n"
                          "Check PCL/TTI action configuration\n");
    }
    /* Increment Policer Policy Counter */
    __LOG(("Counter increment from [%d] \n",
        policerPolicyCounterRegPtr[pcktCnt]));

    policerPolicyCounterRegPtr[pcktCnt]++;

}

/**
* @internal snetXCatPolicerVlanCounterIncrement function
* @endinternal
*
* @brief   Increment Policer VLAN Counters
*/
static GT_VOID snetXCatPolicerVlanCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 bytesCount
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerVlanCounterIncrement);

    GT_U32 regAddr;
    GT_U32 fldValue;
    GT_U32 *regPtr;
    GT_U32 * policerPolicyCounterRegPtr;
    GT_U32 policerCntIndex, pcktCnt;
    GT_U32 cntMode;
    SKERNEL_EXT_PACKET_CMD_ENT packetCommand;

    /* Ingress/Egress Policer Control0 */
    regAddr = SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,
                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);

    /* VLAN Counting Mode */
    cntMode = SNET_XCAT_POLICER_VLAN_COUNT_MODE_GET_MAC(regPtr);

    if ((direction == SMAIN_DIRECTION_EGRESS_E) && !(SMEM_CHT_IS_SIP6_GET(devObjPtr)))
    {
        /* egress PLR don't get packet command from EPCL so use 'forward'
           ??? do we need to use : descrPtr->epclAction.drop || descrPtr->haAction.drop
        */
        __LOG(("NOTE: For trigger purpose : don't get packet command from EPCL , so treat as FORWARD (for trigger purpose) \n"));
        packetCommand = SKERNEL_EXT_PKT_CMD_FORWARD_E;
    }
    else
    {
        packetCommand = descrPtr->packetCmd;
    }


    /* VLAN Counting Trigger */
    switch(packetCommand)
    {
        case SKERNEL_EXT_PKT_CMD_FORWARD_E:
            /* check if the counter trigger not set for current packet command */
            if(0 == SMEM_U32_GET_FIELD(regPtr[0], 25, 1))
            {
                __LOG(("VLAN Counting : not enable for FORWARD command \n"));
                return;
            }
            break;
        case SKERNEL_EXT_PKT_CMD_HARD_DROP_E:
        case SKERNEL_EXT_PKT_CMD_SOFT_DROP_E:
            /* check if the counter trigger not set for current packet command */
            if(0 == SMEM_U32_GET_FIELD(regPtr[0], 26, 1))
            {
                __LOG(("VLAN Counting : not enable for DROP(soft/hard) command \n"));
                return;
            }
            break;
        case SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E:
            /* check if the counter trigger not set for current packet command */
            if(0 == SMEM_U32_GET_FIELD(regPtr[0], 27, 1))
            {
                __LOG(("VLAN Counting : not enable for TRAP_TO_CPU command \n"));
                return;
            }
            break;
        case SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E:
            /* check if the counter trigger not set for current packet command */
            if(0 == SMEM_U32_GET_FIELD(regPtr[0], 28, 1))
            {
                __LOG(("VLAN Counting : not enable for MIRROR_TO_CPU command \n"));
                return;
            }
            break;
    default:
            /* packet command that is not supported for counting */
            __LOG(("VLAN Counting : packet command[%d] that is not supported for counting  \n",
                packetCommand));
            return;
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr) && cntMode/*bytes*/)
    {
        __LOG(("Calc num bytes needed for [%s] purpose \n",
            "COUNTING_VLAN"));
        snetLion3PolicerPacketSizeGet(devObjPtr, descrPtr, direction,
                                     SNET_LION3_POLICER_PACKET_SIZE_FROM_GLOBAL_CONFIG_E,
                                     NULL, &bytesCount);
    }

    /* Policer Counter entry Index */
    policerCntIndex = descrPtr->eVid >> 2;

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
         /* counting base address is used to get absolute index in memory starting from SIP 5.15 (BobK).*/
         GT_U32 countingBaseAddr =
            SMEM_LION3_POLICER_COUNTING_BASE_ADDR____FROM_DB(devObjPtr,descrPtr->policerCycle);

         policerCntIndex += countingBaseAddr;
         if(countingBaseAddr)
         {
             __LOG_PARAM(countingBaseAddr);
             __LOG_PARAM(policerCntIndex);
         }
    }

    /* Policer counter entry pointer */
    __LOG(("Access the Counting memory : Get the VLAN counter entry index [0x%x] (4 vlans in entry) \n",
        policerCntIndex));

    regAddr = SMEM_XCAT_POLICER_CNT_ENTRY_TBL_MEM(devObjPtr, direction,
                                                  descrPtr->policerCycle,
                                                  policerCntIndex);
    descrPtr->policerCounterEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);

    descrPtr->countingActuallAccessedIndex = policerCntIndex;
    __LOG_PARAM(descrPtr->countingActuallAccessedIndex);
    policerPolicyCounterRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    pcktCnt = (descrPtr->eVid)/*policerCntIndex*/ & 0x3;

    /* Increment Policer Policy Counter */
    fldValue = policerPolicyCounterRegPtr[pcktCnt];
    fldValue += (cntMode == 0) ? 1 : bytesCount;

    __LOG(("Counter increment from [%d] to [%d] \n",
        policerPolicyCounterRegPtr[pcktCnt],
        fldValue));

    policerPolicyCounterRegPtr[pcktCnt] = fldValue;

}


/**
* @internal eplrEPortTriggerEntryGet function
* @endinternal
*
* @brief   function of the EPLR unit
*         get index to EPLR - ePort trigger table
* @param[in] devObjPtr                - pointer to device object.
* @param[in] descrPtr                 - Cht frame descriptor
* @param[in] localEgressPort          - physical egress port -- local port number (port 0..15) !!!
*                                      (referred as <LocalDevTrgPhyPort> in documentation ,
*                                      but it is not part of the 'descriptor' !)
*/
static GT_U32 eplrEPortTriggerEntryGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32    localEgressPort
)
{
    DECLARE_FUNC_NAME(eplrEPortTriggerEntryGet);

    GT_U32  index;/* table index*/

    if ((descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_FORWARD_E ||
         descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_FROM_CPU_E) &&
        (descrPtr->useVidx == 0 &&
            ((SKERNEL_IS_MATCH_DEVICES_MAC(descrPtr->trgDev, descrPtr->ownDev,
                            devObjPtr->dualDeviceIdEnable.ha)) ||
                descrPtr->eArchExtInfo.assignTrgEPortAttributesLocally)))
    {
        index =  descrPtr->trgEPort;
        __LOG(("use descrPtr->trgEPort[0x%x] (useVidx == 0 , to 'own device' , FORWARD/FROM_CPU)\n",
            index));
    }
    else if ((descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_TO_CPU_E) &&
             (descrPtr->useVidx == 0 &&
                (SKERNEL_IS_MATCH_DEVICES_MAC(descrPtr->trgDev, descrPtr->ownDev,
                                            devObjPtr->dualDeviceIdEnable.ha))))
    {
        index =  descrPtr->trgEPort;
        __LOG(("use descrPtr->trgEPort[0x%x] (useVidx == 0 , to 'own device' , TO_CPU)\n",
            index));
    }
    else if ((descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_TO_TRG_SNIFFER_E) &&
             (descrPtr->useVidx == 0 &&
                (SKERNEL_IS_MATCH_DEVICES_MAC(descrPtr->sniffTrgDev, descrPtr->ownDev,
                                            devObjPtr->dualDeviceIdEnable.ha))))
    {
        index =  descrPtr->eArchExtInfo.toTargetSniffInfo.sniffTrgEPort;
        __LOG(("use descrPtr->eArchExtInfo.toTargetSniffInfo.sniffTrgEPort[0x%x] (useVidx == 0 , to 'own device' , TO_SNIFFER)\n",
            index));
    }
    else
    {
        /* make global port from the local port */
        index =  SMEM_CHT_GLOBAL_PORT_FROM_LOCAL_PORT_MAC(devObjPtr,localEgressPort);
        __LOG(("use global egress port[0x%x] \n",
            index));
    }

    return index;
}

#define LION3_NUM_TRAFFIC_TYPES_CNS (SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_TCP_SYN_OFFSET_E - SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_KNOWN_UNICAST_OFFSET_E + 1)
#define LION3_TRAFFIC_TYPES_NOT_VALID_CNS   7
/**
* @internal policerEArchIndexGet function
* @endinternal
*
* @brief   check if ePort/eVlan entry used for meter/counting ,get meter/count index
*/
static GT_BOOL policerEArchIndexGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT pcktType,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32       egressPort,
    IN GT_BOOL      useEport,
    INOUT GT_U32 * entryIndexPtr
)
{
    DECLARE_FUNC_NAME(policerEArchIndexGet);

    GT_U32  regAddr;                        /* register address */
    GT_U32  *memPtr;                        /* pointer to memory */
    GT_U32  fieldVal;                       /* register's field value */
    E_ARCH_POLICER_METER_MODE_ENT  eArchMeteringMode;/*ePort/eVlan meter mode*/
    GT_U32 entryIndex, trafficTypeOffset;    /* metering pointer index */
    GT_U32  ePort;/*eport for IPLR/EPLR metering*/
    GT_U32  meterEn,countEn;
    GT_U32  trafficTypeOffsetArr[LION3_NUM_TRAFFIC_TYPES_CNS];
    GT_U32  ii;

    regAddr = SMEM_XCAT_POLICER_GLB1_CONF_REG(devObjPtr,descrPtr->policerCycle);

    /* ePort/eVlan Metering Mode */
    smemRegFldGet(devObjPtr, regAddr, 8, 2, &fieldVal);
    __LOG(("ePort/eVlan Metering Mode[%d] \n",
        fieldVal));

    eArchMeteringMode = fieldVal;

    __LOG(("PLR[%d] : EPort/EVlan Policer Meter mode [%s]\n",
        descrPtr->policerCycle,
        (eArchMeteringMode == E_ARCH_POLICER_METER_DISABLED_E       ? "DISABLED":
         eArchMeteringMode == E_ARCH_POLICER_METER_EPORT_USED_E     ? "EPORT_USED":
         eArchMeteringMode == E_ARCH_POLICER_METER_EVLAN_USED_E     ? "EVLAN_USED":
                                                                      "NOT_SUPPORTED")
         ));

    if(eArchMeteringMode != E_ARCH_POLICER_METER_EPORT_USED_E &&
       eArchMeteringMode != E_ARCH_POLICER_METER_EVLAN_USED_E)
    {
        return GT_FALSE;
    }
    else if(useEport == GT_TRUE && eArchMeteringMode != E_ARCH_POLICER_METER_EPORT_USED_E)
    {
        __LOG(("ePORT check , but global mode is eVLAN \n"));
        return GT_FALSE;
    }
    else if(useEport == GT_FALSE && eArchMeteringMode != E_ARCH_POLICER_METER_EVLAN_USED_E)
    {
        __LOG(("eVLAN check , but global mode is ePORT \n"));
        return GT_FALSE;
    }

    if(useEport == GT_TRUE)
    {
        if(SMAIN_DIRECTION_INGRESS_E == direction)
        {
            /* the Ingress Policer, ePort metering is done per packet's
                source ePort if it is an ePort of the local device.
                Otherwise, it is done per local source port.*/
            ePort =  descrPtr->eArchExtInfo.localDevSrcEPort;
            __LOG(("use descrPtr->eArchExtInfo.localDevSrcEPort[0x%x] (eport mode)\n",
                ePort));
        }
        else
        {
            /* EPLR special logic */
            ePort =  eplrEPortTriggerEntryGet(devObjPtr,descrPtr,egressPort);
        }
        entryIndex = ePort;
    }
    else
    {
        entryIndex = descrPtr->eVid;
        __LOG(("use descrPtr->eVid[0x%x] (evlan mode)\n",
            entryIndex));
    }

    memPtr = smemMemGet(devObjPtr,
        SMEM_LION2_POLICER_EPORT_EVLAN_TRIGGER_TBL_MEM(devObjPtr,entryIndex,descrPtr->policerCycle));

    meterEn =
        SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
            SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_METERING_ENABLE_E);
    countEn =
        SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
            SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_COUNTING_ENABLE_E);

    if(countEn)
    {
        descrPtr->policerEArchCounterEnabled = GT_TRUE;
        __LOG(("eArch : counting Enabled \n"));
    }
    else
    {
        descrPtr->policerEArchCounterEnabled = GT_FALSE;
        __LOG(("eArch : counting Disabled \n"));
    }

    /*Metering Disabled / Counting Disabled */
    if(0 == meterEn && 0 == countEn)
    {
        __LOG(("eArch : Metering and Counting Disabled \n"));
        return GT_FALSE;
    }

    if(0 == meterEn)
    {
        /* indication the meter not needed */
        descrPtr->policerActuallAccessedIndex = SMAIN_NOT_VALID_CNS;
    }

    if(SMAIN_DIRECTION_INGRESS_E == direction)
    {
        ii = 0;
        trafficTypeOffsetArr[ii++]/*0*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_KNOWN_UNICAST_OFFSET_E);
        trafficTypeOffsetArr[ii++]/*1*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNKNOWN_UNICAST_OFFSET_E);
        trafficTypeOffsetArr[ii++]/*2*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_REGISTERED_MULTICAST_OFFSET_E);
        trafficTypeOffsetArr[ii++]/*3*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNREGISTERED_MULTICAST_OFFSET_E);
        trafficTypeOffsetArr[ii++]/*4*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_BROADCAST_OFFSET_E);
        trafficTypeOffsetArr[ii++]/*5*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_TCP_SYN_OFFSET_E);


        for(ii = 0 ; ii < LION3_NUM_TRAFFIC_TYPES_CNS ; ii++)
        {
            if(trafficTypeOffsetArr[ii] != LION3_TRAFFIC_TYPES_NOT_VALID_CNS)
            {
                break;
            }
        }

        if(ii == LION3_NUM_TRAFFIC_TYPES_CNS)
        {
            /* In ePort based metering and eVLAN based metering, metering/counting is performed only if the
               following statement is true: (<Metering Enable>==Enabled || <Counting Enable>==Enabled) &&
               metering/counting is enabled for at least one of the six traffic types.
               I.e., if all traffic types are configured to 0x7 in the relevant ePort or eVLAN entry, then
               metering/counting is not performed */
            __LOG(("eArch : Metering and Counting Disabled , on all [%d] traffic types \n",
                LION3_NUM_TRAFFIC_TYPES_CNS));

            descrPtr->policerEArchCounterEnabled = GT_FALSE;

            return GT_FALSE;
        }

        trafficTypeOffset = trafficTypeOffsetArr[pcktType];

        if(trafficTypeOffset == LION3_TRAFFIC_TYPES_NOT_VALID_CNS)
        {
            /* A value of 0x7 means that metering / counting is
                disabled for this traffic type */
            __LOG(("eArch : Metering and Counting Disabled , for current packet type[%d] \n",
                pcktType));

            __LOG(("NOTE: eArch choose NOT to count/meter \n"));

            descrPtr->policerEArchCounterEnabled = GT_FALSE;

            return GT_TRUE;/*return TRUE to state that eArch choose not to count/meter*/
        }
    }
    else
    {
        __LOG(("The egress Policer perform policing on all the traffic. thus, the traffic type offset is ignored and the offset if always 0 \n"));
        trafficTypeOffset = 0;
    }

    descrPtr->policerEArchPointer =
        SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
            SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_POLICER_PTR_E);
    descrPtr->policerEArchPointer += trafficTypeOffset;


    __LOG_PARAM(descrPtr->policerEArchPointer);
    *entryIndexPtr = descrPtr->policerEArchPointer;

    if(0 == meterEn)/*Metering Disabled*/
    {
        __LOG(("eArch : Metering Disabled and counting enabled \n"));
    }
    else
    if(countEn == 0)
    {
        __LOG(("eArch : Metering enabled and counting disabled \n"));
    }
    else
    {
        __LOG(("eArch : Metering enabled and counting enabled \n"));
    }

    if(useEport == GT_TRUE)
    {
        __LOG(("eArch : Metering/Counting Enabled - ePort mode \n"));
        descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_E_PORT_E;
    }
    else
    {
        __LOG(("eArch : Metering/Counting Enabled - eVlan mode \n"));
        descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_E_VLAN_E;
    }
    __LOG_PARAM(descrPtr->policerTriggerMode);

    /* indication the eport/evlan logic used */
    return GT_TRUE;

}

/**
* @internal snetLion2PolicerEArchIndexGet function
* @endinternal
*
* @brief   Override if need index to policer entry
*/
GT_BOOL snetLion2PolicerEArchIndexGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32       egressPort,
    INOUT GT_U32 * entryIndexPtr
)
{
    DECLARE_FUNC_NAME(snetLion2PolicerEArchIndexGet);

    GT_U32  regAddr;                        /* register address */
    GT_U32  fieldVal;                       /* register's field value */
    SNET_XCAT_POLICER_METER_MODE_ENT meterMode;
    SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT pcktType;
    GT_BIT meterEnable;
    GT_BIT countEnable;

    if(0 == SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        return GT_FALSE;
    }

    /* Ingress/Egress Policer Control0 */
    regAddr = SMEM_XCAT_PLR_HIERARCHICAL_POLICER_CTRL_REG(devObjPtr,
                                                 descrPtr->policerCycle);
    /* Policer Meter mode */
    smemRegFldGet(devObjPtr, regAddr, 0, 1, &fieldVal);
    meterMode = fieldVal;

    /* Get storm rate type */
    snetXCatPolicerStormRateTypeGet(devObjPtr, descrPtr, &pcktType);
    __LOG_PARAM(pcktType);

    /* use SKERNEL_POLICER_TRIGGER_MODE_EARCH_NOT_INITIALIZED_E that
       is not SKERNEL_POLICER_TRIGGER_MODE_NONE_E , to know that
       policerEVlanIndexGet(...) / policerEPortIndexGet(...) may set
       SKERNEL_POLICER_TRIGGER_MODE_NONE_E inside the function */

    descrPtr->policerEArchCounterEnabled = GT_FALSE;

    if(meterMode == SNET_XCAT_POLICER_METER_FLOW_E)
    {
        __LOG(("meterMode = 'FLOW mode' \n"));
        /* In FLOW mode, PCL trigger can override triggering for PORT mode */
        meterEnable = direction == SMAIN_DIRECTION_INGRESS_E ? descrPtr->policerEn : descrPtr->policerEgressEn;
        countEnable = SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(devObjPtr,descrPtr, direction);

        if (meterEnable || countEnable)
        {
            __LOG(("policerTriggerMode = 'flow mode' \n"));
            /* Metering/Counters entry index */
            *entryIndexPtr = descrPtr->policerPtr;
            descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_FLOW_E;
            __LOG_PARAM(descrPtr->policerTriggerMode);
            /* the indication that we need meterring depends on the 'policerEn' */
            if(meterEnable)
            {
                if(countEnable)
                {
                    __LOG(("Flow based : metering and counting used \n"));
                }
                else
                {
                    __LOG(("Flow based : only metering used and counting disabled \n"));
                }
            }
            else
            /*if(countEnable)*/
            {
                /* indication the meter not needed */
                descrPtr->policerActuallAccessedIndex = SMAIN_NOT_VALID_CNS;
                __LOG(("Flow based : metering disabled and only counting used \n"));
            }

            return GT_TRUE;
        }
        else
        {
            /* eVlan Metering Mode */
            if(GT_TRUE == policerEArchIndexGet(devObjPtr, descrPtr,pcktType,direction,egressPort,GT_FALSE/*eVlan*/,entryIndexPtr))
            {
                __LOG(("eVlan metering used \n"));
                return GT_TRUE;
            }
        }
    }
    else
    {
        __LOG(("meterMode = 'port mode' \n"));
    }

    /* ePort Metering Mode */
    if(GT_TRUE == policerEArchIndexGet(devObjPtr, descrPtr,pcktType,direction,egressPort,GT_TRUE/*ePort*/,entryIndexPtr))
    {
        __LOG(("ePort metering used \n"));
        return GT_TRUE;
    }

    __LOG(("ePort/eVlan metering NOT used \n"));
    return GT_FALSE;
}

/**
* @internal snetXCatPolicerOverrideMeterIndex function
* @endinternal
*
* @brief   Override if need index to policer entry
*/
GT_VOID snetXCatPolicerOverrideMeterIndex
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    INOUT GT_U32 * entryIndexPtr,
    IN GT_U32   portIndex
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerOverrideMeterIndex);

    GT_U32  regAddr;                        /* register address */
    GT_U32  regValue;                        /* register's value */
    GT_U32  fieldVal;                        /* register's field value */
    SNET_XCAT_POLICER_METER_MODE_ENT meterMode;
    GT_U32 entryIndex, trafficTypeOffset;    /* metering pointer index */
    SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT pcktType;
    GT_BOOL doPortMode;                    /* perform PORT mode logic */
    GT_U32  trafficTypeFirstBit;           /* first bit in index for traffic type value */
    GT_U32 portModeAddressSelect;   /* Full(0) or compressed(1) mode of metering entry
                                       address calculation in Port Mode */

    ASSERT_PTR(entryIndexPtr);

    /* Initial policer metering entry index */
    entryIndex = *entryIndexPtr;

    /* Ingress/Egress Policer Control0 */
    regAddr = SMEM_XCAT_PLR_HIERARCHICAL_POLICER_CTRL_REG(devObjPtr,
                                                 descrPtr->policerCycle);
    /* Policer Meter mode */
    smemRegFldGet(devObjPtr, regAddr, 0, 1, &fieldVal);
    meterMode = fieldVal;

    doPortMode = GT_TRUE;
    if(meterMode == SNET_XCAT_POLICER_METER_FLOW_E)
    {
        __LOG(("meterMode = SNET_XCAT_POLICER_METER_FLOW_E \n"));

        /* In FLOW mode, PCL trigger can override triggering for PORT mode */
        if (SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(devObjPtr,descrPtr, direction))
        {
            /* Metering/Counters entry index */
            entryIndex = descrPtr->policerPtr;
            descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_FLOW_E;
            __LOG_PARAM(descrPtr->policerTriggerMode);
            doPortMode = GT_FALSE;
        }

        /* SIP5 devices checks PORT mode (traffic type checks) triggering if
          other (PCL/TTI, ePort/eVlan) triggers are not set.
          SIP4 devices do not performs PORT mode triggering in FLOW mode. */
        if(0 == SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            doPortMode = GT_FALSE;
        }
    }
    else
    {
        __LOG(("meterMode = SNET_XCAT_POLICER_METER_PORT_E \n"));
    }


    if(doPortMode)
    {
        if((descrPtr->policerTriggerMode != SKERNEL_POLICER_TRIGGER_MODE_PORT_E) ||
           ((SMAIN_DIRECTION_EGRESS_E == direction) && (!devObjPtr->policerSupport.supportEplrPerPort)))
        {
            /* there was no trigger by the 'per port'
               in devices before xCat2, ERLR per port does not works too */
            descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_NONE_E;
            __LOG_PARAM(descrPtr->policerTriggerMode);
            return;
        }

        /* PORT mode */
        descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_PORT_E;
        __LOG_PARAM(descrPtr->policerTriggerMode);

        if ((SMAIN_DIRECTION_EGRESS_E == direction) && SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            /* Egress Policer of SIP5 device use Unknown Unicast packet type
               regardless of real packet type */
            pcktType = SNET_XCAT_POLICER_METER_UNK_UCAST_E;
        }
        else
        {
            /* Get storm rate type */
            snetXCatPolicerStormRateTypeGet(devObjPtr, descrPtr, &pcktType);
        }
        __LOG_PARAM(pcktType);

        /* Ingress/Egress Policer Port metering pointer index */
        regAddr = SMEM_XCAT_POLICER_PORT_METER_POINTER_TBL_MEM(devObjPtr,
                                                           descrPtr->policerCycle,
                                                           portIndex);
        smemRegGet(devObjPtr, regAddr,&regValue);

        /* Storm type port metering index */
        trafficTypeOffset =
            snetXcatPolicerPortPointerIndexGet(devObjPtr,regValue, pcktType, portIndex);

        __LOG_PARAM(trafficTypeOffset);

        if (devObjPtr->policerSupport.supportPortModeAddressSelect)
        {
            regAddr = SMEM_XCAT_PLR_HIERARCHICAL_POLICER_CTRL_REG(devObjPtr, descrPtr->policerCycle);
            smemRegFldGet(devObjPtr, regAddr, 4, 1, &portModeAddressSelect);
        }
        else
        {
            portModeAddressSelect = 0;  /* full mode */
        }

        /* calculate Metering/Counters entry index */
        if (portModeAddressSelect)
        {
            entryIndex = (portIndex << 2) | trafficTypeOffset;
            /* Compressed mode: The address is {port_num,index} - xCat2 and above*/
            __LOG(("Compressed mode: The entryIndex = [%d] from {port_num[%d]<<[2],index[%d]}",
                entryIndex , portIndex , trafficTypeOffset));
        }
        else
        {
            /* Full mode: The address is {index,port_num} */
            if(SMEM_CHT_IS_SIP6_10_GET(devObjPtr))
            {
                /* devices use 10 bits for port parts regardless of only 128 supported physical ports */
                trafficTypeFirstBit = 10;
            }
            else
            if(0 == SMEM_CHT_IS_SIP5_GET(devObjPtr))
            {
                /* SIP4 support 6 bits for port number.
                 Traffic type is in bits 6..7  */
                trafficTypeFirstBit = 6;
            }
            else
            {
                /* SIP5 support 8/9 bits for port number.
                   Traffic type is in bits 8..9 */
                trafficTypeFirstBit = MAX(8,devObjPtr->flexFieldNumBitsSupport.phyPort);
            }

            entryIndex = trafficTypeOffset << trafficTypeFirstBit | portIndex;

            __LOG(("Full mode: The entryIndex = [%d] from {index[%d]<<[%d],port_num[%d]}",
                entryIndex ,
                trafficTypeOffset,
                trafficTypeFirstBit,
                portIndex));

        }
    }

    /* Final policer metering entry index */
    *entryIndexPtr = entryIndex;

    __LOG(("Final policer metering entry index[%d] " ,
        entryIndex));

}

/**
* @internal snetXCatPolicerStormRateTypeGet function
* @endinternal
*
* @brief   Get storm rate type
*/
static GT_VOID snetXCatPolicerStormRateTypeGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT * pcktTypePtr
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerStormRateTypeGet);

    GT_U32 fldVal;

    if ((descrPtr->isIp && (descrPtr->ipProt == SNET_TCP_PROT_E))
        && descrPtr->l4StartOffsetPtr != NULL)
    {
        fldVal = descrPtr->l4StartOffsetPtr[13] & 0x3f;
        /* Packet is a TCP SYN */
        if (fldVal == 0x10)
        {
            __LOG(("packet type : SNET_XCAT_POLICER_METER_TCP_SYN_E \n"));
            *pcktTypePtr = SNET_XCAT_POLICER_METER_TCP_SYN_E;
            return;
        }
    }

    switch (descrPtr->macDaType)
    {
        case SKERNEL_UNICAST_MAC_E:
            *pcktTypePtr = (descrPtr->egressFilterRegistered) ?
                SNET_XCAT_POLICER_METER_UCAST_E : SNET_XCAT_POLICER_METER_UNK_UCAST_E;
            if(descrPtr->egressFilterRegistered)
            {
                __LOG(("packet type : SNET_XCAT_POLICER_METER_UCAST_E \n"));
            }
            else
            {
                __LOG(("packet type : SNET_XCAT_POLICER_METER_UNK_UCAST_E \n"));
            }
            break;
        case SKERNEL_MULTICAST_MAC_E:
            *pcktTypePtr = (descrPtr->egressFilterRegistered) ?
                SNET_XCAT_POLICER_METER_REG_MCAST_E : SNET_XCAT_POLICER_METER_UNREG_MCAST_E;
            if(descrPtr->egressFilterRegistered)
            {
                __LOG(("packet type : SNET_XCAT_POLICER_METER_REG_MCAST_E \n"));
            }
            else
            {
                __LOG(("packet type : SNET_XCAT_POLICER_METER_UNREG_MCAST_E \n"));
            }
            break;
        default:    /* BC,ARP-BC*/
            *pcktTypePtr = SNET_XCAT_POLICER_METER_BCAST_E;
            __LOG(("packet type : SNET_XCAT_POLICER_METER_BCAST_E \n"));
            break;
    }
}

/**
* @internal snetXcatIpfixTimestampFormat function
* @endinternal
*
* @brief   Convert tick clocks to time stamp format
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in] clock                    -  value in ticks
*                                      OUTPUT:
*                                      timestampPtr    - pointer to timestamp format value
*                                      RETURN:
*
* @note Time stamp format:
*       [15:8] The eight least significant bits of the seconds field
*       [7:0] The eight most significant bits of the nanoseconds field
*
*/
GT_VOID snetXcatIpfixTimestampFormat
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 clock,
    OUT GT_U32 * timeStampPtr
)
{
    GT_U32 nanoSeconds = 0;     /* IPfix nano timer value */
    GT_U32 seconds = 0;         /* IPfix second timer */

    SNET_TOD_CLOCK_FORMAT_MAC(clock, seconds, nanoSeconds);
    *timeStampPtr = (((nanoSeconds >> 22) & 0xff) | ((seconds & 0xff) << 8));
}


/**
* @internal snetXcatIpfixCounterWrite function
* @endinternal
*
* @brief   Set packets/data units billing counter value
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in] descrPtr                 - packet descriptor (ignored when NULL)
* @param[in] ipFixCounterRegPtr       - pointer to IPFix counter register write memory
*                                      bytes               - byte counter write value
* @param[in] packets                  -  counter write value
* @param[in] stamps                   -  counter write value
* @param[in] drops                    -  counter write value
*                                      OUTPUT:
*                                      RETURN:
*/
GT_VOID snetXcatIpfixCounterWrite
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * ipFixCounterRegPtr,
    IN GT_U64 * bytesCntPtr,
    IN GT_U32 packets,
    IN GT_U32 stamps,
    IN GT_U32 drops
)
{
    DECLARE_FUNC_NAME(snetXcatIpfixCounterWrite);

    GT_U32  index = descrPtr ?  descrPtr->countingActuallAccessedIndex : SMAIN_NOT_VALID_CNS;

    if(descrPtr == NULL)
    {
        __LOG(("CPU trigger modification in the counters \n"));
    }


    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        SMEM_LION3_PLR_IPFIX_ENTRY_LARGE_FIELD_SET(devObjPtr,ipFixCounterRegPtr,
                        index,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_BYTE_COUNT_E,
                        &bytesCntPtr->l[0]);

        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,ipFixCounterRegPtr,
                        index,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_PACKET_COUNT_E,
                        packets);

        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,ipFixCounterRegPtr,
                        index,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_TIME_STAMP_E,
                        stamps);

        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,ipFixCounterRegPtr,
                        index,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_DROP_COUNTER_E,
                        drops);
    }
    else
    {
        snetFieldValueSet(ipFixCounterRegPtr,   0, 32, bytesCntPtr->l[0]);
        snetFieldValueSet(ipFixCounterRegPtr,  32,  4, bytesCntPtr->l[1]);
        snetFieldValueSet(ipFixCounterRegPtr,  36, 30, packets);
        snetFieldValueSet(ipFixCounterRegPtr,  66, 16, stamps);
        snetFieldValueSet(ipFixCounterRegPtr, 198, 30, drops);
    }
}

/**
* @internal snetXcatPolicerIpfixDropWaCheck function
* @endinternal
*
* @brief   IPFIX drop counters wraparound indications and action
*
* @param[in] devObjPtr                - pointer to device object
* @param[in] descrPtr                 - pointer to frame descriptor
* @param[in] dropCountEn              - drop counter enable/disable
* @param[in] dropPcktsPtr             - pointer to drop packets counter
* @param[in] treshold                 -  value
* @param[in] wrapAction               - wrap around action: clear counter or no action
*
* @param[out] wrapTriggeredPtr         - pointer to wrap around trigger
*                                      RETURN:
*/
static void snetXcatPolicerIpfixDropWaCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_BIT dropCountEn,
    IN GT_U32 * dropPcktsPtr,
    GT_U32 treshold,
    GT_BIT wrapAction,
    GT_BOOL * wrapTriggeredPtr
)
{
    if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_HARD_DROP_E ||
       descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_SOFT_DROP_E)
    {
        if(dropCountEn ||
          (descrPtr->meterDp == SKERNEL_CONFORM_RED ||
           descrPtr->meterDp == SKERNEL_CONFORM_DROP))
        {
            snetXcatPolicerIpfixWaCheck(devObjPtr, descrPtr,
                                        SNET_XCAT_POLICER_IPFIX_DROP_PKTS_COUNT_E,
                                        dropPcktsPtr, treshold, wrapAction, wrapTriggeredPtr);
        }
    }
}

/**
* @internal snetXcatPolicerIpfixGoodPcktWaCheck function
* @endinternal
*
* @brief   IPFIX good packets wraparound indications and action
*
* @param[in] devObjPtr                - pointer to device object
* @param[in] descrPtr                 - pointer to frame descriptor
* @param[in] goodPcktsPtr             - pointer to good packets counter
* @param[in] treshold                 -  value
* @param[in] wrapAction               - wrap around action: clear counter or no action
* @param[in,out] wrapTriggeredPtr         - pointer to wrap around trigger
*                                      RETURN:
*/
static void snetXcatPolicerIpfixGoodPcktWaCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * goodPcktsPtr,
    IN GT_U32 treshold,
    IN GT_BIT wrapAction,
    INOUT GT_BOOL * wrapTriggeredPtr
)
{
    if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FORWARD_E ||
       descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E)
    {
        snetXcatPolicerIpfixWaCheck(devObjPtr, descrPtr,
                                    SNET_XCAT_POLICER_IPFIX_GOOD_PKTS_COUNT_E,
                                    goodPcktsPtr, treshold, wrapAction, wrapTriggeredPtr);
    }
}

/**
* @internal snetXcatPolicerIpfixBytesWaCheck function
* @endinternal
*
* @brief   IPFIX bytes wraparound indications and action
*
* @param[in] devObjPtr                - pointer to device object
* @param[in] descrPtr                 - pointer to frame descriptor
* @param[in] bytes                    - pointer to byte counter
* @param[in] bytes                    - 64 bit counter value
* @param[in] treshold64Ptr            - 64 bit treshold value
* @param[in] wrapAction               - wrap around action: clear counter or no action
*
* @param[out] wrapTriggeredPtr         - pointer to wrap around trigger
*                                      RETURN:
*/
static void snetXcatPolicerIpfixBytesWaCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT GT_U64 * bytesCntPtr,
    IN GT_U32 bytes,
    IN GT_U64 * treshold64Ptr,
    IN GT_BIT wrapAction,
    OUT GT_BOOL * wrapTriggeredPtr
)
{
    if(descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_FORWARD_E &&
       descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E)
    {
        return;
    }

    snetXcatPolicerIpfixWa64Check(devObjPtr, descrPtr,
                                  SNET_XCAT_POLICER_IPFIX_BYTES_COUNT_E,
                                  bytesCntPtr, bytes, treshold64Ptr,
                                  wrapAction, wrapTriggeredPtr);
}

/**
* @internal snetLion2PolicerOamLmCounterIncrement function
* @endinternal
*
* @brief   Packet counting for OAM loss measurement (LM).
*/
static GT_BOOL snetLion2PolicerOamLmCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 policerCntIndex,
    GT_U64 increment64
)
{
    DECLARE_FUNC_NAME(snetLion2PolicerOamLmCounterIncrement);

    GT_U32 regAddr;                         /* register address */
    GT_U32 * regPtr;                        /* register data pointer */
    GT_U32 *policerBillingCounterRegPtr;    /* pointer to billing table entry */
    GT_U64 val64;                           /* counter 64 bits increment */
    GT_U32 fieldVal;                        /* register entry field */
    GT_U32 lmCaptureMode;                   /* LM counter capture mode: copy/insert */

    if(devObjPtr->oamSupport.plrSupportOamLmCapture == 0)
    {
        /* LM OAM packet capturing is not supported */
        __LOG(("LM OAM packet capturing is not supported"));
        return GT_FALSE;
    }

    if(descrPtr->oamInfo.lmCounterCaptureEnable == 0)
    {
        /* Policer Counter Capture disabled */
        __LOG(("Policer Counter Capture disabled"));
        return GT_FALSE;
    }

    regAddr = SMEM_XCAT_POLICER_GLB1_CONF_REG(devObjPtr, descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    fieldVal = SMEM_U32_GET_FIELD(regPtr[0], 7, 1);
    if(fieldVal == 0)
    {
        /* Counter Capture for LM disabled */
        __LOG(("Counter Capture for LM disabled"));
        return GT_TRUE;
    }

    /* Billing counter entry pointer */
    policerBillingCounterRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    /* LM Counter Capture Mode */
    lmCaptureMode =
        SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,policerBillingCounterRegPtr,
            descrPtr->countingActuallAccessedIndex,
            SMEM_LION3_PLR_BILLING_TABLE_FIELDS_LM_COUNTER_CAPTURE_MODE_E);

    snetXcatPolicerBillingCounterRead(devObjPtr, descrPtr,policerBillingCounterRegPtr,
                                       SKERNEL_CONFORM_GREEN, &val64);
    val64 = prvSimMathAdd64(val64, increment64);

    /* Update billing entry */
    snetXcatPolicerBillingCounterWrite(devObjPtr, descrPtr,policerBillingCounterRegPtr,
                                        SKERNEL_CONFORM_GREEN, &val64);


    if(lmCaptureMode == 0)/* LM Counter Capture Mode - Copy  */
    {
        __LOG(("LM Counter Capture Mode - Copy \n"));
        /*Green Counter Snapshot Valid*/
        fieldVal =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,policerBillingCounterRegPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_VALID_E);

        /* Green Counter Snapshot Valid */
        __LOG(("Green Counter Snapshot Valid[%d] \n",
            fieldVal));
        if(fieldVal)
        {
            if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E ||
               descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E)
            {
                regAddr = SMEM_LION3_POLICER_OAM_REG(devObjPtr,
                                                     descrPtr->policerCycle);
                regPtr = smemMemGet(devObjPtr, regAddr);
                /* Failed Capture CPU Code */
                descrPtr->cpuCode = SMEM_U32_GET_FIELD(regPtr[0], 0, 8);
                __LOG(("Failed Capture CPU Code : descrPtr->cpuCode[%d] \n"));
            }
            else
            {
                __LOG(("The 'Failed Capture CPU Code' : not relevant as this is not FORWARD/MIRROR_TO_CPU \n"));
            }
        }
        else
        {
            __LOG(("Update 'Snapshot of the green traffic counter' , and set valid bit \n"));
            /* Write to snapshot of the green traffic counter
            after billing counter update */
            SMEM_LION3_PLR_BILLING_ENTRY_LARGE_FIELD_SET(devObjPtr,policerBillingCounterRegPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_E,
                 &val64.l[0]);

            /* When the policer copies the Green Counter, it sets the valid bit.
            When the CPU reads the snapshot, the CPU clears the valid bit. */
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_SET(devObjPtr,policerBillingCounterRegPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_VALID_E,
                1);
        }
    }
    else
    {
        __LOG(("LM Counter Capture Mode - Insert \n"));
        /* In Insert case Billing is not performed for this packet even if desc<BillingEn>==SET !!! */
        __LOG(("In Insert case Billing is not performed for this packet even if desc<BillingEn>==SET !!!"));
        descrPtr->oamInfo.lmCounter = val64.l[0];
        descrPtr->oamInfo.lmCounterInsertEnable = 1;
    }

    return GT_TRUE;
}

/**
* @internal snetSip6PolicerMeterMirrorCheck function
* @endinternal
*
* @bbrief   (sip6) function check if the meter entry request for mirror to analyzer
*           and update the descriptor if needed.
*/
GT_VOID snetSip6PolicerMeterMirrorCheck
    (
    IN    SKERNEL_DEVICE_OBJECT           * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN    SNET_CHT3_POLICER_QOS_INFO_STC  * qosProfileInfoPtr,
    IN    GT_BOOL                         isEgress
    )
{
    DECLARE_FUNC_NAME(snetSip6PolicerMeterMirrorCheck);

    GT_U32 * meteringEntryPtr;
    GT_U32  myColor,mirrorForMyColorEn;
    GT_U32  plrAnalyzerIndex = 0;
    GT_U32  regAddr; /* register address */
    GT_U32 * regPtr;

   SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_ENT greenFieldId;

   SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_ENT yellowFieldId;

   SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_ENT redFieldId;

    meteringEntryPtr = descrPtr->policerMeterConfigEntryMemoryPtr;
    if (meteringEntryPtr == NULL)
        return;

    if (isEgress == GT_FALSE)
    {
        /*ingress*/
        greenFieldId   =
            SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_GREEN_MIRROR_TO_ANALYZER_ENABLE_E;
        yellowFieldId  =
            SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_YELLOW_MIRROR_TO_ANALYZER_ENABLE_E;
        redFieldId     =
            SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_RED_MIRROR_TO_ANALYZER_ENABLE_E;
    }
    else
    {
        /*egress*/
        greenFieldId   =
            SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_GREEN_MIRROR_TO_ANALYZER_ENABLE_E;
        yellowFieldId  =
            SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_YELLOW_MIRROR_TO_ANALYZER_ENABLE_E;
        redFieldId     =
            SMEM_SIP6_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_RED_MIRROR_TO_ANALYZER_ENABLE_E;
    }

    myColor = qosProfileInfoPtr->cl;

    mirrorForMyColorEn = SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(
        devObjPtr,
        meteringEntryPtr,
        descrPtr->policerActuallAccessedIndex,
        myColor == SKERNEL_CONFORM_GREEN  ? greenFieldId :
        myColor == SKERNEL_CONFORM_YELLOW ? yellowFieldId :
        redFieldId
        );

    if(mirrorForMyColorEn)
    {
        __LOG(("sip6 : meter entry needs mirror to analyzer \n"));

        regAddr = SMEM_SIP6_PLR_ANALYZER_INDEXES_REG(devObjPtr, descrPtr->policerCycle);
        regPtr = smemMemGet(devObjPtr, regAddr);
        plrAnalyzerIndex = SMEM_U32_GET_FIELD(regPtr[0], myColor*3, 3); /*get from 'myColor' in the register of 'global analyzers' of PLR*/

        if(isEgress)
        {
            snetXcatEgressMirrorAnalyzerIndexSelect(devObjPtr,descrPtr,plrAnalyzerIndex);
        }
        else
        {
            snetXcatIngressMirrorAnalyzerIndexSelect(devObjPtr,descrPtr,plrAnalyzerIndex);
        }
    }
    else
    {
        __LOG(("sip6 : meter entry NOT needs mirror to analyzer \n"));
    }

    return;
}

/**
* @internal snetPlrTablesFormatInit function
* @endinternal
*
* @brief   init the format of PLR tables.(IPLR0,1 and EPLR)
*
* @param[in] devObjPtr                - pointer to device object.
*/
void snetPlrTablesFormatInit(
    IN SKERNEL_DEVICE_OBJECT            * devObjPtr
)
{
    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_PLR_METERING_E,
        lion3PlrMeteringTableFieldsFormat, lion3PlrMeteringFieldsTableNames);

    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_PLR_E_ATTRIBUTES_E,
        lion3PlrEAttributesTableFieldsFormat, lion3PlrEAttributesFieldsTableNames);

    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_PLR_BILLING_E,
        lion3PlrBillingTableFieldsFormat, lion3PlrBillingFieldsTableNames);

    if(SMEM_CHT_IS_SIP6_10_GET(devObjPtr))
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_PLR_IPFIX_E,
            sip6_10_PlrIpfixTableFieldsFormat, sip6_10_PlrIpfixFieldsTableNames);
    }
    else
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_PLR_IPFIX_E,
            lion3PlrIpfixTableFieldsFormat, lion3PlrIpfixFieldsTableNames);
    }

    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_PLR_HIERARCHICAL_E,
        lion3PlrHierarchicalTableFieldsFormat, lion3PlrHierarchicalFieldsTableNames);


    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_PLR_METERING_CONFIG_E,
            sip5_15PlrMeteringConfigTableFieldsFormat, sip5_15PlrMeteringConfigFieldsTableNames);

        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_PLR_BILLING_E,
            sip5_15PlrBillingTableFieldsFormat, lion3PlrBillingFieldsTableNames);
    }

    if(SMEM_CHT_IS_SIP6_GET(devObjPtr))
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_PLR_METERING_CONFIG_E,
            sip6PlrMeteringConfigTableFieldsFormat, sip6PlrMeteringConfigFieldsTableNames);
    }
    else if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_PLR_METERING_CONFIG_E,
            sip5_20PlrMeteringConfigTableFieldsFormat, sip5_15PlrMeteringConfigFieldsTableNames);
    }

    if(SMEM_CHT_IS_SIP6_GET(devObjPtr))
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_PLR_E_ATTRIBUTES_E,
            falconPlrEAttributesTableFieldsFormat, lion3PlrEAttributesFieldsTableNames);

        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_PLR_HIERARCHICAL_E,
            falconPlrHierarchicalTableFieldsFormat, lion3PlrHierarchicalFieldsTableNames);
    }
}



/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
*/
/**
********************************************************************************
* @file sRemoteTm.h
*
* @brief The file to handle connection to remote TM (traffic manager) device (simulation of TM)
*
* @version   2
********************************************************************************
*/
#ifndef __sRemoteTmh
#define __sRemoteTmh

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define UINT8   GT_U8
#define UINT32  GT_U32
#define UINT64  GT_U64


/***************************************************/
/***************************************************/
/***************************************************/
/***************************************************/
/* start definitions that define the info send     */
/* on the sockets between the PP<-->TM             */
/***************************************************/
/***************************************************/
/***************************************************/
/***************************************************/

typedef enum {
    PP_TMSIM_DROP_QUERY,             /* PP to TMsim */
    PP_TMSIM_DROP_RESPONSE,          /* TMsim to PP */

    PP_TMSIM_START_PACKET_PROCESS,   /* PP to TMsim */
    PP_TMSIM_PACKET_DONE,            /* TMsim to PP */

    PP_TMSIM_REGISTER_WRITE,         /* PP to TMsim */
    PP_TMSIM_REGISTER_READ,          /* PP to TMsim */
    PP_TMSIM_REGISTER_READ_RESPONSE, /* TMsim to PP */

    PP_TMSIM_ACK_RESPONSE /* PP to TMsim & TMsim to PP. Send only if ack_needed not 0 */
}PPMsim_msg_type;

/*
Header
Each of the messages begins with the following header which is followed by the message specific data:
*/
/* Header on all ASIC-TM simulation communication */
typedef struct {
    UINT32 version; /* integration version. */
    UINT32  message_type;     /* type of message (one of PPMsim_msg_type). */
    UINT32 length; /* Length of message including this header */
    UINT32 tid; /* Transaction id associated with this message not to confuse with packet id. */
    UINT32 ack_needed; /* 1 - for indication that acknowledge is needed. 0 to indicate and no
                        acknowledge is required */
    UINT32 error_code;     /* TBD */
}PPTMsim_header;

/*PP_TMSIM_DROP_QUERY
PP sends Drop Query to TMsim. The message starts with PPTmsim_header followed by the following structure:
*/
typedef struct
{
    UINT64 packet_id; /* Unique id that is generated by PP*/
    UINT32 dropProbabilitySelect; /* always local 0*/
    UINT32 cos;
    UINT32 color;
    UINT32 queue;
}PPTMsim_drop_query;

/*PP_TMSIM_DROP_RESPONSE
Tmsim sends Drop Response to PP. There is no need for Query ID since PP waits for the response before sending a new query.
The message starts with PPTmsim_header followed by the following structure:
*/
typedef struct  {
    UINT64 packet_id; /* Unique id that was generated by PP*/
    UINT32 queue;
    /*drop recommendations*/
    UINT32 tailQueueRecommendation;
    UINT32 wredQueueRecommendation;
    UINT32 tailAnodeRecommendation;
    UINT32 wredAnodeRecommendation;
    UINT32 tailBnodeRecommendation;
    UINT32 wredBnodeRecommendation;
    UINT32 tailCnodeRecommendation;
    UINT32 wredCnodeRecommendation;
    UINT32 tailPortRecommendation;
    UINT32 wredPortRecommendation;
    UINT32 bufferRsv;
    UINT32 outOfRsv;
    UINT32 dropProbability;
    UINT32 aNode;
    UINT32 bNode;
    UINT32 cNode;
    UINT32 port;
}PPTMsim_drop_response;

/*PP_TMSIM_START_PACKET_PROCESS
PP sends Start Packet process to TMsim. Packet id is generated by PP.
The message starts with PPTmsim_header followed by the following structure:
*/
typedef struct  {
    /* Packet header */
    UINT32  color;
    UINT32  cos;
    UINT32  pk_len;
    UINT32  queue;
    UINT64 packet_id;                /* unique packet id generated by PP simulation*/
}PPTMsim_packet_header;
/*
PP_TMSIM_PACKET_DONE
Tmsim sends Drop Response to PP.
The message starts with PPTmsim_header followed by the following structure:
*/
typedef struct {
    UINT64 packet_id;                /* unique packet id generated by PP simulation*/
    UINT32 egress_port;              /* TM final egress port */
}PPTMsim_packet_done_header ;
/*
PP_TMSIM_REGISTER_WRITE
PP sends Register write to TMsim.
The message starts with PPTmsim_header followed by the following structure:
*/
/*PP_TMSIM_REGISTER_READ
PP sends Register read to TMsim.
The message starts with PPTmsim_header followed by the following structure:
*/
/*PP_TMSIM_REGISTER_READ_RESPONSE
Tmsim sends Register read Response to PP.
The message starts with PPTmsim_header followed by the following structure:
*/
typedef struct
{
    UINT64 address;     /* address as defined in CIDER */
    UINT64 value;
}PPTMsim_register;

/*PP_TMSIM_ACK_RESPONSE
TMsim sends to PP following any request that has indication of ack_needed
PP send to TMsim following any request that has indication of ack_needed
No data will follow the PPTmsim_header.
*/

/***************************************************/
/***************************************************/
/***************************************************/
/***************************************************/
/* end of definitions that define the info send    */
/* on the sockets between the PP<-->TM             */
/***************************************************/
/***************************************************/
/***************************************************/
/***************************************************/

/* indication that we work with remote TM memory managers */
extern GT_U32   sRemoteTmUsed;
/*******************************************************************************
 * Typedef:     struct   PP_TO_TM_PACKET_INFO_STC
 *
 * Description: the info that PP send to TM for processing a packet.
 *
 * Fields :
 *        cookiePtr - cookie to identify the packet
 *        others - info needed by the TM
 * Comments:
 *
 *******************************************************************************/
typedef struct{
    GT_VOID*    cookiePtr;
    GT_U32  color;
    GT_U32  cos;
    GT_U32  pk_len;
    GT_U32  queue;
}SREMOTE_TM_PP_TO_TM_PACKET_INFO_STC;

/*******************************************************************************
 * Typedef:     struct   SREMOTE_TM_PP_TO_TM_INPUT_DROP_INFO_STC
 *
 * Description: the info that PP send to TM for 'drop' decisions
 *
 * Fields :
 *
 * Comments:
 *
 *******************************************************************************/
typedef struct{
    GT_U32 dropProbabilitySelect; /* always local 0*/
    GT_U32 cos;
    GT_U32 color;
    GT_U32 queue;
}SREMOTE_TM_PP_TO_TM_INPUT_DROP_INFO_STC;

/*******************************************************************************
 * Typedef:     struct   SREMOTE_TM_PP_TO_TM_INPUT_DROP_INFO_STC
 *
 * Description: the info that PP send to TM for 'drop' decisions
 *
 * Fields :
 *
 * Comments:
 *
 *******************************************************************************/
typedef struct{
    GT_U32 queue;
    /*drop recommendations*/
    GT_U32 tailQueueRecommendation;
    GT_U32 wredQueueRecommendation;
    GT_U32 tailAnodeRecommendation;
    GT_U32 wredAnodeRecommendation;
    GT_U32 tailBnodeRecommendation;
    GT_U32 wredBnodeRecommendation;
    GT_U32 tailCnodeRecommendation;
    GT_U32 wredCnodeRecommendation;
    GT_U32 tailPortRecommendation;
    GT_U32 wredPortRecommendation;
    GT_U32 bufferRsv;
    GT_U32 outOfRsv;
    GT_U32 dropProbability;
    GT_U32 aNode;
    GT_U32 bNode;
    GT_U32 cNode;
    GT_U32 port;
}SREMOTE_TM_PP_TO_TM_OUTPUT_DROP_INFO_STC;

/*******************************************************************************
*  SREMOTE_TM_RECEIVED_PACKET_DONE_FROM_TM_CALLBACK_FUNC
*
* DESCRIPTION:
*      typedef for 'callback' function that will be called when when the
*       'packet done' message is returned from the TM (for specific packetId).
*
* INPUTS:
*       simDeviceId  - device id.
*       cookiePtr    - the cookie that was attached to the packet
*       tmFinalPort  - the TM final port
*
* OUTPUTS:
*
* RETURNS:
*
* COMMENTS:
*        the function is called from 'UDP socket listener' task context.
*        so the CB function must not to 'sleep' or 'heavy' operations
*
*******************************************************************************/
typedef void SREMOTE_TM_RECEIVED_PACKET_DONE_FROM_TM_CALLBACK_FUNC
(
    IN GT_U32   simDeviceId,
    IN GT_VOID* cookiePtr,
    IN GT_U32   tmFinalPort
);

/**
* @internal sRemoteTmBindCallBack function
* @endinternal
*
* @brief   register callback function(s) to the engine
*
* @param[in] packetDoneCbPtr          - callback for 'packet done' message
*/
void sRemoteTmBindCallBack(
    IN SREMOTE_TM_RECEIVED_PACKET_DONE_FROM_TM_CALLBACK_FUNC *packetDoneCbPtr
);

/**
* @internal sRemoteTmCreateUdpSockets function
* @endinternal
*
* @brief   create the needed sockets for TM device.
*         using UDP sockets (as used by the TM device)
* @param[in] simDeviceId              - Simulation device ID.
*
* @note must be called before sRemoteTmWaitForTmServer
*
*/
void sRemoteTmCreateUdpSockets
(
    IN GT_U32   simDeviceId
);

/**
* @internal sRemoteTmWaitForTmServer function
* @endinternal
*
* @brief   initiate 'wait' for the TM server to be ready.
*         function does not returns until TM server response.
*
* @note must be called after sRemoteTmCreateUdpSockets
*
*/
void sRemoteTmWaitForTmServer(IN GT_U32 simDeviceId);

/**
* @internal sRemoteTmTest_emulateDummyTmDevice function
* @endinternal
*
* @brief   test the messages between simulation and TM
*/
void sRemoteTmTest_emulateDummyTmDevice(void);

/**
* @internal sRemoteTmPacketSendToTm function
* @endinternal
*
* @brief   send packet to TM
*/
void sRemoteTmPacketSendToTm
(
    IN GT_U32 simDeviceId,
    IN SREMOTE_TM_PP_TO_TM_PACKET_INFO_STC *packetInfoPtr
);

/**
* @internal sRemoteTmPacketDropInfoGet function
* @endinternal
*
* @brief   send to TM query about the 'drop' for 'input info' and get reply with
*         pass/drop + drop recommendations.
*
* @param[out] outDropInfoPtr           - (pointer to) output info
*/
void sRemoteTmPacketDropInfoGet
(
    IN GT_U32 simDeviceId,
    IN SREMOTE_TM_PP_TO_TM_INPUT_DROP_INFO_STC   *inDropInfoPtr,
    OUT SREMOTE_TM_PP_TO_TM_OUTPUT_DROP_INFO_STC *outDropInfoPtr
);

/**
* @internal sRemoteTmRegisterRead function
* @endinternal
*
* @brief   Read register from TM .
*         logic of operation :
*         1. 'read register' message send from PP to TM.
*         2. wait on semaphore for response from TM
*         the TM sent to PP 'read register response' with the needed value.
*         signal the semaphore ...
*         3. get the info and return
*
* @param[out] valuePtr                 - (pointer to) get the value of the 'address' (64 bits value)
*/
void sRemoteTmRegisterRead
(
    IN GT_U32 simDeviceId,
    IN GT_U64 *addressPtr,
    OUT GT_U64 *valuePtr
);

/**
* @internal sRemoteTmRegisterWrite function
* @endinternal
*
* @brief   Write register To TM .
*/
void sRemoteTmRegisterWrite
(
    IN GT_U32 simDeviceId,
    IN GT_U64 *addressPtr,
    IN GT_U64 *valuePtr
);


#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif  /* __smainh */



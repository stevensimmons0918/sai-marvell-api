/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
*/
/**
********************************************************************************
* @file cpssDxChPortTx.c
*
* @brief CPSS implementation for configuring the Physical Port Tx Traffic Class
* Queues.
* This covers:
* - queuing enable/disable
* - transmit enable/disable
* - scheduling algorithms, bandwidth management
* - shaping on queues and the logical port
* - drop algorithms for congestion handling
*
* @version   127
********************************************************************************
*/
#define CPSS_LOG_IN_MODULE_ENABLE
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortLog.h>
#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChInfo.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortTx.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortPfc.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortBufMg.h>
#include <cpss/dxCh/dxChxGen/cos/private/prvCpssDxChCoS.h>
#include <cpssCommon/private/prvCpssMath.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChHwInit.h>
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortTxDba.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortTxDba.h>

#include <cpss/dxCh/dxChxGen/txq/private/prvCpssDxChTxqMain.h>
#include <cpss/dxCh/dxChxGen/txq/private/utils/prvCpssDxChTxqDebugUtils.h>
#include <cpss/dxCh/dxChxGen/txq/private/units/prvCpssDxChTxqPds.h>
#include <cpss/dxCh/dxChxGen/txq/private/units/prvCpssDxChTxqPfcc.h>
#include <cpss/dxCh/dxChxGen/txq/private/utils/prvCpssDxChTxqRemotePortSched.h>
#include <cpss/generic/private/prvCpssCommonDefs.h>
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortTxDba.h>
#include <cpss/dxCh/dxChxGen/txq/private/utils/prvCpssDxChTxqTailDropUtils.h>
#include <cpss/dxCh/dxChxGen/txq/private/utils/prvCpssDxChTxqFcUtils.h>
#include <cpss/dxCh/dxChxGen/txq/private/utils/prvCpssDxChTxqShapingUtils.h>
#include <cpss/dxCh/dxChxGen/txq/private/utils/prvCpssDxChTxqSchedulingUtils.h>
#include <cpss/dxCh/dxChxGen/port/PizzaArbiter/DynamicPizzaArbiter/prvCpssDxChPortTxQHighSpeedPortsDrv.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDb.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDbInterface.h>
#include <cpss/dxCh/dxChxGen/txq/private/utils/prvCpssDxChTxqPreemptionUtils.h>



#define PRV_CPSS_DXCH_CPU_PORT_PROFILE_CNS       CPSS_PORT_TX_SCHEDULER_PROFILE_1_E
#define PRV_CPSS_DXCH_NET_GE_PORT_PROFILE_CNS    CPSS_PORT_TX_SCHEDULER_PROFILE_2_E
#define PRV_CPSS_DXCH_NET_10GE_PORT_PROFILE_CNS  CPSS_PORT_TX_SCHEDULER_PROFILE_3_E
#define PRV_CPSS_DXCH_CASCADING_PORT_PROFILE_CNS CPSS_PORT_TX_SCHEDULER_PROFILE_4_E

#define PRV_CPSS_DXCH_TC_DP_BUFFER_LIMIT_MAX_CNS                0xFFF
#define PRV_CPSS_DXCH_TC_DP_DESC_LIMIT_MAX_CNS                  0xFFF
#define PRV_CPSS_DXCH_TC_DP_PARAMS_LEN_CNS                      24
#define PRV_CPSS_DXCH_TC_DP_BUFFER_LIMIT_OFFSET_CNS             12
#define PRV_CPSS_DXCH_TC_DP_BUFFER_LIMIT_LEN_CNS                12
#define PRV_CPSS_DXCH_TC_DP_DESC_LIMIT_OFFSET_CNS               0
#define PRV_CPSS_DXCH_TC_DP_DESC_LIMIT_LEN_CNS                  12

#define PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_MAX_CNS               0x3FFF
#define PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_MAX_CNS                 0x3FFF
#define PRV_CPSS_DXCH3_TC_DP_PARAMS_LEN_CNS                     28
#define PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_OFFSET_CNS            14
#define PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_LEN_CNS               14
#define PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_OFFSET_CNS              0
#define PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_LEN_CNS                 14

#define PRV_CPSS_DXCH_INGRESS_MIRR_2_ANLY_DESC_MAX_CNS          0xFFF
#define PRV_CPSS_DXCH_EGRESS_MIRR_2_ANLY_DESC_MAX_CNS           0xFFF
#define PRV_CPSS_DXCH_INGRESS_MIRR_2_ANLY_DESC_MAX_OFFSET_CNS   12
#define PRV_CPSS_DXCH_MIRR_2_ANLY_DESC_MAX_PARAM_LEN_CNS        24

#define PRV_CPSS_DXCH3_INGRESS_MIRR_2_ANLY_DESC_MAX_CNS         0x3FFF
#define PRV_CPSS_DXCH3_EGRESS_MIRR_2_ANLY_DESC_MAX_CNS          0x3FFF
#define PRV_CPSS_DXCH3_INGRESS_MIRR_2_ANLY_DESC_MAX_OFFSET_CNS  14
#define PRV_CPSS_DXCH3_MIRR_2_ANLY_DESC_MAX_PARAM_LEN_CNS       28

#define PRV_CPSS_DXCH_MULTICAST_PCKTS_DESC_LIMIT_MAX_CNS        0x1F
#define PRV_CPSS_DXCH_TOKEN_BUCKET_TOKENS_OFFSET_CNS            4
#define PRV_CPSS_DXCH_TOKEN_BUCKET_TOKENS_LEN_CNS               12
#define PRV_CPSS_DXCH_TOKEN_BUCKET_SLOW_RATE_EN_OFFSET_CNS      1
#define PRV_CPSS_DXCH_TOKEN_BUCKET_SLOW_RATE_EN_LEN_CNS         1
#define PRV_CPSS_DXCH_TOKEN_BUCKET_EN_LEN_CNS                   1
#define PRV_CPSS_DXCH_TOKEN_BUCKET_RESERVED_LEN_CNS             2

#define PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_MIN_CNS            1
#define PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_MAX_CNS            15
#define PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_MIN_CNS           1
#define PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_MAX_CNS           15
#define PRV_CPSS_DXCH_GIG_SLOW_TOKEN_BCKT_UPD_RATIO_MIN_CNS     1
#define PRV_CPSS_DXCH_GIG_SLOW_TOKEN_BCKT_UPD_RATIO_MAX_CNS     16
#define PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_OFFSET_CNS         26
#define PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_LEN_CNS            4
#define PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_OFFSET_CNS        22
#define PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_LEN_CNS           4
#define PRV_CPSS_DXCH_GIG_SLOW_TOKEN_BCKT_UPD_RATIO_OFFSET_CNS  18
#define PRV_CPSS_DXCH_GIG_SLOW_TOKEN_BCKT_UPD_RATIO_LEN_CNS     4

#define PRV_CPSS_DXCH_PORT_REQUEST_MASK_INDEX_MAX_CNS           3

/* for the TxQ dump */
#define PRV_CPSS_DXCH_MAX_TC                                    8
#define PRV_CPSS_DXCH_SIP_6_MAX_TC                              16



#define PRV_CPSS_DXCH_SIP6_TXQ_DUMP_PDX 0x1
#define PRV_CPSS_DXCH_SIP6_TXQ_DUMP_PSI 0x2
#define PRV_CPSS_DXCH_SIP6_TXQ_DUMP_PDQ_SW 0x4
#define PRV_CPSS_DXCH_SIP6_TXQ_DUMP_PDQ_HW 0x8
#define PRV_CPSS_DXCH_SIP6_TXQ_DUMP_SDQ 0x10
#define PRV_CPSS_DXCH_SIP6_TXQ_DUMP_PDS 0x20
#define PRV_CPSS_DXCH_SIP6_TXQ_DUMP_SW_MAP_SHADOW 0x40
#define PRV_CPSS_DXCH_SIP6_TXQ_DUMP_SCHED_PROFILE_DB 0x80




#define PRV_CPSS_DXCH_SIP6_TXQ_DUMP_ALL_UNITS 0xFF

#define PRV_CPSS_DXCH_SIP6_TXQ_DUMP_INFO (PRV_CPSS_DXCH_SIP6_TXQ_DUMP_PDQ_HW)


#define PRV_CPSS_DXCH_SIP6_TXQ_DUMP_ENABLED(UNIT) (PRV_CPSS_DXCH_SIP6_TXQ_DUMP_INFO&PRV_CPSS_DXCH_SIP6_TXQ_DUMP_##UNIT)



/* Convert CPSS_PORT_TX_TAIL_DROP_PROBABILITY_ENT to HW value */
#define PRV_CPSS_PORT_TX_TAIL_DROP_PROBABILITY_TO_HW_CONVERT_MAC(_probability, _hwValue) \
    switch (_probability)                                                             \
    {                                                                          \
    case CPSS_PORT_TX_TAIL_DROP_PROBABILITY_100_E:                         \
    _hwValue = 0x0;                                                     \
    break;                                                             \
    \
    case CPSS_PORT_TX_TAIL_DROP_PROBABILITY_89_E:                          \
    _hwValue = 0x1;                                                     \
    break;                                                             \
    case CPSS_PORT_TX_TAIL_DROP_PROBABILITY_73_E:                           \
    _hwValue = 0x2;                                                     \
    break;                                                             \
    case CPSS_PORT_TX_TAIL_DROP_PROBABILITY_67_E:                             \
    _hwValue = 0x3;                                                     \
    break;                                                             \
    case CPSS_PORT_TX_TAIL_DROP_PROBABILITY_50_E:                             \
    _hwValue = 0x4;                                                     \
    break;                                                             \
    case CPSS_PORT_TX_TAIL_DROP_PROBABILITY_25_E:                             \
    _hwValue = 0x5;                                                     \
    break;                                                             \
    default:                                                               \
    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);     \
    }

/* Convert HW value to  CPSS_PORT_TX_TAIL_DROP_PROBABILITY_ENT */
#define PRV_CPSS_PORT_TX_HW_TO_TAIL_DROP_PROBABILITY_CONVERT_MAC(_probability, _hwValue) \
    switch (_hwValue)                                                             \
    {                                                                          \
    case 0x0:                         \
    _probability = CPSS_PORT_TX_TAIL_DROP_PROBABILITY_100_E;\
    break;                                                             \
    \
    case 0x1:                          \
    _probability = CPSS_PORT_TX_TAIL_DROP_PROBABILITY_89_E;\
    break;                                                           \
    case 0x2:                           \
    _probability = CPSS_PORT_TX_TAIL_DROP_PROBABILITY_73_E;                \
    break;                                                             \
    case 0x3:                             \
    _probability = CPSS_PORT_TX_TAIL_DROP_PROBABILITY_67_E; \
    break;                                                             \
    case 0x4:                             \
    _probability = CPSS_PORT_TX_TAIL_DROP_PROBABILITY_50_E;            \
    break;                                                             \
    case 0x5:                             \
    _probability = CPSS_PORT_TX_TAIL_DROP_PROBABILITY_25_E;\
    break;\
    default:                                                               \
    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);     \
    }

/* Convert CPSS_DXCH_PORT_TXQ_OFFSET_WIDTH_ENT to HW value */
#define PRV_CPSS_PORT_TX_QUEUE_OFFSET_WIDTH_TO_HW_CONVERT_MAC(_offset, _hwValue) \
    switch (_offset)                                                             \
    {                                                                          \
    case CPSS_DXCH_PORT_TXQ_OFFSET_WIDTH_4_BIT_ENT:                         \
    _hwValue = 0x0;                                                     \
    break;                                                             \
    \
    case CPSS_DXCH_PORT_TXQ_OFFSET_WIDTH_8_BIT_ENT:                          \
    _hwValue = 0x1;                                                     \
    break;                                                             \
    default:                                                               \
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);     \
     break;\
    }
/* Convert HW value  to    CPSS_DXCH_PORT_TXQ_OFFSET_WIDTH_ENT*/

#define PRV_CPSS_PORT_HW_TO_TX_QUEUE_OFFSET_WIDTH_CONVERT_MAC(_hwValue, _offset) \
    switch (_hwValue)                                                             \
    {                                                                   \
     case 0x0:                                                          \
     _offset = CPSS_DXCH_PORT_TXQ_OFFSET_WIDTH_4_BIT_ENT;              \
     break;                                                             \
     case 0x1:                                                          \
      _offset = CPSS_DXCH_PORT_TXQ_OFFSET_WIDTH_8_BIT_ENT;             \
      break;                                                            \
    default:                                                            \
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);     \
     break;\
    }


/* Convert CPSS_DXCH_QUEUE_OFFSET_MODE_ENT to HW value */
#define PRV_CPSS_PORT_QUEUE_OFFSET_MODE_TO_HW_CONVERT_MAC(_offsetMode, _hwValue) \
    switch (_offsetMode)                                                             \
    {                                                                          \
    case CPSS_DXCH_QUEUE_OFFSET_MODE_PRIORITY_AND_VLAN_E:                         \
    _hwValue = 0x3;                                                     \
    break;                                                             \
    \
    case CPSS_DXCH_QUEUE_OFFSET_MODE_VLAN_E:                          \
    _hwValue = 0x1;                                                     \
    break;                                                             \
    case CPSS_DXCH_QUEUE_OFFSET_MODE_PRIORITY_QUEUE_E:                 \
    _hwValue = 0x2;                                                     \
     break;\
    default:                                                               \
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);     \
     break;\
    }
/* Convert HW value  to    CPSS_DXCH_QUEUE_OFFSET_MODE_ENT*/

#define PRV_CPSS_PORT_HW_TO_CPSS_DXCH_QUEUE_OFFSET_MODE_CONVERT_MAC(_hwValue, _offsetMode) \
    switch (_hwValue)                                                             \
    {                                                                   \
     case 0x3:                                                          \
     _offsetMode = CPSS_DXCH_QUEUE_OFFSET_MODE_PRIORITY_AND_VLAN_E;     \
     break;                                                             \
     case 0x1:                                                          \
      _offsetMode = CPSS_DXCH_QUEUE_OFFSET_MODE_VLAN_E;             \
      break;                                                            \
     case 0x2:                                                          \
      _offsetMode = CPSS_DXCH_QUEUE_OFFSET_MODE_PRIORITY_QUEUE_E;          \
      break;                                                            \
    default:                                                            \
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);     \
     break;\
    }



/* macro to validate the max buffer fill level

*/
#define PRV_CPSS_DXCH_CHECK_MAX_BUFFER_FILL_LVL_MAC(_maxBufFillLvl)       \
    if((_maxBufFillLvl) >= BIT_20)                                        \
    {                                                                     \
    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG); \
    }


#define PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(_devNum,_physicalPortNum,_queueOffset) \
    do{ \
        if(PRV_CPSS_SIP_6_CHECK_MAC(_devNum))\
        {\
            GT_BOOL valid;                                                                                      \
            GT_STATUS rcLocal;                                                                                  \
            rcLocal = prvCpssFalconTxqUtilsPortQueueOffsetValidGet(_devNum,_physicalPortNum,_queueOffset,&valid);\
            if(rcLocal!=GT_OK)                                                                                  \
            {                                                                                                   \
                CPSS_LOG_ERROR_AND_RETURN_MAC(rcLocal, LOG_ERROR_NO_MSG);                                       \
            }                                                                                                   \
            if(GT_FALSE==valid)                                                                                 \
            {\
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "Queue offset %d is not in port %d  range.\n",_queueOffset,_physicalPortNum);\
            }\
        }\
    }\
    while(0);

/*
* typedef: struct PORT_TX_SHAPER_TOKEN_BUCKET_STC
*
* Description:  structure to hold port's shaper info (per port/tc)
*
* Enumerations:
*         tokenBucketEn - token Bucket Enable
*         slowRateEn    - slow Rate Enable
*         tbUpdateRatio - token bucket update ratio
*         tokens - number of tokens
*         maxBucketSize - max Bucket Size
*         currentBucketSize - current Bucket Size
*         tokenBucketAvbEnabled - controls enabling/disabling AVB feature
*                              (APPLICABLE DEVICES: Bobcat2, Caelum, Aldrin, AC3X, Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                 GT_TRUE - AVB enabled
*                                 GT_FALSE - AVB disabled
*
* Comments:
*          for TXQ version 1 and above
*/
typedef struct{
    GT_BOOL tokenBucketEn;
    GT_BOOL slowRateEn;
    GT_U32  tbUpdateRatio;
    GT_U32  tokens;
    GT_U32  maxBucketSize;
    GT_U32  currentBucketSize;
    GT_BOOL tokenBucketAvbEnabled;
}PORT_TX_SHAPER_TOKEN_BUCKET_STC;


typedef struct
{
    CPSS_PORT_TX_WRR_MODE_ENT               countMode;
    CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_ENT  byteCountode;
    CPSS_ADJUST_OPERATION_ENT               byteCountOperation;
    CPSS_PORT_TX_Q_ARB_GROUP_ENT            arbGroup[16];
    GT_U8                                   wrrWeight[16];
} PORT_SCHEDULER_PARAM_STC;

/* number of words in the shaper per port per TC entry */
#define TXQ_SHAPER_ENTRY_WORDS_NUM_CNS  16

/**
* @enum SHAPER_DISABLE_STAGE_ENT
*
* @brief enum for stage in the disabling shaper operation
*/
typedef enum{

    /** stage 1 -- until sleep , without sleep */
    SHAPER_DISABLE_STAGE_1_E,

    /** stage 2 -- from sleep , without sleep */
    SHAPER_DISABLE_STAGE_2_E

} SHAPER_DISABLE_STAGE_ENT;

/**
* @enum DP_SHARING_ENT
*
* @brief enum for DP share buffers modes --
* for backwards compatible handling (with TXQ version 0)
*/
typedef enum{

    /** enable DP0 */
    DP_SHARING_DP0_ENABLE_E,

    /** disable DP0 */
    DP_SHARING_DP0_DISABLE_E,

    /** enable DP1 */
    DP_SHARING_DP1_ENABLE_E,

    /** disable DP1 */
    DP_SHARING_DP1_DISABLE_E

} DP_SHARING_ENT;

extern GT_STATUS prvCpssDxChPortMappingEGFTargetLocalPhys2TxQPortBaseMapGet
(
    IN  GT_U8  devNum,
    IN  GT_U32 portGroupId,
    IN  GT_U32 physPort,
    OUT GT_U32 *txqPortBasePtr
);


static GT_STATUS prvDxChShaperDisable
(
    IN  GT_U8   devNum,
    IN  GT_U32  portGroupId,
    IN  GT_U32  tokenBucketRegAddr
);

static GT_STATUS prvDxChPortTxCalcShaperTokenBucketRate
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    GT_U32                  xgPortsTokensRate,
    IN    GT_U32                  gigPortsTokensRate,
    IN    GT_U32                  gigPortsSlowRateRatio,
    IN    GT_U32                  tokenRefillValue,
    IN    GT_U32                  slowRateEn,
    IN    GT_BOOL                 stackAsGig,
    OUT   GT_U32                 *tokenBucketRatePtr
);

GT_STATUS prvDxChPortTxCalcShaperTokenBucketRate_rev1
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC *shaperConfigPtr,
    IN    CPSS_PORT_TX_DROP_SHAPER_MODE_ENT     shaperMode,
    IN    GT_BOOL                 slowRateEn,
    IN    GT_U32                  tbUpdateRatio,
    IN    GT_U32                  tokenRefillValue,
    OUT   GT_U32                 *tokenBucketRatePtr

);

static GT_STATUS prvDxChPortTxSetShaperTokenBucketParams
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    GT_BOOL                 usePerTc,
    IN    GT_U32                  tcQueue,
    IN    GT_U32                  old_xgPortsTokensRate,
    IN    GT_U32                  old_gigPortsTokensRate,
    IN    GT_U32                  old_gigPortsSlowRateRatio,
    IN    GT_BOOL                 old_StackAsGig,
    IN    GT_U32                  xgPortsTokensRate,
    IN    GT_U32                  gigPortsTokensRate,
    IN    GT_U32                  gigPortsSlowRateRatio,
    IN    GT_BOOL                 stackAsGig
);

static GT_STATUS prvCpssDxChPortTxReCalcShaperTokenBucketRate
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    GT_U32                  xgPortsTokensRate,
    IN    GT_U32                  gigPortsTokensRate,
    IN    GT_U32                  gigPortsSlowRateRatio,
    IN    GT_BOOL                 stackAsGig,
    OUT   GT_U32                 *tokenRefillValuePtr,
    OUT   GT_U32                 *slowRateEnPtr,
    IN    GT_U32                  tokenBucketRate
);

GT_STATUS prvCpssDxChPortTxReCalcShaperTokenBucketRate_rev1
(
    IN  GT_U8                                 devNum,
    IN  GT_PHYSICAL_PORT_NUM                  portNum,
    IN  GT_BOOL                               usePerTc,
    IN  CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC   *shaperConfigPtr,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT     shaperMode,
    IN  GT_U32                                tokenBucketRate,
    IN  GT_U32                                burstSize,
    IN  GT_BOOL                               isMllShaper,
    OUT GT_BOOL                               *slowRateEnPtr,
    OUT GT_U32                                *tbUpdateRatioPtr,
    OUT GT_U32                                *tokensPtr
);

GT_STATUS prvCpssDxChPortTxShaperTokenBucketEntryWrite_rev1
(
    IN  GT_U8   devNum,
    IN  GT_PHYSICAL_PORT_NUM   portNum,
    IN  GT_BOOL usePerTc,
    IN  GT_U32  tc,
    IN  GT_BOOL slowRateEn,
    IN  GT_U32  tbUpdateRatio,
    IN  GT_U32  tokens,
    IN  GT_U32  maxBucketSize,
    IN  GT_BOOL updCurrentBucketSize,
    IN  GT_U32  currentBucketSize
);

static GT_STATUS portTxShaperTokenBucketEnable_rev1
(
    IN  GT_U8   devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_BOOL usePerTc,
    IN  GT_U32  tc,
    IN  GT_BOOL enable
);

static GT_STATUS portTxShaperTokenBucketAllShapersDisable_rev1
(
    IN  GT_U8    devNum
);

static GT_STATUS portTxShaperTokenBucketShapersDisable_rev1
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum
);

static GT_STATUS portTxShaperTokenBucketEntryRead_rev1
(
    IN  GT_U8   devNum,
    IN  GT_PHYSICAL_PORT_NUM   portNum,
    IN  GT_BOOL usePerTc,
    IN  GT_U32  tc,
    OUT PORT_TX_SHAPER_TOKEN_BUCKET_STC *subEntryPtr
);

static GT_STATUS prvCpssDxChPortTxShaperTokenBucketRateGet
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    GT_BOOL                 usePerTc,
    IN    GT_U32                  tcQueue,
    IN    GT_U32                  xgPortsTokensRate,
    IN    GT_U32                  gigPortsTokensRate,
    IN    GT_U32                  gigPortsSlowRateRatio,
    IN    GT_BOOL                 stackAsGig,
    OUT   GT_BOOL                *tokenBucketEnPtr,
    OUT   GT_U32                 *tokenRefillValuePtr,
    OUT   GT_U32                 *slowRateEnPtr,
    OUT   GT_U16                 *burstSizePtr,
    OUT   GT_U32                 *tokenBucketRatePtr
);

/* macro to get the msb which is set */
#define MSB_SET_GET_MAC(_msbNum , _mask)    \
    _msbNum = 0;                            \
    while( 0x0 != _mask )                   \
{                                       \
    _msbNum++;                          \
    _mask = _mask >> 1;                 \
}



/**
* @internal prvCpssEnableDescriptorRequestSet function
* @endinternal
*
* @brief   set bit "enable descriptor request" in TxDma after
*          TXQ configuration is done. the bit is per DP.
*
*/
static GT_STATUS prvCpssEnableDescriptorRequestSet
(
    IN GT_U8    devNum
)
{
    GT_STATUS   rc;
    GT_U32  regAddr;

    /* in TXDMA unit set the <Enable Descriptor Request >
    TXD Configuration/Global Configurations/TXD Global Configuration */
    regAddr = PRV_DXCH_REG1_UNIT_SIP6_TXDMA_INDEX_MAC(devNum,0).configs.globalConfigs.txDMAGlobalConfig;
    rc = prvCpssHwPpSetRegField(CAST_SW_DEVNUM(devNum), regAddr, 0, 1, 1);
    if(rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}




/**
* @internal internal_cpssDxChPortTxInit function
* @endinternal
*
* @brief   Init port Tx configuration.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note In SALSA family the first profile (profile_0) is used for CPU port and
*       the second one (profile_1) for network ports.
*
*/
static GT_STATUS internal_cpssDxChPortTxInit
(
    IN  GT_U8    devNum
)
{
    GT_PHYSICAL_PORT_NUM                    portNum;
    GT_STATUS                               rc, rc1;    /* return code */
    CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profile;
    CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  lastProfile;/* last valid scheduler profile */
    GT_U8                                   tc;
    GT_U32                                  txqPortNum; /* TXQ port number */
    GT_U32                                  macPortNum; /* MAC port number */
    GT_U32                                  portMaxIter;/* maximal port number */
    GT_PHYSICAL_PORT_NUM cpuPortNumArr[CPSS_MAX_SDMA_CPU_PORTS_CNS];
    GT_U32    numOfNetIfs, i;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        portMaxIter = PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum);
    }
    else
    {
        portMaxIter = PRV_CPSS_PP_MAC(devNum)->numOfPorts;
    }

    for (portNum = 0; portNum < portMaxIter; portNum++)
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            if(PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].valid == GT_FALSE ||
                PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].portMap.mappingType == CPSS_DXCH_PORT_MAPPING_TYPE_CPU_SDMA_E)
            {
                /* skip immediate errors from prvCpssDxChPortPhysicalPortMapCheckAndConvert(...)
                it causes ERROR LOG not to be clean
                */
                continue;
            }

            if(CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS ==
                PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].portMap.txqNum)
            {
                /* skip immediate errors from prvCpssDxChPortPhysicalPortMapCheckAndConvert(...)
                it causes ERROR LOG not to be clean
                */
                continue;
            }

            rc = prvCpssDxChPortPhysicalPortMapCheckAndConvert(devNum, portNum, PRV_CPSS_DXCH_PORT_TYPE_TXQ_E, &txqPortNum);
            if(rc != GT_OK)
                continue;

            if(PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].portMap.mappingType != CPSS_DXCH_PORT_MAPPING_TYPE_REMOTE_PHYSICAL_PORT_E)
            {
                rc = prvCpssDxChPortPhysicalPortMapCheckAndConvert(devNum, portNum, PRV_CPSS_DXCH_PORT_TYPE_MAC_E, &macPortNum);
                if(rc != GT_OK)
                    continue;
            }
            else
            {
                rc = prvCpssDxChPortPhysicalPortMapCheckAndConvertForRemote(devNum, portNum, PRV_CPSS_DXCH_PORT_TYPE_MAC_E, &macPortNum);
                if(rc != GT_OK)
                    continue;
            }
        }
        else
        {
            if (! PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, portNum))
                continue;

            txqPortNum = portNum;
            macPortNum = portNum;
        }

        /* Set the tail drop Profile association used for network ports */
        profile = (PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,macPortNum) >= PRV_CPSS_PORT_XG_E) ?
PRV_CPSS_DXCH_NET_10GE_PORT_PROFILE_CNS :
        PRV_CPSS_DXCH_NET_GE_PORT_PROFILE_CNS;

        rc = cpssDxChPortTxBindPortToDpSet(devNum,portNum,(CPSS_PORT_TX_DROP_PROFILE_SET_ENT)profile);
        if (rc != GT_OK)
            return rc;

        if(prvCpssDxChPortRemotePortCheck(devNum,portNum))
        {
            /* Remote ports need to be associated with a profile number
            *  different than local ports.
            *  It is application responsibility to do so - look at appDemo for reference. */
        }
        else
        {
            /* Set the scheduler TX Profile association used for   *
            * WRR algorithm for network ports                     */
            rc = cpssDxChPortTxBindPortToSchedulerProfileSet(devNum,portNum,profile);
            if (rc != GT_OK)
                return rc;
        }
    }

    /* Set the tail drop Profile association used for   *
    *  CPU port                                        */

    profile = PRV_CPSS_DXCH_CPU_PORT_PROFILE_CNS;
    /* run over all cpu ports*/
    rc = prvCpssDxChPortMappingCPUPortGet(devNum, cpuPortNumArr, &numOfNetIfs);
    if (rc != GT_OK)
    {
        return rc;
    }
    for (i=0; i < numOfNetIfs; i++)
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            rc1 = prvCpssDxChPortPhysicalPortMapCheckAndConvert(devNum, cpuPortNumArr[i], PRV_CPSS_DXCH_PORT_TYPE_TXQ_E, &txqPortNum);
        }
        else
        {
            rc1 = GT_OK;
        }

        /* Need to check if CPU port has TXQ mapping.
        Note: "no CPU" board configuration available */
        if((PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) != GT_TRUE) ||
        ((PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE) && (rc1 == GT_OK)))
        {
            rc = cpssDxChPortTxBindPortToDpSet(devNum,cpuPortNumArr[i],(CPSS_PORT_TX_DROP_PROFILE_SET_ENT)profile);
            if (rc != GT_OK)
                return rc;

            /* Set the scheduler TX Profile association used for   *
            * WRR algorithm for CPU port                          */
            rc = cpssDxChPortTxBindPortToSchedulerProfileSet(devNum,cpuPortNumArr[i],profile);
            if (rc != GT_OK)
                return rc;
        }

    }
    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)
    {
        /* set the initial value of shaper to port speed ratio to 100% */
        if((CPSS_PP_FAMILY_DXCH_LION2_E == PRV_CPSS_PP_MAC(devNum)->devFamily)||
           (PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
        {
            if(CPSS_PP_FAMILY_DXCH_LION2_E == PRV_CPSS_PP_MAC(devNum)->devFamily)
            {
                lastProfile = CPSS_PORT_TX_SCHEDULER_PROFILE_8_E;
            }
            else
            {
                lastProfile = CPSS_PORT_TX_SCHEDULER_PROFILE_16_E;
            }

            for (profile = CPSS_PORT_TX_SCHEDULER_PROFILE_1_E; profile <= lastProfile;profile++)
            {
                for (tc = 0; tc < CPSS_TC_RANGE_CNS; tc++)
                {
                    rc = cpssDxChPortPfcShaperToPortRateRatioSet(devNum,profile,tc,100);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }
    }
    else
    {
        /*Init flow control quanta */
        rc = prvCpssFalconTxqUtilsFlowControlInit(devNum);
        if (rc != GT_OK)
        {
            return rc;
        }

        /*  set Enable Descriptor Request to 1.
        This bit enabel TxDma to take TXQ descriptors
        TXQ have to finish all the initialization configuration
        before setting the bit to 1*/
        rc =  prvCpssEnableDescriptorRequestSet(devNum);
        if (rc != GT_OK)
        {
            return rc;
        }

        rc =prvCpssFalconTxqUtilsInitTailDrop(devNum,GT_TRUE);
        if (rc != GT_OK)
        {
            return rc;
        }

        rc =prvCpssSip6TxqLibInitDoneSet(devNum,GT_TRUE);
        if (rc != GT_OK)
        {
            return rc;
        }

    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxInit function
* @endinternal
*
* @brief   Init port Tx configuration.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note In SALSA family the first profile (profile_0) is used for CPU port and
*       the second one (profile_1) for network ports.
*
*/
GT_STATUS cpssDxChPortTxInit
(
    IN  GT_U8    devNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxInit);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum));

    rc = internal_cpssDxChPortTxInit(devNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueEnableSet function
* @endinternal
*
* @brief   Enable/Disable enqueuing on all Tx queues on a specific device.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE, Global enqueuing enabled
*                                      GT_FALSE, Global enqueuing disabled
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_U32      regAddr;    /* register address             */
    GT_U32      value;      /* value to write into register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    value = BOOL2BIT_MAC(enable);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.egrFiltersGlobal;
        /*<EgfEn>*/
        return prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, value);
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfig;

        return prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, value);
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.filterConfig.globalEnables;

        return prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, value);
    }

}

/**
* @internal cpssDxChPortTxQueueEnableSet function
* @endinternal
*
* @brief   Enable/Disable enqueuing on all Tx queues on a specific device.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE, Global enqueuing enabled
*                                      GT_FALSE, Global enqueuing disabled
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPortTxQueueEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueEnableGet function
* @endinternal
*
* @brief   Get status of enqueuing on all Tx queues on a specific device
*     (enabled/disabled).
*
* @note   APPLICABLE DEVICES:       xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - GT_TRUE, Global enqueuing enabled
*                                      GT_FALSE, Global enqueuing disabled
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL   *enablePtr
)
{
    GT_U32      regAddr;    /* register address             */
    GT_U32      value;      /* value to write into register */
    GT_U32      bitOffset;  /* bit offset inside register   */
    GT_STATUS   rc;         /* return value                 */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.egrFiltersGlobal;
        /*<EgfEn>*/
        bitOffset = 0;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfig;
        bitOffset = 1;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.filterConfig.globalEnables;
        bitOffset = 0;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, bitOffset, 1, &value);
    if (rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(value);

    return rc;
}

/**
* @internal cpssDxChPortTxQueueEnableGet function
* @endinternal
*
* @brief   Get status of enqueuing on all Tx queues on a specific device
*     (enabled/disabled).
*
* @note   APPLICABLE DEVICES:       xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - GT_TRUE, Global enqueuing enabled
*                                      GT_FALSE, Global enqueuing disabled
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL   *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPortTxQueueEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChPortTxQueueingEnableSet function
* @endinternal
*
* @brief   Enable/Disable enqueuing to a Traffic Class queue
*         on the specified port of specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
* @param[in] enable                   - GT_TRUE,  enqueuing to the queue
*                                      GT_FALSE, disable enqueuing to the queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChPortTxQueueingEnableSet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_U8                   tcQueue,
    IN  GT_BOOL                 enable
)
{
    GT_U32  regAddr;    /* register address                 */
    GT_U32  value;      /* value to write into register     */
    GT_U32  txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);

    PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);

    value = BOOL2BIT_MAC(enable);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if(txqPortNum >= 576/*size of tailDrop.tailDropConfig.portEnqueueEnable */)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.portEnqueueEnable[txqPortNum];

        return prvCpssHwPpSetRegField(devNum, regAddr, tcQueue, 1, value);
    }

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_TXQ_REG_MAC(devNum,portNum,&regAddr);

        return prvCpssHwPpPortGroupSetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr, tcQueue, 1, value);
    }
    else
    {
        if(portNum >= PORTS_NUM_SIP_4_CNS /*size of tailDrop.config.portEnqueueEnable */)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.portEnqueueEnable[portNum];

        return prvCpssHwPpSetRegField(devNum, regAddr, tcQueue, 1, value);
    }
}

/**
* @internal internal_cpssDxChPortTxQueueingEnableSet function
* @endinternal
*
* @brief   Enable/Disable enqueuing to a Traffic Class queue
*         on the specified port of specified device.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
* @param[in] enable                   - GT_TRUE,  enqueuing to the queue
*                                      GT_FALSE, disable enqueuing to the queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueingEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    IN  GT_BOOL   enable
)
{
    GT_STATUS rc;
    GT_BOOL isPortEnabled, isCpu;
    GT_U32  txqPortNum;     /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);


    /* validate Traffic Classes queue */
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tcQueue);


    rc = cpssDxChPortPhysicalPortMapIsCpuGet(devNum, portNum, &isCpu);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Don't apply WA on CPU port in SDMA mode */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E) &&
    ((isCpu == GT_FALSE) || ((isCpu == GT_TRUE) &&
    (PRV_CPSS_PP_MAC(devNum)->cpuPortMode != CPSS_NET_CPU_PORT_MODE_SDMA_E)) ||
    ((isCpu == GT_TRUE) && PRV_CPSS_DXCH_CHECK_SDMA_PACKETS_FROM_CPU_CORRUPT_WA_MAC(devNum))))
    {

        /* ports txq state shadow */
        CPSS_PORTS_BMP_PORT_ENABLE_MAC((&(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E.portTxQueuesBmpPtr[tcQueue])),portNum,enable);

        /* get the port enable/disable status */
        rc = prvCpssDxChPortEnableGet(devNum,portNum,&isPortEnabled);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* Don't write the configuration for disabled port */
        if (isPortEnabled == GT_FALSE)
        {
            return GT_OK;
        }
    }

    return prvCpssDxChPortTxQueueingEnableSet(devNum,portNum,tcQueue,enable);
}

/**
* @internal cpssDxChPortTxQueueingEnableSet function
* @endinternal
*
* @brief   Enable/Disable enqueuing to a Traffic Class queue
*         on the specified port of specified device.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
* @param[in] enable                   - GT_TRUE,  enqueuing to the queue
*                                      GT_FALSE, disable enqueuing to the queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueingEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    IN  GT_BOOL   enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueingEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, enable));

    rc = internal_cpssDxChPortTxQueueingEnableSet(devNum, portNum, tcQueue, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueingEnableGet function
* @endinternal
*
* @brief   Get the status of enqueuing to a Traffic Class queue
*         on the specified port of specified device (Enable/Disable).
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
*
* @param[out] enablePtr                - GT_TRUE, enable enqueuing to the queue
*                                      GT_FALSE, disable enqueuing to the queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueingEnableGet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    OUT GT_BOOL   *enablePtr
)
{
    GT_U32      regAddr;    /* register address                 */
    GT_U32      value;      /* value to write into register     */
    GT_STATUS   rc;         /* return code                      */
    GT_U32  txqPortNum;     /* TXQ port number */
    GT_BOOL     isCpu;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    /* validate Traffic Classes queue */
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tcQueue);

    rc = cpssDxChPortPhysicalPortMapIsCpuGet(devNum, portNum, &isCpu);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Don't apply WA on CPU port in SDMA mode */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E) &&
    ((isCpu == GT_FALSE) || ((isCpu == GT_TRUE) &&
    (PRV_CPSS_PP_MAC(devNum)->cpuPortMode != CPSS_NET_CPU_PORT_MODE_SDMA_E)) ||
    ((isCpu == GT_TRUE) && PRV_CPSS_DXCH_CHECK_SDMA_PACKETS_FROM_CPU_CORRUPT_WA_MAC(devNum))))
    {

        *enablePtr = CPSS_PORTS_BMP_IS_PORT_SET_MAC((&(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E.portTxQueuesBmpPtr[tcQueue])),portNum);
        *enablePtr = BIT2BOOL_MAC(*enablePtr);

        return GT_OK;
    }


    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {

        if(txqPortNum >= 576/*size of tailDrop.tailDropConfig.portEnqueueEnable*/)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.portEnqueueEnable[txqPortNum];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, tcQueue, 1, &value);
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_TXQ_REG_MAC(devNum,portNum,&regAddr);

        rc = prvCpssHwPpPortGroupGetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr, tcQueue, 1, &value);
    }
    else
    {
        if(portNum >= PORTS_NUM_SIP_4_CNS/*size of  txqVer1.queue.tailDrop.config.portEnqueueEnable */)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.portEnqueueEnable[portNum];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, tcQueue, 1, &value);
    }
    if (rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/**
* @internal cpssDxChPortTxQueueingEnableGet function
* @endinternal
*
* @brief   Get the status of enqueuing to a Traffic Class queue
*         on the specified port of specified device (Enable/Disable).
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
*
* @param[out] enablePtr                - GT_TRUE, enable enqueuing to the queue
*                                      GT_FALSE, disable enqueuing to the queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueingEnableGet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    OUT GT_BOOL   *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueingEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, enablePtr));

    rc = internal_cpssDxChPortTxQueueingEnableGet(devNum, portNum, tcQueue, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueTxEnableSet function
* @endinternal
*
* @brief   Enable/Disable transmission from a Traffic Class queue
*         on the specified port of specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this Physical Port (0..7)
* @param[in] enable                   - GT_TRUE,  transmission from the queue
*                                      GT_FALSE, disable transmission from the queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueTxEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    IN  GT_BOOL   enable
)
{
    GT_U32      value;      /* value to write into register     */
    GT_U32      regAddr;    /* register address                 */
    GT_U32      offset;
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);


    if(GT_TRUE == PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssFalconTxqUtilsQueueEnableSet(devNum,portNum,tcQueue,enable);
    }

    value = BOOL2BIT_MAC(enable);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.portDequeueEnable[txqPortNum];
        offset = tcQueue;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_TXQ_REG_MAC(devNum,txqPortNum,&regAddr);

        offset = 8 + tcQueue;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.shaper.portDequeueEnable[txqPortNum];
        offset = tcQueue;
    }

    return prvCpssHwPpPortGroupSetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum),
        regAddr, offset, 1, value);
}

/**
* @internal cpssDxChPortTxQueueTxEnableSet function
* @endinternal
*
* @brief   Enable/Disable transmission from a Traffic Class queue
*         on the specified port of specified device.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this Physical Port (0..7)
* @param[in] enable                   - GT_TRUE,  transmission from the queue
*                                      GT_FALSE, disable transmission from the queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueTxEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    IN  GT_BOOL   enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueTxEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, enable));

    rc = internal_cpssDxChPortTxQueueTxEnableSet(devNum, portNum, tcQueue, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxQueueTxEnableGet function
* @endinternal
*
* @brief   Get the status of transmission from a Traffic Class queue
*         on the specified port of specified device (Enable/Disable).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical port number
* @param[in] tcQueue                  - traffic class queue on this Physical Port (0..7)
*
* @param[out] enablePtr                - GT_TRUE, enable transmission from the queue
*                                      GT_FALSE, disable transmission from the queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueTxEnableGet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    OUT GT_BOOL   *enablePtr
)
{
    GT_U32      value;      /* value to write into register     */
    GT_U32      regAddr;    /* register address                 */
    GT_U32      offset;
    GT_STATUS   rc;         /* return code                      */
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(GT_TRUE == PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssFalconTxqUtilsQueueEnableGet(devNum,portNum,tcQueue,enablePtr);
    }


    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.portDequeueEnable[txqPortNum];
        offset = tcQueue;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_TXQ_REG_MAC(devNum,txqPortNum,&regAddr);

        offset = 8 + tcQueue;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.shaper.portDequeueEnable[txqPortNum];
        offset = tcQueue;
    }

    rc = prvCpssHwPpPortGroupGetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum),
        regAddr, offset, 1, &value);
    if (rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/**
* @internal cpssDxChPortTxQueueTxEnableGet function
* @endinternal
*
* @brief   Get the status of transmission from a Traffic Class queue
*         on the specified port of specified device (Enable/Disable).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical port number
* @param[in] tcQueue                  - traffic class queue on this Physical Port (0..7)
*
* @param[out] enablePtr                - GT_TRUE, enable transmission from the queue
*                                      GT_FALSE, disable transmission from the queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueTxEnableGet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    OUT GT_BOOL   *enablePtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueTxEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, enablePtr));

    rc = internal_cpssDxChPortTxQueueTxEnableGet(devNum, portNum, tcQueue, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxFlushQueuesSet function
* @endinternal
*
* @brief   Flush all the traffic class queues on the specified port of
*         specified device.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  physical or CPU port number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxFlushQueuesSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum
)
{
    GT_U32      regAddr;    /* register address */
    GT_U32      offset;     /* field offset     */
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.flushTrig.portTxQFlushTrigger[txqPortNum];
        offset = 0;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_TXQ_REG_MAC(devNum,txqPortNum,&regAddr);
        offset = 21;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.
            global.flushTrig.portTxqFlushTrigger[txqPortNum];
        offset = 0;
    }

    return prvCpssHwPpPortGroupSetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum),
        regAddr, offset, 1, 1);
}

/**
* @internal cpssDxChPortTxFlushQueuesSet function
* @endinternal
*
* @brief   Flush all the traffic class queues on the specified port of
*         specified device.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  physical or CPU port number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxFlushQueuesSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxFlushQueuesSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum));

    rc = internal_cpssDxChPortTxFlushQueuesSet(devNum, portNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperEnableSet function
* @endinternal
*
* @brief   Enable/Disable Token Bucket rate shaping on specified port of
*         specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] enable                   - GT_TRUE,  Shaping
*                                      GT_FALSE, disable Shaping
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Flow control must be disabled before disabling the shaper.
*
*/
static GT_STATUS internal_cpssDxChPortTxShaperEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_BOOL   enable
)
{
    GT_U32      regAddr1;    /* register address for token bucket*/
    GT_U32      portGroupId = 0; /*the port group Id - support multi-port-groups device */
    GT_U32      txqPortNum=0; /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(GT_FALSE== PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);


        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }

        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum);

    }

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_TOKEN_BUCKET_REG_MAC(devNum,txqPortNum,&regAddr1);

        if (GT_FALSE == enable)
        {
            return prvDxChShaperDisable(devNum,
                portGroupId,
                regAddr1);
        }
        else
        {
            return prvCpssHwPpPortGroupSetRegField(devNum,
                portGroupId,
                regAddr1, 0, 1, 1);
        }
    }
    else if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssSip6TxqUtilsShapingEnableSet(devNum,portNum,CPSS_PARAM_NOT_USED_CNS,GT_FALSE,enable);
    }
    else
    {
        return portTxShaperTokenBucketEnable_rev1(devNum,portNum,GT_FALSE,0,enable);
    }

}

/**
* @internal cpssDxChPortTxShaperEnableSet function
* @endinternal
*
* @brief   Enable/Disable Token Bucket rate shaping on specified port of
*         specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.

* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] enable                   - GT_TRUE,  Shaping
*                                      GT_FALSE, disable Shaping
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Flow control must be disabled before disabling the shaper.
*
*/
GT_STATUS cpssDxChPortTxShaperEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_BOOL   enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enable));

    rc = internal_cpssDxChPortTxShaperEnableSet(devNum, portNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperEnableGet function
* @endinternal
*
* @brief   Get Enable/Disable Token Bucket rate shaping status on specified port of
*         specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] enablePtr                - Pointer to Token Bucket rate shaping status.
*                                      - GT_TRUE, enable Shaping
*                                      - GT_FALSE, disable Shaping
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxShaperEnableGet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT  GT_BOOL  *enablePtr
)
{
    GT_U32      regAddr;    /* register address for token bucket*/
    GT_U32      value;      /* register field value */
    GT_STATUS   rc;         /* return value */
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);



    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_TOKEN_BUCKET_REG_MAC(devNum,portNum,&regAddr);

        rc = prvCpssHwPpPortGroupGetRegField(devNum,
            PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr, 0, 1, &value);
        if(rc != GT_OK)
        {
            return rc;
        }

        *enablePtr = BIT2BOOL_MAC(value);
    }
    else if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssSip6TxqUtilsShapingEnableGet(devNum,portNum,CPSS_PARAM_NOT_USED_CNS,GT_FALSE,enablePtr);
    }
    else
    {
        PORT_TX_SHAPER_TOKEN_BUCKET_STC subEntry;

        /* read entry from HW */
        rc = portTxShaperTokenBucketEntryRead_rev1(devNum,portNum,GT_FALSE,0,&subEntry);
        if(rc != GT_OK)
        {
            return rc;
        }
        *enablePtr = subEntry.tokenBucketEn;
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxShaperEnableGet function
* @endinternal
*
* @brief   Get Enable/Disable Token Bucket rate shaping status on specified port of
*         specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] enablePtr                - Pointer to Token Bucket rate shaping status.
*                                      - GT_TRUE, enable Shaping
*                                      - GT_FALSE, disable Shaping
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxShaperEnableGet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT  GT_BOOL  *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enablePtr));

    rc = internal_cpssDxChPortTxShaperEnableGet(devNum, portNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChPortShaperProfileSet function
* @endinternal
*
* @brief   Set Shaper Profile for Traffic Class Queue of specified port /
*         specified port on specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical port number
* @param[in] tcQueue                  - traffic class queue on the port
*                                      CPSS_PARAM_NOT_USED_CNS - to get per port Shaper Profile.
* @param[in] burstSize                - burst size in units of 4K bytes
*                                  (max value is 4K which results in 16K burst size)
* @param[in,out] maxRatePtr               - Requested Rate in Kbps
* @param[in,out] maxRatePtr               - (pointer to) the actual Rate value in Kbps.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong port number, device, tcQueue
*/
static GT_STATUS prvCpssDxChPortShaperProfileSet
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U32   tcQueue,
    IN  GT_U16   burstSize,
    INOUT GT_U32 *maxRatePtr
)
{
    GT_STATUS   rc;                     /* return value */
    GT_U32      regData;                /* value to read from register */
    GT_U32      regAddr = 0;            /* register address            */
    GT_U32      xgPortsTokensRate;      /* XG token rate */
    GT_U32      gigPortsTokensRate;     /* GE token rate */
    GT_U32      gigPortsSlowRateRatio;  /* GE Slow rate  */
    GT_U32      slowRateEn;   /* 1 - Slow rate is enabled, 0 - Slow rate is disabled */
    GT_U32      tokens;       /* number of tokens that are added to the bucket */
    GT_BOOL     usePerTc;/* do we set 'per port' or 'per port per tc'*/
    GT_BOOL     stackAsGig = GT_FALSE;
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    if(GT_FALSE == PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
      PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    }
    CPSS_NULL_PTR_CHECK_MAC(maxRatePtr);

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    /* check burst size validity - 12 bits in HW */
    if(burstSize >= BIT_12)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(tcQueue == CPSS_PARAM_NOT_USED_CNS)
    {
        usePerTc = GT_FALSE;
    }
    else
    {
        /* validate Traffic Classes queue */
        PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
        PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);
        usePerTc = GT_TRUE;
    }

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        /* Get port Token bucket configuration register */
        if(usePerTc == GT_FALSE)
        {
            PRV_CPSS_DXCH_PORT_TOKEN_BUCKET_REG_MAC(devNum, portNum, &regAddr);
        }
        /* Get Queue -- Token bucket configuration register. */
        else
        {
            PRV_CPSS_DXCH_PORT_Q_TOKEN_BUCKET_REG_MAC(devNum, portNum, tcQueue, &regAddr);
        }

        rc = cpssDxChPortTxShaperGlobalParamsGet(devNum,
            &xgPortsTokensRate,
            &gigPortsTokensRate,
            &gigPortsSlowRateRatio);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* check if StackAsGig mode enabled */
        if (PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
        {
            rc = cpssDxChPortTxShaperOnStackAsGigEnableGet(devNum,&stackAsGig);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        rc = prvCpssDxChPortTxReCalcShaperTokenBucketRate(devNum,
            portNum,
            xgPortsTokensRate,
            gigPortsTokensRate,
            gigPortsSlowRateRatio,
            stackAsGig,
            &tokens,
            &slowRateEn,
            *maxRatePtr);

        if(rc != GT_OK)
        {
            return rc;
        }

        regData = slowRateEn | ((tokens & 0xFFF) << 3) | ((burstSize & 0xFFF) << 15);

        rc = prvCpssHwPpPortGroupSetRegField(devNum,
            PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr, 1, 27, regData);
        if(rc != GT_OK)
        {
            return rc;
        }

        return prvDxChPortTxCalcShaperTokenBucketRate(devNum,
            portNum,
            xgPortsTokensRate,
            gigPortsTokensRate,
            gigPortsSlowRateRatio,
            tokens,
            slowRateEn,
            stackAsGig,
            maxRatePtr);
    }
    else if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
     if(usePerTc == GT_FALSE)
     {
       return prvCpssFalconTxqUtilsShapingParametersSet(devNum,portNum,CPSS_PARAM_NOT_USED_CNS,GT_FALSE,PRV_QUEUE_SHAPING_ACTION_STOP_TRANSMITION_ENT,burstSize,maxRatePtr);
     }
      else
     {
       return prvCpssFalconTxqUtilsShapingParametersSet(devNum,portNum,tcQueue,GT_TRUE,PRV_QUEUE_SHAPING_ACTION_STOP_TRANSMITION_ENT,burstSize,maxRatePtr);
     }
    }
    else
    {
        CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC shaperConfig; /* global shaper configurations */
        CPSS_PORT_TX_DROP_SHAPER_MODE_ENT   shaperMode;   /* shaper mode on port */
        GT_U32 tbUpdateRatio;    /* TB interval update ratio value */
        GT_BOOL slowRateEnable;  /* slow rate enable value */
        GT_U32 baseline;         /* baseline value */

        /* get global shaper baseline */
        rc = cpssDxChPortTxShaperBaselineGet(devNum,&baseline);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* get global shaper configurations */
        rc = cpssDxChPortTxShaperConfigurationGet(devNum,&shaperConfig);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* get shaper mode on port */
        rc = cpssDxChPortTxShaperModeGet(devNum,portNum,&shaperMode);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* calculate per TB configurations */
        rc = prvCpssDxChPortTxReCalcShaperTokenBucketRate_rev1(devNum,
            portNum,
            usePerTc,
            &shaperConfig,
            shaperMode,
            *maxRatePtr,
        (burstSize*_4K) - baseline,
            GT_FALSE,
            &slowRateEnable,
            &tbUpdateRatio,
            &tokens);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* update TB entry */
        /* set the current Bucket Size to max Bucket Size */
        rc = prvCpssDxChPortTxShaperTokenBucketEntryWrite_rev1(devNum,
            portNum,
            usePerTc,
            tcQueue,
            slowRateEnable,
            tbUpdateRatio,
            tokens,
            burstSize,
            GT_TRUE,
            burstSize * _4KB);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* calculate the actual Rate value */
        return prvDxChPortTxCalcShaperTokenBucketRate_rev1(devNum,
            portNum,
            &shaperConfig,
            shaperMode,
            slowRateEnable,
            tbUpdateRatio,
            tokens,
            maxRatePtr);
    }
}
/**
* @internal prvCpssDxChPortShaperProfileGet function
* @endinternal
*
* @brief   Get Shaper Profile for Traffic Class Queue of specified port /
*         specified port on specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on the port
*                                      CPSS_PARAM_NOT_USED_CNS - to get per port Shaper Profile.
*
* @param[out] burstSizePtr             - (pointer to) burst size in units of 4K bytes
* @param[out] maxRatePtr               - (pointer to) the actual Rate value in Kbps.
* @param[out] enablePtr                - (pointer to) Token Bucket rate shaping status.
*                                      - GT_TRUE - Token Bucket rate shaping is enabled.
*                                      - GT_FALSE - Token Bucket rate shaping is disabled.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong port number, device, tcQueue
*/
static GT_STATUS prvCpssDxChPortShaperProfileGet
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U32   tcQueue,
    OUT GT_U16   *burstSizePtr,
    OUT GT_U32   *maxRatePtr,
    OUT GT_BOOL  *enablePtr
)
{
    GT_STATUS   rc;            /* return value */
    GT_U32      xgPortsTokensRate;      /* XG token rate */
    GT_U32      gigPortsTokensRate;     /* GE token rate */
    GT_U32      gigPortsSlowRateRatio;  /* GE Slow rate  */
    GT_U32      tokens;        /* number of tokens that are added to the bucket */
    GT_U32      slowRateEn;    /* 1 - Slow rate is enabled, 0 - Slow rate is disabled */
    PORT_TX_SHAPER_TOKEN_BUCKET_STC subEntry;/* sub entry format - relevant for TXQ_REV_1 */
    GT_BOOL     usePerTc;/* do we set 'per port' or 'per port per tc'*/
    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC shaperConfig; /* shaper global configuration */
    CPSS_PORT_TX_DROP_SHAPER_MODE_ENT   shaperMode;   /* shaper mode on port */
    GT_BOOL stackAsGig = GT_FALSE;
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    if(GT_FALSE == PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    }
    CPSS_NULL_PTR_CHECK_MAC(burstSizePtr);
    CPSS_NULL_PTR_CHECK_MAC(maxRatePtr);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    if(tcQueue == CPSS_PARAM_NOT_USED_CNS)
    {
        usePerTc = GT_FALSE;
    }
    else
    {
        /* validate Traffic Classes queue */
        PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
        PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);
        usePerTc = GT_TRUE;
    }

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {

        rc = cpssDxChPortTxShaperGlobalParamsGet(devNum,
            &xgPortsTokensRate,
            &gigPortsTokensRate,
            &gigPortsSlowRateRatio);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* check if StackAsGig mode enabled */
        if (PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
        {
            rc = cpssDxChPortTxShaperOnStackAsGigEnableGet(devNum,&stackAsGig);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        return prvCpssDxChPortTxShaperTokenBucketRateGet(devNum,portNum,usePerTc,tcQueue,
            xgPortsTokensRate,
            gigPortsTokensRate,
            gigPortsSlowRateRatio,
            stackAsGig,
            enablePtr,
            &tokens,
            &slowRateEn,
            burstSizePtr,
            maxRatePtr);
    }
    else if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        if(usePerTc == GT_FALSE)
        {
            rc = prvCpssFalconTxqUtilsShapingParametersGet(devNum,portNum,CPSS_PARAM_NOT_USED_CNS,GT_FALSE,PRV_QUEUE_SHAPING_ACTION_STOP_TRANSMITION_ENT,burstSizePtr,maxRatePtr);
            if(rc!=GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
            }

            rc = prvCpssSip6TxqUtilsShapingEnableGet(devNum,portNum,CPSS_PARAM_NOT_USED_CNS,GT_FALSE,enablePtr);
            return rc;
        }
        else
        {
            rc = prvCpssFalconTxqUtilsShapingParametersGet(devNum,portNum,tcQueue,GT_TRUE,PRV_QUEUE_SHAPING_ACTION_STOP_TRANSMITION_ENT,burstSizePtr,maxRatePtr);
            if(rc!=GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
            }

            rc = prvCpssSip6TxqUtilsShapingEnableGet(devNum,portNum,tcQueue,GT_TRUE,enablePtr);
            return rc;
        }
    }
    else
    {
        /* read the entry */
        rc = portTxShaperTokenBucketEntryRead_rev1(devNum,portNum,usePerTc,tcQueue,&subEntry);
        if(rc != GT_OK)
        {
            return rc;
        }

        *enablePtr = subEntry.tokenBucketEn;
        /* Token Bucket rate shaping is disabled. */
        if(*enablePtr == GT_FALSE)
        {
            return GT_OK;
        }
        /* Token Bucket rate shaping is enabled. */
        *burstSizePtr = (GT_U16)subEntry.maxBucketSize;

        /* get global shaper configurations */
        rc = cpssDxChPortTxShaperConfigurationGet(devNum,&shaperConfig);
        if (rc != GT_OK)
        {
            return rc;
        }

        rc = cpssDxChPortTxShaperModeGet(devNum,portNum,&shaperMode);
        if (rc != GT_OK)
        {
            return rc;
        }

        return prvDxChPortTxCalcShaperTokenBucketRate_rev1(devNum,
            portNum,
            &shaperConfig,
            shaperMode,
            subEntry.slowRateEn,
            subEntry.tbUpdateRatio,
            subEntry.tokens,
            maxRatePtr);
    }
}

/**
 * @internal internal_cpssDxChPortTxShaperProfileSet function
 * @endinternal
 *
 * @brief   Set Token Bucket Shaper Profile on specified port of specified device.
 *
 * @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
 * @note   NOT APPLICABLE DEVICES:  None.
 *
 * @param[in] devNum                   - physical device number
 * @param[in] portNum                  - physical or CPU port number
 * @param[in] burstSize                - burst size in units of 4K bytes
 * @param[in,out] maxRatePtr           - Requested Rate in Kbps or packets per second
 *                                       according to port shaper mode.
 * @param[in,out] maxRatePtr           - (pointer to) the actual Rate value in Kbps
 *                                       or packets per second.
 *
 * @retval GT_OK                    - on success
 * @retval GT_FAIL                  - on error
 * @retval GT_BAD_PARAM             - on wrong port number or device
 * @retval GT_HW_ERROR              - on hardware error
 * @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
 *
 * @note 1. For xCat3:
 *       For port number in the range 24..27, whether G or XG type, the global
 *       shaper used parameters are determined by
 *       "cpssDxChPortTxShaperOnStackAsGigEnableSet".
 *       2. For Lion:
 *       If the shaper mode on a given port is packet based and the packet
 *       length (portsPacketLength/cpuPacketLength) configuration isn't null,
 *       maxRatePtr units are packets per second,
 *       otherwise maxRatePtr units are Kbps.
 *       3. burstSize:
 *          For xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2:
 *              max value is 4K-1 which results in 16M burst size
 *          For Falcon; AC5P; AC5X; Harrier; Ironman:
 *              max value is 1K-1 which results in 4M burst size
 */
static GT_STATUS internal_cpssDxChPortTxShaperProfileSet
(
    IN    GT_U8     devNum,
    IN    GT_PHYSICAL_PORT_NUM        portNum,
    IN    GT_U16    burstSize,
    INOUT GT_U32    *maxRatePtr
)
{
    return prvCpssDxChPortShaperProfileSet(devNum, portNum,
        CPSS_PARAM_NOT_USED_CNS,
        burstSize, maxRatePtr);
}

/**
 * @internal cpssDxChPortTxShaperProfileSet function
 * @endinternal
 *
 * @brief   Set Token Bucket Shaper Profile on specified port of specified device.
 *
 * @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
 * @note   NOT APPLICABLE DEVICES:  None.
 *
 * @param[in] devNum                   - physical device number
 * @param[in] portNum                  - physical or CPU port number
 * @param[in] burstSize                - burst size in units of 4K bytes
 * @param[in,out] maxRatePtr           - Requested Rate in Kbps or packets per second
 *                                       according to port shaper mode.
 * @param[in,out] maxRatePtr           - (pointer to) the actual Rate value in Kbps
 *                                       or packets per second.
 *
 * @retval GT_OK                    - on success
 * @retval GT_FAIL                  - on error
 * @retval GT_BAD_PARAM             - on wrong port number or device
 * @retval GT_HW_ERROR              - on hardware error
 * @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
 *
 * @note 1. For xCat3:
 *       For port number in the range 24..27, whether G or XG type, the global
 *       shaper used parameters are determined by
 *       "cpssDxChPortTxShaperOnStackAsGigEnableSet".
 *       2. For Lion:
 *       If the shaper mode on a given port is packet based and the packet
 *       length (portsPacketLength/cpuPacketLength) configuration isn't null,
 *       maxRatePtr units are packets per second,
 *       otherwise maxRatePtr units are Kbps.
 *       3. burstSize:
 *          For xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2:
 *              max value is 4K-1 which results in 16M burst size
 *          For Falcon; AC5P; AC5X; Harrier; Ironman:
 *              max value is 1K-1 which results in 4M burst size
 */
GT_STATUS cpssDxChPortTxShaperProfileSet
(
    IN    GT_U8     devNum,
    IN    GT_PHYSICAL_PORT_NUM        portNum,
    IN    GT_U16    burstSize,
    INOUT GT_U32    *maxRatePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperProfileSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, burstSize, maxRatePtr));

    rc = internal_cpssDxChPortTxShaperProfileSet(devNum, portNum, burstSize, maxRatePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, burstSize, maxRatePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperProfileGet function
* @endinternal
*
* @brief   Get Token Bucket Shaper Profile on specified port of specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] burstSizePtr             - (pointer to) burst size in units of 4K bytes
* @param[out] maxRatePtr               - (pointer to) the actual Rate value in Kbps
*                                      or packets per second.
* @param[out] enablePtr                - (pointer to) Token Bucket rate shaping status.
*                                      - GT_TRUE - Token Bucket rate shaping is enabled.
*                                      - GT_FALSE - Token Bucket rate shaping is disabled.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1. For Lion:
*       If the shaper mode on a given port is packet based and the packet
*       length (portsPacketLength/cpuPacketLength) configuration isn't null,
*       maxRatePtr units are packets per second,
*       otherwise maxRatePtr units are Kbps.
*
*/
static GT_STATUS internal_cpssDxChPortTxShaperProfileGet
(
    IN  GT_U8   devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT GT_U16  *burstSizePtr,
    OUT GT_U32  *maxRatePtr,
    OUT GT_BOOL *enablePtr
)
{
    return prvCpssDxChPortShaperProfileGet(devNum, portNum,
        CPSS_PARAM_NOT_USED_CNS,
        burstSizePtr, maxRatePtr, enablePtr);
}

/**
* @internal cpssDxChPortTxShaperProfileGet function
* @endinternal
*
* @brief   Get Token Bucket Shaper Profile on specified port of specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] burstSizePtr             - (pointer to) burst size in units of 4K bytes
* @param[out] maxRatePtr               - (pointer to) the actual Rate value in Kbps
*                                      or packets per second.
* @param[out] enablePtr                - (pointer to) Token Bucket rate shaping status.
*                                      - GT_TRUE - Token Bucket rate shaping is enabled.
*                                      - GT_FALSE - Token Bucket rate shaping is disabled.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1. For Lion:
*       If the shaper mode on a given port is packet based and the packet
*       length (portsPacketLength/cpuPacketLength) configuration isn't null,
*       maxRatePtr units are packets per second,
*       otherwise maxRatePtr units are Kbps.
*
*/
GT_STATUS cpssDxChPortTxShaperProfileGet
(
    IN  GT_U8   devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT GT_U16  *burstSizePtr,
    OUT GT_U32  *maxRatePtr,
    OUT GT_BOOL *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperProfileGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, burstSizePtr, maxRatePtr, enablePtr));

    rc = internal_cpssDxChPortTxShaperProfileGet(devNum, portNum, burstSizePtr, maxRatePtr, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, burstSizePtr, maxRatePtr, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQShaperEnableSet function
* @endinternal
*
* @brief   Enable/Disable shaping of transmitted traffic from a specified Traffic
*         Class Queue and specified port of specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..7)
* @param[in] enable                   - GT_TRUE,  shaping on this traffic queue
*                                      GT_FALSE, disable shaping on this traffic queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQShaperEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    IN  GT_BOOL   enable
)
{
    GT_U32      regAddr1;    /* register address for token bucket*/
    GT_U32      portGroupId; /*the port group Id - support multi-port-groups device */
    GT_U32      txqPortNum;  /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_Q_TOKEN_BUCKET_REG_MAC(devNum,portNum,tcQueue,&regAddr1);

        if (GT_FALSE == enable)
        {
            return prvDxChShaperDisable(devNum,
                portGroupId,
                regAddr1);
        }
        else
        {
            return prvCpssHwPpPortGroupSetRegField(devNum,
                portGroupId,
                regAddr1, 0, 1, 1);
        }
    }
    else if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssSip6TxqUtilsShapingEnableSet(devNum,portNum,tcQueue,GT_TRUE,enable);
    }
    else
    {
        return portTxShaperTokenBucketEnable_rev1(devNum,portNum,GT_TRUE,tcQueue,enable);
    }
}

/**
* @internal cpssDxChPortTxQShaperEnableSet function
* @endinternal
*
* @brief   Enable/Disable shaping of transmitted traffic from a specified Traffic
*         Class Queue and specified port of specified device.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..7)
* @param[in] enable                   - GT_TRUE,  shaping on this traffic queue
*                                      GT_FALSE, disable shaping on this traffic queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQShaperEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    IN  GT_BOOL   enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQShaperEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, enable));

    rc = internal_cpssDxChPortTxQShaperEnableSet(devNum, portNum, tcQueue, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQShaperEnableGet function
* @endinternal
*
* @brief   Get Enable/Disable shaping status
*         of transmitted traffic from a specified Traffic
*         Class Queue and specified port of specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..7)
*
* @param[out] enablePtr                - Pointer to  shaping status
*                                      - GT_TRUE, enable shaping on this traffic queue
*                                      - GT_FALSE, disable shaping on this traffic queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQShaperEnableGet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    OUT GT_BOOL   *enablePtr
)
{
    GT_U32      regAddr;    /* register address for token bucket*/
    GT_U32      value;      /* register field value */
    GT_STATUS   rc;         /* return value */
    GT_U32      txqPortNum;  /* TXQ port number */


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_Q_TOKEN_BUCKET_REG_MAC(devNum,portNum,tcQueue,&regAddr);

        rc = prvCpssHwPpPortGroupGetRegField(devNum,
            PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr, 0, 1, &value);
        if(rc != GT_OK)
        {
            return rc;
        }

        *enablePtr = BIT2BOOL_MAC(value);
    }
    else if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssSip6TxqUtilsShapingEnableGet(devNum,portNum,tcQueue,GT_TRUE,enablePtr);
    }
    else
    {
        PORT_TX_SHAPER_TOKEN_BUCKET_STC subEntry;

        /* read entry from HW */
        rc = portTxShaperTokenBucketEntryRead_rev1(devNum,portNum,GT_TRUE,tcQueue,&subEntry);
        if(rc != GT_OK)
        {
            return rc;
        }
        *enablePtr = subEntry.tokenBucketEn;
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxQShaperEnableGet function
* @endinternal
*
* @brief   Get Enable/Disable shaping status
*         of transmitted traffic from a specified Traffic
*         Class Queue and specified port of specified device.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..7)
*
* @param[out] enablePtr                - Pointer to  shaping status
*                                      - GT_TRUE, enable shaping on this traffic queue
*                                      - GT_FALSE, disable shaping on this traffic queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQShaperEnableGet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    OUT GT_BOOL   *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQShaperEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, enablePtr));

    rc = internal_cpssDxChPortTxQShaperEnableGet(devNum, portNum, tcQueue, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQShaperProfileSet function
* @endinternal
*
* @brief   Set Shaper Profile for Traffic Class Queue of specified port on
*         specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this Logical Port
* @param[in] burstSize                - burst size in units of 4K bytes
*                                  (max value is 4K which results in 16M burst size)
* @param[in,out] maxRatePtr               - Requested Rate in Kbps or packets per second.
* @param[in,out] maxRatePtr               - (pointer to) the actual Rate value in Kbps or
*                                      or packets per second.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1. for xCat3:
*       For port number in the range 0..23: whether G or XG type, the global
*       shaper used parameters are those referenced as gig ones -
*       "gigPortsTokensRate" and "gigPortsSlowRateRatio" inputs for
*       "cpssDxChPortTxShaperGlobalParamsSet" API.
*       For port number in the range 24..27: whether G or XG type, the global
*       shaper used parameters are determined by
*       "cpssDxChPortTxShaperOnStackAsGigEnableSet".
*       2. For Lion2:
*       If the shaper mode on a given port is packet based and the packet
*       length (portsPacketLength/cpuPacketLength) configuration isn't null,
*       maxRatePtr units are packets per second,
*       otherwise maxRatePtr units are Kbps.
*
*/
static GT_STATUS internal_cpssDxChPortTxQShaperProfileSet
(
    IN    GT_U8     devNum,
    IN    GT_PHYSICAL_PORT_NUM        portNum,
    IN    GT_U8     tcQueue,
    IN    GT_U16    burstSize,
    INOUT GT_U32    *maxRatePtr
)
{
    return prvCpssDxChPortShaperProfileSet(devNum, portNum, tcQueue,
        burstSize, maxRatePtr);
}

/**
* @internal cpssDxChPortTxQShaperProfileSet function
* @endinternal
*
* @brief   Set Shaper Profile for Traffic Class Queue of specified port on
*         specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this Logical Port
* @param[in] burstSize                - burst size in units of 4K bytes
*                                  (max value is 4K which results in 16M burst size)
* @param[in,out] maxRatePtr               - Requested Rate in Kbps or packets per second.
* @param[in,out] maxRatePtr               - (pointer to) the actual Rate value in Kbps or
*                                      or packets per second.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1. for xCat3:
*       For port number in the range 0..23: whether G or XG type, the global
*       shaper used parameters are those referenced as gig ones -
*       "gigPortsTokensRate" and "gigPortsSlowRateRatio" inputs for
*       "cpssDxChPortTxShaperGlobalParamsSet" API.
*       For port number in the range 24..27: whether G or XG type, the global
*       shaper used parameters are determined by
*       "cpssDxChPortTxShaperOnStackAsGigEnableSet".
*       2. For Lion2:
*       If the shaper mode on a given port is packet based and the packet
*       length (portsPacketLength/cpuPacketLength) configuration isn't null,
*       maxRatePtr units are packets per second,
*       otherwise maxRatePtr units are Kbps.
*
*/
GT_STATUS cpssDxChPortTxQShaperProfileSet
(
    IN    GT_U8     devNum,
    IN    GT_PHYSICAL_PORT_NUM        portNum,
    IN    GT_U8     tcQueue,
    IN    GT_U16    burstSize,
    INOUT GT_U32    *maxRatePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQShaperProfileSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, burstSize, maxRatePtr));

    rc = internal_cpssDxChPortTxQShaperProfileSet(devNum, portNum, tcQueue, burstSize, maxRatePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, burstSize, maxRatePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQShaperProfileGet function
* @endinternal
*
* @brief   Get Shaper Profile for Traffic Class Queue of specified port on
*         specified device.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on the port
*
* @param[out] burstSizePtr             - (pointer to) burst size in units of 4K bytes
* @param[out] maxRatePtr               - (pointer to) the actual Rate value in Kbps
*                                      or packets per second.
* @param[out] enablePtr                - (pointer to) Token Bucket rate shaping status.
*                                      - GT_TRUE - Token Bucket rate shaping is enabled.
*                                      - GT_FALSE - Token Bucket rate shaping is disabled.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1. For Lion:
*       If the shaper mode on a given port is packet based and the packet
*       length (portsPacketLength/cpuPacketLength) configuration isn't null,
*       maxRatePtr units are packets per second,
*       otherwise maxRatePtr units are Kbps.
*
*/
static GT_STATUS internal_cpssDxChPortTxQShaperProfileGet
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8    tcQueue,
    OUT GT_U16   *burstSizePtr,
    OUT GT_U32   *maxRatePtr,
    OUT GT_BOOL  *enablePtr
)
{
    return prvCpssDxChPortShaperProfileGet(devNum, portNum, tcQueue,
        burstSizePtr, maxRatePtr, enablePtr);
}

/**
* @internal cpssDxChPortTxQShaperProfileGet function
* @endinternal
*
* @brief   Get Shaper Profile for Traffic Class Queue of specified port on
*         specified device.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on the port
*
* @param[out] burstSizePtr             - (pointer to) burst size in units of 4K bytes
* @param[out] maxRatePtr               - (pointer to) the actual Rate value in Kbps
*                                      or packets per second.
* @param[out] enablePtr                - (pointer to) Token Bucket rate shaping status.
*                                      - GT_TRUE - Token Bucket rate shaping is enabled.
*                                      - GT_FALSE - Token Bucket rate shaping is disabled.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1. For Lion:
*       If the shaper mode on a given port is packet based and the packet
*       length (portsPacketLength/cpuPacketLength) configuration isn't null,
*       maxRatePtr units are packets per second,
*       otherwise maxRatePtr units are Kbps.
*
*/
GT_STATUS cpssDxChPortTxQShaperProfileGet
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8    tcQueue,
    OUT GT_U16   *burstSizePtr,
    OUT GT_U32   *maxRatePtr,
    OUT GT_BOOL  *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQShaperProfileGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, burstSizePtr, maxRatePtr, enablePtr));

    rc = internal_cpssDxChPortTxQShaperProfileGet(devNum, portNum, tcQueue, burstSizePtr, maxRatePtr, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, burstSizePtr, maxRatePtr, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxBindPortToSchedulerProfileSet function
* @endinternal
*
* @brief   Bind a port to scheduler profile set.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] profileSet               - The Profile Set in which the scheduler's parameters are
*                                      associated.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxBindPortToSchedulerProfileSet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet
)
{
    GT_U32  regAddr;        /* register address */
    GT_U32  fieldOffset;    /* the start bit number in the register         */
    GT_U32  fieldLength;    /* the number of bits to be written to register */
    GT_U32  hwProfileId;    /* HW profile ID */
    GT_STATUS rc;           /* return status */
    GT_U32  txqPortNum;     /* TXQ port number */
    GT_BOOL preemptionEnabled;
    GT_BOOL actAsPreemptiveChannel;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    PRV_CPSS_DXCH_SCHEDULER_PROFILE_CHECK_MAC(profileSet, devNum);

    hwProfileId = (GT_U32)profileSet;


    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        rc = prvCpssSip6TxqUtilsPreemptionStatusGet(devNum,portNum,&preemptionEnabled,&actAsPreemptiveChannel,NULL,NULL);
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc , "prvCpssSip6TxqUtilsPreemptionStatusGet failed for port %d\n", portNum);
        }
        if(GT_TRUE == actAsPreemptiveChannel)
        {
          CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, "Port %d act as preemptive channel.\n", portNum);
        }

        rc = prvCpssFalconTxqUtilsBindPortToSchedulerProfile(devNum,portNum,profileSet,GT_FALSE);
    }
    else
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.priorityArbiterWeights.portSchedulerProfile[txqPortNum];

            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 4, hwProfileId);
        }
        else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            fieldOffset = 16;
            fieldLength = 2;

            PRV_CPSS_DXCH_PORT_TXQ_REG_MAC(devNum,portNum,&regAddr);

            /* Set the scheduler TX Profile 2 LSB association used for   *
            * WRR algorithm for network ports                          */
            rc = prvCpssHwPpPortGroupSetRegField(devNum,PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
                regAddr,
                fieldOffset,
                fieldLength,
                hwProfileId);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* DxCh2 and above supports 8 profiles */
            /* set MSB */
            hwProfileId >>= 2;
            rc = prvCpssHwPpPortGroupSetRegField(devNum,PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
                regAddr,
                24,
                1,
                hwProfileId);
        }
        else
        {
            if (portNum == CPSS_CPU_PORT_NUM_CNS)
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.
                    scheduler.priorityArbiterWeights.portCpuSchedulerProfile;
            }
            else
            {
                if(txqPortNum >= PORTS_NUM_SIP_4_CNS/*size of portSchedulerProfile*/)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
                }

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.
                    scheduler.priorityArbiterWeights.portSchedulerProfile[portNum];
            }


            rc = prvCpssHwPpPortGroupSetRegField(devNum,
                PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
                regAddr,0,3,hwProfileId);
        }

    return rc;
}

/**
* @internal cpssDxChPortTxBindPortToSchedulerProfileSet function
* @endinternal
*
* @brief   Bind a port to scheduler profile set.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] profileSet               - The Profile Set in which the scheduler's parameters are
*                                      associated.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxBindPortToSchedulerProfileSet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxBindPortToSchedulerProfileSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, profileSet));

    rc = internal_cpssDxChPortTxBindPortToSchedulerProfileSet(devNum, portNum, profileSet);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, profileSet));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxBindPortToSchedulerProfileGet function
* @endinternal
*
* @brief   Get scheduler profile set that is binded to the port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] profileSetPtr            - The Profile Set in which the scheduler's parameters are
*                                      associated.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxBindPortToSchedulerProfileGet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    OUT CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  *profileSetPtr
)
{
    GT_U32    regAddr;        /* register address */
    GT_U32    fieldOffset;    /* the start bit number in the register         */
    GT_U32    fieldLength;    /* the number of bits to be written to register */
    GT_U32    hwProfileId;    /* HW profile ID */
    GT_STATUS rc;             /* return status */
    GT_U32    txqPortNum;     /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    CPSS_NULL_PTR_CHECK_MAC(profileSetPtr);


    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        rc = prvCpssFalconTxqUtilsPortSchedulerProfileGet(devNum,portNum,profileSetPtr);
    }
    else
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.priorityArbiterWeights.portSchedulerProfile[txqPortNum];

            rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 4, &hwProfileId);

            *profileSetPtr = (CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT)hwProfileId;
        }
        else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            fieldOffset = 16;
            fieldLength = 2;

            PRV_CPSS_DXCH_PORT_TXQ_REG_MAC(devNum,portNum,&regAddr);

            /* Get the scheduler TX Profile LBSs association used for   *
            * WRR algorithm for network ports                     */
            rc = prvCpssHwPpPortGroupGetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
                regAddr,fieldOffset, fieldLength, &hwProfileId);

            if(rc != GT_OK)
            {
                return rc;
            }

            *profileSetPtr = (CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT)hwProfileId;

            /* DxCh2 and above supports 8 profiles */
            /* get MSB */
            rc = prvCpssHwPpPortGroupGetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
                regAddr,24, 1, &hwProfileId);

            hwProfileId <<= 2;

            *profileSetPtr = (*profileSetPtr) |
            (CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT)hwProfileId;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.
                scheduler.priorityArbiterWeights.portSchedulerProfile[portNum];

            rc = prvCpssHwPpPortGroupGetRegField(devNum,
                PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
                regAddr,0,3,&hwProfileId);

            *profileSetPtr = (CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT)hwProfileId;
        }

    return rc;
}

/**
* @internal cpssDxChPortTxBindPortToSchedulerProfileGet function
* @endinternal
*
* @brief   Get scheduler profile set that is binded to the port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] profileSetPtr            - The Profile Set in which the scheduler's parameters are
*                                      associated.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxBindPortToSchedulerProfileGet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    OUT CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  *profileSetPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxBindPortToSchedulerProfileGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, profileSetPtr));

    rc = internal_cpssDxChPortTxBindPortToSchedulerProfileGet(devNum, portNum, profileSetPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, profileSetPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


static GT_STATUS prvCpssDxChPortTx4TcTailDropProfileParamsTest
(
    GT_U8                                    devNum,
    CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC *tailDropProfileParamsPtr
)
{
    CPSS_NULL_PTR_CHECK_MAC(tailDropProfileParamsPtr);

    if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        /*No descriptor limits on SIP6*/
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)
        {
            if (tailDropProfileParamsPtr->dp0MaxDescrNum >= BIT_16)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
            }

            if (tailDropProfileParamsPtr->dp1MaxDescrNum >= BIT_16)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
            }

            if (tailDropProfileParamsPtr->dp2MaxDescrNum >= BIT_16 )
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
            }

            if (tailDropProfileParamsPtr->tcMaxDescrNum >= BIT_16)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
            }
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)/*No static  TC DP limit on SIP6*/
        {
            if (tailDropProfileParamsPtr->dp0MaxBuffNum >= BIT_20)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
            }

            if (tailDropProfileParamsPtr->dp1MaxBuffNum >= BIT_20)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
            }

            if (tailDropProfileParamsPtr->dp2MaxBuffNum >= BIT_20)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
            }
        }
        if (tailDropProfileParamsPtr->tcMaxBuffNum  >= BIT_20)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

    }
    else
    {
        if (tailDropProfileParamsPtr->dp0MaxBuffNum  >= BIT_14)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        if (tailDropProfileParamsPtr->dp0MaxDescrNum >= BIT_14 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        if (tailDropProfileParamsPtr->dp0MaxMCBuffNum >= BIT_20)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        if (tailDropProfileParamsPtr->dp1MaxBuffNum  >= BIT_14)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        if (tailDropProfileParamsPtr->dp1MaxDescrNum >= BIT_14)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        if (tailDropProfileParamsPtr->dp1MaxMCBuffNum >= BIT_20)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        if (tailDropProfileParamsPtr->dp2MaxBuffNum  >= BIT_14 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        if (tailDropProfileParamsPtr->dp2MaxDescrNum >= BIT_14 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        if (tailDropProfileParamsPtr->dp2MaxMCBuffNum >= BIT_20)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        if (tailDropProfileParamsPtr->tcMaxBuffNum  >= BIT_20)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        if (tailDropProfileParamsPtr->tcMaxDescrNum >= BIT_14)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
    }

    if (PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
    {
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)
        {
            if (tailDropProfileParamsPtr->dp0QueueAlpha > CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_8_E)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            if (tailDropProfileParamsPtr->dp1QueueAlpha > CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_8_E)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            if (tailDropProfileParamsPtr->dp2QueueAlpha > CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_8_E)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChPortTx4TcTailDropProfileSet function
* @endinternal
*
* @brief   Set tail drop profiles limits for particular TC.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] trafficClass             - the Traffic Class associated with this set of
*                                      Drop Parameters (0..7).For Falcon only (0..15)
* @param[in] tailDropProfileParamsPtr -
*                                      the Drop Profile Parameters to associate
*                                      with the Traffic Class in this Profile set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTx4TcTailDropProfileSet
(
    IN    GT_U8                                   devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet,
    IN    GT_U8                                   trafficClass,
    IN    CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC *tailDropProfileParamsPtr
)
{
    GT_STATUS   rc;         /* return code */
    GT_U32      regAddr;    /* register address                         */
    GT_U32      buffOffset; /* buffer field offset                      */
    GT_U32      totalLen;   /* total buffer & descriptor len            */
    GT_U32      regData;    /* data to write into register              */
    GT_U32      maxDescVal; /* the maximum allowed descriptors value    */
    GT_U32      maxBuffVal; /* the maximum allowed buffers value        */
    CPSS_DXCH_TABLE_ENT tableType; /*table type*/
    GT_U32      hwArray[2] = {0};   /* HW table data */
    GT_U32      tableIndex;         /* table index */
    GT_BOOL     isDbaEnable; /* flag indicating if DBA feature is enabled */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(tailDropProfileParamsPtr);
    PRV_CPSS_DXCH_COS_CHECK_4BIT_TC_MAC(devNum,trafficClass);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(profileSet, devNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChPortTx4TcTailDropProfileParamsTest(devNum, tailDropProfileParamsPtr);
        if (rc != GT_OK)
        {
            return rc;
        }

        if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E) &&
        (PRV_CPSS_DXCH_DBA_NUMBER_OF_TX_PROFILES > profileSet))
        {
            rc = cpssDxChPortTxDbaEnableGet(devNum, &isDbaEnable);
            if (rc != GT_OK)
            {
                return rc;
            }

            if (GT_TRUE == isDbaEnable)
            {
                return prvCpssDxChPortTxDbaProfileTcSet(devNum,
                    profileSet,
                    trafficClass,
                    tailDropProfileParamsPtr);
            }
        }

        /******************/
        /*   Set DP0      */
        /******************/
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)
        {
            tableIndex = (profileSet<<3) + trafficClass;
        }
        else
        {
            tableIndex = (profileSet<<4) + trafficClass;
        }

        /* Queue Limits DP0 - Enqueue */
        tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP0_E;

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            PRV_CPSS_PORT_TX_TAIL_DROP_SIP6_ALPHA_TO_HW_CONVERT_MAC(tailDropProfileParamsPtr->dp0QueueAlpha, regData);

            rc = prvCpssDxChWriteTableEntryField(devNum,
                CPSS_DXCH_SIP6_TABLE_PREQ_QUEUE_DP_CONFIGURATIONS_E,
                tableIndex,
                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,0,4,
                regData);

            if(rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "Updating TABLE_PREQ_QUEUE_CONFIGURATIONS  failed at index %d\n",16*(profileSet*16+trafficClass));
            }
        }
        else if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
        {
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp0MaxDescrNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp0MaxBuffNum);
            PRV_CPSS_PORT_TX_TAIL_DROP_QCN_DBA_ALPHA_TO_HW_CONVERT_MAC(tailDropProfileParamsPtr->dp0QueueAlpha, regData);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 52, 3, regData);
        }
        else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp0MaxDescrNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp0MaxBuffNum);
        }
        else
        {
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 14, tailDropProfileParamsPtr->dp0MaxDescrNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 14, 14, tailDropProfileParamsPtr->dp0MaxBuffNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 28, 20, tailDropProfileParamsPtr->dp0MaxMCBuffNum);
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)
        {
            rc = prvCpssDxChWriteTableEntry(devNum, tableType, tableIndex, hwArray);
            if(rc != GT_OK)
            {
                return rc;
            }


            /* Queue Buffer Limits - Dequeue */
            tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_DQ_QUEUE_BUF_LIMITS_E;

            hwArray[0] = hwArray[1] = 0;
            if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 16, 20, tailDropProfileParamsPtr->dp0MaxBuffNum);
            }
            else
            {
                U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 14, tailDropProfileParamsPtr->dp0MaxBuffNum);
                U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 14, 20, tailDropProfileParamsPtr->dp0MaxMCBuffNum);
            }

            rc = prvCpssDxChWriteTableEntry(devNum, tableType, tableIndex, hwArray);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* Queue Descriptor Limits - Dequeue */
            tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_DQ_QUEUE_DESC_LIMITS_E;

            hwArray[0] = hwArray[1] = 0;
            hwArray[0] = tailDropProfileParamsPtr->dp0MaxDescrNum;
            rc = prvCpssDxChWriteTableEntry(devNum, tableType, tableIndex, hwArray);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /*******************/
        /*  Set DP1 & DP2  */
        /*******************/

        /* Queue Limits DP12 - Enqueue */
        tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP1_E;

        hwArray[0] = hwArray[1] = 0;
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            PRV_CPSS_PORT_TX_TAIL_DROP_SIP6_ALPHA_TO_HW_CONVERT_MAC(tailDropProfileParamsPtr->dp1QueueAlpha, regData);

            rc = prvCpssDxChWriteTableEntryField(devNum,
                CPSS_DXCH_SIP6_TABLE_PREQ_QUEUE_DP_CONFIGURATIONS_E,
                256+tableIndex,
                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,0,4,
                regData);

            if(rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "Updating TABLE_PREQ_QUEUE_CONFIGURATIONS  failed at index %d\n",16*(profileSet*16+trafficClass));
            }
        }
        else if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
        {
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp1MaxDescrNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp1MaxBuffNum);
            PRV_CPSS_PORT_TX_TAIL_DROP_QCN_DBA_ALPHA_TO_HW_CONVERT_MAC(tailDropProfileParamsPtr->dp1QueueAlpha, regData);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 52, 3, regData);
        }
        else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp1MaxDescrNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp1MaxBuffNum);
        }
        else
        {
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 14, tailDropProfileParamsPtr->dp1MaxDescrNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 14, 14, tailDropProfileParamsPtr->dp1MaxBuffNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 28, 20, tailDropProfileParamsPtr->dp1MaxMCBuffNum);
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)
        {
            rc = prvCpssDxChWriteTableEntry(devNum, tableType, tableIndex, hwArray);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* Queue Limits DP12 - Enqueue */
        tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP2_E;
        hwArray[0] = hwArray[1] = 0;

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            PRV_CPSS_PORT_TX_TAIL_DROP_SIP6_ALPHA_TO_HW_CONVERT_MAC(tailDropProfileParamsPtr->dp2QueueAlpha, regData);

            rc = prvCpssDxChWriteTableEntryField(devNum,
                CPSS_DXCH_SIP6_TABLE_PREQ_QUEUE_DP_CONFIGURATIONS_E,
                512+tableIndex,
                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,0,4,
                regData);

            if(rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "Updating TABLE_PREQ_QUEUE_CONFIGURATIONS  failed at index %d\n",16*(profileSet*16+trafficClass));
            }
        }
        else if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
        {
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp2MaxDescrNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp2MaxBuffNum);
            PRV_CPSS_PORT_TX_TAIL_DROP_QCN_DBA_ALPHA_TO_HW_CONVERT_MAC(tailDropProfileParamsPtr->dp2QueueAlpha, regData);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 52, 3, regData);
        }
        else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp2MaxDescrNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp2MaxBuffNum);
        }
        else
        {
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 14, tailDropProfileParamsPtr->dp2MaxDescrNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 14, 14, tailDropProfileParamsPtr->dp2MaxBuffNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 28, 20, tailDropProfileParamsPtr->dp2MaxMCBuffNum);
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)
        {
            rc = prvCpssDxChWriteTableEntry(devNum, tableType, tableIndex, hwArray);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* Set TC */
        tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_MAX_QUEUE_LIMITS_E;
        hwArray[0] = hwArray[1] = 0;

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            rc = prvCpssDxChWriteTableEntryField(devNum,
                CPSS_DXCH_SIP6_TABLE_PREQ_QUEUE_CONFIGURATIONS_E,
                tableIndex,
                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,0,20,
                tailDropProfileParamsPtr->tcMaxBuffNum);

            if(rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "Updating TABLE_PREQ_QUEUE_CONFIGURATIONS  failed at index %d\n",16*(profileSet*16+trafficClass));
            }

            /*we are done for sip6*/
            return GT_OK;
        }
        else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->tcMaxDescrNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 16, 20, tailDropProfileParamsPtr->tcMaxBuffNum);
        }
        else
        {
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 0, 14, tailDropProfileParamsPtr->tcMaxDescrNum);
            U32_SET_FIELD_IN_ENTRY_MAC(hwArray, 14, 20, tailDropProfileParamsPtr->tcMaxBuffNum);
        }

        rc = prvCpssDxChWriteTableEntry(devNum, tableType, tableIndex, hwArray);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) == 0)
        {
            /* Set shared counters mode per profile */
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profileTailDropConfig[profileSet];
            regData = (tailDropProfileParamsPtr->sharedUcAndMcCountersDisable == GT_TRUE) ? 0 : 1;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 2, 1, regData);
        }

        return rc;
    }

    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(trafficClass);
    if(profileSet > CPSS_PORT_TX_DROP_PROFILE_8_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    maxBuffVal = PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_MAX_CNS;
    maxDescVal = PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_MAX_CNS;
    buffOffset = PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_OFFSET_CNS;
    totalLen   = PRV_CPSS_DXCH3_TC_DP_PARAMS_LEN_CNS;

    if ( (tailDropProfileParamsPtr->dp0MaxBuffNum  > maxBuffVal) ||
    (tailDropProfileParamsPtr->dp0MaxDescrNum > maxDescVal) ||
    (tailDropProfileParamsPtr->dp2MaxBuffNum  > maxBuffVal) ||
    (tailDropProfileParamsPtr->dp2MaxDescrNum > maxDescVal) )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if( 0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum) )
    {

        /* Set DP0 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            egrTxQConf.setsConfigRegs.tcDp0Red[trafficClass][profileSet];

        regData = tailDropProfileParamsPtr->dp0MaxDescrNum |
        (tailDropProfileParamsPtr->dp0MaxBuffNum << buffOffset);

        if (prvCpssHwPpSetRegField(devNum, regAddr, 0, totalLen, regData) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* Set DP1 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            egrTxQConf.setsConfigRegs.tcDp1Red[trafficClass][profileSet];

        regData = tailDropProfileParamsPtr->dp2MaxDescrNum |
        (tailDropProfileParamsPtr->dp2MaxBuffNum << buffOffset);

        return prvCpssHwPpSetRegField(devNum, regAddr, 0, totalLen, regData);
    }
    else
    {


        if ( (tailDropProfileParamsPtr->dp1MaxBuffNum  > maxBuffVal) ||
        (tailDropProfileParamsPtr->dp1MaxDescrNum > maxDescVal) ||
        (tailDropProfileParamsPtr->tcMaxBuffNum  > maxBuffVal) ||
        (tailDropProfileParamsPtr->tcMaxDescrNum > maxDescVal) )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled == GT_TRUE)
        {
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.tailDropUcEnable == GT_FALSE)
            {
                cpssOsMemCpy(&PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                    profileInfo[profileSet].tailDropProfileParamsArray[trafficClass],tailDropProfileParamsPtr,sizeof(CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC));

                return GT_OK;
            }
        }

        /* Set DP0 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.eqQueueLimitsDp0[profileSet][trafficClass];

        regData = tailDropProfileParamsPtr->dp0MaxDescrNum |
        (tailDropProfileParamsPtr->dp0MaxBuffNum << buffOffset);

        if (prvCpssHwPpSetRegField(devNum, regAddr, 0, totalLen, regData) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.dqQueueDescLimits[profileSet][trafficClass];

        regData = tailDropProfileParamsPtr->dp0MaxDescrNum;

        if (prvCpssHwPpSetRegField(devNum, regAddr, 0, 14, regData) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.dqQueueBufLimits[profileSet][trafficClass];

        regData = tailDropProfileParamsPtr->dp0MaxBuffNum;

        if (prvCpssHwPpSetRegField(devNum, regAddr, 0, 14, regData) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* Set DP1 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.eqQueueLimitsDp1[profileSet][trafficClass];

        regData = tailDropProfileParamsPtr->dp1MaxDescrNum |
        (tailDropProfileParamsPtr->dp1MaxBuffNum << buffOffset);

        if (prvCpssHwPpSetRegField(devNum, regAddr, 0, totalLen, regData) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* Set DP2 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.eqQueueLimitsDp2[profileSet][trafficClass];

        regData = tailDropProfileParamsPtr->dp2MaxDescrNum |
        (tailDropProfileParamsPtr->dp2MaxBuffNum << buffOffset);

        if (prvCpssHwPpSetRegField(devNum, regAddr, 0, totalLen, regData) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* Set TC */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.maximumQueueLimits[profileSet][trafficClass];

        regData = tailDropProfileParamsPtr->tcMaxDescrNum |
        (tailDropProfileParamsPtr->tcMaxBuffNum << buffOffset);

        return prvCpssHwPpSetRegField(devNum, regAddr, 0, totalLen, regData);
    }
}

/**
* @internal cpssDxChPortTx4TcTailDropProfileSet function
* @endinternal
*
* @brief   Set tail drop profiles limits for particular TC.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] trafficClass             - the Traffic Class associated with this set of
*                                       Drop Parameters (0..7).For Falcon only (0..15)
* @param[in] tailDropProfileParamsPtr -
*                                      the Drop Profile Parameters to associate
*                                      with the Traffic Class in this Profile set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTx4TcTailDropProfileSet
(
    IN    GT_U8                                   devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet,
    IN    GT_U8                                   trafficClass,
    IN    CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC *tailDropProfileParamsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTx4TcTailDropProfileSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profileSet, trafficClass, tailDropProfileParamsPtr));

    rc = internal_cpssDxChPortTx4TcTailDropProfileSet(devNum, profileSet, trafficClass, tailDropProfileParamsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profileSet, trafficClass, tailDropProfileParamsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTx4TcTailDropProfileGet function
* @endinternal
*
* @brief   Get tail drop profiles limits for particular TC.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] trafficClass             - the Traffic Class associated with this set of
*                                                           Drop Parameters (0..7).For Falcon only (0..15)
*
* @param[out] tailDropProfileParamsPtr - Pointer to
*                                      the Drop Profile Parameters to associate
*                                      with the Traffic Class in this Profile.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTx4TcTailDropProfileGet
(
    IN    GT_U8                                   devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet,
    IN    GT_U8                                   trafficClass,
    OUT   CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC *tailDropProfileParamsPtr
)
{
    GT_U32      regAddr;    /* register address                         */
    GT_U32      buffOffset; /* buffer field offset                      */
    GT_U32      buffLen;    /* buffer field length                      */
    GT_U32      descLen;    /* descriptor field len                     */
    GT_U32      totalLen;   /* total buffer & descriptor len            */
    GT_U32      regData;    /* data to write into register              */
    GT_STATUS   rc;         /* return value                             */
    CPSS_DXCH_TABLE_ENT tableType; /*table type*/
    GT_U32      hwArray[4]; /* HW table data */
    GT_U32      tableIndex; /* table index */
    GT_BOOL     isDbaEnable; /* flag indicating if DBA feature is enabled */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(tailDropProfileParamsPtr);
    PRV_CPSS_DXCH_COS_CHECK_4BIT_TC_MAC(devNum,trafficClass);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(profileSet, devNum);

    buffOffset = PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_OFFSET_CNS;
    buffLen    = PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_LEN_CNS;
    descLen    = PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_LEN_CNS;
    totalLen   = PRV_CPSS_DXCH3_TC_DP_PARAMS_LEN_CNS;

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)
        {
            tableIndex = (profileSet<<3) + trafficClass;
            /* Queue Limits DP0 - Enqueue */
            tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP0_E;
        }
        else
        {
            tableIndex = (profileSet<<4) + trafficClass;
            tableType = CPSS_DXCH_SIP6_TABLE_PREQ_QUEUE_DP_CONFIGURATIONS_E;
        }


        rc = prvCpssDxChReadTableEntry(devNum, tableType, tableIndex, hwArray);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 4, regData);
            PRV_CPSS_PORT_TX_TAIL_DROP_SIP6_HW_TO_ALPHA_CONVERT_MAC(tailDropProfileParamsPtr->dp0QueueAlpha,
                regData);
        }
        else if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp0MaxDescrNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp0MaxBuffNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 52, 3, regData);
            PRV_CPSS_PORT_TX_TAIL_DROP_QCN_DBA_HW_TO_ALPHA_CONVERT_MAC(regData,
                tailDropProfileParamsPtr->dp0QueueAlpha);
        }
        else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp0MaxDescrNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp0MaxBuffNum);
        }
        else
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 14, tailDropProfileParamsPtr->dp0MaxDescrNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 14, 14, tailDropProfileParamsPtr->dp0MaxBuffNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 28, 20, tailDropProfileParamsPtr->dp0MaxMCBuffNum);
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)
        {
            /* Queue Limits DP12 - Enqueue */
            tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP1_E;
        }
        else
        {
            tableIndex +=256;
        }
        rc = prvCpssDxChReadTableEntry(devNum, tableType, tableIndex, hwArray);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 4, regData);
            PRV_CPSS_PORT_TX_TAIL_DROP_SIP6_HW_TO_ALPHA_CONVERT_MAC(tailDropProfileParamsPtr->dp1QueueAlpha,
                regData);
        }
        else if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp1MaxDescrNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp1MaxBuffNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 52, 3, regData);
            PRV_CPSS_PORT_TX_TAIL_DROP_QCN_DBA_HW_TO_ALPHA_CONVERT_MAC(regData,
                tailDropProfileParamsPtr->dp1QueueAlpha);
        }
        else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp1MaxDescrNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp1MaxBuffNum);
        }
        else
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 14, tailDropProfileParamsPtr->dp1MaxDescrNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 14, 14, tailDropProfileParamsPtr->dp1MaxBuffNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 28, 20, tailDropProfileParamsPtr->dp1MaxMCBuffNum);
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)
        {
            /* Queue Limits DP12 - Enqueue */
            tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP2_E;
        }
        else
        {
            tableIndex+=256;
        }

        rc = prvCpssDxChReadTableEntry(devNum, tableType, tableIndex, hwArray);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 4, regData);
            PRV_CPSS_PORT_TX_TAIL_DROP_SIP6_HW_TO_ALPHA_CONVERT_MAC(tailDropProfileParamsPtr->dp2QueueAlpha,
                regData);
        }
        else if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp2MaxDescrNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp2MaxBuffNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 52, 3, regData);
            PRV_CPSS_PORT_TX_TAIL_DROP_QCN_DBA_HW_TO_ALPHA_CONVERT_MAC(regData,
                tailDropProfileParamsPtr->dp2QueueAlpha);
        }
        else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->dp2MaxDescrNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 32, 20, tailDropProfileParamsPtr->dp2MaxBuffNum);
        }
        else
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 14, tailDropProfileParamsPtr->dp2MaxDescrNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 14, 14, tailDropProfileParamsPtr->dp2MaxBuffNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 28, 20, tailDropProfileParamsPtr->dp2MaxMCBuffNum);
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)==GT_FALSE)
        {
            /* Get TC */
            tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_MAX_QUEUE_LIMITS_E;
        }
        else
        {
            tableType = CPSS_DXCH_SIP6_TABLE_PREQ_QUEUE_CONFIGURATIONS_E;
            tableIndex-=512;
        }
        rc = prvCpssDxChReadTableEntry(devNum, tableType, tableIndex, hwArray);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 20, tailDropProfileParamsPtr->tcMaxBuffNum);
        }
        else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 16, tailDropProfileParamsPtr->tcMaxDescrNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 16, 20, tailDropProfileParamsPtr->tcMaxBuffNum);
        }
        else
        {
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 0, 14, tailDropProfileParamsPtr->tcMaxDescrNum);
            U32_GET_FIELD_IN_ENTRY_MAC(hwArray, 14, 20, tailDropProfileParamsPtr->tcMaxBuffNum);
        }

        if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) == 0)
        {
            /* Set shared counters mode per profile */
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profileTailDropConfig[profileSet];
            rc = prvCpssHwPpGetRegField(devNum, regAddr, 2, 1, &regData);
            if(rc != GT_OK)
            {
                return rc;
            }

            tailDropProfileParamsPtr->sharedUcAndMcCountersDisable = (regData == 0) ? GT_TRUE : GT_FALSE;
        }
        else
        {
            tailDropProfileParamsPtr->sharedUcAndMcCountersDisable = GT_FALSE;
            tailDropProfileParamsPtr->dp0MaxMCBuffNum = 0;
            tailDropProfileParamsPtr->dp1MaxMCBuffNum = 0;
            tailDropProfileParamsPtr->dp2MaxMCBuffNum = 0;
        }

        if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E) &&
        (PRV_CPSS_DXCH_DBA_NUMBER_OF_TX_PROFILES > profileSet))
        {
            rc = cpssDxChPortTxDbaEnableGet(devNum, &isDbaEnable);
            if (rc != GT_OK)
            {
                return rc;
            }

            if (GT_TRUE == isDbaEnable)
            {
                return prvCpssDxChPortTxDbaProfileTcGet(devNum,
                    profileSet,
                    trafficClass,
                    tailDropProfileParamsPtr);
            }
        }

        return GT_OK;
    }

    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(trafficClass);
    if(profileSet > CPSS_PORT_TX_DROP_PROFILE_8_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    tailDropProfileParamsPtr->sharedUcAndMcCountersDisable = GT_FALSE;
    tailDropProfileParamsPtr->dp0MaxMCBuffNum = 0;
    tailDropProfileParamsPtr->dp1MaxMCBuffNum = 0;
    tailDropProfileParamsPtr->dp2MaxMCBuffNum = 0;

    if( 0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum) )
    {

        /* Get DP0 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            egrTxQConf.setsConfigRegs.tcDp0Red[trafficClass][profileSet];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, totalLen, &regData);
        if(rc != GT_OK)
        {
            return rc;
        }

        tailDropProfileParamsPtr->dp0MaxDescrNum = (GT_U16)U32_GET_FIELD_MAC(regData, 0, descLen);
        tailDropProfileParamsPtr->dp0MaxBuffNum  = (GT_U16)U32_GET_FIELD_MAC(regData, buffOffset, buffLen);

        /* Get DP1 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            egrTxQConf.setsConfigRegs.tcDp1Red[trafficClass][profileSet];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, totalLen, &regData);
        if(rc != GT_OK)
        {
            return rc;
        }

        tailDropProfileParamsPtr->dp2MaxDescrNum = (GT_U16)U32_GET_FIELD_MAC(regData, 0, descLen);
        tailDropProfileParamsPtr->dp2MaxBuffNum  = (GT_U16)U32_GET_FIELD_MAC(regData, buffOffset, buffLen);
    }
    else
    {
        if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled == GT_TRUE)
        {
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.tailDropUcEnable == GT_FALSE)
            {
                cpssOsMemCpy(tailDropProfileParamsPtr,&(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                    profileInfo[profileSet].tailDropProfileParamsArray[trafficClass]),sizeof(CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC));
                return GT_OK;
            }
        }

        /* Get DP0 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.eqQueueLimitsDp0[profileSet][trafficClass];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, totalLen, &regData);
        if(rc != GT_OK)
        {
            return rc;
        }

        tailDropProfileParamsPtr->dp0MaxDescrNum = (GT_U16)U32_GET_FIELD_MAC(regData, 0, descLen);
        tailDropProfileParamsPtr->dp0MaxBuffNum  = (GT_U16)U32_GET_FIELD_MAC(regData, buffOffset, buffLen);

        /* Get DP1 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.eqQueueLimitsDp1[profileSet][trafficClass];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, totalLen, &regData);
        if(rc != GT_OK)
        {
            return rc;
        }

        tailDropProfileParamsPtr->dp1MaxDescrNum = (GT_U16)U32_GET_FIELD_MAC(regData, 0, descLen);
        tailDropProfileParamsPtr->dp1MaxBuffNum  = (GT_U16)U32_GET_FIELD_MAC(regData, buffOffset, buffLen);

        /* Get DP2 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.eqQueueLimitsDp2[profileSet][trafficClass];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, totalLen, &regData);
        if(rc != GT_OK)
        {
            return rc;
        }

        tailDropProfileParamsPtr->dp2MaxDescrNum = (GT_U16)U32_GET_FIELD_MAC(regData, 0, descLen);
        tailDropProfileParamsPtr->dp2MaxBuffNum  = (GT_U16)U32_GET_FIELD_MAC(regData, buffOffset, buffLen);

        /* Get TC */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.maximumQueueLimits[profileSet][trafficClass];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, totalLen, &regData);
        if(rc != GT_OK)
        {
            return rc;
        }

        tailDropProfileParamsPtr->tcMaxDescrNum = (GT_U16)U32_GET_FIELD_MAC(regData, 0, descLen);
        tailDropProfileParamsPtr->tcMaxBuffNum  = (GT_U16)U32_GET_FIELD_MAC(regData, buffOffset, buffLen);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTx4TcTailDropProfileGet function
* @endinternal
*
* @brief   Get tail drop profiles limits for particular TC.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] trafficClass             - the Traffic Class associated with this set of
*                                                           Drop Parameters (0..7).For Falcon only (0..15)
*
* @param[out] tailDropProfileParamsPtr - Pointer to
*                                      the Drop Profile Parameters to associate
*                                      with the Traffic Class in this Profile.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTx4TcTailDropProfileGet
(
    IN    GT_U8                                   devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet,
    IN    GT_U8                                   trafficClass,
    OUT   CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC *tailDropProfileParamsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTx4TcTailDropProfileGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profileSet, trafficClass, tailDropProfileParamsPtr));

    rc = internal_cpssDxChPortTx4TcTailDropProfileGet(devNum, profileSet, trafficClass, tailDropProfileParamsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profileSet, trafficClass, tailDropProfileParamsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropProfileSet function
* @endinternal
*
* @brief Configures port dynamic limit alpha and set maximal port's limits of
*       buffers and descriptors.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                       Class Drop Parameters is associated
* @param[in] portAlpha                - ratio of the free buffers used for the port
*                                       thresholds (APPLICABLE DEVICES: Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman).
* @param[in] portMaxBuffLimit         - maximal number of buffers for a port.
*                                  (APPLICABLE RANGES:
*                                       xCat3; AC5 0..16383;
*                                       Bobcat2,Caelum,Bobcat3,Aldrin,Aldrin2 0..0xFFFFF)
* @param[in] portMaxDescrLimit        - maximal number of descriptors for a port.
*                                  (APPLICABLE RANGES:
*                                       xCat3, AC5, Aldrin2 0..16383;
*                                       Bobcat2,Caelum,Bobcat3,Aldrin 0..0xFFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number or profile set
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropProfileSet
(
    IN  GT_U8                                devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT    profileSet,
    IN  CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_ENT portAlpha,
    IN  GT_U32                               portMaxBuffLimit,
    IN  GT_U32                               portMaxDescrLimit
)
{
    GT_STATUS   rc;         /* return code */
    GT_U32      regAddr;    /* register address                         */
    GT_U32      buffOffset; /* buffer field offset                      */
    GT_U32      totalLen;   /* total buffer & descriptor len            */
    GT_U32      regData;    /* data to write into register              */
    GT_U32      maxDescVal; /* the maximum allowed descriptors value    */
    GT_U32      maxBuffVal; /* the maximum allowed buffers value        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(profileSet, devNum);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        PRV_CPSS_PORT_TX_TAIL_DROP_SIP6_ALPHA_TO_HW_CONVERT_MAC(portAlpha, regData);

        rc = prvCpssDxChWriteTableEntryField(devNum,
            CPSS_DXCH_SIP6_TABLE_PREQ_PORT_PROFILE_E,
            profileSet,PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,0,4,regData);

        return rc;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
        {
            maxDescVal = 0xFFFF;
        }
        else
        {
            maxDescVal = 0xFFFFF;
        }
        maxBuffVal = 0xFFFFF;
        buffOffset = 0;
        totalLen   = 20;
    }
    else /* xCat3 and Lion2 */
    {
        maxDescVal = PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_MAX_CNS;
        maxBuffVal = PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_MAX_CNS;
        buffOffset = PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_OFFSET_CNS;
        totalLen   = PRV_CPSS_DXCH3_TC_DP_PARAMS_LEN_CNS;
    }

    if ( (portMaxBuffLimit > maxBuffVal) ||
    (portMaxDescrLimit > maxDescVal) )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled == GT_TRUE)
        {
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.tailDropUcEnable == GT_FALSE)
            {
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                    profileInfo[profileSet].portMaxBuffLimit = portMaxBuffLimit;
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                    profileInfo[profileSet].portMaxDescrLimit = portMaxDescrLimit;

                return GT_OK;
            }
        }


        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropLimits.profilePortBufferLimits[profileSet];
        regData = portMaxBuffLimit;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, totalLen, regData);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
        {
            PRV_CPSS_PORT_TX_TAIL_DROP_QCN_DBA_ALPHA_TO_HW_CONVERT_MAC(portAlpha, regData);
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 20, 3, regData);
            if(rc != GT_OK)
            {
                return rc;
            }

            totalLen = 16;
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropLimits.profilePortDescLimits[profileSet];
        regData = portMaxDescrLimit;
        return prvCpssHwPpSetRegField(devNum, regAddr, 0, totalLen, regData);
    }
    else
    {
        PRV_CPSS_DXCH_PORT_DESCR_LIMIT_REG_MAC(devNum,profileSet,&regAddr);

        regData = portMaxDescrLimit | (portMaxBuffLimit << buffOffset);

        if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled == GT_TRUE)
        {
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.tailDropUcEnable == GT_FALSE)
            {
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                    profileInfo[profileSet].portMaxBuffLimit = portMaxBuffLimit;
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                    profileInfo[profileSet].portMaxDescrLimit = portMaxDescrLimit;

                return GT_OK;
            }
        }

        return prvCpssHwPpSetRegField(devNum, regAddr, 0, totalLen, regData);
    }
}

/**
* @internal cpssDxChPortTxTailDropProfileSet function
* @endinternal
*
* @brief Configures port dynamic limit alpha and set maximal port's limits of
*       buffers and descriptors.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                       Class Drop Parameters is associated
* @param[in] portAlpha                - ratio of the free buffers used for the port
*                                       thresholds (APPLICABLE DEVICES: Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman).
* @param[in] portMaxBuffLimit         - maximal number of buffers for a port.
*                                  (APPLICABLE RANGES:
*                                       xCat3; AC5 0..16383;
*                                       Bobcat2,Caelum,Bobcat3,Aldrin,Aldrin2 0..0xFFFFF)
* @param[in] portMaxDescrLimit        - maximal number of descriptors for a port.
*                                  (APPLICABLE RANGES:
*                                       xCat3, AC5, Aldrin2 0..16383;
*                                       Bobcat2,Caelum,Bobcat3,Aldrin 0..0xFFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number or profile set
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropProfileSet
(
    IN  GT_U8                                devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT    profileSet,
    IN  CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_ENT portAlpha,
    IN  GT_U32                               portMaxBuffLimit,
    IN  GT_U32                               portMaxDescrLimit
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropProfileSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profileSet, portAlpha, portMaxBuffLimit, portMaxDescrLimit));

    rc = internal_cpssDxChPortTxTailDropProfileSet(devNum, profileSet, portAlpha, portMaxBuffLimit, portMaxDescrLimit);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profileSet, portAlpha, portMaxBuffLimit, portMaxDescrLimit));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropProfileGet function
* @endinternal
*
* @brief Get port dynamic limit alpha and set maximal port's limits of buffers
*       and descriptors.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                       Class Drop Parameters is associated
*
* @param[out] portAlphaPtr            - Pointer to ratio of the free buffers
*                                       used for the port thresholds
*                                   (APPLICABLE DEVICES: Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman).
* @param[out] portMaxBuffLimitPtr     - Pointer to maximal number of buffers for a port
* @param[out] portMaxDescrLimitPtr    - Pointer to maximal number of descriptors for a port
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number or profile set
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropProfileGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT    profileSet,
    OUT CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_ENT *portAlphaPtr,
    OUT GT_U32                               *portMaxBuffLimitPtr,
    OUT GT_U32                               *portMaxDescrLimitPtr
)
{
    GT_U32      regAddr;    /* register address                         */
    GT_U32      buffOffset; /* buffer field offset                      */
    GT_U32      buffLen;    /* buffer field length                      */
    GT_U32      descLen;    /* descriptor field len                     */
    GT_U32      totalLen;   /* total buffer & descriptor len            */
    GT_U32      regData;    /* data to write into register              */
    GT_STATUS   rc;         /* return value                             */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(profileSet, devNum);
    CPSS_NULL_PTR_CHECK_MAC(portAlphaPtr);
    CPSS_NULL_PTR_CHECK_MAC(portMaxBuffLimitPtr);
    CPSS_NULL_PTR_CHECK_MAC(portMaxDescrLimitPtr);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        regData = 0;
        rc = prvCpssDxChReadTableEntryField(devNum,
            CPSS_DXCH_SIP6_TABLE_PREQ_PORT_PROFILE_E,
            profileSet,PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,0,4,&regData);

        if(rc==GT_OK)
        {
            PRV_CPSS_PORT_TX_TAIL_DROP_SIP6_HW_TO_ALPHA_CONVERT_MAC(*portAlphaPtr, regData);
        }

        return rc;
    }

    *portAlphaPtr = CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_0_E;
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        totalLen   = 20;
        buffOffset = 0;
        buffLen = 0;
        descLen = 0;
    }
    else /* xCat3 and Lion2 */
    {
        buffOffset = PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_OFFSET_CNS;
        buffLen    = PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_LEN_CNS;
        descLen    = PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_LEN_CNS;
        totalLen   = PRV_CPSS_DXCH3_TC_DP_PARAMS_LEN_CNS;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled == GT_TRUE)
        {
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.tailDropUcEnable == GT_FALSE)
            {
                *portMaxBuffLimitPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                    profileInfo[profileSet].portMaxBuffLimit;
                *portMaxDescrLimitPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                    profileInfo[profileSet].portMaxDescrLimit;

                return GT_OK;
            }
        }


        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropLimits.profilePortBufferLimits[profileSet];
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, totalLen, portMaxBuffLimitPtr);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
        {
            rc = prvCpssHwPpGetRegField(devNum, regAddr, 20, 3, &regData);
            if(rc != GT_OK)
            {
                return rc;
            }
            PRV_CPSS_PORT_TX_TAIL_DROP_QCN_DBA_HW_TO_ALPHA_CONVERT_MAC(regData, *portAlphaPtr);

            totalLen = 16;
        }
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropLimits.profilePortDescLimits[profileSet];
        return prvCpssHwPpGetRegField(devNum, regAddr, 0, totalLen, portMaxDescrLimitPtr);
    }
    else
    {
        PRV_CPSS_DXCH_PORT_DESCR_LIMIT_REG_MAC(devNum,profileSet,&regAddr);

        if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled == GT_TRUE)
        {
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.tailDropUcEnable == GT_FALSE)
            {
                *portMaxBuffLimitPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                    profileInfo[profileSet].portMaxBuffLimit;
                *portMaxDescrLimitPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                    profileInfo[profileSet].portMaxDescrLimit;

                return GT_OK;
            }
        }

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, totalLen+1, &regData);
        if(rc != GT_OK)
        {
            return rc;
        }

        *portMaxDescrLimitPtr = U32_GET_FIELD_MAC(regData, 0, descLen);
        *portMaxBuffLimitPtr = U32_GET_FIELD_MAC(regData, buffOffset, buffLen);

        return GT_OK;
    }
}

/**
* @internal cpssDxChPortTxTailDropProfileGet function
* @endinternal
*
* @brief Get port dynamic limit alpha and set maximal port's limits of buffers
*       and descriptors.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                       Class Drop Parameters is associated
*
* @param[out] portAlphaPtr            - Pointer to ratio of the free buffers
*                                       used for the port thresholds
*                                   (APPLICABLE DEVICES: Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman).
* @param[out] portMaxBuffLimitPtr     - Pointer to maximal number of buffers for a port
* @param[out] portMaxDescrLimitPtr    - Pointer to maximal number of descriptors for a port
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number or profile set
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropProfileGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT    profileSet,
    OUT CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_ENT *portAlphaPtr,
    OUT GT_U32                               *portMaxBuffLimitPtr,
    OUT GT_U32                               *portMaxDescrLimitPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropProfileGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profileSet, portAlphaPtr, portMaxBuffLimitPtr, portMaxDescrLimitPtr));

    rc = internal_cpssDxChPortTxTailDropProfileGet(devNum, profileSet, portAlphaPtr, portMaxBuffLimitPtr, portMaxDescrLimitPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profileSet, portAlphaPtr, portMaxBuffLimitPtr, portMaxDescrLimitPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSniffedPcktDescrLimitSet function
* @endinternal
*
* @brief   Set maximal descriptors limits for mirrored packets.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] rxSniffMaxDescNum        - The number of descriptors allocated for packets
*                                      forwarded to the ingress analyzer port due to
*                                      mirroring.
*                                      For xCat3: range 0..0x3FFF
*                                      For Lion: range 0..0xFFFF
* @param[in] txSniffMaxDescNum        - The number of descriptors allocated for packets
*                                      forwarded to the egress analyzer port due to
*                                      mirroring.
*                                      For xCat3: range 0..0x3FFF
*                                      For Lion: range 0..0xFFFF
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out of range value
*/
static GT_STATUS internal_cpssDxChPortTxSniffedPcktDescrLimitSet
(
    IN    GT_U8                  devNum,
    IN    GT_U32                 rxSniffMaxDescNum,
    IN    GT_U32                 txSniffMaxDescNum
)
{
    GT_U32      regAddr;        /* register address     */
    GT_U32      rxOffset;       /* ingress field offset */
    GT_U32      len;            /* all fields len       */
    GT_U32      maxRxDescVal;   /* the maximum allowed ingress descriptors value */
    GT_U32      maxTxDescVal;   /* the maximum allowed egress descriptors value  */
    GT_U32      value;          /* value to write into register     */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if(rxSniffMaxDescNum >= BIT_16 ||
            txSniffMaxDescNum >= BIT_16)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.mcFilterLimits.mirroredPktsToAnalyzerPortDescsLimit;
        len = 32;
        value = rxSniffMaxDescNum | (txSniffMaxDescNum << 16);
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        /* xCat3 */
        maxRxDescVal = PRV_CPSS_DXCH3_INGRESS_MIRR_2_ANLY_DESC_MAX_CNS;
        maxTxDescVal = PRV_CPSS_DXCH3_EGRESS_MIRR_2_ANLY_DESC_MAX_CNS;
        rxOffset     = PRV_CPSS_DXCH3_INGRESS_MIRR_2_ANLY_DESC_MAX_OFFSET_CNS;
        len          = PRV_CPSS_DXCH3_MIRR_2_ANLY_DESC_MAX_PARAM_LEN_CNS;

        if ( (rxSniffMaxDescNum > maxRxDescVal) || (txSniffMaxDescNum > maxTxDescVal) )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.sniffTailDropCfgReg;

        value = txSniffMaxDescNum | (rxSniffMaxDescNum << rxOffset);
    }
    else
    {
        if(rxSniffMaxDescNum >= BIT_16 ||
            txSniffMaxDescNum >= BIT_16)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        len = 32;

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
            mcFilterLimits.mirroredPacketsToAnalyzerPortDescriptorsLimit;

        value = rxSniffMaxDescNum | (txSniffMaxDescNum << 16);
    }

    /* Set the number of descriptors allocated for packets forwarded
    to the ingress analyzer port and egress analyzer port due to mirroring. */
    return prvCpssHwPpSetRegField(devNum, regAddr, 0, len, value);
}

/**
* @internal cpssDxChPortTxSniffedPcktDescrLimitSet function
* @endinternal
*
* @brief   Set maximal descriptors limits for mirrored packets.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] rxSniffMaxDescNum        - The number of descriptors allocated for packets
*                                      forwarded to the ingress analyzer port due to
*                                      mirroring.
*                                      For xCat3: range 0..0x3FFF
*                                      For Lion: range 0..0xFFFF
* @param[in] txSniffMaxDescNum        - The number of descriptors allocated for packets
*                                      forwarded to the egress analyzer port due to
*                                      mirroring.
*                                      For xCat3: range 0..0x3FFF
*                                      For Lion: range 0..0xFFFF
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out of range value
*/
GT_STATUS cpssDxChPortTxSniffedPcktDescrLimitSet
(
    IN    GT_U8                  devNum,
    IN    GT_U32                 rxSniffMaxDescNum,
    IN    GT_U32                 txSniffMaxDescNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSniffedPcktDescrLimitSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, rxSniffMaxDescNum, txSniffMaxDescNum));

    rc = internal_cpssDxChPortTxSniffedPcktDescrLimitSet(devNum, rxSniffMaxDescNum, txSniffMaxDescNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, rxSniffMaxDescNum, txSniffMaxDescNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSniffedPcktDescrLimitGet function
* @endinternal
*
* @brief   Get maximal descriptors limits for mirrored packets.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] rxSniffMaxDescNumPtr     - (pointer to) The number of descriptors allocated
*                                      for packets forwarded to the ingress analyzer
*                                      port due to mirroring.
* @param[out] txSniffMaxDescNumPtr     - (pointer to) The number of descriptors allocated
*                                      for packets forwarded to the egress analyzer
*                                      port due to mirroring.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSniffedPcktDescrLimitGet
(
    IN    GT_U8                  devNum,
    OUT   GT_U32                *rxSniffMaxDescNumPtr,
    OUT   GT_U32                *txSniffMaxDescNumPtr
)
{
    GT_U32      regAddr;        /* register address     */
    GT_U32      rxOffset;       /* ingress field offset */
    GT_U32      maxRxDescVal;   /* the maximum allowed ingress descriptors value */
    GT_U32      maxTxDescVal;   /* the maximum allowed egress descriptors value  */
    GT_U32      len;            /* all fields len       */
    GT_U32      value;          /* value to write into register     */
    GT_STATUS   rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(rxSniffMaxDescNumPtr);
    CPSS_NULL_PTR_CHECK_MAC(txSniffMaxDescNumPtr);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.mcFilterLimits.mirroredPktsToAnalyzerPortDescsLimit;
        maxRxDescVal = BIT_16-1;
        maxTxDescVal = BIT_16-1;
        rxOffset     = 0;
        len          = 32;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        /* xCat3 */
        maxRxDescVal = PRV_CPSS_DXCH3_INGRESS_MIRR_2_ANLY_DESC_MAX_CNS;
        maxTxDescVal = PRV_CPSS_DXCH3_EGRESS_MIRR_2_ANLY_DESC_MAX_CNS;
        rxOffset     = PRV_CPSS_DXCH3_INGRESS_MIRR_2_ANLY_DESC_MAX_OFFSET_CNS;
        len          = PRV_CPSS_DXCH3_MIRR_2_ANLY_DESC_MAX_PARAM_LEN_CNS;

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.sniffTailDropCfgReg;
    }
    else
    {
        maxRxDescVal = BIT_16-1;
        maxTxDescVal = BIT_16-1;
        rxOffset     = 0;
        len          = 32;

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
            mcFilterLimits.mirroredPacketsToAnalyzerPortDescriptorsLimit;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, len, &value);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        *txSniffMaxDescNumPtr = value & maxTxDescVal;
        *rxSniffMaxDescNumPtr = (value >> rxOffset) & maxRxDescVal;
    }
    else
    {
        *rxSniffMaxDescNumPtr = value & maxRxDescVal;
        *txSniffMaxDescNumPtr = (value >> 16) & maxTxDescVal;
    }


    return GT_OK;
}

/**
* @internal cpssDxChPortTxSniffedPcktDescrLimitGet function
* @endinternal
*
* @brief   Get maximal descriptors limits for mirrored packets.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] rxSniffMaxDescNumPtr     - (pointer to) The number of descriptors allocated
*                                      for packets forwarded to the ingress analyzer
*                                      port due to mirroring.
* @param[out] txSniffMaxDescNumPtr     - (pointer to) The number of descriptors allocated
*                                      for packets forwarded to the egress analyzer
*                                      port due to mirroring.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSniffedPcktDescrLimitGet
(
    IN    GT_U8                  devNum,
    OUT   GT_U32                *rxSniffMaxDescNumPtr,
    OUT   GT_U32                *txSniffMaxDescNumPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSniffedPcktDescrLimitGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, rxSniffMaxDescNumPtr, txSniffMaxDescNumPtr));

    rc = internal_cpssDxChPortTxSniffedPcktDescrLimitGet(devNum, rxSniffMaxDescNumPtr, txSniffMaxDescNumPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, rxSniffMaxDescNumPtr, txSniffMaxDescNumPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMcastPcktDescrLimitSet function
* @endinternal
*
* @brief   Set maximal descriptors limits for multicast packets.
*
* @note   APPLICABLE DEVICES:          xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] mcastMaxDescNum          - The number of descriptors allocated for multicast
*                                      packets.
*                                      For xCat3, AC5: in units of 512 descriptors, the actual number
*                                      descriptors allocated will be 512 mcastMaxDescNum.
*                                      For all other devices except Bobcat2, Caelum,Aldrin, AC3X:
*                                      in units of 128 descriptors, the actual number descriptors
*                                      allocated will be 128  mcastMaxDescNum.
*                                      For Bobcat2, Caelum, Aldrin, AC3X, Aldrin2: actual descriptors
*                                      number (granularity of 1).
*                                      For xCat3: range 0..0x3E00
*                                      For Bobcat2, Caelum, Aldrin, AC3X, Aldrin2: range 0..0xFFFF
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMcastPcktDescrLimitSet
(
    IN    GT_U8                  devNum,
    IN    GT_U32                 mcastMaxDescNum
)
{
    GT_U32      regAddr;    /* register address                 */
    GT_U32      offset;     /* field offset                     */
    GT_U32      len;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if ( mcastMaxDescNum >= BIT_16 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        len    = 16;
        offset = 0;

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.mcFilterLimits.mcDescsLimit;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        if (mcastMaxDescNum > PRV_CPSS_DXCH_MULTICAST_PCKTS_DESC_LIMIT_MAX_CNS)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* Set the number of descriptors allocated for multicast packets. */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfig;
        len    = 5;
        offset = 11;
    }
    else
    {
        if ( mcastMaxDescNum >= BIT_16 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
            mcFilterLimits.multicastDescriptorsLimit;
        len    = 16;
        offset = 0;
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, offset, len, mcastMaxDescNum);
}

/**
* @internal cpssDxChPortTxMcastPcktDescrLimitSet function
* @endinternal
*
* @brief   Set maximal descriptors limits for multicast packets.
*
* @note   APPLICABLE DEVICES:          xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] mcastMaxDescNum          - The number of descriptors allocated for multicast
*                                      packets.
*                                      For xCat3, AC5: in units of 512 descriptors, the actual number
*                                      descriptors allocated will be 512 mcastMaxDescNum.
*                                      For all other devices except Bobcat2, Caelum,Aldrin, AC3X:
*                                      in units of 128 descriptors, the actual number descriptors
*                                      allocated will be 128  mcastMaxDescNum.
*                                      For Bobcat2, Caelum, Aldrin, AC3X, Aldrin2: actual descriptors
*                                      number (granularity of 1).
*                                      For xCat3: range 0..0x3E00
*                                      For Bobcat2, Caelum, Aldrin, AC3X, Aldrin2: range 0..0xFFFF
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxMcastPcktDescrLimitSet
(
    IN    GT_U8                  devNum,
    IN    GT_U32                 mcastMaxDescNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcastPcktDescrLimitSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mcastMaxDescNum));

    rc = internal_cpssDxChPortTxMcastPcktDescrLimitSet(devNum, mcastMaxDescNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mcastMaxDescNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMcastPcktDescrLimitGet function
* @endinternal
*
* @brief   Get maximal descriptors limits for multicast packets.
*
* @note   APPLICABLE DEVICES:          xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] mcastMaxDescNumPtr     - (pointer to) number of descriptors allocated for multicast
*                                      packets.
*                                      For xCat3, AC5: in units of 512 descriptors, the actual number
*                                      descriptors allocated will be 512 mcastMaxDescNum.
*                                      For all other devices except Bobcat2, Caelum,Aldrin, AC3X:
*                                      in units of 128 descriptors, the actual number descriptors
*                                      allocated will be 128  mcastMaxDescNum.
*                                      For Bobcat2, Caelum, Aldrin, AC3X, Aldrin2: actual descriptors
*                                      number (granularity of 1).
*                                      For xCat3: range 0..0x3E00
*                                      For Bobcat2, Caelum, Aldrin, AC3X, Aldrin2: range 0..0xFFFF
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMcastPcktDescrLimitGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *mcastMaxDescNumPtr
)
{
    GT_U32      regAddr;    /* register address                 */
    GT_U32      offset;     /* field offset                     */
    GT_U32      len;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(mcastMaxDescNumPtr);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        len    = 16;
        offset = 0;

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.mcFilterLimits.mcDescsLimit;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        /* Get the number of descriptors allocated for multicast packets. */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfig;
        len    = 5;
        offset = 11;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
            mcFilterLimits.multicastDescriptorsLimit;
        len    = 16;
        offset = 0;
    }

    return prvCpssHwPpGetRegField(devNum, regAddr, offset, len, mcastMaxDescNumPtr);
}

/**
* @internal cpssDxChPortTxMcastPcktDescrLimitGet function
* @endinternal
*
* @brief   Get maximal descriptors limits for multicast packets.
*
* @note   APPLICABLE DEVICES:          xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] mcastMaxDescNumPtr     - (pointer to) number of descriptors allocated for multicast
*                                      packets.
*                                      For xCat3, AC5: in units of 512 descriptors, the actual number
*                                      descriptors allocated will be 512 mcastMaxDescNum.
*                                      For all other devices except Bobcat2, Caelum,Aldrin, AC3X:
*                                      in units of 128 descriptors, the actual number descriptors
*                                      allocated will be 128  mcastMaxDescNum.
*                                      For Bobcat2, Caelum, Aldrin, AC3X, Aldrin2: actual descriptors
*                                      number (granularity of 1).
*                                      For xCat3: range 0..0x3E00
*                                      For Bobcat2, Caelum, Aldrin, AC3X, Aldrin2: range 0..0xFFFF
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxMcastPcktDescrLimitGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *mcastMaxDescNumPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcastPcktDescrLimitGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mcastMaxDescNumPtr));

    rc = internal_cpssDxChPortTxMcastPcktDescrLimitGet(devNum, mcastMaxDescNumPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mcastMaxDescNumPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxWrrGlobalParamSet function
* @endinternal
*
* @brief   Set global parameters for WRR scheduler.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] wrrMode                  - Transmit Scheduler count mode.
*                                  (APPLICABLE DEVICES xCat3; AC5; Lion2.)
* @param[in] wrrMtu                   - MTU for DSWRR, resolution of WRR weights for byte based
*                                      Transmit Scheduler count mode.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPortTxWrrGlobalParamSet
(
    IN    GT_U8                     devNum,
    IN    CPSS_PORT_TX_WRR_MODE_ENT wrrMode,
    IN    CPSS_PORT_TX_WRR_MTU_ENT  wrrMtu
)
{
    GT_U32      regAddr;    /* register address                 */
    GT_U32      offset;     /* field offset                     */
    GT_U32      len;
    GT_U32      wrrModeValue;
    GT_U32      wrrMtuValue;
    GT_U32      value = 0;
    GT_U32      mask;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    switch (wrrMode)
    {
    case CPSS_PORT_TX_WRR_BYTE_MODE_E:
        wrrModeValue = 1;
        break;
    case CPSS_PORT_TX_WRR_PACKET_MODE_E:
        wrrModeValue = 0;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.schedulerConfig.schedulerConfig;

        switch (wrrMtu)
        {
        case CPSS_PORT_TX_WRR_MTU_2K_E:
            wrrMtuValue = 5;
            break;
        case CPSS_PORT_TX_WRR_MTU_8K_E:
            wrrMtuValue = 7;
            break;
        case CPSS_PORT_TX_WRR_MTU_256_E:
            wrrMtuValue = 2;
            break;
        case CPSS_PORT_TX_WRR_MTU_64_E:
            wrrMtuValue = 0;
            break;
        case CPSS_PORT_TX_WRR_MTU_128_E:
            wrrMtuValue = 1;
            break;
        case CPSS_PORT_TX_WRR_MTU_512_E:
            wrrMtuValue = 3;
            break;
        case CPSS_PORT_TX_WRR_MTU_1K_E:
            wrrMtuValue = 4;
            break;
        case CPSS_PORT_TX_WRR_MTU_4K_E:
            wrrMtuValue = 6;
            break;
        case CPSS_PORT_TX_WRR_MTU_16K_E:
            wrrMtuValue = 8;
            break;
        case CPSS_PORT_TX_WRR_MTU_32K_E:
            wrrMtuValue = 9;
            break;
        case CPSS_PORT_TX_WRR_MTU_64K_E:
            wrrMtuValue = 10;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        U32_SET_FIELD_MAC(value, 2,  4, wrrMtuValue);
        mask = FIELD_MASK_MAC(2, 4);
        if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            mask |= FIELD_MASK_MAC(26, 4);
            U32_SET_FIELD_MAC(value, 26, 4, wrrMtuValue);
        }

        return prvCpssHwPpWriteRegBitMask(devNum, regAddr, mask, value);

    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        switch (wrrMtu)
        {
        case CPSS_PORT_TX_WRR_MTU_2K_E:
            wrrMtuValue = 0;
            break;
        case CPSS_PORT_TX_WRR_MTU_8K_E:
            wrrMtuValue = 1;
            break;
        case CPSS_PORT_TX_WRR_MTU_256_E:
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* Set global parameters for WRR scheduler. */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfigExt;

        offset = 1;
        len = 2;

        value = wrrModeValue | (wrrMtuValue << 1);

        return prvCpssHwPpSetRegField(devNum,regAddr,offset,len,value);
    }
    else
    {
        switch (wrrMtu)
        {
        case CPSS_PORT_TX_WRR_MTU_2K_E:
            wrrMtuValue = 5;
            break;
        case CPSS_PORT_TX_WRR_MTU_8K_E:
            wrrMtuValue = 7;
            break;
        case CPSS_PORT_TX_WRR_MTU_256_E:
            wrrMtuValue = 2;
            break;
        case CPSS_PORT_TX_WRR_MTU_64_E:
            wrrMtuValue = 0;
            break;
        case CPSS_PORT_TX_WRR_MTU_128_E:
            wrrMtuValue = 1;
            break;
        case CPSS_PORT_TX_WRR_MTU_512_E:
            wrrMtuValue = 3;
            break;
        case CPSS_PORT_TX_WRR_MTU_1K_E:
            wrrMtuValue = 4;
            break;
        case CPSS_PORT_TX_WRR_MTU_4K_E:
            wrrMtuValue = 6;
            break;
        case CPSS_PORT_TX_WRR_MTU_16K_E:
            wrrMtuValue = 8;
            break;
        case CPSS_PORT_TX_WRR_MTU_32K_E:
            wrrMtuValue = 9;
            break;
        case CPSS_PORT_TX_WRR_MTU_64K_E:
            wrrMtuValue = 10;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.scheduler.config.config;
        offset = 1;
        len = 5;

        value = wrrModeValue | (wrrMtuValue << 1);

        return prvCpssHwPpSetRegField(devNum,regAddr,offset,len,value);
    }
}

/**
* @internal cpssDxChPortTxWrrGlobalParamSet function
* @endinternal
*
* @brief   Set global parameters for WRR scheduler.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] wrrMode                  - Transmit Scheduler count mode.
*                                  (APPLICABLE DEVICES xCat3; AC5; Lion2.)
* @param[in] wrrMtu                   - MTU for DSWRR, resolution of WRR weights for byte based
*                                      Transmit Scheduler count mode.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPortTxWrrGlobalParamSet
(
    IN    GT_U8                     devNum,
    IN    CPSS_PORT_TX_WRR_MODE_ENT wrrMode,
    IN    CPSS_PORT_TX_WRR_MTU_ENT  wrrMtu
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxWrrGlobalParamSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, wrrMode, wrrMtu));

    rc = internal_cpssDxChPortTxWrrGlobalParamSet(devNum, wrrMode, wrrMtu);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, wrrMode, wrrMtu));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxWrrGlobalParamGet function
* @endinternal
*
* @brief   Get global parameters for WRR scheduler.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] wrrModePtr               - (pointer to) Transmit Scheduler count mode.
* @param[out] wrrMtuPtr                - (pointer to) MTU for DSWRR, resolution of WRR weights
*                                      for byte based Transmit Scheduler count mode.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*/
static GT_STATUS internal_cpssDxChPortTxWrrGlobalParamGet
(
    IN    GT_U8                      devNum,
    OUT   CPSS_PORT_TX_WRR_MODE_ENT *wrrModePtr,
    OUT   CPSS_PORT_TX_WRR_MTU_ENT  *wrrMtuPtr
)
{
    GT_STATUS   rc;         /* return value         */
    GT_U32      regAddr;    /* register address     */
    GT_U32      value;      /* register field value */
    GT_U32      len;        /* register field lenght */
    GT_U32      offset;     /* register field offset */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(wrrModePtr);
    CPSS_NULL_PTR_CHECK_MAC(wrrMtuPtr);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.schedulerConfig.schedulerConfig;
        offset = 2;
        len = 4;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, len, &value);
        if(rc != GT_OK)
        {
            return rc;
        }

        switch (value)
        {
        case 5:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_2K_E;
            break;
        case 7:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_8K_E;
            break;
        case 2:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_256_E;
            break;
        case 0:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_64_E;
            break;
        case 1:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_128_E;
            break;
        case 3:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_512_E;
            break;
        case 4:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_1K_E;
            break;
        case 6:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_4K_E;
            break;
        case 8:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_16K_E;
            break;
        case 9:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_32K_E;
            break;
        case 10:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_64K_E;
            break;
        }
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfigExt;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 1, 2, &value);
        if (rc != GT_OK)
            return rc;

        *wrrModePtr = (value & 0x1) ?  CPSS_PORT_TX_WRR_BYTE_MODE_E :
            CPSS_PORT_TX_WRR_PACKET_MODE_E ;
        *wrrMtuPtr = ((value >> 1) & 0x1) ? CPSS_PORT_TX_WRR_MTU_8K_E :
            CPSS_PORT_TX_WRR_MTU_2K_E;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.scheduler.config.config;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 1, 5, &value);
        if (rc != GT_OK)
            return rc;

        *wrrModePtr = (value & 0x1) ?  CPSS_PORT_TX_WRR_BYTE_MODE_E :
            CPSS_PORT_TX_WRR_PACKET_MODE_E ;
        switch (value >> 1)
        {
        case 5:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_2K_E;
            break;
        case 7:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_8K_E;
            break;
        case 2:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_256_E;
            break;
        case 0:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_64_E;
            break;
        case 1:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_128_E;
            break;
        case 3:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_512_E;
            break;
        case 4:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_1K_E;
            break;
        case 6:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_4K_E;
            break;
        case 8:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_16K_E;
            break;
        case 9:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_32K_E;
            break;
        case 10:
            *wrrMtuPtr = CPSS_PORT_TX_WRR_MTU_64K_E;
            break;
        }
    }
    return GT_OK;
}

/**
* @internal cpssDxChPortTxWrrGlobalParamGet function
* @endinternal
*
* @brief   Get global parameters for WRR scheduler.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] wrrModePtr               - (pointer to) Transmit Scheduler count mode.
* @param[out] wrrMtuPtr                - (pointer to) MTU for DSWRR, resolution of WRR weights
*                                      for byte based Transmit Scheduler count mode.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*/
GT_STATUS cpssDxChPortTxWrrGlobalParamGet
(
    IN    GT_U8                      devNum,
    OUT   CPSS_PORT_TX_WRR_MODE_ENT *wrrModePtr,
    OUT   CPSS_PORT_TX_WRR_MTU_ENT  *wrrMtuPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxWrrGlobalParamGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, wrrModePtr, wrrMtuPtr));

    rc = internal_cpssDxChPortTxWrrGlobalParamGet(devNum, wrrModePtr, wrrMtuPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, wrrModePtr, wrrMtuPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperGlobalParamsSet function
* @endinternal
*
* @brief   Set Global parameters for shaper.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] xgPortsTokensRate        - tokens rate for XG ports' shapers (1..15)
* @param[in] gigPortsTokensRate       - tokens rate for Tri Speed ports' shapers.(1..15)
* @param[in] gigPortsSlowRateRatio    - slow rate ratio for Tri Speed ports.
*                                      Tokens Update rate for ports with slow rate
*                                      divided to the ratio. (1..16)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxShaperGlobalParamsSet
(
    IN    GT_U8                   devNum,
    IN    GT_U32                  xgPortsTokensRate,
    IN    GT_U32                  gigPortsTokensRate,
    IN    GT_U32                  gigPortsSlowRateRatio
)
{
    GT_U32      regAddr;    /* register address                 */
    GT_U32      offset;     /* field offset                     */
    GT_U32      len;
    GT_U32      value;      /* value to write into register     */
    GT_PHYSICAL_PORT_NUM       port;
    GT_U32      tcQueue = 0;
    GT_U32      old_xgPortsTokensRate;
    GT_U32      old_gigPortsTokensRate;
    GT_U32      old_gigPortsSlowRateRatio;
    GT_STATUS   rc;
    GT_BOOL     stackAsGig = GT_FALSE;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if ( (xgPortsTokensRate < PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_MIN_CNS) ||
    (xgPortsTokensRate > PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_MAX_CNS) ||
    (gigPortsTokensRate < PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_MIN_CNS) ||
    (gigPortsTokensRate > PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_MAX_CNS) ||
    (gigPortsSlowRateRatio < PRV_CPSS_DXCH_GIG_SLOW_TOKEN_BCKT_UPD_RATIO_MIN_CNS) ||
    (gigPortsSlowRateRatio > PRV_CPSS_DXCH_GIG_SLOW_TOKEN_BCKT_UPD_RATIO_MAX_CNS) )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* Set global parameters for shaper. */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQMcFifoEccConfig;

    offset = PRV_CPSS_DXCH_GIG_SLOW_TOKEN_BCKT_UPD_RATIO_OFFSET_CNS;
    len = PRV_CPSS_DXCH_GIG_SLOW_TOKEN_BCKT_UPD_RATIO_LEN_CNS +
        PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_LEN_CNS +
        PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_LEN_CNS; /* =12 */

    if (prvCpssHwPpGetRegField(devNum, regAddr, offset, len, &value) != GT_OK)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

    old_gigPortsSlowRateRatio = (value & 0xF) + 1;
    old_gigPortsTokensRate = (value >>
    (PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_OFFSET_CNS - offset)) &
        0xF;
    old_xgPortsTokensRate = (value >>
    (PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_OFFSET_CNS - offset)) &
        0xF;

    value = (gigPortsSlowRateRatio - 1) |
    ((gigPortsTokensRate & 0xF) <<
    (PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_OFFSET_CNS - offset)) |
    ((xgPortsTokensRate & 0xF) <<
    (PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_OFFSET_CNS - offset));

    if (prvCpssHwPpSetRegField(devNum, regAddr, offset, len, value) != GT_OK)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

    /* check if StackAsGig mode enabled */
    if (PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        rc = cpssDxChPortTxShaperOnStackAsGigEnableGet(devNum,&stackAsGig);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* Reconfigure all enabled Token Buckets per port and per port per queue. */
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    for (port = 0; port < PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
    {
        if (! PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, port))
            continue;

        /* per port */
        rc = prvDxChPortTxSetShaperTokenBucketParams(
            devNum,
            port,
            GT_FALSE,
            tcQueue,
            old_xgPortsTokensRate,
            old_gigPortsTokensRate,
            old_gigPortsSlowRateRatio,
            stackAsGig,
            xgPortsTokensRate,
            gigPortsTokensRate,
            gigPortsSlowRateRatio,
            stackAsGig);

        if (rc != GT_OK)
        {
            return rc;
        }

        /* per port per traffic class (tcQueue) */
        for (tcQueue = 0; tcQueue < CPSS_TC_RANGE_CNS; tcQueue++)
        {
            rc = prvDxChPortTxSetShaperTokenBucketParams(
                devNum,
                port,
                GT_TRUE,
                tcQueue,
                old_xgPortsTokensRate,
                old_gigPortsTokensRate,
                old_gigPortsSlowRateRatio,
                stackAsGig,
                xgPortsTokensRate,
                gigPortsTokensRate,
                gigPortsSlowRateRatio,
                stackAsGig);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /* for CPU port */
    port = CPSS_CPU_PORT_NUM_CNS;
    rc = prvDxChPortTxSetShaperTokenBucketParams(
        devNum,
        port,
        GT_FALSE,
        tcQueue,
        old_xgPortsTokensRate,
        old_gigPortsTokensRate,
        old_gigPortsSlowRateRatio,
        stackAsGig,
        xgPortsTokensRate,
        gigPortsTokensRate,
        gigPortsSlowRateRatio,
        stackAsGig);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* CPU port per traffic class (tcQueue) */
    for (tcQueue = 0; tcQueue < CPSS_TC_RANGE_CNS; tcQueue++)
    {
        rc = prvDxChPortTxSetShaperTokenBucketParams(
            devNum,
            port,
            GT_TRUE,
            tcQueue,
            old_xgPortsTokensRate,
            old_gigPortsTokensRate,
            old_gigPortsSlowRateRatio,
            stackAsGig,
            xgPortsTokensRate,
            gigPortsTokensRate,
            gigPortsSlowRateRatio,
            stackAsGig);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxShaperGlobalParamsSet function
* @endinternal
*
* @brief   Set Global parameters for shaper.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] xgPortsTokensRate        - tokens rate for XG ports' shapers (1..15)
* @param[in] gigPortsTokensRate       - tokens rate for Tri Speed ports' shapers.(1..15)
* @param[in] gigPortsSlowRateRatio    - slow rate ratio for Tri Speed ports.
*                                      Tokens Update rate for ports with slow rate
*                                      divided to the ratio. (1..16)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxShaperGlobalParamsSet
(
    IN    GT_U8                   devNum,
    IN    GT_U32                  xgPortsTokensRate,
    IN    GT_U32                  gigPortsTokensRate,
    IN    GT_U32                  gigPortsSlowRateRatio
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperGlobalParamsSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, xgPortsTokensRate, gigPortsTokensRate, gigPortsSlowRateRatio));

    rc = internal_cpssDxChPortTxShaperGlobalParamsSet(devNum, xgPortsTokensRate, gigPortsTokensRate, gigPortsSlowRateRatio);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, xgPortsTokensRate, gigPortsTokensRate, gigPortsSlowRateRatio));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperGlobalParamsGet function
* @endinternal
*
* @brief   Get Global parameters for shaper.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number
*
* @param[out] xgPortsTokensRatePtr     - (pointer to) tokens rate for XG ports' shapers
* @param[out] gigPortsTokensRatePtr    - (pointer to) tokens rate for Tri Speed ports' shapers
* @param[out] gigPortsSlowRateRatioPtr - (pointer to) slow rate ratio for Tri Speed ports.
*                                      Tokens Update rate for ports with slow rate divided
*                                      to the ratio.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on illegal parameter
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxShaperGlobalParamsGet
(
    IN    GT_U8          devNum,
    OUT   GT_U32         *xgPortsTokensRatePtr,
    OUT   GT_U32         *gigPortsTokensRatePtr,
    OUT   GT_U32         *gigPortsSlowRateRatioPtr
)
{
    GT_U32  regAddr;    /* register address */
    GT_U32  regData;    /* register data    */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(xgPortsTokensRatePtr);
    CPSS_NULL_PTR_CHECK_MAC(gigPortsTokensRatePtr);
    CPSS_NULL_PTR_CHECK_MAC(gigPortsSlowRateRatioPtr);


    /* Set global parameters for shaper. */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQMcFifoEccConfig;


    if (prvCpssHwPpReadRegister(devNum, regAddr, &regData) != GT_OK)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

    *xgPortsTokensRatePtr = U32_GET_FIELD_MAC(regData,
        PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_OFFSET_CNS,
        PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_LEN_CNS);

    *gigPortsTokensRatePtr = U32_GET_FIELD_MAC(regData,
        PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_OFFSET_CNS,
        PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_LEN_CNS);

    *gigPortsSlowRateRatioPtr = U32_GET_FIELD_MAC(regData,
        PRV_CPSS_DXCH_GIG_SLOW_TOKEN_BCKT_UPD_RATIO_OFFSET_CNS,
        PRV_CPSS_DXCH_GIG_SLOW_TOKEN_BCKT_UPD_RATIO_LEN_CNS) + 1;

    if ( *xgPortsTokensRatePtr < PRV_CPSS_DXCH_XG_TOKEN_BCKT_UPD_RATE_MIN_CNS)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    if(*gigPortsTokensRatePtr < PRV_CPSS_DXCH_GIG_TOKEN_BCKT_UPD_RATE_MIN_CNS)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxShaperGlobalParamsGet function
* @endinternal
*
* @brief   Get Global parameters for shaper.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number
*
* @param[out] xgPortsTokensRatePtr     - (pointer to) tokens rate for XG ports' shapers
* @param[out] gigPortsTokensRatePtr    - (pointer to) tokens rate for Tri Speed ports' shapers
* @param[out] gigPortsSlowRateRatioPtr - (pointer to) slow rate ratio for Tri Speed ports.
*                                      Tokens Update rate for ports with slow rate divided
*                                      to the ratio.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on illegal parameter
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxShaperGlobalParamsGet
(
    IN    GT_U8          devNum,
    OUT   GT_U32         *xgPortsTokensRatePtr,
    OUT   GT_U32         *gigPortsTokensRatePtr,
    OUT   GT_U32         *gigPortsSlowRateRatioPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperGlobalParamsGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, xgPortsTokensRatePtr, gigPortsTokensRatePtr, gigPortsSlowRateRatioPtr));

    rc = internal_cpssDxChPortTxShaperGlobalParamsGet(devNum, xgPortsTokensRatePtr, gigPortsTokensRatePtr, gigPortsSlowRateRatioPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, xgPortsTokensRatePtr, gigPortsTokensRatePtr, gigPortsSlowRateRatioPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal updateSchedVarTriggerBitWaitAndSet function
* @endinternal
*
* @brief   wait for <UpdateSchedVarTrigger> to be ready for triggering , and when
*         ready --> trigger new action.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - previous updated operation not yet completed
*/
static GT_STATUS    updateSchedVarTriggerBitWaitAndSet(
    IN  GT_U8  devNum
)
{
    GT_U32      regAddr;    /* register address                 */
    GT_U32      updateSchedVarTriggerBit;/*bit of <UpdateSchedVarTrigger>*/
    GT_STATUS   rc;


    PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.schedulerConfig.schedulerConfig;
        updateSchedVarTriggerBit = 6;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        updateSchedVarTriggerBit = 4;
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfig;
    }
    else
    {
        updateSchedVarTriggerBit = 6;
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.scheduler.config.config;
    }

    /* Each of the the scheduling parameters need to be set by the <UpdateSchedVarTrigger> */
    /* in the Transmit Queue Control Register in order to take effect. */

    /* wait for bit <UpdateSchedVarTrigger> to clear */
    rc = prvCpssPortGroupBusyWait(devNum,CPSS_PORT_GROUP_UNAWARE_MODE_CNS,regAddr,updateSchedVarTriggerBit,GT_FALSE);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* 'Trigger the new setting' */
    return prvCpssHwPpSetRegField(devNum, regAddr, updateSchedVarTriggerBit, 1, 1);
}

/**
* @internal internal_cpssDxChPortTxQWrrProfileSet function
* @endinternal
*
* @brief   Set Weighted Round Robin profile on the specified port's
*         Traffic Class Queue.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue on this Port (0..7) Falcon (0..15)
* @param[in] wrrWeight                - proportion of bandwidth assigned to this queue
*                                      relative to the other queues in this
*                                      Arbitration Group - resolution is 1/255.
* @param[in] profileSet               - the Tx Queue scheduler Profile Set in which the wrrWeight
*                                      Parameter is associated.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - previous updated operation not yet completed
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note - if weight will be less than port's MTU (maximum transmit unit) there
*       is possibility for empty WRR loops for given TC queue, but to not
*       tight user and for future ASIC's where this problem will be solved
*       check of wrrWeight 256 > MTU not implemented
*       - There is errata for Cheetah FEr#29. weigh cannot be = 255 for some
*       modes. The functions limits weight accordingly.
*
*/
static GT_STATUS internal_cpssDxChPortTxQWrrProfileSet
(
    IN  GT_U8                                   devNum,
    IN  GT_U8                                   tcQueue,
    IN  GT_U8                                   wrrWeight,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet
)
{
    GT_U32      value;      /* value to write into register     */
    GT_U32      regAddr;    /* register address                 */
    GT_U32      offset;     /* register field offset */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_SCHEDULER_PROFILE_CHECK_MAC(profileSet, devNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    PRV_CPSS_DXCH_SCHEDULER_WRR_CHECK_MAC(wrrWeight);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssFalconTxqUtilsWrrProfileSet(devNum,tcQueue,wrrWeight,profileSet);
    }

    value = wrrWeight;

    if (tcQueue < 4)
    {
        PRV_CPSS_DXCH_PORT_WRR_WEIGHTS_0_REG_MAC(devNum,profileSet,&regAddr);
        offset = tcQueue << 3;
    }
    else
    {
        PRV_CPSS_DXCH_PORT_WRR_WEIGHTS_1_REG_MAC(devNum,profileSet,&regAddr);
        offset = (tcQueue - 4) << 3;
    }

    if(prvCpssHwPpSetRegField(devNum, regAddr, offset, 8, value) != GT_OK)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

    /* Each of the the scheduling parameters need to be set by the <UpdateSchedVarTrigger> */
    /* in the Transmit Queue Control Register in order to take effect. */

    /* For Lion2/3 it is not needed to configer trigger */
    if(PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_LION2_SCHEDULER_PROFILE_UNDER_TRAFFIC_WA_E))
    {
        return GT_OK;
    }
    else
    {
        return updateSchedVarTriggerBitWaitAndSet(devNum);
    }
}

/**
* @internal cpssDxChPortTxQWrrProfileSet function
* @endinternal
*
* @brief   Set Weighted Round Robin profile on the specified port's
*         Traffic Class Queue.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue on this Port (0..7) Falcon (0..15)
* @param[in] wrrWeight                - proportion of bandwidth assigned to this queue
*                                      relative to the other queues in this
*                                      Arbitration Group - resolution is 1/255.
* @param[in] profileSet               - the Tx Queue scheduler Profile Set in which the wrrWeight
*                                      Parameter is associated.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - previous updated operation not yet completed
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note - if weight will be less than port's MTU (maximum transmit unit) there
*       is possibility for empty WRR loops for given TC queue, but to not
*       tight user and for future ASIC's where this problem will be solved
*       check of wrrWeight 256 > MTU not implemented
*       - There is errata for Cheetah FEr#29. weigh cannot be = 255 for some
*       modes. The functions limits weight accordingly.
*
*/
GT_STATUS cpssDxChPortTxQWrrProfileSet
(
    IN  GT_U8                                   devNum,
    IN  GT_U8                                   tcQueue,
    IN  GT_U8                                   wrrWeight,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQWrrProfileSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcQueue, wrrWeight, profileSet));

    rc = internal_cpssDxChPortTxQWrrProfileSet(devNum, tcQueue, wrrWeight, profileSet);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcQueue, wrrWeight, profileSet));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQWrrProfileGet function
* @endinternal
*
* @brief   Get Weighted Round Robin profile on the specified port's
*         Traffic Class Queue.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.

* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue on this Port (0..7) Falcon (0..15)
* @param[in] profileSet               - the Tx Queue scheduler Profile Set in which the wrrWeight
*                                      Parameter is associated.
*
* @param[out] wrrWeightPtr             - Pointer to proportion of bandwidth assigned to this queue
*                                      relative to the other queues in this
*                                      Arbitration Group - resolution is 1/255.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - previous updated operation not yet completed
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQWrrProfileGet
(
    IN  GT_U8                                   devNum,
    IN  GT_U8                                   tcQueue,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet,
    OUT  GT_U8                                  *wrrWeightPtr
)
{
    GT_U32      regAddr;      /* register address */
    GT_U32      offset;       /* register field offset */
    GT_U32      fieldValue;   /* register field value */
    GT_STATUS   rc;           /* return status */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_SCHEDULER_PROFILE_CHECK_MAC(profileSet, devNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    CPSS_NULL_PTR_CHECK_MAC(wrrWeightPtr);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssFalconTxqUtilsWrrProfileGet(devNum,tcQueue,profileSet,wrrWeightPtr);
    }


    if (tcQueue < 4)
    {
        PRV_CPSS_DXCH_PORT_WRR_WEIGHTS_0_REG_MAC(devNum,profileSet,&regAddr);
        offset = tcQueue << 3;
    }
    else
    {
        PRV_CPSS_DXCH_PORT_WRR_WEIGHTS_1_REG_MAC(devNum,profileSet,&regAddr);
        offset = (tcQueue - 4) << 3;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 8, &fieldValue);
    if(rc != GT_OK)
    {
        return rc;
    }

    *wrrWeightPtr = (GT_U8)fieldValue;

    return GT_OK;
}

/**
* @internal cpssDxChPortTxQWrrProfileGet function
* @endinternal
*
* @brief   Get Weighted Round Robin profile on the specified port's
*         Traffic Class Queue.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue on this Port (0..7) Falcon (0..15)
* @param[in] profileSet               - the Tx Queue scheduler Profile Set in which the wrrWeight
*                                      Parameter is associated.
*
* @param[out] wrrWeightPtr             - Pointer to proportion of bandwidth assigned to this queue
*                                      relative to the other queues in this
*                                      Arbitration Group - resolution is 1/255.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - previous updated operation not yet completed
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQWrrProfileGet
(
    IN  GT_U8                                   devNum,
    IN  GT_U8                                   tcQueue,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet,
    OUT  GT_U8                                  *wrrWeightPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQWrrProfileGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcQueue, profileSet, wrrWeightPtr));

    rc = internal_cpssDxChPortTxQWrrProfileGet(devNum, tcQueue, profileSet, wrrWeightPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcQueue, profileSet, wrrWeightPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQArbGroupSet function
* @endinternal
*
* @brief   Set Traffic Class Queue scheduling arbitration group on
*         specificed profile of specified device.
*
* @note   APPLICABLE DEVICES:     xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue  Falcon (0..15 ) ,else (0..7)
* @param[in] arbGroup                 - scheduling arbitration group:
*                                      1) Strict Priority
*                                      2) WRR Group 1
*                                      3) WRR Group 0
* @param[in] profileSet               - the Tx Queue scheduler Profile Set in which the arbGroup
*                                      parameter is associated.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong profile number, device or arbGroup
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - previous updated operation not yet completed
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQArbGroupSet
(
    IN  GT_U8                                   devNum,
    IN  GT_U8                                   tcQueue,
    IN  CPSS_PORT_TX_Q_ARB_GROUP_ENT            arbGroup,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet
)
{
    GT_U32      wrrEn  = 0;   /* WRR arbitration group enable     */
    GT_U32      wrrGrp = 0;   /* WRR arbitration group            */
    GT_U32      regAddr;      /* register address                 */
    GT_U32      offset;       /* register field offset */
    GT_U32      fieldLength;  /* register field offset */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_SCHEDULER_PROFILE_CHECK_MAC(profileSet, devNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);

    switch (arbGroup)
    {
    case CPSS_PORT_TX_WRR_ARB_GROUP_0_E:
        wrrEn = 1;
        wrrGrp = 0;
        break;
    case CPSS_PORT_TX_WRR_ARB_GROUP_1_E:
        wrrEn = 1;
        wrrGrp = 1;
        break;
    case CPSS_PORT_TX_SP_ARB_GROUP_E:
        wrrEn = 0;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssFalconTxqUtilsArbGroupSet(devNum,tcQueue,arbGroup,profileSet);
    }

    PRV_CPSS_DXCH_PORT_WRR_STRICT_PRIO_EN_REG_MAC(devNum,profileSet,&regAddr);

    offset = tcQueue;
    fieldLength = 1;

    if (prvCpssHwPpSetRegField(devNum, regAddr, offset, fieldLength, wrrEn) != GT_OK)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

    if ( arbGroup != CPSS_PORT_TX_SP_ARB_GROUP_E)
    {
        PRV_CPSS_DXCH_PORT_WRR_STRICT_PRIO_REG_MAC(devNum,profileSet,&regAddr);

        if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            offset = tcQueue + 8;
        }
        else
        {
            offset = tcQueue;
        }

        fieldLength = 1;

        if (prvCpssHwPpSetRegField(devNum, regAddr, offset, fieldLength, wrrGrp) != GT_OK)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    /* Each of the the scheduling parameters need to be set by the <UpdateSchedVarTrigger> */
    /* in the Transmit Queue Control Register in order to take effect. */

    /* For Lion2/3 it is not needed to configer trigger */
    if(PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_LION2_SCHEDULER_PROFILE_UNDER_TRAFFIC_WA_E))
    {
        return GT_OK;
    }
    else
    {
        return updateSchedVarTriggerBitWaitAndSet(devNum);
    }
}

/**
* @internal cpssDxChPortTxQArbGroupSet function
* @endinternal
*
* @brief   Set Traffic Class Queue scheduling arbitration group on
*         specificed profile of specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue  Falcon (0..15 ) ,else (0..7)
* @param[in] arbGroup                 - scheduling arbitration group:
*                                      1) Strict Priority
*                                      2) WRR Group 1
*                                      3) WRR Group 0
* @param[in] profileSet               - the Tx Queue scheduler Profile Set in which the arbGroup
*                                      parameter is associated.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong profile number, device or arbGroup
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - previous updated operation not yet completed
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQArbGroupSet
(
    IN  GT_U8                                   devNum,
    IN  GT_U8                                   tcQueue,
    IN  CPSS_PORT_TX_Q_ARB_GROUP_ENT            arbGroup,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQArbGroupSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcQueue, arbGroup, profileSet));

    rc = internal_cpssDxChPortTxQArbGroupSet(devNum, tcQueue, arbGroup, profileSet);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcQueue, arbGroup, profileSet));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQArbGroupGet function
* @endinternal
*
* @brief   Get Traffic Class Queue scheduling arbitration group on
*         specificed profile of specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.

* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue  Falcon (0..15 ) ,else (0..7)
* @param[in] profileSet               - the Tx Queue scheduler Profile Set in which the arbGroup
*                                      parameter is associated.
*
* @param[out] arbGroupPtr              - Pointer to scheduling arbitration group:
*                                      1) Strict Priority
*                                      2) WRR Group 1
*                                      3) WRR Group 0
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong profile number, device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQArbGroupGet
(
    IN  GT_U8                                   devNum,
    IN  GT_U8                                   tcQueue,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet,
    OUT CPSS_PORT_TX_Q_ARB_GROUP_ENT            *arbGroupPtr
)
{

    GT_STATUS   rc;           /* return status */
    GT_U32      wrrEn;        /* WRR arbitration group enable     */
    GT_U32      wrrGrp;       /* WRR arbitration group            */
    GT_U32      regAddr;      /* register address                 */
    GT_U32      offset;       /* register field offset */
    GT_U32      fieldLength;  /* register field length */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    PRV_CPSS_DXCH_SCHEDULER_PROFILE_CHECK_MAC(profileSet, devNum);
    CPSS_NULL_PTR_CHECK_MAC(arbGroupPtr);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssFalconTxqUtilsArbGroupGet(devNum,tcQueue,profileSet,arbGroupPtr);
    }

    PRV_CPSS_DXCH_PORT_WRR_STRICT_PRIO_EN_REG_MAC(devNum,profileSet,&regAddr);

    offset = tcQueue;
    fieldLength = 1;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, fieldLength, &wrrEn);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(wrrEn == 0)
    {
        *arbGroupPtr = CPSS_PORT_TX_SP_ARB_GROUP_E;
    }
    else
    {
        PRV_CPSS_DXCH_PORT_WRR_STRICT_PRIO_REG_MAC(devNum,profileSet,&regAddr);

        if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            offset = tcQueue + 8;
        }
        else
        {
            offset = tcQueue;
        }

        rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, fieldLength, &wrrGrp);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(wrrGrp == 1)
        {
            *arbGroupPtr = CPSS_PORT_TX_WRR_ARB_GROUP_1_E;
        }
        else
        {
            *arbGroupPtr = CPSS_PORT_TX_WRR_ARB_GROUP_0_E;
        }
    }

    return GT_OK;

}

/**
* @internal cpssDxChPortTxQArbGroupGet function
* @endinternal
*
* @brief   Get Traffic Class Queue scheduling arbitration group on
*         specificed profile of specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue  Falcon (0..15 ) ,else (0..7)
* @param[in] profileSet               - the Tx Queue scheduler Profile Set in which the arbGroup
*                                      parameter is associated.
*
* @param[out] arbGroupPtr              - Pointer to scheduling arbitration group:
*                                      1) Strict Priority
*                                      2) WRR Group 1
*                                      3) WRR Group 0
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong profile number, device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQArbGroupGet
(
    IN  GT_U8                                   devNum,
    IN  GT_U8                                   tcQueue,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet,
    OUT CPSS_PORT_TX_Q_ARB_GROUP_ENT            *arbGroupPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQArbGroupGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcQueue, profileSet, arbGroupPtr));

    rc = internal_cpssDxChPortTxQArbGroupGet(devNum, tcQueue, profileSet, arbGroupPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcQueue, profileSet, arbGroupPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChPortSip6TxBindPortToDpSet function
* @endinternal
*
* @brief   Bind a Physical Port to a specific Drop Profile Set.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; ..
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
*/

GT_STATUS prvCpssDxChPortSip6TxBindPortToDpSet
(
    IN  GT_U8                               devNum,
    IN  GT_PHYSICAL_PORT_NUM                portNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT   profileSet
)
{
    GT_STATUS rc;
    GT_U32 queueGroupIndex;
    GT_U32 registerIndex,registerOffset;

    /*Find queue group index*/
    rc = prvCpssDxChPortMappingEGFTargetLocalPhys2TxQPortBaseMapGet(devNum,0/*unused*/,portNum,&queueGroupIndex);
    if (GT_OK != rc )
    {
        return rc;
    }

    if(PRV_CPSS_DXCH_PORT_NUM_MAPPING_INVALID_PORT_CNS!=queueGroupIndex)
    {
        /*There are 8 queue group indexes per register*/
        registerIndex = queueGroupIndex>>3;
        registerOffset = queueGroupIndex&0x7;

        if(registerIndex >= PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.preqInfo.portMappingNum)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "registerIndex[%d] >= max [%d]",
                registerIndex,
                PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.preqInfo.portMappingNum);
        }
        return prvCpssHwPpSetRegField(devNum, PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).portMapping[registerIndex],
            registerOffset*4, 4, (GT_U32)profileSet);
    }

    /*the port does not have queues assigned*/
    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

}


/**
* @internal prvCpssDxChPortTxBindPortToDpSet function
* @endinternal
*
* @brief   Bind a Physical Port to a specific Drop Profile Set.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
*/
GT_STATUS prvCpssDxChPortTxBindPortToDpSet
(
    IN  GT_U8                               devNum,
    IN  GT_PHYSICAL_PORT_NUM                portNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT   profileSet
)
{
    GT_STATUS   rc;
    GT_U32      lowValue;   /* two lower bits of the value to write
                            into register */
    GT_U32      upperValue; /* upper bit of the value to write into register*/
    GT_U32      regAddr;    /* register address           */
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(profileSet, devNum);

    /*This function should not be used for sip 6*/
    PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);

    /* If Lion2 errata is initialized and portNum is not equal to 14 (hemispher 0) or
    to 64+14 (hemispher 1) then CPSS_PORT_TX_DROP_PROFILE_8_E is not legal */
    if((PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled == GT_TRUE)&&
    (portNum!=14) && (portNum!=78) && (profileSet==CPSS_PORT_TX_DROP_PROFILE_8_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    lowValue = profileSet;


    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);

        /* BC3 does not have such registers in TxQ LL unit */
        if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_LL_MAC(devNum).global.globalLLConfig.portProfile[txqPortNum];

            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 4, lowValue);
            if(GT_OK != rc)
            {
                return rc;
            }
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.portTailDropCNProfile[txqPortNum];

        return prvCpssHwPpSetRegField(devNum, regAddr, 0, 4, lowValue);
    }


    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_TXQ_REG_MAC(devNum,portNum,&regAddr);

        lowValue &= 0x3;

        /* set the two low bits of Drop Profile value */
        if (prvCpssHwPpPortGroupSetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr, 18, 2, lowValue) != GT_OK)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

        if (profileSet > CPSS_PORT_TX_DROP_PROFILE_4_E)
            upperValue = 1;
        else
            upperValue = 0;

        /* set the upper bit of the Drop Profile value - bit 25 */
        return prvCpssHwPpPortGroupSetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr, 25, 1, upperValue);
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.
            tailDrop.config.tailDropCnProfile[portNum];

        rc = prvCpssHwPpPortGroupSetRegField(devNum,
            PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr, 0, 3, lowValue);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChPortTxBindPortToDpSet function
* @endinternal
*
* @brief   Bind a Physical Port to a specific Drop Profile Set.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS internal_cpssDxChPortTxBindPortToDpSet
(
    IN  GT_U8                               devNum,
    IN  GT_PHYSICAL_PORT_NUM                portNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT   profileSet
)
{
    GT_STATUS rc;
    GT_U32  txqPortNum;     /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(GT_TRUE == PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* the port can be without TXQ port          */
        /* but it need to be in physical ports range */
        PRV_CPSS_DXCH_ENHANCED_PHY_PORT_CHECK_MAC(devNum,portNum);
        rc =  prvCpssDxChPortSip6TxBindPortToDpSet(devNum,portNum,profileSet);
    }
    else
    {
        PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
        rc =  prvCpssDxChPortTxBindPortToDpSet(devNum,portNum,profileSet);
    }

    return rc;
}

/**
* @internal cpssDxChPortTxBindPortToDpSet function
* @endinternal
*
* @brief   Bind a Physical Port to a specific Drop Profile Set.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
*/
GT_STATUS cpssDxChPortTxBindPortToDpSet
(
    IN  GT_U8                               devNum,
    IN  GT_PHYSICAL_PORT_NUM                portNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT   profileSet
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxBindPortToDpSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, profileSet));

    rc = internal_cpssDxChPortTxBindPortToDpSet(devNum, portNum, profileSet);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, profileSet));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxBindPortToDpGet function
* @endinternal
*
* @brief   Get Drop Profile Set according to a Physical Port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] profileSetPtr            - Pointer to the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxBindPortToDpGet
(
    IN  GT_U8                               devNum,
    IN  GT_PHYSICAL_PORT_NUM                portNum,
    OUT CPSS_PORT_TX_DROP_PROFILE_SET_ENT   *profileSetPtr
)
{
    GT_U32      lowValue;   /* two lower bits of the value to read
                            from register */
    GT_U32      upperValue; /* upper bit of the value to read from register*/
    GT_U32      regAddr;    /* register address           */
    GT_STATUS   rc;         /* return value */
    GT_U32      txqPortNum; /* TXQ port number */
    GT_U32      queueGroupIndex;/* queue group index that repersent physical port number*/
    GT_U32      fieldOffset;/* field offset*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(profileSetPtr);

    if(GT_TRUE == PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* the port can be without TXQ port          */
        /* but it need to be in physical ports range */
        PRV_CPSS_DXCH_ENHANCED_PHY_PORT_CHECK_MAC(devNum,portNum);
        txqPortNum = 0;/* ignored by sip6 */
    }
    else
    {
        PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    }


    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if(GT_TRUE == PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            /*Find queue group index*/
            rc = prvCpssDxChPortMappingEGFTargetLocalPhys2TxQPortBaseMapGet(devNum,0/*unused*/,portNum,&queueGroupIndex);
            if (GT_OK != rc )
            {
                return rc;
            }

            if(PRV_CPSS_DXCH_PORT_NUM_MAPPING_INVALID_PORT_CNS!=queueGroupIndex)
            {
                if((queueGroupIndex>>3) >= PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.preqInfo.portMappingNum)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "registerIndex[%d] >= max [%d]",
                        (queueGroupIndex>>3),
                        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.preqInfo.portMappingNum);
                }
                regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).portMapping[queueGroupIndex>>3];
                fieldOffset = (queueGroupIndex&0x7)<<2;/*each register contain 8 entries of size 4 bit*/
            }
            else
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "The port %d does not have queues assigned\n",portNum);
            }
        }
        else
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.portTailDropCNProfile[txqPortNum];
            fieldOffset = 0;
        }

        rc = prvCpssHwPpGetRegField(devNum, regAddr, fieldOffset, 4, &lowValue);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        PRV_CPSS_DXCH_PORT_TXQ_REG_MAC(devNum,portNum,&regAddr);

        /* get the two low bits of Drop Profile value */
        rc = prvCpssHwPpPortGroupGetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr, 18, 2, &lowValue);
        if(rc != GT_OK)
        {
            return rc;
        }
        /* get the upper bit of the Drop Profile value - bit 25 */
        rc = prvCpssHwPpPortGroupGetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr, 25, 1, &upperValue);
        if(rc != GT_OK)
        {
            return rc;
        }

        lowValue |= upperValue << 2;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.
            tailDrop.config.tailDropCnProfile[portNum];

        rc = prvCpssHwPpPortGroupGetRegField(devNum,
            PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr, 0, 3, &lowValue);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    switch (lowValue)
    {
    case 0:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_1_E;
        break;
    case 1:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_2_E;
        break;
    case 2:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_3_E;
        break;
    case 3:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_4_E;
        break;
    case 4:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_5_E;
        break;
    case 5:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_6_E;
        break;
    case 6:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_7_E;
        break;
    case 7:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_8_E;
        break;
    case 8:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_9_E;
        break;
    case 9:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_10_E;
        break;
    case 10:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_11_E;
        break;
    case 11:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_12_E;
        break;
    case 12:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_13_E;
        break;
    case 13:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_14_E;
        break;
    case 14:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_15_E;
        break;
    case 15:
        *profileSetPtr = CPSS_PORT_TX_DROP_PROFILE_16_E;
        break;
    default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxBindPortToDpGet function
* @endinternal
*
* @brief   Get Drop Profile Set according to a Physical Port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] profileSetPtr            - Pointer to the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxBindPortToDpGet
(
    IN  GT_U8                               devNum,
    IN  GT_PHYSICAL_PORT_NUM                portNum,
    OUT CPSS_PORT_TX_DROP_PROFILE_SET_ENT   *profileSetPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxBindPortToDpGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, profileSetPtr));

    rc = internal_cpssDxChPortTxBindPortToDpGet(devNum, portNum, profileSetPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, profileSetPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxDescNumberGet function
* @endinternal
*
* @brief   Gets the current number of descriptors allocated per specified port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] numberPtr                - number of descriptors
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxDescNumberGet
(
    IN  GT_U8       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT GT_U16      *numberPtr
)
{
    GT_U32      value;      /* value to write into register     */
    GT_U32      regAddr;    /* register address                 */
    GT_U32      txqPortNum; /* TXQ port number */
    GT_U32      fieldLength;/* the number of bits to be written to register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    CPSS_NULL_PTR_CHECK_MAC(numberPtr);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_DXCH_PORT_DESCR_COUNT_REG_MAC(devNum,txqPortNum,&regAddr);
    fieldLength = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 16 : 14;

    if(prvCpssHwPpPortGroupGetRegField(devNum,PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum),
        regAddr,0,fieldLength,&value) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    *numberPtr = (GT_U16)value;
    return GT_OK;
}

/**
* @internal cpssDxChPortTxDescNumberGet function
* @endinternal
*
* @brief   Gets the current number of descriptors allocated per specified port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] numberPtr                - number of descriptors
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxDescNumberGet
(
    IN  GT_U8       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT GT_U16      *numberPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxDescNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, numberPtr));

    rc = internal_cpssDxChPortTxDescNumberGet(devNum, portNum, numberPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, numberPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxBufNumberGet function
* @endinternal
*
* @brief   Gets the current number of buffers allocated per specified port.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] numPtr                   - number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxBufNumberGet
(
    IN   GT_U8                  devNum,
    IN   GT_PHYSICAL_PORT_NUM   portNum,
    OUT  GT_U32                 *numPtr
)
{

    GT_U32      value;      /* value to write into register     */
    GT_U32      regAddr;    /* register address                 */
    GT_U32      txqPortNum; /* TXQ port number */
    GT_U32      fieldLength;/* the number of bits to be written to register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    CPSS_NULL_PTR_CHECK_MAC(numPtr);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return  prvCpssFalconTxqUtilsPortTxBufNumberGet(devNum,portNum,numPtr);
    }

    PRV_CPSS_DXCH_PORT_BUFFER_COUNT_REG_MAC(devNum,txqPortNum,&regAddr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        fieldLength = 20;
    }
    else
    {
        fieldLength = 14;
    }

    if(prvCpssHwPpPortGroupGetRegField(devNum,PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum),
        regAddr,0,fieldLength,&value) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    *numPtr = value;
    return GT_OK;
}

/**
* @internal cpssDxChPortTxBufNumberGet function
* @endinternal
*
* @brief   Gets the current number of buffers allocated per specified port.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] numPtr                   - number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxBufNumberGet
(
    IN   GT_U8                  devNum,
    IN   GT_PHYSICAL_PORT_NUM   portNum,
    OUT  GT_U32                 *numPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxBufNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, numPtr));

    rc = internal_cpssDxChPortTxBufNumberGet(devNum, portNum, numPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, numPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTx4TcDescNumberGet function
* @endinternal
*
* @brief   Gets the current number of descriptors allocated on specified port
*         for specified Traffic Class queues.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X.
* @note   NOT APPLICABLE DEVICES:  Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] trafClass                - trafiic class (0..7)
*
* @param[out] numberPtr                - (pointer to) the number of descriptors
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Note: Do not call this API under traffic for Lion devices
*
*/
static GT_STATUS internal_cpssDxChPortTx4TcDescNumberGet
(
    IN  GT_U8       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8       trafClass,
    OUT GT_U16      *numberPtr
)
{
    GT_STATUS   rc;         /* return code */
    GT_U32      value;      /* value to write into register     */
    GT_U32      regAddr;    /* register address                 */
    GT_U32      tableIndex; /* table index                 */
    CPSS_DXCH_TABLE_ENT tableType; /* table type */
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(trafClass);
    CPSS_NULL_PTR_CHECK_MAC(numberPtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        tableType = CPSS_DXCH_SIP5_TABLE_TXQ_LINK_LIST_COUNTERS_Q_MAIN_DESC_E;

        tableIndex = trafClass | (txqPortNum << 3);

        rc = prvCpssDxChReadTableEntry(devNum, tableType, tableIndex, &value);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        PRV_CPSS_DXCH_PORT_TC_DESCR_COUNT_REG_MAC(devNum,portNum,trafClass,&regAddr);

        if(prvCpssHwPpPortGroupGetRegField(devNum,PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr,0,14,&value) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    *numberPtr = (GT_U16)value;

    return GT_OK;
}

/**
* @internal cpssDxChPortTx4TcDescNumberGet function
* @endinternal
*
* @brief   Gets the current number of descriptors allocated on specified port
*         for specified Traffic Class queues.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X.
* @note   NOT APPLICABLE DEVICES:  Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] trafClass                - trafiic class (0..7)
*
* @param[out] numberPtr                - (pointer to) the number of descriptors
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Note: Do not call this API under traffic for Lion devices
*
*/
GT_STATUS cpssDxChPortTx4TcDescNumberGet
(
    IN  GT_U8       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8       trafClass,
    OUT GT_U16      *numberPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTx4TcDescNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, trafClass, numberPtr));

    rc = internal_cpssDxChPortTx4TcDescNumberGet(devNum, portNum, trafClass, numberPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, trafClass, numberPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTx4TcBufNumberGet function
* @endinternal
*
* @brief   Gets the current number of buffers allocated on specified port
*         for specified Traffic Class queues.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] trafClass                -  trafiic class (0..7) (For Falcon only  0..15)
*
* @param[out] numPtr                   - (pointer to) the number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Note: Do not call this API under traffic for Lion devices
*
*/
static GT_STATUS internal_cpssDxChPortTx4TcBufNumberGet
(
    IN  GT_U8       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8       trafClass,
    OUT GT_U32      *numPtr
)
{
    GT_STATUS   rc;         /* return code */
    GT_U32      value;      /* value to write into register     */
    GT_U32      regAddr;    /* register address                 */
    GT_U32      tableIndex; /* table index                 */
    CPSS_DXCH_TABLE_ENT tableType; /* table type */
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,trafClass);
    CPSS_NULL_PTR_CHECK_MAC(numPtr);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,trafClass);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        rc = prvCpssFalconTxqUtilsCounterPerPortTcGet(devNum,PRV_CPSS_DXCH_TXQ_SIP_6_COUNTER_TYPE_OCCUPIED_BUFFERS,
            portNum,trafClass,numPtr);

        return rc;
    }

    else if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_COUNTERS_Q_MAIN_BUFF_E;

        tableIndex = trafClass | (txqPortNum << 3);

        rc = prvCpssDxChReadTableEntry(devNum, tableType, tableIndex, &value);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        PRV_CPSS_DXCH_PORT_TC_BUFFER_COUNT_REG_MAC(devNum,portNum,trafClass,&regAddr);

        if(prvCpssHwPpPortGroupGetRegField(devNum,PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
            regAddr,0,14,&value) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    *numPtr = (GT_U16)value;

    return GT_OK;
}

/**
* @internal cpssDxChPortTx4TcBufNumberGet function
* @endinternal
*
* @brief   Gets the current number of buffers allocated on specified port
*         for specified Traffic Class queues.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] trafClass                - trafiic class (0..7)
*
* @param[out] numPtr                   - (pointer to) the number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Note: Do not call this API under traffic for Lion devices
*
*/
GT_STATUS cpssDxChPortTx4TcBufNumberGet
(
    IN  GT_U8       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8       trafClass,
    OUT GT_U32      *numPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTx4TcBufNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, trafClass, numPtr));

    rc = internal_cpssDxChPortTx4TcBufNumberGet(devNum, portNum, trafClass, numPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, trafClass, numPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}



/**
* @internal internal_cpssDxChPortTxToCpuShaperModeSet function
* @endinternal
*
* @brief   Set Shaper mode packet or byte based for CPU port shapers
*         Shapers are configured by cpssDxChPortTxShaperProfileSet or
*         cpssDxChPortTxQShaperProfileSet
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] mode                     - shaper mode: byte count or packet number based ackets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxToCpuShaperModeSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT   mode
)
{
    GT_U32 hwCpuPortTbMode; /* The CPU Port Token bucket Rate shaper mode  */
    GT_U32 regAddr;         /* register address                 */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    switch (mode)
    {
    case CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E:
        hwCpuPortTbMode = 0;
        break;
    case CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E:
        hwCpuPortTbMode = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueMiscCtrl;

    /* The CPU Port Token bucket Rate shaper mode */
    return prvCpssHwPpSetRegField(devNum, regAddr, 2, 1, hwCpuPortTbMode);
}

/**
* @internal cpssDxChPortTxToCpuShaperModeSet function
* @endinternal
*
* @brief   Set Shaper mode packet or byte based for CPU port shapers
*         Shapers are configured by cpssDxChPortTxShaperProfileSet or
*         cpssDxChPortTxQShaperProfileSet
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] mode                     - shaper mode: byte count or packet number based ackets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxToCpuShaperModeSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT   mode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxToCpuShaperModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mode));

    rc = internal_cpssDxChPortTxToCpuShaperModeSet(devNum, mode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxToCpuShaperModeGet function
* @endinternal
*
* @brief   Get Shaper mode packet or byte based for CPU port shapers.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] modePtr                  - (pointer to) shaper mode: byte count or packet number based ackets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
static GT_STATUS internal_cpssDxChPortTxToCpuShaperModeGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_PORT_TX_DROP_SHAPER_MODE_ENT  *modePtr
)
{
    GT_U32 hwCpuPortTbMode; /* The CPU Port Token bucket Rate shaper mode */
    GT_U32 regAddr;         /* register address */
    GT_STATUS   rc;         /* return code */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    CPSS_NULL_PTR_CHECK_MAC(modePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueMiscCtrl;

    /* The CPU Port Token bucket Rate shaper mode */
    rc = prvCpssHwPpGetRegField(devNum, regAddr, 2, 1, &hwCpuPortTbMode);
    if (rc != GT_OK)
        return rc;

    *modePtr = (hwCpuPortTbMode == 1) ? CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E:
        CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E;

    return GT_OK;
}

/**
* @internal cpssDxChPortTxToCpuShaperModeGet function
* @endinternal
*
* @brief   Get Shaper mode packet or byte based for CPU port shapers.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] modePtr                  - (pointer to) shaper mode: byte count or packet number based ackets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
GT_STATUS cpssDxChPortTxToCpuShaperModeGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_PORT_TX_DROP_SHAPER_MODE_ENT  *modePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxToCpuShaperModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, modePtr));

    rc = internal_cpssDxChPortTxToCpuShaperModeGet(devNum, modePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, modePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSharingGlobalResourceEnableSet function
* @endinternal
*
* @brief   Enable/Disable sharing of resources for enqueuing of packets.
*         The shared resources configuration is set by
*         cpssDxChPortTxSharedGlobalResourceLimitsSet
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE   -  TX queue resourses sharing
*                                      GT_FALSE - disable TX queue resources sharing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSharingGlobalResourceEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_U32 regAddr;         /* register address                     */
    GT_U32 value;           /* value to be written to the register  */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    value = BOOL2BIT_MAC(enable);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
        egrTxQConf.txQueueResSharingAndTunnelEgrFltr;

    /* Set <ResourceShareEn> in the Transmit Queue Resource Sharing Register */
    return prvCpssHwPpSetRegField(devNum, regAddr, 24, 1, value);
}

/**
* @internal cpssDxChPortTxSharingGlobalResourceEnableSet function
* @endinternal
*
* @brief   Enable/Disable sharing of resources for enqueuing of packets.
*         The shared resources configuration is set by
*         cpssDxChPortTxSharedGlobalResourceLimitsSet
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE   -  TX queue resourses sharing
*                                      GT_FALSE - disable TX queue resources sharing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSharingGlobalResourceEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSharingGlobalResourceEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPortTxSharingGlobalResourceEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxSharingGlobalResourceEnableGet function
* @endinternal
*
* @brief   Get enable/disable sharing of resources for enqueuing of packets.
*         The shared resources configuration is set by
*         cpssDxChPortTxSharedGlobalResourceLimitsSet
*
* @note   APPLICABLE DEVICES:   xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE   - enable TX queue resourses sharing
*                                      GT_FALSE - disable TX queue resources sharing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSharingGlobalResourceEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL    *enablePtr
)
{
    GT_U32 regAddr;         /* register address                     */
    GT_U32 value;           /* value to be written to the register  */
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    /* Get <ResourceShareEn> in the Transmit Queue Resource Sharing Register */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
        egrTxQConf.txQueueResSharingAndTunnelEgrFltr;
    rc = prvCpssHwPpGetRegField(devNum, regAddr, 24, 1, &value);
    if( GT_OK != rc )
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/**
* @internal cpssDxChPortTxSharingGlobalResourceEnableGet function
* @endinternal
*
* @brief   Get enable/disable sharing of resources for enqueuing of packets.
*         The shared resources configuration is set by
*         cpssDxChPortTxSharedGlobalResourceLimitsSet
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE   - enable TX queue resourses sharing
*                                      GT_FALSE - disable TX queue resources sharing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSharingGlobalResourceEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL    *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSharingGlobalResourceEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPortTxSharingGlobalResourceEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSharedGlobalResourceLimitsSet function
* @endinternal
*
* @brief   Configuration of shared resources for enqueuing of packets.
*         The using of shared resources is set
*         by cpssDxChPortTxSharingGlobalResourceEnableSet
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] sharedBufLimit           - The number of buffers in all Transmit queues that
*                                      can be shared between eligible packets.
*                                      For xCat3: range 0..16380
* @param[in] sharedDescLimit          - The number of descriptors that can be shared
*                                      between all eligible packets.
*                                      For xCat3: range 0..16380
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note For xCat3: sharedBufLimit and sharedDescLimit are rounded up
*       to the nearest multiple of 4 since the corresponding fields in the
*       Transmit Queue Resource Sharing register are in 4 buffers\descriptors
*       resolution.
*
*/
static GT_STATUS internal_cpssDxChPortTxSharedGlobalResourceLimitsSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  sharedBufLimit,
    IN  GT_U32  sharedDescLimit
)
{
    GT_U32 regAddr;             /* register address                     */
    GT_U32 data;                /* data to be written to the register   */
    GT_U32 sharedBufLimitInt;   /* local use of sharedBufLimit value    */
    GT_U32 sharedDescLimitInt;  /* local use of sharedDescLimit value   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    sharedBufLimitInt  = (sharedBufLimit + 3) >> 2;
    sharedDescLimitInt = (sharedDescLimit + 3) >> 2;

    /* check validity of the input parameters */
    if ((sharedBufLimitInt > 0xFFF) || (sharedDescLimitInt > 0xFFF))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
        egrTxQConf.txQueueResSharingAndTunnelEgrFltr;

    data = (sharedBufLimitInt << 12) | sharedDescLimitInt;

    /* Set <Share DescLimit> and <Share BufLimit> in the
    Transmit Queue Resource Sharing Register */
    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 24, data);
}

/**
* @internal cpssDxChPortTxSharedGlobalResourceLimitsSet function
* @endinternal
*
* @brief   Configuration of shared resources for enqueuing of packets.
*         The using of shared resources is set
*         by cpssDxChPortTxSharingGlobalResourceEnableSet
*
* @note   APPLICABLE DEVICES:     xCat3; AC5;.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] sharedBufLimit           - The number of buffers in all Transmit queues that
*                                      can be shared between eligible packets.
*                                      For xCat3: range 0..16380
* @param[in] sharedDescLimit          - The number of descriptors that can be shared
*                                      between all eligible packets.
*                                      For xCat3: range 0..16380
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note For xCat3: sharedBufLimit and sharedDescLimit are rounded up
*       to the nearest multiple of 4 since the corresponding fields in the
*       Transmit Queue Resource Sharing register are in 4 buffers\descriptors
*       resolution.
*
*/
GT_STATUS cpssDxChPortTxSharedGlobalResourceLimitsSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  sharedBufLimit,
    IN  GT_U32  sharedDescLimit
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSharedGlobalResourceLimitsSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, sharedBufLimit, sharedDescLimit));

    rc = internal_cpssDxChPortTxSharedGlobalResourceLimitsSet(devNum, sharedBufLimit, sharedDescLimit);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, sharedBufLimit, sharedDescLimit));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxSharedGlobalResourceLimitsGet function
* @endinternal
*
* @brief   Get the configuration of shared resources for enqueuing of packets.
*         The using of shared resources is set
*         by cpssDxChPortTxSharingGlobalResourceEnableSet
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] sharedBufLimitPtr        - (pointer to) The number of buffers in all
*                                      Transmit queues that
*                                      can be shared between eligible packets.
* @param[out] sharedDescLimitPtr       - (pointer to) The number of descriptors that
*                                      can be shared between all eligible packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer.
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSharedGlobalResourceLimitsGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *sharedBufLimitPtr,
    OUT GT_U32  *sharedDescLimitPtr
)
{
    GT_U32 regAddr;             /* register address                     */
    GT_U32 data;                /* data to be written to the register   */
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(sharedBufLimitPtr);
    CPSS_NULL_PTR_CHECK_MAC(sharedDescLimitPtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
        egrTxQConf.txQueueResSharingAndTunnelEgrFltr;
    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 24, &data);
    if (rc != GT_OK)
    {
        return rc;
    }

    *sharedDescLimitPtr = (data & 0xFFF) << 2 ;
    *sharedBufLimitPtr  = ((data >> 12) & 0xFFF) << 2;

    return GT_OK;
}

/**
* @internal cpssDxChPortTxSharedGlobalResourceLimitsGet function
* @endinternal
*
* @brief   Get the configuration of shared resources for enqueuing of packets.
*         The using of shared resources is set
*         by cpssDxChPortTxSharingGlobalResourceEnableSet
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] sharedBufLimitPtr        - (pointer to) The number of buffers in all
*                                      Transmit queues that
*                                      can be shared between eligible packets.
* @param[out] sharedDescLimitPtr       - (pointer to) The number of descriptors that
*                                      can be shared between all eligible packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer.
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSharedGlobalResourceLimitsGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *sharedBufLimitPtr,
    OUT GT_U32  *sharedDescLimitPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSharedGlobalResourceLimitsGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, sharedBufLimitPtr, sharedDescLimitPtr));

    rc = internal_cpssDxChPortTxSharedGlobalResourceLimitsGet(devNum, sharedBufLimitPtr, sharedDescLimitPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, sharedBufLimitPtr, sharedDescLimitPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSharedPolicySet function
* @endinternal
*
* @brief   Sets shared pool allocation policy for enqueuing of packets.
*
* @note   APPLICABLE DEVICES:    xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 .
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] policy                   - shared pool allocation policy.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device or wrong policy
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSharedPolicySet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PORT_TX_SHARED_POLICY_ENT  policy
)
{
    GT_U32  value;      /* value to set to register */
    GT_U32  regAddr;    /* register address         */
    GT_U32  offset;     /* offset within register   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);


    switch (policy)
    {
    case CPSS_DXCH_PORT_TX_SHARED_POLICY_UNCONSTRAINED_E:
        value = 0;
        break;
    case CPSS_DXCH_PORT_TX_SHARED_POLICY_CONSTRAINED_E:
        value = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.globalTailDropConfig;
        offset = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 6 : 5;
    }
    else if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.config.config;
        offset = 4;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.
            txQueueResSharingAndTunnelEgrFltr;
        offset = 29;
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, offset, 1, value);
}

/**
* @internal cpssDxChPortTxSharedPolicySet function
* @endinternal
*
* @brief   Sets shared pool allocation policy for enqueuing of packets.
*
* @note   APPLICABLE DEVICES:    xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 .
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] policy                   - shared pool allocation policy.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device or wrong policy
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSharedPolicySet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PORT_TX_SHARED_POLICY_ENT  policy
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSharedPolicySet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, policy));

    rc = internal_cpssDxChPortTxSharedPolicySet(devNum, policy);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, policy));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSharedPolicyGet function
* @endinternal
*
* @brief   Gets shared pool allocation policy for enqueuing of packets.
*
* @note   APPLICABLE DEVICES:    xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 .
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
*
* @param[out] policyPtr                - (pointer to) shared pool allocation policy.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer.
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSharedPolicyGet
(
    IN  GT_U8                                devNum,
    OUT CPSS_DXCH_PORT_TX_SHARED_POLICY_ENT  *policyPtr
)
{
    GT_U32      value;      /* value to read from the register  */
    GT_U32      regAddr;    /* register address                 */
    GT_U32      offset;     /* offset within register           */
    GT_STATUS   rc;         /* function return value            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(policyPtr);


    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.globalTailDropConfig;
        offset = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 6 : 5;
    }
    else if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.config.config;
        offset = 4;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.
            txQueueResSharingAndTunnelEgrFltr;
        offset = 29;
    }

    rc =  prvCpssHwPpGetRegField(devNum, regAddr, offset, 1, &value);

    if(rc != GT_OK)
    {
        return rc;
    }

    *policyPtr = (value == 1) ? CPSS_DXCH_PORT_TX_SHARED_POLICY_CONSTRAINED_E :
        CPSS_DXCH_PORT_TX_SHARED_POLICY_UNCONSTRAINED_E;

    return GT_OK;
}

/**
* @internal cpssDxChPortTxSharedPolicyGet function
* @endinternal
*
* @brief   Gets shared pool allocation policy for enqueuing of packets.
*
* @note   APPLICABLE DEVICES:    xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 .
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
*
* @param[out] policyPtr                - (pointer to) shared pool allocation policy.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer.
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSharedPolicyGet
(
    IN  GT_U8                                devNum,
    OUT CPSS_DXCH_PORT_TX_SHARED_POLICY_ENT  *policyPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSharedPolicyGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, policyPtr));

    rc = internal_cpssDxChPortTxSharedPolicyGet(devNum, policyPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, policyPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/***********internal functions*************************************************/

/**
* @internal prvDxChShaperDisable function
* @endinternal
*
* @brief   Disable Token Bucket rate shaping on specified port of
*         specified device or
*         Disable shaping of transmitted traffic from a specified Traffic
*         Class Queue and specified port of specified device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portGroupId              - The port group id. relevant only to 'multi-port-groups'
*                                      devices. Supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS
* @param[in] tokenBucketRegAddr       - token bucket register address
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
*
* @note 1. Read and store bucket's parameters
*       2. Set maximal parameters to the bucket
*       3. Read MTU from register
*       4. Delay some microseconds
*       5. Disable shaper
*       6. Restore previous values
*
*/
static GT_STATUS prvDxChShaperDisable
(
    IN  GT_U8   devNum,
    IN  GT_U32  portGroupId,
    IN  GT_U32  tokenBucketRegAddr
)
{
    GT_U32      oldValue;    /* old value of Token Bucket Register */
    GT_U32      data;        /* data to write */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    /* Disabling the Egress Rate Shaper under traffic may hang its
    relevant transmit queue. (FEr#47) */
    if(PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E) == GT_FALSE)
    {
        /* no WA needed just disable the shaper */
        return prvCpssHwPpPortGroupSetRegField(devNum, portGroupId, tokenBucketRegAddr, 0, 1, 0);
    }

    /* read and store bucket parameters */
    if(prvCpssHwPpPortGroupReadRegister(devNum, portGroupId, tokenBucketRegAddr, &oldValue) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    /* Set Number Tokens and Bucket Size to a maximal values - 0xFFF
    and disable slow rate */
    data = (oldValue & 0xFFFFFFFD) | (0xFFFFFF << 4);

    if (prvCpssHwPpPortGroupWriteRegister(devNum, portGroupId, tokenBucketRegAddr, data) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    /* Token bucket update to new maximal values will be configured by next
    pulse of token bucket update clock. It's need to be done delay to
    disable token bucket to guaranty maximal values update.
    The delay need to be for time more than maximal token bucket update
    period - 15360 core clock cycles. For Core Clock 144MHz delay should be
    more than 100 micro seconds. */
    cpssOsTimerWkAfter(1);

    /* disable shaping */
    if (prvCpssHwPpPortGroupSetRegField(devNum, portGroupId, tokenBucketRegAddr, 0, 1, 0) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    /* restore old values */
    oldValue &= ~1;

    return prvCpssHwPpPortGroupWriteRegister(devNum, portGroupId, tokenBucketRegAddr, oldValue);
}

/**
* @internal prvDxChPortTxCalcShaperTokenBucketRate function
* @endinternal
*
* @brief   Get shaper parameters for token bucket per port / per port per queue:
*         - Token refill value.
*         - slow-rate mode.
*         - tokens rate for XG/GIG.
*         - slow rate ratio.
*         The Formula is:
*         <Core Clock Frequency in Kbps> <Token refill value in bits>
*         Rate in Kbps = -------------------------------------------------------------
*         <Refill period in clock cycles>
*         Refill period for 1000/100/10Mbps ports (GIG) is:
*         Refill period in clock cycles = <TriSpeed ports tokens rate> 128
*         <Slow Rate>
*         Where <Slow Rate> is:
*         Slow Rate = [1 - <Slow Rate mode>] + [<Slow Rate mode> <Slow Rate Ratio>]
*         Where <Slow Rate mode> is: 0 for disabled, 1 for enabled.
*         Refill period for HyperG.Stack ports (XG) is:
*         Refill period in clock cycles = <XG ports tokens rate> 8
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical port number
* @param[in] xgPortsTokensRate        - tokens rate for XG ports' shapers
* @param[in] gigPortsTokensRate       - tokens rate for Tri Speed ports' shapers
* @param[in] gigPortsSlowRateRatio    - slow rate ratio for Tri Speed ports. Tokens Update
*                                      rate for ports with slow rate divided to the ratio.
* @param[in] tokenRefillValue         - number of tokens added to the bucket on each update
*                                      cycle.
* @param[in] slowRateEn               - Enable the division of <gigPortsTokensRate> by
* @param[in] gigPortsSlowRateRatio
* @param[in] stackAsGig               - GT_TRUE, stacking ports shapers operates
*                                      as Tri Speed ports' shapers.
*                                      GT_FALSE, stacking ports shapers operates as XG ports.
*
* @param[out] tokenBucketRatePtr       - (pointer to) the shaping rate - actual Rate in Kbps.
*
* @retval GT_OK                    - on success
*
* @note 1.If the Token Bucket rate shaping is disabled then shaping rate returned
*       is set to 0.
*       For port number in the range 0..23, whether G or XG type, the global
*       shaper used parameters are those referenced as gig ones -
*       "gigPortsTokensRate" and "gigPortsSlowRateRatio" inputs for
*       "cpssDxChPortTxShaperGlobalParamsSet" API.
*       2. Txq revision 1 is not supported by this function.
*
*/
static GT_STATUS prvDxChPortTxCalcShaperTokenBucketRate
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    GT_U32                  xgPortsTokensRate,
    IN    GT_U32                  gigPortsTokensRate,
    IN    GT_U32                  gigPortsSlowRateRatio,
    IN    GT_U32                  tokenRefillValue,
    IN    GT_U32                  slowRateEn,
    IN    GT_BOOL                 stackAsGig,
    OUT   GT_U32                 *tokenBucketRatePtr
)
{
    GT_U32      rateDividor;    /* rate dividor due to token refill period and */
    /* the slow rate (if enabled). */
    GT_U32      coreClockInK;   /* clock rate in Khz */

    coreClockInK = PRV_CPSS_PP_MAC(devNum)->coreClock * 1000;

    if ( (portNum != CPSS_CPU_PORT_NUM_CNS) && (portNum > 23) &&
         (stackAsGig == GT_FALSE) &&
         (CPSS_PP_FAMILY_DXCH_LION2_E != PRV_CPSS_PP_MAC(devNum)->devFamily) &&
         (!PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
    {
        /* no slow rate support */
        rateDividor = xgPortsTokensRate * 8;
    }
    else
    {
        if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) ||
           (PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
        {
            rateDividor = gigPortsTokensRate * 8;
        }
        else
        {
            rateDividor = gigPortsTokensRate * 128;
        }

        if( slowRateEn )
        {
            rateDividor = rateDividor * gigPortsSlowRateRatio;
        }
    }

    *tokenBucketRatePtr = tokenRefillValue * coreClockInK / rateDividor ;

    /* round up the result */
    if (tokenRefillValue * coreClockInK % rateDividor)
    {
        *tokenBucketRatePtr += 1;
    }

    return GT_OK;
}

/**
* @internal prvDxChPortTxCalcShaperTokenBucketRate_rev1 function
* @endinternal
*
* @brief   Get shaper parameters for token bucket per port / per port per queue:
*         - Token refill value.
*         - slow-rate mode.
*         - tokens rate for XG/GIG.
*         - slow rate ratio.
*         The Formula is:
*         <Core Clock Frequency in Kbps> <Token refill value in bits>
*         Rate in Kbps = -------------------------------------------------------------
*         <Refill period in clock cycles>
*         Refill period in clock cycles when slow rate is enabled =
*         <tokensRate> <tokensRateGran> <Slow Rate>
*         Refill period in clock cycles when slow rate is disabled =
*         <tokensRate> <tokensRateGran> 2 ^ < tbUpdateRatio >
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - port number
* @param[in] shaperConfigPtr          - (pointer to) shaper configuration
* @param[in] shaperMode               - shaper mode
* @param[in] slowRateEn               - slow rate enable value
* @param[in] tbUpdateRatio            - TB interval update ratio value
* @param[in] tokenRefillValue         - TB refill value
*
* @param[out] tokenBucketRatePtr       - (pointer to) the actual Rate in Kbps or pps.
*
* @retval GT_OK                    - on success
*
* @note Only Txq revision 1 is supported by this function.
*
*/
GT_STATUS prvDxChPortTxCalcShaperTokenBucketRate_rev1
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC *shaperConfigPtr,
    IN    CPSS_PORT_TX_DROP_SHAPER_MODE_ENT   shaperMode,
    IN    GT_BOOL                 slowRateEn,
    IN    GT_U32                  tbUpdateRatio,
    IN    GT_U32                  tokenRefillValue,
    OUT   GT_U32                 *tokenBucketRatePtr
)
{
    GT_U32 refillPeriod;     /* Refill period in clock cycles */
    GT_U32 coreClockInK;     /* clock rate in Khz */
    GT_U32 packetLengthBits; /* packet length used in packet based shaping */
    /* in bits */
    GT_U32 tempRate;
    GT_U32 remainder;
    GT_U64 tempResult;       /* used for temp calculation with U64 */
    GT_U16 tempResult1;     /* used for temp calculation with U16 */
    GT_STATUS rc;
    GT_BOOL   isCpu;

    if (tbUpdateRatio > 10)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }
    rc = cpssDxChPortPhysicalPortMapIsCpuGet(devNum, portNum, &isCpu);
    if (rc != GT_OK)
    {
        return rc;
    }
    packetLengthBits = ((isCpu == GT_TRUE) ?
        shaperConfigPtr->cpuPacketLength :
    shaperConfigPtr->portsPacketLength) * 8;

    coreClockInK = PRV_CPSS_PP_MAC(devNum)->coreClock * 1000;

    switch(shaperConfigPtr->tokensRateGran)
    {
    case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_64_CORE_CLOCKS_E:
        refillPeriod = shaperConfigPtr->tokensRate * 8;
        break;
    case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
        refillPeriod = shaperConfigPtr->tokensRate * 128;
        break;
    case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_128_CORE_CLOCKS_E:
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            refillPeriod = shaperConfigPtr->tokensRate * 16;
            break;
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_256_CORE_CLOCKS_E:
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            refillPeriod = shaperConfigPtr->tokensRate * 32;
            break;
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    if (slowRateEn)
    {
        refillPeriod *= shaperConfigPtr->slowRateRatio;
    }
    else
    {
        refillPeriod *= 1 << tbUpdateRatio;
    }

    if(refillPeriod == 0)
    {
        /* the values of shaperConfigPtr->tokensRate from HW indicate problem  */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* use 64-bit data to avoid 32-bit overflow caused errors */
    tempResult = prvCpssMathMul64(tokenRefillValue, coreClockInK);
    tempResult = prvCpssMathDiv64By32(tempResult, refillPeriod, &remainder);
    *tokenBucketRatePtr = tempResult.l[0];

    /* round up the result */
    if (remainder)
    {
        *tokenBucketRatePtr += 1;
    }

    if (packetLengthBits != 0 && shaperMode == CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E)
    {
        tempRate = *tokenBucketRatePtr;
        if(packetLengthBits < BIT_17)
        {
            tempResult1 = (GT_U16)(packetLengthBits/2);
            tempResult = prvCpssMathMul64(tempRate, 500);
            tempResult = prvCpssMathDiv64By16(tempResult, tempResult1);
            *tokenBucketRatePtr = tempResult.l[0];
        }
        else
        {
            *tokenBucketRatePtr = tempRate * 1000 / packetLengthBits;
        }

        /* round up the result */
        if ((tempRate * 1000) % packetLengthBits)
        {
            *tokenBucketRatePtr += 1;
        }
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChPortTxReCalcShaperTokenBucketRate function
* @endinternal
*
* @brief   Calculate shaping rate parameters (<Token refill value>, <slow-rate mode>)
*         for token bucket per port / per port per queue.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical port number
* @param[in] xgPortsTokensRate        - tokens rate for XG ports' shapers
* @param[in] gigPortsTokensRate       - tokens rate for Tri Speed ports' shapers
* @param[in] gigPortsSlowRateRatio    - slow rate ratio for Tri Speed ports. Tokens Update
*                                      rate for ports with slow rate divided to the ratio.
* @param[in] stackAsGig               - GT_TRUE, stacking ports shapers operates
*                                      as Tri Speed ports' shapers.
*                                      GT_FALSE, stacking ports shapers operates as XG ports.
* @param[in] tokenBucketRate          - the shaping rate - actual Rate in Kbps.
*
* @param[out] tokenRefillValuePtr      - number of tokens added to the bucket on each update
*                                      cycle.
* @param[out] slowRateEnPtr            - Enable the division of <gigPortsTokensRate> by
* @param[out] gigPortsSlowRateRatio
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1.For port number in the range 0..23, whether G or XG type, the global
*       shaper used parameters are those referenced as gig ones -
*       "gigPortsTokensRate" and "gigPortsSlowRateRatio" inputs for
*       "cpssDxChPortTxShaperGlobalParamsSet" API.
*       2. Txq revision 1 is not supported by this function.
*
*/
static GT_STATUS prvCpssDxChPortTxReCalcShaperTokenBucketRate
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    GT_U32                  xgPortsTokensRate,
    IN    GT_U32                  gigPortsTokensRate,
    IN    GT_U32                  gigPortsSlowRateRatio,
    IN    GT_BOOL                 stackAsGig,
    OUT   GT_U32                 *tokenRefillValuePtr,
    OUT   GT_U32                 *slowRateEnPtr,
    IN    GT_U32                  tokenBucketRate
)
{
    GT_U32      maxRate;            /* the maximal rate available when slow rate in disabled */
    GT_U32      newRate;            /* the rate that will be requested when max and min limits */
    /* are taken into consideration */
    GT_U32      minSlowRate;        /* the minimal rate available when slow rate is enabled */
    GT_U32      maxSlowRate;        /* the maximal rate available when slow rate is enabled */
    GT_U32      rateDividor;        /* rate dividor due to token refill period */
    GT_U32      slowRateDividor;    /* rate dividor due to token refill period and the slow rate */
    GT_U32      coreClockInK;       /* clock rate in Khz */
    GT_U64      tempResult;         /* temprory result for u64 calculations */

    coreClockInK = PRV_CPSS_PP_MAC(devNum)->coreClock * 1000;

    if ((portNum != CPSS_CPU_PORT_NUM_CNS) && (portNum > 23) &&
        (stackAsGig == GT_FALSE) &&
        (CPSS_PP_FAMILY_DXCH_LION2_E != PRV_CPSS_PP_MAC(devNum)->devFamily) &&
        (!PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
    {
        /* no slow rate support therefore slowRate is same as Rate */
        rateDividor = slowRateDividor = xgPortsTokensRate * 8;
    }
    else
    {
        if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) ||
           (PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
        {
            rateDividor = gigPortsTokensRate * 8;
        }
        else
        {
            rateDividor = gigPortsTokensRate * 128;
        }
        slowRateDividor = rateDividor * gigPortsSlowRateRatio;
    }

    minSlowRate = coreClockInK / slowRateDividor;

    /* the maximal tokens number is 0xFFF (4095) */
    maxRate = coreClockInK * 0xFFF / rateDividor;
    maxSlowRate = coreClockInK * 0xFFF / slowRateDividor;

    if (tokenBucketRate < minSlowRate)
    {
        /* this is the min rate that can be supported */
        newRate = minSlowRate;
        *slowRateEnPtr = 1;
    }
    else if (tokenBucketRate > maxRate)
    {
        /* this is the max rate that can be supported */
        newRate = maxRate;
        *slowRateEnPtr = 0;
    }
    else
    {
        newRate = tokenBucketRate;

        if (tokenBucketRate > maxSlowRate)
        {
            /* the *maxRate between maxSlowRate and maxRate */
            *slowRateEnPtr = 0;
        }
        else
        {
            /* the *maxRrate between minSlowRate and maxSlowRate */
            *slowRateEnPtr = 1;
        }
    }

    if (*slowRateEnPtr)
    {
        tempResult = prvCpssMathMul64(newRate,slowRateDividor);
    }
    else
    {
        tempResult = prvCpssMathMul64(newRate,rateDividor);
    }

    tempResult = prvCpssMathDiv64By16(tempResult,(GT_U16)(coreClockInK/1000));
    tempResult = prvCpssMathDiv64By16(tempResult,1000);

    if (tempResult.l[1])
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    *tokenRefillValuePtr = tempResult.l[0];

    if( 0 == *tokenRefillValuePtr )
        *tokenRefillValuePtr = 1;

    return GT_OK;
}

/**
* @internal prvCpssDxChPortTxReCalcShaperTokenBucketRate_rev1 function
* @endinternal
*
* @brief   Calculate shaping rate parameters for given tokenBucketRate:
*         1. TB refill value
*         2. slow rate enable value
*         3. TB interval update ratio value
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical port number
* @param[in] usePerTc                 - token bucket per port or per queue
* @param[in] shaperConfigPtr          - (pointer to) shaper configuration.
* @param[in] shaperMode               - shaper mode
* @param[in] tokenBucketRate          - the shaping rate - actual Rate in Kbps.
* @param[in] burstSize                - burst size in bytes
*                                  (already adjusted for baseline)
* @param[in] isMllShaper               - MLL or TxQ Shaper
*
* @param[out] slowRateEnPtr            - (pointer to) slow rate enable value
* @param[out] tbUpdateRatioPtr         - (pointer to) TB interval update ratio value
* @param[out] tokensPtr                - (pointer to) TB refill value
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Only Txq revision 1 is supported by this function.
*
*/
GT_STATUS prvCpssDxChPortTxReCalcShaperTokenBucketRate_rev1
(
    IN  GT_U8                                 devNum,
    IN  GT_PHYSICAL_PORT_NUM                  portNum,
    IN  GT_BOOL                               usePerTc,
    IN  CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC   *shaperConfigPtr,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT     shaperMode,
    IN  GT_U32                                tokenBucketRate,
    IN  GT_U32                                burstSize,
    IN  GT_BOOL                               isMllShaper,
    OUT GT_BOOL                               *slowRateEnPtr,
    OUT GT_U32                                *tbUpdateRatioPtr,
    OUT GT_U32                                *tokensPtr
)
{
    GT_U32      rateDivisor;        /* rate divisor due to token refill period */
    GT_U16      coreClockInM;       /* clock rate in Mhz */
    GT_U32      packetLengthBits;   /* packet length used in packet based shaping */
    GT_U32      TBIntervalUpdateRatio;
    GT_U32      TBIntervalUpdateRatioSaved;  /* Saved value for Slow Rate calculation. */
    GT_U64      tempResult;         /* used for temp calculation with U64 */
    GT_U64      tempResult1;        /* used for temp calculation with U64 */
    GT_U32      temp;
    GT_U32      tokensGran;         /* HW granularity */
    GT_STATUS   rc;
    GT_BOOL     isCpu;
    GT_U32      maxTokenRefill;

    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_FALSE)
    {
        maxTokenRefill = PRV_CPSS_DXCH_TXQREV1_TOKENS_REFILL_MAX_CNS;
    }
    else
    {
        if(isMllShaper) {
            maxTokenRefill = PRV_CPSS_DXCH_TXQREV1_TOKENS_REFILL_MAX_CNS;
        }
        else{
            maxTokenRefill = PRV_CPSS_DXCH_TXQREV1_SIP5_TOKENS_REFILL_MAX_CNS;
        }
    }

    /* After each adding tokens to the bucket                                        */
    /* the amount of tokens in the bucket immediately reduced to maximal bucket size */
    /* and the redundant tokens are lost.                                            */
    /* Amount of added tokens should not be greater then maximal bucket size,        */
    /* otherwise tokens will be lost and the planned rate will not be reached.       */
    /* burstSize == 0 should be ignored (used for debugging only)                    */
    if ((burstSize > 0) && (maxTokenRefill > burstSize))
    {
        maxTokenRefill = burstSize;
    }

    rc = cpssDxChPortPhysicalPortMapIsCpuGet(devNum, portNum, &isCpu);
    if (rc != GT_OK)
    {
        return rc;
    }

    tempResult.l[0] = tempResult.l[1] = 0;

    packetLengthBits = ((isCpu == GT_TRUE) ?
        shaperConfigPtr->cpuPacketLength :
    shaperConfigPtr->portsPacketLength) * 8;

    if (packetLengthBits != 0 && shaperMode == CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E)
    {
        tempResult1 = prvCpssMathMul64(tokenBucketRate, packetLengthBits);
        tempResult1 = prvCpssMathDiv64By16(tempResult1, 1000);
        tokenBucketRate = tempResult1.l[0];
    }

    coreClockInM = (GT_U16)PRV_CPSS_PP_MAC(devNum)->coreClock;

    switch(shaperConfigPtr->tokensRateGran)
    {
    case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_64_CORE_CLOCKS_E:
        tokensGran = 8;
        break;

    case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
        tokensGran = 128;
        break;

    case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_128_CORE_CLOCKS_E:
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            tokensGran = 16;
            break;
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_256_CORE_CLOCKS_E:
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            tokensGran = 32;
            break;
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    rateDivisor = shaperConfigPtr->tokensRate * tokensGran;

    TBIntervalUpdateRatio=11;
    do
    {
        TBIntervalUpdateRatio--;
        temp = ( 1 << TBIntervalUpdateRatio) * rateDivisor;
        tempResult = prvCpssMathMul64(tokenBucketRate,temp);
        tempResult = prvCpssMathDiv64By16(tempResult,coreClockInM);
        tempResult = prvCpssMathDiv64By16(tempResult,1000);
    }
    while ((TBIntervalUpdateRatio != 0) && ((tempResult.l[1] > 0) ||
    (tempResult.l[0] > maxTokenRefill)));

    /* check for minimum */
    if ((tempResult.l[0] == 0) && (tempResult.l[1] == 0))
    {
        tempResult.l[0] = 1;
    }

    /* check for maximum */
    if ((tempResult.l[1] > 0) || (tempResult.l[0] > maxTokenRefill))
    {
        tempResult.l[0] = maxTokenRefill;
        tempResult.l[1] = 0;

    }

    /* When token refill value is even:
    *  Halve both the token refill value and the update interval,
    *  it will not affect the traffic rate, and shaper burstiness will be improved.
    */
    TBIntervalUpdateRatioSaved = TBIntervalUpdateRatio;
    while ((TBIntervalUpdateRatio != 0) &&
    ((tempResult.l[0] % 2) == 0))
    {
        TBIntervalUpdateRatio--;
        tempResult.l[0] /= 2;
    }

    *slowRateEnPtr = GT_FALSE;
    *tokensPtr = tempResult.l[0];
    *tbUpdateRatioPtr = TBIntervalUpdateRatio;

    /* check if slowRate should be used */
    if(usePerTc == GT_TRUE ||
    (GT_FALSE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_LION_SLOW_RATE_ON_PORT_TB_NOT_SUPPORTED_WA_E)))
    {
        if ((1U << TBIntervalUpdateRatioSaved) < shaperConfigPtr->slowRateRatio)
        {
            temp = shaperConfigPtr->slowRateRatio * rateDivisor;
            tempResult = prvCpssMathMul64(tokenBucketRate,temp);
            tempResult = prvCpssMathDiv64By16(tempResult,coreClockInM);
            tempResult = prvCpssMathDiv64By16(tempResult,1000);

            if ((tempResult.l[1] == 0) && (tempResult.l[0] < maxTokenRefill))
            {
                *slowRateEnPtr = GT_TRUE;
                *tokensPtr = tempResult.l[0];
                *tbUpdateRatioPtr = TBIntervalUpdateRatioSaved;
            }
        }
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChPortTxShaperTokenBucketRateGet function
* @endinternal
*
* @brief   Get shaper parameters for token bucket per port / per port per queue:
*         - Token refill value.
*         - slow-rate mode.
*         - Bucket size.
*         - the shaping rate.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical port number
* @param[in] usePerTc                 - token bucket per port or per queue
* @param[in] tcQueue                  - traffic class queue on this Physical Port
* @param[in] xgPortsTokensRate        - tokens rate for XG ports' shapers
* @param[in] gigPortsTokensRate       - tokens rate for Tri Speed ports' shapers
* @param[in] gigPortsSlowRateRatio    - slow rate ratio for Tri Speed ports. Tokens Update
*                                      rate for ports with slow rate divided to the ratio.
* @param[in] stackAsGig               - GT_TRUE, stacking ports shapers operates
*                                      as Tri Speed ports' shapers.
*                                      GT_FALSE, stacking ports shapers operates as XG ports.
*
* @param[out] tokenBucketEnPtr         - (pointer to) Bucket enable status.
* @param[out] tokenRefillValuePtr      - number of tokens added to the bucket on each update
*                                      cycle.
* @param[out] slowRateEnPtr            - Enable the division of <gigPortsTokensRate> by
* @param[out] gigPortsSlowRateRatio
* @param[out] burstSizePtr             - burst size.
* @param[out] tokenBucketRatePtr       - the shaping rate - actual Rate in Kbps.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*
* @note 1. If the Token Bucket rate shaping is disabled then shaping rate returned
*       is set to 0.
*       2. Txq revision 1 is not supported by this function.
*
*/
static GT_STATUS prvCpssDxChPortTxShaperTokenBucketRateGet
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    GT_BOOL                 usePerTc,
    IN    GT_U32                  tcQueue,
    IN    GT_U32                  xgPortsTokensRate,
    IN    GT_U32                  gigPortsTokensRate,
    IN    GT_U32                  gigPortsSlowRateRatio,
    IN    GT_BOOL                 stackAsGig,
    OUT   GT_BOOL                 *tokenBucketEnPtr,
    OUT   GT_U32                  *tokenRefillValuePtr,
    OUT   GT_U32                  *slowRateEnPtr,
    OUT   GT_U16                  *burstSizePtr,
    OUT   GT_U32                  *tokenBucketRatePtr
)
{
    GT_U32      regAddr;    /* register address                 */
    GT_U32      offset;     /* field offset                     */
    GT_U32      len;
    GT_U32      value;      /* value to write into register     */

    PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum,portNum);

    /* cannot devide in zero. see prvDxChPortTxCalcShaperTokenBucketRate */
    if((xgPortsTokensRate == 0) || (gigPortsTokensRate == 0))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    /* Get port Token bucket configuration register */
    if(usePerTc == GT_FALSE)
    {
        /* token bucket per port */
        PRV_CPSS_DXCH_PORT_TOKEN_BUCKET_REG_MAC(devNum,portNum,&regAddr);
    }
    else
    {
        /* token bucket per port per queue */
        PRV_CPSS_DXCH_PORT_Q_TOKEN_BUCKET_REG_MAC(devNum,portNum,tcQueue,&regAddr);
    }

    /* read the Token Bucket Configuration register values */
    offset = 0;
    len = 28;

    if (prvCpssHwPpPortGroupGetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
        regAddr, offset, len, &value) != GT_OK)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

    *tokenBucketEnPtr = (value & 0x1);
    *slowRateEnPtr = (value >>
    (PRV_CPSS_DXCH_TOKEN_BUCKET_SLOW_RATE_EN_OFFSET_CNS - offset)) & 0x1;
    *tokenRefillValuePtr = (value >>
    (PRV_CPSS_DXCH_TOKEN_BUCKET_TOKENS_OFFSET_CNS - offset)) & 0xFFF;
    *burstSizePtr = (GT_U16)((value >> 16) & 0xFFF);

    if (*tokenBucketEnPtr == GT_FALSE)
    {
        return GT_OK;
    }

    return prvDxChPortTxCalcShaperTokenBucketRate(devNum,
        portNum,
        xgPortsTokensRate,
        gigPortsTokensRate,
        gigPortsSlowRateRatio,
        *tokenRefillValuePtr,
        *slowRateEnPtr,
        stackAsGig,
        tokenBucketRatePtr);

}

/**
* @internal prvDxChPortTxSetShaperTokenBucketParams function
* @endinternal
*
* @brief   Set shaper paramters for token bucket per port / per port per queue.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical port number
* @param[in] usePerTc                 - token bucket per port or per queue
* @param[in] tcQueue                  - traffic class queue on this Physical Port
* @param[in] xgPortsTokensRate        - old tokens rate for XG ports' shapers
* @param[in] gigPortsTokensRate       - old tokens rate for Tri Speed ports' shapers
* @param[in] gigPortsSlowRateRatio    - old slow rate ratio for Tri Speed ports. Tokens
*                                      Update rate for ports with slow rate divided to
*                                      the ratio.
* @param[in] old_StackAsGig           - old stacking ports shaper mode
* @param[in] xgPortsTokensRate        - tokens rate for XG ports' shapers
* @param[in] gigPortsTokensRate       - tokens rate for Tri Speed ports' shapers
* @param[in] gigPortsSlowRateRatio    - slow rate ratio for Tri Speed ports. Tokens Update
*                                      rate for ports with slow rate divided to the ratio.
* @param[in] stackAsGig               - GT_TRUE, stacking ports shapers operates
*                                      as Tri Speed ports' shapers.
*                                      GT_FALSE, stacking ports shapers operates as XG ports.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
*
* @note Txq revision 1 is not supported by this function.
*
*/
static GT_STATUS prvDxChPortTxSetShaperTokenBucketParams
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    GT_BOOL                 usePerTc,
    IN    GT_U32                  tcQueue,
    IN    GT_U32                  old_xgPortsTokensRate,
    IN    GT_U32                  old_gigPortsTokensRate,
    IN    GT_U32                  old_gigPortsSlowRateRatio,
    IN    GT_BOOL                 old_StackAsGig,
    IN    GT_U32                  xgPortsTokensRate,
    IN    GT_U32                  gigPortsTokensRate,
    IN    GT_U32                  gigPortsSlowRateRatio,
    IN    GT_BOOL                 stackAsGig
)
{
    GT_U32      regAddr;    /* register address                 */
    GT_U32      offset;     /* field offset                     */
    GT_U32      len;
    GT_U32      value;      /* value to write into register     */
    GT_U32      tokenRefillValue;
    GT_U32      slowRateEn;
    GT_STATUS   rc;
    GT_BOOL     tokenBucketEn;
    GT_U32      tokenBucketRate;
    GT_U16      burstSize;

    rc = prvCpssDxChPortTxShaperTokenBucketRateGet(devNum,
        portNum,
        usePerTc,
        tcQueue,
        old_xgPortsTokensRate,
        old_gigPortsTokensRate,
        old_gigPortsSlowRateRatio,
        old_StackAsGig,
        &tokenBucketEn,
        &tokenRefillValue,
        &slowRateEn,
        &burstSize,
        &tokenBucketRate);

    if (rc != GT_OK)
    {
        return rc;
    }

    /* The function should do nothing in the case disabled bucket. */
    if (tokenBucketEn == 0)
    {
        return GT_OK;
    }
    /* calculate with new params */
    rc = prvCpssDxChPortTxReCalcShaperTokenBucketRate(devNum,
        portNum,
        xgPortsTokensRate,
        gigPortsTokensRate,
        gigPortsSlowRateRatio,
        stackAsGig,
        &tokenRefillValue,
        &slowRateEn,
        tokenBucketRate);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* tokenRefillValue should never be 0. */
    if (tokenRefillValue == 0)
    {
        tokenRefillValue = 1;
    }

    /* Get port Token bucket configuration register */
    if(usePerTc == GT_FALSE)
    {
        PRV_CPSS_DXCH_PORT_TOKEN_BUCKET_REG_MAC(devNum,portNum,&regAddr);
    }
    else
    {
        PRV_CPSS_DXCH_PORT_Q_TOKEN_BUCKET_REG_MAC(devNum,portNum,tcQueue,&regAddr);
    }

    value = slowRateEn | ((tokenRefillValue & 0xFFF) << 3);
    offset = 1;
    len = 15;
    if (prvCpssHwPpPortGroupSetRegField(devNum, PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum),
        regAddr, offset, len, value) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}


/**
* @internal prvDxChPortTxSetShaperTokenBucketParams_rev1 function
* @endinternal
*
* @brief   Set shaper parameters for token bucket per port / per port per queue.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical port number
* @param[in] shaperMode               - shaper mode
* @param[in] usePerTc                 - are we use 'per port' or 'per port per TC'
* @param[in] tcQueue                  - traffic class queue on this Physical Port
* @param[in] oldShaperConfigPtr       - (pointer to) old shaper global configurations
* @param[in] newShaperConfigPtr       - (pointer to) new shaper global configurations
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
*
* @note Only Txq revision 1 is supported by this function.
*
*/
static GT_STATUS prvDxChPortTxSetShaperTokenBucketParams_rev1
(
    IN GT_U8                               devNum,
    IN GT_PHYSICAL_PORT_NUM                portNum,
    IN CPSS_PORT_TX_DROP_SHAPER_MODE_ENT   shaperMode,
    IN GT_BOOL                             usePerTc,
    IN GT_U32                              tcQueue,
    IN CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC *oldShaperConfigPtr,
    IN CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC *newShaperConfigPtr
)
{
    PORT_TX_SHAPER_TOKEN_BUCKET_STC subEntry; /* sub entry format */
    GT_STATUS   rc;                /* return code */
    GT_U32      tokenBucketRate;   /* TB rate in Kbps or pps */
    GT_BOOL     slowRateEn;        /* slow rate enable */
    GT_U32      tbUpdateRatio;     /* TB interval update ratio value */
    GT_U32      tokenRefillValue;  /* TB refill value */
    GT_U32      baseline;         /* baseline value */

    /* get global shaper baseline */
    rc = cpssDxChPortTxShaperBaselineGet(devNum,&baseline);
    if (rc != GT_OK)
    {
        return rc;
    }

    rc = portTxShaperTokenBucketEntryRead_rev1(devNum,portNum,usePerTc,tcQueue,&subEntry);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* The function should do nothing in the case disabled bucket. */
    if(subEntry.tokenBucketEn == GT_FALSE)
    {
        return GT_OK;
    }

    /* calculate the rate */
    rc = prvDxChPortTxCalcShaperTokenBucketRate_rev1(devNum,
        portNum,
        oldShaperConfigPtr,
        shaperMode,
        subEntry.slowRateEn,
        subEntry.tbUpdateRatio,
        subEntry.tokens,
        &tokenBucketRate);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* calculate per TB configurations with new global shaper configurations */
    rc = prvCpssDxChPortTxReCalcShaperTokenBucketRate_rev1(devNum,
        portNum,
        usePerTc,
        newShaperConfigPtr,
        shaperMode,
        tokenBucketRate,
    (subEntry.maxBucketSize * _4K) -
        baseline,
        GT_FALSE,
        &slowRateEn,
        &tbUpdateRatio,
        &tokenRefillValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* update the TB entry */
    rc = prvCpssDxChPortTxShaperTokenBucketEntryWrite_rev1(devNum,portNum,
        usePerTc,tcQueue,
        slowRateEn,
        tbUpdateRatio,
        tokenRefillValue,
        subEntry.maxBucketSize,
        GT_FALSE, 0);
    return rc;
}


/**
* @internal prvCpssDxChPortIpmBridgeCopyGetDroppedWaTailDropMaxLimitsSet function
* @endinternal
*
* @brief   Set tail drop max limit for WA of IPM Bridge Copy Dropped errata
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - success
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS prvCpssDxChPortIpmBridgeCopyGetDroppedWaTailDropMaxLimitsSet
(
    IN GT_U8 devNum
)
{
    GT_STATUS   rc = GT_OK;

    GT_U8     trafficClass;
    GT_U32    portMaxBuffLimit;
    GT_U32    portMaxDescrLimit;
    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet;
    CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC tailDropProfileParamsGet;
    CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC tailDropProfileParams;
    CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_ENT alpha;

    /*  per TC and DP - Keep Limit values in a shadow */
    for(profileSet = CPSS_PORT_TX_DROP_PROFILE_1_E;
        profileSet <= CPSS_PORT_TX_DROP_PROFILE_8_E;
        profileSet++)
    {
        rc = cpssDxChPortTxTailDropProfileGet(devNum,
            profileSet,
            &alpha,
            &portMaxBuffLimit,
            &portMaxDescrLimit);
        if(rc != GT_OK)
        {
            return rc;
        }

        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
            profileInfo[profileSet].portMaxBuffLimit = portMaxBuffLimit;
        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
            profileInfo[profileSet].portMaxDescrLimit = portMaxDescrLimit;

        for (trafficClass = 0; trafficClass < CPSS_TC_RANGE_CNS; trafficClass++)
        {
            rc = cpssDxChPortTx4TcTailDropProfileGet(devNum,
                profileSet,
                trafficClass,
                &tailDropProfileParamsGet);
            if(rc != GT_OK)
            {
                return rc;
            }

            PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.profileInfo[profileSet].
                tailDropProfileParamsArray[trafficClass] = tailDropProfileParamsGet;
        }
    }

    /* per TC and DP - Set Limits to be MAX_LIMITS  */
    tailDropProfileParams.dp0MaxBuffNum=PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_MAX_CNS;
    tailDropProfileParams.dp1MaxBuffNum=PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_MAX_CNS;
    tailDropProfileParams.dp2MaxBuffNum=PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_MAX_CNS;
    tailDropProfileParams.dp0MaxDescrNum=PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_MAX_CNS;
    tailDropProfileParams.dp1MaxDescrNum=PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_MAX_CNS;
    tailDropProfileParams.dp2MaxDescrNum=PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_MAX_CNS;
    tailDropProfileParams.tcMaxBuffNum=PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_MAX_CNS;
    tailDropProfileParams.tcMaxDescrNum=PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_MAX_CNS;
    tailDropProfileParams.dp0MaxMCBuffNum = 0;
    tailDropProfileParams.dp1MaxMCBuffNum = 0;
    tailDropProfileParams.dp2MaxMCBuffNum = 0;
    tailDropProfileParams.dp0MaxMCBuffNum = GT_FALSE;

    for(profileSet = CPSS_PORT_TX_DROP_PROFILE_1_E;
        profileSet <= CPSS_PORT_TX_DROP_PROFILE_8_E;
        profileSet++)
    {
        rc = cpssDxChPortTxTailDropProfileSet(devNum,
            profileSet,
            CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_0_E,
            PRV_CPSS_DXCH3_TC_DP_BUFFER_LIMIT_MAX_CNS,
            PRV_CPSS_DXCH3_TC_DP_DESC_LIMIT_MAX_CNS);

        if(rc != GT_OK)
        {
            return rc;
        }

        for (trafficClass = 0; trafficClass < CPSS_TC_RANGE_CNS; trafficClass++)
        {
            rc = cpssDxChPortTx4TcTailDropProfileSet(devNum,
                profileSet,
                trafficClass,
                &tailDropProfileParams);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }
    return rc;
}

/**
* @internal prvCpssDxChPortIpmBridgeCopyGetDroppedWaTailDropLimitsRestore function
* @endinternal
*
* @brief   Restore tail drop limit for WA of IPM Bridge Copy Dropped errata
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - success
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS prvCpssDxChPortIpmBridgeCopyGetDroppedWaTailDropLimitsRestore
(
    IN GT_U8 devNum
)
{
    GT_STATUS   rc = GT_OK;

    GT_U8     trafficClass;
    GT_U32    portMaxBuffLimit;
    GT_U32    portMaxDescrLimit;
    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet;
    CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC tailDropProfileParams;

    for(profileSet = CPSS_PORT_TX_DROP_PROFILE_1_E;
        profileSet <= CPSS_PORT_TX_DROP_PROFILE_8_E;
        profileSet++)
    {
        portMaxBuffLimit = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
            profileInfo[profileSet].portMaxBuffLimit;
        portMaxDescrLimit = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
            profileInfo[profileSet].portMaxDescrLimit;

        rc = cpssDxChPortTxTailDropProfileSet(devNum,
            profileSet,
            CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_0_E,
            portMaxBuffLimit,
            portMaxDescrLimit);
        if(rc != GT_OK)
        {
            return rc;
        }

        for (trafficClass = 0; trafficClass < CPSS_TC_RANGE_CNS; trafficClass++)
        {
            tailDropProfileParams = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                profileInfo[profileSet].tailDropProfileParamsArray[trafficClass];

            rc = cpssDxChPortTx4TcTailDropProfileSet(devNum,
            (CPSS_PORT_TX_DROP_PROFILE_SET_ENT)profileSet,
                trafficClass,
                &tailDropProfileParams);
            if(rc != GT_OK)
            {
                return rc;
            }

        }
    }
    return rc;
}
/**
* @internal internal_cpssDxChPortTxTailDropUcEnableSet function
* @endinternal
*
* @brief   Enable/Disable tail-dropping for all packets based on the profile limits.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   -  device number.
* @param[in] enable                   -  GT_TRUE  - Tail Drop is enabled.
*                                      GT_FALSE - The Tail Drop limits for all packets are
*                                      ignored and packet is dropped only
*                                      when the Tx Queue has reached its global
*                                      descriptors limit.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropUcEnableSet
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
{
    GT_U32      tailDropDisable;     /* whether to disable tail drop for uc */
    GT_U32      regAddr;             /* register address */
    GT_STATUS   rc = GT_OK;
    GT_U32      fieldOffset;         /* the start bit number in the register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled == GT_FALSE)
    {

        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.globalTailDropConfig;
            fieldOffset = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 7 : 6;

            rc = prvCpssHwPpSetRegField(devNum, regAddr, fieldOffset, 1, BOOL2BIT_MAC(enable));
        }
        else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            tailDropDisable = (enable == GT_TRUE)? 0 : 1;

            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfig;

            rc = prvCpssHwPpSetRegField(devNum, regAddr, 10, 1, tailDropDisable);
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.config.config;

            rc = prvCpssHwPpSetRegField(devNum, regAddr, 5, 1, BOOL2BIT_MAC(enable));
        }

        if(rc != GT_OK)
            return rc;
    }
    else
    {    /* If Lion2 errata is initialized then if the application call explicitly
         cpssDxChPortTxTailDropUcEnableSet(devNum, GT_TRUE) and the tail drop was disabled
         prior to the WA init then  need to return all the limits kept in the shadow */
        if (enable == GT_TRUE)
        {
            if(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.tailDropUcEnable == GT_FALSE)
            {
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.tailDropUcEnable = GT_TRUE;

                rc = prvCpssDxChPortIpmBridgeCopyGetDroppedWaTailDropLimitsRestore(devNum);
                if(rc != GT_OK)
                {
                    return rc;
                }

            }
            else
            {
                /* nothing to do, already in enable mode */
            }
        }
        else/* (enable == GT_FALSE) */
        {
            if(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.tailDropUcEnable == GT_TRUE)
            {
                /* per TC and DP - Keep Limit values in a shadow and Set Limits to be MAX_LIMITS  */
                rc = prvCpssDxChPortIpmBridgeCopyGetDroppedWaTailDropMaxLimitsSet(devNum);
                if(rc != GT_OK)
                {
                    return rc;
                }

                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.tailDropUcEnable = GT_FALSE;
            }
            else
            {
                /* nothing to do, already in disable mode - meaning limits are at max value */
            }
        }
    }

    return rc;
}

/**
* @internal cpssDxChPortTxTailDropUcEnableSet function
* @endinternal
*
* @brief   Enable/Disable tail-dropping for all packets based on the profile limits.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   -  device number.
* @param[in] enable                   -  GT_TRUE  - Tail Drop is enabled.
*                                      GT_FALSE - The Tail Drop limits for all packets are
*                                      ignored and packet is dropped only
*                                      when the Tx Queue has reached its global
*                                      descriptors limit.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropUcEnableSet
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropUcEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPortTxTailDropUcEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropUcEnableGet function
* @endinternal
*
* @brief   Get enable/disable tail-dropping for all packets based on the profile limits.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   -  device number.
*
* @param[out] enablePtr                -  pointer to tail drop status:
*                                      GT_TRUE  - Tail Drop is enabled.
*                                      GT_FALSE - The Tail Drop limits for all packets are
*                                      ignored and packet is dropped only
*                                      when the Tx Queue has reached its global
*                                      descriptors limit.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropUcEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_U32      value;     /* whether to disable tail drop for uc         */
    GT_U32      regAddr;             /* register address */
    GT_STATUS   rc;                  /* function return value            */
    GT_U32      fieldOffset;         /* the start bit number in the register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    /* If Lion2 errata is initialized get enable status set by the application
    and not by the WA (Because tail drop always enabled in such case)  */
    if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled == GT_TRUE)
    {
        *enablePtr =  PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.tailDropUcEnable;
        return GT_OK;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.globalTailDropConfig;
        fieldOffset = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 7 : 6;

        rc = prvCpssHwPpGetRegField(devNum, regAddr, fieldOffset, 1, &value);

        *enablePtr = BIT2BOOL_MAC(value);
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfig;

        rc =  prvCpssHwPpGetRegField(devNum, regAddr, 10, 1, &value);

        *enablePtr = (value == 0) ? GT_TRUE : GT_FALSE;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.config.config;

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 5, 1, &value);

        *enablePtr = BIT2BOOL_MAC(value);
    }

    return rc;
}

/**
* @internal cpssDxChPortTxTailDropUcEnableGet function
* @endinternal
*
* @brief   Get enable/disable tail-dropping for all packets based on the profile limits.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   -  device number.
*
* @param[out] enablePtr                -  pointer to tail drop status:
*                                      GT_TRUE  - Tail Drop is enabled.
*                                      GT_FALSE - The Tail Drop limits for all packets are
*                                      ignored and packet is dropped only
*                                      when the Tx Queue has reached its global
*                                      descriptors limit.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropUcEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropUcEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPortTxTailDropUcEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxBufferTailDropEnableSet function
* @endinternal
*
* @brief   Enable/disable Tail Drop according to the number of buffers in the
*         queues.
*
* @note   APPLICABLE DEVICES:          xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number.
* @param[in] enable                   -  GT_TRUE  -  Enables Tail Drop according to the number of
*                                      buffers in the queues. Tail drop use both
*                                      decsriptiors and buffers limits.
*                                      GT_FALSE - Tail drop use only descriptor limits.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxBufferTailDropEnableSet
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
{
    GT_U32  value;            /* value to set to register  */
    GT_U32  regAddr;          /* register address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    value = BOOL2BIT_MAC(enable);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfigExt;

    return prvCpssHwPpSetRegField(devNum, regAddr, 23, 1, value);
}

/**
* @internal cpssDxChPortTxBufferTailDropEnableSet function
* @endinternal
*
* @brief   Enable/disable Tail Drop according to the number of buffers in the
*         queues.
*
* @note   APPLICABLE DEVICES:          xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number.
* @param[in] enable                   -  GT_TRUE  -  Enables Tail Drop according to the number of
*                                      buffers in the queues. Tail drop use both
*                                      decsriptiors and buffers limits.
*                                      GT_FALSE - Tail drop use only descriptor limits.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxBufferTailDropEnableSet
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxBufferTailDropEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPortTxBufferTailDropEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxBufferTailDropEnableGet function
* @endinternal
*
* @brief   Get enable/disable Tail Drop status according to the number of buffers
*         in the queues.
*
* @note   APPLICABLE DEVICES:          xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number.
*
* @param[out] enablePtr                -  pointer to Tail Drop status:
*                                      GT_TRUE  - Enables Tail Drop according to the number of
*                                      buffers in the queues. Tail drop use both
*                                      decsriptiors and buffers limits.
*                                      GT_FALSE - Tail drop use only descriptor limits.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxBufferTailDropEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_U32      value;     /* value to read from the register  */
    GT_U32      regAddr;   /* register address */
    GT_STATUS   rc;        /* function return value            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfigExt;

    rc =  prvCpssHwPpGetRegField(devNum, regAddr, 23, 1, &value);
    if(rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/**
* @internal cpssDxChPortTxBufferTailDropEnableGet function
* @endinternal
*
* @brief   Get enable/disable Tail Drop status according to the number of buffers
*               in the queues.
*
* @note   APPLICABLE DEVICES:          xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number.
*
* @param[out] enablePtr                -  pointer to Tail Drop status:
*                                      GT_TRUE  - Enables Tail Drop according to the number of
*                                      buffers in the queues. Tail drop use both
*                                      decsriptiors and buffers limits.
*                                      GT_FALSE - Tail drop use only descriptor limits.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxBufferTailDropEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxBufferTailDropEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPortTxBufferTailDropEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxBuffersSharingMaxLimitSet function
* @endinternal
*
* @brief   Sets the maximal number of shared buffers in a Tail Drop system.
*         When the total number of buffers exceeds this threshold, all of the
*         shared buffers are currently used and packets are queued according to
*         their target queue guaranteed limits.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] limit                    - maximal number of shared buffers in a Tail Drop system.
*                                      For xCat3: range 0..0x3FFF
*                                      To disable Buffers Sharing for Transmit queues
*                                      set this field to 0.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxBuffersSharingMaxLimitSet
(
    IN  GT_U8       devNum,
    IN  GT_U32      limit
)
{
    GT_U32 regAddr;          /* register address */
    GT_U32 fieldLength;      /* The number of bits to be written to register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if(limit > 0x3FFF)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }
    fieldLength = 14;

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.bufMngSharedBufConfigReg;

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, fieldLength, limit);

}

/**
* @internal cpssDxChPortTxBuffersSharingMaxLimitSet function
* @endinternal
*
* @brief   Sets the maximal number of shared buffers in a Tail Drop system.
*         When the total number of buffers exceeds this threshold, all of the
*         shared buffers are currently used and packets are queued according to
*         their target queue guaranteed limits.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] limit                    - maximal number of shared buffers in a Tail Drop system.
*                                      For xCat3: range 0..0x3FFF
*                                      To disable Buffers Sharing for Transmit queues
*                                      set this field to 0.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxBuffersSharingMaxLimitSet
(
    IN  GT_U8       devNum,
    IN  GT_U32      limit
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxBuffersSharingMaxLimitSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, limit));

    rc = internal_cpssDxChPortTxBuffersSharingMaxLimitSet(devNum, limit);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, limit));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxBuffersSharingMaxLimitGet function
* @endinternal
*
* @brief   Gets the maximal number of shared buffers in a Tail Drop system.
*         When the total number of buffers exceeds this threshold, all of the
*         shared buffers are currently used and packets are queued according to
*         their target queue guaranteed limits.
*
* @note   APPLICABLE DEVICES:     xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] limitPtr                 -  pointer to maximal number of shared buffers
*                                      in a Tail Drop system
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxBuffersSharingMaxLimitGet
(
    IN  GT_U8       devNum,
    OUT GT_U32      *limitPtr
)
{
    GT_U32    regAddr;        /* register address */
    GT_U32    fieldLength;    /* The number of bits to be written to register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(limitPtr);

    fieldLength = 14;

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.bufMngSharedBufConfigReg;

    return prvCpssHwPpGetRegField(devNum, regAddr, 0, fieldLength, limitPtr);
}

/**
* @internal cpssDxChPortTxBuffersSharingMaxLimitGet function
* @endinternal
*
* @brief   Gets the maximal number of shared buffers in a Tail Drop system.
*         When the total number of buffers exceeds this threshold, all of the
*         shared buffers are currently used and packets are queued according to
*         their target queue guaranteed limits.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] limitPtr                 -  pointer to maximal number of shared buffers
*                                      in a Tail Drop system
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxBuffersSharingMaxLimitGet
(
    IN  GT_U8       devNum,
    OUT GT_U32      *limitPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxBuffersSharingMaxLimitGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, limitPtr));

    rc = internal_cpssDxChPortTxBuffersSharingMaxLimitGet(devNum, limitPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, limitPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxDp1SharedEnableSet function
* @endinternal
*
* @brief   Enable/Disable packets with DP1 (Red) to use the shared
*         descriptors / buffers pool.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE   - Allow DP1 (Red) in shared pool.
*                                      GT_FALSE  - Disallow DP1 to be shared.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxDp1SharedEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_U32      value;      /* value to write */
    GT_U32      regAddr;    /* register address */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    /* write enable value */
    value = BOOL2BIT_MAC(enable);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueDpToCfiReg;

    return prvCpssHwPpSetRegField(devNum, regAddr, 5, 1, value);
}

/**
* @internal cpssDxChPortTxDp1SharedEnableSet function
* @endinternal
*
* @brief   Enable/Disable packets with DP1 (Red) to use the shared
*         descriptors / buffers pool.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5 .
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE   - Allow DP1 (Red) in shared pool.
*                                      GT_FALSE  - Disallow DP1 to be shared.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxDp1SharedEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxDp1SharedEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPortTxDp1SharedEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxDp1SharedEnableGet function
* @endinternal
*
* @brief   Gets current status of shared descriptors / buffer pool usage
*         for packets with DP1 (Red).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5 .
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - pointer to current status of
*                                      shared  descroptors / Buffers pool usage:
*                                      - GT_TRUE   - Allow DP1 (Red) in shared pool.
*                                      - GT_FALSE  - Allow DP0 (Green) only in shared pool.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxDp1SharedEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32      value;      /* register value */
    GT_U32      regAddr;    /* register address */
    GT_STATUS   rc;         /* function return code */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueDpToCfiReg;
    rc = prvCpssHwPpGetRegField(devNum, regAddr, 5, 1, &value);
    if( GT_OK != rc )
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/**
* @internal cpssDxChPortTxDp1SharedEnableGet function
* @endinternal
*
* @brief   Gets current status of shared descriptors / buffer pool usage
*         for packets with DP1 (Red).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5 .
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - pointer to current status of
*                                      shared  descroptors / Buffers pool usage:
*                                      - GT_TRUE   - Allow DP1 (Red) in shared pool.
*                                      - GT_FALSE  - Allow DP0 (Green) only in shared pool.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxDp1SharedEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxDp1SharedEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPortTxDp1SharedEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTcSharedProfileEnableSet function
* @endinternal
*
* @brief   Enable/Disable usage of the shared descriptors / buffer pool for
*         packets with the traffic class (tc) that are transmited via a
*         port that is associated with the Profile (pfSet).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
* @param[in] tc                       - the Traffic Class, range 0..7.
* @param[in] enableMode               - Drop Precedence (DPs) enabled mode for sharing.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, pfSet
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTcSharedProfileEnableSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT       pfSet,
    IN  GT_U8                                   tc,
    IN  CPSS_PORT_TX_SHARED_DP_MODE_ENT         enableMode
)
{
    GT_U32      regAddr;    /* register address                 */
    GT_U32      offset;     /* field offset                     */
    GT_U32      value;      /* value to write into register     */
    GT_U32      fieldLen;   /* register field length            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);


    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(pfSet, devNum);



    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        switch(enableMode)
        {
        case CPSS_PORT_TX_SHARED_DP_MODE_ALL_E:     value = 2;
            break;
        case CPSS_PORT_TX_SHARED_DP_MODE_DISABLE_E: value = 3;
            break;
        case CPSS_PORT_TX_SHARED_DP_MODE_DP0_E:     value = 0;
            break;
        case CPSS_PORT_TX_SHARED_DP_MODE_DP0_DP1_E: value = 1;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        offset = pfSet * 2;
        fieldLen = 2;

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profilePriorityQueueEnablePoolUsage[tc];
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        /* write enable value */
        switch(enableMode)
        {
        case CPSS_PORT_TX_SHARED_DP_MODE_DISABLE_E: value = 0;
            break;
        case CPSS_PORT_TX_SHARED_DP_MODE_ALL_E:     value = 1;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        if(pfSet/4 >= 2)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        /* Shared priority register0: tc 0 - 3,
        Shared priority register1: tc 4 - 7 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            egrTxQConf.txQueueSharedPriorityReg[pfSet/4];

        offset = tc + (pfSet % 4) * 8;

        fieldLen = 1;
    }
    else
    {
        switch(enableMode)
        {
        case CPSS_PORT_TX_SHARED_DP_MODE_ALL_E:     value = 2;
            break;
        case CPSS_PORT_TX_SHARED_DP_MODE_DISABLE_E: value = 3;
            break;
        case CPSS_PORT_TX_SHARED_DP_MODE_DP0_E:     value = 0;
            break;
        case CPSS_PORT_TX_SHARED_DP_MODE_DP0_DP1_E: value = 1;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        offset = pfSet * 2;

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.
            tailDrop.config.tcProfileEnableSharedPoolUsage[tc];

        fieldLen = 2;
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, offset, fieldLen, value);
}

/**
* @internal cpssDxChPortTxTcSharedProfileEnableSet function
* @endinternal
*
* @brief   Enable/Disable usage of the shared descriptors / buffer pool for
*         packets with the traffic class (tc) that are transmited via a
*         port that is associated with the Profile (pfSet).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
* @param[in] tc                       - the Traffic Class, range 0..7.
* @param[in] enableMode               - Drop Precedence (DPs) enabled mode for sharing.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, pfSet
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTcSharedProfileEnableSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT       pfSet,
    IN  GT_U8                                   tc,
    IN  CPSS_PORT_TX_SHARED_DP_MODE_ENT         enableMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTcSharedProfileEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, pfSet, tc, enableMode));

    rc = internal_cpssDxChPortTxTcSharedProfileEnableSet(devNum, pfSet, tc, enableMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, pfSet, tc, enableMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTcSharedProfileEnableGet function
* @endinternal
*
* @brief   Gets usage of the shared descriptors / buffer pool status for
*         packets with the traffic class (tc) that are transmited via a
*         port that is associated with the Profile (pfSet).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
* @param[in] tc                       - the Traffic Class, range 0..7.
*
* @param[out] enableModePtr            - (pointer to) Drop Precedence (DPs) enabled mode for
*                                      sharing.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, pfSet
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTcSharedProfileEnableGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT       pfSet,
    IN  GT_U8                                   tc,
    OUT CPSS_PORT_TX_SHARED_DP_MODE_ENT         *enableModePtr
)
{
    GT_U32      regAddr;    /* register address                 */
    GT_U32      value;      /* value to write into register     */
    GT_U32      offset;     /* field offset                     */
    GT_STATUS   rc;         /* function return value            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(pfSet, devNum);
    CPSS_NULL_PTR_CHECK_MAC(enableModePtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        offset = pfSet * 2;

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profilePriorityQueueEnablePoolUsage[tc];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 2, &value);
        if( GT_OK != rc )
        {
            return rc;
        }

        switch(value)
        {
        case 0: *enableModePtr = CPSS_PORT_TX_SHARED_DP_MODE_DP0_E;
            break;
        case 1: *enableModePtr = CPSS_PORT_TX_SHARED_DP_MODE_DP0_DP1_E;
            break;
        case 2: *enableModePtr = CPSS_PORT_TX_SHARED_DP_MODE_ALL_E;
            break;
        case 3: *enableModePtr = CPSS_PORT_TX_SHARED_DP_MODE_DISABLE_E;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        if (pfSet > CPSS_PORT_TX_DROP_PROFILE_8_E)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* Shared priority register0: tc 0 - 3,
        Shared priority register1: tc 4 - 7 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            egrTxQConf.txQueueSharedPriorityReg[pfSet/4];

        offset = tc + (pfSet % 4) * 8;

        rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 1, &value);
        if( GT_OK != rc )
        {
            return rc;
        }

        *enableModePtr = (0 == value) ? CPSS_PORT_TX_SHARED_DP_MODE_DISABLE_E :
            CPSS_PORT_TX_SHARED_DP_MODE_ALL_E ;
    }
    else
    {
        offset = pfSet * 2;

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.
            tailDrop.config.tcProfileEnableSharedPoolUsage[tc];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 2, &value);
        if( GT_OK != rc )
        {
            return rc;
        }

        switch(value)
        {
        case 0: *enableModePtr = CPSS_PORT_TX_SHARED_DP_MODE_DP0_E;
            break;
        case 1: *enableModePtr = CPSS_PORT_TX_SHARED_DP_MODE_DP0_DP1_E;
            break;
        case 2: *enableModePtr = CPSS_PORT_TX_SHARED_DP_MODE_ALL_E;
            break;
        case 3: *enableModePtr = CPSS_PORT_TX_SHARED_DP_MODE_DISABLE_E;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxTcSharedProfileEnableGet function
* @endinternal
*
* @brief   Gets usage of the shared descriptors / buffer pool status for
*         packets with the traffic class (tc) that are transmited via a
*         port that is associated with the Profile (pfSet).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
* @param[in] tc                       - the Traffic Class, range 0..7.
*
* @param[out] enableModePtr            - (pointer to) Drop Precedence (DPs) enabled mode for
*                                      sharing.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, pfSet
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTcSharedProfileEnableGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT       pfSet,
    IN  GT_U8                                   tc,
    OUT CPSS_PORT_TX_SHARED_DP_MODE_ENT         *enableModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTcSharedProfileEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, pfSet, tc, enableModePtr));

    rc = internal_cpssDxChPortTxTcSharedProfileEnableGet(devNum, pfSet, tc, enableModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, pfSet, tc, enableModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperTokenBucketMtuSet function
* @endinternal
*
* @brief   Set Token bucket maximum transmission unit (MTU).
*         The token bucket MTU defines the minimum number of tokens required to
*         permit a packet to be transmitted (i.e., conforming).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] mtu                      - MTU for egress rate shaper
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, mtu
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxShaperTokenBucketMtuSet
(
    IN GT_U8                                  devNum,
    IN CPSS_DXCH_PORT_TX_TOKEN_BUCKET_MTU_ENT mtu
)
{
    GT_U32      regAddr;     /* register address */
    GT_U32      value;       /* value to write into register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    switch(mtu)
    {
    case CPSS_DXCH_PORT_TX_TOKEN_BUCKET_MTU_1_5K_E:
        value = 0;
        break;
    case CPSS_DXCH_PORT_TX_TOKEN_BUCKET_MTU_2K_E:
        value = 1;
        break;
    case CPSS_DXCH_PORT_TX_TOKEN_BUCKET_MTU_10K_E:
        value = 2;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* Set Token bucket maximum transmission unit */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfigExt;

    return prvCpssDrvHwPpSetRegField(devNum, regAddr, 3, 2, value);
}

/**
* @internal cpssDxChPortTxShaperTokenBucketMtuSet function
* @endinternal
*
* @brief   Set Token bucket maximum transmission unit (MTU).
*         The token bucket MTU defines the minimum number of tokens required to
*         permit a packet to be transmitted (i.e., conforming).
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] mtu                      - MTU for egress rate shaper
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, mtu
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxShaperTokenBucketMtuSet
(
    IN GT_U8                                  devNum,
    IN CPSS_DXCH_PORT_TX_TOKEN_BUCKET_MTU_ENT mtu
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperTokenBucketMtuSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mtu));

    rc = internal_cpssDxChPortTxShaperTokenBucketMtuSet(devNum, mtu);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mtu));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChPortTxShaperTokenBucketMtuGet
*
*       Get Token bucket maximum transmission unit (MTU).
*       The token bucket MTU defines the minimum number of tokens required to
*       permit a packet to be transmitted (i.e., conforming).
*
* APPLICABLE DEVICES:
*        xCat3; AC5.
*
* NOT APPLICABLE DEVICES:
*       Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* INPUTS:
*       devNum   - physical device number
*
* OUTPUTS:
*       mtuPtr   -  pointer to MTU for egress rate shaper
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChPortTxShaperTokenBucketMtuGet
(
    IN  GT_U8                                  devNum,
    OUT CPSS_DXCH_PORT_TX_TOKEN_BUCKET_MTU_ENT *mtuPtr
)
{
    GT_U32      regAddr;    /* register address                */
    GT_U32      value;      /* value to read from register     */
    GT_STATUS   rc;         /* function return value           */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(mtuPtr);

    /* Get Token bucket maximum transmission unit */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfigExt;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 3, 2, &value);

    if (rc != GT_OK)
        return rc;

    switch(value)
    {
    case 0:
        *mtuPtr = CPSS_DXCH_PORT_TX_TOKEN_BUCKET_MTU_1_5K_E;
        break;
    case 1:
        *mtuPtr = CPSS_DXCH_PORT_TX_TOKEN_BUCKET_MTU_2K_E;
        break;
    case 2:
        *mtuPtr = CPSS_DXCH_PORT_TX_TOKEN_BUCKET_MTU_10K_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/*******************************************************************************
* cpssDxChPortTxShaperTokenBucketMtuGet
*
*       Get Token bucket maximum transmission unit (MTU).
*       The token bucket MTU defines the minimum number of tokens required to
*       permit a packet to be transmitted (i.e., conforming).
*
* APPLICABLE DEVICES:
*        xCat3; AC5.
*
* NOT APPLICABLE DEVICES:
*      Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* INPUTS:
*       devNum   - physical device number
*
* OUTPUTS:
*       mtuPtr   -  pointer to MTU for egress rate shaper
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChPortTxShaperTokenBucketMtuGet
(
    IN  GT_U8                                  devNum,
    OUT CPSS_DXCH_PORT_TX_TOKEN_BUCKET_MTU_ENT *mtuPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperTokenBucketMtuGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mtuPtr));

    rc = internal_cpssDxChPortTxShaperTokenBucketMtuGet(devNum, mtuPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mtuPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxRandomTailDropEnableSet function
* @endinternal
*
* @brief   Enable/disable Random Tail drop Threshold, to overcome synchronization.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number.
* @param[in] enable                   -  GT_TRUE  -  Enable Random Tail drop Threshold.
*                                      GT_FALSE -  Disable Random Tail drop Threshold.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxRandomTailDropEnableSet
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
{
    GT_U32  value;            /* value to set to register  */
    GT_U32  regAddr;          /* register address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    value = BOOL2BIT_MAC(enable);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfigExt;

    return prvCpssDrvHwPpSetRegField(devNum, regAddr, 30, 1, value);
}

/**
* @internal cpssDxChPortTxRandomTailDropEnableSet function
* @endinternal
*
* @brief   Enable/disable Random Tail drop Threshold, to overcome synchronization.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number.
* @param[in] enable                   -  GT_TRUE  -  Enable Random Tail drop Threshold.
*                                      GT_FALSE -  Disable Random Tail drop Threshold.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxRandomTailDropEnableSet
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxRandomTailDropEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPortTxRandomTailDropEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxRandomTailDropEnableGet function
* @endinternal
*
* @brief   Get Random Tail drop Threshold status.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number.
*
* @param[out] enablePtr                -  pointer to Random Tail drop Threshold status:
*                                      GT_TRUE  - Random Tail drop Threshold enabled.
*                                      GT_FALSE - Random Tail drop Threshold disabled.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxRandomTailDropEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_U32      value;     /* value to read from the register  */
    GT_U32      regAddr;   /* register address */
    GT_STATUS   rc;        /* function return value            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfigExt;

    rc =  prvCpssHwPpGetRegField(devNum, regAddr, 30, 1, &value);
    if( GT_OK != rc )
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/**
* @internal cpssDxChPortTxRandomTailDropEnableGet function
* @endinternal
*
* @brief   Get Random Tail drop Threshold status.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number.
*
* @param[out] enablePtr                -  pointer to Random Tail drop Threshold status:
*                                      GT_TRUE  - Random Tail drop Threshold enabled.
*                                      GT_FALSE - Random Tail drop Threshold disabled.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxRandomTailDropEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxRandomTailDropEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPortTxRandomTailDropEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChTxPortShaperMaxValueSet function
* @endinternal
*
* @brief   Set Number Tokens and Bucket Size to a maximal values - 0xFFF
*         and disable slow rate
* @param[in] devNum                   - physical device number.
* @param[in] portGroupId              - The port group id. relevant only to 'multi-port-groups'
*                                      devices. Supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS
* @param[in] tokenBucketAddress       - token bucket register address
*
* @param[out] tokenBucketOldValuePtr   - pointer to old port (tc) token bucket register value
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS prvCpssDxChTxPortShaperMaxValueSet
(
    IN  GT_U8    devNum,
    IN  GT_U32   portGroupId,
    IN  GT_U32   tokenBucketAddress,
    OUT GT_U32  *tokenBucketOldValuePtr
)
{
    GT_U32      data;       /* register data */
    GT_STATUS   rc;

    /* read and store bucket parameters */
    rc = prvCpssHwPpPortGroupReadRegister(devNum, portGroupId, tokenBucketAddress, tokenBucketOldValuePtr);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Set Number Tokens and Bucket Size to a maximal values - 0xFFF
    and disable slow rate */
    data = (*tokenBucketOldValuePtr & 0xFFFFFFFD) | (0xFFFFFF << 4);

    return prvCpssHwPpPortGroupWriteRegister(devNum, portGroupId, tokenBucketAddress, data);
}

/**
* @internal prvCpssDxChTxPortShaperDisable function
* @endinternal
*
* @brief   Disable shaping and restore old values
*
* @param[in] devNum                   - physical device number.
* @param[in] portGroupId              - The port group id. relevant only to 'multi-port-groups'
*                                      devices. Supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS
* @param[in] tokenBucketAddress       - token bucket register address
* @param[in] tokenBucketOldValue      - old port (tc) token bucket register value
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS prvCpssDxChTxPortShaperDisable
(
    IN  GT_U8    devNum,
    IN  GT_U32   portGroupId,
    IN  GT_U32   tokenBucketAddress,
    IN  GT_U32   tokenBucketOldValue
)
{
    GT_STATUS   rc;         /* return code */

    /* disable shaping */
    rc = prvCpssHwPpPortGroupSetRegField(devNum, portGroupId, tokenBucketAddress, 0, 1, 0);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* restore old values */
    tokenBucketOldValue &= ~1;

    return prvCpssHwPpPortGroupWriteRegister(devNum, portGroupId, tokenBucketAddress, tokenBucketOldValue);
}

/* maximal port number for xCat3 and AC5 device (TxQ revision 0) */
#define PRV_CPSS_XCAT3_AC5_MAX_PORT_NUM_CNS 64

/**
 * @struct PRV_TX_XCAT3_SHAPER_TOKEN_BUCKET_VAR_STC
 *
 * @brief variables hold shapers configurations.
 */
typedef struct {
    /** port token bucket register value */
    GT_U32 portTbRegValue[PRV_CPSS_XCAT3_AC5_MAX_PORT_NUM_CNS];
    /** port's TC token bucket register value*/
    GT_U32 portTcTbRegValue[PRV_CPSS_XCAT3_AC5_MAX_PORT_NUM_CNS][CPSS_TC_RANGE_CNS];
} PRV_TX_XCAT3_SHAPER_TOKEN_BUCKET_VAR_STC;


/**
* @internal internal_cpssDxChTxPortAllShapersDisable function
* @endinternal
*
* @brief   Disables all ports and queues shapers for specified device in minimum delay.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_CPU_MEM        - on CPU memory allocation failure
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChTxPortAllShapersDisable
(
    IN  GT_U8    devNum
)
{
    GT_PHYSICAL_PORT_NUM  port;/* device port */
    GT_U8       queue;      /* port traffic class */
    GT_U32      regAddr;    /* register address */
    GT_STATUS   rc;         /* return code */
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    PRV_TX_XCAT3_SHAPER_TOKEN_BUCKET_VAR_STC * tbVarPtr; /* pointer to token bucket variables */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        tbVarPtr = cpssOsMalloc(sizeof(PRV_TX_XCAT3_SHAPER_TOKEN_BUCKET_VAR_STC));
        if (tbVarPtr == NULL)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }

        for (port = 0; port < PRV_CPSS_XCAT3_AC5_MAX_PORT_NUM_CNS; port++)
        {
            if (!PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, port) && port != CPSS_CPU_PORT_NUM_CNS)
                continue;

            /* Get port Token bucket configuration register */
            PRV_CPSS_DXCH_PORT_TOKEN_BUCKET_REG_MAC(devNum, port, &regAddr);

            portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, port);

            /* Set Number Tokens and Bucket Size to a maximal values - 0xFFF
            and disable slow rate */
            rc = prvCpssDxChTxPortShaperMaxValueSet(devNum,
                portGroupId,
                regAddr,
                &tbVarPtr->portTbRegValue[port]);
            /* Per port per traffic class (queue) */
            for (queue = 0; queue < CPSS_TC_RANGE_CNS; queue++)
            {
                PRV_CPSS_DXCH_PORT_Q_TOKEN_BUCKET_REG_MAC(devNum, port, queue, &regAddr);

                /* Set Number Tokens and Bucket Size to a maximal values - 0xFFF
                and disable slow rate */
                rc = prvCpssDxChTxPortShaperMaxValueSet(devNum,
                    portGroupId,
                    regAddr,
                    &tbVarPtr->portTcTbRegValue[port][queue]);
                if(rc != GT_OK)
                {
                    goto clean_exit;
                }
            }
        }
        /* wait at least 1 millisecond to guaranty bucket size will be > MTU.
        this avoid traffic stuck during shaper disable under traffic.*/
        cpssOsTimerWkAfter(1);

        for (port = 0; port < PRV_CPSS_XCAT3_AC5_MAX_PORT_NUM_CNS; port++)
        {
            if (!PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, port) && port != CPSS_CPU_PORT_NUM_CNS)
                continue;

            PRV_CPSS_DXCH_PORT_TOKEN_BUCKET_REG_MAC(devNum, port, &regAddr);

            portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, port);

            /* Disable shaping and restore old values */
            rc = prvCpssDxChTxPortShaperDisable(devNum,
                portGroupId,
                regAddr,
                tbVarPtr->portTbRegValue[port]);
            if(rc != GT_OK)
            {
                goto clean_exit;
            }
            /* Per port per traffic class (queue) */
            for (queue = 0; queue < CPSS_TC_RANGE_CNS; queue++)
            {
                PRV_CPSS_DXCH_PORT_Q_TOKEN_BUCKET_REG_MAC(devNum, port, queue, &regAddr);

                /* Disable shaping and restore old values */
                rc = prvCpssDxChTxPortShaperDisable(devNum,
                    portGroupId,
                    regAddr,
                    tbVarPtr->portTcTbRegValue[port][queue]);
                if(rc != GT_OK)
                {
                    goto clean_exit;
                }
            }
        }

        /* logic above done without errors */
        rc = GT_OK;

clean_exit:
        cpssOsFree(tbVarPtr);
        return rc;
    }
    else
    {
        return portTxShaperTokenBucketAllShapersDisable_rev1(devNum);
    }
}

/**
* @internal cpssDxChTxPortAllShapersDisable function
* @endinternal
*
* @brief   Disables all ports and queues shapers for specified device in minimum delay.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_CPU_MEM        - on CPU memory allocation failure
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChTxPortAllShapersDisable
(
    IN  GT_U8    devNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChTxPortAllShapersDisable);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum));

    rc = internal_cpssDxChTxPortAllShapersDisable(devNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChTxPortShapersDisable function
* @endinternal
*
* @brief   Disable Shaping on Port and all it's queues.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number.
* @param[in] port                     - physical or CPU  number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChTxPortShapersDisable
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM        port
)
{
    GT_U8       queue;      /* port traffic class */
    GT_U32      regAddr;    /* register address */
    GT_STATUS   rc;         /* return code */
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32      portTbRegValue;      /* port token bucket register value */
    GT_U32      portTcTbRegValue[8]; /* port, TC token bucket register value */
    GT_U32      txqPortNum;     /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, port, txqPortNum);


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, port);

        PRV_CPSS_DXCH_PORT_TOKEN_BUCKET_REG_MAC(devNum, port, &regAddr);

        /* Set Number Tokens and Bucket Size to a maximal values - 0xFFF
        and disable slow rate */
        rc = prvCpssDxChTxPortShaperMaxValueSet(devNum,
            portGroupId,
            regAddr,
            &portTbRegValue);
        if(rc != GT_OK)
        {
            return rc;
        }
        /* Per port per traffic class (queue) */
        for (queue = 0; queue < CPSS_TC_RANGE_CNS; queue++)
        {
            PRV_CPSS_DXCH_PORT_Q_TOKEN_BUCKET_REG_MAC(devNum, port, queue, &regAddr);

            /* Set Number Tokens and Bucket Size to a maximal values - 0xFFF
            and disable slow rate */
            rc = prvCpssDxChTxPortShaperMaxValueSet(devNum,
                portGroupId,
                regAddr,
                &portTcTbRegValue[queue]);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* Wait at least 1 millisecond to guaranty bucket size will be > MTU.
        this avoid traffic stuck during shaper disable under traffic.*/
        cpssOsTimerWkAfter(1);

        PRV_CPSS_DXCH_PORT_TOKEN_BUCKET_REG_MAC(devNum, port, &regAddr);

        /* Disable shaping and restore old values */
        rc = prvCpssDxChTxPortShaperDisable(devNum,
            portGroupId,
            regAddr,
            portTbRegValue);
        if(rc != GT_OK)
        {
            return rc;
        }
        /* Per port per traffic class (queue) */
        for (queue = 0; queue < CPSS_TC_RANGE_CNS; queue++)
        {
            PRV_CPSS_DXCH_PORT_Q_TOKEN_BUCKET_REG_MAC(devNum, port, queue, &regAddr);

            /* Disable shaping and restore old values */
            rc = prvCpssDxChTxPortShaperDisable(devNum,
                portGroupId,
                regAddr,
                portTcTbRegValue[queue]);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }
    else
    {
        rc = portTxShaperTokenBucketShapersDisable_rev1(devNum,port);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChTxPortShapersDisable function
* @endinternal
*
* @brief   Disable Shaping on Port and all it's queues.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number.
* @param[in] port                     - physical or CPU  number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChTxPortShapersDisable
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM        port
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChTxPortShapersDisable);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, port));

    rc = internal_cpssDxChTxPortShapersDisable(devNum, port);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, port));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal portTxShaperTokenBucketBuild function
* @endinternal
*
* @brief   build entry format for tx shaper token bucket configuration
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in,out] startHwArray             - pointer to start of HW format of the full entry
* @param[in] usePerTc                 - are we use 'per port' or 'per port per TC'
* @param[in] tc                       - traffic class , relevant when usePerTc = GT_TRUE
* @param[in] subEntryPtr              - (pointer to) entry when usePerTc = GT_FALSE
*                                  (pointer to) sub entry when usePerTc = GT_TRUE
* @param[in,out] startHwArray             - pointer to start of HW format of the full entry
*
* @param[out] maskPtr                  - (pointer to) mask buffer for HW entry with
*                                      raised bits appropriating to entry fields assigned
*                                      inside this function
*                                       GT_OK
*/
static GT_STATUS portTxShaperTokenBucketBuild
(
    IN    GT_U8   devNum,
    INOUT GT_U32  *startHwArray,
    OUT GT_U32    *maskPtr,
    IN    GT_BOOL usePerTc,
    IN    GT_U32  tc,
    IN    PORT_TX_SHAPER_TOKEN_BUCKET_STC *subEntryPtr
)
{
    GT_U32  startSubEntryOffset;/* offset till the sub entry  */
    GT_U32  offset;/* offset in side the sub entry */
    GT_U32  value;/* hwValue*/

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        startSubEntryOffset = (usePerTc == GT_TRUE) ? (61 * tc) : 0;

        value = BOOL2BIT_MAC(subEntryPtr->tokenBucketEn);
        offset = 0;
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),1,value);

        offset = 1;
        value = BOOL2BIT_MAC(subEntryPtr->slowRateEn);
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),1,value);

        offset = 2;
        value = subEntryPtr->tbUpdateRatio;
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),4,value);

        offset = 6;
        value = subEntryPtr->tokens;
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),18,value);

        offset = 24;
        value = subEntryPtr->maxBucketSize;
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),12,value);

        offset = 36;
        value = subEntryPtr->currentBucketSize;
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),24,value);

        value = BOOL2BIT_MAC(subEntryPtr->tokenBucketAvbEnabled);
        offset = 60;
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),1,value);

        raiseBitsInMemory(maskPtr, startSubEntryOffset, 61);
    }
    else
    {
        startSubEntryOffset = (usePerTc == GT_TRUE) ? (54 * tc) : 0;

        value = BOOL2BIT_MAC(subEntryPtr->tokenBucketEn);
        offset = 0;
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),1,value);

        offset = 1;
        value = BOOL2BIT_MAC(subEntryPtr->slowRateEn);
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),1,value);

        offset = 2;
        value = subEntryPtr->tbUpdateRatio;
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),4,value);

        offset = 6;
        value = subEntryPtr->tokens;
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),12,value);

        offset = 18;
        value = subEntryPtr->maxBucketSize;
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),12,value);

        offset = 30;
        value = subEntryPtr->currentBucketSize;
        U32_SET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),24,value);

        raiseBitsInMemory(maskPtr, startSubEntryOffset, 54);
    }

    return GT_OK;
}

/**
* @internal portTxShaperTokenBucketParse function
* @endinternal
*
* @brief   parse entry format from tx shaper token bucket configuration
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in] startHwArray             - pointer to start of HW format of the full entry
* @param[in] usePerTc                 - are we use 'per port' or 'per port per TC'
* @param[in] tc                       - traffic class , relevant when usePerTc = GT_TRUE
*
* @param[out] subEntryPtr              - (pointer to) entry when usePerTc = GT_FALSE
*                                  (pointer to) sub entry when usePerTc = GT_TRUE
*                                       GT_OK
*/
static GT_STATUS portTxShaperTokenBucketParse
(
    IN  GT_U8   devNum,
    IN  GT_U32  *startHwArray,
    IN  GT_BOOL usePerTc,
    IN  GT_U32  tc,
    OUT  PORT_TX_SHAPER_TOKEN_BUCKET_STC *subEntryPtr
)
{
    GT_U32  startSubEntryOffset;/* offset till the sub entry  */
    GT_U32  offset;/* offset in side the sub entry */
    GT_U32  value;/* hwValue*/

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        startSubEntryOffset = (usePerTc == GT_TRUE) ? (61 * tc) : 0;

        offset = 0;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),1,value);
        subEntryPtr->tokenBucketEn = BIT2BOOL_MAC(value);

        offset = 1;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),1,value);
        subEntryPtr->slowRateEn = BIT2BOOL_MAC(value);

        offset = 2;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),4,value);
        subEntryPtr->tbUpdateRatio = value;

        offset = 6;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),18,value);
        subEntryPtr->tokens = value;

        offset = 24;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),12,value);
        subEntryPtr->maxBucketSize = value;

        offset = 36;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),24,value);
        subEntryPtr->currentBucketSize = value;

        offset = 60;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),1,value);
        subEntryPtr->tokenBucketAvbEnabled = BIT2BOOL_MAC(value);

    }
    else
    {
        startSubEntryOffset = (usePerTc == GT_TRUE) ? (54 * tc) : 0;

        offset = 0;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),1,value);
        subEntryPtr->tokenBucketEn = BIT2BOOL_MAC(value);

        offset = 1;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),1,value);
        subEntryPtr->slowRateEn = BIT2BOOL_MAC(value);

        offset = 2;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),4,value);
        subEntryPtr->tbUpdateRatio = value;

        offset = 6;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),12,value);
        subEntryPtr->tokens = value;

        offset = 18;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),12,value);
        subEntryPtr->maxBucketSize = value;

        offset = 30;
        U32_GET_FIELD_IN_ENTRY_MAC(startHwArray,(offset + startSubEntryOffset),24,value);
        subEntryPtr->currentBucketSize = value;
    }

    return GT_OK;
}

/**
* @internal portTxShaperTokenBucketEntryWrite_rev1 function
* @endinternal
*
* @brief   write entry to tx shaper token bucket configuration
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number
* @param[in] usePerTc                 - are we use 'per port' or 'per port per TC'
* @param[in] tc                       - traffic class , relevant when usePerTc = GT_TRUE
* @param[in] subEntryPtr              - (pointer to) entry when usePerTc = GT_FALSE
*                                  (pointer to) sub entry when usePerTc = GT_TRUE
*                                       GT_OK
*
* @note Only Txq revision 1 is supported by this function.
*
*/
static GT_STATUS portTxShaperTokenBucketEntryWrite_rev1
(
    IN  GT_U8   devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_BOOL usePerTc,
    IN  GT_U32  tc,
    IN  PORT_TX_SHAPER_TOKEN_BUCKET_STC *subEntryPtr
)
{
    GT_U32  hwEntryArray[TXQ_SHAPER_ENTRY_WORDS_NUM_CNS];/* HW entry array */
    GT_U32  hwMaskArray[TXQ_SHAPER_ENTRY_WORDS_NUM_CNS];/* HW mask array */
    GT_STATUS rc;
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */
    CPSS_DXCH_TABLE_ENT tableType;
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);

    cpssOsMemSet(hwEntryArray, 0, sizeof(hwEntryArray));
    cpssOsMemSet(hwMaskArray,  0, sizeof(hwMaskArray));

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum, txqPortNum);

    if(usePerTc == GT_FALSE)
    {
        tableType =  CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG_E;
    }
    else
    {
        tableType =  CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG_E;
    }

    /* build the entry */
    rc = portTxShaperTokenBucketBuild(devNum, hwEntryArray, hwMaskArray, usePerTc,tc,subEntryPtr);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* write the entry */
    rc = prvCpssDxChPortGroupWriteTableEntryMasked(devNum,portGroupId,
        tableType,
        localPort,
        hwEntryArray,
        hwMaskArray);

    return rc;
}

/**
* @internal portTxShaperTokenBucketEntryRead_rev1 function
* @endinternal
*
* @brief   read entry from tx shaper token bucket configuration
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number
* @param[in] usePerTc                 - are we use 'per port' or 'per port per TC'
* @param[in] tc                       - traffic class , relevant when usePerTc = GT_TRUE
*
* @param[out] subEntryPtr              - (pointer to) entry when usePerTc = GT_FALSE
*                                  (pointer to) sub entry when usePerTc = GT_TRUE
*                                       GT_OK
*
* @note Only Txq revision 1 is supported by this function.
*
*/
static GT_STATUS portTxShaperTokenBucketEntryRead_rev1
(
    IN  GT_U8   devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_BOOL usePerTc,
    IN  GT_U32  tc,
    OUT PORT_TX_SHAPER_TOKEN_BUCKET_STC *subEntryPtr
)
{
    GT_U32  hwEntryArray[TXQ_SHAPER_ENTRY_WORDS_NUM_CNS];/* HW entry array */
    GT_STATUS rc;
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */
    CPSS_DXCH_TABLE_ENT tableType;
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,txqPortNum);

    if(usePerTc == GT_FALSE)
    {
        tableType =  CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG_E;
    }
    else
    {
        tableType =  CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG_E;
    }

    /* read the entry */
    rc = prvCpssDxChPortGroupReadTableEntry(devNum,portGroupId,
        tableType,
        localPort,
        hwEntryArray);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* parse the entry */
    rc = portTxShaperTokenBucketParse(devNum, hwEntryArray,usePerTc,tc,subEntryPtr);

    return rc;
}

/**
* @internal prvDxChPortTxShaperTokenBucketEntryRead_rev1 function
* @endinternal
*
* @brief   read entry from tx shaper token bucket configuration
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number
* @param[in] usePerTc                 - are we use 'per port' or 'per port per TC'
* @param[in] tc                       - traffic class , relevant when usePerTc = GT_TRUE
*
* @param[out] subEntryPtr              - (pointer to) entry when usePerTc = GT_FALSE
*                                  (pointer to) sub entry when usePerTc = GT_TRUE
*                                       GT_OK
*
* @note Only Txq revision 1 is supported by this function.
*
*/
GT_STATUS prvDxChPortTxShaperTokenBucketEntryRead_rev1
(
    IN  GT_U8   devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_BOOL usePerTc,
    IN  GT_U32  tc,
    OUT PORT_TX_SHAPER_TOKEN_BUCKET_STC *subEntryPtr
)
{
    return portTxShaperTokenBucketEntryRead_rev1(devNum,portNum,usePerTc,tc,subEntryPtr);
}
/**
* @internal prvCpssDxChPortTxShaperTokenBucketEntryWrite_rev1 function
* @endinternal
*
* @brief   Write entry to tx shaper token bucket configuration.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number
* @param[in] usePerTc                 - are we use 'per port' or 'per port per TC'
* @param[in] tc                       - traffic class , relevant when usePerTc = GT_TRUE
* @param[in] slowRateEn               - slow rate enable value
* @param[in] tbUpdateRatio            - TB interval update ratio value
* @param[in] tokens                   - TB refill value
* @param[in] maxBucketSize            - max Bucket Size
* @param[in] updCurrentBucketSize     - GT_TRUE: update CurrentBucketSize
*                                      GT_FALSE: don't update CurrentBucketSize
* @param[in] currentBucketSize        - current Bucket Size. Relevant only when
* @param[in] updCurrentBucketSize     is GT_TRUE.
*                                       GT_OK
*
* @note Only Txq revision 1 is supported by this function.
*
*/
GT_STATUS prvCpssDxChPortTxShaperTokenBucketEntryWrite_rev1
(
    IN  GT_U8   devNum,
    IN  GT_PHYSICAL_PORT_NUM   portNum,
    IN  GT_BOOL usePerTc,
    IN  GT_U32  tc,
    IN  GT_BOOL slowRateEn,
    IN  GT_U32  tbUpdateRatio,
    IN  GT_U32  tokens,
    IN  GT_U32  maxBucketSize,
    IN  GT_BOOL updCurrentBucketSize,
    IN  GT_U32  currentBucketSize
)
{
    GT_STATUS rc;
    PORT_TX_SHAPER_TOKEN_BUCKET_STC subEntry;

    /* read entry from HW */
    rc = portTxShaperTokenBucketEntryRead_rev1(devNum,portNum,usePerTc,tc,&subEntry);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* update the entry */
    subEntry.slowRateEn = slowRateEn;
    subEntry.tbUpdateRatio = tbUpdateRatio;
    subEntry.tokens = tokens;
    subEntry.maxBucketSize = maxBucketSize;

    if (updCurrentBucketSize == GT_TRUE)
    {
        subEntry.currentBucketSize = currentBucketSize;
    }

    /* write updated entry to HW */
    rc = portTxShaperTokenBucketEntryWrite_rev1(devNum,portNum,usePerTc,tc,&subEntry);
    return rc;
}


/**
* @internal portTxShaperTokenBucketEnable_rev1 function
* @endinternal
*
* @brief   enable entry to tx shaper token bucket configuration
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number
* @param[in] usePerTc                 - are we use 'per port' or 'per port per TC'
* @param[in] tc                       - traffic class , relevant when usePerTc = GT_TRUE
* @param[in] enable                   - GT_TRUE,  shaping
*                                      GT_FALSE, disable shaping
*                                       GT_OK
*
* @note Only Txq revision 1 is supported by this function.
*
*/
static GT_STATUS portTxShaperTokenBucketEnable_rev1
(
    IN  GT_U8   devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_BOOL usePerTc,
    IN  GT_U32  tc,
    IN  GT_BOOL enable
)
{
    GT_STATUS rc;
    PORT_TX_SHAPER_TOKEN_BUCKET_STC subEntry;
    PORT_TX_SHAPER_TOKEN_BUCKET_STC tmpSubEntry;

    /* read entry from HW */
    rc = portTxShaperTokenBucketEntryRead_rev1(devNum,portNum,usePerTc,tc,&subEntry);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Don't update if value remains the same */
    if (subEntry.tokenBucketEn == enable)
    {
        return GT_OK;
    }

    if((enable == GT_TRUE) ||
    (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E) == GT_FALSE))
    {
        /* update the entry */
        subEntry.tokenBucketEn = enable;

        /* write updated entry to HW */
        rc = portTxShaperTokenBucketEntryWrite_rev1(devNum,portNum,usePerTc,tc,&subEntry);
        return rc;
    }

    /*
    NOTE: next logic replace the  prvDxChShaperDisable(...)
    */

    /* Disabling the Egress Rate Shaper under traffic may hang its relevant transmit queue. (FEr#47) */

    tmpSubEntry = subEntry;
    /* Set Number Tokens and Bucket Size to a maximal values
    and disable slow rate */
    tmpSubEntry.slowRateEn = GT_FALSE;
    tmpSubEntry.tokens = PRV_CPSS_SIP_5_CHECK_MAC(devNum) ? 0x3FFFF : 0xFFF;
    tmpSubEntry.maxBucketSize = 0xFFF;
    tmpSubEntry.tbUpdateRatio = 0;

    /* write updated entry to HW */
    rc = portTxShaperTokenBucketEntryWrite_rev1(devNum,portNum,usePerTc,tc,&tmpSubEntry);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Token bucket update to new maximal values will be configured by next

    pulse of token bucket update clock. It's need to be done delay to
    disable token bucket to guaranty maximal values update.
    The delay need to be for time more than maximal token bucket update
    period - 15360 core clock cycles. For Core Clock 144MHz delay should be
    more than 100 micro seconds. */

    cpssOsTimerWkAfter(1);

    /* disable shaping */
    tmpSubEntry.tokenBucketEn = GT_FALSE;
    tmpSubEntry.currentBucketSize = 0xFFFFFF;

    /* write updated entry to HW */
    rc = portTxShaperTokenBucketEntryWrite_rev1(devNum,portNum,usePerTc,tc,&tmpSubEntry);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* restore old values */
    subEntry.tokenBucketEn = GT_FALSE;

    /* write updated entry to HW */
    return portTxShaperTokenBucketEntryWrite_rev1(devNum,portNum,usePerTc,tc,&subEntry);
}

/**
* @internal portTxShaperTokenBucketShapersDisableStage_rev1 function
* @endinternal
*
* @brief   Disable Shaping on Port and all it's queues.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - physical device number.
* @param[in] portNum                  - physical port number (CPU port supported as well as regular ports).
* @param[in] stage                    - disable stage.
* @param[in,out] origPortEntryPtr         - (pointer to) original port TB entry value.
* @param[in,out] tempPortEntryPtr         - (pointer to) temp port TB entry value.
* @param[in,out] origTcEntryPtr           - (pointer to) original port/tc TB entries.
* @param[in,out] tempTcEntryPtr           - (pointer to) temp port/tc TB entries.
* @param[in,out] origPortEntryPtr         - (pointer to) original port TB entry value.
* @param[in,out] tempPortEntryPtr         - (pointer to) temp port TB entry value.
* @param[in,out] origTcEntryPtr           - (pointer to) original port/tc TB entries.
* @param[in,out] tempTcEntryPtr           - (pointer to) temp port/tc TB entries.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Only Txq revision 1 is supported by this function.
*
*/
static GT_STATUS portTxShaperTokenBucketShapersDisableStage_rev1
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  SHAPER_DISABLE_STAGE_ENT    stage,
    INOUT PORT_TX_SHAPER_TOKEN_BUCKET_STC *origPortEntryPtr,
    INOUT PORT_TX_SHAPER_TOKEN_BUCKET_STC *tempPortEntryPtr,
    INOUT PORT_TX_SHAPER_TOKEN_BUCKET_STC *origTcEntryPtr,
    INOUT PORT_TX_SHAPER_TOKEN_BUCKET_STC *tempTcEntryPtr
)
{
    GT_U8       queue;      /* port traffic class */
    GT_STATUS   rc;         /* return code */
    GT_U32  portGroupId;    /*the port group Id - support multi-port-groups device */
    GT_U32   localPort;      /* local port - support multi-port-groups device */
    CPSS_DXCH_TABLE_ENT tableType =
        CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG_E;
    GT_U32  portTcTbRegValueArr[TXQ_SHAPER_ENTRY_WORDS_NUM_CNS];
    GT_U32  portTcTbRegMaskArr[TXQ_SHAPER_ENTRY_WORDS_NUM_CNS];
    PORT_TX_SHAPER_TOKEN_BUCKET_STC *currentTempTcEntryPtr;
    GT_U32  txqPortNum;     /* TXQ port number */

    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);

    cpssOsMemSet(portTcTbRegValueArr, 0, sizeof(portTcTbRegValueArr));
    cpssOsMemSet(portTcTbRegMaskArr, 0, sizeof(portTcTbRegMaskArr));

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,txqPortNum);

    if(stage == SHAPER_DISABLE_STAGE_1_E)
    {
        /* Disabling the Egress Rate Shaper under traffic may hang its */
        /*   relevant transmit queue. (FEr#47) */

        /**************/
        /* 'per port' */
        /**************/

        /* read the entry */
        rc = portTxShaperTokenBucketEntryRead_rev1(devNum,portNum,GT_FALSE,0,tempPortEntryPtr);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* save the original entry values */
        *origPortEntryPtr = *tempPortEntryPtr;

        /* Set Number Tokens and Bucket Size to a maximal values */
        /*   and disable slow rate */
        tempPortEntryPtr->slowRateEn = GT_FALSE;
        tempPortEntryPtr->tokens = PRV_CPSS_SIP_5_CHECK_MAC(devNum) ? 0x3FFFF : 0xFFF;
        tempPortEntryPtr->maxBucketSize = 0xFFF;
        tempPortEntryPtr->tbUpdateRatio = 0;

        /* write the entry */
        rc = portTxShaperTokenBucketEntryWrite_rev1(devNum,portNum,GT_FALSE,0,tempPortEntryPtr);
        if(rc != GT_OK)
        {
            return rc;
        }

        /*********************/
        /* 'per port per tc' */
        /*********************/

        /* read the HW entry */

        rc = prvCpssDxChPortGroupReadTableEntry(devNum,portGroupId,tableType,localPort,portTcTbRegValueArr);
        if(rc != GT_OK)
        {
            return rc;
        }

        for (queue = 0; queue < CPSS_TC_RANGE_CNS; queue++)
        {
            /* parse the sub entries */
            currentTempTcEntryPtr = tempTcEntryPtr + queue;
            rc = portTxShaperTokenBucketParse(devNum, portTcTbRegValueArr,GT_TRUE,queue,currentTempTcEntryPtr);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* save the original entry values */
            *(origTcEntryPtr  + queue) = *currentTempTcEntryPtr;

            /* Set Number Tokens and Bucket Size to a maximal values */
            /*   and disable slow rate */
            currentTempTcEntryPtr->slowRateEn = GT_FALSE;
            currentTempTcEntryPtr->tokens = PRV_CPSS_SIP_5_CHECK_MAC(devNum) ? 0x3FFFF : 0xFFF;
            currentTempTcEntryPtr->maxBucketSize = 0xFFF;
            currentTempTcEntryPtr->tbUpdateRatio = 0;

            /* update HW entry */
            rc = portTxShaperTokenBucketBuild(devNum,
                portTcTbRegValueArr,
                portTcTbRegMaskArr,
                GT_TRUE,
                queue,
                currentTempTcEntryPtr);
            if(rc != GT_OK)
            {
                return rc;
            }

        }

        /* write the HW entry. Use ...WriteTableEntryMasked instead of ...WriteTableEntry
        * to make the shadow table entry updated with modified HW fields only (instead of
        * copying full HW entry) */
        rc = prvCpssDxChPortGroupWriteTableEntryMasked(devNum,portGroupId,tableType,localPort,
            portTcTbRegValueArr,
            portTcTbRegMaskArr);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(stage == SHAPER_DISABLE_STAGE_2_E)
    {
        /**************/
        /* 'per port' */
        /**************/
        tempPortEntryPtr->tokenBucketEn = GT_FALSE;

        /* write the temp entry */
        rc = portTxShaperTokenBucketEntryWrite_rev1(devNum,portNum,GT_FALSE,0,tempPortEntryPtr);
        if(rc != GT_OK)
        {
            return rc;
        }

        origPortEntryPtr->tokenBucketEn = GT_FALSE;

        /* write the original entry */
        rc = portTxShaperTokenBucketEntryWrite_rev1(devNum,portNum,GT_FALSE,0,origPortEntryPtr);
        if(rc != GT_OK)
        {
            return rc;
        }

        /*********************/
        /* 'per port per tc' */
        /*********************/
        for (queue = 0; queue < CPSS_TC_RANGE_CNS; queue++)
        {

            currentTempTcEntryPtr = tempTcEntryPtr + queue;
            currentTempTcEntryPtr->tokenBucketEn = GT_FALSE;

            /* update HW entry */
            rc = portTxShaperTokenBucketBuild(devNum,
                portTcTbRegValueArr,
                portTcTbRegMaskArr,
                GT_TRUE,
                queue,
                currentTempTcEntryPtr);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* write the HW entry. Use ...WriteTableEntryMasked instead of ...WriteTableEntry
        * to make the shadow table entry updated with modified HW fields only (instead of
        * copying full HW entry) */
        rc = prvCpssDxChPortGroupWriteTableEntryMasked(devNum,portGroupId,tableType,localPort,
            portTcTbRegValueArr,
            portTcTbRegMaskArr);
        if(rc != GT_OK)
        {
            return rc;
        }

        for (queue = 0; queue < CPSS_TC_RANGE_CNS; queue++)
        {

            currentTempTcEntryPtr = origTcEntryPtr + queue;
            currentTempTcEntryPtr->tokenBucketEn = GT_FALSE;

            /* update HW entry */
            rc = portTxShaperTokenBucketBuild(devNum,
                portTcTbRegValueArr,
                portTcTbRegMaskArr,
                GT_TRUE,
                queue,
                currentTempTcEntryPtr);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* write the HW entry. Use ...WriteTableEntryMasked instead of ...WriteTableEntry
        * to make the shadow table entry updated with modified HW fields only (instead of
        * copying full HW entry) */
        rc = prvCpssDxChPortGroupWriteTableEntryMasked(devNum,portGroupId,tableType,localPort,
            portTcTbRegValueArr,
            portTcTbRegMaskArr);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal portTxShaperTokenBucketShapersDisable_rev1 function
* @endinternal
*
* @brief   Disable Shaping on Port and all it's queues.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - physical device number.
* @param[in] portNum                  - physical port number (CPU port supported as well as regular ports)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Only Txq revision 1 is supported by this function.
*
*/
static GT_STATUS portTxShaperTokenBucketShapersDisable_rev1
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum
)
{
    PORT_TX_SHAPER_TOKEN_BUCKET_STC origPortEntry;
    PORT_TX_SHAPER_TOKEN_BUCKET_STC tempPortEntry;
    PORT_TX_SHAPER_TOKEN_BUCKET_STC origTcEntryArr[CPSS_TC_RANGE_CNS];
    PORT_TX_SHAPER_TOKEN_BUCKET_STC tempTcEntry[CPSS_TC_RANGE_CNS];
    GT_U8       queue;      /* port traffic class */
    GT_STATUS   rc;         /* return code */

    if(PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E) == GT_FALSE)
    {
        /* no need for WA */
        rc = portTxShaperTokenBucketEnable_rev1(devNum,portNum,GT_FALSE,0,GT_FALSE);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Per port per traffic class (queue) */
        for (queue = 0; queue < CPSS_TC_RANGE_CNS; queue++)
        {
            rc = portTxShaperTokenBucketEnable_rev1(devNum,portNum,GT_TRUE,queue,GT_FALSE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        return GT_OK;
    }

    /* Disabling the Egress Rate Shaper under traffic may hang its
    relevant transmit queue. (FEr#47) */

    rc = portTxShaperTokenBucketShapersDisableStage_rev1(devNum,portNum,
        SHAPER_DISABLE_STAGE_1_E,
        &origPortEntry,
        &tempPortEntry,
        origTcEntryArr,
        tempTcEntry);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* wait at least 1 millisecond to guaranty bucket size will be > MTU.
    this avoid traffic stuck during shaper disable under traffic.*/
    cpssOsTimerWkAfter(1);

    rc = portTxShaperTokenBucketShapersDisableStage_rev1(devNum,portNum,
        SHAPER_DISABLE_STAGE_2_E,
        &origPortEntry,
        &tempPortEntry,
        origTcEntryArr,
        tempTcEntry);
    if(rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/* maximal physical port number that may be used by logic below.
   Falcon and other sip_6 device are not applicable.
   BC3 device support 512 ports */
#define PORT_TX_SHAPER_MAX_PORT_NUM_CNS 512

/**
 * @struct PRV_TX_SHAPER_TOKEN_BUCKET_VAR_STC
 *
 * @brief variables hold shapers configurations.
 */
typedef struct {
    /** original port configuration */
    PORT_TX_SHAPER_TOKEN_BUCKET_STC origPortEntry[PORT_TX_SHAPER_MAX_PORT_NUM_CNS];
    /** temporary port configuration */
    PORT_TX_SHAPER_TOKEN_BUCKET_STC tempPortEntry[PORT_TX_SHAPER_MAX_PORT_NUM_CNS];
    /** original port's traffic class configuration */
    PORT_TX_SHAPER_TOKEN_BUCKET_STC origTcEntryArr[PORT_TX_SHAPER_MAX_PORT_NUM_CNS][CPSS_TC_RANGE_CNS];
    /** temporary port's traffic class configuration */
    PORT_TX_SHAPER_TOKEN_BUCKET_STC tempTcEntry[PORT_TX_SHAPER_MAX_PORT_NUM_CNS][CPSS_TC_RANGE_CNS];
} PRV_TX_SHAPER_TOKEN_BUCKET_VAR_STC;

/**
* @internal portTxShaperTokenBucketAllShapersDisable_rev1 function
* @endinternal
*
* @brief   Disables all ports and queues shapers for specified device in minimum delay.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_OUT_OF_CPU_MEM        - on CPU memory allocation failure
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Only Txq revision 1 is supported by this function.
*
*/
static GT_STATUS portTxShaperTokenBucketAllShapersDisable_rev1
(
    IN  GT_U8    devNum
)
{
    PRV_TX_SHAPER_TOKEN_BUCKET_VAR_STC * tbVarPtr; /* token buckets variables */
    GT_PHYSICAL_PORT_NUM       portNum;       /* device port */
    GT_STATUS   rc;         /* return code */
    GT_U8       queue;      /* port traffic class */
    GT_BOOL     isValid;    /* is valid mapping exists */
    GT_U32      txqPortNum;

    if(PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E) == GT_FALSE)
    {
        /* no need for WA */
        for (portNum = 0; portNum < PORT_TX_SHAPER_MAX_PORT_NUM_CNS; portNum++)
        {
            if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
            {
                rc = cpssDxChPortPhysicalPortMapIsValidGet(devNum, portNum, &isValid);
                if((rc != GT_OK) || (isValid != GT_TRUE))
                    continue;

                rc = prvCpssDxChPortPhysicalPortMapCheckAndConvert(devNum, portNum, PRV_CPSS_DXCH_PORT_TYPE_TXQ_E, &txqPortNum);
                if ((rc == GT_BAD_PARAM) && (txqPortNum == CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS))
                    continue;
            }
            else
            {
                if (!PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, portNum) && portNum != CPSS_CPU_PORT_NUM_CNS)
                    continue;
            }

            /* Per port */
            rc = portTxShaperTokenBucketEnable_rev1(devNum,portNum,GT_FALSE,0,GT_FALSE);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* Per port per traffic class (queue) */
            for (queue = 0; queue < CPSS_TC_RANGE_CNS; queue++)
            {
                rc = portTxShaperTokenBucketEnable_rev1(devNum,portNum,GT_TRUE,queue,GT_FALSE);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }

        return GT_OK;
    }

    tbVarPtr = cpssOsMalloc(sizeof(PRV_TX_SHAPER_TOKEN_BUCKET_VAR_STC));
    if (tbVarPtr == NULL)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
    }

    /* Disabling the Egress Rate Shaper under traffic may hang its
    relevant transmit queue. (FEr#47) */
    for (portNum = 0; portNum < PORT_TX_SHAPER_MAX_PORT_NUM_CNS; portNum++)
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            rc = cpssDxChPortPhysicalPortMapIsValidGet(devNum, portNum, &isValid);
            if((rc != GT_OK) || (isValid != GT_TRUE))
                continue;

            rc = prvCpssDxChPortPhysicalPortMapCheckAndConvert(devNum, portNum, PRV_CPSS_DXCH_PORT_TYPE_TXQ_E, &txqPortNum);
            if ((rc == GT_BAD_PARAM) && (txqPortNum == CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS))
                continue;
        }
        else
        {
            if (!PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, portNum) && portNum != CPSS_CPU_PORT_NUM_CNS)
                continue;
        }

        rc = portTxShaperTokenBucketShapersDisableStage_rev1(devNum,portNum,
            SHAPER_DISABLE_STAGE_1_E,
            &tbVarPtr->origPortEntry[portNum],
            &tbVarPtr->tempPortEntry[portNum],
            &tbVarPtr->origTcEntryArr[portNum][0],
            &tbVarPtr->tempTcEntry[portNum][0]);
        if(rc != GT_OK)
        {
            goto clean_exit;
        }
    }

    /* wait at least 1 millisecond to guaranty bucket size will be > MTU.
    this avoid traffic stuck during shaper disable under traffic.*/
    cpssOsTimerWkAfter(1);

    for (portNum = 0; portNum < PORT_TX_SHAPER_MAX_PORT_NUM_CNS; portNum++)
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            rc = cpssDxChPortPhysicalPortMapIsValidGet(devNum, portNum, &isValid);
            if((rc != GT_OK) || (isValid != GT_TRUE))
                continue;

            rc = prvCpssDxChPortPhysicalPortMapCheckAndConvert(devNum, portNum, PRV_CPSS_DXCH_PORT_TYPE_TXQ_E, &txqPortNum);
            if ((rc == GT_BAD_PARAM) && (txqPortNum == CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS))
                continue;
        }
        else
        {
            if (!PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, portNum) && portNum != CPSS_CPU_PORT_NUM_CNS)
                continue;
        }

        rc = portTxShaperTokenBucketShapersDisableStage_rev1(devNum,portNum,
            SHAPER_DISABLE_STAGE_2_E,
            &tbVarPtr->origPortEntry[portNum],
            &tbVarPtr->tempPortEntry[portNum],
            &tbVarPtr->origTcEntryArr[portNum][0],
            &tbVarPtr->tempTcEntry[portNum][0]);
        if(rc != GT_OK)
        {
            goto clean_exit;
        }
    }

    /* logic above done without errors */
    rc = GT_OK;

clean_exit:
    cpssOsFree(tbVarPtr);
    return rc;
}

/**
* @internal prvCpssDxChPortTxRegisterAddrGet function
* @endinternal
*
* @brief   get register address for 'txq per port' .
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number.
* @param[in] primaryIndex             - primary index , can be used as :
*                                      port number (also CPU port)
*                                      or as profile number
* @param[in] secondaryIndex           - secondary index , can be used as TC
* @param[in] registerType             - register type
*
* @param[out] regAddrPtr               - (pointer to) register address
*                                       GT_OK
*/
GT_STATUS prvCpssDxChPortTxRegisterAddrGet
(
    IN  GT_U8    devNum,
    IN  GT_U32   primaryIndex,
    IN  GT_U32   secondaryIndex,
    IN  PRV_CPSS_DXCH_PORT_TX_REG_TYPE_ENT  registerType,
    OUT GT_U32   *regAddrPtr
)
{
    dxch_txPortRegs *txPortsPtr;/* current tx Ports info */

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        switch(registerType)
        {
        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TX_CONFIG_E:
            /* this register spread to many registers in txqVer1 */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TOKEN_BUCK_E:
            /* use tables engine , with table:
            CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG_E
            */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TOKEN_BUCK_LEN_E:
            /* not used in cpss yet */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_PRIO_TOKEN_BUCK_E:
            /* use tables engine , with table:
            CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG_E
            */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_PRIO_TOKEN_BUCK_LEN_E:
            /* not used in cpss yet */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_DESCR_COUNTER_E:
            PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);
            *(regAddrPtr) =
                PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropCntrs.portDescCntr[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_BUFFER_COUNTER_E:
            PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);
            *(regAddrPtr) =
                PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropCntrs.portBuffersCntr[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TC_DESCR_COUNTER_E:
            /* use tables engine with table:
            CPSS_DXCH_SIP5_TABLE_TXQ_LINK_LIST_COUNTERS_Q_MAIN_DESC_E */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TC_BUFFER_COUNTER_E:
            /* use tables engine with table:
            CPSS_DXCH_SIP5_TABLE_TAIL_DROP_COUNTERS_Q_MAIN_BUFF_E */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_WEIGHTS_0_E:
            PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);

            *(regAddrPtr) =
                PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.priorityArbiterWeights.profileSDWRRWeightsConfigReg0[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_WEIGHTS_1_E:
            PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);

            *(regAddrPtr) =
                PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.priorityArbiterWeights.profileSDWRRWeightsConfigReg1[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_STRICT_PRIO_E:
            PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);

            *(regAddrPtr) =
                PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.priorityArbiterWeights.profileSDWRRGroup[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_STRICT_PRIO_EN_E:
            PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);

            *(regAddrPtr) =
                PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.priorityArbiterWeights.profileSDWRREnable[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_DESCR_LIMIT_E:
            /* use explicit register - Port Descriptor Limits or Port Buffer Limits registers. */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        if(primaryIndex == CPSS_CPU_PORT_NUM_CNS)
        {
            txPortsPtr = &PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txCpuRegs;
        }
        else
        {
            txPortsPtr = &PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txPortRegs[primaryIndex];
        }

        switch(registerType)
        {
        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TX_CONFIG_E:
            *(regAddrPtr) = txPortsPtr->txConfig;
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TOKEN_BUCK_E:
            *(regAddrPtr) = txPortsPtr->tokenBuck;
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TOKEN_BUCK_LEN_E:
            *(regAddrPtr) = txPortsPtr->tokenBuckLen;
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_PRIO_TOKEN_BUCK_E:
            *(regAddrPtr) = txPortsPtr->prioTokenBuck[secondaryIndex];
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_PRIO_TOKEN_BUCK_LEN_E:
            *(regAddrPtr) = txPortsPtr->prioTokenBuckLen[secondaryIndex];
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_DESCR_COUNTER_E:
            *(regAddrPtr) = txPortsPtr->descrCounter;
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_BUFFER_COUNTER_E:
            *(regAddrPtr) = txPortsPtr->bufferCounter;
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TC_DESCR_COUNTER_E:
            *(regAddrPtr) = txPortsPtr->tcDescrCounter[secondaryIndex];
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TC_BUFFER_COUNTER_E:
            *(regAddrPtr) = txPortsPtr->tcBufferCounter[secondaryIndex];
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_WEIGHTS_0_E:
            *(regAddrPtr) = txPortsPtr->wrrWeights0;
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_WEIGHTS_1_E:
            *(regAddrPtr) = txPortsPtr->wrrWeights1;
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_STRICT_PRIO_E:
        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_STRICT_PRIO_EN_E:
            *(regAddrPtr) = txPortsPtr->wrrStrictPrio;
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_DESCR_LIMIT_E:
            if(primaryIndex > CPSS_PORT_TX_DROP_PROFILE_8_E)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            *(regAddrPtr) = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                egrTxQConf.setsConfigRegs.portLimitsConf[primaryIndex];
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }
    else
    {

        switch(registerType)
        {
        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TX_CONFIG_E:
            /* this register spread to many registers in txqVer1 */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TOKEN_BUCK_E:
            /* use tables engine , with table:
            CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG_E
            */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TOKEN_BUCK_LEN_E:
            /* not used in cpss yet */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_PRIO_TOKEN_BUCK_E:
            /* use tables engine , with table:
            CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG_E
            */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_PRIO_TOKEN_BUCK_LEN_E:
            /* not used in cpss yet */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_DESCR_COUNTER_E:
            *(regAddrPtr) =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
                counters.portDescCounter[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_BUFFER_COUNTER_E:
            *(regAddrPtr) =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
                counters.portBuffersCounter[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TC_DESCR_COUNTER_E:
            *(regAddrPtr) =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
                counters.qMainDesc[primaryIndex][secondaryIndex];
            break;

        case PRV_CPSS_DXCH_PORT_TX_REG_TYPE_TC_BUFFER_COUNTER_E:
            *(regAddrPtr) =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
                counters.qMainBuff[primaryIndex][secondaryIndex];
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_WEIGHTS_0_E:
            *(regAddrPtr) =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.scheduler.
                priorityArbiterWeights.profileSdwrrWeightsConfig0[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_WEIGHTS_1_E:
            *(regAddrPtr) =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.scheduler.
                priorityArbiterWeights.profileSdwrrWeightsConfig1[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_STRICT_PRIO_E:
            *(regAddrPtr) =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.scheduler.
                priorityArbiterWeights.profileSdwrrGroup[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_WRR_STRICT_PRIO_EN_E:
            *(regAddrPtr) =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.scheduler.
                priorityArbiterWeights.profileSdwrrEnable[primaryIndex];
            break;

        case PRV_CPSS_DXCH_PROFILE_TX_REG_TYPE_DESCR_LIMIT_E:
            *(regAddrPtr) =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
                limits.profilePortLimits[primaryIndex];
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChPortTxSchedulerDeficitModeEnableSet function
* @endinternal
*
* @brief   Enable/Disable scheduler deficit mode.
*
* @note   APPLICABLE DEVICES:          Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE: Enable Scheduler Deficit mode.
*                                      GT_FALSE: Disable Scheduler Deficit mode.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1. Deficit mode should be enabled to support line-rate scheduling
*       in 40/100 Gbps ports.
*       2. Request Masks must be properly configured if deficit mode
*       is enabled, see:
*       cpssDxChPortTxRequestMaskSet
*       cpssDxChPortTxRequestMaskIndexSet.
*       3. If Deficit scheduling is enabled, the shaper's baseline must be
*       at least 8MTU, see:
*       cpssDxChPortTxShaperBaselineSet
*
*/
static GT_STATUS internal_cpssDxChPortTxSchedulerDeficitModeEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_U32 value;     /* register value */
    GT_U32 regAddr;   /* register address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    value = BOOL2BIT_MAC(enable);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.scheduler.config.config;
    return prvCpssHwPpSetRegField(devNum, regAddr, 23, 1, value);
}

/**
* @internal cpssDxChPortTxSchedulerDeficitModeEnableSet function
* @endinternal
*
* @brief   Enable/Disable scheduler deficit mode.
*
* @note   APPLICABLE DEVICES:          Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE: Enable Scheduler Deficit mode.
*                                      GT_FALSE: Disable Scheduler Deficit mode.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1. Deficit mode should be enabled to support line-rate scheduling
*       in 40/100 Gbps ports.
*       2. Request Masks must be properly configured if deficit mode
*       is enabled, see:
*       cpssDxChPortTxRequestMaskSet
*       cpssDxChPortTxRequestMaskIndexSet.
*       3. If Deficit scheduling is enabled, the shaper's baseline must be
*       at least 8MTU, see:
*       cpssDxChPortTxShaperBaselineSet
*
*/
GT_STATUS cpssDxChPortTxSchedulerDeficitModeEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSchedulerDeficitModeEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPortTxSchedulerDeficitModeEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSchedulerDeficitModeEnableGet function
* @endinternal
*
* @brief   Gets the current status of scheduler deficit mode.
*
* @note   APPLICABLE DEVICES:          Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - (pointer to) status of scheduler deficit mode
*                                      GT_TRUE: Scheduler deficit mode enabled.
*                                      GT_FALSE: Scheduler Deficit mode disabled.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSchedulerDeficitModeEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL   *enablePtr
)
{
    GT_U32 value;     /* register value */
    GT_U32 regAddr;   /* register address */
    GT_STATUS rc;     /* function return value */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.scheduler.config.config;
    rc =  prvCpssHwPpGetRegField(devNum, regAddr, 23, 1, &value);
    if (rc != GT_OK)
    {
        return rc;
    }
    *enablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/**
* @internal cpssDxChPortTxSchedulerDeficitModeEnableGet function
* @endinternal
*
* @brief   Gets the current status of scheduler deficit mode.
*
* @note   APPLICABLE DEVICES:          Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - (pointer to) status of scheduler deficit mode
*                                      GT_TRUE: Scheduler deficit mode enabled.
*                                      GT_FALSE: Scheduler Deficit mode disabled.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSchedulerDeficitModeEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL   *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSchedulerDeficitModeEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPortTxSchedulerDeficitModeEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChTxRequestMaskSet function
* @endinternal
*
* @brief   Set the request mask value for a given mask index
*
* @note   APPLICABLE DEVICES:      Caelum; Aldrin; AC3X;
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman;
*
* @param[in] devNum                   - device number
* @param[in] maskIndex                - request mask index (0..3).
* @param[in] maskValue                - request mask value defines the minimum number of core clock
*                                      cycles between two consecutive service grants
*                                      to the same port (3..255).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChTxRequestMaskSet
(
    IN GT_U8    devNum,
    IN GT_U32   maskIndex,
    IN GT_U32   maskValue
)
{
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);

    if (maskIndex > PRV_CPSS_DXCH_PORT_REQUEST_MASK_INDEX_MAX_CNS)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    if (maskValue < 3 || maskValue > 255)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if (maskIndex > PRV_CPSS_DXCH_PORT_REQUEST_MASK_INDEX_MAX_CNS)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssDxChPortTxQUnitDQPortRequestMaskSet(
        devNum, 0 /*dqIdx*/, maskIndex/*maskId*/, maskValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChPortTxShaperModeSet function
* @endinternal
*
* @brief   Set Shaper mode, packet or byte based for given port.
*         Shapers are configured by cpssDxChPortTxShaperProfileSet or
*         cpssDxChPortTxQShaperProfileSet
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 .
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number (CPU port supported as well as regular ports).
* @param[in] mode                     - shaper mode: byte count or packet number based.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxShaperModeSet
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT   mode
)
{
    GT_U32  regAddr;        /* register address             */
    GT_U32  hwPortTbMode;   /* The Port Token bucket Rate shaper mode  */
    GT_U32  portGroupId;    /* the port group Id - support multi-port-groups device */
    GT_U32   localPort;      /* local port - support multi-port-groups device */
    GT_U32  txqPortNum;     /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    switch (mode)
    {
    case CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E:
        hwPortTbMode = 0;
        break;
    case CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E:
        hwPortTbMode = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum, txqPortNum);

    if ((localPort == CPSS_CPU_PORT_NUM_CNS) && (PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_FALSE))
    {
        localPort &= 0xF;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.portTokenBucketMode[txqPortNum];

        return prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, hwPortTbMode);
    }
    else
    {
        /* Set Token Bucket Mode */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.shaper.tokenBucketMode;

        return prvCpssDrvHwPpPortGroupSetRegField(devNum, portGroupId, regAddr, localPort, 1, hwPortTbMode);
    }
}

/**
* @internal cpssDxChPortTxShaperModeSet function
* @endinternal
*
* @brief   Set Shaper mode, packet or byte based for given port.
*         Shapers are configured by cpssDxChPortTxShaperProfileSet or
*         cpssDxChPortTxQShaperProfileSet
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 .
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number (CPU port supported as well as regular ports).
* @param[in] mode                     - shaper mode: byte count or packet number based.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxShaperModeSet
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT   mode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, mode));

    rc = internal_cpssDxChPortTxShaperModeSet(devNum, portNum, mode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, mode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperModeGet function
* @endinternal
*
* @brief   Get Shaper mode, packet or byte based for given port.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 .
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number (CPU port supported as well as regular ports).
*
* @param[out] modePtr                  - (pointer to) shaper mode: byte count or packet number based.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxShaperModeGet
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT CPSS_PORT_TX_DROP_SHAPER_MODE_ENT   *modePtr
)
{
    GT_U32     regAddr;     /* register address             */
    GT_U32     value;       /* value to read from register */
    GT_STATUS  rc;          /* return code */
    GT_U32     portGroupId; /*the port group Id - support multi-port-groups device */
    GT_U32      localPort;   /* local port - support multi-port-groups device */
    GT_U32     txqPortNum;  /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    CPSS_NULL_PTR_CHECK_MAC(modePtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, txqPortNum);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum, txqPortNum);

    if ((localPort == CPSS_CPU_PORT_NUM_CNS) && (PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_FALSE))
    {
        localPort &= 0xF;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.portTokenBucketMode[txqPortNum];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 1, &value);
    }
    else
    {

        /* Get Token Bucket Mode */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.shaper.tokenBucketMode;

        rc = prvCpssDrvHwPpPortGroupGetRegField(devNum, portGroupId, regAddr, localPort, 1, &value);
    }
    if (rc != GT_OK)
    {
        return rc;
    }

    *modePtr = (value == 1) ? CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E :
        CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E;
    return GT_OK;
}

/**
* @internal cpssDxChPortTxShaperModeGet function
* @endinternal
*
* @brief   Get Shaper mode, packet or byte based for given port.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 .
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number (CPU port supported as well as regular ports).
*
* @param[out] modePtr                  - (pointer to) shaper mode: byte count or packet number based.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxShaperModeGet
(
    IN  GT_U8    devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT CPSS_PORT_TX_DROP_SHAPER_MODE_ENT   *modePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, modePtr));

    rc = internal_cpssDxChPortTxShaperModeGet(devNum, portNum, modePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, modePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperBaselineSet function
* @endinternal
*
* @brief   Set Token Bucket Baseline.
*         The Token Bucket Baseline is the "zero" level of the token bucket.
*         When the token bucket fill level < Baseline, the respective queue/port
*         is not served.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number.
* @param[in] baseline                 - Token Bucket Baseline value in bytes(0..0xFFFFFF).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range baseline
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Token Bucket Baseline must be configured as follows:
*       1. At least MTU.
*       2. If PFC response is enabled, the Baseline must be
*       at least 0x3FFFC0, see:
*       cpssDxChPortPfcEnableSet.
*       3. If Deficit scheduling is enabled, the Baseline must be
*       at least 8MTU, see:
*       cpssDxChPortTxSchedulerDeficitModeEnableSet.
*       4. When packet based shaping is enabled, the following used as
*       shaper's MTU:
*       CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC. portsPacketLength
*       CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC. cpuPacketLength
*       see:
*       cpssDxChPortTxShaperConfigurationSet.
*
*/
static GT_STATUS internal_cpssDxChPortTxShaperBaselineSet
(
    IN GT_U8    devNum,
    IN GT_U32   baseline
)
{
    GT_U32      regAddr;    /* register address             */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }
    if (baseline > 0xFFFFFF)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    /* Set Token Bucket Base Line */
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.tokenBucketBaseLine;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.shaper.tokenBucketBaseLine;
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 24, baseline);
}

/**
* @internal cpssDxChPortTxShaperBaselineSet function
* @endinternal
*
* @brief   Set Token Bucket Baseline.
*         The Token Bucket Baseline is the "zero" level of the token bucket.
*         When the token bucket fill level < Baseline, the respective queue/port
*         is not served.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;Falcon; AC5P; AC5X; Harrier; Ironman .
*
* @param[in] devNum                   - device number.
* @param[in] baseline                 - Token Bucket Baseline value in bytes(0..0xFFFFFF).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range baseline
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Token Bucket Baseline must be configured as follows:
*       1. At least MTU.
*       2. If PFC response is enabled, the Baseline must be
*       at least 0x3FFFC0, see:
*       cpssDxChPortPfcEnableSet.
*       3. If Deficit scheduling is enabled, the Baseline must be
*       at least 8MTU, see:
*       cpssDxChPortTxSchedulerDeficitModeEnableSet.
*       4. When packet based shaping is enabled, the following used as
*       shaper's MTU:
*       CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC. portsPacketLength
*       CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC. cpuPacketLength
*       see:
*       cpssDxChPortTxShaperConfigurationSet.
*
*/
GT_STATUS cpssDxChPortTxShaperBaselineSet
(
    IN GT_U8    devNum,
    IN GT_U32   baseline
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperBaselineSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, baseline));

    rc = internal_cpssDxChPortTxShaperBaselineSet(devNum, baseline);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, baseline));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperBaselineGet function
* @endinternal
*
* @brief   Get Token Bucket Baseline.
*         The Token Bucket Baseline is the "zero" level of the token bucket.
*         When the token bucket fill level < Baseline, the respective queue/port
*         is not served.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;Falcon; AC5P; AC5X; Harrier; Ironman .
*
* @param[in] devNum                   - device number.
*
* @param[out] baselinePtr              - (pointer to) Token Bucket Baseline value in bytes.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxShaperBaselineGet
(
    IN  GT_U8    devNum,
    OUT GT_U32   *baselinePtr
)
{
    GT_U32      regAddr;    /* register address                */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(baselinePtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    /* Get Token Bucket Base Line */
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.tokenBucketBaseLine;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.shaper.tokenBucketBaseLine;
    }

    return prvCpssDrvHwPpGetRegField(devNum, regAddr, 0, 24, baselinePtr);
}

/**
* @internal cpssDxChPortTxShaperBaselineGet function
* @endinternal
*
* @brief   Get Token Bucket Baseline.
*         The Token Bucket Baseline is the "zero" level of the token bucket.
*         When the token bucket fill level < Baseline, the respective queue/port
*         is not served.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;Falcon; AC5P; AC5X; Harrier; Ironman .
*
* @param[in] devNum                   - device number.
*
* @param[out] baselinePtr              - (pointer to) Token Bucket Baseline value in bytes.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxShaperBaselineGet
(
    IN  GT_U8    devNum,
    OUT GT_U32   *baselinePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperBaselineGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, baselinePtr));

    rc = internal_cpssDxChPortTxShaperBaselineGet(devNum, baselinePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, baselinePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperConfigurationSet function
* @endinternal
*
* @brief   Set global configuration for shaper.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin .
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] configsPtr               - (pointer to) shaper configuration.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note When packet based shaping is enabled, the following used as shaper's MTU:
*       configsPtr->portsPacketLength
*       configsPtr->cpuPacketLength
*       see:
*       cpssDxChPortTxShaperBaselineSet.
*
*/
static GT_STATUS internal_cpssDxChPortTxShaperConfigurationSet
(
    IN  GT_U8                   devNum,
    IN  CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC *configsPtr
)
{
    GT_U32      value;      /* value to write into register */
    GT_STATUS   rc;         /* return code */
    GT_U32      regAddr;    /* register address             */
    GT_U32      mask;       /* register mask */
    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC oldConfigs; /* old global configurations */
    CPSS_PORT_TX_DROP_SHAPER_MODE_ENT shaperMode; /* shaper mode on port */
    GT_U32 port;
    GT_U32 tcQueue = 0;
    GT_BOOL isValid;
    GT_U32  txqPortNum;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(configsPtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if((configsPtr->tokensRate < PRV_CPSS_DXCH_TXQREV1_TOKEN_BCKT_UPD_RATE_MIN_CNS) ||
    (configsPtr->tokensRate > PRV_CPSS_DXCH_TXQREV1_TOKEN_BCKT_UPD_RATE_MAX_CNS) ||
    (configsPtr->slowRateRatio < PRV_CPSS_DXCH_TXQREV1_SLOW_TOKEN_BCKT_UPD_RATIO_MIN_CNS) ||
    (configsPtr->slowRateRatio > PRV_CPSS_DXCH_TXQREV1_SLOW_TOKEN_BCKT_UPD_RATIO_MAX_CNS) ||
    (configsPtr->portsPacketLength > 0xFFFFFF) ||
    (configsPtr->cpuPacketLength > 0xFFFFFF))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    /* save the old configurations */
    rc = cpssDxChPortTxShaperConfigurationGet(devNum,&oldConfigs);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Set update rates */
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.tokenBucketUpdateRate;

        value = ((configsPtr->slowRateRatio - 1)& 0xF) << 17 |
        (configsPtr->tokensRate & 0xF) << 25;

        switch (configsPtr->tokensRateGran)
        {
        case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
            value |= 3 << 30;
            break;
        case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_128_CORE_CLOCKS_E:
            value |= 1 << 30;
            break;
        case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_256_CORE_CLOCKS_E:
            value |= 2 << 30;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        mask = 0xDE1E0000;

    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.shaper.tokenBucketUpdateRate;

        value = ((configsPtr->slowRateRatio - 1)& 0xF) << 18 |
        (configsPtr->tokensRate & 0xF) << 26;

        switch (configsPtr->tokensRateGran)
        {
        case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_64_CORE_CLOCKS_E:
            value |= BIT_31;
            break;
        case CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        mask = 0xBC3C0000;
    }

    rc = prvCpssHwPpWriteRegBitMask(devNum, regAddr, mask, value);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Set CPU Token Bucket MTU */
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.CPUTokenBucketMTU;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.shaper.cpuTokenBucketMtuConfig;
    }

    value = configsPtr->cpuPacketLength;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 24, value);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Set Ports Token Bucket MTU */
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.portsTokenBucketMTU;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.shaper.portsTokenBucketMtuConfig;
    }
    value = configsPtr->portsPacketLength;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 24, value);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E))
    {
        return GT_OK;
    }

    /* Reconfigure all enabled Token Buckets per port and per port per queue. */
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    for (port = 0; port < CPSS_MAX_PORTS_NUM_CNS; port++)
    {

        if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            rc = cpssDxChPortPhysicalPortMapIsValidGet(devNum, port, &isValid);
            if((rc != GT_OK) || (isValid != GT_TRUE))
                continue;

            rc = prvCpssDxChPortPhysicalPortMapCheckAndConvert(devNum, port, PRV_CPSS_DXCH_PORT_TYPE_TXQ_E, &txqPortNum);
            if ((rc == GT_BAD_PARAM) && (txqPortNum == CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS))
                continue;

        }
        else
        {
            if (!PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, port))
                continue;
        }

        /* get shaper mode on the port */
        rc = cpssDxChPortTxShaperModeGet(devNum,port,&shaperMode);
        if (rc != GT_OK)
        {
            return rc;
        }


        /* per port */
        rc = prvDxChPortTxSetShaperTokenBucketParams_rev1(
            devNum,
            port,
            shaperMode,
            GT_FALSE,
            tcQueue,
            &oldConfigs,
            configsPtr);

        if (rc != GT_OK)
        {
            return rc;
        }

        /* per port per traffic class (tcQueue) */
        for (tcQueue = 0; tcQueue < CPSS_TC_RANGE_CNS; tcQueue++)
        {
            rc = prvDxChPortTxSetShaperTokenBucketParams_rev1(
                devNum,
                port,
                shaperMode,
                GT_TRUE,
                tcQueue,
                &oldConfigs,
                configsPtr);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) != GT_TRUE)
    {
        /* for CPU port */
        port = CPSS_CPU_PORT_NUM_CNS;

        /* get shaper mode on the port */
        rc = cpssDxChPortTxShaperModeGet(devNum,port,&shaperMode);
        if (rc != GT_OK)
        {
            return rc;
        }

        rc = prvDxChPortTxSetShaperTokenBucketParams_rev1(
            devNum,
            port,
            shaperMode,
            GT_FALSE,
            tcQueue,
            &oldConfigs,
            configsPtr);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* CPU port per traffic class (tcQueue) */
        for (tcQueue = 0; tcQueue < CPSS_TC_RANGE_CNS; tcQueue++)
        {
            rc = prvDxChPortTxSetShaperTokenBucketParams_rev1(
                devNum,
                port,
                shaperMode,
                GT_TRUE,
                tcQueue,
                &oldConfigs,
                configsPtr);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxShaperConfigurationSet function
* @endinternal
*
* @brief   Set global configuration for shaper.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin .
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] configsPtr               - (pointer to) shaper configuration.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note When packet based shaping is enabled, the following used as shaper's MTU:
*       configsPtr->portsPacketLength
*       configsPtr->cpuPacketLength
*       see:
*       cpssDxChPortTxShaperBaselineSet.
*
*/
GT_STATUS cpssDxChPortTxShaperConfigurationSet
(
    IN  GT_U8                   devNum,
    IN  CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC *configsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperConfigurationSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, configsPtr));

    rc = internal_cpssDxChPortTxShaperConfigurationSet(devNum, configsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, configsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperConfigurationGet function
* @endinternal
*
* @brief   Get global configuration for shaper.
*
* @note   APPLICABLE DEVICES:           Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin .
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
*
* @param[out] configsPtr               - (pointer to) shaper configuration.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note none.
*
*/
static GT_STATUS internal_cpssDxChPortTxShaperConfigurationGet
(
    IN  GT_U8                   devNum,
    OUT CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC *configsPtr
)
{
    GT_U32      value;      /* value to write into register */
    GT_STATUS   rc;         /* return code                  */
    GT_U32      regAddr;    /* register address             */
    GT_U32      mask;       /* register mask                */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(configsPtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    /* Get update rates */
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.tokenBucketUpdateRate;

        mask = 0xDE1E0000;

    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.shaper.tokenBucketUpdateRate;

        mask = 0xBC3C0000;
    }

    rc = prvCpssDrvHwPpReadRegBitMask(devNum, regAddr, mask, &value);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        configsPtr->slowRateRatio = ((value >> 17) & 0xF) + 1;
        configsPtr->tokensRate = (value >> 25) & 0xF;

        switch ((value >> 30))
        {
        case 3:
            configsPtr->tokensRateGran = CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E;
            break;
        case 1:
            configsPtr->tokensRateGran = CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_128_CORE_CLOCKS_E;
            break;
        case 2:
            configsPtr->tokensRateGran = CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_256_CORE_CLOCKS_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }
    else
    {

        configsPtr->slowRateRatio = ((value >> 18) & 0xF) + 1;
        configsPtr->tokensRate = (value >> 26) & 0xF;
        configsPtr->tokensRateGran = ((value >> 31) == 0) ?
CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
        CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_64_CORE_CLOCKS_E;
    }

    /* Get CPU Token Bucket MTU */
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.CPUTokenBucketMTU;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.shaper.cpuTokenBucketMtuConfig;
    }

    rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, 0, 24, &value);
    if (rc != GT_OK)
    {
        return rc;
    }
    configsPtr->cpuPacketLength = value;

    /* Get Ports Token Bucket MTU */
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.portsTokenBucketMTU;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.shaper.portsTokenBucketMtuConfig;
    }
    rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, 0, 24, &value);
    if (rc != GT_OK)
    {
        return rc;
    }
    configsPtr->portsPacketLength = value;

    return GT_OK;
}

/**
* @internal cpssDxChPortTxShaperConfigurationGet function
* @endinternal
*
* @brief   Get global configuration for shaper.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin .
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
*
* @param[out] configsPtr               - (pointer to) shaper configuration.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note none.
*
*/
GT_STATUS cpssDxChPortTxShaperConfigurationGet
(
    IN  GT_U8                   devNum,
    OUT CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC *configsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperConfigurationGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, configsPtr));

    rc = internal_cpssDxChPortTxShaperConfigurationGet(devNum, configsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, configsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropBufferConsumptionModeSet function
* @endinternal
*
* @brief   Sets the packet buffer consumption mode and its parameter.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] mode                     - packet buffer consumption mode.
*                                  (APPLICABLE DEVICES Lion2.)
* @param[in] length                   - Defines the number of buffers consumed by a packet for
*                                      Tail Drop and Scheduling.
*                                      Range: 0..63
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device or wrong mode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on length out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The function should be called only when traffic disabled
*       Mode configuration in Bobcat2,Caelum,Bobcat3; Aldrin2,Aldrin performed per profile.
*
*/
static GT_STATUS internal_cpssDxChPortTxTailDropBufferConsumptionModeSet
(
    IN  GT_U8                                                   devNum,
    IN  CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT mode,
    IN  GT_U32                                                  length
)
{
    GT_STATUS rc;       /* return code          */
    GT_U32  regAddr;    /* register address     */
    GT_U32  regData;    /* register data        */
    GT_U32  regDataLen; /* register data length */
    GT_U32  offset;     /* register offset */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if( length >= BIT_6 )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    switch (mode)
    {
    case CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_BYTE_E:
        regData = 0;
        break;
    case CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_PACKET_E:
        regData = 1;
        break;
    default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }


    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.pktLengthForTailDropEnqueue;

        offset =  1;
        regDataLen = 6;
        regData = length;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.byteCount;
        offset =  0;
        regDataLen = 7;
        U32_SET_FIELD_MAC(regData, 1, 6, length);
    }


    rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, regDataLen, regData);
    if( GT_OK != rc )
    {
        return rc;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.schedulerConfig.pktLengthForTailDropDequeue;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.scheduler.config.schedulerByteCountForTailDrop;
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, offset, regDataLen, regData);
}

/**
* @internal cpssDxChPortTxTailDropBufferConsumptionModeSet function
* @endinternal
*
* @brief   Sets the packet buffer consumption mode and its parameter.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] mode                     - packet buffer consumption mode.
*                                  (APPLICABLE DEVICES Lion2.)
* @param[in] length                   - Defines the number of buffers consumed by a packet for
*                                      Tail Drop and Scheduling.
*                                      Range: 0..63
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device or wrong mode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on length out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The function should be called only when traffic disabled
*       Mode configuration in Bobcat2,Caelum,Bobcat3; Aldrin2,Aldrin performed per profile.
*
*/
GT_STATUS cpssDxChPortTxTailDropBufferConsumptionModeSet
(
    IN  GT_U8                                                   devNum,
    IN  CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT mode,
    IN  GT_U32                                                  length
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropBufferConsumptionModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mode, length));

    rc = internal_cpssDxChPortTxTailDropBufferConsumptionModeSet(devNum, mode, length);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mode, length));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropBufferConsumptionModeGet function
* @endinternal
*
* @brief   Gets the packet buffer consumption mode and its parameter.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
*
* @param[out] modePtr                  - (pointer to) packet buffer consumption mode.
*                                  (Not applicable for Bobcat2,Caelum,Bobcat3,Aldrin)
* @param[out] lengthPtr                - (pointer to ) the number of buffers consumed by a packet
*                                      for Tail Drop and Scheduling. Relevant only for mode
*                                      CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_PACKET_E.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device or wrong mode
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropBufferConsumptionModeGet
(
    IN  GT_U8                                                   devNum,
    OUT CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT *modePtr,
    OUT GT_U32                                                  *lengthPtr
)
{
    GT_STATUS rc;       /* return code          */
    GT_U32  regAddr;    /* register address     */
    GT_U32  regData;    /* register data        */
    GT_U32  regDataLen; /* register data lenght */
    GT_U32  offset;     /* register offset */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(modePtr);
    CPSS_NULL_PTR_CHECK_MAC(lengthPtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.pktLengthForTailDropEnqueue;

        offset =  1;
        regDataLen = 6;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.byteCount;

        offset =  0;
        regDataLen = 7;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, regDataLen, &regData);
    if( GT_OK != rc )
    {
        return rc;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        *modePtr = 0;

        *lengthPtr = regData;
    }
    else
    {
        *modePtr = U32_GET_FIELD_MAC(regData, 0, 1) == 0 ?
CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_BYTE_E :
        CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_PACKET_E ;

        *lengthPtr = U32_GET_FIELD_MAC(regData, 1, 6);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxTailDropBufferConsumptionModeGet function
* @endinternal
*
* @brief   Gets the packet buffer consumption mode and its parameter.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
*
* @param[out] modePtr                  - (pointer to) packet buffer consumption mode.
*                                  (Not applicable for Bobcat2,Caelum,Bobcat3,Aldrin)
* @param[out] lengthPtr                - (pointer to ) the number of buffers consumed by a packet
*                                      for Tail Drop and Scheduling. Relevant only for mode
*                                      CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_PACKET_E.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device or wrong mode
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropBufferConsumptionModeGet
(
    IN  GT_U8                                                   devNum,
    OUT CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT *modePtr,
    OUT GT_U32                                                  *lengthPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropBufferConsumptionModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, modePtr, lengthPtr));

    rc = internal_cpssDxChPortTxTailDropBufferConsumptionModeGet(devNum, modePtr, lengthPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, modePtr, lengthPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTcProfileSharedPoolSet function
* @endinternal
*
* @brief   Sets the shared pool associated for traffic class and Profile.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
* @param[in] tc                       - the Traffic Class, range 0..7.
* @param[in] poolNum                  - shared pool associated, range 0..7.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, pfSet
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTcProfileSharedPoolSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT   pfSet,
    IN  GT_U8                               tc,
    IN  GT_U32                              poolNum
)
{
    GT_STATUS rc;       /* return code */
    GT_U32  regAddr;    /* register address     */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);


    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(pfSet, devNum);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if( poolNum >= SHARED_POOLS_NUM_CNS )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profilePriorityQueueToPoolAssociation[pfSet];

        rc =  prvCpssHwPpSetRegField(devNum, regAddr, tc*3, 3, poolNum);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* BC3 does not have such registers in TxQ LL unit */
        if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            return GT_OK;

        /* This configuration must be the same to the same configuration in the TXQ LL:
        Profile Priority Queue to Shared Pool Association */
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_LL_MAC(devNum).global.globalLLConfig.profilePriorityQueueToPoolAssociation[pfSet];
        return prvCpssHwPpSetRegField(devNum, regAddr, tc*3, 3, poolNum);
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.profilePriorityQueueToSharedPoolAssociation[pfSet];

        return prvCpssHwPpSetRegField(devNum, regAddr, tc*3, 3, poolNum);
    }
}

/**
* @internal cpssDxChPortTxTcProfileSharedPoolSet function
* @endinternal
*
* @brief   Sets the shared pool associated for traffic class and Profile.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
* @param[in] tc                       - the Traffic Class, range 0..7.
* @param[in] poolNum                  - shared pool associated, range 0..7.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, pfSet
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTcProfileSharedPoolSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT   pfSet,
    IN  GT_U8                               tc,
    IN  GT_U32                              poolNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTcProfileSharedPoolSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, pfSet, tc, poolNum));

    rc = internal_cpssDxChPortTxTcProfileSharedPoolSet(devNum, pfSet, tc, poolNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, pfSet, tc, poolNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTcProfileSharedPoolGet function
* @endinternal
*
* @brief   Gets the shared pool associated for traffic class and Profile.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
* @param[in] tc                       - the Traffic Class, range 0..7.
*
* @param[out] poolNumPtr               - (pointer to) shared pool associated.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, pfSet
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTcProfileSharedPoolGet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT   pfSet,
    IN  GT_U8                               tc,
    OUT GT_U32                              *poolNumPtr
)
{
    GT_U32  regAddr;    /* register address     */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);
    CPSS_NULL_PTR_CHECK_MAC(poolNumPtr);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(pfSet, devNum);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profilePriorityQueueToPoolAssociation[pfSet];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.profilePriorityQueueToSharedPoolAssociation[pfSet];
    }

    return prvCpssHwPpGetRegField(devNum, regAddr, tc*3, 3, poolNumPtr);
}

/**
* @internal cpssDxChPortTxTcProfileSharedPoolGet function
* @endinternal
*
* @brief   Gets the shared pool associated for traffic class and Profile.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated
* @param[in] tc                       - the Traffic Class, range 0..7.
*
* @param[out] poolNumPtr               - (pointer to) shared pool associated.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, pfSet
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTcProfileSharedPoolGet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT   pfSet,
    IN  GT_U8                               tc,
    OUT GT_U32                              *poolNumPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTcProfileSharedPoolGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, pfSet, tc, poolNumPtr));

    rc = internal_cpssDxChPortTxTcProfileSharedPoolGet(devNum, pfSet, tc, poolNumPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, pfSet, tc, poolNumPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMcastBuffersLimitSet function
* @endinternal
*
* @brief   Set maximal buffers limits for multicast packets.
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] mcastMaxBufNum           - The number of buffers allocated for multicast
*                                      packets. Range 0..0xFFFF
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on out of range mcastMaxBufNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMcastBuffersLimitSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  mcastMaxBufNum
)
{
    GT_U32  regAddr;    /* register address */
    GT_U32  fieldLen;   /* register field lenght */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);


    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if( mcastMaxBufNum >= BIT_20 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.mcFilterLimits.mcBuffersLimit;
        fieldLen = 20;
    }
    else
    {
        if( mcastMaxBufNum >= BIT_16 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
            mcFilterLimits.multicastBuffersLimit;
        fieldLen = 16;
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, fieldLen, mcastMaxBufNum);
}

/**
* @internal cpssDxChPortTxMcastBuffersLimitSet function
* @endinternal
*
* @brief   Set maximal buffers limits for multicast packets.
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] mcastMaxBufNum           - The number of buffers allocated for multicast
*                                      packets. Range 0..0xFFFF
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on out of range mcastMaxBufNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxMcastBuffersLimitSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  mcastMaxBufNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcastBuffersLimitSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mcastMaxBufNum));

    rc = internal_cpssDxChPortTxMcastBuffersLimitSet(devNum, mcastMaxBufNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mcastMaxBufNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMcastBuffersLimitGet function
* @endinternal
*
* @brief   Get maximal buffers limits for multicast packets.
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] mcastMaxBufNumPtr        - (pointer to) the number of buffers allocated
*                                      for multicast packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMcastBuffersLimitGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *mcastMaxBufNumPtr
)
{
    GT_U32  regAddr;    /* register address */
    GT_U32  fieldLen;   /* register field lenght */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(mcastMaxBufNumPtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.mcFilterLimits.mcBuffersLimit;
        fieldLen = 20;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
            mcFilterLimits.multicastBuffersLimit;
        fieldLen = 16;
    }

    return prvCpssHwPpGetRegField(devNum, regAddr, 0, fieldLen, mcastMaxBufNumPtr);
}

/**
* @internal cpssDxChPortTxMcastBuffersLimitGet function
* @endinternal
*
* @brief   Get maximal buffers limits for multicast packets.
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] mcastMaxBufNumPtr        - (pointer to) the number of buffers allocated
*                                      for multicast packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxMcastBuffersLimitGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *mcastMaxBufNumPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcastBuffersLimitGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mcastMaxBufNumPtr));

    rc = internal_cpssDxChPortTxMcastBuffersLimitGet(devNum, mcastMaxBufNumPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mcastMaxBufNumPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSniffedBuffersLimitSet function
* @endinternal
*
* @brief   Set maximal buffers limits for mirrored packets.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] rxSniffMaxBufNum         - The number of buffers allocated for packets
*                                      forwarded to the ingress analyzer port due to
*                                      mirroring.
*                                  (APPLICABLE RANGES:  Lion2: 0..0xFFFF,
*                                      Bobcat2, Caelum, Bobcat3, Aldrin, AC3X: 0..0xFFFFF)
* @param[in] txSniffMaxBufNum         - The number of buffers allocated for packets
*                                      forwarded to the egress analyzer port due to
*                                      mirroring.
*                                  (APPLICABLE RANGES:  Lion2: 0..0xFFFF,
*                                      Bobcat2, Caelum, Bobcat3; Aldrin2, Aldrin, AC3X: 0..0xFFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out of range value
*/
static GT_STATUS internal_cpssDxChPortTxSniffedBuffersLimitSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  rxSniffMaxBufNum,
    IN  GT_U32  txSniffMaxBufNum
)
{
    GT_STATUS rc;       /* return code */
    GT_U32  regAddr;    /* register address */
    GT_U32  regData;    /* register value   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if( rxSniffMaxBufNum >= BIT_20 ||
            txSniffMaxBufNum >= BIT_20 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.mcFilterLimits.ingrMirroredPktsToAnalyzerPortBuffersLimit;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 20, rxSniffMaxBufNum);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.mcFilterLimits.egrMirroredPktsToAnalyzerPortBuffersLimit;

        return prvCpssHwPpSetRegField(devNum, regAddr, 0, 20, txSniffMaxBufNum);
    }
    else
    {
        if( rxSniffMaxBufNum >= BIT_16 ||
            txSniffMaxBufNum >= BIT_16 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
            mcFilterLimits.mirroredPacketsToAnalyzerPortBuffersLimit;

        regData = rxSniffMaxBufNum;
        U32_SET_FIELD_MAC(regData, 16, 16, txSniffMaxBufNum);

        return prvCpssHwPpWriteRegister(devNum, regAddr, regData);
    }
}

/**
* @internal cpssDxChPortTxSniffedBuffersLimitSet function
* @endinternal
*
* @brief   Set maximal buffers limits for mirrored packets.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] rxSniffMaxBufNum         - The number of buffers allocated for packets
*                                      forwarded to the ingress analyzer port due to
*                                      mirroring.
*                                  (APPLICABLE RANGES:  Lion2: 0..0xFFFF,
*                                      Bobcat2, Caelum, Bobcat3, Aldrin, AC3X: 0..0xFFFFF)
* @param[in] txSniffMaxBufNum         - The number of buffers allocated for packets
*                                      forwarded to the egress analyzer port due to
*                                      mirroring.
*                                  (APPLICABLE RANGES:  Lion2: 0..0xFFFF,
*                                      Bobcat2, Caelum, Bobcat3; Aldrin2, Aldrin, AC3X: 0..0xFFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out of range value
*/
GT_STATUS cpssDxChPortTxSniffedBuffersLimitSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  rxSniffMaxBufNum,
    IN  GT_U32  txSniffMaxBufNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSniffedBuffersLimitSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, rxSniffMaxBufNum, txSniffMaxBufNum));

    rc = internal_cpssDxChPortTxSniffedBuffersLimitSet(devNum, rxSniffMaxBufNum, txSniffMaxBufNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, rxSniffMaxBufNum, txSniffMaxBufNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSniffedBuffersLimitGet function
* @endinternal
*
* @brief   Get maximal buffers limits for mirrored packets.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] rxSniffMaxBufNumPtr      - (pointer to) The number of buffers allocated
*                                      for packets forwarded to the ingress analyzer
*                                      port due to mirroring.
* @param[out] txSniffMaxBufNumPtr      - (pointer to) The number of buffers allocated
*                                      for packets forwarded to the egress analyzer
*                                      port due to mirroring.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSniffedBuffersLimitGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *rxSniffMaxBufNumPtr,
    OUT GT_U32  *txSniffMaxBufNumPtr
)
{
    GT_STATUS rc;       /* return code      */
    GT_U32  regAddr;    /* register address */
    GT_U32  regData;    /* register value   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(rxSniffMaxBufNumPtr);
    CPSS_NULL_PTR_CHECK_MAC(txSniffMaxBufNumPtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.mcFilterLimits.ingrMirroredPktsToAnalyzerPortBuffersLimit;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 20, rxSniffMaxBufNumPtr);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.mcFilterLimits.egrMirroredPktsToAnalyzerPortBuffersLimit;

        return prvCpssHwPpGetRegField(devNum, regAddr, 0, 20, txSniffMaxBufNumPtr);
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
            mcFilterLimits.mirroredPacketsToAnalyzerPortBuffersLimit;

        rc =  prvCpssHwPpReadRegister(devNum, regAddr, &regData);
        if( GT_OK != rc )
        {
            return rc;
        }

        *rxSniffMaxBufNumPtr = U32_GET_FIELD_MAC(regData, 0, 16);
        *txSniffMaxBufNumPtr = U32_GET_FIELD_MAC(regData, 16, 16);

        return GT_OK;
    }
}

/**
* @internal cpssDxChPortTxSniffedBuffersLimitGet function
* @endinternal
*
* @brief   Get maximal buffers limits for mirrored packets.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] rxSniffMaxBufNumPtr      - (pointer to) The number of buffers allocated
*                                      for packets forwarded to the ingress analyzer
*                                      port due to mirroring.
* @param[out] txSniffMaxBufNumPtr      - (pointer to) The number of buffers allocated
*                                      for packets forwarded to the egress analyzer
*                                      port due to mirroring.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSniffedBuffersLimitGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *rxSniffMaxBufNumPtr,
    OUT GT_U32  *txSniffMaxBufNumPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSniffedBuffersLimitGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, rxSniffMaxBufNumPtr, txSniffMaxBufNumPtr));

    rc = internal_cpssDxChPortTxSniffedBuffersLimitGet(devNum, rxSniffMaxBufNumPtr, txSniffMaxBufNumPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, rxSniffMaxBufNumPtr, txSniffMaxBufNumPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal cpssDxChPortTxSharedPoolLimitsSet function
* @endinternal
*
* @brief   Set maximal descriptors and buffers limits for shared pool.
*         APPLICABLE DEVICES:
*          Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*         NOT APPLICABLE DEVICES: xCat3; AC5;
*         INPUTS:
*         devNum   - physical device number
*         poolNum  - Shared pool number. Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Range 0..7
*                                                                   Falcon :Range 0..1
*         maxBufNum - The number of buffers allocated for a shared pool.
*            Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;  Range 0..0x3FFF.
*            Falcon:Range 0..0xFFFFF.
*         maxDescNum - The number of descriptors allocated for a shared pool.
*          NOT APPLICABLE DEVICES:Falcon; AC5P; AC5X; Harrier; Ironman
*         APPLICABLE RANGES:
*         Lion2, Bobcat2, Caelum, Aldrin, AC3X: 0..0x3FFF.
*
* @note   APPLICABLE DEVICES:       Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5.
*
* @param[in] devNum                   - physical device number
* @param[in] poolNum                  - Shared pool number.
*                                                               Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Range 0..7
*                                                               Falcon :Range 0..1
* @param[in] maxBufNum                - The number of buffers allocated for a shared pool.
*                                       Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2: Range 0..0x3FFF.
*                                       Falcon:Range   0..0xFFFFF
* @param[in] maxDescNum               - The number of descriptors allocated for a shared pool.
*                                      APPLICABLE RANGES:
*                                      Lion2, Bobcat2, Caelum, Aldrin, AC3X: 0..0x3FFF.
*                                      APPLICABLE RANGES:
*                                      Bobcat3; Aldrin2;: 0..0x3F7F.
*                                     NOT APPLICABLE DEVICES:Falcon; AC5P; AC5X; Harrier; Ironman
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out of range value
*/
static GT_STATUS internal_cpssDxChPortTxSharedPoolLimitsSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  poolNum,
    IN  GT_U32  maxBufNum,
    IN  GT_U32  maxDescNum
)
{
    GT_STATUS rc;       /* return code */
    GT_U32  regAddr;    /* register address */
    GT_U32  regData;    /* register value   */
    GT_U32  fieldLength;/* the number of bits to be written to register */
    GT_U32 numberOfPools;/* maximal number of pools */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    numberOfPools = PRV_CPSS_SIP_6_CHECK_MAC(devNum)?SIP6_SHARED_REGULAR_POOLS_NUM_CNS:SHARED_POOLS_NUM_CNS;

    if( poolNum >= numberOfPools )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }


    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)== GT_FALSE)
        {
            fieldLength = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 16 : 14;

            if ((GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT3_DESC_SHARED_POOL_TAILDROP_THRESHOLDS_WA_E)) ||
                PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
            {
                maxDescNum += 128;
            }

            if( maxBufNum >= BIT_20 ||
                maxDescNum >= (GT_U32)(1 << fieldLength) )
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
            }

            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropLimits.poolDescLimits[poolNum];

            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, fieldLength, maxDescNum);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {

            rc = prvCpssSip6TxQUtilsPoolConfigurationValidate(devNum,poolNum,maxBufNum);
            if(rc!=GT_OK)
            {
              CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
            }

            if(poolNum == 0)
            {
                regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).pool0TailDropLimit;
            }
            else
            {
                regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).pool1TailDropLimit;
            }

        }
        else
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropLimits.poolBufferLimits[poolNum];
        }

        return prvCpssHwPpSetRegField(devNum, regAddr, 0, 20, maxBufNum);
    }
    else
    {
        if( maxBufNum >= BIT_14 ||
            maxDescNum >= BIT_14 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
            limits.sharedPoolLimits[poolNum];

        regData = maxDescNum;
        U32_SET_FIELD_MAC(regData, 14, 14, maxBufNum);

        return prvCpssHwPpSetRegField(devNum, regAddr, 0, 28, regData);
    }
}

/**
* @internal cpssDxChPortTxSharedPoolLimitsSet function
* @endinternal
*
* @brief   Set maximal descriptors and buffers limits for shared pool.
*         APPLICABLE DEVICES:
*          Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*         NOT APPLICABLE DEVICES: xCat3; AC5;
*         INPUTS:
*         devNum   - physical device number
*         poolNum  - Shared pool number. Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Range 0..7
*                                                                   Falcon :Range 0..1
*         maxBufNum - The number of buffers allocated for a shared pool.
*            Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;  Range 0..0x3FFF.
*            Falcon:Range 0..0xFFFFF.
*         maxDescNum - The number of descriptors allocated for a shared pool.
*          NOT APPLICABLE DEVICES:Falcon; AC5P; AC5X; Harrier; Ironman
*         APPLICABLE RANGES:
*         Lion2, Bobcat2, Caelum, Aldrin, AC3X: 0..0x3FFF.
*
* @note   APPLICABLE DEVICES:       Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5.
*
* @param[in] devNum                   - physical device number
* @param[in] poolNum                  - Shared pool number.
*                                                               Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Range 0..7
*                                                               Falcon :Range 0..1
* @param[in] maxBufNum                - The number of buffers allocated for a shared pool.
*                                       Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2: Range 0..0x3FFF.
*                                       Falcon:Range   0..0xFFFFF
* @param[in] maxDescNum               - The number of descriptors allocated for a shared pool.
*                                      APPLICABLE RANGES:
*                                      Lion2, Bobcat2, Caelum, Aldrin, AC3X: 0..0x3FFF.
*                                      APPLICABLE RANGES:
*                                      Bobcat3; Aldrin2;: 0..0x3F7F.
*                                     NOT APPLICABLE DEVICES:Falcon; AC5P; AC5X; Harrier; Ironman
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out of range value
*/
GT_STATUS cpssDxChPortTxSharedPoolLimitsSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  poolNum,
    IN  GT_U32  maxBufNum,
    IN  GT_U32  maxDescNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSharedPoolLimitsSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, poolNum, maxBufNum, maxDescNum));

    rc = internal_cpssDxChPortTxSharedPoolLimitsSet(devNum, poolNum, maxBufNum, maxDescNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, poolNum, maxBufNum, maxDescNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSharedPoolLimitsGet function
* @endinternal
*
* @brief   Get maximal descriptors and buffers limits for shared pool.
*
* @note   APPLICABLE DEVICES:       Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5.
*
* @param[in] devNum                   - physical device number
* @param[in] poolNum                  - Shared pool number.
*                                                               Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Range 0..7
*                                                               Falcon :Range 0..1

*
* @param[out] maxBufNumPtr             - (pointer to) The number of buffers allocated for a
*                                      shared pool.
* @param[out] maxDescNumPtr            - (pointer to) The number of descriptors allocated
*                                      for a shared pool.NOT APPLICABLE DEVICES:Falcon; AC5P; AC5X; Harrier; Ironman
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSharedPoolLimitsGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  poolNum,
    OUT GT_U32  *maxBufNumPtr,
    OUT GT_U32  *maxDescNumPtr
)
{
    GT_STATUS rc;       /* return code      */
    GT_U32  regAddr;    /* register address */
    GT_U32  regData;    /* register value   */
    GT_U32  fieldLength;/* the number of bits to be written to register */
    GT_U32 numberOfPools;/* maximal number of pools */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E);

    CPSS_NULL_PTR_CHECK_MAC(maxBufNumPtr);
    CPSS_NULL_PTR_CHECK_MAC(maxDescNumPtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    numberOfPools = PRV_CPSS_SIP_6_CHECK_MAC(devNum)?SIP6_SHARED_REGULAR_POOLS_NUM_CNS:SHARED_POOLS_NUM_CNS;

    if( poolNum >= numberOfPools)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)== GT_FALSE)
        {
            fieldLength = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 16 : 14;
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropLimits.poolDescLimits[poolNum];

            rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, fieldLength, maxDescNumPtr);
            if(rc != GT_OK)
            {
                return rc;
            }

            if ((GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT3_DESC_SHARED_POOL_TAILDROP_THRESHOLDS_WA_E)) ||
                PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
            {
                if(*maxDescNumPtr < 128)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }
                *maxDescNumPtr = *maxDescNumPtr - 128 ;
            }
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            if(poolNum == 0)
            {
                regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).pool0TailDropLimit;
            }
            else
            {
                regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).pool1TailDropLimit;
            }
        }
        else
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropLimits.poolBufferLimits[poolNum];
        }

        return prvCpssHwPpGetRegField(devNum, regAddr, 0, 20, maxBufNumPtr);
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.
            limits.sharedPoolLimits[poolNum];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 28, &regData);
        if( GT_OK != rc )
        {
            return rc;
        }

        *maxDescNumPtr = U32_GET_FIELD_MAC(regData, 0, 14);
        *maxBufNumPtr = U32_GET_FIELD_MAC(regData, 14, 28);

        return GT_OK;
    }
}

/**
* @internal cpssDxChPortTxSharedPoolLimitsGet function
* @endinternal
*
* @brief   Get maximal descriptors and buffers limits for shared pool.
*
* @note   APPLICABLE DEVICES:       Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5.
*
* @param[in] devNum                   - physical device number
* @param[in] poolNum                  - Shared pool number.
*                                                               Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Range 0..7
*                                                               Falcon :Range 0..1

*
* @param[out] maxBufNumPtr             - (pointer to) The number of buffers allocated for a
*                                      shared pool.
* @param[out] maxDescNumPtr            - (pointer to) The number of descriptors allocated
*                                      for a shared pool.NOT APPLICABLE DEVICES:Falcon; AC5P; AC5X; Harrier; Ironman
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSharedPoolLimitsGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  poolNum,
    OUT GT_U32  *maxBufNumPtr,
    OUT GT_U32  *maxDescNumPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSharedPoolLimitsGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, poolNum, maxBufNumPtr, maxDescNumPtr));

    rc = internal_cpssDxChPortTxSharedPoolLimitsGet(devNum, poolNum, maxBufNumPtr, maxDescNumPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, poolNum, maxBufNumPtr, maxDescNumPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxProfileWeightedRandomTailDropEnableSet function
* @endinternal
*
* @brief   Enable/disable Weighted Random Tail Drop Threshold to overcome
*         synchronization.
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] dp                       - Drop Precedence
*                                  (APPLICABLE RANGES: Lion2, Bobcat2, Caelum, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman, Aldrin, AC3X 0..2)
* @param[in] tc                       - the Traffic Class, range 0..7.
*                                  (APPLICABLE DEVICES Bobcat2, Caelum, Aldrin, AC3X, Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
* @param[in] enablersPtr              - (pointer to) Tail Drop limits enabling
*                                      for Weigthed Random Tail Drop
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxProfileWeightedRandomTailDropEnableSet
(
    IN GT_U8                                    devNum,
    IN CPSS_PORT_TX_DROP_PROFILE_SET_ENT        pfSet,
    IN GT_U32                                   dp,
    IN GT_U8                                    tc,
    IN CPSS_PORT_TX_TAIL_DROP_WRTD_ENABLERS_STC *enablersPtr
)
{
    GT_U32 regAddr;    /* register address     */
    GT_U32 regData;    /* register value       */
    GT_U32 bitOffset;  /* bit offset inside register   */
    GT_U32 value;      /* value to write into register */
    GT_STATUS rc;      /* return code */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);


    CPSS_NULL_PTR_CHECK_MAC(enablersPtr);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(pfSet, devNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if( dp > 2 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        bitOffset = (dp << 3) + tc;

        if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT2_ENH_TAILDROP_MODE_WRED_CONFLICT_WA_E))
        {
            if(enablersPtr->sharedPoolLimit == GT_TRUE)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            }
        }

        regData = BOOL2BIT_MAC(enablersPtr->sharedPoolLimit);
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profilePoolWRTDEn[pfSet];
        rc = prvCpssHwPpSetRegField(devNum, regAddr, bitOffset, 1, regData);
        if(GT_OK != rc)
        {
            return rc;
        }

        regData = BOOL2BIT_MAC(enablersPtr->tcLimit);
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profileMaxQueueWRTDEn[pfSet];
        rc = prvCpssHwPpSetRegField(devNum, regAddr, bitOffset, 1, regData);
        if(GT_OK != rc)
        {
            return rc;
        }

        regData = BOOL2BIT_MAC(enablersPtr->portLimit);
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profilePortWRTDEn[pfSet];
        rc = prvCpssHwPpSetRegField(devNum, regAddr, bitOffset, 1, regData);
        if(GT_OK != rc)
        {
            return rc;
        }

        regData = BOOL2BIT_MAC(enablersPtr->tcDpLimit);
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profileQueueWRTDEn[pfSet];
        return prvCpssHwPpSetRegField(devNum, regAddr, bitOffset, 1, regData);
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        if( dp > 1 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        /* validate Traffic Classes queue */
        PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);

        bitOffset = dp*8 + tc;

        /* set Port WRTD En */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.setsConfigRegs.portWRTDEn[pfSet];
        value = BOOL2BIT_MAC(enablersPtr->portLimit);
        rc = prvCpssHwPpSetRegField(devNum, regAddr, bitOffset, 1, value);
        if (rc != GT_OK)
            return rc;

        /* set Queue WRTD En */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.setsConfigRegs.queueWRTDEn[pfSet];
        value = BOOL2BIT_MAC(enablersPtr->tcDpLimit);
        rc = prvCpssHwPpSetRegField(devNum, regAddr, bitOffset, 1, value);
        if (rc != GT_OK)
            return rc;

        /* set Shared Pool WRTD En */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.setsConfigRegs.sharedPoolWRTDEn[pfSet];
        value = BOOL2BIT_MAC(enablersPtr->sharedPoolLimit);
        rc = prvCpssHwPpSetRegField(devNum, regAddr, bitOffset, 1, value);
        if (rc != GT_OK)
            return rc;
    }
    else
    {
        if( dp > 2 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.profileEnableWrtdDp[dp];

        regData = BOOL2BIT_MAC(enablersPtr->portLimit);
        U32_SET_FIELD_MAC(regData,  8, 1, BOOL2BIT_MAC(enablersPtr->tcLimit));
        U32_SET_FIELD_MAC(regData, 16, 1, BOOL2BIT_MAC(enablersPtr->tcDpLimit));
        U32_SET_FIELD_MAC(regData, 24, 1, BOOL2BIT_MAC(enablersPtr->sharedPoolLimit));

        rc = prvCpssHwPpWriteRegBitMask(devNum, regAddr,
        (0x01010101 << pfSet) , regData << pfSet);
        if (rc != GT_OK)
            return rc;
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxProfileWeightedRandomTailDropEnableSet function
* @endinternal
*
* @brief   Enable/disable Weighted Random Tail Drop Threshold to overcome
*         synchronization.
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] dp                       - Drop Precedence
*                                  (APPLICABLE RANGES: Lion2, Bobcat2, Caelum, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman, Aldrin, AC3X 0..2)
* @param[in] tc                       - the Traffic Class, range 0..7.
*                                  (APPLICABLE DEVICES Bobcat2, Caelum, Aldrin, AC3X, Bobcat3; Aldrin2)
* @param[in] enablersPtr              - (pointer to) Tail Drop limits enabling
*                                      for Weigthed Random Tail Drop
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxProfileWeightedRandomTailDropEnableSet
(
    IN GT_U8                                    devNum,
    IN CPSS_PORT_TX_DROP_PROFILE_SET_ENT        pfSet,
    IN GT_U32                                   dp,
    IN GT_U8                                    tc,
    IN CPSS_PORT_TX_TAIL_DROP_WRTD_ENABLERS_STC *enablersPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxProfileWeightedRandomTailDropEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, pfSet, dp, tc, enablersPtr));

    rc = internal_cpssDxChPortTxProfileWeightedRandomTailDropEnableSet(devNum, pfSet, dp, tc, enablersPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, pfSet, dp, tc, enablersPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxProfileWeightedRandomTailDropEnableGet function
* @endinternal
*
* @brief   Get Random Tail drop Threshold status.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] dp                       - Drop Precedence
*                                  (APPLICABLE RANGES: Lion2, Bobcat2, Caelum, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman, Aldrin, AC3X 0..2)
* @param[in] tc                       - the Traffic Class, range 0..7.
*                                  (APPLICABLE DEVICES Bobcat2, Caelum, Aldrin, AC3X, Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*
* @param[out] enablersPtr              - (pointer to) Tail Drop limits enabling
*                                      for Weigthed Random Tail Drop.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxProfileWeightedRandomTailDropEnableGet
(
    IN  GT_U8                                    devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT        pfSet,
    IN  GT_U32                                   dp,
    IN  GT_U8                                    tc,
    OUT CPSS_PORT_TX_TAIL_DROP_WRTD_ENABLERS_STC *enablersPtr
)
{
    GT_STATUS rc;      /* return code          */
    GT_U32 regAddr;    /* register address     */
    GT_U32 regData;    /* register value       */
    GT_U32 bitOffset;  /* bit offset inside register   */


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(enablersPtr);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(pfSet, devNum);
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if( dp > 2 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        bitOffset = (dp << 3) + tc;

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profilePoolWRTDEn[pfSet];
        rc = prvCpssHwPpGetRegField(devNum, regAddr, bitOffset, 1, &regData);
        if(GT_OK != rc)
        {
            return rc;
        }
        enablersPtr->sharedPoolLimit = BIT2BOOL_MAC(regData);

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profileMaxQueueWRTDEn[pfSet];
        rc = prvCpssHwPpGetRegField(devNum, regAddr, bitOffset, 1, &regData);
        if(GT_OK != rc)
        {
            return rc;
        }
        enablersPtr->tcLimit         = BIT2BOOL_MAC(regData);

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profilePortWRTDEn[pfSet];
        rc = prvCpssHwPpGetRegField(devNum, regAddr, bitOffset, 1, &regData);
        if(GT_OK != rc)
        {
            return rc;
        }
        enablersPtr->portLimit       = BIT2BOOL_MAC(regData);

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profileQueueWRTDEn[pfSet];
        rc = prvCpssHwPpGetRegField(devNum, regAddr, bitOffset, 1, &regData);
        if(GT_OK != rc)
        {
            return rc;
        }
        enablersPtr->tcDpLimit       = BIT2BOOL_MAC(regData);

        return GT_OK;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        if( dp > 1 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        /* validate Traffic Classes queue */
        PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);

        bitOffset = dp*8 + tc;

        /* get Port WRTD En */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.setsConfigRegs.portWRTDEn[pfSet];
        rc = prvCpssHwPpGetRegField(devNum, regAddr, bitOffset, 1, &regData);
        if (rc != GT_OK)
            return rc;
        enablersPtr->portLimit = BIT2BOOL_MAC(regData);

        /* get Queue WRTD En */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.setsConfigRegs.queueWRTDEn[pfSet];
        rc = prvCpssHwPpGetRegField(devNum, regAddr, bitOffset, 1, &regData);
        if (rc != GT_OK)
            return rc;
        enablersPtr->tcDpLimit = BIT2BOOL_MAC(regData);

        /* get Shared Pool WRTD En */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.setsConfigRegs.sharedPoolWRTDEn[pfSet];
        rc = prvCpssHwPpGetRegField(devNum, regAddr, bitOffset, 1, &regData);
        if (rc != GT_OK)
            return rc;
        enablersPtr->sharedPoolLimit = BIT2BOOL_MAC(regData);
    }
    else
    {
        if( dp > 2 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.profileEnableWrtdDp[dp];

        rc = prvCpssHwPpReadRegister(devNum, regAddr, &regData);
        if( GT_OK != rc )
        {
            return rc;
        }

        regData = regData >> pfSet;

        enablersPtr->portLimit       = BIT2BOOL_MAC(U32_GET_FIELD_MAC(regData,  0, 1));
        enablersPtr->tcLimit         = BIT2BOOL_MAC(U32_GET_FIELD_MAC(regData,  8, 1));
        enablersPtr->tcDpLimit       = BIT2BOOL_MAC(U32_GET_FIELD_MAC(regData, 16, 1));
        enablersPtr->sharedPoolLimit = BIT2BOOL_MAC(U32_GET_FIELD_MAC(regData, 24, 1));
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxProfileWeightedRandomTailDropEnableGet function
* @endinternal
*
* @brief   Get Random Tail drop Threshold status.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] pfSet                    - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] dp                       - Drop Precedence
*                                  (APPLICABLE RANGES: Lion2, Bobcat2, Caelum, Bobcat3, Aldrin2, Aldrin, AC3X 0..2)
* @param[in] tc                       - the Traffic Class, range 0..7.
*                                  (APPLICABLE DEVICES Bobcat2, Caelum, Aldrin, AC3X, Bobcat3; Aldrin2)
*
* @param[out] enablersPtr              - (pointer to) Tail Drop limits enabling
*                                      for Weigthed Random Tail Drop.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxProfileWeightedRandomTailDropEnableGet
(
    IN  GT_U8                                    devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT        pfSet,
    IN  GT_U32                                   dp,
    IN  GT_U8                                    tc,
    OUT CPSS_PORT_TX_TAIL_DROP_WRTD_ENABLERS_STC *enablersPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxProfileWeightedRandomTailDropEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, pfSet, dp, tc, enablersPtr));

    rc = internal_cpssDxChPortTxProfileWeightedRandomTailDropEnableGet(devNum, pfSet, dp, tc, enablersPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, pfSet, dp, tc, enablersPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropWrtdMasksSet function
* @endinternal
*
* @brief   Sets Weighted Random Tail Drop (WRTD) masks.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - physical device number
* @param[in] maskLsbPtr               - WRTD masked least significant bits.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropWrtdMasksSet
(
    IN  GT_U8                            devNum,
    IN  CPSS_PORT_TX_WRTD_MASK_LSB_STC  *maskLsbPtr
)
{
    GT_STATUS rc;       /* return code          */
    GT_U32  regAddr;    /* register address     */
    GT_U32  regData;    /* register value       */
    GT_U32  i,offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E);

    CPSS_NULL_PTR_CHECK_MAC(maskLsbPtr);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        if(maskLsbPtr->tc>= BIT_6 || maskLsbPtr->pool >=BIT_6||maskLsbPtr->mcast>=BIT_6)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        for(i=0;i<4;i++)
        {
            switch(i)
            {
            case 0:
                regData = maskLsbPtr->tc;
                regAddr =PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).queueMaxLimitConfig;
                offset =0;
                break;
            case 1:
                regData = maskLsbPtr->mcast;
                regAddr =PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).mcAvailableBuffers;
                offset =20;
                break;
            case 2:
                regData = maskLsbPtr->pool;
                regAddr =PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).pool0TailDropLimit;
                offset =20;
                break;
            default:
                regData = maskLsbPtr->pool;
                regAddr =PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).pool1TailDropLimit;
                offset = 20;
                break;
            }
            rc = prvCpssHwPpSetRegField(devNum,regAddr , offset, 6, regData);
            if( GT_OK != rc )
            {
                return rc;
            }
        }

    }
    else if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if (maskLsbPtr->port > 20 || maskLsbPtr->tcDp > 20 ||
            maskLsbPtr->tc   > 20 || maskLsbPtr->pool > 20)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }


        regData = BIT_MASK_0_31_MAC(maskLsbPtr->pool);
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.poolWRTDMasks;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 20, regData);
        if( GT_OK != rc )
        {
            return rc;
        }

        regData = BIT_MASK_0_31_MAC(maskLsbPtr->port);
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.portWRTDMasks;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 20, regData);
        if( GT_OK != rc )
        {
            return rc;
        }

        regData = BIT_MASK_0_31_MAC(maskLsbPtr->tc);
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.maxQueueWRTDMasks;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 20, regData);
        if( GT_OK != rc )
        {
            return rc;
        }

        regData = BIT_MASK_0_31_MAC(maskLsbPtr->tcDp);
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.queueWRTDMasks;
        return prvCpssHwPpSetRegField(devNum, regAddr, 0, 20, regData);
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        if( maskLsbPtr->port > 14 || maskLsbPtr->tcDp > 14 ||
            maskLsbPtr->pool > 14 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        /* set WRTD mask for the Queue buffer/descriptor limits. */
        regData = BIT_MASK_0_31_MAC(maskLsbPtr->tcDp);
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.queueWRTDMask;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 14, regData);
        if( GT_OK != rc )
            return rc;

        /* set WRTD mask for the Port buffer/descriptor limits. */

        regData = BIT_MASK_0_31_MAC(maskLsbPtr->port);
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.portWRTDMask;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 14, regData);
        if( GT_OK != rc )
            return rc;

        /* set WRTD mask for the Shared Pool buffer/descriptor limits. */
        regData = BIT_MASK_0_31_MAC(maskLsbPtr->pool);
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.sharedPoolWRTDMask;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 14, regData);
        if( GT_OK != rc )
            return rc;
    }
    else
    {
        if( maskLsbPtr->port > 9 || maskLsbPtr->tcDp > 9 ||
            maskLsbPtr->tc   > 9 || maskLsbPtr->pool > 9 )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        regData = BIT_MASK_0_31_MAC(maskLsbPtr->tc);
        U32_SET_FIELD_MAC(regData, 9, 9, BIT_MASK_0_31_MAC(maskLsbPtr->port));

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.wrtdMask0;

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 18, regData);
        if( GT_OK != rc )
        {
            return rc;
        }

        regData = BIT_MASK_0_31_MAC(maskLsbPtr->tcDp);
        U32_SET_FIELD_MAC(regData, 9, 9, BIT_MASK_0_31_MAC(maskLsbPtr->pool));

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.wrtdMask1;

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 18, regData);
        if( GT_OK != rc )
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxTailDropWrtdMasksSet function
* @endinternal
*
* @brief   Sets Weighted Random Tail Drop (WRTD) masks.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - physical device number
* @param[in] maskLsbPtr               - WRTD masked least significant bits.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropWrtdMasksSet
(
    IN  GT_U8                            devNum,
    IN  CPSS_PORT_TX_WRTD_MASK_LSB_STC  *maskLsbPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropWrtdMasksSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, maskLsbPtr));

    rc = internal_cpssDxChPortTxTailDropWrtdMasksSet(devNum, maskLsbPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, maskLsbPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropWrtdMasksGet function
* @endinternal
*
* @brief   Gets Weighted Random Tail Drop (WRTD) masks.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - physical device number
*
* @param[out] maskLsbPtr               - (pointer to) WRTD masked least significant bits.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropWrtdMasksGet
(
    IN  GT_U8                            devNum,
    OUT CPSS_PORT_TX_WRTD_MASK_LSB_STC  *maskLsbPtr
)
{
    GT_STATUS rc;       /* return code          */
    GT_U32  regAddr;    /* register address     */
    GT_U32  regData;    /* register value       */
    GT_U32  localMask;  /* bits mask from the register value    */
    GT_U32 i,offset,*regDataPtr;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E);

    CPSS_NULL_PTR_CHECK_MAC(maskLsbPtr);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        for(i=0;i<3;i++)
        {
            switch(i)
            {
            case 0:
                regDataPtr = &(maskLsbPtr->tc);
                regAddr =PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).queueMaxLimitConfig;
                offset =0;
                break;
            case 1:
                regDataPtr = &(maskLsbPtr->mcast);
                regAddr =PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).mcAvailableBuffers;
                offset =20;
                break;
            default:
                regDataPtr = &(maskLsbPtr->pool);
                regAddr =PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).pool0TailDropLimit;
                offset =20;
                break;
            }
            rc = prvCpssHwPpGetRegField(devNum,regAddr , offset, 6, regDataPtr);
            if( GT_OK != rc )
            {
                return rc;
            }
        }

    }
    else if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.poolWRTDMasks;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 20, &regData);
        if( GT_OK != rc )
        {
            return rc;
        }
        MSB_SET_GET_MAC(maskLsbPtr->pool, regData);

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.portWRTDMasks;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 20, &regData);
        if( GT_OK != rc )
        {
            return rc;
        }
        MSB_SET_GET_MAC(maskLsbPtr->port, regData);

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.maxQueueWRTDMasks;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 20, &regData);
        if( GT_OK != rc )
        {
            return rc;
        }
        MSB_SET_GET_MAC(maskLsbPtr->tc, regData);

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.queueWRTDMasks;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 20, &regData);
        if( GT_OK != rc )
        {
            return rc;
        }
        MSB_SET_GET_MAC(maskLsbPtr->tcDp, regData);

        return GT_OK;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        /* get WRTD mask for the Queue buffer/descriptor limits. */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.queueWRTDMask;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 14, &regData);
        if( GT_OK != rc )
            return rc;
        MSB_SET_GET_MAC(maskLsbPtr->tcDp , regData);

        /* get WRTD mask for the Port buffer/descriptor limits. */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.portWRTDMask;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 14, &regData);
        if( GT_OK != rc )
            return rc;
        MSB_SET_GET_MAC(maskLsbPtr->port , regData);

        /* get WRTD mask for the Shared Pool buffer/descriptor limits. */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.sharedPoolWRTDMask;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 14, &regData);
        if( GT_OK != rc )
            return rc;
        MSB_SET_GET_MAC(maskLsbPtr->pool , regData);
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.wrtdMask0;

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 18, &regData);
        if( GT_OK != rc )
        {
            return rc;
        }

        localMask = U32_GET_FIELD_MAC(regData, 0, 9);
        MSB_SET_GET_MAC(maskLsbPtr->tc , localMask);
        localMask = U32_GET_FIELD_MAC(regData, 9, 9);
        MSB_SET_GET_MAC(maskLsbPtr->port , localMask);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.config.wrtdMask1;

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 18, &regData);
        if( GT_OK != rc )
        {
            return rc;
        }

        localMask = U32_GET_FIELD_MAC(regData, 0, 9);
        MSB_SET_GET_MAC(maskLsbPtr->tcDp , localMask);
        localMask = U32_GET_FIELD_MAC(regData, 9, 9);
        MSB_SET_GET_MAC(maskLsbPtr->pool , localMask);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxTailDropWrtdMasksGet function
* @endinternal
*
* @brief   Gets Weighted Random Tail Drop (WRTD) masks.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - physical device number
*
* @param[out] maskLsbPtr               - (pointer to) WRTD masked least significant bits.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropWrtdMasksGet
(
    IN  GT_U8                            devNum,
    OUT CPSS_PORT_TX_WRTD_MASK_LSB_STC  *maskLsbPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropWrtdMasksGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, maskLsbPtr));

    rc = internal_cpssDxChPortTxTailDropWrtdMasksGet(devNum, maskLsbPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, maskLsbPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxResourceHistogramThresholdSet function
* @endinternal
*
* @brief   Sets threshold for Histogram counter increment.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] cntrNum                  - Histogram Counter number. Range 0..3.
* @param[in] threshold                - If the Global Descriptors Counter exceeds this Threshold,
*                                      the Histogram Counter is incremented by 1.
*                                      Range 0..0x3FFF.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, cntrNum
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxResourceHistogramThresholdSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  cntrNum,
    IN  GT_U32  threshold
)
{
    GT_U32  regAddr;    /* register address */
    GT_U32  fieldLength;/* the number of bits to be written to register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    fieldLength = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 16 : 14;

    switch(cntrNum)
    {
    case 0:
    case 1:
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.resourceHistogram.resourceHistogramLimits.resourceHistogramLimitReg1;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                txqVer1.queue.tailDrop.resourceHistogram.limitRegister1;
        }
        break;
    case 2:
    case 3:
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.resourceHistogram.resourceHistogramLimits.resourceHistogramLimitReg2;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                txqVer1.queue.tailDrop.resourceHistogram.limitRegister2;
        }
        break;
    default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if( threshold >= (GT_U32)(1 << fieldLength) )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, (cntrNum & 0x1)*fieldLength, fieldLength, threshold);
}

/**
* @internal cpssDxChPortTxResourceHistogramThresholdSet function
* @endinternal
*
* @brief   Sets threshold for Histogram counter increment.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] cntrNum                  - Histogram Counter number. Range 0..3.
* @param[in] threshold                - If the Global Descriptors Counter exceeds this Threshold,
*                                      the Histogram Counter is incremented by 1.
*                                      Range 0..0x3FFF.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, cntrNum
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxResourceHistogramThresholdSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  cntrNum,
    IN  GT_U32  threshold
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxResourceHistogramThresholdSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cntrNum, threshold));

    rc = internal_cpssDxChPortTxResourceHistogramThresholdSet(devNum, cntrNum, threshold);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cntrNum, threshold));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxResourceHistogramThresholdGet function
* @endinternal
*
* @brief   Gets threshold for Histogram counter increment.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] cntrNum                  - Histogram Counter number. Range 0..3.
*
* @param[out] thresholdPtr             - (pointer to) If the Global Descriptors Counter
*                                      exceeds this Threshold, the Histogram Counter
*                                      is incremented by 1.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, cntrNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxResourceHistogramThresholdGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  cntrNum,
    OUT GT_U32  *thresholdPtr
)
{
    GT_U32  regAddr;    /* register address */
    GT_U32  fieldLength;/* the number of bits to be written to register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(thresholdPtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    fieldLength = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 16 : 14;

    switch(cntrNum)
    {
    case 0:
    case 1:
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.resourceHistogram.resourceHistogramLimits.resourceHistogramLimitReg1;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                txqVer1.queue.tailDrop.resourceHistogram.limitRegister1;
        }
        break;
    case 2:
    case 3:
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.resourceHistogram.resourceHistogramLimits.resourceHistogramLimitReg2;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                txqVer1.queue.tailDrop.resourceHistogram.limitRegister2;
        }
        break;
    default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return prvCpssHwPpGetRegField(devNum, regAddr, (cntrNum & 0x1)*fieldLength, fieldLength, thresholdPtr);
}

/**
* @internal cpssDxChPortTxResourceHistogramThresholdGet function
* @endinternal
*
* @brief   Gets threshold for Histogram counter increment.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] cntrNum                  - Histogram Counter number. Range 0..3.
*
* @param[out] thresholdPtr             - (pointer to) If the Global Descriptors Counter
*                                      exceeds this Threshold, the Histogram Counter
*                                      is incremented by 1.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, cntrNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxResourceHistogramThresholdGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  cntrNum,
    OUT GT_U32  *thresholdPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxResourceHistogramThresholdGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cntrNum, thresholdPtr));

    rc = internal_cpssDxChPortTxResourceHistogramThresholdGet(devNum, cntrNum, thresholdPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cntrNum, thresholdPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxResourceHistogramCounterGet function
* @endinternal
*
* @brief   Gets Histogram Counter.
*
* @note   APPLICABLE DEVICES:         Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:     xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] cntrNum                  - Histogram Counter number. Range 0..3.
*
* @param[out] cntrPtr                  - (pointer to) Histogram Counter value.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, cntrNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Histogram Counter is cleared on read.
*
*/
static GT_STATUS internal_cpssDxChPortTxResourceHistogramCounterGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  cntrNum,
    OUT GT_U32  *cntrPtr
)
{
    GT_U32    regAddr;     /* register address */
    GT_U32    cntrHwValue; /* value of counter in HW */
    GT_U32    fieldLength; /* the number of bits to be written to register */
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(cntrPtr);

    PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if( cntrNum > 3 )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.resourceHistogram.resourceHistogramCntrs.resourceHistogramCntr[cntrNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.resourceHistogram.counters[cntrNum];
    }

    fieldLength = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 16 : 14;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, fieldLength, &cntrHwValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum,
        PRV_CPSS_DXCH_BOBCAT2_EGRESS_MIB_COUNTERS_NOT_ROC_WA_E))
    {
        if (cntrHwValue < PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_BOBCAT2_EGRESS_MIB_COUNTERS_NOT_ROC_WA_E.
            histogramCntrShadow[cntrNum])
        {
            /* wraparound occurred, need to restart and use HW value as-is */
            *cntrPtr = cntrHwValue;
        }
        else
        {
            /* decrement stored value from current one */
            *cntrPtr = cntrHwValue - PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_BOBCAT2_EGRESS_MIB_COUNTERS_NOT_ROC_WA_E.
                histogramCntrShadow[cntrNum];
        }

        /* store current value for future use */
        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_BOBCAT2_EGRESS_MIB_COUNTERS_NOT_ROC_WA_E.
            histogramCntrShadow[cntrNum] = cntrHwValue;
    }
    else
    {
        *cntrPtr = cntrHwValue;
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxResourceHistogramCounterGet function
* @endinternal
*
* @brief   Gets Histogram Counter.
*
* @note   APPLICABLE DEVICES:         Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:     xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] cntrNum                  - Histogram Counter number. Range 0..3.
*
* @param[out] cntrPtr                  - (pointer to) Histogram Counter value.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, cntrNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Histogram Counter is cleared on read.
*
*/
GT_STATUS cpssDxChPortTxResourceHistogramCounterGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  cntrNum,
    OUT GT_U32  *cntrPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxResourceHistogramCounterGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cntrNum, cntrPtr));

    rc = internal_cpssDxChPortTxResourceHistogramCounterGet(devNum, cntrNum, cntrPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cntrNum, cntrPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxGlobalDescNumberGet function
* @endinternal
*
* @brief   Gets total number of descriptors allocated.
*
* @note   APPLICABLE DEVICES:     xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] numberPtr                - number of descriptors
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxGlobalDescNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *numberPtr
)
{
    GT_U32 regAddr; /* register address     */
    GT_U32 len;     /* register data length */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(numberPtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropCntrs.totalDescCntr;
        len = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 16 : 14;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.totalDescCounter;
        len = 16;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.counters.totalDescCounter;
        len = 14;
    }

    return prvCpssPortGroupsCounterSummary(devNum, regAddr, 0, len, numberPtr, NULL);
}

/**
* @internal cpssDxChPortTxGlobalDescNumberGet function
* @endinternal
*
* @brief   Gets total number of descriptors allocated.
*
* @note   APPLICABLE DEVICES:     xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] numberPtr                - number of descriptors
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxGlobalDescNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *numberPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxGlobalDescNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, numberPtr));

    rc = internal_cpssDxChPortTxGlobalDescNumberGet(devNum, numberPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, numberPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxGlobalBufNumberGet function
* @endinternal
*
* @brief   Gets total number of virtual buffers enqueued.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] numberPtr                - number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The buffers associated with enqueued multi-target descriptors are
*       counted multiple times, once for each multi-target descriptor instance.
*
*/
static GT_STATUS internal_cpssDxChPortTxGlobalBufNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *numberPtr
)
{
    GT_U32 regAddr; /* register address     */
    GT_U32 len;     /* register data length */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(numberPtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropCntrs.totalBuffersCntr;
        len = 20;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.totalBuffersCounter;
        len = 18;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.counters.totalBuffersCounter;
        len = 14;
    }

    return prvCpssPortGroupsCounterSummary(devNum, regAddr, 0, len, numberPtr,NULL);
}

/**
* @internal cpssDxChPortTxGlobalBufNumberGet function
* @endinternal
*
* @brief   Gets total number of virtual buffers enqueued.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] numberPtr                - number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The buffers associated with enqueued multi-target descriptors are
*       counted multiple times, once for each multi-target descriptor instance.
*
*/
GT_STATUS cpssDxChPortTxGlobalBufNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *numberPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxGlobalBufNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, numberPtr));

    rc = internal_cpssDxChPortTxGlobalBufNumberGet(devNum, numberPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, numberPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxMcastDescNumberGet function
* @endinternal
*
* @brief   Gets total number of multi-target descriptors allocated.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
*
* @param[in] devNum                   - physical device number
*
* @param[out] numberPtr                - number of descriptors
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Multi-target descriptors are descriptors that are duplicated to
*       multiple egress targets, e.g. Multicast, Broadcast, or unknown Unicast
*       flooded packets.
*
*/
static GT_STATUS internal_cpssDxChPortTxMcastDescNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *numberPtr
)
{
    GT_U32 regAddr; /* register address     */
    GT_U32 len;     /* register data length */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(numberPtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.muliticastFilterCntrs.mcDescsCntr;
        len = 16;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.multicastDescriptorsCounter;
        len = 14;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.mcFilterCounters.multicastDescriptorsCounter;
        len = 16;
    }

    return prvCpssPortGroupsCounterSummary(devNum, regAddr, 0, len, numberPtr, NULL);
}

/**
* @internal cpssDxChPortTxMcastDescNumberGet function
* @endinternal
*
* @brief   Gets total number of multi-target descriptors allocated.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] numberPtr                - number of descriptors
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Multi-target descriptors are descriptors that are duplicated to
*       multiple egress targets, e.g. Multicast, Broadcast, or unknown Unicast
*       flooded packets.
*
*/
GT_STATUS cpssDxChPortTxMcastDescNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *numberPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcastDescNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, numberPtr));

    rc = internal_cpssDxChPortTxMcastDescNumberGet(devNum, numberPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, numberPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMcastBufNumberGet function
* @endinternal
*
* @brief   Gets total number of multi-target buffers allocated (virtual buffers).
*
* @note   APPLICABLE DEVICES:           Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] numberPtr                - number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The buffers associated with enqueued multi-target descriptors are
*       counted multiple times, once for each multi-target descriptor instance.
*       Multi-target descriptors are descriptors that are duplicated to
*       multiple egress targets, e.g. Multicast, Broadcast, or unknown Unicast
*       flooded packets.
*
*/
static GT_STATUS internal_cpssDxChPortTxMcastBufNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *numberPtr
)
{
    GT_U32 regAddr; /* register address */
    GT_U32 len;     /* register field lenght */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(numberPtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.muliticastFilterCntrs.mcBuffersCntr;
        len = 20;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.mcFilterCounters.multicastBuffersCounter;
        len = 16;
    }

    return prvCpssPortGroupsCounterSummary(devNum, regAddr, 0, len, numberPtr, NULL);
}

/**
* @internal cpssDxChPortTxMcastBufNumberGet function
* @endinternal
*
* @brief   Gets total number of multi-target buffers allocated (virtual buffers).
*
* @note   APPLICABLE DEVICES:           Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] numberPtr                - number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The buffers associated with enqueued multi-target descriptors are
*       counted multiple times, once for each multi-target descriptor instance.
*       Multi-target descriptors are descriptors that are duplicated to
*       multiple egress targets, e.g. Multicast, Broadcast, or unknown Unicast
*       flooded packets.
*
*/
GT_STATUS cpssDxChPortTxMcastBufNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *numberPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcastBufNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, numberPtr));

    rc = internal_cpssDxChPortTxMcastBufNumberGet(devNum, numberPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, numberPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSniffedDescNumberGet function
* @endinternal
*
* @brief   Gets total number of mirrored descriptors allocated.
*
* @note   APPLICABLE DEVICES:     xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] rxNumberPtr              - number of ingress mirrored descriptors.
* @param[out] txNumberPtr              - number of egress mirrored descriptors.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSniffedDescNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *rxNumberPtr,
    OUT GT_U32  *txNumberPtr
)
{
    GT_STATUS rc;       /* return code      */
    GT_U32 regAddr;     /* register address */
    GT_U32 regData;     /* register value   */
    GT_U32 fieldLen;    /* register field length */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(rxNumberPtr);
    CPSS_NULL_PTR_CHECK_MAC(txNumberPtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.muliticastFilterCntrs.snifferDescsCntr;
        fieldLen = 16;
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.snifferDescriptorsCounter;
        fieldLen = 14;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.mcFilterCounters.snifferDescriptorsCounter;
        fieldLen = 16;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 2*fieldLen, &regData);
    if( GT_OK != rc )
    {
        return rc;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        *rxNumberPtr = U32_GET_FIELD_MAC(regData, 0, fieldLen);
        *txNumberPtr = U32_GET_FIELD_MAC(regData, fieldLen, fieldLen);
    }
    else if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        *txNumberPtr = U32_GET_FIELD_MAC(regData, 0, fieldLen);
        *rxNumberPtr = U32_GET_FIELD_MAC(regData, fieldLen, fieldLen);
    }
    else
    {
        *rxNumberPtr = U32_GET_FIELD_MAC(regData, 0, fieldLen);
        *txNumberPtr = U32_GET_FIELD_MAC(regData, fieldLen, fieldLen);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxSniffedDescNumberGet function
* @endinternal
*
* @brief   Gets total number of mirrored descriptors allocated.
*
* @note   APPLICABLE DEVICES:     xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] rxNumberPtr              - number of ingress mirrored descriptors.
* @param[out] txNumberPtr              - number of egress mirrored descriptors.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSniffedDescNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *rxNumberPtr,
    OUT GT_U32  *txNumberPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSniffedDescNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, rxNumberPtr, txNumberPtr));

    rc = internal_cpssDxChPortTxSniffedDescNumberGet(devNum, rxNumberPtr, txNumberPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, rxNumberPtr, txNumberPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSniffedBufNumberGet function
* @endinternal
*
* @brief   Gets total number of mirrored buffers allocated.
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
*
* @param[in] devNum                   - physical device number
*
* @param[out] rxNumberPtr              - number of ingress mirrored buffers.
* @param[out] txNumberPtr              - number of egress mirrored buffers.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSniffedBufNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *rxNumberPtr,
    OUT GT_U32  *txNumberPtr
)
{
    GT_STATUS rc;   /* return code      */
    GT_U32 regAddr; /* register address */
    GT_U32 regData; /* register value   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(rxNumberPtr);
    CPSS_NULL_PTR_CHECK_MAC(txNumberPtr);

    PRV_CPSS_DXCH_SIP6_NOT_SUPPORT_SIP5_TXQ_CHECK_MAC(devNum);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.muliticastFilterCntrs.ingrSnifferBuffersCntr;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 20, rxNumberPtr);
        if( GT_OK != rc )
        {
            return rc;
        }


        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.muliticastFilterCntrs.egrSnifferBuffersCntr;
        return prvCpssHwPpGetRegField(devNum, regAddr, 0, 20, txNumberPtr);
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.mcFilterCounters.snifferBuffersCounter;

        rc = prvCpssHwPpReadRegister(devNum, regAddr, &regData);
        if( GT_OK != rc )
        {
            return rc;
        }

        *rxNumberPtr = U32_GET_FIELD_MAC(regData, 0, 16);
        *txNumberPtr = U32_GET_FIELD_MAC(regData, 16, 16);

        return GT_OK;
    }
}

/**
* @internal cpssDxChPortTxSniffedBufNumberGet function
* @endinternal
*
* @brief   Gets total number of mirrored buffers allocated.
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] rxNumberPtr              - number of ingress mirrored buffers.
* @param[out] txNumberPtr              - number of egress mirrored buffers.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSniffedBufNumberGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *rxNumberPtr,
    OUT GT_U32  *txNumberPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSniffedBufNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, rxNumberPtr, txNumberPtr));

    rc = internal_cpssDxChPortTxSniffedBufNumberGet(devNum, rxNumberPtr, txNumberPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, rxNumberPtr, txNumberPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSharedResourceDescNumberGet function
* @endinternal
*
* @brief   Gets total number of descriptors allocated from the shared descriptors
*         pool.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue (0..7).
*
* @param[out] numberPtr                - number of descriptors
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong poolNum or devNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSharedResourceDescNumberGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  tcQueue,
    OUT GT_U32  *numberPtr
)
{
    GT_U32 regAddr; /* register address */
    GT_U32 fieldLength;/* the number of bits to be written to register */
    GT_STATUS rc; /* return status */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(numberPtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if( tcQueue >= TC_NUM_CNS )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    fieldLength = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 16 : 14;

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropCntrs.priorityDescCntr[tcQueue];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.counters.tcSharedDescCounter[tcQueue];
    }

    rc = prvCpssPortGroupsCounterSummary(devNum, regAddr, 0, fieldLength, numberPtr, NULL);
    if (rc != GT_OK)
    {
        return rc;
    }

    if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        /* constant 128 is added to the register need to reduce it from results */
        *numberPtr -= 128;
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxSharedResourceDescNumberGet function
* @endinternal
*
* @brief   Gets total number of descriptors allocated from the shared descriptors
*         pool.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue (0..7).
*
* @param[out] numberPtr                - number of descriptors
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong poolNum or devNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSharedResourceDescNumberGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  tcQueue,
    OUT GT_U32  *numberPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSharedResourceDescNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcQueue, numberPtr));

    rc = internal_cpssDxChPortTxSharedResourceDescNumberGet(devNum, tcQueue, numberPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcQueue, numberPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSharedResourceBufNumberGet function
* @endinternal
*
* @brief   Gets the number of virtual buffers enqueued from the shared buffer pool.
*
* @note   APPLICABLE DEVICES:       Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue (0..7).
*
* @param[out] numberPtr                - number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong poolNum or devNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSharedResourceBufNumberGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  tcQueue,
    OUT GT_U32  *numberPtr
)
{
    GT_U32 regAddr; /* register address */
    GT_U32 len;     /* register field lenght */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(numberPtr);

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    if( tcQueue >= TC_NUM_CNS )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropCntrs.priorityBuffersCntr[tcQueue];
        len = 20;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.counters.tcSharedBuffersCounter[tcQueue];
        len = 14;
    }

    return prvCpssPortGroupsCounterSummary(devNum, regAddr, 0, len, numberPtr,NULL);
}

/**
* @internal cpssDxChPortTxSharedResourceBufNumberGet function
* @endinternal
*
* @brief   Gets the number of virtual buffers enqueued from the shared buffer pool.
*
* @note   APPLICABLE DEVICES:       Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] tcQueue                  - traffic class queue (0..7).
*
* @param[out] numberPtr                - number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong poolNum or devNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSharedResourceBufNumberGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  tcQueue,
    OUT GT_U32  *numberPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSharedResourceBufNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcQueue, numberPtr));

    rc = internal_cpssDxChPortTxSharedResourceBufNumberGet(devNum, tcQueue, numberPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcQueue, numberPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperOnStackAsGigEnableSet function
* @endinternal
*
* @brief   Enables/Disables the shaper on stacking ports (24-27) to operate as
*         Tri Speed ports' shapers.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE, stacking ports shapers operates
*                                      as Tri Speed ports' shapers.
*                                      GT_FALSE, stacking ports shapers operates as XG ports.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note When "Stack As Gig" enabled, for a port number in the range 24..27,
*       whether Gig or XG type, the global shaper used parameters are those
*       referenced as gig ones -
*       "gigPortsTokensRate" and "gigPortsSlowRateRatio" inputs for
*       "cpssDxChPortTxShaperGlobalParamsSet" API.
*
*/
static GT_STATUS internal_cpssDxChPortTxShaperOnStackAsGigEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_U32      regAddr;    /* register address */
    GT_STATUS   rc;         /* function return code */
    GT_U32      value;      /* value to write into register */
    GT_U32      fieldOffset;/* the start bit number in the register */
    GT_BOOL     oldEnable;
    GT_PHYSICAL_PORT_NUM       port;
    GT_U32      tcQueue = 0;
    GT_U32      xgPortsTokensRate;
    GT_U32      gigPortsTokensRate;
    GT_U32      gigPortsSlowRateRatio;

    /* check parameters */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    regAddr = PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum) ?
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQMcFifoEccConfig :
    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueMiscCtrl;

    fieldOffset = PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum) ? 31 : 10;

    /* read the old value */
    rc = prvCpssDrvHwPpGetRegField(devNum,regAddr,fieldOffset,1,&value);
    if(rc != GT_OK)
    {
        return rc;
    }

    oldEnable = BIT2BOOL_MAC(value);

    /* do nothing if same value */
    if (enable == oldEnable)
    {
        return GT_OK;
    }

    /* write register value */
    value = BOOL2BIT_MAC(enable);
    rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,fieldOffset,1,value);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* get global shaper params */
    rc = cpssDxChPortTxShaperGlobalParamsGet(devNum,
        &xgPortsTokensRate,
        &gigPortsTokensRate,
        &gigPortsSlowRateRatio);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* update TB parameters on stacking ports */
    for (port = 24; port < 28; port++)
    {
        if (! PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, port))
            continue;

        /* per port */
        rc = prvDxChPortTxSetShaperTokenBucketParams(
            devNum,
            port,
            GT_FALSE,
            tcQueue,
            xgPortsTokensRate,
            gigPortsTokensRate,
            gigPortsSlowRateRatio,
            oldEnable,
            xgPortsTokensRate,
            gigPortsTokensRate,
            gigPortsSlowRateRatio,
            enable);

        if (rc != GT_OK)
        {
            return rc;
        }

        /* per port per traffic class (tcQueue) */
        for (tcQueue = 0; tcQueue < CPSS_TC_RANGE_CNS; tcQueue++)
        {
            rc = prvDxChPortTxSetShaperTokenBucketParams(
                devNum,
                port,
                GT_TRUE,
                tcQueue,
                xgPortsTokensRate,
                gigPortsTokensRate,
                gigPortsSlowRateRatio,
                oldEnable,
                xgPortsTokensRate,
                gigPortsTokensRate,
                gigPortsSlowRateRatio,
                enable);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    return rc;
}

/**
* @internal cpssDxChPortTxShaperOnStackAsGigEnableSet function
* @endinternal
*
* @brief   Enables/Disables the shaper on stacking ports (24-27) to operate as
*         Tri Speed ports' shapers.
*
* @note   APPLICABLE DEVICES:     xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE, stacking ports shapers operates
*                                      as Tri Speed ports' shapers.
*                                      GT_FALSE, stacking ports shapers operates as XG ports.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note When "Stack As Gig" enabled, for a port number in the range 24..27,
*       whether Gig or XG type, the global shaper used parameters are those
*       referenced as gig ones -
*       "gigPortsTokensRate" and "gigPortsSlowRateRatio" inputs for
*       "cpssDxChPortTxShaperGlobalParamsSet" API.
*
*/
GT_STATUS cpssDxChPortTxShaperOnStackAsGigEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperOnStackAsGigEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPortTxShaperOnStackAsGigEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperOnStackAsGigEnableGet function
* @endinternal
*
* @brief   Gets the current state (enable/disable) of the shaper's mode on
*         stacking ports (24-27).
*
* @note   APPLICABLE DEVICES:     xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE, stacking ports shapers operates
*                                      as Tri Speed ports' shapers.
*                                      GT_FALSE, stacking ports shapers operates as XG ports.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxShaperOnStackAsGigEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL  *enablePtr
)
{
    GT_U32    regAddr;     /* register address */
    GT_STATUS rc;          /* function return code */
    GT_U32    value;       /* value to read from the register */
    GT_U32    fieldOffset; /* the start bit number in the register */

    /* check parameters */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    /* read register value */
    regAddr = PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum) ?
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQMcFifoEccConfig :
    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueMiscCtrl;

    fieldOffset = PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum) ? 31 : 10;

    rc = prvCpssDrvHwPpGetRegField(devNum,regAddr,fieldOffset,1,&value);

    *enablePtr = BIT2BOOL_MAC(value);

    return rc;
}

/**
* @internal cpssDxChPortTxShaperOnStackAsGigEnableGet function
* @endinternal
*
* @brief   Gets the current state (enable/disable) of the shaper's mode on
*         stacking ports (24-27).
*
* @note   APPLICABLE DEVICES:     xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE, stacking ports shapers operates
*                                      as Tri Speed ports' shapers.
*                                      GT_FALSE, stacking ports shapers operates as XG ports.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxShaperOnStackAsGigEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL  *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperOnStackAsGigEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPortTxShaperOnStackAsGigEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortProfileTxByteCountChangeEnableSet function
* @endinternal
*
* @brief   Enables/Disables profile Byte Count Change of the packet length by per port
*         constant for shaping and/or scheduling rate calculation.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] profile                  - scheduler  index
* @param[in] bcMode                   - byte count change enable options
* @param[in] bcOp                     - addition or subtraction of the per port value.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on illegal profile, bcMode, bcOp
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortProfileTxByteCountChangeEnableSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profile,
    IN  CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_ENT  bcMode,
    IN  CPSS_ADJUST_OPERATION_ENT               bcOp
)
{
    GT_U32      regAddr;    /* register address */
    GT_STATUS   rc;         /* function return code */
    GT_U32      regValue;   /* value to write into register */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_SCHEDULER_PROFILE_CHECK_MAC(profile, devNum);

    switch (bcMode)
    {
    case CPSS_DXCH_PORT_TX_BC_CHANGE_DISABLE_ALL_E:
        regValue = 0x0;
        break;
    case CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SHAPER_ONLY_E:
        regValue = 0x1 << 7;
        break;
    case CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SCHEDULER_ONLY_E:
        regValue = 0x1 << 8;
        break;
    case CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SHAPER_AND_SCHEDULER_E:
        regValue = 0x3 << 7;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch (bcOp)
    {
    case CPSS_ADJUST_OPERATION_ADD_E:
        break;
    case CPSS_ADJUST_OPERATION_SUBSTRUCT_E:
        regValue|= 0x1 << 6;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.profileByteCountModification[profile];

    rc = prvCpssHwPpWriteRegBitMask(devNum, regAddr, (0x7 << 6), regValue);

    return rc;
}

/**
* @internal cpssDxChPortProfileTxByteCountChangeEnableSet function
* @endinternal
*
* @brief   Enables/Disables profile Byte Count Change of the packet length by per port
*         constant for shaping and/or scheduling rate calculation.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] profile                  - scheduler  index
* @param[in] bcMode                   - byte count change enable options
* @param[in] bcOp                     - addition or subtraction of the per port value.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on illegal profile, bcMode, bcOp
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortProfileTxByteCountChangeEnableSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profile,
    IN  CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_ENT  bcMode,
    IN  CPSS_ADJUST_OPERATION_ENT               bcOp
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortProfileTxByteCountChangeEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profile, bcMode, bcOp));

    rc = internal_cpssDxChPortProfileTxByteCountChangeEnableSet(devNum, profile, bcMode, bcOp);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profile, bcMode, bcOp));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortProfileTxByteCountChangeEnableGet function
* @endinternal
*
* @brief   Get profile Byte Count Change mode.
*         The byte count change mode changes the length of a packet by per port
*         constant for shaping and/or scheduling rate calculation.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] profile                  - scheduler  index
*
* @param[out] bcModePtr                - (pointer to) byte count change enable options.
* @param[out] bcOpPtr                  - (pointer to) addition or subtraction of the per port value.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on illegal profile
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortProfileTxByteCountChangeEnableGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profile,
    OUT CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_ENT  *bcModePtr,
    OUT CPSS_ADJUST_OPERATION_ENT               *bcOpPtr
)
{
    GT_U32      regAddr;    /* register address */
    GT_STATUS   rc;         /* function return code */
    GT_U32      regValue;   /* value to write into register */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    CPSS_NULL_PTR_CHECK_MAC(bcModePtr);
    CPSS_NULL_PTR_CHECK_MAC(bcOpPtr);
    PRV_CPSS_DXCH_SCHEDULER_PROFILE_CHECK_MAC(profile, devNum);

    regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.profileByteCountModification[profile];

    rc = prvCpssHwPpReadRegBitMask(devNum, regAddr, (0x7 << 6), &regValue);
    if(rc != GT_OK)
    {
        return rc;
    }

    switch ((regValue >> 7) & 0x3)
    {
    case 0:
        *bcModePtr = CPSS_DXCH_PORT_TX_BC_CHANGE_DISABLE_ALL_E;
        break;
    case 1:
        *bcModePtr = CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SHAPER_ONLY_E;
        break;
    case 2:
        *bcModePtr = CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SCHEDULER_ONLY_E;
        break;
    case 3:
        *bcModePtr = CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SHAPER_AND_SCHEDULER_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    *bcOpPtr = (((regValue >> 6) & 0x1) == 1) ? CPSS_ADJUST_OPERATION_SUBSTRUCT_E : CPSS_ADJUST_OPERATION_ADD_E;

    return GT_OK;
}

/**
* @internal cpssDxChPortProfileTxByteCountChangeEnableGet function
* @endinternal
*
* @brief   Get profile Byte Count Change mode.
*         The byte count change mode changes the length of a packet by per port
*         constant for shaping and/or scheduling rate calculation.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] profile                  - scheduler  index
*
* @param[out] bcModePtr                - (pointer to) byte count change enable options.
* @param[out] bcOpPtr                  - (pointer to) addition or subtraction of the per port value.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on illegal profile
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortProfileTxByteCountChangeEnableGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profile,
    OUT CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_ENT  *bcModePtr,
    OUT CPSS_ADJUST_OPERATION_ENT               *bcOpPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortProfileTxByteCountChangeEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profile, bcModePtr, bcOpPtr));

    rc = internal_cpssDxChPortProfileTxByteCountChangeEnableGet(devNum, profile, bcModePtr, bcOpPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profile, bcModePtr, bcOpPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxByteCountChangeEnableSet function
* @endinternal
*
* @brief   Enables/Disables Byte Count Change of the packet length by per port
*         constant for shaping and/or scheduling rate calculation.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number.
* @param[in] bcChangeEnable           - Byte Count Change enable opition.
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number or BC change option
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxByteCountChangeEnableSet
(
    IN  GT_U8     devNum,
    IN  CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_ENT bcChangeEnable
)
{
    GT_U32      regAddr;    /* register address */
    GT_STATUS   rc;         /* function return code */
    GT_U32      value;      /* value to write into register */
    GT_U32      mask;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    switch (bcChangeEnable)
    {
    case CPSS_DXCH_PORT_TX_BC_CHANGE_DISABLE_ALL_E:
        value = 0;
        break;
    case CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SHAPER_ONLY_E:
        value = PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum) ? 0x600 : 0x300;
        break;
    case CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SCHEDULER_ONLY_E:
        value = PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum) ? 0xA00 : 0x900;
        break;
    case CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SHAPER_AND_SCHEDULER_E:
        value = PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum) ? 0xE00 : 0xB00;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    mask = PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum) ? 0xE00 : 0xB00;

    /* write register value */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueMiscCtrl;
    rc = prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, mask, value);

    return rc;
}

/**
* @internal cpssDxChPortTxByteCountChangeEnableSet function
* @endinternal
*
* @brief   Enables/Disables Byte Count Change of the packet length by per port
*         constant for shaping and/or scheduling rate calculation.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number.
* @param[in] bcChangeEnable           - Byte Count Change enable opition.
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number or BC change option
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxByteCountChangeEnableSet
(
    IN  GT_U8     devNum,
    IN  CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_ENT bcChangeEnable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxByteCountChangeEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, bcChangeEnable));

    rc = internal_cpssDxChPortTxByteCountChangeEnableSet(devNum, bcChangeEnable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, bcChangeEnable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxByteCountChangeEnableGet function
* @endinternal
*
* @brief   Gets the Byte Count Change enable opition.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number.
*
* @param[out] bcChangeEnablePtr        - (pointer to) Byte Count Change enable opition.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxByteCountChangeEnableGet
(
    IN  GT_U8     devNum,
    OUT CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_ENT *bcChangeEnablePtr
)
{
    GT_U32      regAddr;    /* register address */
    GT_STATUS   rc;         /* function return code */
    GT_U32      value;      /* value to read from the register  */
    GT_BOOL     shaperEnabled,schedulerEnabled;

    /* check parameters */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(bcChangeEnablePtr);

    /* read register value */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueMiscCtrl;
    rc = prvCpssDrvHwPpGetRegField(devNum,regAddr,9,3,&value);
    if (rc != GT_OK)
        return rc;

    shaperEnabled = PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum) ?
        BIT2BOOL_MAC((value & 0x2) >> 1) :
    BIT2BOOL_MAC(value & 0x1);
    schedulerEnabled = BIT2BOOL_MAC((value & 0x4) >> 2);

    if (shaperEnabled == GT_FALSE && schedulerEnabled == GT_FALSE)
    {
        *bcChangeEnablePtr = CPSS_DXCH_PORT_TX_BC_CHANGE_DISABLE_ALL_E;
    }
    else if(shaperEnabled == GT_TRUE && schedulerEnabled == GT_FALSE)
    {
        *bcChangeEnablePtr = CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SHAPER_ONLY_E;
    }
    else if(shaperEnabled == GT_FALSE && schedulerEnabled == GT_TRUE)
    {
        *bcChangeEnablePtr = CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SCHEDULER_ONLY_E;
    }
    else
    {
        *bcChangeEnablePtr = CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_SHAPER_AND_SCHEDULER_E;
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxByteCountChangeEnableGet function
* @endinternal
*
* @brief   Gets the Byte Count Change enable opition.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number.
*
* @param[out] bcChangeEnablePtr        - (pointer to) Byte Count Change enable opition.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxByteCountChangeEnableGet
(
    IN  GT_U8     devNum,
    OUT CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_ENT *bcChangeEnablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxByteCountChangeEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, bcChangeEnablePtr));

    rc = internal_cpssDxChPortTxByteCountChangeEnableGet(devNum, bcChangeEnablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, bcChangeEnablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal prvCpssDxChAldrin2ErmrkPortTxByteCountChangeValueSet function
* @endinternal
*
* @brief   Sets the number of bytes added/subtracted to the length of every frame
*          dropped in egress pipe to be counted in scheduler and shaper TXQ DQ mechanisms
*          for given port when Byte Count Change is enabled.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] bcValue                  - number of bytes added/subtracted to the length of every frame
*                                      for shaping/scheduling rate calculation.
*                                  (APPLICABLE RANGES: 0..63)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1. To globally enable/disable Byte Count Change,
*       use cpssDxChPortTxByteCountChangeEnableSet
*       2. To update bcValue for given port Byte Count Change globally disabled.
*       This can cause side effects to shaper/scheduler behavior
*       on other ports if performed under traffic.
*
*/
static GT_STATUS prvCpssDxChAldrin2ErmrkPortTxByteCountChangeValueSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM     portNum,
    IN  GT_32     bcValue
)
{
    GT_U32      value;      /* value to write */
    GT_STATUS   rc;         /* function return code */
    CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet;
    CPSS_DXCH_PORT_TX_BC_CHANGE_ENABLE_ENT  bcMode;
    CPSS_ADJUST_OPERATION_ENT               bcOp;

    /* retrieve operation mode (add/subtract from profile bound to port)*/
    rc = cpssDxChPortTxBindPortToSchedulerProfileGet(
        devNum, portNum, &profileSet);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    rc  = cpssDxChPortProfileTxByteCountChangeEnableGet(
        devNum, profileSet, &bcMode, &bcOp);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    /* update ERMRK target port entry fields */
    /* Port bc cfg value bits[326:321]       */
    /* Port bc cfg sign bit[327]             */
    switch (bcOp)
    {
    case CPSS_ADJUST_OPERATION_ADD_E:       value = 1; break;
    case CPSS_ADJUST_OPERATION_SUBSTRUCT_E: value = 0; break;
    default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }
    value = (value << 6) | (GT_U32)bcValue;
    return prvCpssDxChWriteTableEntryField(
        devNum, CPSS_DXCH_SIP5_TABLE_ERMRK_PTP_TARGET_PORT_E,
        portNum, PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
        321/*fieldOffset*/, 7 /*fieldLength*/, value);
}

/**
* @internal internal_cpssDxChPortTxByteCountChangeValueSet function
* @endinternal
*
* @brief   Sets the number of bytes added/subtracted to the length of every frame
*         for shaping/scheduling rate calculation for given port when
*         Byte Count Change is enabled.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] bcValue                  - number of bytes added to the length of every frame
*                                      for shaping/scheduling rate calculation.
*                                     (APPLICABLE RANGES: xCat3; AC5: -63..63;
*                                                         Bobcat2,Falcon: 0..63)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1. To globally enable/disable Byte Count Change,
*       use cpssDxChPortTxByteCountChangeEnableSet
*       2. To update bcValue for given port Byte Count Change globally disabled.
*       This can cause side effects to shaper/scheduler behavior
*       on other ports if performed under traffic.
*
*/
static GT_STATUS internal_cpssDxChPortTxByteCountChangeValueSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM     portNum,
    IN  GT_32     bcValue
)
{
    GT_U32      value;      /* value to write */
    GT_STATUS   rc;         /* function return code */
    GT_U32      regAddr;    /* register address */
    GT_BOOL     bcEnable;
    GT_U32      enableBcChangefieldOffset;
    GT_U32      txqPortNum; /* TXQ port number */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_LION2_E);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssFalconTxqPdsByteCountChangeValueSet(devNum,portNum,bcValue);

    }
    else if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);

        if((bcValue >= BIT_6) || (bcValue < 0))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        if (PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
        {
            rc = prvCpssDxChAldrin2ErmrkPortTxByteCountChangeValueSet(
                devNum, portNum, bcValue);
            if (rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
            }
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.portBCConstantValue[txqPortNum];

        return prvCpssHwPpSetRegField(devNum, regAddr, 0, 6, bcValue);
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        enableBcChangefieldOffset = PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum) ? 9 : 8;

        /* The field MUST be updated only when the feature is globally disabled.*/
        /* Get the value of <EnableBcChange> */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueMiscCtrl;
        rc = prvCpssDrvHwPpGetRegField(devNum,regAddr,enableBcChangefieldOffset,1,&value);
        if (rc != GT_OK)
            return rc;

        /* Disable if enabled */
        bcEnable = BIT2BOOL_MAC(value);
        if (bcEnable == GT_TRUE)
        {
            rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,enableBcChangefieldOffset,1,0);
            if (rc != GT_OK)
                return rc;
        }

        /* prepare value to write */
        if (bcValue >= 0 && bcValue < 64)
        {
            value = bcValue;
        }
        else if (bcValue < 0 && bcValue > -64)
        {
            value = bcValue * (-1);
            value |= 1 << 6;
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        if(portNum == CPSS_CPU_PORT_NUM_CNS)
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                egrTxQConf.txCpuRegs.l1OverheadConfig;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                egrTxQConf.txPortRegs[portNum].l1OverheadConfig;
        }

        /* write register value */
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 4, 7, value);
        if (rc != GT_OK)
            return rc;

        /* restore EnableBcChange value */
        if (bcEnable == GT_TRUE)
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueMiscCtrl;
            rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,enableBcChangefieldOffset,1,1);
            if (rc != GT_OK)
                return rc;
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxByteCountChangeValueSet function
* @endinternal
*
* @brief   Sets the number of bytes added/subtracted to the length of every frame
*         for shaping/scheduling rate calculation for given port when
*         Byte Count Change is enabled.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] bcValue                  - number of bytes added to the length of every frame
*                                      for shaping/scheduling rate calculation.
*                                       (APPLICABLE RANGES: xCat3; AC5: -63..63;
*                                                           Bobcat2,Falcon: 0..63)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note 1. To globally enable/disable Byte Count Change,
*       use cpssDxChPortTxByteCountChangeEnableSet
*       2. To update bcValue for given port Byte Count Change globally disabled.
*       This can cause side effects to shaper/scheduler behavior
*       on other ports if performed under traffic.
*
*/
GT_STATUS cpssDxChPortTxByteCountChangeValueSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM     portNum,
    IN  GT_32     bcValue
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxByteCountChangeValueSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, bcValue));

    rc = internal_cpssDxChPortTxByteCountChangeValueSet(devNum, portNum, bcValue);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, bcValue));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxByteCountChangeValueGet function
* @endinternal
*
* @brief   Gets the number of bytes added/subtracted to the length of every frame
*         for shaping/scheduling rate calculation for given port when
*         Byte Count Change is enabled.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2.
*
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] bcValuePtr               - (pointer to) number of bytes added to the length of
*                                      every frame for shaping/scheduling rate calculation.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxByteCountChangeValueGet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM     portNum,
    OUT GT_32    *bcValuePtr
)
{
    GT_U32      value;      /* value to write */
    GT_STATUS   rc;         /* function return code */
    GT_U32      regAddr;    /* register address */
    GT_U32      txqPortNum; /* TXQ port number */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(bcValuePtr);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssFalconTxqPdsByteCountChangeValueGet(devNum,portNum,bcValuePtr);

    }
    else if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.portBCConstantValue[txqPortNum];

        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 6, &value);
        if(GT_OK != rc)
        {
            return rc;
        }

        *bcValuePtr = value;
    }
    else
    {

        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        if(portNum == CPSS_CPU_PORT_NUM_CNS)
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                egrTxQConf.txCpuRegs.l1OverheadConfig;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                egrTxQConf.txPortRegs[portNum].l1OverheadConfig;
        }

        /* read register value */
        rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, 4, 7, &value);
        if (rc != GT_OK)
            return rc;

        *bcValuePtr = (value & 0x40) ? (value & 0x3F) * -1 :
        (value & 0x3F);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxByteCountChangeValueGet function
* @endinternal
*
* @brief   Gets the number of bytes added/subtracted to the length of every frame
*         for shaping/scheduling rate calculation for given port when
*         Byte Count Change is enabled.
*
* @note   APPLICABLE DEVICES:           xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] bcValuePtr               - (pointer to) number of bytes added to the length of
*                                      every frame for shaping/scheduling rate calculation.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxByteCountChangeValueGet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM     portNum,
    OUT GT_32    *bcValuePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxByteCountChangeValueGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, bcValuePtr));

    rc = internal_cpssDxChPortTxByteCountChangeValueGet(devNum, portNum, bcValuePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, bcValuePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxGlobalDescLimitSet function
* @endinternal
*
* @brief   Set limits of total descriptors in all egress queues
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;.
*
* @param[in] devNum                   - device number.
* @param[in] limit                    - total descriptor  value
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_OUT_OF_RANGE          - on limit out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Improper configuration of descriptors limit may affect entire system behavior
*
*/
static GT_STATUS internal_cpssDxChPortTxGlobalDescLimitSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  limit
)
{
    GT_U32  regAddr;          /* register address */
    GT_U32  fieldLength;      /* the number of bits to be written to register */
    GT_STATUS rc;
    GT_U32 pbSize;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        fieldLength = 20;
    }
    else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        fieldLength = 16;
    }
    else
    {
        fieldLength = 14;
    }

    /* Check number of total descriptors - 14/16 bits in HW */
    if (limit >= (GT_U32)(1 << fieldLength))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        rc = prvCpssSip6TxqUtilsPbSizeGet(devNum,&pbSize);
        if(rc!=GT_OK)
        {
           CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }

        if(limit >pbSize)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "limit [%d]is out of range[%d].\n",
                limit,pbSize);
        }
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).globalTailDropLimit;
        }
        else
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropLimits.globalDescsLimit;
        }
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.limits.globalDescriptorsLimit;
    }

    /* Set the number of total descriptors in all egress queues */
    return prvCpssHwPpSetRegField(devNum, regAddr, 0, fieldLength, limit);
}

/**
* @internal cpssDxChPortTxGlobalDescLimitSet function
* @endinternal
*
* @brief   Set limits of total descriptors in all egress queues
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;.
*
* @param[in] devNum                   - device number.
* @param[in] limit                    - total descriptor  value
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_OUT_OF_RANGE          - on limit out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Improper configuration of descriptors limit may affect entire system behavior
*
*/
GT_STATUS cpssDxChPortTxGlobalDescLimitSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  limit
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxGlobalDescLimitSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, limit));

    rc = internal_cpssDxChPortTxGlobalDescLimitSet(devNum, limit);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, limit));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxGlobalDescLimitGet function
* @endinternal
*
* @brief   Get limits of total descriptors in all egress queues
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;.
*
* @param[in] devNum                   - device number.
*
* @param[out] limitPtr                 -  pointer to total descriptor limit value
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxGlobalDescLimitGet
(
    IN  GT_U8   devNum,
    OUT GT_U32 *limitPtr
)
{
    GT_U32  regAddr;          /* register address */
    GT_U32  fieldLength;      /* the number of bits to be written to register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E);

    CPSS_NULL_PTR_CHECK_MAC(limitPtr);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        fieldLength = 20;
    }
    else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        fieldLength = 16;
    }
    else
    {
        fieldLength = 14;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).globalTailDropLimit;
        }
        else
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropLimits.globalDescsLimit;
        }
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.tailDrop.limits.globalDescriptorsLimit;
    }


    /* Get the number of total descriptors in all egress queues */
    return prvCpssDrvHwPpGetRegField(devNum, regAddr, 0, fieldLength, limitPtr);
}

/**
* @internal cpssDxChPortTxGlobalDescLimitGet function
* @endinternal
*
* @brief   Get limits of total descriptors in all egress queues
*
* @note   APPLICABLE DEVICES:     Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;.
*
* @param[in] devNum                   - device number.
*
* @param[out] limitPtr                 -  pointer to total descriptor limit value
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on invalid input paramters value
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxGlobalDescLimitGet
(
    IN  GT_U8   devNum,
    OUT GT_U32 *limitPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxGlobalDescLimitGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, limitPtr));

    rc = internal_cpssDxChPortTxGlobalDescLimitGet(devNum, limitPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, limitPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMcFifoSet function
* @endinternal
*
* @brief   Enable/Disable selected MC FIFO for specified egress port.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] mcFifo                   - MC FIFO number (APPLICABLE RANGES: Lion2, Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2 0..3;
*                                                                          Falcon 0..1)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong dev, port or mcFifo
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMcFifoSet
(
    IN GT_U8        devNum,
    IN GT_PORT_NUM  portNum,
    IN GT_U32        mcFifo
)
{
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32  portBmpRegIdx; /* index of register */
    GT_STATUS   rc; /* return code */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E);

    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_CHECK_MAC(devNum,portNum);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        return prvCpssDxChHwEgfEftFieldSet(devNum,portNum,
            PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_MC_FIFO_PORT_TO_MC_FIFO_ATTRIBUTION_E,
            mcFifo);
    }

    if( mcFifo > 1 )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

    portBmpRegIdx = OFFSET_TO_WORD_MAC(portNum);
    if (portBmpRegIdx >= PORTS_BMP_NUM_SIP_4_CNS)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    /* Not used MC FIFO is not selected */
    rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
        mcFifoConfig.distributionMask[1 - mcFifo][portBmpRegIdx],
        OFFSET_TO_BIT_MAC(portNum), 1, 0);
    if( GT_OK != rc )
    {
        return rc;
    }

    /* selected MC FIFO */
    rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
        mcFifoConfig.distributionMask[mcFifo][portBmpRegIdx],
        OFFSET_TO_BIT_MAC(portNum), 1, 1);

    return rc;
}

/**
* @internal cpssDxChPortTxMcFifoSet function
* @endinternal
*
* @brief   Enable/Disable selected MC FIFO for specified egress port.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] mcFifo                   - MC FIFO number (APPLICABLE RANGES: Lion2, Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2 0..3;
*                                                                          Falcon 0..1)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong dev, port or mcFifo
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxMcFifoSet
(
    IN GT_U8        devNum,
    IN GT_PORT_NUM  portNum,
    IN GT_U32        mcFifo
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcFifoSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, mcFifo));

    rc = internal_cpssDxChPortTxMcFifoSet(devNum, portNum, mcFifo);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, mcFifo));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMcFifoGet function
* @endinternal
*
* @brief   Gets state (Enable/Disable) of selected MC FIFO for specified egress port.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*
* @param[out] mcFifoPtr                - (pointer to) MC FIFO number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong dev or port
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_STATE             - wrong HW configuration
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMcFifoGet
(
    IN GT_U8        devNum,
    IN GT_PORT_NUM  portNum,
    OUT GT_U32       *mcFifoPtr
)
{
    GT_U32      value0;      /* hardware value for MC FIFO 0 */
    GT_U32      value1;      /* hardware value for MC FIFO 1 */
    GT_STATUS   rc;
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32  portBmpRegIdx; /* index of register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E);
    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_CHECK_MAC(devNum,portNum);
    CPSS_NULL_PTR_CHECK_MAC(mcFifoPtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        return prvCpssDxChHwEgfEftFieldGet(devNum,portNum,
            PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_MC_FIFO_PORT_TO_MC_FIFO_ATTRIBUTION_E,
            mcFifoPtr);
    }

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

    portBmpRegIdx = OFFSET_TO_WORD_MAC(portNum);
    if (portBmpRegIdx >= PORTS_BMP_NUM_SIP_4_CNS)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
        mcFifoConfig.distributionMask[0][portBmpRegIdx],
        OFFSET_TO_BIT_MAC(portNum), 1, &value0);

    if (GT_OK != rc)
    {
        return rc;
    }

    rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
        mcFifoConfig.distributionMask[1][portBmpRegIdx],
        OFFSET_TO_BIT_MAC(portNum), 1, &value1);

    if (GT_OK != rc)
    {
        return rc;
    }

    if( (1 == value0) && (0==value1) )
    {
        *mcFifoPtr = 0;
    }
    else if( (0 == value0) && (1==value1) )
    {
        *mcFifoPtr = 1;
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxMcFifoGet function
* @endinternal
*
* @brief   Gets state (Enable/Disable) of selected MC FIFO for specified egress port.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*
* @param[out] mcFifoPtr                - (pointer to) MC FIFO number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong dev or port
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_STATE             - wrong HW configuration
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxMcFifoGet
(
    IN GT_U8        devNum,
    IN GT_PORT_NUM  portNum,
    OUT GT_U32       *mcFifoPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcFifoGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, mcFifoPtr));

    rc = internal_cpssDxChPortTxMcFifoGet(devNum, portNum, mcFifoPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, mcFifoPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMcFifoArbiterWeigthsSet function
* @endinternal
*
* @brief   Configure the Multicast arbiter weights for MC FIFOs.
*
* @note   APPLICABLE DEVICES:            Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] weigthsPtr               - (pointer to) Multicast arbiter weights
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong dev
* @retval GT_OUT_OF_RANGE          - FIFO weight out of range
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMcFifoArbiterWeigthsSet
(
    IN GT_U8        devNum,
    IN CPSS_PORT_TX_MC_FIFO_ARBITER_WEIGHTS_STC  *weigthsPtr
)
{
    GT_U32      regData; /* register HW data */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E);
    CPSS_NULL_PTR_CHECK_MAC(weigthsPtr);

    if( (weigthsPtr->mcFifo0 >= BIT_8) ||
    (weigthsPtr->mcFifo1 >= BIT_8) )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    regData = weigthsPtr->mcFifo0;
    U32_SET_FIELD_MAC(regData, 8, 8, weigthsPtr->mcFifo1);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        if( (weigthsPtr->mcFifo2 >= BIT_8) ||
        (weigthsPtr->mcFifo3 >= BIT_8) )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        U32_SET_FIELD_MAC(regData, 16, 8, weigthsPtr->mcFifo2);
        U32_SET_FIELD_MAC(regData, 24, 8, weigthsPtr->mcFifo3);

        return prvCpssHwPpWriteRegister(devNum,
            PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).MCFIFO.MCFIFOConfigs.MCFIFOArbiterWeights0,
            regData);

    }
    else
    {

        return prvCpssHwPpSetRegField(devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
            mcFifoConfig.arbiterWeights,
            0, 16, regData);
    }
}

/**
* @internal cpssDxChPortTxMcFifoArbiterWeigthsSet function
* @endinternal
*
* @brief   Configure the Multicast arbiter weights for MC FIFOs.
*
* @note   APPLICABLE DEVICES:            Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] weigthsPtr               - (pointer to) Multicast arbiter weights
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong dev
* @retval GT_OUT_OF_RANGE          - FIFO weight out of range
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxMcFifoArbiterWeigthsSet
(
    IN GT_U8        devNum,
    IN CPSS_PORT_TX_MC_FIFO_ARBITER_WEIGHTS_STC  *weigthsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcFifoArbiterWeigthsSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, weigthsPtr));

    rc = internal_cpssDxChPortTxMcFifoArbiterWeigthsSet(devNum, weigthsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, weigthsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMcFifoArbiterWeigthsGet function
* @endinternal
*
* @brief   Get the Multicast arbiter weights for MC FIFOs configuration.
*
* @note   APPLICABLE DEVICES:            Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5.
*
* @param[in] devNum                   - device number
*
* @param[out] weigthsPtr               - (pointer to) Multicast arbiter weights
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong dev
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMcFifoArbiterWeigthsGet
(
    IN GT_U8        devNum,
    OUT CPSS_PORT_TX_MC_FIFO_ARBITER_WEIGHTS_STC  *weigthsPtr
)
{
    GT_U32      regData; /* register HW data */
    GT_STATUS   rc; /* return code */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E);

    CPSS_NULL_PTR_CHECK_MAC(weigthsPtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssHwPpReadRegister(devNum,
            PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).MCFIFO.MCFIFOConfigs.MCFIFOArbiterWeights0,
            &regData);

        weigthsPtr->mcFifo2 = U32_GET_FIELD_MAC(regData, 16, 8);
        weigthsPtr->mcFifo3 = U32_GET_FIELD_MAC(regData, 24, 8);
    }
    else
    {
        rc = prvCpssHwPpGetRegField(devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
            mcFifoConfig.arbiterWeights,
            0, 16, &regData);
    }

    weigthsPtr->mcFifo0 = U32_GET_FIELD_MAC(regData, 0, 8);
    weigthsPtr->mcFifo1 = U32_GET_FIELD_MAC(regData, 8, 8);

    return rc;
}

/**
* @internal cpssDxChPortTxMcFifoArbiterWeigthsGet function
* @endinternal
*
* @brief   Get the Multicast arbiter weights for MC FIFOs configuration.
*
* @note   APPLICABLE DEVICES:            Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5.
*
* @param[in] devNum                   - device number
*
* @param[out] weigthsPtr               - (pointer to) Multicast arbiter weights
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong dev
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxMcFifoArbiterWeigthsGet
(
    IN GT_U8        devNum,
    OUT CPSS_PORT_TX_MC_FIFO_ARBITER_WEIGHTS_STC  *weigthsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcFifoArbiterWeigthsGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, weigthsPtr));

    rc = internal_cpssDxChPortTxMcFifoArbiterWeigthsGet(devNum, weigthsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, weigthsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueGlobalTxEnableSet function
* @endinternal
*
* @brief   Enable/Disable transmission of specified device.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE,  transmission
*                                                          GT_FALSE, disable transmission
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueGlobalTxEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_U32  value;      /* value to write into register */
    GT_U32  regAddr;    /* register address             */
    GT_U32  regOffset;  /* register offset              */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    value = BOOL2BIT_MAC(enable);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.globalDequeueConfig;
        regOffset = 8;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.global.config.config;
        regOffset = 1;
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, regOffset, 1, value);
}

/**
* @internal cpssDxChPortTxQueueGlobalTxEnableSet function
* @endinternal
*
* @brief   Enable/Disable transmission of specified device.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE,  transmission
*                                                         GT_FALSE, disable transmission
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueGlobalTxEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueGlobalTxEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPortTxQueueGlobalTxEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueGlobalTxEnableGet function
* @endinternal
*
* @brief   Get the status of transmission of specified device (Enable/Disable).
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE, enable transmission
*                                      GT_FALSE, disable transmission
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueGlobalTxEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL   *enablePtr
)
{
    GT_U32  value;      /* value read from register */
    GT_U32  regAddr;    /* register address         */
    GT_U32  regOffset;  /* register offset          */
    GT_STATUS   rc;     /* return code              */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.globalDequeueConfig;
        regOffset = 8;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.dq.global.config.config;
        regOffset = 1;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, regOffset, 1, &value);
    if ( GT_OK != rc )
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/**
* @internal cpssDxChPortTxQueueGlobalTxEnableGet function
* @endinternal
*
* @brief   Get the status of transmission of specified device (Enable/Disable).
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE, enable transmission
*                                      GT_FALSE, disable transmission
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueGlobalTxEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL   *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueGlobalTxEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPortTxQueueGlobalTxEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxMcShaperMaskSet function
* @endinternal
*
* @brief   Function sets the multicast shaper mask value.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 ; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5 .
*
* @param[in] devNum                   - physical device number
* @param[in] mask                     -  value (APPLICABLE RANGE: 0..255)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_OUT_OF_RANGE          - on wrong mask
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMcShaperMaskSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  mask
)
{
    GT_U32      regAddr;    /* register address         */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E);

    if(mask >= BIT_8)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EGF_QAG_MAC(devNum).uniMultiArb.multiShaperCtrl;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.ucMcArb.mcShaperControl;
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 8, mask);
}

/**
* @internal cpssDxChPortTxMcShaperMaskSet function
* @endinternal
*
* @brief   Function sets the multicast shaper mask value.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 ; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5 .
*
* @param[in] devNum                   - physical device number
* @param[in] mask                     -  value (APPLICABLE RANGE: 0..255)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_OUT_OF_RANGE          - on wrong mask
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxMcShaperMaskSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  mask
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcShaperMaskSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mask));

    rc = internal_cpssDxChPortTxMcShaperMaskSet(devNum, mask);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mask));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMcShaperMaskGet function
* @endinternal
*
* @brief   Function gets the multicast shaper mask value.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 ; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5 .
*
* @param[in] devNum                   - physical device number
*
* @param[out] maskPtr                  - (pointer to) mask value
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMcShaperMaskGet
(
    IN  GT_U8       devNum,
    OUT GT_U32      *maskPtr
)
{
    GT_U32      regAddr;    /* register address         */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E);
    CPSS_NULL_PTR_CHECK_MAC(maskPtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EGF_QAG_MAC(devNum).uniMultiArb.multiShaperCtrl;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.ucMcArb.mcShaperControl;
    }

    return prvCpssHwPpGetRegField(devNum, regAddr, 0, 8, maskPtr);
}

/**
* @internal cpssDxChPortTxMcShaperMaskGet function
* @endinternal
*
* @brief   Function gets the multicast shaper mask value.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 ; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5 .
*
* @param[in] devNum                   - physical device number
*
* @param[out] maskPtr                  - (pointer to) mask value
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxMcShaperMaskGet
(
    IN  GT_U8       devNum,
    OUT GT_U32      *maskPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcShaperMaskGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, maskPtr));

    rc = internal_cpssDxChPortTxMcShaperMaskGet(devNum, maskPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, maskPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropProfileBufferConsumptionModeSet function
* @endinternal
*
* @brief   Sets the packet buffer consumption mode per Tail Drop profile.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Falcon; AC5P; AC5X; Harrier; Ironman; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - tail drop profile
* @param[in] mode                     - buffer consumption mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile or wrong mode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropProfileBufferConsumptionModeSet
(
    IN  GT_U8                                                   devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT                       profile,
    IN  CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT mode
)
{
    GT_U32  regAddr;    /* register address     */
    GT_U32  regData;    /* register data        */
    GT_U32  regDataLen; /* register data length */
    GT_U32  offset;     /* register offset */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(profile, devNum);

    switch (mode)
    {
    case CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_BYTE_E:
        regData = 0;
        break;
    case CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_PACKET_E:
        regData = 1;
        break;
    default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* ENQ Packet Length Mode Profile */
    offset =  1;
    regDataLen = 1;
    regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profileTailDropConfig[profile];

    return prvCpssHwPpSetRegField(devNum, regAddr, offset, regDataLen, regData);
}

/**
* @internal cpssDxChPortTxTailDropProfileBufferConsumptionModeSet function
* @endinternal
*
* @brief   Sets the packet buffer consumption mode per Tail Drop profile.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Falcon; AC5P; AC5X; Harrier; Ironman; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - tail drop profile
* @param[in] mode                     - buffer consumption mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile or wrong mode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropProfileBufferConsumptionModeSet
(
    IN  GT_U8                                                   devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT                       profile,
    IN  CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT mode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropProfileBufferConsumptionModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profile, mode));

    rc = internal_cpssDxChPortTxTailDropProfileBufferConsumptionModeSet(devNum, profile, mode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profile, mode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxTailDropProfileBufferConsumptionModeGet function
* @endinternal
*
* @brief   Gets the packet buffer consumption mode per Tail Drop profile.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - tail drop profile
*
* @param[out] modePtr                  - (pointer to) buffer consumption mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
static GT_STATUS internal_cpssDxChPortTxTailDropProfileBufferConsumptionModeGet
(
    IN  GT_U8                                                   devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT                       profile,
    OUT CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT *modePtr
)
{
    GT_STATUS rc;       /* return code          */
    GT_U32  regAddr;    /* register address     */
    GT_U32  regData;    /* register data        */
    GT_U32  regDataLen; /* register data length */
    GT_U32  offset;     /* register offset */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E | CPSS_LION2_E);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(profile, devNum);
    CPSS_NULL_PTR_CHECK_MAC(modePtr);

    /* ENQ Packet Length Mode Profile */
    offset =  1;
    regDataLen = 1;
    regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.profileTailDropConfig[profile];

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, regDataLen, &regData);
    if( GT_OK != rc )
    {
        return rc;
    }

    *modePtr = (regData == 0) ? CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_BYTE_E : CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_PACKET_E;

    return GT_OK;
}

/**
* @internal cpssDxChPortTxTailDropProfileBufferConsumptionModeGet function
* @endinternal
*
* @brief   Gets the packet buffer consumption mode per Tail Drop profile.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Falcon; AC5P; AC5X; Harrier; Ironman; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - tail drop profile
*
* @param[out] modePtr                  - (pointer to) buffer consumption mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
GT_STATUS cpssDxChPortTxTailDropProfileBufferConsumptionModeGet
(
    IN  GT_U8                                                   devNum,
    IN  CPSS_PORT_TX_DROP_PROFILE_SET_ENT                       profile,
    OUT CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT *modePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropProfileBufferConsumptionModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profile, modePtr));

    rc = internal_cpssDxChPortTxTailDropProfileBufferConsumptionModeGet(devNum, profile, modePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profile, modePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSchedulerProfileBufferConsumptionModeSet function
* @endinternal
*
* @brief   Sets the packet buffer consumption mode per Scheduler profile.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - scheduler profile
* @param[in] mode                     - buffer consumption mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile or wrong mode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSchedulerProfileBufferConsumptionModeSet
(
    IN  GT_U8                                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT                  profile,
    IN  CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT mode
)
{
    GT_U32  regAddr;    /* register address     */
    GT_U32  regData;    /* register data        */
    GT_U32  regDataLen; /* register data length */
    GT_U32  offset;     /* register offset */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_SCHEDULER_PROFILE_CHECK_MAC(profile, devNum);

    switch (mode)
    {
    case CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_BYTE_E:
        regData = 0;
        break;
    case CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_PACKET_E:
        regData = 1;
        break;
    default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* DQ Packet Length Mode Profile */
    offset =  0;
    regDataLen = 1;
    regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.profileByteCountModification[profile];

    return prvCpssHwPpSetRegField(devNum, regAddr, offset, regDataLen, regData);
}

/**
* @internal cpssDxChPortTxSchedulerProfileBufferConsumptionModeSet function
* @endinternal
*
* @brief   Sets the packet buffer consumption mode per Scheduler profile.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - scheduler profile
* @param[in] mode                     - buffer consumption mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile or wrong mode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSchedulerProfileBufferConsumptionModeSet
(
    IN  GT_U8                                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT                  profile,
    IN  CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT mode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSchedulerProfileBufferConsumptionModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profile, mode));

    rc = internal_cpssDxChPortTxSchedulerProfileBufferConsumptionModeSet(devNum, profile, mode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profile, mode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSchedulerProfileBufferConsumptionModeGet function
* @endinternal
*
* @brief   Gets the packet buffer consumption mode per Scheduler profile.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - scheduler profile
*
* @param[out] modePtr                  - (pointer to) buffer consumption mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
static GT_STATUS internal_cpssDxChPortTxSchedulerProfileBufferConsumptionModeGet
(
    IN  GT_U8                                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT                  profile,
    OUT CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT *modePtr
)
{
    GT_STATUS rc;       /* return code          */
    GT_U32  regAddr;    /* register address     */
    GT_U32  regData;    /* register data        */
    GT_U32  regDataLen; /* register data length */
    GT_U32  offset;     /* register offset */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_SCHEDULER_PROFILE_CHECK_MAC(profile, devNum);
    CPSS_NULL_PTR_CHECK_MAC(modePtr);

    /* DQ Packet Length Mode Profile */
    offset =  0;
    regDataLen = 1;
    regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.profileByteCountModification[profile];

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, regDataLen, &regData);
    if( GT_OK != rc )
    {
        return rc;
    }

    *modePtr = (regData == 0) ? CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_BYTE_E : CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_PACKET_E;

    return GT_OK;
}

/**
* @internal cpssDxChPortTxSchedulerProfileBufferConsumptionModeGet function
* @endinternal
*
* @brief   Gets the packet buffer consumption mode per Scheduler profile.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - scheduler profile
*
* @param[out] modePtr                  - (pointer to) buffer consumption mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
GT_STATUS cpssDxChPortTxSchedulerProfileBufferConsumptionModeGet
(
    IN  GT_U8                                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT                  profile,
    OUT CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT *modePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSchedulerProfileBufferConsumptionModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profile, modePtr));

    rc = internal_cpssDxChPortTxSchedulerProfileBufferConsumptionModeGet(devNum, profile, modePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profile, modePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxShaperAvbModeEnableSet function
* @endinternal
*
* @brief   Set Shaper AVB Mode of specified port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - physical or CPU port number
* @param[in] avbModeEnable            - AVB mode
*                                      GT_TRUE - AVB mode enabled
*                                      GT_FALSE - AVB mode disabled
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, portNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxShaperAvbModeEnableSet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_BOOL                 avbModeEnable
)
{
    GT_STATUS   rc; /* return code */
    GT_U32      txqPortNum; /* TXQ port number */
    PORT_TX_SHAPER_TOKEN_BUCKET_STC subEntry; /* token bucket parameters struct */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);


    /* read entry from HW */
    rc = portTxShaperTokenBucketEntryRead_rev1(devNum, portNum, GT_FALSE, 0, &subEntry);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(subEntry.tokenBucketAvbEnabled == avbModeEnable)
    {
        return GT_OK;
    }

    subEntry.tokenBucketAvbEnabled = avbModeEnable;

    rc = portTxShaperTokenBucketEntryWrite_rev1(devNum, portNum, GT_FALSE, 0, &subEntry);
    return rc;
}

/**
* @internal cpssDxChPortTxShaperAvbModeEnableSet function
* @endinternal
*
* @brief   Set Shaper AVB Mode of specified port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - physical or CPU port number
* @param[in] avbModeEnable            - AVB mode
*                                      GT_TRUE - AVB mode enabled
*                                      GT_FALSE - AVB mode disabled
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, portNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxShaperAvbModeEnableSet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_BOOL                 avbModeEnable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperAvbModeEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, avbModeEnable));

    rc = internal_cpssDxChPortTxShaperAvbModeEnableSet(devNum, portNum, avbModeEnable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, avbModeEnable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxShaperAvbModeEnableGet function
* @endinternal
*
* @brief   Get status of Shaper AVB Mode of specified port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] avbModeEnablePtr     (pointer to) AVB mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, portNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
static GT_STATUS internal_cpssDxChPortTxShaperAvbModeEnableGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_BOOL                 *avbModeEnablePtr
)
{
    GT_STATUS   rc; /* return code */
    GT_U32      txqPortNum; /* TXQ port number */
    PORT_TX_SHAPER_TOKEN_BUCKET_STC subEntry; /* token bucket parameters struct */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    CPSS_NULL_PTR_CHECK_MAC(avbModeEnablePtr);

    /* read entry from HW */
    rc = portTxShaperTokenBucketEntryRead_rev1(devNum, portNum, GT_FALSE, 0, &subEntry);
    if(rc != GT_OK)
    {
        return rc;
    }

    *avbModeEnablePtr = subEntry.tokenBucketAvbEnabled;

    return GT_OK;
}

/**
* @internal cpssDxChPortTxShaperAvbModeEnableGet function
* @endinternal
*
* @brief   Get status of Shaper AVB Mode of specified port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] avbModeEnablePtr     (pointer to) AVB mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, portNum
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
GT_STATUS cpssDxChPortTxShaperAvbModeEnableGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_BOOL                 *avbModeEnablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxShaperAvbModeEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, avbModeEnablePtr));

    rc = internal_cpssDxChPortTxShaperAvbModeEnableGet(devNum, portNum, avbModeEnablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, avbModeEnablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxQShaperAvbModeEnableSet function
* @endinternal
*
* @brief   Set Shaper AVB Mode for Traffic Class Queue of specified port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this Logical Port
* @param[in] avbModeEnable            - AVB mode
*                                      GT_TRUE - AVB mode enabled
*                                      GT_FALSE - AVB mode disabled
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, portNum, tc
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQShaperAvbModeEnableSet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_U8                   tcQueue,
    IN  GT_BOOL                 avbModeEnable
)
{
    GT_STATUS   rc; /* return code */
    GT_U32      txqPortNum; /* TXQ port number */
    PORT_TX_SHAPER_TOKEN_BUCKET_STC subEntry; /* token bucket parameters struct */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);

    /* validate Traffic Classes queue */
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tcQueue);

    /* read entry from HW */
    rc = portTxShaperTokenBucketEntryRead_rev1(devNum, portNum, GT_TRUE, tcQueue, &subEntry);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(subEntry.tokenBucketAvbEnabled == avbModeEnable)
    {
        return GT_OK;
    }

    subEntry.tokenBucketAvbEnabled = avbModeEnable;

    rc = portTxShaperTokenBucketEntryWrite_rev1(devNum, portNum, GT_TRUE, tcQueue, &subEntry);
    return rc;
}

/**
* @internal cpssDxChPortTxQShaperAvbModeEnableSet function
* @endinternal
*
* @brief   Set Shaper AVB Mode for Traffic Class Queue of specified port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this Logical Port
* @param[in] avbModeEnable            - AVB mode
*                                      GT_TRUE - AVB mode enabled
*                                      GT_FALSE - AVB mode disabled
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, portNum, tc
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQShaperAvbModeEnableSet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_U8                   tcQueue,
    IN  GT_BOOL                 avbModeEnable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQShaperAvbModeEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, avbModeEnable));

    rc = internal_cpssDxChPortTxQShaperAvbModeEnableSet(devNum, portNum, tcQueue, avbModeEnable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, avbModeEnable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQShaperAvbModeEnableGet function
* @endinternal
*
* @brief   Get status of Shaper AVB Mode for Traffic Class Queue of specified port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this Logical Port
*
* @param[out] avbModeEnablePtr     (pointer to) AVB mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, portNum, tc
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
static GT_STATUS internal_cpssDxChPortTxQShaperAvbModeEnableGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_U8                   tcQueue,
    OUT GT_BOOL                 *avbModeEnablePtr
)
{
    GT_STATUS   rc; /* return code */
    GT_U32      txqPortNum; /* TXQ port number */
    PORT_TX_SHAPER_TOKEN_BUCKET_STC subEntry; /* token bucket parameters struct */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    CPSS_NULL_PTR_CHECK_MAC(avbModeEnablePtr);

    /* validate Traffic Classes queue */
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tcQueue);

    /* read entry from HW */
    rc = portTxShaperTokenBucketEntryRead_rev1(devNum, portNum, GT_TRUE, tcQueue, &subEntry);
    if(rc != GT_OK)
    {
        return rc;
    }

    *avbModeEnablePtr = subEntry.tokenBucketAvbEnabled;

    return GT_OK;
}

/**
* @internal cpssDxChPortTxQShaperAvbModeEnableGet function
* @endinternal
*
* @brief   Get status of Shaper AVB Mode for Traffic Class Queue of specified port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this Logical Port
*
* @param[out] avbModeEnablePtr     (pointer to) AVB mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, portNum, tc
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
GT_STATUS cpssDxChPortTxQShaperAvbModeEnableGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_U8                   tcQueue,
    OUT GT_BOOL                 *avbModeEnablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQShaperAvbModeEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, avbModeEnablePtr));

    rc = internal_cpssDxChPortTxQShaperAvbModeEnableGet(devNum, portNum, tcQueue, avbModeEnablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, avbModeEnablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxSchedulerProfileCountModeSet function
* @endinternal
*
* @brief   Sets the counting mode for scheduler profile.
*
* @note   APPLICABLE DEVICES:          Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 .
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - scheduler profile
* @param[in] wrrMode                  - scheduler count mode.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile or wrong wrrMode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxSchedulerProfileCountModeSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profile,
    IN  CPSS_PORT_TX_WRR_MODE_ENT               wrrMode
)
{
    GT_STATUS rc;       /* return code          */
    GT_U32  regAddr;    /* register address     */
    GT_U32  regData;    /* register data        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_SCHEDULER_PROFILE_CHECK_MAC(profile, devNum);

    switch (wrrMode)
    {
    case CPSS_PORT_TX_WRR_BYTE_MODE_E:
        regData = 1;
        break;
    case CPSS_PORT_TX_WRR_PACKET_MODE_E:
        regData = 0;
        break;
    default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* Profile <%p> Byte Count Modification register */
    regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.profileByteCountModification[profile];

    /* Set <TxSchedCountModeProfile> */
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, regData);
    return rc;
}

/**
* @internal cpssDxChPortTxSchedulerProfileCountModeSet function
* @endinternal
*
* @brief   Sets the counting mode for scheduler profile.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 .
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - scheduler profile
* @param[in] wrrMode                  - scheduler count mode.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile or wrong wrrMode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxSchedulerProfileCountModeSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profile,
    IN  CPSS_PORT_TX_WRR_MODE_ENT               wrrMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSchedulerProfileCountModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profile, wrrMode));

    rc = internal_cpssDxChPortTxSchedulerProfileCountModeSet(devNum, profile, wrrMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profile, wrrMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxSchedulerProfileCountModeGet function
* @endinternal
*
* @brief   Sets the counting mode for scheduler profile.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; .
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - scheduler profile
*
* @param[out] wrrModePtr               - (pointer to) scheduler count mode.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile or wrong wrrMode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
static GT_STATUS internal_cpssDxChPortTxSchedulerProfileCountModeGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profile,
    OUT CPSS_PORT_TX_WRR_MODE_ENT               *wrrModePtr
)
{
    GT_STATUS rc;       /* return code          */
    GT_U32  regAddr;    /* register address     */
    GT_U32  regData;    /* register data        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_DXCH_SCHEDULER_PROFILE_CHECK_MAC(profile, devNum);
    CPSS_NULL_PTR_CHECK_MAC(wrrModePtr);

    /* Profile <%p> Byte Count Modification register */
    regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.profileByteCountModification[profile];

    /* Set <TxSchedCountModeProfile> */
    rc = prvCpssHwPpGetRegField(devNum, regAddr, 1, 1, &regData);
    if(GT_OK != rc)
    {
        return rc;
    }

    *wrrModePtr = (regData == 0) ? CPSS_PORT_TX_WRR_PACKET_MODE_E : CPSS_PORT_TX_WRR_BYTE_MODE_E;

    return GT_OK;
}

/**
* @internal cpssDxChPortTxSchedulerProfileCountModeGet function
* @endinternal
*
* @brief   Sets the counting mode for scheduler profile.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; .
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] profile                  - scheduler profile
*
* @param[out] wrrModePtr               - (pointer to) scheduler count mode.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, profile or wrong wrrMode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
GT_STATUS cpssDxChPortTxSchedulerProfileCountModeGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profile,
    OUT CPSS_PORT_TX_WRR_MODE_ENT               *wrrModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxSchedulerProfileCountModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, profile, wrrModePtr));

    rc = internal_cpssDxChPortTxSchedulerProfileCountModeGet(devNum, profile, wrrModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, profile, wrrModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropMaskSharedBuffEnableSet function
* @endinternal
*
* @brief   Enable/Disable shared buffer indication masking.
*         When enabled, the tail drop mechanism will ignore
*         the buffer fill level indication.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE - Enable buffer fill level masking.
*                                      GT_FALSE -Disable buffer fill level masking.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropMaskSharedBuffEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_U32 regAddr;     /* register address */
    GT_U32 fieldOffset; /* the start bit number in the register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E | CPSS_LION2_E);

    regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.globalTailDropConfig;
    fieldOffset = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 12 : 11;

    return prvCpssHwPpSetRegField(devNum, regAddr, fieldOffset, 1, BOOL2BIT_MAC(enable));

}

/**
* @internal cpssDxChPortTxTailDropMaskSharedBuffEnableSet function
* @endinternal
*
* @brief   Enable/Disable shared buffer indication masking.
*         When enabled, the tail drop mechanism will ignore
*         the buffer fill level indication.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE - Enable buffer fill level masking.
*                                      GT_FALSE -Disable buffer fill level masking.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropMaskSharedBuffEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropMaskSharedBuffEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPortTxTailDropMaskSharedBuffEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropMaskSharedBuffEnableGet function
* @endinternal
*
* @brief   Gets status of shared buffer indication masking.
*         When enabled, the tail drop mechanism will ignore
*         the buffer fill level indication.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - (pointer to) shared buffer indication masking.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
static GT_STATUS internal_cpssDxChPortTxTailDropMaskSharedBuffEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;       /* return code */
    GT_U32 regAddr;     /* register address */
    GT_U32 regValue;    /* register value */
    GT_U32 fieldOffset; /* the start bit number in the register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E | CPSS_LION2_E);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.globalTailDropConfig;
    fieldOffset = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 12 : 11;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, fieldOffset, 1, &regValue);
    if(rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(regValue);

    return GT_OK;
}

/**
* @internal cpssDxChPortTxTailDropMaskSharedBuffEnableGet function
* @endinternal
*
* @brief   Gets status of shared buffer indication masking.
*         When enabled, the tail drop mechanism will ignore
*         the buffer fill level indication.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Falcon; AC5P; AC5X; Harrier; Ironman Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - (pointer to) shared buffer indication masking.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
GT_STATUS cpssDxChPortTxTailDropMaskSharedBuffEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropMaskSharedBuffEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPortTxTailDropMaskSharedBuffEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropSharedBuffMaxLimitSet function
* @endinternal
*
* @brief   Set max shared buffer limit value.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] maxSharedBufferLimit     - maximal shared buffer limit
*                                  (APPLICABLE RANGES: 0..0xFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_OUT_OF_RANGE          - on illegal maxSharedBufferLimit
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropSharedBuffMaxLimitSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  maxSharedBufferLimit
)
{
    GT_U32 regAddr;     /* register address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if(maxSharedBufferLimit >= BIT_16)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_DXCH_REG1_UNIT_BM_MAC(devNum).BMGlobalConfigs.BMBufferLimitConfig1;

    return prvCpssHwPpSetRegField(devNum, regAddr, 16, 16, maxSharedBufferLimit);
}

/**
* @internal cpssDxChPortTxTailDropSharedBuffMaxLimitSet function
* @endinternal
*
* @brief   Set max shared buffer limit value.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.

*
* @param[in] devNum                   - physical device number
* @param[in] maxSharedBufferLimit     - maximal shared buffer limit
*                                  (APPLICABLE RANGES: 0..0xFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_OUT_OF_RANGE          - on illegal maxSharedBufferLimit
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropSharedBuffMaxLimitSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  maxSharedBufferLimit
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropSharedBuffMaxLimitSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, maxSharedBufferLimit));

    rc = internal_cpssDxChPortTxTailDropSharedBuffMaxLimitSet(devNum, maxSharedBufferLimit);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, maxSharedBufferLimit));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropSharedBuffMaxLimitGet function
* @endinternal
*
* @brief   Get max shared buffer limit value.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] maxSharedBufferLimitPtr  - (pointer to) maximal shared buffer limit
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
static GT_STATUS internal_cpssDxChPortTxTailDropSharedBuffMaxLimitGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *maxSharedBufferLimitPtr
)
{
    GT_U32 regAddr;     /* register address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(maxSharedBufferLimitPtr);

    regAddr = PRV_DXCH_REG1_UNIT_BM_MAC(devNum).BMGlobalConfigs.BMBufferLimitConfig1;

    return prvCpssHwPpGetRegField(devNum, regAddr, 16, 16, maxSharedBufferLimitPtr);
}

/**
* @internal cpssDxChPortTxTailDropSharedBuffMaxLimitGet function
* @endinternal
*
* @brief   Get max shared buffer limit value.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
*
* @param[out] maxSharedBufferLimitPtr  - (pointer to) maximal shared buffer limit
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
*/
GT_STATUS cpssDxChPortTxTailDropSharedBuffMaxLimitGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *maxSharedBufferLimitPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropSharedBuffMaxLimitGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, maxSharedBufferLimitPtr));

    rc = internal_cpssDxChPortTxTailDropSharedBuffMaxLimitGet(devNum, maxSharedBufferLimitPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, maxSharedBufferLimitPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTx4TcMcBufNumberGet function
* @endinternal
*
* @brief   Gets the current number of MC buffers allocated on specified port
*         for specified Traffic Class queues.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] trafClass                - trafiic class
*
* @param[out] numPtr                   - (pointer to) the number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTx4TcMcBufNumberGet
(
    IN  GT_U8       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8       trafClass,
    OUT GT_U32      *numPtr
)
{
    GT_STATUS   rc;         /* return code */
    GT_U32      tableIndex; /* table index                 */
    CPSS_DXCH_TABLE_ENT tableType; /* table type */
    GT_U32      txqPortNum; /* TXQ port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, txqPortNum);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(trafClass);
    CPSS_NULL_PTR_CHECK_MAC(numPtr);

    tableType = CPSS_DXCH_SIP5_TABLE_TAIL_DROP_COUNTERS_Q_MAIN_MC_BUFF_E;

    tableIndex = trafClass | (txqPortNum << 3);

    rc = prvCpssDxChReadTableEntry(devNum, tableType, tableIndex, numPtr);
    return rc;
}

/**
* @internal cpssDxChPortTx4TcMcBufNumberGet function
* @endinternal
*
* @brief   Gets the current number of MC buffers allocated on specified port
*         for specified Traffic Class queues.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] trafClass                - trafiic class
*
* @param[out] numPtr                   - (pointer to) the number of buffers
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTx4TcMcBufNumberGet
(
    IN  GT_U8       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8       trafClass,
    OUT GT_U32      *numPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTx4TcMcBufNumberGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, trafClass, numPtr));

    rc = internal_cpssDxChPortTx4TcMcBufNumberGet(devNum, portNum, trafClass, numPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, trafClass, numPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChPortTxQStatusGet function
* @endinternal
*
* @brief   dumps the related TxQ parameters in the system.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - SW device number
*
* @retval GT_OK                    - on success, match found for devNum.
* @retval GT_FAIL                  - no match found for devNum.
*/
GT_STATUS prvCpssDxChPortTxQStatusGet
(
    IN  GT_U8 devNum
)
{
    GT_STATUS   rc;
    GT_U8       tcQueue;
    GT_PHYSICAL_PORT_NUM    portNum;
    GT_PHYSICAL_PORT_NUM    portMaxIter;/* maximal port number */
    GT_BOOL     txQueueingEnable,txQueueEnable;
    GT_BOOL     txQueueGlobalEnable;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    cpssOsPrintf("+------------------------------------------------------------------------------+\n");
    cpssOsPrintf("|        T x Q    E n q u e u e    a n d    T r a s m i t    S T A T U S       |\n");
    cpssOsPrintf("+------------------------------------------------------------------------------+\n");

    rc = cpssDxChPortTxQueueEnableGet(devNum,&txQueueGlobalEnable);
    if (rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("cpssDxChPortTxQueueEnableGet failed rc = %x\n",rc);
    }
    else
    {
        if(txQueueGlobalEnable == GT_TRUE)
        {
            cpssOsPrintf("\n\n Global Tx Queueing is ENABLED\n\n");
        }
        else
        {
            cpssOsPrintf("\n\n Global Tx Queueing is DISABLED\n\n");
        }
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        cpssOsPrintf("+--------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+"
        "------------+------------+------------+------------+------------+------------+\n");
        cpssOsPrintf("|  Port  |    TC0     |    TC1     |    TC2     |    TC3     |    TC4     |    TC5     |    TC6     |    TC7     |     TC 8   |    TC 9    |"
        "   TC 10    |   TC 11    |  TC 12     |   TC 13    |  TC 14     |   TC 15    |\n");
        cpssOsPrintf("|        | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn |"
        " EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn |\n");
        cpssOsPrintf("+--------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+"
        "------------+------------+------------+------------+------------+------------+\n");
    }
    else
    {
        cpssOsPrintf("+--------+------------+------------+------------+------------+------------+------------+------------+------------+\n");
        cpssOsPrintf("|  Port  |    TC0     |    TC1     |    TC2     |    TC3     |    TC4     |    TC5     |    TC6     |    TC7     |\n");
        cpssOsPrintf("|        | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn | EnqEn:TxEn |\n");
        cpssOsPrintf("+--------+------------+------------+------------+------------+------------+------------+------------+------------+\n");
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        portMaxIter = PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum);
    }
    else
    {
        portMaxIter = PRV_CPSS_PP_MAC(devNum)->numOfPorts;
    }
    for(portNum = 0; portNum < portMaxIter; portNum++)
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            if((PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].valid == GT_FALSE) ||
            (PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].portMap.txqNum == CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS))
            {
                continue;
            }
        }
        else
        {
            /* skip non existing ports (not including cpu port) */
            if ((! PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, portNum)) && (portNum != CPSS_CPU_PORT_NUM_CNS))
                continue;
        }

        cpssOsPrintf("| %3d  |",portNum);
        for(tcQueue = 0; tcQueue < (PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? PRV_CPSS_DXCH_SIP_6_MAX_TC : PRV_CPSS_DXCH_MAX_TC); tcQueue++)
        {
            rc = cpssDxChPortTxQueueingEnableGet(devNum,portNum,tcQueue,&txQueueingEnable);
            if(rc != GT_OK)
            {
                /*CPSS_LOG_INFORMATION_MAC("cpssDxChPortTxQueueingEnableGet fails rc = %x\n",rc);*/
                cpssOsPrintf("    N/A     |");
                continue;
            }
            rc = cpssDxChPortTxQueueTxEnableGet(devNum,portNum,tcQueue,&txQueueEnable);
            if(rc != GT_OK)
            {
                /*CPSS_LOG_INFORMATION_MAC("cpssDxChPortTxQueueTxEnableGet fails rc = %x\n",rc);*/
                cpssOsPrintf("    N/A     |");
                continue;
            }
            cpssOsPrintf("  %3d : %-2d  |",txQueueingEnable,txQueueEnable);
        }
        cpssOsPrintf("\n");
    }
    cpssOsPrintf("+--------+------------+------------+------------+------------+------------+------------+------------+------------+\n");

    return GT_OK;
}

/**
* @internal prvCpssDxChPortTxTailDropResourceAllocationGet function
* @endinternal
*
* @brief   Dumps tail drop configuration showing the current resources allocated per port/TC.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - SW device number
*
* @retval GT_OK                    - on success.
*/
GT_STATUS prvCpssDxChPortTxTailDropResourceAllocationGet
(
    IN  GT_U8 devNum
)
{
    GT_STATUS   rc;
    GT_U32      globalDescLimit      =0xFFFF, globalDescAllocated   =0xFFFF;
    GT_U32      globalBufLimit       =0xFFFF, globalBufAllocated    =0xFFFF;
    GT_U32      globalMCDescrLimit   =0xFFFF, globalMCDescrAllocated=0xFFFF;
    GT_U32      globalMCBufLimit     =0xFFFF, globalMCBufAllocated  =0xFFFF;
    GT_U32      rxSniffDescLimit     =0xFFFF, rxSniffDescAllocated  =0xFFFF;
    GT_U32      txSniffDescLimit     =0xFFFF, txSniffDescAllocated  =0xFFFF;
    GT_U32      rxSniffBufLimit      =0xFFFF, rxSniffBufAllocated   =0xFFFF;
    GT_U32      txSniffBufLimit      =0xFFFF, txSniffBufAllocated   =0xFFFF;
    GT_U32      portBufAllocated     =0xFFFF;
    GT_U16      portDescrAllocated   =0xFFFF;
    GT_U32      perPortPerTcBufAllocated    =0xFFFFFFFF;
    GT_U16      perPortPerTcDescAllocated   =0xFFFF;

    GT_U8       tcQueue;
    GT_PHYSICAL_PORT_NUM    portNum;
    GT_PHYSICAL_PORT_NUM    portMaxIter;/* maximal port number */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    cpssOsPrintf("\n\n");
    cpssOsPrintf("+---------------------------------------------------------------------------------------+\n");
    cpssOsPrintf("|                                                                                       |\n");
    cpssOsPrintf("|       T  A  I  L     D  R  O  P     R E S O U R C E     A L L O C A T I O N           |\n");
    cpssOsPrintf("|                                                                                       |\n");
    cpssOsPrintf("+---------------------------------------------------------------------------------------+\n");

    cpssOsPrintf("\n** The value 65535 indicates Not Applicable Device\n\n");

    /*============================= Limits ================================*/

    /*============================= Global ================================*/
    rc = cpssDxChPortTxGlobalDescLimitGet(devNum,&globalDescLimit);
    if(rc == GT_NOT_APPLICABLE_DEVICE) ;
    else if (rc == GT_OK) ;
    else
        cpssOsPrintf("cpssDxChPortTxGlobalDescLimitGet failed rc = %x\n",rc);

    rc = cpssDxChPortTxGlobalBufNumberGet(devNum,&globalBufLimit);
    if(rc == GT_NOT_APPLICABLE_DEVICE) ;
    else if (rc == GT_OK) ;
    else
        cpssOsPrintf("cpssDxChPortTxGlobalBufNumberGet failed rc = %x\n",rc);

    /*============================== MC =================================*/
    rc = cpssDxChPortTxMcastPcktDescrLimitGet(devNum,&globalMCDescrLimit);
    if(rc == GT_NOT_APPLICABLE_DEVICE) ;
    else if (rc == GT_OK) ;
    else
        cpssOsPrintf("cpssDxChPortTxMcastPcktDescrLimitGet fails rc = %x\n",rc);

    rc = cpssDxChPortTxMcastBuffersLimitGet(devNum,&globalMCBufLimit);
    if(rc == GT_NOT_APPLICABLE_DEVICE) ;
    else if (rc == GT_OK) ;
    else
        cpssOsPrintf("cpssDxChPortTxMcastBuffersLimitGet fails rc = %x\n",rc);


    /*============================= Sniffer ================================*/

    rc = cpssDxChPortTxSniffedPcktDescrLimitGet(devNum,&rxSniffDescLimit,&txSniffDescLimit);
    if(rc == GT_NOT_APPLICABLE_DEVICE) ;
    else if (rc == GT_OK);
    else
        cpssOsPrintf("cpssDxChPortTxSniffedPcktDescrLimitGet fails rc = %x\n",rc);

    rc = cpssDxChPortTxSniffedBuffersLimitGet  (devNum,&rxSniffBufLimit, &txSniffBufLimit);
    if(rc == GT_NOT_APPLICABLE_DEVICE) ;
    else if (rc == GT_OK);
    else
        cpssOsPrintf("cpssDxChPortTxSniffedBuffersLimitGet fails rc = %x\n",rc);



    /*============================= Allocated ================================*/

    /*============================== Global ================================*/
    rc = cpssDxChPortTxGlobalDescNumberGet(devNum,&globalDescAllocated);
    if(rc == GT_NOT_APPLICABLE_DEVICE) ;
    else if (rc == GT_OK) ;
    else
    {
        cpssOsPrintf("cpssDxChPortTxGlobalDescNumberGet fails rc = %x\n",rc);
    }

    rc = cpssDxChPortTxGlobalBufNumberGet(devNum,&globalBufAllocated);
    if(rc == GT_NOT_APPLICABLE_DEVICE) ;
    else if (rc == GT_OK) ;
    else
    {
        cpssOsPrintf("cpssDxChPortTxGlobalBufNumberGet fails rc = %x\n",rc);
    }

    /*==============================MC=======================*/
    rc = cpssDxChPortTxMcastDescNumberGet(devNum,&globalMCDescrAllocated);
    if(rc == GT_NOT_APPLICABLE_DEVICE) ;
    else if (rc == GT_OK) ;
    else
    {
        cpssOsPrintf("cpssDxChPortTxMcastDescNumberGet fails rc = %x\n",rc);
    }

    rc = cpssDxChPortTxMcastBufNumberGet(devNum,&globalMCBufAllocated);
    if(rc == GT_NOT_APPLICABLE_DEVICE);
    else if (rc == GT_OK) ;
    else
    {
        cpssOsPrintf("cpssDxChPortTxMcastBufNumberGet fails rc = %x\n",rc);
    }

    /*========================= Sniffer =================================*/
    rc = cpssDxChPortTxSniffedDescNumberGet(devNum,&rxSniffDescAllocated,&txSniffDescAllocated);
    if(rc == GT_NOT_APPLICABLE_DEVICE) ;
    else if (rc == GT_OK) ;
    else
    {
        cpssOsPrintf("cpssDxChPortTxSniffedDescNumberGet fails rc = %x\n",rc);
    }

    rc = cpssDxChPortTxSniffedBufNumberGet(devNum,&rxSniffBufAllocated,&txSniffBufAllocated);
    if(rc == GT_NOT_APPLICABLE_DEVICE) ;
    else if (rc == GT_OK) ;
    else
    {
        cpssOsPrintf("cpssDxChPortTxSniffedBufNumberGet fails rc = %x\n",rc);
    }

    cpssOsPrintf("Global Resource allocated                  Buffer [%4d/%-5d]\n",globalBufAllocated     ,globalBufLimit );
    cpssOsPrintf("Global Resource allocated                  Desc   [%4d/%-5d]\n",globalDescAllocated    ,globalDescLimit);
    cpssOsPrintf("Global Resource allocated for MC           Buffer [%4d/%-5d]\n",globalMCBufAllocated   ,globalMCBufLimit   );
    cpssOsPrintf("Global Resource allocated for MC           Desc   [%4d/%-5d]\n",globalMCDescrAllocated ,globalMCDescrLimit );
    cpssOsPrintf("Global Resource allocated for Rx Mirroring Buffer [%4d/%-5d]\n",rxSniffBufAllocated    ,rxSniffBufLimit);
    cpssOsPrintf("Global Resource allocated for Rx Mirroring Desc   [%4d/%-5d]\n",rxSniffDescAllocated   ,rxSniffDescLimit   );
    cpssOsPrintf("Global Resource allocated for Tx Mirroring Buffer [%4d/%-5d]\n",txSniffBufAllocated    ,txSniffBufLimit);
    cpssOsPrintf("Global Resource allocated for Tx Mirroring Desc   [%4d/%-5d]\n",txSniffDescAllocated   ,txSniffDescLimit   );

    /* ======================================== get the number of TD per each Port ===========*/
    cpssOsPrintf("\n\n\n");
    cpssOsPrintf("==========================================================================\n");
    cpssOsPrintf("            Per port/per TC Desc allocated \n");
    cpssOsPrintf("==========================================================================\n");
    if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        portMaxIter = PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum);
    }
    else
    {
        portMaxIter = PRV_CPSS_PP_MAC(devNum)->numOfPorts;
    }
    for(portNum = 0; portNum < portMaxIter; portNum++)
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            if((PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].valid == GT_FALSE) ||
            (PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].portMap.txqNum == CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS))
            {
                continue;
            }
        }
        else
        {
            /* skip non existing ports (not including cpu port) */
            if ((! PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, portNum)) && (portNum != CPSS_CPU_PORT_NUM_CNS))
                continue;
        }

        rc = cpssDxChPortTxDescNumberGet(devNum,portNum,&portDescrAllocated);
        if (rc != GT_OK && rc != GT_NOT_APPLICABLE_DEVICE)
        {
            /*cpssOsPrintf("cpssDxChPortTxDescNumberGet fails for port %d rc = %d\n",portNum,rc);*/
            continue;
        }

        rc = cpssDxChPortTxBufNumberGet(devNum,portNum,&portBufAllocated);
        if (rc != GT_OK && rc != GT_NOT_APPLICABLE_DEVICE)
        {
            /*cpssOsPrintf("cpssDxChPortTxBufNumberGet fails rc = %x\n",rc);*/
            continue;
        }

        if(portNum == 0)
            cpssOsPrintf("\n\nNumber of Buffers and Descriptors used by the port: [port: Buff/Desc]\n");
        if ((portNum % 8) == 0)
            cpssOsPrintf("\n");

        cpssOsPrintf("[%3d:%4d/%-4d] ",portNum,portBufAllocated,portDescrAllocated);
    }

    /* cpu port */
    if (portNum <= CPSS_CPU_PORT_NUM_CNS)
    {
        rc = cpssDxChPortTxDescNumberGet(devNum,63,&portDescrAllocated);
        if (rc == GT_OK)
        {
            rc = cpssDxChPortTxBufNumberGet(devNum,63,&portBufAllocated);
            if (rc == GT_OK)
            {
                cpssOsPrintf("\n");
                cpssOsPrintf("[%3d:%4d/%-4d] ",63,portBufAllocated,portDescrAllocated);
            }
        }
    }


    cpssOsPrintf("\n");
    cpssOsPrintf("\n\n          Resource allocation per port/Tc\n");
    cpssOsPrintf("======================================================\n\n\n");

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        cpssOsPrintf("+--------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+"
        "------------+------------+------------+------------+------------+------------+------------+\n");
        cpssOsPrintf("|  Port  |   Total    |    TC0     |    TC1     |    TC2     |    TC3     |    TC4     |    TC5     |    TC6     |    TC7     |     TC8    "
        "   TC9      |    TC10    |  TC11      |   TC12     |   TC13     |   TC14     |    TC15    |\n");
        cpssOsPrintf("|        | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc]|"
        " [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] |\n");
        cpssOsPrintf("+--------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+"
        "------------+------------+------------+------------+------------+------------+------------+\n");
    }
    else
    {
        cpssOsPrintf("+--------+------------+------------+------------+------------+------------+------------+------------+------------+------------+\n");
        cpssOsPrintf("|  Port  |   Total    |    TC0     |    TC1     |    TC2     |    TC3     |    TC4     |    TC5     |    TC6     |    TC7     |\n");
        cpssOsPrintf("|        | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] | [Buf/Desc] |\n");
        cpssOsPrintf("+--------+------------+------------+------------+------------+------------+------------+------------+------------+------------+\n");
    }

    for(portNum = 0; portNum < portMaxIter; portNum++)
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            if((PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].valid == GT_FALSE) ||
            (PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].portMap.txqNum == CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS))
            {
                continue;
            }
        }
        else
        {
            /* skip non existing ports (not including cpu port) */
            if ((! PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, portNum)) && (portNum != CPSS_CPU_PORT_NUM_CNS))
                continue;
        }

        rc = cpssDxChPortTxDescNumberGet(devNum,portNum,&portDescrAllocated);
        if (rc != GT_OK && rc != GT_NOT_APPLICABLE_DEVICE)
        {
            /*cpssOsPrintf("cpssDxChPortTxDescNumberGet fails for port %d rc = %d\n",portNum,rc);*/
            continue;
        }

        rc = cpssDxChPortTxBufNumberGet(devNum,portNum,&portBufAllocated);
        if (rc != GT_OK && rc != GT_NOT_APPLICABLE_DEVICE)
        {
            /*cpssOsPrintf("cpssDxChPortTxBufNumberGet fails rc = %x\n",rc);*/
            continue;
        }


        /* Per port resource allocated */
        cpssOsPrintf("| %3d  |",portNum);
        cpssOsPrintf("  %4d/%-3d  |",portBufAllocated,portDescrAllocated);

        for(tcQueue = 0; tcQueue < (PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? PRV_CPSS_DXCH_SIP_6_MAX_TC : PRV_CPSS_DXCH_MAX_TC); tcQueue++)
        {
            /* Per TC resource allocated */
            rc = cpssDxChPortTx4TcBufNumberGet(devNum, portNum,tcQueue,&perPortPerTcBufAllocated);
            if(rc == GT_NOT_APPLICABLE_DEVICE)
            {
                break;
            }
            else if (rc != GT_OK)
            {
                /*cpssOsPrintf("cpssDxChPortTx4TcBufNumberGet fails rc = %x\n",rc);*/
                cpssOsPrintf("     N/A    |");
                continue;
            }

            rc = cpssDxChPortTx4TcDescNumberGet(devNum, portNum,tcQueue,&perPortPerTcDescAllocated);
            if(rc == GT_NOT_APPLICABLE_DEVICE)
            {
                break;
            }
            else if (rc != GT_OK)
            {
                /*cpssOsPrintf("cpssDxChPortTx4TcDescNumberGet fails rc = %x\n",rc);*/
                cpssOsPrintf("    N/A     |");
                continue;
            }

            cpssOsPrintf("  %4d/%-3d  |", perPortPerTcBufAllocated, perPortPerTcDescAllocated);
        }
        cpssOsPrintf("\n");
    }

    /* cpu port */
    for (; portNum <= CPSS_CPU_PORT_NUM_CNS;)
    {
        rc = cpssDxChPortTxDescNumberGet(devNum,63,&portDescrAllocated);
        if (rc != GT_OK && rc != GT_NOT_APPLICABLE_DEVICE)
        {
            continue;
        }

        rc = cpssDxChPortTxBufNumberGet(devNum,63,&portBufAllocated);
        if (rc != GT_OK && rc != GT_NOT_APPLICABLE_DEVICE)
        {
            continue;
        }

        /* Per port resource allocated */
        cpssOsPrintf("| %3d  |",63);
        cpssOsPrintf("  %4d/%-3d  |",portBufAllocated,portDescrAllocated);

        for(tcQueue = 0; tcQueue < (PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? PRV_CPSS_DXCH_SIP_6_MAX_TC : PRV_CPSS_DXCH_MAX_TC); tcQueue++)
        {
            /* Per TC resource allocated */
            rc = cpssDxChPortTx4TcBufNumberGet(devNum, 63,tcQueue,&perPortPerTcBufAllocated);
            if(rc == GT_NOT_APPLICABLE_DEVICE)
            {
                break;
            }
            else if (rc != GT_OK)
            {
                cpssOsPrintf("     N/A    |");
                continue;
            }

            rc = cpssDxChPortTx4TcDescNumberGet(devNum, 63,tcQueue,&perPortPerTcDescAllocated);
            if(rc == GT_NOT_APPLICABLE_DEVICE)
            {
                break;
            }
            else if (rc != GT_OK)
            {
                cpssOsPrintf("    N/A     |");
                continue;
            }

            cpssOsPrintf("  %4d/%-3d  |", perPortPerTcBufAllocated, perPortPerTcDescAllocated);
        }
        cpssOsPrintf("\n");

        break;
    }

    cpssOsPrintf("+--------+------------+------------+------------+------------+------------+------------+------------+------------+------------+\n\n\n");

    return GT_OK;
}

/**
* @internal prvCpssDxChPortTxTailDropSharePoolEnPerProfileGet function
* @endinternal
*
* @brief   Dumps tail drop configuration related to share pools.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - SW device number
*
* @retval GT_OK                    - on success, match found for devNum.
*/
GT_STATUS prvCpssDxChPortTxTailDropSharePoolEnPerProfileGet
(
    IN  GT_U8 devNum
)
{
    GT_STATUS                            rc;
    GT_U8                                tcQueue;
    CPSS_PORT_TX_DROP_PROFILE_SET_ENT    tailDropProfile;
    GT_BOOL                              dp1SharedEnable;
    CPSS_DXCH_PORT_TX_SHARED_POLICY_ENT  sharedPolicy;
    GT_U32                               poolNum;
    GT_U32                               sharedBuffPerPool[16];
    GT_U32                               sharedDescPerPool[16];
    GT_U32                               sharedPoolBufLimit[16],sharedPoolDescLimit[16];
    CPSS_PORT_TX_SHARED_DP_MODE_ENT      TCEnabledForSharedPool;
    GT_BOOL                              SharingGlobalResourceEnable;
    GT_U32                               sharedBufLimit,sharedDescLimit;
    GT_U32                               tcToPoolNum;

    GT_U32                               buffersSharingMaxLimit;
    GT_BOOL                              maskSharedBufEnable;
    GT_U32                               maxSharedBufferLimit;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    cpssOsPrintf("+-------------------------------------------------------------------------------------+\n");
    cpssOsPrintf("|                                                                                     |\n");
    cpssOsPrintf("|               T A I L    D R O P    S H A R E D    P O O L S                        |\n");
    cpssOsPrintf("|                                                                                     |\n");
    cpssOsPrintf("+-------------------------------------------------------------------------------------+\n\n");


    rc = cpssDxChPortTxSharedPolicyGet(devNum,&sharedPolicy);
    if (rc == GT_OK)
    {
        if(sharedPolicy == CPSS_DXCH_PORT_TX_SHARED_POLICY_UNCONSTRAINED_E)
            cpssOsPrintf(" Share Policy [constrained/unconstrained]      : UNCONSTRAINED\n");
        else if(sharedPolicy == CPSS_DXCH_PORT_TX_SHARED_POLICY_CONSTRAINED_E)
            cpssOsPrintf(" Share Policy [constrained/unconstrained]      : CONSTRAINED\n");
        else
            cpssOsPrintf(" Share Policy [constrained/unconstrained]      : [%d]\n",sharedPolicy);
    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortTxSharedPolicyGet fails rc = %x\n",rc);
    }

    rc = cpssDxChPortTxSharingGlobalResourceEnableGet(devNum,&SharingGlobalResourceEnable);
    if (rc == GT_OK)
    {
        cpssOsPrintf(" Share Global Resource [Enable/Disable]    : %d\n",SharingGlobalResourceEnable);
    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortTxSharingGlobalResourceEnableGet fails rc = %x\n",rc);
    }

    rc =  cpssDxChPortTxBuffersSharingMaxLimitGet( devNum, &buffersSharingMaxLimit);
    if (rc == GT_OK)
    {
        cpssOsPrintf(" Max Number Of Buffer for Sharing       : %4d\n",buffersSharingMaxLimit);

    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortTxBuffersSharingMaxLimitGet fails rc = %x\n",rc);
    }

    rc = cpssDxChPortTxSharedGlobalResourceLimitsGet(devNum,&sharedBufLimit,&sharedDescLimit);
    if (rc == GT_OK)
    {
        cpssOsPrintf(" Global Shared Resource Limits [buf/descr] : [%-4d/%4d]\n",sharedBufLimit,sharedDescLimit);
    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortTxSharedGlobalResourceLimitsGet fails rc = %x\n",rc);
    }

    rc =  cpssDxChPortTxDp1SharedEnableGet(devNum, &dp1SharedEnable);
    if (rc == GT_OK)
    {
        cpssOsPrintf(" DP1 [Enable / Disable] for Shared Pool    : [%d]\n",dp1SharedEnable);
    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortTxDp1SharedEnableGet fails rc = %x\n",rc);
    }

    rc = cpssDxChPortTxTailDropSharedBuffMaxLimitGet(devNum,&maxSharedBufferLimit);
    if (rc == GT_OK)
    {
        cpssOsPrintf(" Shared Buffer Max Limit                   : %4x\n",maxSharedBufferLimit);
    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortTxSharedResourceDescNumberGet fails rc = %x\n",rc);
    }

    rc = cpssDxChPortTxTailDropMaskSharedBuffEnableGet(devNum, &maskSharedBufEnable);
    if (rc == GT_OK)
    {
        cpssOsPrintf(" Mask Shared Buffers Enable/Disable        : [%1d]\n",maskSharedBufEnable);
    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortTxTailDropMaskSharedBuffEnableGet fails rc = %x\n\n",rc);
    }

    cpssOsPrintf("\n\n");

    cpssOsPrintf("+--------+----------------+----------------+\n");
    cpssOsPrintf("| Shared |    buffers     |  Descriptors   |\n");
    cpssOsPrintf("|  pool  | [in Use/Limit] | [In Use/Limit] |\n");
    cpssOsPrintf("+--------+----------------+----------------+\n");

    for (poolNum = 0; poolNum < (PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? PRV_CPSS_DXCH_SIP_6_MAX_TC : PRV_CPSS_DXCH_MAX_TC); poolNum++)
    {
        /* get the limits */
        rc = cpssDxChPortTxSharedPoolLimitsGet(devNum,poolNum,&sharedPoolBufLimit[poolNum],&sharedPoolDescLimit[poolNum]);
        if (rc == GT_NOT_APPLICABLE_DEVICE)
        {
            cpssOsPrintf("|      Not applicable for this device      |\n");
            break;
        }

        cpssOsPrintf("|   %2d   |", poolNum);

        /* get the current number of Buffers n Used */
        rc = cpssDxChPortTxSharedResourceBufNumberGet(devNum,poolNum,&sharedBuffPerPool[poolNum]);
        if(rc == GT_NOT_APPLICABLE_DEVICE)
        {
            break;
        }
        else if (rc == GT_OK)
        {
            cpssOsPrintf("   %4d/%-4d    |", sharedBuffPerPool[poolNum], sharedPoolBufLimit[poolNum]);
        }
        else
        {
            cpssOsPrintf("     NA/%-4d    |", sharedPoolBufLimit[poolNum]);
        }


        /* get the current number of TDs n Used */
        rc = cpssDxChPortTxSharedResourceDescNumberGet(devNum,poolNum,&sharedDescPerPool[poolNum]);
        if(rc == GT_NOT_APPLICABLE_DEVICE)
        {
            break;
        }
        else if (rc == GT_OK)
        {
            cpssOsPrintf("   %4d/%-4d    |\n", sharedDescPerPool[poolNum], sharedPoolDescLimit[poolNum]);
        }
        else
        {
            cpssOsPrintf("     NA/%-4d    |\n", sharedPoolDescLimit[poolNum]);
        }

    }
    cpssOsPrintf("+--------+----------------+----------------+\n\n\n");


    /*============================ Check per TC per Tail Drop Profile what is the shared pool =====================*/

    cpssOsPrintf("Mapping TC to Share Pool per Tail Drop profile\n");
    cpssOsPrintf("----------------------------------------------\n\n\n");

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        cpssOsPrintf("+---------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n");
        cpssOsPrintf("| Profile | TC0 | TC1 | TC2 | TC3 | TC4 | TC5 | TC6 | TC7 | TC8 | TC9 | TC10| TC11| TC12| TC13| TC14| TC15|\n");
        cpssOsPrintf("+---------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n");
    }
    else
    {
        cpssOsPrintf("+---------+-----+-----+-----+-----+-----+-----+-----+-----+\n");
        cpssOsPrintf("| Profile | TC0 | TC1 | TC2 | TC3 | TC4 | TC5 | TC6 | TC7 |\n");
        cpssOsPrintf("+---------+-----+-----+-----+-----+-----+-----+-----+-----+\n");
    }

    for (tailDropProfile = CPSS_PORT_TX_DROP_PROFILE_1_E; tailDropProfile <= CPSS_PORT_TX_DROP_PROFILE_16_E; tailDropProfile++)
    {
        GT_BOOL done = GT_FALSE;

        if((CPSS_PP_FAMILY_DXCH_BOBCAT2_E > PRV_CPSS_PP_MAC(devNum)->devFamily) && (tailDropProfile > CPSS_PORT_TX_DROP_PROFILE_8_E))
        {
            break;
        }

        for(tcQueue = 0; tcQueue < (PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? PRV_CPSS_DXCH_SIP_6_MAX_TC : PRV_CPSS_DXCH_MAX_TC); tcQueue++)
        {
            rc = cpssDxChPortTxTcProfileSharedPoolGet(devNum,tailDropProfile,  tcQueue, &tcToPoolNum);
            if (rc == GT_NOT_APPLICABLE_DEVICE)
            {
                cpssOsPrintf("|             Not applicable for this device              |\n");
                done = GT_TRUE;
                break;
            }

            if (tcQueue == 0)
            {
                cpssOsPrintf("|%5d    |",tailDropProfile);
            }

            if (rc != GT_OK)
            {
                cpssOsPrintf("  NA |");
            }
            else
            {
                cpssOsPrintf("  %-2d |",tcToPoolNum);
            }

        } /* for tcQueue*/

        if (done)
        {
            break;
        }

        cpssOsPrintf("\n");
    } /* for tailDropProfile*/

    cpssOsPrintf("+---------+-----+-----+-----+-----+-----+-----+-----+-----+\n\n");


    /* ============== Read the TC enabled per TailDrop Profile ==========*/

    cpssOsPrintf("\n\n\n TC that are enabled for Shared Pool [Sharing mode]\n");
    cpssOsPrintf(" Legend:\n");
    cpssOsPrintf(" CPSS_PORT_TX_SHARED_DP_MODE_DISABLE_E\t[%-2d]\n", CPSS_PORT_TX_SHARED_DP_MODE_DISABLE_E);
    cpssOsPrintf(" CPSS_PORT_TX_SHARED_DP_MODE_ALL_E\t[%-2d]\n", CPSS_PORT_TX_SHARED_DP_MODE_ALL_E);
    cpssOsPrintf(" CPSS_PORT_TX_SHARED_DP_MODE_DP0_E\t[%-2d]\n", CPSS_PORT_TX_SHARED_DP_MODE_DP0_E);
    cpssOsPrintf(" CPSS_PORT_TX_SHARED_DP_MODE_DP0_DP1_E\t[%-2d]\n", CPSS_PORT_TX_SHARED_DP_MODE_DP0_DP1_E);
    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        cpssOsPrintf("+---------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n");
        cpssOsPrintf("| Profile | TC0 | TC1 | TC2 | TC3 | TC4 | TC5 | TC6 | TC7 | TC8 | TC9 | TC10| TC11| TC12| TC13| TC14| TC15|\n");
        cpssOsPrintf("+---------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n");
    }
    else
    {
        cpssOsPrintf("+---------+-----+-----+-----+-----+-----+-----+-----+-----+\n");
        cpssOsPrintf("| Profile | TC0 | TC1 | TC2 | TC3 | TC4 | TC5 | TC6 | TC7 |\n");
        cpssOsPrintf("+---------+-----+-----+-----+-----+-----+-----+-----+-----+\n");
    }

    for (tailDropProfile = CPSS_PORT_TX_DROP_PROFILE_1_E; tailDropProfile <= CPSS_PORT_TX_DROP_PROFILE_16_E; tailDropProfile++)
    {
        GT_BOOL done = GT_FALSE;

        if((CPSS_PP_FAMILY_DXCH_BOBCAT2_E > PRV_CPSS_PP_MAC(devNum)->devFamily) && (tailDropProfile > CPSS_PORT_TX_DROP_PROFILE_8_E))
        {
            break;
        }

        for (tcQueue = 0; tcQueue < (PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? PRV_CPSS_DXCH_SIP_6_MAX_TC : PRV_CPSS_DXCH_MAX_TC); tcQueue++)
        {
            rc = cpssDxChPortTxTcSharedProfileEnableGet(devNum, tailDropProfile,tcQueue,&TCEnabledForSharedPool);
            if(rc == GT_NOT_APPLICABLE_DEVICE)
            {
                cpssOsPrintf("|             Not applicable for this device              |\n");
                done = GT_TRUE;
                break;
            }

            if (tcQueue == 0)
            {
                cpssOsPrintf("|%5d    |",tailDropProfile);
            }

            if (rc != GT_OK)
            {
                cpssOsPrintf(" N/A |");
            }
            else
            {
                cpssOsPrintf("  %1d  |",TCEnabledForSharedPool);
            }
        }

        if (done)
        {
            break;
        }

        cpssOsPrintf("\n");
    }
    cpssOsPrintf("+---------+-----+-----+-----+-----+-----+-----+-----+-----+\n\n\n");

    return GT_OK;
}

/**
* @internal prvCpssDxChPortTxTailDropGlobalConfigurationGet function
* @endinternal
*
* @brief   Dumps global tail drop configuration.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - SW device number
*
* @retval GT_OK                    - on success, match found for devNum.
* @retval GT_FAIL                  - no match found for devNum.
*/
GT_STATUS prvCpssDxChPortTxTailDropGlobalConfigurationGet
(
    IN  GT_U8 devNum
)
{
    GT_STATUS                               rc;
    GT_U32                                  descNumber;
    GT_BOOL                                 enableTd,enableUcTd,enableRndTd;
    CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT
        consumptionMode;
    GT_U32                                  length;
    GT_U32                                  mcastMaxDescNum,
        mcastMaxBufNum   ,
        rxSniffMaxDescNum,
        txSniffMaxDescNum,
        rxSniffMaxBufNum,
        txSniffMaxBufNum;
    CPSS_DXCH_PORT_BUFFERS_MODE_ENT         bufferMode;
    GT_U32                                  portGroupGEBufferLimit;
    GT_U32                                  portGroupXGBufferLimit;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /*======================= Buffer mode and tail Drop enable/Disable===================================*/

    cpssOsPrintf("\n\n\n");
    cpssOsPrintf("** The value 65535 indicates Not Applicable Device\n\n");

    rc = cpssDxChPortBuffersModeGet(devNum,&bufferMode);
    if (rc == GT_OK)
    {
        if(bufferMode == CPSS_DXCH_PORT_BUFFERS_MODE_SHARED_E)
            cpssOsPrintf("Buffer Mode SHARED  i.e. Tail Drop\n");
        else if (bufferMode == CPSS_DXCH_PORT_BUFFERS_MODE_DIVIDED_E)
            cpssOsPrintf("Buffer Mode DIVIDED i.e. Flow Control\n");
        else
            cpssOsPrintf("Buffer Mode: %d\n",bufferMode);
    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortBuffersModeGet fails rc = %x\n",rc);
    }

    /* Tail drop global configuration*/
    rc = cpssDxChPortTxTailDropUcEnableGet(devNum,&enableUcTd);
    if (rc == GT_OK)
    {
        cpssOsPrintf("Tail Drop Enable/Disable for UC                    : [%1d]\n",enableUcTd);
    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortTxTailDropUcEnableGet fails rc = %x\n",rc);
    }

    rc = cpssDxChPortTxBufferTailDropEnableGet(devNum,&enableTd);
    if (rc == GT_OK)
    {
        cpssOsPrintf("Tail Drop UC Enable/Disable                        : [%1d]\n",enableTd);
    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortTxBufferTailDropEnableGet fails rc = %x\n",rc);
    }

    rc = cpssDxChPortTxRandomTailDropEnableGet(devNum,&enableRndTd);
    if (rc == GT_OK)
    {
        cpssOsPrintf("Tail Drop Random Enable/Disable                    : [%1d]\n",enableRndTd);
    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortTxRandomTailDropEnableGet fails rc = %x\n",rc);
    }

    rc = cpssDxChPortTxTailDropBufferConsumptionModeGet (devNum,&consumptionMode,&length);
    if (rc == GT_OK)
    {
        if (consumptionMode == CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_BYTE_E)
            cpssOsPrintf("Tail Drop Buffer Consumption mode Pkt/Byte is      : Byte   length : [%5d]\n",length);
        else /*if( consumptionMode == CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_PACKET_E)*/
            cpssOsPrintf("Tail Drop Buffer Consumption mode Pkt/Byte is      : Pkt    length : [%5d]\n",length);
    }
    else if (rc != GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("cpssDxChPortTxTailDropBufferConsumptionModeGet fails rc = %x\n",rc);
    }
    cpssOsPrintf("\n");


    /* ============================= Global Desc and buffer limits ==========================*/

    rc = cpssDxChPortTxGlobalDescLimitGet (devNum,&descNumber);
    if(rc == GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("Global number of Desc available in the System      : [N/A]\n");
    }
    else if (rc != GT_OK)
    {
        cpssOsPrintf("cpssDxChPortTxGlobalDescLimitGet failed rc = %x\n",rc);
    }
    else
    {
        cpssOsPrintf("Global number of Desc available in the System      : [%5d]\n",descNumber);
    }

    rc = cpssDxChPortGroupRxBufLimitGet (devNum,CPSS_DXCH_PORT_GROUP_GIGA_E,&portGroupGEBufferLimit);
    if(rc == GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("Global number of Buffers available for GE Ports    : [N/A]\n");
    }
    else if (rc != GT_OK)
    {
        cpssOsPrintf("cpssDxChPortGroupRxBufLimitGet failed for GE rc = %x\n",rc);
    }
    else
    {
        cpssOsPrintf("Global number of Buffers available for GE Ports    : [%4d]\n",portGroupGEBufferLimit);
    }

    rc = cpssDxChPortGroupRxBufLimitGet (devNum,CPSS_DXCH_PORT_GROUP_HGS_E,&portGroupXGBufferLimit);
    if(rc == GT_NOT_APPLICABLE_DEVICE)
    {
        cpssOsPrintf("Global number of Buffers available for HGS Ports   : [N/A]\n");
    }
    else if (rc != GT_OK)
    {
        cpssOsPrintf("cpssDxChPortGroupRxBufLimitGet failed for HGS rc = %x\n",rc);
    }
    else
    {
        cpssOsPrintf("Global number of Buffers available for HGS Ports   : [%4d]\n",portGroupXGBufferLimit);
    }


    /*================================= MC Resources ======================================*/
    rc = cpssDxChPortTxMcastPcktDescrLimitGet  (devNum,&mcastMaxDescNum);
    if(rc == GT_NOT_APPLICABLE_DEVICE)
    {
        mcastMaxDescNum = 0xFFFF;
    }
    else if (rc != GT_OK)
    {
        cpssOsPrintf("cpssDxChPortTxMcastPcktDescrLimitGet fails rc = %x\n",rc);
    }

    else
    {
        cpssOsPrintf("Global number of Desc available for MC             : [%4d]\n",mcastMaxDescNum);
    }

    rc = cpssDxChPortTxMcastBuffersLimitGet(devNum,&mcastMaxBufNum);
    if(rc == GT_NOT_APPLICABLE_DEVICE)
    {
        mcastMaxBufNum = 0xFFFF;
    }
    else if (rc == GT_OK)
    {
        cpssOsPrintf("Global number of buffers/Desc available for MC     : [%4d/%-4d]\n",mcastMaxBufNum,mcastMaxDescNum);
    }
    else
    {
        cpssOsPrintf("cpssDxChPortTxMcastBuffersLimitGet fails rc = %x\n",rc);
    }


    /*================================= Sniffer Rx/Tx [Buffers/Desc] Resources ======================================*/

    rc = cpssDxChPortTxSniffedPcktDescrLimitGet(devNum,&rxSniffMaxDescNum,&txSniffMaxDescNum);
    if(rc == GT_NOT_APPLICABLE_DEVICE)
    {
        rxSniffMaxDescNum=0xFFFF;
        txSniffMaxDescNum=0xFFFF;
    }
    else if (rc != GT_OK)
    {
        cpssOsPrintf("cpssDxChPortTxSniffedPcktDescrLimitGet fails rc = %x\n",rc);
    }

    rc = cpssDxChPortTxSniffedBuffersLimitGet  (devNum,&rxSniffMaxBufNum, &txSniffMaxBufNum);
    if(rc == GT_NOT_APPLICABLE_DEVICE)
    {
        rxSniffMaxBufNum=0xFFFF;
        txSniffMaxBufNum=0xFFFF;
    }
    else if (rc != GT_OK)
    {
        cpssOsPrintf("cpssDxChPortTxSniffedBuffersLimitGet fails rc = %x\n",rc);
    }

    cpssOsPrintf("Number of Buffer/Descr available for Rx Sniffer    : [%4d/%-4d]\n",rxSniffMaxBufNum,rxSniffMaxDescNum);
    cpssOsPrintf("Number of Buffer/Descr available for Tx Sniffer    : [%4d/%-4d]\n",txSniffMaxBufNum,txSniffMaxDescNum);
    cpssOsPrintf("\n\n");

    return GT_OK;
}

/**
* @internal prvCpssDxChPortTxTailDropProfilesGet function
* @endinternal
*
* @brief   Dumps Tail Drop configuration related tail drop configuration and resource allocation.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - SW device number
*
* @retval GT_OK                    - on success, match found for devNum.
*/
GT_STATUS prvCpssDxChPortTxTailDropProfilesGet
(
    IN  GT_U8 devNum
)
{
    GT_STATUS                               rc;
    GT_U8                                   tcQueue;
    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       tailDropProfile;
    CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC tailDropProfileParams;
    GT_U32                                  portMaxBuffLimit,portMaxDescrLimit;
    CPSS_DXCH_PORT_TX_TAIL_DROP_BUFFER_CONSUMPTION_MODE_ENT
        tailDropBufConsMode;
    CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_ENT alpha = CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_0_E;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    cpssOsPrintf("+-------------------------------------------------------------------------------------+\n");
    cpssOsPrintf("|                                                                                     |\n");
    cpssOsPrintf("|               T  A  I  L    D  R  O  P    P  R  O  F  I  L  E  S                    |\n");
    cpssOsPrintf("|                                                                                     |\n");
    cpssOsPrintf("+-------------------------------------------------------------------------------------+\n");

    cpssOsPrintf("\n** The value 65535 indicates Not Applicable Device\n\n");

    for (tailDropProfile = CPSS_PORT_TX_DROP_PROFILE_1_E; tailDropProfile <= CPSS_PORT_TX_DROP_PROFILE_16_E; tailDropProfile++)
    {
        if((CPSS_PP_FAMILY_DXCH_BOBCAT2_E > PRV_CPSS_PP_MAC(devNum)->devFamily) && (tailDropProfile > CPSS_PORT_TX_DROP_PROFILE_8_E))
        {
            break;
        }

        rc = cpssDxChPortTxTailDropProfileBufferConsumptionModeGet(devNum, tailDropProfile, &tailDropBufConsMode);
        if(rc == GT_NOT_APPLICABLE_DEVICE)
        {
            tailDropBufConsMode = 0xFFFF;
        }
        else if(rc != GT_OK)
        {
            cpssOsPrintf("cpssDxChPortTxTailDropProfileBufferConsumptionModeGet fails rc = %x\n",rc);
        }


        rc = cpssDxChPortTxTailDropProfileGet(devNum,tailDropProfile,&alpha,&portMaxBuffLimit,&portMaxDescrLimit);
        if(rc != GT_OK)
        {
            cpssOsPrintf("cpssDxChPortTxTailDropProfileGet fails rc = %x\n",rc);
        }

        if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
        {
            cpssOsPrintf("\nprofile                            : [%8d]\nMax buffers Limit          : [%8d]\nMax Desc Limit             : [%8d]\nTDBufConsMode[Byte/Packet]         : [%8d]\nalpha                      : [%8d]\n",
                tailDropProfile,portMaxBuffLimit,portMaxDescrLimit,tailDropBufConsMode,alpha);
        }
        else
        {
            cpssOsPrintf("\nprofile                            : [%8d]\nMax buffers Limit          : [%8d]\nMax Desc Limit             : [%8d]\nTDBufConsMode[Byte/Packet]         : [%8d]\n",
                tailDropProfile,portMaxBuffLimit,portMaxDescrLimit,tailDropBufConsMode);
        }

        cpssOsPrintf("\n");
        cpssOsPrintf("+----+-------------------+-------------------+-------------------+-----------------------+\n");
        cpssOsPrintf("| TC | DP0 [Buf/Desc/MC] | DP1 [Buf/Desc/MC] | DP2 [Buf/Desc/MC] | Counting En/Dis [0/1] |\n");
        cpssOsPrintf("|    | MC for DEV >= BC2 | MC for DEV >= BC2 | MC for DEV >= BC2 |    for DEV >= BC2     |\n");
        cpssOsPrintf("+----+-------------------+-------------------+-------------------+-----------------------+\n");

        for(tcQueue = 0; tcQueue < (PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? PRV_CPSS_DXCH_SIP_6_MAX_TC : PRV_CPSS_DXCH_MAX_TC); tcQueue++)
        {
            cpssOsMemSet(&tailDropProfileParams,0x0,sizeof(tailDropProfileParams));

            rc = cpssDxChPortTx4TcTailDropProfileGet(devNum,tailDropProfile,tcQueue,&tailDropProfileParams);
            if(rc != GT_OK)
            {
                cpssOsPrintf("cpssDxChPortTx4TcTailDropProfileGet fails rc = %x\n",rc);
            }

            if(CPSS_PP_FAMILY_DXCH_BOBCAT2_E <= PRV_CPSS_PP_MAC(devNum)->devFamily)
            {
                cpssOsPrintf("| %2d |  %-4d/%-4d/%-4d   |  %-4d/%-4d/%-4d   |  %-4d/%-4d/%-4d   |             %1d         |\n",
                    tcQueue,
                    tailDropProfileParams.dp0MaxBuffNum,
                    tailDropProfileParams.dp0MaxDescrNum,
                    tailDropProfileParams.dp0MaxMCBuffNum,
                    tailDropProfileParams.dp1MaxBuffNum,
                    tailDropProfileParams.dp1MaxDescrNum,
                    tailDropProfileParams.dp1MaxMCBuffNum,
                    tailDropProfileParams.dp2MaxBuffNum,
                    tailDropProfileParams.dp2MaxDescrNum,
                    tailDropProfileParams.dp2MaxMCBuffNum,
                    tailDropProfileParams.sharedUcAndMcCountersDisable);
            }
            else
            {
                cpssOsPrintf("| %2d |     %4d/%-4d     |     %4d/%-4d     |     %4d/%-4d     |          N/A          |\n",
                    tcQueue,
                    tailDropProfileParams.dp0MaxBuffNum,
                    tailDropProfileParams.dp0MaxDescrNum,
                    tailDropProfileParams.dp1MaxBuffNum,
                    tailDropProfileParams.dp1MaxDescrNum,
                    tailDropProfileParams.dp2MaxBuffNum,
                    tailDropProfileParams.dp2MaxDescrNum);
            }
        }

        cpssOsPrintf("+----+-------------------+-------------------+-------------------+-----------------------+\n\n");
    }
    cpssOsPrintf("\n");


    return GT_OK;
}

/**
* @internal prvCpssDxChPortTxTailDropPortToTDProfileGet function
* @endinternal
*
* @brief   Dumps tail drop configuration showing the port and its tail drop profile.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - SW device number
*
* @retval GT_OK                    - on success, match found for devNum.
*/
GT_STATUS prvCpssDxChPortTxTailDropPortToTDProfileGet
(
    IN  GT_U8 devNum
)
{
    GT_STATUS                               rc;
    GT_PHYSICAL_PORT_NUM                    portNum;
    GT_PHYSICAL_PORT_NUM                    portMaxIter;/* maximal port number */
    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       tailDropProfile;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    cpssOsPrintf("+-------------------------------------------------------------------------------------+\n");
    cpssOsPrintf("|                                                                                     |\n");
    cpssOsPrintf("|       P  O  R  T       T  O      T  A  I  L      D  R  O  P                         |\n");
    cpssOsPrintf("|                                                                                     |\n");
    cpssOsPrintf("+-------------------------------------------------------------------------------------+\n");

    cpssOsPrintf("\n\nPort<->Tail Drop Profile Binding: [port:TD Profile]\n");

    if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        portMaxIter = PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum);
    }
    else
    {
        portMaxIter = PRV_CPSS_PP_MAC(devNum)->numOfPorts;
    }
    for(portNum = 0; portNum < portMaxIter; portNum++)
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            if((PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].valid == GT_FALSE) ||
            (PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].portMap.txqNum == CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS))
            {
                continue;
            }
        }
        else
        {
            /* skip non existing ports (not including cpu port) */
            if ((! PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, portNum)) && (portNum != CPSS_CPU_PORT_NUM_CNS))
                continue;
        }

        rc = cpssDxChPortTxBindPortToDpGet(devNum,portNum,&tailDropProfile);
        if(rc != GT_OK)
        {
            cpssOsPrintf("cpssDxChPortTxBindPortToDpGet fails rc = %x\n",rc);
        }

        if ((portNum % 8) == 0)
            cpssOsPrintf("\n");

        cpssOsPrintf("[%3d:%2d] ",portNum,tailDropProfile);
    }

    /* cpu port */
    if (portNum <= CPSS_CPU_PORT_NUM_CNS)
    {
        cpssOsPrintf("\n");
        rc = cpssDxChPortTxBindPortToDpGet(devNum,63,&tailDropProfile);
        if(rc != GT_OK)
        {
            cpssOsPrintf("cpssDxChPortTxBindPortToDpGet fails rc = %x\n",rc);
        }

        cpssOsPrintf("[%3d:%2d] ",63,tailDropProfile);
    }

    cpssOsPrintf("\n\n");

    return GT_OK;
}

/**
* @internal prvCpssDxChPortTxSchedulerConfigGet function
* @endinternal
*
* @brief   dumps the related WRTD parameters in the system.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - SW device number
*
* @retval GT_OK                    - on success, match found for devNum.
* @retval GT_FAIL                  - no match found for devNum.
*/
GT_STATUS prvCpssDxChPortTxSchedulerConfigGet
(
    IN  GT_U8 devNum
)
{
    GT_STATUS                               rc;
    GT_U8                                   tcQueue;
    GT_PHYSICAL_PORT_NUM                    portNum;
    GT_PHYSICAL_PORT_NUM                    portMaxIter;/* maximal port number */
    CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT  profileSet;
    CPSS_PORT_TX_WRR_MTU_ENT                wrrMtu;
    CPSS_PORT_TX_WRR_MODE_ENT               wrrMode;
    GT_BOOL                                 deficitModeEnable;
    PORT_SCHEDULER_PARAM_STC                schedulerParams ;
    GT_U32                                  i,tileIterator,tileNumber;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);


    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {

        cpssOsPrintf("+-------------------------------------------------------------------------------------+\n");
        cpssOsPrintf("|                                                                                     |\n");
        cpssOsPrintf("|                            S   I   P   6      SCHEDULER                             |\n");
        cpssOsPrintf("|                                                                                     |\n");
        cpssOsPrintf("+-------------------------------------------------------------------------------------+\n\n");

        switch(PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles)
        {
        case 0:
        case 1:
            tileNumber = 1;
            break;\
        case 2:
        case 4:
            tileNumber =PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles;\
                break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, "unexpected number of tiles - %d ",PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles);
            break;
        }


        if(PRV_CPSS_DXCH_SIP6_TXQ_DUMP_ENABLED(SCHED_PROFILE_DB))
        {

            rc = prvCpssSip6TxqUtilsDumpSchedDbProfiles(devNum);

            if(GT_OK != rc)
            {
                return rc;
            }

            rc = prvCpssSip6TxqUtilsDumpBindPortsToSchedDb(devNum);

            if(GT_OK != rc)
            {
                return rc;
            }

            cpssOsTimerWkAfter(50);
        }


        if(PRV_CPSS_DXCH_SIP6_TXQ_DUMP_ENABLED(SW_MAP_SHADOW))
        {

            rc = prvCpssFalconTxqUtilsPhysicalPortsToSwShadowDump(devNum,0,128);

            if(GT_OK != rc)
            {
                return rc;
            }

            cpssOsTimerWkAfter(50);
        }


        for(tileIterator=0;tileIterator<tileNumber;tileIterator++)
        {

            cpssOsPrintf("|                            T   I   L   E    [%d] total tiles [%d]                            |\n",tileIterator,tileNumber);



            if(PRV_CPSS_DXCH_SIP6_TXQ_DUMP_ENABLED(PDQ_SW))
            {

                cpssOsPrintf("Dump scheduler database from SW\n");

                for(i = 0;i<72;i++)
                {

                    rc = prvCpssFalconTxqPdqDumpPortSw(devNum,tileIterator,i);

                    if(GT_OK != rc)
                    {
                        return rc;
                    }

                    cpssOsTimerWkAfter(50);
                }
            }

            if(PRV_CPSS_DXCH_SIP6_TXQ_DUMP_ENABLED(PDQ_HW))
            {

                cpssOsPrintf("Dump scheduler database from HW\n");

                for(i = 0;i<74;i++)
                {

                    rc = prvCpssFalconTxqPdqDumpPortHw(devNum,tileIterator,i);

                    if(GT_OK != rc)
                    {
                        return rc;
                    }

                    cpssOsTimerWkAfter(50);
                }
            }

            if(PRV_CPSS_DXCH_SIP6_TXQ_DUMP_ENABLED(PDX))
            {
                rc = prvCpssFalconTxqUtilsPdxTablesDump(devNum,tileIterator,CPSS_DXCH_SIP_6_10_MAX_Q_GROUP_SIZE_MAC,GT_TRUE);
                if(GT_OK != rc)
                {
                    return rc;
                }

                cpssOsTimerWkAfter(50);
            }

            if(PRV_CPSS_DXCH_SIP6_TXQ_DUMP_ENABLED(PSI))
            {

                rc = prvCpssFalconTxqUtilsPsiConfigDump(devNum,tileIterator);
                if(GT_OK != rc)
                {
                    return rc;
                }


                cpssOsTimerWkAfter(50);
            }


            if(PRV_CPSS_DXCH_SIP6_TXQ_DUMP_ENABLED(SDQ))
            {

                for(i = 0;i<8;i++)
                {
                    rc = prvCpssFalconTxqUtilsSdqPortRangeDump(devNum,tileIterator,i,GT_FALSE,0);

                    if(GT_OK != rc)
                    {
                        return rc;
                    }


                    rc = prvCpssFalconTxqUtilsSdqQueueAttributesDump(devNum,tileIterator,i,0,72,NULL);

                    if(GT_OK != rc)
                    {
                        return rc;
                    }

                    cpssOsTimerWkAfter(50);
                }
            }
        }
    }
    else
    {

        cpssOsPrintf("+-------------------------------------------------------------------------------------+\n");
        cpssOsPrintf("|                                                                                     |\n");
        cpssOsPrintf("|                            S   C   H   E   D   U   L   E   R                        |\n");
        cpssOsPrintf("|                                                                                     |\n");
        cpssOsPrintf("+-------------------------------------------------------------------------------------+\n\n");

        rc = cpssDxChPortTxWrrGlobalParamGet(devNum, &wrrMode, &wrrMtu);
        if (rc != GT_OK && rc != GT_NOT_APPLICABLE_DEVICE)
        {
            cpssOsPrintf("cpssDxChPortTxWrrGlobalParamGet fails rc = %x\n",rc);
        }

        cpssOsPrintf("WRR Global parameters:\n");
        cpssOsPrintf("======================\n");

        rc = cpssDxChPortTxSchedulerDeficitModeEnableGet( devNum, &deficitModeEnable);
        if (rc == GT_OK)
        {
            cpssOsPrintf("Scheduler Deficit Mode [Enable/Disable] is %d\n",deficitModeEnable);
        }
        else if (rc != GT_NOT_APPLICABLE_DEVICE)
        {
            cpssOsPrintf("cpssDxChPortTxSchedulerDeficitModeEnableGet fails rc = %x\n",rc);
        }


        if (wrrMode == 0)
            cpssOsPrintf("WRR MODE is BYTE\n");
        else
            cpssOsPrintf("WRR MODE is PACKET\n");

        switch (wrrMtu)
        {
        case CPSS_PORT_TX_WRR_MTU_256_E:
            cpssOsPrintf("WRR MTU = 256\n");
            break;
        case CPSS_PORT_TX_WRR_MTU_2K_E:
            cpssOsPrintf("WRR MTU = 2K\n");
            break;
        case CPSS_PORT_TX_WRR_MTU_8K_E:
            cpssOsPrintf("WRR MTU = 8K\n");
            break;
        case CPSS_PORT_TX_WRR_MTU_64_E:
            cpssOsPrintf("WRR MTU = 64\n");
            break;
        case CPSS_PORT_TX_WRR_MTU_128_E:
            cpssOsPrintf("WRR MTU = 128\n");
            break;
        case CPSS_PORT_TX_WRR_MTU_512_E:
            cpssOsPrintf("WRR MTU = 512\n");
            break;
        case CPSS_PORT_TX_WRR_MTU_1K_E:
            cpssOsPrintf("WRR MTU = 1K\n");
            break;
        case CPSS_PORT_TX_WRR_MTU_4K_E:
            cpssOsPrintf("WRR MTU = 4K\n");
            break;
        case CPSS_PORT_TX_WRR_MTU_16K_E:
            cpssOsPrintf("WRR MTU = 16K\n");
            break;
        case CPSS_PORT_TX_WRR_MTU_32K_E:
            cpssOsPrintf("WRR MTU = 32K\n");
            break;
        case CPSS_PORT_TX_WRR_MTU_64K_E:
            cpssOsPrintf("WRR MTU = 64K\n");
            break;
        default:
            cpssOsPrintf(" WRR MTU = N/A [Value = %d]\n",wrrMtu);
            break;
        }


        /*=============================== Scheduler Profiles =============================*/

        cpssOsPrintf("\n\n     Scheduler profiles\n");
        cpssOsPrintf("=======================================\n\n\n");
        cpssOsPrintf("** The value -1 indicates Not Applicable Device\n\n");

        cpssOsPrintf("+----------+------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n");
        cpssOsPrintf("|  profile | Count Mode |    TC0    |    TC1    |    TC2    |    TC3    |    TC4    |    TC5    |    TC6    |    TC7    |\n");
        cpssOsPrintf("|          | [Byte/Pkt] | [Grp/Wgt] | [Grp/Wgt] | [Grp/Wgt] | [Grp/Wgt] | [Grp/Wgt] | [Grp/Wgt] | [Grp/Wgt] | [Grp/Wgt] |\n");
        cpssOsPrintf("+----------+------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n");

        cpssOsMemSet(&schedulerParams,0xFF,sizeof(schedulerParams));
        for (profileSet = CPSS_PORT_TX_SCHEDULER_PROFILE_1_E; profileSet <= CPSS_PORT_TX_SCHEDULER_PROFILE_16_E; profileSet++)
        {
            if((CPSS_PP_FAMILY_DXCH_BOBCAT2_E > PRV_CPSS_PP_MAC(devNum)->devFamily) && (profileSet > CPSS_PORT_TX_SCHEDULER_PROFILE_8_E))
            {
                break;
            }

            rc = cpssDxChPortProfileTxByteCountChangeEnableGet(devNum,profileSet,&schedulerParams.byteCountode,&schedulerParams.byteCountOperation );
            if(rc == GT_NOT_APPLICABLE_DEVICE)
            {
                ;
            }
            else if(rc != GT_OK)
            {
                cpssOsPrintf("cpssDxChPortTxSchedulerProfileCountModeGet fails rc = %x\n",rc);
            }

            rc = cpssDxChPortTxSchedulerProfileCountModeGet(devNum, profileSet, &schedulerParams.countMode);
            if(rc == GT_NOT_APPLICABLE_DEVICE)
            {
                ;
            }
            else if(rc != GT_OK)
            {
                cpssOsPrintf("cpssDxChPortTxSchedulerProfileCountModeGet fails rc = %x\n",rc);
            }

            for(tcQueue = 0; tcQueue < (PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? PRV_CPSS_DXCH_SIP_6_MAX_TC : PRV_CPSS_DXCH_MAX_TC); tcQueue++)
            {
                /*Get the arbitration group */
                rc = cpssDxChPortTxQArbGroupGet(devNum, tcQueue, profileSet, &schedulerParams.arbGroup[tcQueue]);
                if(rc == GT_NOT_APPLICABLE_DEVICE)
                {
                    ;
                }
                else if(rc != GT_OK)
                {
                    cpssOsPrintf("cpssDxChPortTxQArbGroupGet fails rc = %x\n",rc);
                }
                /* Get the weight */
                rc = cpssDxChPortTxQWrrProfileGet(devNum, tcQueue, profileSet, &schedulerParams.wrrWeight[tcQueue]);
                if(rc == GT_NOT_APPLICABLE_DEVICE)
                {
                    ;
                }
                else if(rc != GT_OK)
                {
                    cpssOsPrintf("cpssDxChPortTxQWrrProfileGet fails rc = %x\n",rc);
                }
            }
            cpssOsPrintf("|%9d |   %-6d   |",profileSet,schedulerParams.countMode);

            for(tcQueue = 0; tcQueue < (PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? PRV_CPSS_DXCH_SIP_6_MAX_TC : PRV_CPSS_DXCH_MAX_TC); tcQueue++)
            {
                if(schedulerParams.arbGroup[tcQueue] == CPSS_PORT_TX_SP_ARB_GROUP_E)
                {
                    cpssOsPrintf("  [SP/NA]  |");
                }
                else
                {
                    cpssOsPrintf("  [%2d/%-3d] |",  schedulerParams.arbGroup[tcQueue],  schedulerParams.wrrWeight[tcQueue]);
                }
            }
            cpssOsPrintf("\n");
        }
        cpssOsPrintf("+----------+------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n\n\n");

        cpssOsPrintf("+----------+---------------+-------------+\n");
        cpssOsPrintf("|          | Byte Count    | Byte Count  |\n");
        cpssOsPrintf("|          | 0-Disable     | Operation   |\n");
        cpssOsPrintf("|  profile | 1-Shaper Only | 0- Add      |\n");
        cpssOsPrintf("|          | 2-Sched  Only | 1-Subtract  |\n");
        cpssOsPrintf("|          | 3-Both        |             |\n");
        cpssOsPrintf("+----------+---------------+-------------+\n");

        for (profileSet = CPSS_PORT_TX_SCHEDULER_PROFILE_1_E; profileSet <= CPSS_PORT_TX_SCHEDULER_PROFILE_16_E; profileSet++)
        {
            rc = cpssDxChPortProfileTxByteCountChangeEnableGet(devNum,profileSet,&schedulerParams.byteCountode,&schedulerParams.byteCountOperation );
            if(rc == GT_NOT_APPLICABLE_DEVICE)
            {
                cpssOsPrintf("|    Not Applicable for this device      |\n");
                break;
            }
            else if(rc != GT_OK)
            {
                cpssOsPrintf("cpssDxChPortProfileTxByteCountChangeEnableGet fails rc = %x\n",rc);
            }

            cpssOsPrintf("|%9d |    %6d     | %6d    |\n",profileSet,schedulerParams.byteCountode,schedulerParams.byteCountOperation);
        }
        cpssOsPrintf("+----------+---------------+-------------+\n");


        /*================================= What port is bound to what scheduler profile =============================*/

        cpssOsPrintf("\n\n     Find what port is bound to what scheduler profile\n");
        cpssOsPrintf("=======================================================================\n");

        cpssOsPrintf("\n\nPort<->Scheduler Profile Binding: [port:Scheduler Profile]\n");

        if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            portMaxIter = PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum);
        }
        else
        {
            portMaxIter = PRV_CPSS_PP_MAC(devNum)->numOfPorts;
        }
        for(portNum = 0; portNum < portMaxIter; portNum++)
        {
            if(PRV_CPSS_DXCH_PP_HW_INFO_PORT_MAP_CHECK_SUPPORTED_MAC(devNum) == GT_TRUE)
            {
                if((PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].valid == GT_FALSE) ||
                (PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMapInfoShadowArr[portNum].portMap.txqNum == CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS))
                {
                    continue;
                }
            }
            else
            {
                /* skip non existing ports (not including cpu port) */
                if ((! PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, portNum)) && (portNum != CPSS_CPU_PORT_NUM_CNS))
                    continue;
            }

            rc = cpssDxChPortTxBindPortToSchedulerProfileGet(devNum, portNum, &profileSet);
            if(rc == GT_NOT_APPLICABLE_DEVICE)
            {
                cpssOsPrintf("*** This device doesn't support cpssDxChPortTxBindPortToSchedulerProfileGet ***\n");
                break;
            }
            else if(rc != GT_OK)
            {
                cpssOsPrintf("cpssDxChPortTxBindPortToSchedulerProfileGet fails rc = %x\n",rc);
            }

            if ((portNum % 8) == 0)
                cpssOsPrintf("\n");

            cpssOsPrintf("[%3d:%2d] ",portNum,profileSet);
        }

        /* cpu port */
        for (; portNum <= CPSS_CPU_PORT_NUM_CNS;)
        {
            rc = cpssDxChPortTxBindPortToSchedulerProfileGet(devNum, 63, &profileSet);
            if(rc == GT_NOT_APPLICABLE_DEVICE)
            {
                cpssOsPrintf("*** This device doesn't support cpssDxChPortTxBindPortToSchedulerProfileGet ***\n");
                break;
            }
            else if(rc != GT_OK)
            {
                cpssOsPrintf("cpssDxChPortTxBindPortToSchedulerProfileGet fails rc = %x\n",rc);
            }

            cpssOsPrintf("\n");
            cpssOsPrintf("[%3d:%2d] ",63,profileSet);

            break;
        }

        cpssOsPrintf("\n\n");

    }


    return GT_OK;
}

/**
* @internal prvCpssDxChPortTxTailDropWRTDinfoGet function
* @endinternal
*
* @brief   dumps the related WRTD parameters in the system.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - SW device number
*
* @retval GT_OK                    - on success, match found for devNum.
* @retval GT_FAIL                  - no match found for devNum.
*/
GT_STATUS prvCpssDxChPortTxTailDropWRTDinfoGet
(
    IN  GT_U8 devNum
)
{
    GT_STATUS                               rc;
    GT_U8                                   ii;
    GT_U8                                   tcQueue;
    CPSS_PORT_TX_TAIL_DROP_WRTD_ENABLERS_STC
        tailDropWRTDenablers[3];
    CPSS_PORT_TX_WRTD_MASK_LSB_STC          maskLsb;

    GT_U8                                   dp[3]={0,1,2};/*for some devices only 0,1 need to address that */
    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       tailDropProfile;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /*================================ Random Tail Drop =======================*/

    cpssOsMemSet(&maskLsb,0x0,sizeof(maskLsb));

    rc = cpssDxChPortTxTailDropWrtdMasksGet(devNum, &maskLsb);
    if(rc == GT_NOT_APPLICABLE_DEVICE)
    {
        CPSS_LOG_INFORMATION_MAC("Not applicable for this device\n");
        return GT_OK;
    }
    else if (rc != GT_OK)
    {
        cpssOsPrintf("cpssDxChPortTxTailDropWrtdMasksGet fails rc = %x\n",rc);
    }


    cpssOsPrintf("\n\n");
    cpssOsPrintf("+-------------------------------------------------------------------------------------+\n");
    cpssOsPrintf("|                                                                                     |\n");
    cpssOsPrintf("|           W e i g h t e d    R a n d o m    T a i l   D r o p                       |\n");
    cpssOsPrintf("|                                                                                     |\n");
    cpssOsPrintf("+-------------------------------------------------------------------------------------+\n");
    cpssOsPrintf("\n\n");


    cpssOsPrintf("+------------+----+----+----------------+--------------+--------------+----------------------+\n");
    cpssOsPrintf("|            |    |    | Use Port Limit | Use TC Limit | Use DP Limit | Use Share pool Limit |\n");
    cpssOsPrintf("| TD Profile | TC | DP |    [En/Dis]    |   [En/Dis]   |   [En/Dis]   |        [En/Dis]      |\n");
    cpssOsPrintf("|            |    |    |    Mask=%3d    |   Mask=%3d   |  Mask=%3d    |        Mask=%3d      |\n",
        maskLsb.port,maskLsb.tc,maskLsb.tcDp,maskLsb.pool);
    cpssOsPrintf("+------------+----+----+----------------+--------------+--------------+----------------------+\n");

    for (tailDropProfile=CPSS_PORT_TX_DROP_PROFILE_1_E; tailDropProfile <= CPSS_PORT_TX_DROP_PROFILE_16_E; tailDropProfile++)
    {

        if((CPSS_PP_FAMILY_DXCH_BOBCAT2_E > PRV_CPSS_PP_MAC(devNum)->devFamily) && (tailDropProfile > CPSS_PORT_TX_DROP_PROFILE_8_E))
        {
            break;
        }

        for(tcQueue = 0; tcQueue < (PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? PRV_CPSS_DXCH_SIP_6_MAX_TC : PRV_CPSS_DXCH_MAX_TC); tcQueue++)
        {
            for(ii = 0; ii <= 2; ii++)
            {
                if (CPSS_PP_FAMILY_DXCH_XCAT2_E == PRV_CPSS_PP_MAC(devNum)->devFamily && ii == 2)
                {
                    break;
                }

                cpssOsMemSet(&tailDropWRTDenablers,0x0,sizeof(tailDropWRTDenablers));

                /*Tail Drop limits enabling for Weighted Random Tail Drop*/
                rc = cpssDxChPortTxProfileWeightedRandomTailDropEnableGet(devNum, tailDropProfile,dp[ii],tcQueue,&tailDropWRTDenablers[ii]);
                if (rc == GT_OK)
                {
                    cpssOsPrintf("|   %3d      | %2d | %2d |    %12d|    %10d|    %10d|    %18d|\n",
                        tailDropProfile, tcQueue, dp[ii],
                        tailDropWRTDenablers[ii].portLimit,
                        tailDropWRTDenablers[ii].sharedPoolLimit,
                        tailDropWRTDenablers[ii].tcDpLimit,
                        tailDropWRTDenablers[ii].tcLimit);
                }
                else if (rc != GT_NOT_APPLICABLE_DEVICE)
                {
                    cpssOsPrintf("cpssDxChPortTxProfileWeightedRandomTailDropEnableGet fails dp[%1d] rc = %x\n",dp[ii],rc);
                }
            }
        }

        cpssOsPrintf("+------------+----+----+----------------+--------------+--------------+----------------------+\n");
    }

    cpssOsPrintf("\n\n");
    return GT_OK;
}

/**
* @internal internal_cpssDxChPortTxQueueDumpAll function
* @endinternal
*
* @brief   Dumps all related Tx Queue information.
*         That includes the static configuration and resources allocated at run-time
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - SW device number
* @param[in] tailDropDumpBmp          - bitmap to indicate what info to show (0xff for all)
*
* @retval GT_OK                    - on success, match found for devNum.
* @retval GT_BAD_PARAM             - on tailDropDumpBmp not in range
*/
GT_STATUS internal_cpssDxChPortTxQueueDumpAll
(
    IN  GT_U8 devNum,
    IN  GT_U32 tailDropDumpBmp
)
{
    GT_STATUS  rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /* check if bitmap value is within range */
    if (tailDropDumpBmp == 0 || tailDropDumpBmp > 0xff)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (tailDropDumpBmp & 0x1f)
    {
        cpssOsPrintf("+=====================================================================================+\n");
        cpssOsPrintf("|                                                                                     |\n");
        cpssOsPrintf("|                           T  A  I  L    D  R  O  P                                  |\n");
        cpssOsPrintf("|               R  E  S  O  U  R  C  E    T  H  R  E  S  H  O  L  D  S                |\n");
        cpssOsPrintf("|                                                                                     |\n");
        cpssOsPrintf("+=====================================================================================+\n");

        if (tailDropDumpBmp & PRV_CPSS_DXCH_DUMP_TAIL_DROP_GLOBAL_CONFIG)
        {
            rc = prvCpssDxChPortTxTailDropGlobalConfigurationGet(devNum);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        if (tailDropDumpBmp & PRV_CPSS_DXCH_DUMP_TAIL_DROP_PROFILES)
        {
            rc = prvCpssDxChPortTxTailDropProfilesGet(devNum);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        if (tailDropDumpBmp & PRV_CPSS_DXCH_DUMP_TAIL_DROP_PORT_TO_TD_PROFILE)
        {
            rc = prvCpssDxChPortTxTailDropPortToTDProfileGet(devNum);
            if (rc != GT_OK) {
                return rc;
            }
        }

        if (tailDropDumpBmp & PRV_CPSS_DXCH_DUMP_TAIL_DROP_SCHEDULER_CONFIG)
        {
            rc = prvCpssDxChPortTxSchedulerConfigGet(devNum);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        if (tailDropDumpBmp & PRV_CPSS_DXCH_DUMP_TAIL_DROP_WRTD_INFO)
        {
            rc = prvCpssDxChPortTxTailDropWRTDinfoGet(devNum);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        cpssOsPrintf("\n\n");
    }


    if (tailDropDumpBmp & 0xe0)
    {
        cpssOsPrintf("+=====================================================================================+\n");
        cpssOsPrintf("|                                                                                     |\n");
        cpssOsPrintf("|                          T  A  I  L     D  R  O  P                                  |\n");
        cpssOsPrintf("|              R  E  S  O  U  R  C  E     A  L  L  O  C  A  T  I  O  N                |\n");
        cpssOsPrintf("|                                                                                     |\n");
        cpssOsPrintf("+=====================================================================================+\n");

        if (tailDropDumpBmp & PRV_CPSS_DXCH_DUMP_TAIL_DROP_RESOURCE_ALLOCATION)
        {
            rc = prvCpssDxChPortTxTailDropResourceAllocationGet(devNum);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        if (tailDropDumpBmp & PRV_CPSS_DXCH_DUMP_TAIL_DROP_SHARE_POOL)
        {
            rc = prvCpssDxChPortTxTailDropSharePoolEnPerProfileGet(devNum);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        if (tailDropDumpBmp & PRV_CPSS_DXCH_DUMP_TX_Q_STATUS)
        {
            rc = prvCpssDxChPortTxQStatusGet(devNum);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxQueueDumpAll function
* @endinternal
*
* @brief   Dumps all related Tx Queue information.
*         That includes the static configuration and resources allocated at run-time
*
* @note   APPLICABLE DEVICES:       xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - SW device number
* @param[in] tailDropDumpBmp          - bitmap to indicate what info to show (0xff for all)
*
* @retval GT_OK                    - on success, match found for devNum.
* @retval GT_BAD_PARAM             - on tailDropDumpBmp not in range.
*/
GT_STATUS cpssDxChPortTxQueueDumpAll
(
    IN  GT_U8 devNum,
    IN  GT_U32 tailDropDumpBmp
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueDumpAll);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum));

    rc = internal_cpssDxChPortTxQueueDumpAll(devNum, tailDropDumpBmp);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxBufferStatisticsEnableSet function
* @endinternal
*
* @brief  Enable/disable port buffer statistics.
*
* @note   APPLICABLE DEVICES:      Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X.
*
* @param[in] devNum                   - device number
* @param[in] enPortStat               - enable port statistics
*                                       GT_FALSE - disable port buffer statistics.
*                                       GT_TRUE  - enable port buffer statistics.
* @param[in] enQueueStat              - enable port queue statistics
*                                       GT_FALSE - disable port queue buffer statistics.
*                                       GT_TRUE  - enable port queue buffer statistics.
*
* @retval GT_OK                       - on success
* @retval GT_BAD_PARAM                - wrong value in any of the parameters
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxBufferStatisticsEnableSet
(
    IN  GT_U8                devNum,
    IN  GT_BOOL              enPortStat,
    IN  GT_BOOL              enQueueStat
)
{
    GT_U32      regAddr;
    GT_STATUS   st;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).global.portBufferStat;
    st = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1,
        BOOL2BIT_MAC(enPortStat));
    if(GT_OK != st)
    {
        return st;
    }

    regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).global.queueBufferStat;
    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 1,
        BOOL2BIT_MAC(enQueueStat));
}

/**
* @internal cpssDxChPortTxBufferStatisticsEnableSet function
* @endinternal
*
* @brief  Enable/disable port buffer statistics.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X;Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] enPortStat               - enable port statistics
*                                       GT_FALSE - disable port buffer statistics.
*                                       GT_TRUE  - enable port buffer statistics.
* @param[in] enQueueStat              - enable port queue statistics
*                                       GT_FALSE - disable port queue buffer statistics.
*                                       GT_TRUE  - enable port queue buffer statistics.
*
* @retval GT_OK                       - on success
* @retval GT_BAD_PARAM                - wrong value in any of the parameters
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
*/
GT_STATUS cpssDxChPortTxBufferStatisticsEnableSet
(
    IN  GT_U8                devNum,
    IN  GT_BOOL              enPortStat,
    IN  GT_BOOL              enQueueStat
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxBufferStatisticsEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enPortStat, enQueueStat));

    rc = internal_cpssDxChPortTxBufferStatisticsEnableSet(devNum, enPortStat, enQueueStat);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enPortStat, enQueueStat));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxBufferStatisticsEnableGet function
* @endinternal
*
* @brief  Get enable status of port buffer statistics.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X;Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in]  devNum                   - device number
*
* @param[out] enPortStatPtr            - (pointer to) enabled status of
*                                        port buffer statistics
* @param[out] enQueueStatPtr           - (pointer to) enabled status of
*                                        queue buffer statistics
*
* @retval GT_OK                        - on success
* @retval GT_BAD_PTR                   - on NULL pointer
* @retval GT_BAD_PARAM                 - wrong value in any of the parameters
* @retval GT_HW_ERROR                  - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE     - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxBufferStatisticsEnableGet
(
    IN  GT_U8                devNum,
    OUT GT_BOOL              *enPortStatPtr,
    OUT GT_BOOL              *enQueueStatPtr
)
{
    GT_U32  regAddr;
    GT_U32  regVal;
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    CPSS_NULL_PTR_CHECK_MAC(enPortStatPtr);
    CPSS_NULL_PTR_CHECK_MAC(enQueueStatPtr);

    regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).global.portBufferStat;
    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 1, &regVal);
    *enPortStatPtr = BIT2BOOL_MAC(regVal);
    if(GT_OK != rc)
    {
        return rc;
    }

    regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).global.queueBufferStat;
    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 1, &regVal);
    *enQueueStatPtr = BIT2BOOL_MAC(regVal);
    return rc;
}

/**
* @internal cpssDxChPortTxBufferStatisticsEnableGet function
* @endinternal
*
* @brief  Get enable status of port buffer statistics.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X;Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in]  devNum                   - device number
*
* @param[out] enPortStatPtr            - (pointer to) enabled status of
*                                        port buffer statistics
* @param[out] enQueueStatPtr           - (pointer to) enabled status of
*                                        queue buffer statistics
*
* @retval GT_OK                        - on success
* @retval GT_BAD_PTR                   - on NULL pointer
* @retval GT_BAD_PARAM                 - wrong value in any of the parameters
* @retval GT_HW_ERROR                  - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE     - on not applicable device
*/
GT_STATUS cpssDxChPortTxBufferStatisticsEnableGet
(
    IN  GT_U8                devNum,
    OUT GT_BOOL              *enPortStatPtr,
    OUT GT_BOOL              *enQueueStatPtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxBufferStatisticsEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enPortStatPtr, enQueueStatPtr));

    rc = internal_cpssDxChPortTxBufferStatisticsEnableGet(devNum, enPortStatPtr,
        enQueueStatPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enPortStatPtr, enQueueStatPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMaxBufferFillLevelSet function
* @endinternal
*
* @brief  Set max port buffer fill level per port.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X;Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] maxBuffFillLvl           - max buffer fill level (APPLICABLE RANGES: 0..0xFFFFF)
*
* @retval GT_OK                       - on success
* @retval GT_BAD_PTR                  - on NULL pointer
* @retval GT_BAD_PARAM                - wrong value in any of the parameters
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMaxBufferFillLevelSet
(
    IN  GT_U8                devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_U32               maxBuffFillLvl
)
{
    GT_U32  portTxq;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_DXCH_PORT_NUM_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, portTxq);
    PRV_CPSS_DXCH_CHECK_MAX_BUFFER_FILL_LVL_MAC(maxBuffFillLvl);

    return prvCpssDxChWriteTableEntryField(devNum,
        CPSS_DXCH_SIP5_25_TABLE_TAIL_DROP_PORT_MAX_BUFFER_FILL_LEVEL_E, portTxq,
        PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS, 0, 20, maxBuffFillLvl);
}

/**
* @internal cpssDxChPortTxMaxBufferFillLevelSet function
* @endinternal
*
* @brief  Set max port buffer fill level per port.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X;Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] maxBuffFillLvl           - max buffer fill level (APPLICABLE RANGES: 0..0xFFFFF)
*
* @retval GT_OK                       - on success
* @retval GT_BAD_PTR                  - on NULL pointer
* @retval GT_BAD_PARAM                - wrong value in any of the parameters
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
*/
GT_STATUS cpssDxChPortTxMaxBufferFillLevelSet
(
    IN  GT_U8                devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_U32               maxBuffFillLvl
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMaxBufferFillLevelSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, maxBuffFillLvl));

    rc = internal_cpssDxChPortTxMaxBufferFillLevelSet(devNum, portNum, maxBuffFillLvl);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, maxBuffFillLvl));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMaxBufferFillLevelGet function
* @endinternal
*
* @brief  Get max port buffer fill level per port.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X;Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*
* @param[out] maxBuffFillLvlPtr       - (pointer to)max buffer fill level
*
* @retval GT_OK                       - on success
* @retval GT_BAD_PTR                  - on NULL pointer
* @retval GT_BAD_PARAM                - wrong value in any of the parameters
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxMaxBufferFillLevelGet
(
    IN  GT_U8                devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    OUT GT_U32               *maxBuffFillLvlPtr
)
{
    GT_U32  portTxq;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, portTxq);
    CPSS_NULL_PTR_CHECK_MAC(maxBuffFillLvlPtr);

    return prvCpssDxChReadTableEntryField(devNum,
        CPSS_DXCH_SIP5_25_TABLE_TAIL_DROP_PORT_MAX_BUFFER_FILL_LEVEL_E,
        portTxq, PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
        0, 20, maxBuffFillLvlPtr);
}

/**
* @internal cpssDxChPortTxMaxBufferFillLevelGet function
* @endinternal
*
* @brief  Get max port buffer fill level per port.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X;Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*
* @param[out] maxBuffFillLvlPtr       - (pointer to)max buffer fill level
*
* @retval GT_OK                       - on success
* @retval GT_BAD_PTR                  - on NULL pointer
* @retval GT_BAD_PARAM                - wrong value in any of the parameters
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
*/
GT_STATUS cpssDxChPortTxMaxBufferFillLevelGet
(
    IN  GT_U8                devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    OUT GT_U32               *maxBuffFillLvlPtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMaxBufferFillLevelGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, maxBuffFillLvlPtr));

    rc = internal_cpssDxChPortTxMaxBufferFillLevelGet(devNum, portNum, maxBuffFillLvlPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, maxBuffFillLvlPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueMaxBufferFillLevelSet function
* @endinternal
*
* @brief  Set max port queue buffer fill level per port.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] tc                       - traffic class queue (0..7)
* @param[in] maxBuffFillLvl           - max buffer fill level (APPLICABLE RANGES: 0..0xFFFFF)
*
* @retval GT_OK                       - on success
* @retval GT_BAD_PTR                  - on NULL pointer
* @retval GT_BAD_PARAM                - wrong value in any of the parameters
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueMaxBufferFillLevelSet
(
    IN  GT_U8                devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_U8                tc,
    IN  GT_U32               maxBuffFillLvl
)
{
    GT_U32  portTxq;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, portTxq);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);
    PRV_CPSS_DXCH_CHECK_MAX_BUFFER_FILL_LVL_MAC(maxBuffFillLvl);

    return prvCpssDxChWriteTableEntryField(devNum,
        CPSS_DXCH_SIP5_25_TABLE_TAIL_DROP_QUEUE_MAX_BUFFER_FILL_LEVEL_E, portTxq * 8 + tc,
        PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS, 0, 20, maxBuffFillLvl);
}

/**
* @internal cpssDxChPortTxQueueMaxBufferFillLevelSet function
* @endinternal
*
* @brief  Set max port queue buffer fill level per port.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] tc                       -        traffic class queue (0..7)
* @param[in] maxBuffFillLvl           - max buffer fill level (APPLICABLE RANGES: 0..0xFFFFF)
*
* @retval GT_OK                       - on success
* @retval GT_BAD_PTR                  - on NULL pointer
* @retval GT_BAD_PARAM                - wrong value in any of the parameters
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueMaxBufferFillLevelSet
(
    IN  GT_U8                devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_U8                tc,
    IN  GT_U32               maxBuffFillLvl
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueMaxBufferFillLevelSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tc, maxBuffFillLvl));

    rc = internal_cpssDxChPortTxQueueMaxBufferFillLevelSet(devNum, portNum, tc, maxBuffFillLvl);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tc, maxBuffFillLvl));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueMaxBufferFillLevelGet function
* @endinternal
*
* @brief  Get max port queue buffer fill level per port.
*
* @note   APPLICABLE DEVICES:      Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] tc                       - traffic class queue (0..7)
*
* @param[out] maxBuffFillLvlPtr       - (pointer to)max buffer fill level
*
* @retval GT_OK                       - on success
* @retval GT_BAD_PTR                  - on NULL pointer
* @retval GT_BAD_PARAM                - wrong value in any of the parameters
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueMaxBufferFillLevelGet
(
    IN  GT_U8                devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_U8                tc,
    OUT GT_U32               *maxBuffFillLvlPtr
)
{
    GT_U32  portTxq;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    PRV_CPSS_DXCH_PORT_NUM_CHECK_AND_TXQ_PORT_GET_MAC(devNum, portNum, portTxq);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);
    CPSS_NULL_PTR_CHECK_MAC(maxBuffFillLvlPtr);

    return prvCpssDxChReadTableEntryField(devNum,
        CPSS_DXCH_SIP5_25_TABLE_TAIL_DROP_QUEUE_MAX_BUFFER_FILL_LEVEL_E,
        portTxq * 8 + tc,
        PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
        0, 20, maxBuffFillLvlPtr);
}

/**
* @internal cpssDxChPortTxQueueMaxBufferFillLevelGet function
* @endinternal
*
* @brief  Get max port queue buffer fill level per port.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; AC3X;Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] tc                       - traffic class queue (0..7)
*
* @param[out] maxBuffFillLvlPtr       - (pointer to)max buffer fill level
*
* @retval GT_OK                       - on success
* @retval GT_BAD_PTR                  - on NULL pointer
* @retval GT_BAD_PARAM                - wrong value in any of the parameters
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueMaxBufferFillLevelGet
(
    IN  GT_U8                devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_U8                tc,
    OUT GT_U32               *maxBuffFillLvlPtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueMaxBufferFillLevelGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tc, maxBuffFillLvlPtr));

    rc = internal_cpssDxChPortTxQueueMaxBufferFillLevelGet(devNum, portNum, tc, maxBuffFillLvlPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tc, maxBuffFillLvlPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal cpssDxChPortTxMcFifoPriorityAttributesSet function
* @endinternal
*
* @brief   Sets priority multicast attributes for specified MC FIFO.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] mcFifo                   - MC FIFO number (APPLICABLE RANGE: 0..1)
* @param[in] threshold                - threshold for acceptance of non-priority multicast frames
*                                   (APPLICABLE RANGE: 0..0xF)
* @param[in] minTc                    - minimum TC which is classified as priority multicast
*                                   (APPLICABLE RANGE: 0..7)
* @param[in] maxDp                    - maximum DP which is classified as priority multicast
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_OUT_OF_RANGE             - on data out of range
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
**/
static GT_STATUS internal_cpssDxChPortTxMcFifoPriorityAttributesSet
(
    IN GT_U8                devNum,
    IN GT_U32               mcFifo,
    IN GT_U32               threshold,
    IN GT_U8                minTc,
    IN CPSS_DP_LEVEL_ENT    maxDp
)
{
    GT_U32      regData = 0;      /* register HW data */
    GT_U32      thresholdNumOfBits;/* number of bits for 'threshold' */
    GT_STATUS   rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        thresholdNumOfBits = 7;
    }
    else
    {
        thresholdNumOfBits = 4;
    }

    /* Check fields */
    CPSS_PARAM_CHECK_MAX_MAC(mcFifo, BIT_1);
    CPSS_DATA_CHECK_MAX_MAC(threshold, (1<<thresholdNumOfBits));
    CPSS_DATA_CHECK_MAX_MAC(minTc, BIT_3);
    PRV_CPSS_DXCH3_COS_CHECK_DP_MAC(maxDp);

    rc = prvCpssHwPpReadRegister(devNum,
             PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).MCFIFO.MCFIFOConfigs.priorityMulticast,
             &regData);
    if(rc != GT_OK)
    {
        return rc;
    }

    if (mcFifo == 0)
    {
        U32_SET_FIELD_MAC(regData,  0                         , thresholdNumOfBits , threshold);
        U32_SET_FIELD_MAC(regData,  2*thresholdNumOfBits      , 3                  , minTc    );
        U32_SET_FIELD_MAC(regData,  2*thresholdNumOfBits+2*3  , 2                  , maxDp    );
    }
    else
    {
        U32_SET_FIELD_MAC(regData,  thresholdNumOfBits        , thresholdNumOfBits , threshold);
        U32_SET_FIELD_MAC(regData,  2*thresholdNumOfBits+3    , 3                  , minTc    );
        U32_SET_FIELD_MAC(regData,  2*thresholdNumOfBits+2*3+2, 2                  , maxDp    );
    }

    return prvCpssHwPpWriteRegister(devNum,
        PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).MCFIFO.MCFIFOConfigs.priorityMulticast,
        regData);
}

/**
* @internal cpssDxChPortTxMcFifoPriorityAttributesSet function
* @endinternal
*
* @brief   Sets priority multicast attributes for specified MC FIFO.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] mcFifo                   - MC FIFO number (APPLICABLE RANGE: 0..1)
* @param[in] threshold                - threshold for acceptance of non-priority multicast frames
*                                   (APPLICABLE RANGE: 0..0xF)
* @param[in] minTc                    - minimum TC which is classified as priority multicast
*                                   (APPLICABLE RANGE: 0..7)
* @param[in] maxDp                    - maximum DP which is classified as priority multicast
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_OUT_OF_RANGE             - on data out of range
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
**/
GT_STATUS cpssDxChPortTxMcFifoPriorityAttributesSet
(
    IN GT_U8                devNum,
    IN GT_U32               mcFifo,
    IN GT_U32               threshold,
    IN GT_U8                minTc,
    IN CPSS_DP_LEVEL_ENT    maxDp
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcFifoPriorityAttributesSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mcFifo, threshold, minTc, maxDp));

    rc = internal_cpssDxChPortTxMcFifoPriorityAttributesSet(devNum, mcFifo, threshold, minTc, maxDp);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mcFifo, threshold, minTc, maxDp));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxMcFifoPriorityAttributesGet function
* @endinternal
*
* @brief   Gets priority multicast attributes for specified MC FIFO.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] mcFifo                   - MC FIFO number (APPLICABLE RANGE: 0..1)
* @param[in] thresholdPtr             - (pointer to) threshold for acceptance of non-priority multicast frames
* @param[out] minTcPtr                - (pointer to) minimum TC which is classified as priority multicast
* @param[out] maxDpPtr                - (pointer to) maximum DP which is classified as priority multicast
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
static GT_STATUS internal_cpssDxChPortTxMcFifoPriorityAttributesGet
(
    IN  GT_U8               devNum,
    IN  GT_U32              mcFifo,
    OUT GT_U32              *thresholdPtr,
    OUT GT_U8               *minTcPtr,
    OUT CPSS_DP_LEVEL_ENT   *maxDpPtr
)
{
    GT_U32      regData;    /* register HW data */
    GT_U32      thresholdNumOfBits;/* number of bits for 'threshold' */
    GT_STATUS   rc;         /* return code */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    /* Check field */
    CPSS_PARAM_CHECK_MAX_MAC(mcFifo, BIT_1);
    /* Check pointers */
    CPSS_NULL_PTR_CHECK_MAC(thresholdPtr);
    CPSS_NULL_PTR_CHECK_MAC(minTcPtr);
    CPSS_NULL_PTR_CHECK_MAC(maxDpPtr);

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        thresholdNumOfBits = 7;
    }
    else
    {
        thresholdNumOfBits = 4;
    }

    rc = prvCpssHwPpReadRegister(devNum,
        PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).MCFIFO.MCFIFOConfigs.priorityMulticast,
        &regData);
    if(rc != GT_OK)
    {
        return rc;
    }

    if (mcFifo == 0)
    {
        *thresholdPtr = U32_GET_FIELD_MAC(regData,  0                         , thresholdNumOfBits );
        *minTcPtr     = U32_GET_FIELD_MAC(regData,  2*thresholdNumOfBits      , 3                  );
        *maxDpPtr     = U32_GET_FIELD_MAC(regData,  2*thresholdNumOfBits+2*3  , 2                  );
    }
    else
    {
        *thresholdPtr = U32_GET_FIELD_MAC(regData,  thresholdNumOfBits        , thresholdNumOfBits );
        *minTcPtr     = U32_GET_FIELD_MAC(regData,  2*thresholdNumOfBits+3    , 3                  );
        *maxDpPtr     = U32_GET_FIELD_MAC(regData,  2*thresholdNumOfBits+2*3+2, 2                  );
    }

    return rc;
}

/**
* @internal cpssDxChPortTxMcFifoPriorityAttributesGet function
* @endinternal
*
* @brief   Gets priority multicast attributes for specified MC FIFO.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] mcFifo                   - MC FIFO number (APPLICABLE RANGE: 0..1)
* @param[in] thresholdPtr             - (pointer to) threshold for acceptance of non-priority multicast frames
* @param[out] minTcPtr                - (pointer to) minimum TC which is classified as priority multicast
* @param[out] maxDpPtr                - (pointer to) maximum DP which is classified as priority multicast
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
GT_STATUS cpssDxChPortTxMcFifoPriorityAttributesGet
(
    IN  GT_U8               devNum,
    IN  GT_U32              mcFifo,
    OUT GT_U32              *thresholdPtr,
    OUT GT_U8               *minTcPtr,
    OUT CPSS_DP_LEVEL_ENT   *maxDpPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcFifoPriorityAttributesGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mcFifo, thresholdPtr, minTcPtr, maxDpPtr));

    rc = internal_cpssDxChPortTxMcFifoPriorityAttributesGet(devNum, mcFifo, thresholdPtr, minTcPtr, maxDpPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mcFifo, thresholdPtr, minTcPtr, maxDpPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal  internal_cpssDxChPortTxMcastBuffersPriorityLimitSet function
* @endinternal
*
* @brief   Set the guaranteed buffers limit and ratio of the
*          free buffers for multicast packets.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - Device number
* @param[in] mcastPriority            - MC priority(low or high)
* @param[in] mcastGuaranteedLimit     - Guaranteed buffers limit
* @param[in] alpha                    - Ratio of the free buffers
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
static GT_STATUS internal_cpssDxChPortTxMcastBuffersPriorityLimitSet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_PORT_TX_DROP_MCAST_PRIORITY_ENT  mcastPriority,
    IN  GT_U32                                mcastGuaranteedLimit,
    IN  CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_ENT  alpha
)
{
    GT_U32      regData = 0;      /* register HW data */
    GT_U32      regAddr;         /* register address             */
    GT_U32      aplphaHwValue;   /*HW value corresponding to enum*/
    GT_U32      pbSize;
    GT_STATUS   rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    /* Check fields */
    CPSS_PARAM_CHECK_MAX_MAC(mcastGuaranteedLimit, BIT_20);

    rc = prvCpssSip6TxqUtilsPbSizeGet(devNum,&pbSize);
    if(rc!=GT_OK)
    {
       CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    if(mcastGuaranteedLimit >pbSize)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "mcastGuaranteedLimit [%d]is out of range[%d].\n",
            mcastGuaranteedLimit,pbSize);
    }

    PRV_CPSS_PORT_TX_TAIL_DROP_SIP6_ALPHA_TO_HW_CONVERT_MAC(alpha, aplphaHwValue);

    switch(mcastPriority)
    {
    case CPSS_PORT_TX_DROP_MCAST_PRIORITY_LOW_E:
        regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).mcTDConfigurationLowPrio;
        break;
    case CPSS_PORT_TX_DROP_MCAST_PRIORITY_HI_E:
        regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).mcTDConfigurationHighPrio;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    U32_SET_FIELD_MAC(regData,  0, 20, mcastGuaranteedLimit);
    U32_SET_FIELD_MAC(regData,  20, 4, aplphaHwValue);

    return prvCpssHwPpWriteRegister(devNum,regAddr,regData);

}

/**
* @internal  cpssDxChPortTxMcastBuffersPriorityLimitSet function
* @endinternal
*
* @brief   Set the guaranteed buffers limit and ratio of the
*          free buffers for multicast packets.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   -  Device number
* @param[in] mcastPriority            - MC priority(low or high)
* @param[in] mcastGuaranteedLimit     - Guaranteed buffers limit
* @param[in] alpha                    - Ratio of the free buffers
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
GT_STATUS cpssDxChPortTxMcastBuffersPriorityLimitSet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_PORT_TX_DROP_MCAST_PRIORITY_ENT  mcastPriority,
    IN  GT_U32                                mcastGuaranteedLimit,
    IN  CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_ENT  alpha
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcastBuffersPriorityLimitSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mcastPriority, mcastGuaranteedLimit, alpha));

    rc = internal_cpssDxChPortTxMcastBuffersPriorityLimitSet(devNum, mcastPriority, mcastGuaranteedLimit, alpha);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mcastPriority, mcastGuaranteedLimit, alpha));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal  cpssDxChPortTxMcastBuffersPriorityLimitGet function
* @endinternal
*
* @brief   Get the guaranteed buffers limit and ratio of the
*          free buffers for multicast packets.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                      - Device number
* @param[in] mcastPriority               - MC priority(low or high)
* @param[out] mcastGuaranteedLimitPtr    - (pointer to)Guaranteed buffers limit
* @param[out] alphaPtr                   - (pointer to)Ratio of the free buffers
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
static GT_STATUS internal_cpssDxChPortTxMcastBuffersPriorityLimitGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_PORT_TX_DROP_MCAST_PRIORITY_ENT  mcastPriority,
    OUT  GT_U32                               *mcastGuaranteedLimitPtr,
    OUT  CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_ENT  *alphaPtr
)
{
    GT_U32      regData = 0;      /* register HW data */
    GT_U32      regAddr;         /* register address             */
    GT_U32      aplphaHwValue;   /*HW value corresponding to enum*/


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E  | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    CPSS_NULL_PTR_CHECK_MAC(mcastGuaranteedLimitPtr);
    CPSS_NULL_PTR_CHECK_MAC(alphaPtr);

    switch(mcastPriority)
    {
    case CPSS_PORT_TX_DROP_MCAST_PRIORITY_LOW_E:
        regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).mcTDConfigurationLowPrio;
        break;
    case CPSS_PORT_TX_DROP_MCAST_PRIORITY_HI_E:
        regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).mcTDConfigurationHighPrio;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (prvCpssHwPpReadRegister(devNum, regAddr, &regData) != GT_OK)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

    *mcastGuaranteedLimitPtr = U32_GET_FIELD_MAC(regData,  0, 20);
    aplphaHwValue = U32_GET_FIELD_MAC(regData,  20, 4);

    PRV_CPSS_PORT_TX_TAIL_DROP_SIP6_HW_TO_ALPHA_CONVERT_MAC(*alphaPtr, aplphaHwValue);

    return GT_OK;

}

/**
* @internal  cpssDxChPortTxMcastBuffersPriorityLimitGet function
* @endinternal
*
* @brief   Get the guaranteed buffers limit and ratio of the
*          free buffers for multicast packets.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                      - Device number
* @param[in] mcastPriority               - MC priority(low or high)
* @param[out] mcastGuaranteedLimitPtr    - (pointer to)Guaranteed buffers limit
* @param[out] alphaPtr                   - (pointer to)Ratio of the free buffers
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
GT_STATUS cpssDxChPortTxMcastBuffersPriorityLimitGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_PORT_TX_DROP_MCAST_PRIORITY_ENT  mcastPriority,
    OUT  GT_U32                               *mcastGuaranteedLimitPtr,
    OUT  CPSS_PORT_TX_TAIL_DROP_DBA_ALPHA_ENT  *alphaPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcastBuffersPriorityLimitGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mcastPriority, mcastGuaranteedLimitPtr, alphaPtr));

    rc = internal_cpssDxChPortTxMcastBuffersPriorityLimitGet(devNum, mcastPriority, mcastGuaranteedLimitPtr, alphaPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mcastPriority, mcastGuaranteedLimitPtr, alphaPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}
/**
* @internal  internal_cpssDxChPortTxMcastAvailableBuffersSet function
* @endinternal
*
* @brief   Set  the total available buffers for Multicast dynamic buffers allocation
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                        - Device number
* @param[in] mcastAvailableBuffersNum      - Total available buffers for Multicast dynamic buffers allocation
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
static GT_STATUS internal_cpssDxChPortTxMcastAvailableBuffersSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  mcastAvailableBuffersNum
)
{
    GT_U32    pbSize;
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    /* Check fields */
    CPSS_PARAM_CHECK_MAX_MAC(mcastAvailableBuffersNum, BIT_20);

    rc = prvCpssSip6TxqUtilsPbSizeGet(devNum,&pbSize);
    if(rc!=GT_OK)
    {
       CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    if(mcastAvailableBuffersNum >pbSize)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "mcastAvailableBuffersNum [%d]is out of range[%d].\n",
            mcastAvailableBuffersNum,pbSize);
    }

    return prvCpssHwPpSetRegField(devNum, PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).mcAvailableBuffers,
        0, 20, mcastAvailableBuffersNum);
}

/**
* @internal  cpssDxChPortTxMcastAvailableBuffersSet function
* @endinternal
*
* @brief   Set  the total available buffers for Multicast dynamic buffers allocation
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                        - Device number
* @param[in] mcastAvailableBuffersNum      - Total available buffers for Multicast dynamic buffers allocation
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
GT_STATUS cpssDxChPortTxMcastAvailableBuffersSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  mcastAvailableBuffersNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId,cpssDxChPortTxMcastAvailableBuffersSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,mcastAvailableBuffersNum));

    rc = internal_cpssDxChPortTxMcastAvailableBuffersSet(devNum, mcastAvailableBuffersNum);

    CPSS_LOG_API_EXIT_MAC(funcId,rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId,rc,devNum,mcastAvailableBuffersNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal  internal_cpssDxChPortTxMcastAvailableBuffersGet function
* @endinternal
*
* @brief  Get the total available buffers for Multicast dynamic
*         buffers allocation
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                         - Device number
* @param[out] mcastAvailableBuffersNumPtr   - (pointer to)Total available buffers for Multicast
*                                              dynamic buffers allocation
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
static GT_STATUS internal_cpssDxChPortTxMcastAvailableBuffersGet
(
    IN  GT_U8   devNum,
    OUT  GT_U32  *mcastAvailableBuffersNumPtr
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    CPSS_NULL_PTR_CHECK_MAC(mcastAvailableBuffersNumPtr);

    return prvCpssHwPpGetRegField(devNum, PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).mcAvailableBuffers,
        0, 20, mcastAvailableBuffersNumPtr);
}
/**
* @internal  cpssDxChPortTxMcastAvailableBuffersGet function
* @endinternal
*
* @brief  Get the total available buffers for Multicast dynamic
*         buffers allocation
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                         - Device number
* @param[out] mcastAvailableBuffersNumPtr   - (pointer to)Total available buffers for Multicast
*                                              dynamic buffers allocation
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
GT_STATUS cpssDxChPortTxMcastAvailableBuffersGet
(
    IN  GT_U8   devNum,
    OUT  GT_U32  *mcastAvailableBuffersNumPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxMcastAvailableBuffersSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mcastAvailableBuffersNumPtr));

    rc = internal_cpssDxChPortTxMcastAvailableBuffersGet(devNum, mcastAvailableBuffersNumPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mcastAvailableBuffersNumPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}
/**
* @internal  internal_cpssDxChPortTxTcMapToSharedPoolSet function
* @endinternal
*
* @brief  Set tail drop mapping between TC to pool
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum       - Device number
* @param[in] tc           - Traffic class [0..7]
*@param[in]  poolNum      - Pool id[0..1]
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
static GT_STATUS internal_cpssDxChPortTxTcMapToSharedPoolSet
(
    IN  GT_U8                               devNum,
    IN  GT_U8                               tc,
    IN  GT_U32                              poolNum
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    /*tc and poolNum validated inside prvCpssFalconTxqPfccMapTcToPoolSet*/

    return prvCpssFalconTxqPfccMapTcToPoolSet(devNum,tc, poolNum,GT_TRUE);

}

/**
* @internal  cpssDxChPortTxTcMapToSharedPoolSet function
* @endinternal
*
* @brief  Set tail drop mapping between TC to pool
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum       - Device number
* @param[in] tc           - Traffic class [0..7]
* @param[in] poolNum      - Pool id[0..1]
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
GT_STATUS cpssDxChPortTxTcMapToSharedPoolSet
(
    IN  GT_U8                               devNum,
    IN  GT_U8                               tc,
    IN  GT_U32                              poolNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTcMapToSharedPoolSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tc, poolNum));

    rc = internal_cpssDxChPortTxTcMapToSharedPoolSet(devNum,tc, poolNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum,tc, poolNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal  internal_cpssDxChPortTxTcMapToSharedPoolGet function
* @endinternal
*
* @brief  Get tail drop mapping between TC to pool
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - Device number
* @param[in] tc                       - traffic class [0..7]
* @param[out]  poolNumPtr             - (Pointer to) Pool id[0..1]
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
static GT_STATUS internal_cpssDxChPortTxTcMapToSharedPoolGet
(
    IN  GT_U8                               devNum,
    IN  GT_U8                               tc,
    OUT GT_U32                              *poolNumPtr
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    CPSS_NULL_PTR_CHECK_MAC(poolNumPtr);

    /*tc  validated inside prvCpssFalconTxqPfccMapTcToPoolGet*/

    return prvCpssFalconTxqPfccMapTcToPoolGet(devNum, PRV_CPSS_DXCH_FALCON_TXQ_PFCC_MASTER_TILE_MAC,
        tc, GT_FALSE,poolNumPtr);
}

/**
* @internal  cpssDxChPortTxTcMapToSharedPoolGet function
* @endinternal
*
* @brief  Get tail drop mapping between TC to pool
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - Device number
* @param[in] tc                       - traffic class [0..7]
* @param[out]  poolNumPtr             - (Pointer to) Pool id[0..1]
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
GT_STATUS cpssDxChPortTxTcMapToSharedPoolGet
(
    IN  GT_U8                               devNum,
    IN  GT_U8                               tc,
    OUT GT_U32                              *poolNumPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTcMapToSharedPoolGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tc, poolNumPtr));

    rc = internal_cpssDxChPortTxTcMapToSharedPoolGet(devNum,tc, poolNumPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum,tc, poolNumPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal  internal_cpssDxChPortTxTailDropGlobalParamsSet function
* @endinternal
*
* @brief  Set amount of available buffers for dynamic buffers allocation
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - Device number
* @param[in] resourceMode             - Defines which free buffers resource is used to calculate
*                                       the dynamic buffer limit for the Port/Queue limits(global
*                                       or pool)
* @param[in]  globalAvailableBuffers   - Global amount of available buffers for dynamic buffers allocation
* @param[in]  pool0AvailableBuffers    - Pool 0 amount of available buffers for dynamic buffers allocation
* @param[in]  pool1AvailableBuffers    - Pool 1 amount of available buffers for dynamic buffers allocation
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
static GT_STATUS internal_cpssDxChPortTxTailDropGlobalParamsSet
(
    IN    GT_U8                                     devNum,
    IN    CPSS_PORT_TX_TAIL_DROP_RESOURCE_MODE_ENT  resourceMode,
    IN    GT_U32                                    globalAvailableBuffers,
    IN    GT_U32                                    pool0AvailableBuffers,
    IN    GT_U32                                    pool1AvailableBuffers
)
{
    GT_U32    regAddr, qcnAddr;
    GT_U32    regData = 0, qcnData;
    GT_STATUS rc;
    GT_U32    pbSize;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    if(((globalAvailableBuffers) >= BIT_20)||((pool0AvailableBuffers) >= BIT_20)||((pool1AvailableBuffers) >= BIT_20))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssSip6TxqUtilsPbSizeGet(devNum,&pbSize);
    if(rc!=GT_OK)
    {
       CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    if(globalAvailableBuffers >pbSize)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "globalAvailableBuffers [%d]is out of range[%d].\n",
            globalAvailableBuffers,pbSize);
    }

    if(pool0AvailableBuffers >pbSize)
    {
       CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "pool0AvailableBuffers [%d]is out of range[%d].\n",
            pool0AvailableBuffers,pbSize);
    }

    if(pool1AvailableBuffers >pbSize)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "pool1AvailableBuffers [%d]is out of range[%d].\n",
            pool1AvailableBuffers,pbSize);
    }

    regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).globalTailDropConfig;
    U32_SET_FIELD_MASKED_MAC(regData,0,20,globalAvailableBuffers);
    switch(resourceMode)
    {
    case CPSS_PORT_TX_TAIL_DROP_RESOURCE_MODE_GLOBAL_E:
        U32_SET_FIELD_MASKED_MAC(regData,20,1,0);
        qcnData = 0;
        break;
    case CPSS_PORT_TX_TAIL_DROP_RESOURCE_MODE_POOL_E:
        U32_SET_FIELD_MASKED_MAC(regData,20,1,1);
        qcnData = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        break;
    }

    /* Get the address of QCN global config */
    qcnAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).globalQcnConfig;

    /* Set the value for dynamic threshold Resource mode */
    rc = prvCpssHwPpSetRegField(devNum, qcnAddr, 20, 1, qcnData);
    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpWriteRegister(devNum,regAddr,regData);

    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    regData = 0;
    regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).tdPool0AvailableBuffers;

    U32_SET_FIELD_MASKED_MAC(regData,0,20,pool0AvailableBuffers);

    rc = prvCpssHwPpWriteRegister(devNum,regAddr,regData);

    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).tdPool1AvailableBuffers;

    U32_SET_FIELD_MASKED_MAC(regData,0,20,pool1AvailableBuffers);

    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpWriteRegister(devNum,regAddr,regData);

    return rc;
}

/**
* @internal  cpssDxChPortTxTailDropGlobalParamsSet function
* @endinternal
*
* @brief  Set amount of available buffers for dynamic buffers allocation
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - Device number
* @param[in] resourceMode             - Defines which free buffers resource is used to calculate
*                                       the dynamic buffer limit for the Port/Queue limits(global
*                                       or pool)
* @param[in]  globalAvailableBuffers   - Global amount of available buffers for dynamic buffers allocation
* @param[in]  pool0AvailableBuffers    - Pool 0 amount of available buffers for dynamic buffers allocation
* @param[in]  pool1AvailableBuffers    - Pool 1 amount of available buffers for dynamic buffers allocation
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
GT_STATUS cpssDxChPortTxTailDropGlobalParamsSet
(
    IN    GT_U8                                     devNum,
    IN    CPSS_PORT_TX_TAIL_DROP_RESOURCE_MODE_ENT  resourceMode,
    IN    GT_U32                                    globalAvailableBuffers,
    IN    GT_U32                                    pool0AvailableBuffers,
    IN    GT_U32                                    pool1AvailableBuffers
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropGlobalParamsSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, resourceMode, globalAvailableBuffers, pool0AvailableBuffers,pool1AvailableBuffers));

    rc = internal_cpssDxChPortTxTailDropGlobalParamsSet(devNum,resourceMode,globalAvailableBuffers, pool0AvailableBuffers,pool1AvailableBuffers);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum,resourceMode, pool0AvailableBuffers,pool1AvailableBuffers));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal  internal_cpssDxChPortTxTailDropGlobalParamsGet function
* @endinternal
*
* @brief  Get amount of available buffers for dynamic buffers allocation
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                      - Device number
* @param[out] resourceMode               -   Defines which free buffers resource is used to
*                                            calculate the dynamic buffer limit for the
*                                            Port/Queue limits(global or pool)
* @param[out]  globalAvailableBuffers    - (pointer to) Global amount of available buffers
*                                          for dynamic buffers allocation
*
* @param[out]  pool0AvailableBuffers     - (pointer to) Pool 0 amount of available buffers
*                                          for dynamic buffers allocation
* @param[out]  pool1AvailableBuffers     - (pointer to) Pool 1 amount of available buffers
*                                          for dynamic buffers allocation
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
static GT_STATUS internal_cpssDxChPortTxTailDropGlobalParamsGet
(
    IN    GT_U8                                      devNum,
    OUT   CPSS_PORT_TX_TAIL_DROP_RESOURCE_MODE_ENT  *resourceModePtr,
    OUT   GT_U32                                    *globalAvailableBuffersPtr,
    OUT   GT_U32                                    *pool0AvailableBuffersPtr,
    OUT   GT_U32                                    *pool1AvailableBuffersPtr
)
{
    GT_U32    regAddr;
    GT_U32    regData;
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).globalTailDropConfig;

    rc = prvCpssHwPpReadRegister(devNum,regAddr,&regData);
    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    *globalAvailableBuffersPtr = U32_GET_FIELD_MAC(regData,0,20);

    switch(regData&(1<<20))
    {
    case 0:
        *resourceModePtr = CPSS_PORT_TX_TAIL_DROP_RESOURCE_MODE_GLOBAL_E;
        break;
    default:
        *resourceModePtr = CPSS_PORT_TX_TAIL_DROP_RESOURCE_MODE_POOL_E;
        break;
    }

    regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).tdPool0AvailableBuffers;

    rc = prvCpssHwPpReadRegister(devNum,regAddr,&regData);

    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    *pool0AvailableBuffersPtr = U32_GET_FIELD_MAC(regData,0,20);

    regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).tdPool1AvailableBuffers;

    rc = prvCpssHwPpReadRegister(devNum,regAddr,&regData);

    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    *pool1AvailableBuffersPtr = U32_GET_FIELD_MAC(regData,0,20);

    return rc;
}

/**
* @internal  cpssDxChPortTxTailDropGlobalParamsGet function
* @endinternal
*
* @brief  Get amount of available buffers for dynamic buffers allocation
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                      - Device number
* @param[out] resourceMode               -   Defines which free buffers resource is used to
*                                            calculate the dynamic buffer limit for the
*                                            Port/Queue limits(global or pool)
* @param[out]  globalAvailableBuffers    - (pointer to) Global amount of available buffers
*                                          for dynamic buffers allocation
*
* @param[out]  pool0AvailableBuffers     - (pointer to) Pool 0 amount of available buffers
*                                          for dynamic buffers allocation
* @param[out]  pool1AvailableBuffers     - (pointer to) Pool 1 amount of available buffers
*                                          for dynamic buffers allocation
*
* @retval GT_OK                       - on success
* @retval GT_FAIL                     - on error
* @retval GT_HW_ERROR                 - on hardware error
* @retval GT_BAD_PARAM                - on invalid input parameters value
* @retval GT_NOT_APPLICABLE_DEVICE    - on not applicable device
* @retval GT_BAD_PTR                  - one of the parameters is NULL pointer
**/
GT_STATUS cpssDxChPortTxTailDropGlobalParamsGet
(
    IN    GT_U8                                      devNum,
    OUT   CPSS_PORT_TX_TAIL_DROP_RESOURCE_MODE_ENT  *resourceModePtr,
    OUT   GT_U32                                    *globalAvailableBuffersPtr,
    OUT   GT_U32                                    *pool0AvailableBuffersPtr,
    OUT   GT_U32                                    *pool1AvailableBuffersPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropGlobalParamsGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,resourceModePtr,globalAvailableBuffersPtr, pool0AvailableBuffersPtr,pool1AvailableBuffersPtr));

    rc = internal_cpssDxChPortTxTailDropGlobalParamsGet(devNum,resourceModePtr,globalAvailableBuffersPtr, pool0AvailableBuffersPtr,pool1AvailableBuffersPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum,resourceModePtr,globalAvailableBuffersPtr,pool0AvailableBuffersPtr,pool1AvailableBuffersPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChPortTx4TcTailDropWredProfileValidate  function
* @endinternal
*
* @brief   Check validity of CPSS_PORT_TAIL_DROP_WRED_PARAMS_STC
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] tailDropWredProfileParamsPtr -
*                                      the Drop Profile WRED Parameters to associate
*                                      with the Traffic Class in this Profile set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static  GT_STATUS prvCpssDxChPortTx4TcTailDropWredProfileValidate
(
    CPSS_PORT_TAIL_DROP_WRED_PARAMS_STC *tailDropWredDpProfileParamsPtr
)
{
    if(((tailDropWredDpProfileParamsPtr->guaranteedLimit) >= BIT_20))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if(((tailDropWredDpProfileParamsPtr->wredSize) >= BIT_20))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}
/**
* @internal internal_cpssDxChPortTx4TcTailDropWredProfileSet function
* @endinternal
*
* @brief   Set tail drop WRED profile  parameters  for particular TC.
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] trafficClass             - the Traffic Class associated with this set of
*                                      Drop Parameters (0..15).
* @param[in] tailDropWredProfileParamsPtr -
*                                      the Drop Profile WRED Parameters to associate
*                                      with the Traffic Class in this Profile set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTx4TcTailDropWredProfileSet
(
    IN    GT_U8                                   devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet,
    IN    GT_U8                                   trafficClass,
    IN    CPSS_PORT_TX_Q_TAIL_DROP_WRED_TC_DP_PROF_PARAMS_STC *tailDropWredProfileParamsPtr
)
{
    GT_STATUS rc;
    GT_U32 regData[4],probabilityInHwFormat,i;
    CPSS_PORT_TAIL_DROP_WRED_PARAMS_STC  *dpXWredAttributesPtr;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    CPSS_NULL_PTR_CHECK_MAC(tailDropWredProfileParamsPtr);
    PRV_CPSS_DXCH_COS_CHECK_4BIT_TC_MAC(devNum,trafficClass);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(profileSet, devNum);

    for(i=0;i<3;i++)
    {
        switch (i)
        {
        case 0:
            dpXWredAttributesPtr = &(tailDropWredProfileParamsPtr->dp0WredAttributes);
            break;
        case 1:
            dpXWredAttributesPtr = &(tailDropWredProfileParamsPtr->dp1WredAttributes);
            break;
        default:
            dpXWredAttributesPtr = &(tailDropWredProfileParamsPtr->dp2WredAttributes);
            break;
        }

        rc = prvCpssDxChPortTx4TcTailDropWredProfileValidate(dpXWredAttributesPtr);
        if(rc !=GT_OK)
        {
            return rc;
        }
    }

    for(i=0;i<3;i++)
    {
        switch (i)
        {
        case 0:
            dpXWredAttributesPtr = &(tailDropWredProfileParamsPtr->dp0WredAttributes);
            break;
        case 1:
            dpXWredAttributesPtr = &(tailDropWredProfileParamsPtr->dp1WredAttributes);
            break;
        default:
            dpXWredAttributesPtr = &(tailDropWredProfileParamsPtr->dp2WredAttributes);
            break;
        }

        rc = prvCpssDxChReadTableEntry(devNum,
            CPSS_DXCH_SIP6_TABLE_PREQ_QUEUE_DP_CONFIGURATIONS_E,
        (i<<8)+(profileSet<<4) + trafficClass,regData);
        if(rc !=GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }

        PRV_CPSS_PORT_TX_TAIL_DROP_PROBABILITY_TO_HW_CONVERT_MAC(dpXWredAttributesPtr->probability,probabilityInHwFormat);

        U32_SET_FIELD_IN_ENTRY_MAC(regData,4,20,dpXWredAttributesPtr->guaranteedLimit);
        U32_SET_FIELD_IN_ENTRY_MAC(regData,24,3,probabilityInHwFormat);
        U32_SET_FIELD_IN_ENTRY_MAC(regData,27,20,dpXWredAttributesPtr->wredSize);

        rc = prvCpssDxChWriteTableEntry(devNum,
            CPSS_DXCH_SIP6_TABLE_PREQ_QUEUE_DP_CONFIGURATIONS_E,
        (i<<8)+(profileSet<<4) + trafficClass,
            regData);

        if(rc !=GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTx4TcTailDropWredProfileSet function
* @endinternal
*
* @brief   Set tail drop WRED profile  parameters  for particular TC.
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] trafficClass             - the Traffic Class associated with this set of
*                                      Drop Parameters (0..15).
* @param[in] tailDropWredProfileParamsPtr -
*                                      the Drop Profile WRED Parameters to associate
*                                      with the Traffic Class in this Profile set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTx4TcTailDropWredProfileSet
(
    IN    GT_U8                                   devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet,
    IN    GT_U8                                   trafficClass,
    IN    CPSS_PORT_TX_Q_TAIL_DROP_WRED_TC_DP_PROF_PARAMS_STC *tailDropWredProfileParamsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTx4TcTailDropWredProfileSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,profileSet,trafficClass, tailDropWredProfileParamsPtr));

    rc = internal_cpssDxChPortTx4TcTailDropWredProfileSet(devNum,profileSet,trafficClass, tailDropWredProfileParamsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,profileSet,trafficClass, tailDropWredProfileParamsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTx4TcTailDropWredProfileGet function
* @endinternal
*
* @brief   Get tail drop WRED profile  parameters  for particular TC.
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] trafficClass             - the Traffic Class associated with this set of
*                                      Drop Parameters (0..15).
* @param[out] tailDropWredProfileParamsPtr -
*                                  (pointer to)the Drop Profile WRED Parameters to associate
*                                      with the Traffic Class in this Profile set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTx4TcTailDropWredProfileGet
(
    IN    GT_U8                                   devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet,
    IN    GT_U8                                   trafficClass,
    OUT    CPSS_PORT_TX_Q_TAIL_DROP_WRED_TC_DP_PROF_PARAMS_STC *tailDropWredProfileParamsPtr
)
{
    GT_STATUS rc;
    GT_U32 regData[4],probabilityInHwFormat,i;
    CPSS_PORT_TAIL_DROP_WRED_PARAMS_STC  *dpXWredAttributesPtr;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    CPSS_NULL_PTR_CHECK_MAC(tailDropWredProfileParamsPtr);
    PRV_CPSS_DXCH_COS_CHECK_4BIT_TC_MAC(devNum,trafficClass);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(profileSet, devNum);

    for(i=0;i<3;i++)
    {
        switch (i)
        {
        case 0:
            dpXWredAttributesPtr = &(tailDropWredProfileParamsPtr->dp0WredAttributes);
            break;
        case 1:
            dpXWredAttributesPtr = &(tailDropWredProfileParamsPtr->dp1WredAttributes);
            break;
        default:
            dpXWredAttributesPtr = &(tailDropWredProfileParamsPtr->dp2WredAttributes);
            break;
        }

        rc = prvCpssDxChReadTableEntry(devNum,
            CPSS_DXCH_SIP6_TABLE_PREQ_QUEUE_DP_CONFIGURATIONS_E,
        (i<<8)+(profileSet<<4) + trafficClass,regData);
        if(rc !=GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }

        U32_GET_FIELD_IN_ENTRY_MAC(regData,4,20,dpXWredAttributesPtr->guaranteedLimit);
        U32_GET_FIELD_IN_ENTRY_MAC(regData,24,3,probabilityInHwFormat);
        U32_GET_FIELD_IN_ENTRY_MAC(regData,27,20,dpXWredAttributesPtr->wredSize);

        PRV_CPSS_PORT_TX_HW_TO_TAIL_DROP_PROBABILITY_CONVERT_MAC(dpXWredAttributesPtr->probability,probabilityInHwFormat);

    }

    return GT_OK;
}
/**
* @internal cpssDxChPortTx4TcTailDropWredProfileGet function
* @endinternal
*
* @brief   Get tail drop WRED profile  parameters  for particular TC.
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
* @param[in] trafficClass             - the Traffic Class associated with this set of
*                                      Drop Parameters (0..15).
* @param[out] tailDropWredProfileParamsPtr -
*                                  (pointer to)the Drop Profile WRED Parameters to associate
*                                      with the Traffic Class in this Profile set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTx4TcTailDropWredProfileGet
(
    IN    GT_U8                                   devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet,
    IN    GT_U8                                   trafficClass,
    OUT   CPSS_PORT_TX_Q_TAIL_DROP_WRED_TC_DP_PROF_PARAMS_STC *tailDropWredProfileParamsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTx4TcTailDropWredProfileGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,profileSet,trafficClass, tailDropWredProfileParamsPtr));

    rc = internal_cpssDxChPortTx4TcTailDropWredProfileGet(devNum,profileSet,trafficClass, tailDropWredProfileParamsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,profileSet,trafficClass, tailDropWredProfileParamsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}
/**
* @internal internal_cpssDxChPortTxTailDropWredProfileSet function
* @endinternal
*
* @brief   Set tail drop port WRED profile  parameters .
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
*
* @param[in] tailDropWredProfileParamsPtr -
*                                      the Drop Profile WRED Parameters to associate
*                                      with the Traffic Class in this Profile set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropWredProfileSet
(
    IN    GT_U8                                                 devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT                     profileSet,
    IN    CPSS_PORT_TAIL_DROP_WRED_PARAMS_STC                   *tailDropWredProfileParamsPtr
)
{
    GT_STATUS rc;
    GT_U32 regData[4],probabilityInHwFormat;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    CPSS_NULL_PTR_CHECK_MAC(tailDropWredProfileParamsPtr);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(profileSet, devNum);


    rc = prvCpssDxChReadTableEntry(devNum,
        CPSS_DXCH_SIP6_TABLE_PREQ_PORT_PROFILE_E,
        profileSet,regData);
    if(rc !=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    PRV_CPSS_PORT_TX_TAIL_DROP_PROBABILITY_TO_HW_CONVERT_MAC(tailDropWredProfileParamsPtr->probability,probabilityInHwFormat);

    U32_SET_FIELD_IN_ENTRY_MAC(regData,4,20,tailDropWredProfileParamsPtr->guaranteedLimit);
    U32_SET_FIELD_IN_ENTRY_MAC(regData,24,3,probabilityInHwFormat);
    U32_SET_FIELD_IN_ENTRY_MAC(regData,27,20,tailDropWredProfileParamsPtr->wredSize);

    rc = prvCpssDxChWriteTableEntry(devNum,
        CPSS_DXCH_SIP6_TABLE_PREQ_PORT_PROFILE_E,
        profileSet,
        regData);

    if(rc !=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }


    return GT_OK;
}
/**
* @internal cpssDxChPortTxTailDropWredProfileSet function
* @endinternal
*
* @brief   Set tail drop port WRED profile  parameters .
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
*
* @param[in] tailDropWredProfileParamsPtr -
*                                      the Drop Profile WRED Parameters to associate
*                                      with the Traffic Class in this Profile set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropWredProfileSet
(
    IN    GT_U8                                   devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet,
    IN    CPSS_PORT_TAIL_DROP_WRED_PARAMS_STC     *tailDropWredProfileParamsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropWredProfileSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,profileSet,tailDropWredProfileParamsPtr));

    rc = internal_cpssDxChPortTxTailDropWredProfileSet(devNum,profileSet,tailDropWredProfileParamsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,profileSet,tailDropWredProfileParamsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropWredProfileGet function
* @endinternal
*
* @brief   Get tail drop port WRED profile  parameters .
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
*
* @param[out] tailDropWredProfileParamsPtr -
*                                      the Drop Profile WRED Parameters to associate
*                                      with the port  in this Profile set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropWredProfileGet
(
    IN    GT_U8                                                 devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT                     profileSet,
    IN    CPSS_PORT_TAIL_DROP_WRED_PARAMS_STC                   *tailDropWredProfileParamsPtr
)
{
    GT_STATUS rc;
    GT_U32 regData[4],probabilityInHwFormat;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    CPSS_NULL_PTR_CHECK_MAC(tailDropWredProfileParamsPtr);
    PRV_CPSS_DXCH_DROP_PROFILE_CHECK_MAC(profileSet, devNum);


    rc = prvCpssDxChReadTableEntry(devNum,
        CPSS_DXCH_SIP6_TABLE_PREQ_PORT_PROFILE_E,
        profileSet,regData);
    if(rc !=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    U32_GET_FIELD_IN_ENTRY_MAC(regData,4,20,tailDropWredProfileParamsPtr->guaranteedLimit);
    U32_GET_FIELD_IN_ENTRY_MAC(regData,24,3,probabilityInHwFormat);
    U32_GET_FIELD_IN_ENTRY_MAC(regData,27,20,tailDropWredProfileParamsPtr->wredSize);

    PRV_CPSS_PORT_TX_HW_TO_TAIL_DROP_PROBABILITY_CONVERT_MAC(tailDropWredProfileParamsPtr->probability,probabilityInHwFormat);

    return GT_OK;
}

/**
* @internal cpssDxChPortTxTailDropWredProfileGet function
* @endinternal
*
* @brief   Get tail drop port WRED profile  parameters .
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] profileSet               - the Profile Set in which the Traffic
*                                      Class Drop Parameters is associated.
*
* @param[out] tailDropWredProfileParamsPtr -
*                                      the Drop Profile WRED Parameters to associate
*                                      with the port  in this Profile set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropWredProfileGet
(
    IN    GT_U8                                   devNum,
    IN    CPSS_PORT_TX_DROP_PROFILE_SET_ENT       profileSet,
    OUT   CPSS_PORT_TAIL_DROP_WRED_PARAMS_STC     *tailDropWredProfileParamsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropWredProfileGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,profileSet,tailDropWredProfileParamsPtr));

    rc = internal_cpssDxChPortTxTailDropWredProfileGet(devNum,profileSet,tailDropWredProfileParamsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,profileSet,tailDropWredProfileParamsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropCommandSet function
* @endinternal
*
* @brief   Set tail drop command and drop code
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] cmd                      - Tail drop command
* @param[in] tailDropCode             - Tail drop code
*
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropCommandSet
(
    IN GT_U8                     devNum,
    IN CPSS_PACKET_CMD_ENT       cmd,
    IN CPSS_NET_RX_CPU_CODE_ENT  tailDropCode
)
{
    GT_U32    hwValue,regAddr,regData = 0;
    GT_STATUS rc;
    GT_U32    tailDropCodeInHwFormat;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_APPLICABLE_DEV_SIP6_ONLY_MAC(devNum);

    switch (cmd)
    {
    case CPSS_PACKET_CMD_FORWARD_E:
    case CPSS_PACKET_CMD_MIRROR_TO_CPU_E:
    case CPSS_PACKET_CMD_TRAP_TO_CPU_E:
    case CPSS_PACKET_CMD_DROP_HARD_E:
    case CPSS_PACKET_CMD_DROP_SOFT_E:
        break;
    default :
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "cmd is out of range %d",cmd);
        break;
    }

    if(tailDropCode<CPSS_NET_FIRST_USER_DEFINED_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE,
            "tailDropCode is out of range %d.Should be bigger  then %d",
            tailDropCode,CPSS_NET_FIRST_USER_DEFINED_E);
    }

    rc = prvCpssDxChNetIfCpuToDsaCode(tailDropCode, &tailDropCodeInHwFormat);
    if (rc != GT_OK)
    {
        return rc;
    }

    PRV_CPSS_CONVERT_PACKET_CMD_TO_HW_VAL_MAC(hwValue,cmd);

    regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).globalConfig;

    rc = prvCpssHwPpReadRegister(devNum,regAddr,&regData);

    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    U32_SET_FIELD_MAC(regData, 0, 3,hwValue);
    U32_SET_FIELD_MAC(regData, 3, 8,tailDropCodeInHwFormat);

    rc = prvCpssHwPpWriteRegister(devNum,regAddr,regData);

    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}
/**
* @internal cpssDxChPortTxTailDropCommandSet function
* @endinternal
*
* @brief   Set tail drop command and drop code
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] cmd                      - Tail drop command
* @param[in] tailDropCode             - Tail drop code
*
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropCommandSet
(
    IN GT_U8                     devNum,
    IN CPSS_PACKET_CMD_ENT       cmd,
    IN CPSS_NET_RX_CPU_CODE_ENT  tailDropCode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropCommandSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,cmd,tailDropCode));

    rc = internal_cpssDxChPortTxTailDropCommandSet(devNum,cmd,tailDropCode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,cmd,tailDropCode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxTailDropCommandGet function
* @endinternal
*
* @brief   Set tail drop command and drop code
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[out] cmdPtr                  - (pointer to)Tail drop command
* @param[out] tailDropCodePtr         - (pointer to)Tail drop code
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxTailDropCommandGet
(
    IN  GT_U8                     devNum,
    OUT CPSS_PACKET_CMD_ENT       *cmdPtr,
    OUT CPSS_NET_RX_CPU_CODE_ENT  *tailDropCodePtr
)
{
    GT_U32 regAddr,regData = 0;
    GT_U32 value = 0;
    GT_STATUS rc;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_APPLICABLE_DEV_SIP6_ONLY_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(cmdPtr);
    CPSS_NULL_PTR_CHECK_MAC(tailDropCodePtr);

    regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).globalConfig;

    rc = prvCpssHwPpReadRegister(devNum,regAddr,&regData);

    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    PRV_CPSS_CONVERT_HW_VAL_TO_PACKET_CMD_MAC(*cmdPtr,regData&0x7);

    value = U32_GET_FIELD_MAC(regData, 3, 8);

    rc = prvCpssDxChNetIfDsaToCpuCode((PRV_CPSS_DXCH_NET_DSA_TAG_CPU_CODE_ENT)value,
                                      tailDropCodePtr);
    if (rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/**
* @internal cpssDxChPortTxTailDropCommandGet function
* @endinternal
*
* @brief   Set tail drop command and drop code
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[out] cmdPtr                  - (pointer to)Tail drop command
* @param[out] tailDropCodePtr         - (pointer to)Tail drop code
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxTailDropCommandGet
(
    IN  GT_U8                     devNum,
    OUT CPSS_PACKET_CMD_ENT       *cmdPtr,
    OUT CPSS_NET_RX_CPU_CODE_ENT  *tailDropCodePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxTailDropCommandGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,cmdPtr,tailDropCodePtr));

    rc = internal_cpssDxChPortTxTailDropCommandGet(devNum,cmdPtr,tailDropCodePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,cmdPtr,tailDropCodePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxQMinimalRateEnableSet function
* @endinternal
*
* @brief                Enable/Disable commited rate of transmitted traffic from a specified Traffic
*                           Class Queue and specified port of specified device.
*                           When commited rate is exceeded the queue is scheduled in the lowest priority
*
* @note   APPLICABLE DEVICES:          Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..15)
* @param[in] enable                   -   GT_TRUE,  commited rate enabled  on this traffic queue
*                                                           GT_FALSE,  commited rate  on this traffic queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQMinimalRateEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8     tcQueue,
    IN  GT_BOOL   enable
)
{

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_APPLICABLE_DEV_SIP6_ONLY_MAC(devNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);

    return prvCpssFalconTxqUtilsMinimalBwEnableSet(devNum,portNum,tcQueue,enable);
}

/**
* @internal cpssDxChPortTxQMinimalRateEnableSet function
* @endinternal
*
* @brief                Enable/Disable commited rate of transmitted traffic from a specified Traffic
*                           Class Queue and specified port of specified device.
*                           When commited rate is exceeded the queue is scheduled in the lowest priority
*
* @note   APPLICABLE DEVICES:          Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..15)
* @param[in] enable                   -   GT_TRUE,  commited rate enabled  on this traffic queue
*                                                           GT_FALSE,  commited rate  on this traffic queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQMinimalRateEnableSet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8                       tcQueue,
    IN  GT_BOOL                     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQMinimalRateEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, enable));

    rc = internal_cpssDxChPortTxQMinimalRateEnableSet(devNum, portNum, tcQueue, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQMinimalRateEnableGet function
* @endinternal
*
* @brief               Get Enable/Disable commited rate of transmitted traffic from a specified Traffic
*                           Class Queue and specified port of specified device.
*                           When commited rate is exceeded the queue is scheduled in the lowest priority
*
* @note   APPLICABLE DEVICES:          Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..15)
* @param[out] enablePtr                  (pointer to)GT_TRUE,  commited rate enabled  on this traffic queue
*                                                           GT_FALSE,  commited rate  on this traffic queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/

static GT_STATUS internal_cpssDxChPortTxQMinimalRateEnableGet
(
    IN  GT_U8                devNum,
    IN  GT_PHYSICAL_PORT_NUM portNum,
    IN  GT_U8                tcQueue,
    OUT  GT_BOOL             *enablePtr
)
{

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_APPLICABLE_DEV_SIP6_ONLY_MAC(devNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);

    return prvCpssFalconTxqUtilsMinimalBwEnableGet(devNum,portNum,tcQueue,enablePtr);
}
/**
* @internal cpssDxChPortTxQMinimalRateEnableGet function
* @endinternal
*
* @brief               Get Enable/Disable commited rate of transmitted traffic from a specified Traffic
*                           Class Queue and specified port of specified device.
*                           When commited rate is exceeded the queue is scheduled in the lowest priority
*
* @note   APPLICABLE DEVICES:          Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..15)
* @param[out] enablePtr                  (pointer to)GT_TRUE,  commited rate enabled  on this traffic queue
*                                                           GT_FALSE,  commited rate  on this traffic queue
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQMinimalRateEnableGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8                       tcQueue,
    OUT  GT_BOOL                    *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQMinimalRateEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, enablePtr));

    rc = internal_cpssDxChPortTxQMinimalRateEnableGet(devNum, portNum, tcQueue, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxQMinimalRateSet function
* @endinternal
*
* @brief               Set commited rate of transmitted traffic from a specified Traffic
*                           Class Queue and specified port of specified device.
*                           When commited rate is exceeded the queue is scheduled in the lowest priority.
*
* @note   APPLICABLE DEVICES:          Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..15)
* @param[in] burstSize                - burst size in units of 4K bytes
*                                                           (max value is 1023 which results in  approximate 4M burst size)
* @param[in,out] maxRatePtr        Requested Rate in Kbps
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQMinimalRateSet
(
    IN    GT_U8                       devNum,
    IN    GT_PHYSICAL_PORT_NUM        portNum,
    IN    GT_U8                       tcQueue,
    IN    GT_U16                      burstSize,
    INOUT GT_U32                      *maxRatePtr
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_APPLICABLE_DEV_SIP6_ONLY_MAC(devNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    CPSS_NULL_PTR_CHECK_MAC(maxRatePtr);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);

    return prvCpssFalconTxqUtilsShapingParametersSet(devNum, portNum, tcQueue,GT_TRUE,PRV_QUEUE_SHAPING_ACTION_PRIORITY_DOWNGRADE_ENT,
                                           burstSize, maxRatePtr);
}

/**
* @internal cpssDxChPortTxQMinimalRateSet function
* @endinternal
*
* @brief               Set commited rate of transmitted traffic from a specified Traffic
*                           Class Queue and specified port of specified device.
*                           When commited rate is exceeded the queue is scheduled in the lowest priority.
*
* @note   APPLICABLE DEVICES:          Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..15)
* @param[in] burstSize                - burst size in units of 4K bytes
*                                                           (max value is 1023 which results in  approximate 4M burst size)
* @param[in,out] maxRatePtr        Requested Rate in Kbps
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQMinimalRateSet
(
    IN    GT_U8                       devNum,
    IN    GT_PHYSICAL_PORT_NUM        portNum,
    IN    GT_U8                       tcQueue,
    IN    GT_U16                      burstSize,
    INOUT GT_U32                      *maxRatePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQMinimalRateSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, burstSize,maxRatePtr));

    rc = internal_cpssDxChPortTxQMinimalRateSet(devNum, portNum, tcQueue, burstSize,maxRatePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, burstSize,maxRatePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}
/**
* @internal internal_cpssDxChPortTxQMinimalRateGet function
* @endinternal
*
* @brief               Get commited rate of transmitted traffic from a specified Traffic
*                           Class Queue and specified port of specified device.
*                           When commited rate is exceeded the queue is scheduled in the lowest priority.
*
* @note   APPLICABLE DEVICES:          Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..15)
* @param[out] burstSize                - burst size in units of 4K bytes
*                                                           (max value is 1023 which results in  approximate 4M burst size)
* @param[out] maxRatePtr        Requested Rate in Kbps
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQMinimalRateGet
(
    IN    GT_U8                       devNum,
    IN    GT_PHYSICAL_PORT_NUM        portNum,
    IN    GT_U8                       tcQueue,
    OUT    GT_U16                     *burstSizePtr,
    OUT   GT_U32                      *maxRatePtr
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_APPLICABLE_DEV_SIP6_ONLY_MAC(devNum);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    CPSS_NULL_PTR_CHECK_MAC(maxRatePtr);
    CPSS_NULL_PTR_CHECK_MAC(burstSizePtr);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);

    return prvCpssFalconTxqUtilsShapingParametersGet(devNum, portNum, tcQueue,GT_TRUE,PRV_QUEUE_SHAPING_ACTION_PRIORITY_DOWNGRADE_ENT,
                                           burstSizePtr, maxRatePtr);
}
/**
* @internal cpssDxChPortTxQMinimalRateGet function
* @endinternal
*
* @brief               Get commited rate of transmitted traffic from a specified Traffic
*                           Class Queue and specified port of specified device.
*                           When commited rate is exceeded the queue is scheduled in the lowest priority.
*
* @note   APPLICABLE DEVICES:          Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this port (0..15)
* @param[out] burstSize                - burst size in units of 4K bytes
*                                                           (max value is 1023 which results in  approximate 4M burst size)
* @param[out] maxRatePtr        Requested Rate in Kbps
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQMinimalRateGet
(
    IN    GT_U8                       devNum,
    IN    GT_PHYSICAL_PORT_NUM        portNum,
    IN    GT_U8                       tcQueue,
    OUT   GT_U16                     *burstSizePtr,
    OUT   GT_U32                      *maxRatePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQMinimalRateGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, tcQueue, burstSizePtr,maxRatePtr));

    rc = internal_cpssDxChPortTxQMinimalRateGet(devNum, portNum, tcQueue, burstSizePtr,maxRatePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, tcQueue, burstSizePtr,maxRatePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}



/**
* @internal internal_cpssDxChPortTxQueueLowLatencyModeEnableSet  function
* @endinternal
*
* @brief   Enable/disble low latency mode on queue.
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
* @param[in] enable                   - GT_TRUE,  enable queue  low latency mode,
*                                      GT_FALSE, disable queue  low latency mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE - in case of enabling low latency mode on port  that already
*                                                contain latency queue.
*/
static GT_STATUS internal_cpssDxChPortTxQueueLowLatencyModeEnableSet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8                       tcQueue,
    IN  GT_BOOL                     enable
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);

    return prvCpssFalconTxqUtilsLowLatencySet(devNum,portNum,tcQueue,enable);
}

/**
* @internal cpssDxChPortTxQueueLowLatencyModeEnableSet  function
* @endinternal
*
* @brief   Enable/disble low latency mode on queue.
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
* @param[in] enable                   - GT_TRUE,  enable queue  low latency mode,
*                                      GT_FALSE, disable queue  low latency mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE - in case of enabling low latency mode on port  that already
*                                                contain latency queue.
*/
GT_STATUS cpssDxChPortTxQueueLowLatencyModeEnableSet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8                       tcQueue,
    IN  GT_BOOL                     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId,cpssDxChPortTxQueueLowLatencyModeEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,portNum,tcQueue,enable));

    rc = internal_cpssDxChPortTxQueueLowLatencyModeEnableSet(devNum,portNum,tcQueue,enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,portNum,tcQueue,enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}




/**
* @internal internal_cpssDxChPortTxQueueLowLatencyModeEnableGet  function
* @endinternal
*
* @brief   Get enable/disble low latency mode on queue.
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
* @param[out] enablePtr                  -(pointer to)GT_TRUE,  enable queue  low latency mode,
*                                                           GT_FALSE, disable queue  low latency mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueLowLatencyModeEnableGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8                       tcQueue,
    OUT  GT_BOOL                     *enablePtr
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);
    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);

    return prvCpssFalconTxqUtilsLowLatencyGet(devNum,portNum,tcQueue,enablePtr);
}

/**
* @internal cpssDxChPortTxQueueLowLatencyModeEnableGet  function
* @endinternal
*
* @brief   Get enable/disble low latency mode on queue.
*
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
* @param[out] enablePtr                  -(pointer to)GT_TRUE,  enable queue  low latency mode,
*                                      GT_FALSE, disable queue  low latency mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueLowLatencyModeEnableGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8                       tcQueue,
    OUT  GT_BOOL                     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueLowLatencyModeEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,portNum,tcQueue,enablePtr));

    rc = internal_cpssDxChPortTxQueueLowLatencyModeEnableGet(devNum,portNum,tcQueue,enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,portNum,tcQueue,enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}
/*******************************************************************
* @internal cpssDxChPortTxQueueOptimizedThroughputEnableGet  function
* @endinternal
*
* @brief    Get enable/disable throughput optimization for port/queue .
*           In case queue uses very low  fraction of the port BW , setting optimized throughput  helps
*           other higher rate queues to take over the excess BW
*           Note that throughput optimization may cause latency degradation.
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X;Harrier; Ironman.

* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X;Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
* @param[out] enable                   -(pointer to) GT_TRUE,  enable  optimized throughput mode,
*                                                         GT_FALSE, disable optimized throughput mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueOptimizedThroughputEnableGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8                       tcQueue,
    OUT  GT_BOOL                     *enablePtr
)
{

    GT_STATUS                     rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);


    rc = prvCpssSip6TxQUtilsOptimizedThroughputEnableGet(devNum,portNum,tcQueue,enablePtr);
    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @internal cpssDxChPortTxQueueOptimizedThroughputEnableGet  function
* @endinternal
*
* @brief    Get enable/disable throughput optimization for port/queue .
*           In case queue uses very low  fraction of the port BW , setting optimized throughput  helps
*           other higher rate queues to take over the excess BW
*           Note that throughput optimization may cause latency degradation.
* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X;Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
* @param[out] enable                   -(pointer to) GT_TRUE,  enable  optimized throughput mode,
*                                                         GT_FALSE, disable optimized throughput mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueOptimizedThroughputEnableGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8                       tcQueue,
    OUT  GT_BOOL                     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueOptimizedThroughputEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,portNum,tcQueue,enablePtr));

    rc = internal_cpssDxChPortTxQueueOptimizedThroughputEnableGet(devNum,portNum,tcQueue,enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,portNum,tcQueue,enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueOptimizedThroughputEnableSet  function
* @endinternal
*
* @brief    Enable/disable throughput optimization for port/queue .
*           In case queue uses very low  fraction of the port BW , setting optimized throughput  helps
*           other higher rate queues to take over the excess BW
*           Note that throughput optimization may cause latency degradation.

* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X;Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
* @param[in] enable                   - GT_TRUE,  enable  optimized throughput mode,
*                                                         GT_FALSE, disable optimized throughput mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueOptimizedThroughputEnableSet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8                       tcQueue,
    IN  GT_BOOL                     enable
)
{
    GT_U32                        portMacMap; /* number of mac mapped to this physical port */
    CPSS_PORT_SPEED_ENT          *portSpeedPtr; /* speed configured on port now */
    GT_STATUS                     rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E |
        CPSS_AC3X_E | CPSS_ALDRIN2_E);

    PRV_CPSS_DXCH_COS_CHECK_8BIT_TC_MAC(devNum,tcQueue);
    PRV_CPSS_DXCH_SIP_6_QUEUE_OFFSET_VALIDATE_MAC(devNum,portNum,tcQueue);

    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_MAC_NUM_GET_MAC(devNum,portNum, portMacMap);
    portSpeedPtr = &(PRV_CPSS_DXCH_PORT_SPEED_MAC(devNum, portMacMap));

    rc = prvCpssSip6TxQUtilsOptimizedThroughputEnableSet(devNum,portNum,tcQueue,enable);
    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    return prvCpssDxChTxqSetPortSdqThresholds(devNum,portNum,*portSpeedPtr);
}

/**
* @internal cpssDxChPortTxQueueOptimizedThroughputEnableSet  function
* @endinternal
*
* @brief    Enable/disable throughput optimization for port/queue .
*           In case queue uses very low  fraction of the port BW , setting optimized throughput  helps
*           other higher rate queues to take over the excess BW
*           Note that throughput optimization may cause latency degradation.

* @note   APPLICABLE DEVICES:       Falcon; AC5P; AC5X;Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - physical or CPU port number
* @param[in] tcQueue                  - traffic class queue on this device (0..7)
* @param[in] enable                   - GT_TRUE,  enable  optimized throughput mode,
*                                                         GT_FALSE, disable optimized throughput mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/

GT_STATUS cpssDxChPortTxQueueOptimizedThroughputEnableSet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  GT_U8                       tcQueue,
    IN  GT_BOOL                     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueOptimizedThroughputEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,portNum,tcQueue,enable));

    rc = internal_cpssDxChPortTxQueueOptimizedThroughputEnableSet(devNum,portNum,tcQueue,enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,portNum,tcQueue,enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxQueueOffsetWidthSet  function
* @endinternal
*
* @brief  Set  queue offset width (4bit or 8 bit) (used for flexible mapping of queue based on VLAN)
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - physical device number
* @param[in] queueOffsetWidth                  -queue offset width (4bit or 8 bit)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/

static GT_STATUS internal_cpssDxChPortTxQueueOffsetWidthSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PORT_TXQ_OFFSET_WIDTH_ENT     queueOffsetWidth
)
{
   GT_U32 regAddr;
   GT_U32 hwData =0;
   GT_STATUS rc;

   PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
   PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
      CPSS_ALDRIN_E | CPSS_BOBCAT3_E |CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E);

   PRV_CPSS_PORT_TX_QUEUE_OFFSET_WIDTH_TO_HW_CONVERT_MAC(queueOffsetWidth,hwData);

   regAddr= PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->EREP.configurations.erepGlobalConfigs2;

   rc = prvCpssHwPpSetRegField(devNum,regAddr,31,1,hwData);
   if(rc!=GT_OK)
   {
     CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
   }

   regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).globalConfig;

   return prvCpssHwPpSetRegField(devNum,regAddr,25,1,hwData);
}
/**
* @internal cpssDxChPortTxQueueOffsetWidthSet  function
* @endinternal
*
* @brief  Set  queue offset width (4bit or 8 bit) (used for flexible mapping of queue based on VLAN)
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - physical device number
* @param[in] queueOffsetWidth                  -queue offset width (4bit or 8 bit)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueOffsetWidthSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PORT_TXQ_OFFSET_WIDTH_ENT     queueOffsetWidth
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueOffsetWidthSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,queueOffsetWidth));

    rc = internal_cpssDxChPortTxQueueOffsetWidthSet(devNum,queueOffsetWidth);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,queueOffsetWidth));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueOffsetWidthGet  function
* @endinternal
*
* @brief  Get  queue offset width (4bit or 8 bit) (used for flexible mapping of queue based on VLAN)
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - physical device number
* @param[out] queueOffsetWidthPtr  -(pointer to)queue offset width (4bit or 8 bit)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueOffsetWidthGet
(
    IN  GT_U8                                   devNum,
    OUT CPSS_DXCH_PORT_TXQ_OFFSET_WIDTH_ENT     *queueOffsetWidthPtr
)
{
   GT_U32 regAddr,data;
   GT_STATUS      rc;

   PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
   PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
      CPSS_ALDRIN_E | CPSS_BOBCAT3_E |CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E);

   CPSS_NULL_PTR_CHECK_MAC(queueOffsetWidthPtr);

   regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).globalConfig;

   rc =  prvCpssHwPpGetRegField(devNum,regAddr,25,1,&data);
   if(rc!=GT_OK)
   {
     CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
   }

   PRV_CPSS_PORT_HW_TO_TX_QUEUE_OFFSET_WIDTH_CONVERT_MAC(data,*queueOffsetWidthPtr);

   return GT_OK;
}
/**
* @internal  cpssDxChPortTxQueueOffsetWidthGet  function
* @endinternal
*
* @brief  Get  queue offset width (4bit or 8 bit) (used for flexible mapping of queue based on VLAN)
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - physical device number
* @param[out] queueOffsetWidthPtr  -(pointer to)queue offset width (4bit or 8 bit)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueOffsetWidthGet
(
    IN  GT_U8                                   devNum,
    OUT  CPSS_DXCH_PORT_TXQ_OFFSET_WIDTH_ENT     *queueOffsetWidthPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueOffsetWidthGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,queueOffsetWidthPtr));

    rc = internal_cpssDxChPortTxQueueOffsetWidthGet(devNum,queueOffsetWidthPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,queueOffsetWidthPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}
/**
* @internal internal_cpssDxChPortTxQueueOffsetModeSet function
* @endinternal
*
* @brief Set queue offset mode to specific port.
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - physical or CPU port number
*                                      (APPLICABLE RANGES: 0..0xFFF)
* @param[in] offset mode                   - queue offset mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueOffsetModeSet
(
    IN  GT_U8            devNum,
    IN  GT_PORT_NUM      portNum,
    IN  CPSS_DXCH_QUEUE_OFFSET_MODE_ENT  offsetMode
)
{

   GT_U32 data;

   PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
   PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
      CPSS_ALDRIN_E | CPSS_BOBCAT3_E |CPSS_AC3X_E | CPSS_ALDRIN2_E|CPSS_FALCON_E|CPSS_AC5X_E | CPSS_AC5P_E);

    PRV_CPSS_PORT_QUEUE_OFFSET_MODE_TO_HW_CONVERT_MAC(offsetMode,data);

    return  prvCpssDxChWriteTableEntryField(devNum,
                       CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_QAG_TARGET_PORT_MAPPER_E,
                       portNum,
                       PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,15,2,
                       data);
}

/**
* @internal cpssDxChPortTxQueueOffsetModeSet function
* @endinternal
*
* @brief Set queue offset mode to specific port.
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[in] offset mode                   - queue offset mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueOffsetModeSet
(
    IN  GT_U8            devNum,
    IN  GT_PORT_NUM      portNum,
    IN  CPSS_DXCH_QUEUE_OFFSET_MODE_ENT  offsetMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueOffsetModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, offsetMode));

    rc = internal_cpssDxChPortTxQueueOffsetModeSet(devNum, portNum, offsetMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, offsetMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueOffsetModeGet function
* @endinternal
*
* @brief Get queue offset mode to specific port.
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - physical or CPU port number
*                                      (APPLICABLE RANGES: 0..0xFFF)
* @param[out] offsetModePtr                  - (pointer to) queue offset mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueOffsetModeGet
(
    IN  GT_U8            devNum,
    IN  GT_PORT_NUM      portNum,
    OUT CPSS_DXCH_QUEUE_OFFSET_MODE_ENT  *offsetModePtr
)
{   GT_U32 data;
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
      CPSS_ALDRIN_E | CPSS_BOBCAT3_E |CPSS_AC3X_E | CPSS_ALDRIN2_E|CPSS_FALCON_E|CPSS_AC5X_E | CPSS_AC5P_E);

    CPSS_NULL_PTR_CHECK_MAC(offsetModePtr);

    rc = prvCpssDxChReadTableEntryField(devNum,
                       CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_QAG_TARGET_PORT_MAPPER_E,
                       portNum,
                       PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,15,2,
                       &data);
    if(rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    PRV_CPSS_PORT_HW_TO_CPSS_DXCH_QUEUE_OFFSET_MODE_CONVERT_MAC(data,*offsetModePtr);

    return GT_OK;
}

/**
* @internal cpssDxChPortTxQueueOffsetModeGet function
* @endinternal
*
* @brief Get queue offset mode to specific port.
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - physical or CPU port number
*
* @param[out] offsetModePtr                   - (pointer to) queue offset mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueOffsetModeGet
(
    IN  GT_U8            devNum,
    IN  GT_PORT_NUM      portNum,
    OUT CPSS_DXCH_QUEUE_OFFSET_MODE_ENT  *offsetModePtr
)

{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueOffsetModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, offsetModePtr));

    rc = internal_cpssDxChPortTxQueueOffsetModeGet(devNum, portNum, offsetModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, offsetModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal cpssDxChPortTxQueueOffsetMapSet  function
* @endinternal
*
* @brief   Map  8 bit queue offset to 4   bit queue offset(used for tail drop)
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - physical device number
* @param[in] queueOffset8bit                  - 8 bit queue offset,
* @param[in] queueOffset4bit                  - 4 bit queue offset,

*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueOffsetMapSet
(
    IN  GT_U8            devNum,
    IN  GT_U32           queueOffset8bit,
    IN  GT_U32           queueOffset4bit
)
{
   GT_U32 regAddr;

   PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
   PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
      CPSS_ALDRIN_E | CPSS_BOBCAT3_E |CPSS_AC3X_E | CPSS_ALDRIN2_E|CPSS_FALCON_E|CPSS_AC5X_E | CPSS_AC5P_E);

   if(queueOffset4bit>=(1<<4))
   {
      CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "4 bit offset value [%d] is too big",queueOffset4bit);
   }

   if(queueOffset8bit>=(1<<8))
   {
      CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "8 bit offset value [%d] is too big",queueOffset8bit);
   }

   regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).queueOffsetProfileMapping[queueOffset8bit>>3];

   return prvCpssHwPpSetRegField(devNum,regAddr,(queueOffset8bit&0x7)<<2,4,queueOffset4bit);

}

/**
* @internal cpssDxChPortTxQueueOffsetMapSet  function
* @endinternal
*
* @brief   Map  8 bit queue offset to 4   bit queue offset(used for tail drop)
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - physical device number
* @param[in] queueOffset8bit                  - 8 bit queue offset,
* @param[in] queueOffset4bit                  - 4 bit queue offset,

*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueOffsetMapSet
(
    IN  GT_U8            devNum,
    IN  GT_U32           queueOffset8bit,
    IN  GT_U32           queueOffset4bit
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueOffsetMapSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,queueOffset8bit,queueOffset4bit));

    rc = internal_cpssDxChPortTxQueueOffsetMapSet(devNum,queueOffset8bit,queueOffset4bit);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,queueOffset8bit,queueOffset4bit));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxQueueOffsetMapGet  function
* @endinternal
*
* @brief   Get  8 bit queue offset mapping  to 4   bit queue offset(used for tail drop)
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - physical device number
* @param[in] queueOffset8bit                  - 8 bit queue offset,
* @param[out] queueOffset4bitPtr           - (pointer to)4 bit queue offset,

*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxQueueOffsetMapGet
(
    IN  GT_U8            devNum,
    IN  GT_U32           queueOffset8bit,
    OUT GT_U32           *queueOffset4bitPtr
)
{
   GT_U32 regAddr;

   PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
   PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
      CPSS_ALDRIN_E | CPSS_BOBCAT3_E |CPSS_AC3X_E | CPSS_ALDRIN2_E|CPSS_FALCON_E|CPSS_AC5X_E | CPSS_AC5P_E);

   CPSS_NULL_PTR_CHECK_MAC(queueOffset4bitPtr);

   if(queueOffset8bit>=(1<<8))
   {
      CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "8 bit offset value [%d] is too big",queueOffset8bit);
   }

   regAddr = PRV_DXCH_REG1_UNIT_PREQ_MAC(devNum).queueOffsetProfileMapping[queueOffset8bit>>3];

   return prvCpssHwPpGetRegField(devNum,regAddr,(queueOffset8bit&0x7)<<2,4,queueOffset4bitPtr);

}


/**
* @internal cpssDxChPortTxQueueOffsetMapGet  function
* @endinternal
*
* @brief   Get  8 bit queue offset mapping  to 4   bit queue offset(used for tail drop)
*
* @note   APPLICABLE DEVICES: Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X.
*
* @param[in] devNum                   - physical device number
* @param[in] queueOffset8bit                  - 8 bit queue offset,
* @param[out] queueOffset4bitPtr           - (pointer to)4 bit queue offset,

*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxQueueOffsetMapGet
(
    IN  GT_U8            devNum,
    IN  GT_U32           queueOffset8bit,
    OUT GT_U32           *queueOffset4bitPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxQueueOffsetMapGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,queueOffset8bit,queueOffset4bitPtr));

    rc = internal_cpssDxChPortTxQueueOffsetMapGet(devNum,queueOffset8bit,queueOffset4bitPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,queueOffset8bit,queueOffset4bitPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}
/**
* @internal cpssDxChPortTxPriorityGroupSet function
* @endinternal
*
* @brief   Assign priority group to physical port. This group will be considered in case of port level scheduling.
*   The priority group will be used in scheduling  between ports that are mapped to the same DMA.
*
* @note   APPLICABLE DEVICES:Falcon; AC5P; AC5X;Harrier; Ironman,
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*
* @param[in] devNum                   - physical device number
* @param[in] portNum  -         physical port number
* @param[in] priorityGroup -    scheduling priority group [Applicable range : 0..7]

*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxPriorityGroupSet
(
    IN  GT_U8                             devNum,
    IN  GT_PHYSICAL_PORT_NUM              portNum,
    IN  GT_U32                            priorityGroup
)
{
   PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
   PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
      CPSS_ALDRIN_E | CPSS_BOBCAT3_E |CPSS_AC3X_E | CPSS_ALDRIN2_E);

  PRV_CPSS_DXCH_COS_CHECK_TC_MAC(priorityGroup);

  return prvCpssDxChTxqRemotePortPrioritySet(devNum,portNum,priorityGroup);
}


/**
* @internal cpssDxChPortTxPriorityGroupSet function
* @endinternal
*
* @brief   Assign priority group to physical port. This group will be considered in case of port level scheduling.
*   The priority group will be used in scheduling  between ports that are mapped to the same DMA.
*
* @note   APPLICABLE DEVICES:Falcon; AC5P; AC5X;Harrier; Ironman,
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*
* @param[in] devNum                   - physical device number
* @param[in] portNum  -         physical port number
* @param[in] priorityGroup -    scheduling priority group [Applicable range : 0..7]

*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxPriorityGroupSet
(
    IN  GT_U8                             devNum,
    IN  GT_PHYSICAL_PORT_NUM              portNum,
    IN  GT_U32                            priorityGroup
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxPriorityGroupSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,portNum,priorityGroup));

    rc = internal_cpssDxChPortTxPriorityGroupSet(devNum,portNum,priorityGroup);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,portNum,priorityGroup));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPortTxPriorityGroupGet function
* @endinternal
*
* @brief   Get assigned  priority group to physical port. This group will be considered in case of port level scheduling.
*   The priority group will be used in scheduling  between ports that are mapped to the same DMA.
*
* @note   APPLICABLE DEVICES:Falcon; AC5P; AC5X;Harrier; Ironman,
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*
* @param[in] devNum                   - physical device number
* @param[in] portNum  -         physical port number
* @param[out] priorityGroupPtr -    (pointer to)scheduling priority group [Applicable range : 0..7]

*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxPriorityGroupGet
(
    IN  GT_U8                             devNum,
    IN  GT_PHYSICAL_PORT_NUM              portNum,
    OUT  GT_U32                           *priorityGroupPtr
)
{
  PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
  PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
      CPSS_ALDRIN_E | CPSS_BOBCAT3_E |CPSS_AC3X_E | CPSS_ALDRIN2_E);

  CPSS_NULL_PTR_CHECK_MAC(priorityGroupPtr);

  return prvCpssDxChTxqRemotePortPriorityGet(devNum,portNum,priorityGroupPtr);
}


/**
* @internal cpssDxChPortTxPriorityGroupGet function
* @endinternal
*
* @brief   Get assigned  priority group to physical port. This group will be considered in case of port level scheduling.
*   The priority group will be used in scheduling  between ports that are mapped to the same DMA.
*
* @note   APPLICABLE DEVICES:Falcon; AC5P; AC5X;Harrier; Ironman,
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*
* @param[in] devNum                   - physical device number
* @param[in] portNum  -         physical port number
* @param[out] priorityGroupPtr -    (pointer to)scheduling priority group [Applicable range : 0..7]

*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxPriorityGroupGet
(
    IN  GT_U8                             devNum,
    IN  GT_PHYSICAL_PORT_NUM              portNum,
    OUT  GT_U32                           *priorityGroupPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxPriorityGroupGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,portNum,priorityGroupPtr));

    rc = internal_cpssDxChPortTxPriorityGroupGet(devNum,portNum,priorityGroupPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,portNum,priorityGroupPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxWrrWeightSet  function
* @endinternal
*
* @brief   Assign WRR weight to physical port. This weight will be considered in case of port level DWRR.
*   The  weight will be  used in DWRR between ports that are mapped to the same DMA.
*
* @note   APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*
* @param[in] devNum                - physical device number
* @param[in] portNum               - physical port number
* @param[in] wrrWeight             - wrr weight[Applicable range: 1..256]
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/

static GT_STATUS internal_cpssDxChPortTxWrrWeightSet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    IN  GT_U32                                  wrrWeight
)
{

  return prvCpssDxChTxqRemotePortDwrrWeightSet(devNum,portNum,wrrWeight);
}

/**
* @internal cpssDxChPortTxWrrWeightSet  function
* @endinternal
*
* @brief   Assign WRR weight to physical port. This weight will be considered in case of port level DWRR.
*   The  weight will be  used in DWRR between ports that are mapped to the same DMA.
*
* @note   APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*
* @param[in] devNum                - physical device number
* @param[in] portNum               - physical port number
* @param[in] wrrWeight             - wrr weight[Applicable range: 1..256]
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/

GT_STATUS cpssDxChPortTxWrrWeightSet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    IN  GT_U32                                  wrrWeight
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxWrrWeightSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,portNum,wrrWeight));

    rc = internal_cpssDxChPortTxWrrWeightSet(devNum,portNum,wrrWeight);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,portNum,wrrWeight));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPortTxWrrWeightGet  function
* @endinternal
*
* @brief   Get assigned  WRR weight to physical port. This weight will be considered in case of port level DWRR.
*   The  weight will be  used in DWRR between ports that are mapped to the same DMA.
*
* @note   APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*
* @param[in] devNum                  - physical device number
* @param[in] portNum                 - physical port number
* @param[out] wrrWeightPtr           - (pointer to) wrr weight[Applicable range : 1..256]
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPortTxWrrWeightGet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    OUT  GT_U32                                 *wrrWeightPtr
)
{
  CPSS_NULL_PTR_CHECK_MAC(wrrWeightPtr);

  return prvCpssDxChTxqRemotePortDwrrWeightGet(devNum,portNum,wrrWeightPtr);
}
/**
* @internal cpssDxChPortTxWrrWeightGet  function
* @endinternal
*
* @brief   Get assigned  WRR weight to physical port. This weight will be considered in case of port level DWRR.
*   The  weight will be  used in DWRR between ports that are mapped to the same DMA.
*
* @note   APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*
* @param[in] devNum                  - physical device number
* @param[in] portNum                 - physical port number
* @param[out] wrrWeightPtr           - (pointer to) wrr weight[Applicable range : 1..256]
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number, profile set or
*                                       traffic class
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPortTxWrrWeightGet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    OUT  GT_U32                                 *wrrWeightPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPortTxWrrWeightGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId,devNum,portNum,wrrWeightPtr));

    rc = internal_cpssDxChPortTxWrrWeightGet(devNum,portNum,wrrWeightPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc,devNum,portNum,wrrWeightPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}




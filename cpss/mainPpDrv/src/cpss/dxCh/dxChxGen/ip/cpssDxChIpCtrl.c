/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
*/
/**
********************************************************************************
* @file cpssDxChIpCtrl.c
*
* @brief the CPSS DXCH Ip HW control registers APIs
*
* @version   98
********************************************************************************
*/
#define CPSS_LOG_IN_MODULE_ENABLE

#include <stdlib.h>

#include <cpss/common/cpssTypes.h>
#include <cpss/generic/cpssCommonDefs.h>
#include <cpss/dxCh/dxChxGen/ip/cpssDxChIpTypes.h>
#include <cpss/dxCh/dxChxGen/ip/cpssDxChIpCtrl.h>
#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChInfo.h>
#include <cpss/generic/bridge/private/prvCpssBrgVlanTypes.h>
#include <cpss/dxCh/dxChxGen/cos/private/prvCpssDxChCoS.h>
#include <cpss/dxCh/dxChxGen/ip/private/prvCpssDxChIpLog.h>
#include <cpss/generic/private/prvCpssCommonDefs.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDb.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDbInterface.h>

#define CHEETAH_MAX_MAC_QOS_ENTRIES_CNS   128
#define EARC_MAX_MAC_QOS_ENTRIES_CNS      _1K

#define NUMBER_OF_EXCEPTION_DATABASES_CNS   5


/* max num of global mac sa entries */
#define PRV_CPSS_MAC_SA_MAX_NUM_CNS 255

/* check route mac sa index */
#define PRV_CPSS_GLOBAL_MAC_SA_INDEX_CHECK_MAC(index)    \
    if(index > PRV_CPSS_MAC_SA_MAX_NUM_CNS)   \
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "index[%d] more than [%d]", \
            index,PRV_CPSS_MAC_SA_MAX_NUM_CNS)

/* offset shift for IPVX glocal control 0 register for sip6.10 */
#define PRV_CPSS_SIP6_10_ROUTER_GLB_REG_OFFSET_SHIFT(devNum)\
            PRV_CPSS_SIP_6_10_CHECK_MAC(devNum) ? 1 : 0

/* Struct to hold exception command data */
typedef struct CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STCT
{
    CPSS_DXCH_IP_EXCEPTION_TYPE_ENT excptType;
    CPSS_IP_PROTOCOL_STACK_ENT      protocolStack;
    CPSS_PACKET_CMD_ENT             cmd;
    GT_U8                           registerIndex;
    GT_U32                          offset;
    GT_U32                          length;
    GT_U32                          value;
} CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC;
/*******************************************************************************/
/* static array that holds registers, offsets and values for each         */
/* exception and each command supported; the structure is:                */
/* <family type> <exception> <protocol> <cmd> <registerIndex> <offset> <length> <value> */


/* exceptions entries that apply only to DxCh Devices supporting
   Policy based routing using PCL action as next hop */
static const CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC dxChPbrOnlyExceptions[] =
{
    /* IPv4 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_ROUTE_E,            6,16,1,0},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,16,1,1},
    /* IPv6 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_ROUTE_E,            6,17,1,0},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,17,1,1},
    /* IPv4 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            6,20,1,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,20,1,1},
    /* IPv6 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_E,            6,21,1,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,21,1,1},
    /* IPv4 Unicast TTL Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_ROUTE_E,            6,18,1,0},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,18,1,1},
    /* IPv6 Unicast Hop Limit (TTL) Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_ROUTE_E,            6,19,1,0},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,19,1,1}
};


/* exceptions entries that apply to DxCh2 and above devices */
static const CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC dxCh2AndAboveExceptions[] =
{
    /* IPv4 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,15,3,2},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_HARD_E,        0,15,3,3},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        0,15,3,4},
    /* IPv6 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,15,3,2},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_HARD_E,        1,15,3,3},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        1,15,3,4},
    /* IPv4 Multicast Header Error command */
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,12,3,2},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_HARD_E,        0,12,3,3},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        0,12,3,4},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,12,3,5},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_BRIDGE_E ,          0,12,3,6},
    /* IPv6 Multicast Header Error command */
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,12,3,2},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_HARD_E,        1,12,3,3},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        1,12,3,4},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,12,3,5},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_BRIDGE_E,           1,12,3,6},
    /* IPv4 Unicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,27,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        0,27,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        0,27,3,4},
    /* IPv6 Unicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,27,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        1,27,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        1,27,3,4},
    /* IPv4 Multicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,24,3,2},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        0,24,3,3},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        0,24,3,4},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,24,3,5},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_E,           0,24,3,6},
    /* IPv6 Multicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,24,3,2},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        1,24,3,3},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        1,24,3,4},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,24,3,5},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_E,           1,24,3,6},
    /* IPv4 UC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,0,3,2},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        2,0,3,3},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        2,0,3,4},
    /* IPv6 UC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,0,3,2},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        3,0,3,3},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        3,0,3,4},
    /* IPv4 MC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,3,3,2},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        2,3,3,3},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        2,3,3,4},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,2,3,3,5},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_E ,          2,3,3,6},
    /* IPv6 MC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,3,3,2},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        3,3,3,3},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        3,3,3,4},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,3,3,3,5},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_E ,          3,3,3,6},
    /* IPv4 Unicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        4,3,1,1},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_NONE_E,             4,3,1,0},
    /* IPv6 Unicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        4,1,1,1},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_NONE_E,             4,1,1,0},
    /* IPv6 Unicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,3,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_HARD_E,        1,3,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        1,3,3,4},
    /* IPv6 Multicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,0,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_HARD_E,        1,0,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        1,0,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,0,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_E ,          1,0,3,6},
    /* IPv4 Multicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_E,           4,4,1,1},
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_NONE_E,             4,4,1,0},
    /* IPv6 Multicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_E,           4,2,1,1},
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_NONE_E,             4,2,1,0},
    /* IPv4 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,9,3,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 0,9,3,1},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,9,3,4},
    /* IPv6 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_E,            1,9,3,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 1,9,3,1},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_HARD_E,        1,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        1,9,3,4},
    /* IPv4 Multicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,6,3,0},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 0,6,3,1},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,6,3,2},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,6,3,3},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,6,3,4},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,6,3,5},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_E ,          0,6,3,6},
    /* IPv6 Multicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_E,            1,6,3,0},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 1,6,3,1},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,6,3,2},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_HARD_E,        1,6,3,3},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        1,6,3,4},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,6,3,5},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_BRIDGE_E,           1,6,3,6},
    /* IPv6 Unicast non-Hop-by-hop extension exception command */
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_E,            3,20,3,0},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 3,20,3,1},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,20,3,2},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_HARD_E,        3,20,3,3},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_SOFT_E,        3,20,3,4},
    /* IPv6 Multicast non-Hop-by-hop extension exception command */
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_E,            3,17,3,0},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 3,17,3,1},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,17,3,2},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_HARD_E,        3,17,3,3},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_SOFT_E,        3,17,3,4},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,3,17,3,5},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_BRIDGE_E,           3,17,3,6},
    /* IPv4 Unicast TLL Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,21,3,2},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_DROP_HARD_E,        0,21,3,3},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_DROP_SOFT_E,        0,21,3,4},
    /* IPv6 Unicast Hop Limit (TTL) Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,21,3,2},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_DROP_HARD_E,        1,21,3,3},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_DROP_SOFT_E,        1,21,3,4},
    /* IPv4 Unicast RPF Fail command */
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_DROP_HARD_E,        2,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_DROP_SOFT_E,        2,9,3,4},
    /* IPv6 Unicast RPF Fail command */
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_DROP_HARD_E,        3,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_DROP_SOFT_E,        3,9,3,4},
    /* IPv4 SIP/SA Fail command */
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,13,3,2},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_DROP_HARD_E,        2,13,3,3},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_DROP_SOFT_E,        2,13,3,4},
    /* IPv6 SIP/SA Fail command */
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,13,3,2},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_DROP_HARD_E,        3,13,3,3},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_DROP_SOFT_E,        3,13,3,4}
};

/* exceptions entries that apply to DxCh3 and above devices */
static const CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC dxCh3AndAboveExceptions[] =
{
    /* IPv4 Unicast MTU Exceeded for non "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,3,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,3,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,3,3,4},
    /* IPv4 Multicast MTU Exceeded for non "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,0,3,0},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,0,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,0,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,0,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,0,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_E ,          0,0,3,6},

    /* IPv4 Multicast MTU Exceeded (Same as "don't fragment" (DF) packets command) */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,0,3,0},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,0,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,0,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,0,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,0,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_E ,          0,0,3,6},

    /* IPv4 Unicast MTU Exceeded for "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,19,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        2,19,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        2,19,3,4},
    /* IPv4 Multicast MTU Exceeded for "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,16,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        2,16,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        2,16,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,2,16,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_E ,          2,16,3,6},
};

 /* exceptions entries that apply to Bobcat2, Caelum, Bobcat3 devices */
static const CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC eArchExceptions[] =
{
    /* IPv4 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,15,3,2},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_HARD_E,        0,15,3,3},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        0,15,3,4},
    /* IPv6 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,15,3,2},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_HARD_E,        1,15,3,3},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        1,15,3,4},
    /* IPv4 Multicast Header Error command */
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,12,3,2},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_HARD_E,        0,12,3,3},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        0,12,3,4},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,12,3,5},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_BRIDGE_E ,          0,12,3,6},
    /* IPv6 Multicast Header Error command */
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,12,3,2},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_HARD_E,        1,12,3,3},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        1,12,3,4},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,12,3,5},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_BRIDGE_E,           1,12,3,6},
    /* IPv4 Unicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,27,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        0,27,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        0,27,3,4},
    /* IPv6 Unicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,27,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        1,27,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        1,27,3,4},
    /* IPv4 Multicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,24,3,2},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        0,24,3,3},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        0,24,3,4},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,24,3,5},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_E,           0,24,3,6},
    /* IPv6 Multicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,24,3,2},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        1,24,3,3},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        1,24,3,4},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,24,3,5},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_E,           1,24,3,6},
    /* IPv4 UC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,0,3,2},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        2,0,3,3},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        2,0,3,4},
    /* IPv6 UC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,0,3,2},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        3,0,3,3},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        3,0,3,4},
    /* IPv4 MC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,3,3,2},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        2,3,3,3},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        2,3,3,4},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,2,3,3,5},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_E ,          2,3,3,6},
    /* IPv6 MC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,3,3,2},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        3,3,3,3},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        3,3,3,4},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,3,3,3,5},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_E ,          3,3,3,6},
    /* IPv4 Unicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_ROUTE_E,            4,21,3,0},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 4,21,3,1},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      4,21,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        4,21,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        4,21,3,4},
    /* IPv6 Unicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_ROUTE_E,            4,0,3,0},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 4,0,3,1},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      4,0,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_HARD_E,        4,0,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        4,0,3,4},
    /* IPv4 Unicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_ROUTE_E,            0,3,3,0},
    /*{CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 0,3,3,1},*/
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,3,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        0,3,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        0,3,3,4},
    /* IPv4 Multicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_ROUTE_E,            0,0,3,0},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,0,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        0,0,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        0,0,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,0,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_E,           0,0,3,6},
    /* IPv6 Unicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,3,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_HARD_E,        1,3,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        1,3,3,4},
    /* IPv6 Multicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,0,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_HARD_E,        1,0,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        1,0,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,0,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_E ,          1,0,3,6},
    /* IPv4 Multicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_E,           4,4,1,1},
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_NONE_E,             4,4,1,0},
    /* IPv6 Multicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_E,           4,3,1,1},
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_NONE_E,             4,3,1,0},
    /* IPv4 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,9,3,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 0,9,3,1},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,9,3,4},
    /* IPv6 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_E,            1,9,3,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 1,9,3,1},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_HARD_E,        1,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        1,9,3,4},
    /* IPv4 Multicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,6,3,0},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 0,6,3,1},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,6,3,2},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,6,3,3},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,6,3,4},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,6,3,5},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_E ,          0,6,3,6},
    /* IPv6 Multicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_E,            1,6,3,0},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 1,6,3,1},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,6,3,2},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_HARD_E,        1,6,3,3},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        1,6,3,4},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,6,3,5},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_BRIDGE_E,           1,6,3,6},
    /* IPv6 Unicast non-Hop-by-hop extension exception command */
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_E,            3,20,3,0},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 3,20,3,1},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,20,3,2},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_HARD_E,        3,20,3,3},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_SOFT_E,        3,20,3,4},
    /* IPv6 Multicast non-Hop-by-hop extension exception command */
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_E,            3,17,3,0},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 3,17,3,1},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,17,3,2},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_HARD_E,        3,17,3,3},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_SOFT_E,        3,17,3,4},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,3,17,3,5},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_BRIDGE_E,           3,17,3,6},
    /* IPv4 Unicast TLL Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,21,3,2},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_DROP_HARD_E,        0,21,3,3},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_DROP_SOFT_E,        0,21,3,4},
    /* IPv6 Unicast Hop Limit (TTL) Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,21,3,2},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_DROP_HARD_E,        1,21,3,3},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_DROP_SOFT_E,        1,21,3,4},
    /* IPv4 Unicast RPF Fail command */
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_DROP_HARD_E,        2,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_DROP_SOFT_E,        2,9,3,4},
    /* IPv6 Unicast RPF Fail command */
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_DROP_HARD_E,        3,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_DROP_SOFT_E,        3,9,3,4},
    /* IPv4 SIP/SA Fail command */
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,13,3,2},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_DROP_HARD_E,        2,13,3,3},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_DROP_SOFT_E,        2,13,3,4},
    /* IPv6 SIP/SA Fail command */
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,13,3,2},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_DROP_HARD_E,        3,13,3,3},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_DROP_SOFT_E,        3,13,3,4},
    /* IPv4 Unicast MTU Exceeded for non "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,3,3,0},
    /*{CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 0,3,3,1},*/
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,3,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,3,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,3,3,4},
    /* IPv4 Multicast MTU Exceeded for non "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,0,3,0},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,0,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,0,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,0,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,0,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_E ,          0,0,3,6},
    /* IPv4 Unicast MTU Exceeded for "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_ROUTE_E,            2,19,3,0},
    /*{CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 2,19,3,1},*/
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,19,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        2,19,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        2,19,3,4},
    /* IPv4 Multicast MTU Exceeded for "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_ROUTE_E,            2,16,3,0},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,16,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        2,16,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        2,16,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,2,16,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_E ,          2,16,3,6}
};

extern GT_STATUS prvCpssDxChPortTxReCalcShaperTokenBucketRate_rev1
(
    IN  GT_U8                                 devNum,
    IN  GT_PHYSICAL_PORT_NUM                  portNum,
    IN  GT_BOOL                               usePerTc,
    IN  CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC   *shaperConfigPtr,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT     shaperMode,
    IN  GT_U32                                tokenBucketRate,
    IN  GT_U32                                burstSize,
    IN  GT_BOOL                               isMllShaper,
    OUT GT_BOOL                               *slowRateEnPtr,
    OUT GT_U32                                *tbUpdateRatioPtr,
    OUT GT_U32                                *tokensPtr
);

extern GT_STATUS prvDxChPortTxCalcShaperTokenBucketRate_rev1
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC *shaperConfigPtr,
    IN    CPSS_PORT_TX_DROP_SHAPER_MODE_ENT     shaperMode,
    IN    GT_BOOL                 slowRateEn,
    IN    GT_U32                  tbUpdateRatio,
    IN    GT_U32                  tokenRefillValue,
    OUT   GT_U32                 *tokenBucketRatePtr

);

/**
* @internal internal_cpssDxChIpSpecialRouterTriggerEnable function
* @endinternal
*
* @brief   Sets the special router trigger enable modes for packets with bridge
*         command other then FORWARD or MIRROR.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] bridgeExceptionCmd       - the bridge exception command the packet arrived to
*                                      the router with.
* @param[in] enableRouterTrigger      - enable /disable router trigger.
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum or bridgeExceptionCmd
*/
static GT_STATUS internal_cpssDxChIpSpecialRouterTriggerEnable
(
    IN GT_U8                           devNum,
    IN CPSS_DXCH_IP_BRG_EXCP_CMD_ENT   bridgeExceptionCmd,
    IN GT_BOOL                         enableRouterTrigger
)
{
    GT_U32    regAddr;              /* register address                   */

    GT_STATUS rc;                   /* return code                        */
    GT_U32      value;      /* value to write */
    GT_U32      offset;     /* offset in the register */
    GT_U32      offsetShift;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    offsetShift = PRV_CPSS_SIP6_10_ROUTER_GLB_REG_OFFSET_SHIFT(devNum);

    /* Get address of register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }


    /* all bridgeExceptionCmd refer to the same register but in different offsets */
    /* find offset according to brgExcpCmd */


    switch (bridgeExceptionCmd)
    {
    case CPSS_DXCH_IP_BRG_UC_IPV4_TRAP_EXCP_CMD_E:
        offset = 26 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV6_TRAP_EXCP_CMD_E:
        offset = 24 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV4_SOFT_DROP_EXCP_CMD_E:
        offset = 22 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV6_SOFT_DROP_EXCP_CMD_E:
        offset = 20 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV4_TRAP_EXCP_CMD_E:
        offset = 25 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV6_TRAP_EXCP_CMD_E:
        offset = 23 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV4_SOFT_DROP_EXCP_CMD_E:
        offset = 21 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV6_SOFT_DROP_EXCP_CMD_E:
        offset = 19 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_ARP_TRAP_EXCP_CMD_E:
        offset = 28 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_ARP_SOFT_DROP_EXCP_CMD_E:
        offset = 27 + offsetShift;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* write enable value at the calculated offset */
    value = (enableRouterTrigger == GT_TRUE) ? 1:0;
    rc = prvCpssHwPpSetRegField(devNum,regAddr,offset,1,value);

    return rc;

}

/**
* @internal cpssDxChIpSpecialRouterTriggerEnable function
* @endinternal
*
* @brief   Sets the special router trigger enable modes for packets with bridge
*         command other then FORWARD or MIRROR.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] bridgeExceptionCmd       - the bridge exception command the packet arrived to
*                                      the router with.
* @param[in] enableRouterTrigger      - enable /disable router trigger.
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum or bridgeExceptionCmd
*/
GT_STATUS cpssDxChIpSpecialRouterTriggerEnable
(
    IN GT_U8                           devNum,
    IN CPSS_DXCH_IP_BRG_EXCP_CMD_ENT   bridgeExceptionCmd,
    IN GT_BOOL                         enableRouterTrigger
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpSpecialRouterTriggerEnable);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, bridgeExceptionCmd, enableRouterTrigger));

    rc = internal_cpssDxChIpSpecialRouterTriggerEnable(devNum, bridgeExceptionCmd, enableRouterTrigger);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, bridgeExceptionCmd, enableRouterTrigger));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpSpecialRouterTriggerEnableGet function
* @endinternal
*
* @brief   Gets the special router trigger enable modes for packets with bridge
*         command other then FORWARD or MIRROR.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] bridgeExceptionCmd       - the bridge exception command the packet arrived to
*                                      the router with.
*
* @param[out] enableRouterTriggerPtr   - router trigger state (enable/disable).
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum or bridgeExceptionCmd
* @retval GT_BAD_PTR               - on NULL ptr
*/
static GT_STATUS internal_cpssDxChIpSpecialRouterTriggerEnableGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_DXCH_IP_BRG_EXCP_CMD_ENT   bridgeExceptionCmd,
    OUT GT_BOOL                         *enableRouterTriggerPtr
)
{
    GT_U32    regAddr;        /* register address */

    GT_STATUS rc;             /* return code */
    GT_U32      hwValue;      /* hw value */
    GT_U32      offset;       /* offset in the register */
    GT_U32      offsetShift;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enableRouterTriggerPtr);

    offsetShift = PRV_CPSS_SIP6_10_ROUTER_GLB_REG_OFFSET_SHIFT(devNum);


    /* Get address of register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }


    /* all bridgeExceptionCmd refer to the same register but in different offsets */
    /* find offset according to brgExcpCmd */

    switch (bridgeExceptionCmd)
    {
    case CPSS_DXCH_IP_BRG_UC_IPV4_TRAP_EXCP_CMD_E:
        offset = 26 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV6_TRAP_EXCP_CMD_E:
        offset = 24 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV4_SOFT_DROP_EXCP_CMD_E:
        offset = 22 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV6_SOFT_DROP_EXCP_CMD_E:
        offset = 20 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV4_TRAP_EXCP_CMD_E:
        offset = 25 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV6_TRAP_EXCP_CMD_E:
        offset = 23 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV4_SOFT_DROP_EXCP_CMD_E:
        offset = 21 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV6_SOFT_DROP_EXCP_CMD_E:
        offset = 19 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_ARP_TRAP_EXCP_CMD_E:
        offset = 28 + offsetShift;
        break;
    case CPSS_DXCH_IP_BRG_ARP_SOFT_DROP_EXCP_CMD_E:
        offset = 27 + offsetShift;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* read enable value at the calculated offset */
    rc = prvCpssHwPpGetRegField(devNum,regAddr,offset,1,&hwValue);

    *enableRouterTriggerPtr = (0 == hwValue) ? GT_FALSE : GT_TRUE;

    return rc;
}

/**
* @internal cpssDxChIpSpecialRouterTriggerEnableGet function
* @endinternal
*
* @brief   Gets the special router trigger enable modes for packets with bridge
*         command other then FORWARD or MIRROR.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] bridgeExceptionCmd       - the bridge exception command the packet arrived to
*                                      the router with.
*
* @param[out] enableRouterTriggerPtr   - router trigger state (enable/disable).
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum or bridgeExceptionCmd
* @retval GT_BAD_PTR               - on NULL ptr
*/
GT_STATUS cpssDxChIpSpecialRouterTriggerEnableGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_DXCH_IP_BRG_EXCP_CMD_ENT   bridgeExceptionCmd,
    OUT GT_BOOL                         *enableRouterTriggerPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpSpecialRouterTriggerEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, bridgeExceptionCmd, enableRouterTriggerPtr));

    rc = internal_cpssDxChIpSpecialRouterTriggerEnableGet(devNum, bridgeExceptionCmd, enableRouterTriggerPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, bridgeExceptionCmd, enableRouterTriggerPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChIpExceptionDBIndexGet function
* @endinternal
*
* @brief   initialize databases to scan according to device family type.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] databaseArr[]            - array to hold the databases to scan
* @param[out] databaseSizePtr          - size of the database
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS prvCpssDxChIpExceptionDBIndexGet
(
    IN GT_U8                                    devNum,
    OUT const CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC   *databaseArr[],
    OUT GT_U32                                   *databaseSizePtr
)
{
    GT_U32      i;            /* counters */

  /* initialize databases to scan according to device family type */
    for (i = 0 ; i < NUMBER_OF_EXCEPTION_DATABASES_CNS ; i++)
        databaseArr[i] = NULL;

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        databaseArr[0] = eArchExceptions;
        databaseSizePtr[0] = sizeof(eArchExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
    }
    else
    {
        switch (PRV_CPSS_PP_MAC(devNum)->devFamily)
        {
        case CPSS_PP_FAMILY_DXCH_LION2_E:
            databaseArr[0] = dxCh2AndAboveExceptions;
            databaseSizePtr[0] = sizeof(dxCh2AndAboveExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            databaseArr[1] = dxCh3AndAboveExceptions;
            databaseSizePtr[1] = sizeof(dxCh3AndAboveExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            break;

        case PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_CASES_MAC:
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.ip.routingMode == CPSS_DXCH_POLICY_BASED_ROUTING_ONLY_E)
            {
                databaseArr[0] = dxChPbrOnlyExceptions;
                databaseSizePtr[0] = sizeof(dxChPbrOnlyExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            }
            else
            {
                databaseArr[0] = dxCh2AndAboveExceptions;
                databaseSizePtr[0] = sizeof(dxCh2AndAboveExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
                databaseArr[1] = dxCh3AndAboveExceptions;
                databaseSizePtr[1] = sizeof(dxCh3AndAboveExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            }
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }
    }
    return GT_OK;
}

/**
* @internal internal_cpssDxChIpExceptionCommandSet function
* @endinternal
*
* @brief   set a specific exception command.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] exceptionType            - the exception type
* @param[in] protocolStack            - whether to set for ipv4/v6 or both
* @param[in] command                  - the command, for availble commands see
*                                      CPSS_DXCH_IP_EXCEPTION_TYPE_ENT.
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpExceptionCommandSet
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_IP_EXCEPTION_TYPE_ENT  exceptionType,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    IN CPSS_PACKET_CMD_ENT              command
)
{
    GT_STATUS   rc;             /* function return code */
    GT_U32      regAddr;        /* address of register to write to */
    GT_BOOL     ipv4EntryFound = GT_FALSE; /* ipv4 matching row was found */
    GT_U32      ipv6EntryFound = GT_FALSE; /* ipv6 matching row was found */
    GT_U32      i,j;            /* counters */



    /* array to hold the databases to scan */
    const CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC *database[NUMBER_OF_EXCEPTION_DATABASES_CNS];
    /* size of the database  */
    GT_U32 databaseSize[NUMBER_OF_EXCEPTION_DATABASES_CNS];

    /* check parameters; note that the exception types */
    /* are checked while scanning the databases        */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
        case CPSS_IP_PROTOCOL_IPV6_E:
        case CPSS_IP_PROTOCOL_IPV4V6_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc=prvCpssDxChIpExceptionDBIndexGet(devNum,database,databaseSize);
    if (rc != GT_OK)
        return rc;

    /* search the databases for matching lines, remember 7 elements in each row */
    if((protocolStack == CPSS_IP_PROTOCOL_IPV4V6_E))
    {
        for (i = 0 ; i < NUMBER_OF_EXCEPTION_DATABASES_CNS ; i++)
        {
            /* skip empty databases */
            if (database[i] == NULL)
                continue;

            /* now scan the current databse entries */
            for (j = 0 ; j < databaseSize[i]; j++)
            {
                /* check that excpType and cmd match */
                if ((exceptionType != database[i][j].excptType) || (command != database[i][j].cmd))
                    continue;

                /* check if protocolStack doesn't match */
                if ((protocolStack == CPSS_IP_PROTOCOL_IPV4_E) &&
                    (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV6_E))
                    continue;
                if ((protocolStack == CPSS_IP_PROTOCOL_IPV6_E) &&
                    (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV4_E))
                    continue;

                /* set index of protocol that was updated */
                if (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV4_E)
                    ipv4EntryFound = GT_TRUE;
                else /* meaning database[i][j].protocolStack == GT_IP_PROTOCOL_IPV6 */
                    ipv6EntryFound = GT_TRUE;
            }
        }

        /* if no matching line was found, return with error */
        if ((ipv4EntryFound == GT_FALSE) || (ipv6EntryFound == GT_FALSE))
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* before start search for matching lines, mark that ipv4 matching */
    /* exception and ipv6 matching exception were not found yet        */
    ipv4EntryFound = GT_FALSE;
    ipv6EntryFound = GT_FALSE;

    /* search the databases for matching lines, remember 7 elements in each row*/
    for (i = 0 ; i < NUMBER_OF_EXCEPTION_DATABASES_CNS ; i++)
    {
        /* skip empty databases */
        if (database[i] == NULL)
            continue;

        /* now scan the current databse entries */
        for (j = 0 ; j < databaseSize[i]; j++)
        {
            /* check that excpType and cmd match */
            if ((exceptionType != database[i][j].excptType) || (command != database[i][j].cmd))
                continue;

            /* check if protocolStack doesn't match */
            if ((protocolStack == CPSS_IP_PROTOCOL_IPV4_E) &&
                (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV6_E))
                continue;
            if ((protocolStack == CPSS_IP_PROTOCOL_IPV6_E) &&
                (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV4_E))
                continue;

            /* a match was found, find register address from register index */
            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                switch (database[i][j].registerIndex)
                {
                case 0:
                   regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg0;
                    break;
                case 1:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6GlobalCtrl.IPv6CtrlReg0;
                    break;
                case 2:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg1;
                    break;
                case 3:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6GlobalCtrl.IPv6CtrlReg1;
                    break;
                case 4:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                switch (database[i][j].registerIndex)
                {
                case 0:
                   regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg0;
                    break;
                case 1:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ctrlReg0;
                    break;
                case 2:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg1;
                    break;
                case 3:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ctrlReg1;
                    break;
                case 4:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerAdditionalCtrlReg;
                    break;
                case 5:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ctrlReg0;
                    break;
                case 6:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ucRoutingEngineConfigurationReg;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }

            /* write value to the register */
            rc = prvCpssHwPpSetRegField(devNum,regAddr,database[i][j].offset,
                                           database[i][j].length,database[i][j].value);
            if (rc != GT_OK)
                return rc;

            /* set index of protocol that was updated */
            if (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV4_E)
                ipv4EntryFound = GT_TRUE;
            else /* meaning database[i][j].protocolStack == GT_IP_PROTOCOL_IPV6 */
                ipv6EntryFound = GT_TRUE;
        }
    }

    /* if no matching line was found, return with error */
    if ((ipv4EntryFound == GT_FALSE) && (ipv6EntryFound == GT_FALSE))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    return GT_OK;
}

/**
* @internal cpssDxChIpExceptionCommandSet function
* @endinternal
*
* @brief   set a specific exception command.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] exceptionType            - the exception type
* @param[in] protocolStack            - whether to set for ipv4/v6 or both
* @param[in] command                  - the command, for availble commands see
*                                      CPSS_DXCH_IP_EXCEPTION_TYPE_ENT.
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpExceptionCommandSet
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_IP_EXCEPTION_TYPE_ENT  exceptionType,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    IN CPSS_PACKET_CMD_ENT              command
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpExceptionCommandSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, exceptionType, protocolStack, command));

    rc = internal_cpssDxChIpExceptionCommandSet(devNum, exceptionType, protocolStack, command);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, exceptionType, protocolStack, command));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpExceptionCommandGet function
* @endinternal
*
* @brief   get a specific exception command.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] exceptionType            - the exception type
* @param[in] protocolStack            - whether to get for ipv4/v6
*
* @param[out] exceptionCmdPtr          - the command, for availble commands see
*                                      CPSS_DXCH_IP_EXCEPTION_TYPE_ENT
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_STATE             - on invalid hardware value read
*/
static GT_STATUS internal_cpssDxChIpExceptionCommandGet
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_IP_EXCEPTION_TYPE_ENT  exceptionType,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    OUT CPSS_PACKET_CMD_ENT             *exceptionCmdPtr
)
{
    GT_STATUS   rc;             /* function return code */
    GT_U32      regAddr;        /* address of register to write to */
    GT_U32      i,j;            /* counters */
    GT_U32      value=0;        /* value to read                    */

    /* array to hold the databases to scan */
    const CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC *database[NUMBER_OF_EXCEPTION_DATABASES_CNS];
    /* size of the database  */
    GT_U32 databaseSize[NUMBER_OF_EXCEPTION_DATABASES_CNS];

    /* check parameters; note that the exception types */
    /* are checked while scanning the databases        */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(exceptionCmdPtr);

    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
        case CPSS_IP_PROTOCOL_IPV6_E:
        case CPSS_IP_PROTOCOL_IPV4V6_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc=prvCpssDxChIpExceptionDBIndexGet(devNum,database,databaseSize);
    if (rc != GT_OK)
        return rc;

    /* search the databases for matching lines, remember 7 elements in each row*/
    for (i = 0 ; i < NUMBER_OF_EXCEPTION_DATABASES_CNS ; i++)
    {
        /* skip empty databases */
        if (database[i] == NULL)
            continue;


        /* now scan the current databse entries */
        for (j = 0 ; j < databaseSize[i]; j++)
        {
            /* check that excpType and cmd match */
            if (exceptionType != database[i][j].excptType)
                continue;

            /* check if protocolStack doesn't match */
            if ((protocolStack == CPSS_IP_PROTOCOL_IPV4_E) &&
                (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV6_E))
                continue;
            if ((protocolStack == CPSS_IP_PROTOCOL_IPV6_E) &&
                (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV4_E))
                continue;

            /* a match was found, find register address from register index */
            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                switch (database[i][j].registerIndex)
                {
                case 0:
                   regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg0;
                    break;
                case 1:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6GlobalCtrl.IPv6CtrlReg0;
                    break;
                case 2:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg1;
                    break;
                case 3:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6GlobalCtrl.IPv6CtrlReg1;
                    break;
                case 4:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                switch (database[i][j].registerIndex)
                {
                case 0:
                   regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg0;
                    break;
                case 1:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ctrlReg0;
                    break;
                case 2:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg1;
                    break;
                case 3:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ctrlReg1;
                    break;
                case 4:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerAdditionalCtrlReg;
                    break;
                case 5:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ctrlReg0;
                    break;
                case 6:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ucRoutingEngineConfigurationReg;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }

            /* read value from the register */
            rc = prvCpssHwPpGetRegField(devNum,regAddr,database[i][j].offset,
                                           database[i][j].length,&value);
            if (rc != GT_OK)
                return rc;

            /* break out of the loop after reading the register */
            break;
        }

        /* if end of table reached - then                           */
        /* illegal parameter or illegal combination of parameters   */
        if (j == databaseSize[i] && i == NUMBER_OF_EXCEPTION_DATABASES_CNS)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* scan table lines that match to current set of <excp><stack><type> */
        /* to see if the command read from hardware match any of those lines */
        for (; j < databaseSize[i]; j++)
        {
            /* check that excpType match */
            if (exceptionType != database[i][j].excptType)
                break;

            /* check if protocolStack match */
            if (protocolStack != database[i][j].protocolStack)
                break;

            /* check if command value is valid and return appropriate enum if does */
            if (database[i][j].value == value)
            {
                *exceptionCmdPtr = database[i][j].cmd;
                return GT_OK;
            }
         }

    }
    /* if end of table reached - then                           */
    /* illegal parameter or illegal combination of parameters   */
    if (i == NUMBER_OF_EXCEPTION_DATABASES_CNS)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* no matching command found for read value */
    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);

}

/**
* @internal cpssDxChIpExceptionCommandGet function
* @endinternal
*
* @brief   get a specific exception command.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] exceptionType            - the exception type
* @param[in] protocolStack            - whether to get for ipv4/v6
*
* @param[out] exceptionCmdPtr          - the command, for availble commands see
*                                      CPSS_DXCH_IP_EXCEPTION_TYPE_ENT
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_STATE             - on invalid hardware value read
*/
GT_STATUS cpssDxChIpExceptionCommandGet
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_IP_EXCEPTION_TYPE_ENT  exceptionType,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    OUT CPSS_PACKET_CMD_ENT             *exceptionCmdPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpExceptionCommandGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, exceptionType, protocolStack, exceptionCmdPtr));

    rc = internal_cpssDxChIpExceptionCommandGet(devNum, exceptionType, protocolStack, exceptionCmdPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, exceptionType, protocolStack, exceptionCmdPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpHeaderErrorMaskSet function
* @endinternal
*
* @brief   Mask or unmask an IP header error.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] ipHeaderErrorType        - the IP header error type
* @param[in] protocolStack            - whether to mask/unmask the error for IPv4 or IPv6
* @param[in] prefixType               - whether to mask/unmask the error for unicast or
*                                      multicast
* @param[in] mask                     - GT_TRUE:  the error
*                                      GT_FALSE: unmask the error
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note If the error is masked, then an IPv4/6 UC/MC header exception will not
*       be triggered for the relevant header error.
*
*/
static GT_STATUS internal_cpssDxChIpHeaderErrorMaskSet
(
    IN GT_U8                                devNum,
    IN CPSS_DXCH_IP_HEADER_ERROR_ENT        ipHeaderErrorType,
    IN CPSS_IP_PROTOCOL_STACK_ENT           protocolStack,
    IN CPSS_UNICAST_MULTICAST_ENT           prefixType,
    IN GT_BOOL                              mask
)
{
    GT_U32      regAddr;
    GT_U32      offset;
    GT_U32      value;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    if ((prefixType != CPSS_UNICAST_E) && (prefixType != CPSS_MULTICAST_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
            switch (ipHeaderErrorType)
            {
                case CPSS_DXCH_IP_HEADER_ERROR_CHECKSUM_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 0 : 1);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_VERSION_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 2 : 3);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_LENGTH_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 4 : 5);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_SIP_DIP_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 6 : 7);
                    break;

                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;

        case CPSS_IP_PROTOCOL_IPV6_E:
            switch (ipHeaderErrorType)
            {
                case CPSS_DXCH_IP_HEADER_ERROR_VERSION_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 8 : 9);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_LENGTH_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 10 : 11);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_SIP_DIP_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 12 : 13);
                    break;

                /* Checksum does not exist in IPv6 */
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).preRouteExceptionMasks;
    value = BOOL2BIT_MAC(mask);

    return prvCpssHwPpSetRegField(devNum, regAddr, offset, 1, value);
}

/**
* @internal cpssDxChIpHeaderErrorMaskSet function
* @endinternal
*
* @brief   Mask or unmask an IP header error.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] ipHeaderErrorType        - the IP header error type
* @param[in] protocolStack            - whether to mask/unmask the error for IPv4 or IPv6
* @param[in] prefixType               - whether to mask/unmask the error for unicast or
*                                      multicast
* @param[in] mask                     - GT_TRUE:  the error
*                                      GT_FALSE: unmask the error
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note If the error is masked, then an IPv4/6 UC/MC header exception will not
*       be triggered for the relevant header error.
*
*/
GT_STATUS cpssDxChIpHeaderErrorMaskSet
(
    IN GT_U8                                devNum,
    IN CPSS_DXCH_IP_HEADER_ERROR_ENT        ipHeaderErrorType,
    IN CPSS_IP_PROTOCOL_STACK_ENT           protocolStack,
    IN CPSS_UNICAST_MULTICAST_ENT           prefixType,
    IN GT_BOOL                              mask
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpHeaderErrorMaskSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ipHeaderErrorType, protocolStack, prefixType, mask));

    rc = internal_cpssDxChIpHeaderErrorMaskSet(devNum, ipHeaderErrorType, protocolStack, prefixType, mask);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ipHeaderErrorType, protocolStack, prefixType, mask));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpHeaderErrorMaskGet function
* @endinternal
*
* @brief   Get the masking status of an IP header error.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] ipHeaderErrorType        - the IP header error type
* @param[in] protocolStack            - whether to check the masking status for IPv4 or IPv6
* @param[in] prefixType               - whether to check the masking status for unicast or
*                                      multicast
*
* @param[out] maskPtr                  - GT_TRUE: mask the error
*                                      GT_FALSE: unmask the error
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note If the error is masked, then an IPv4/6 UC/MC header exception will not
*       be triggered for the relevant header error.
*
*/
static GT_STATUS internal_cpssDxChIpHeaderErrorMaskGet
(
    IN  GT_U8                               devNum,
    IN  CPSS_DXCH_IP_HEADER_ERROR_ENT       ipHeaderErrorType,
    IN  CPSS_IP_PROTOCOL_STACK_ENT          protocolStack,
    IN  CPSS_UNICAST_MULTICAST_ENT          prefixType,
    OUT GT_BOOL                             *maskPtr
)
{
    GT_U32      regAddr;
    GT_U32      offset;
    GT_U32      value;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(maskPtr);

    if ((prefixType != CPSS_UNICAST_E) && (prefixType != CPSS_MULTICAST_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
            switch (ipHeaderErrorType)
            {
                case CPSS_DXCH_IP_HEADER_ERROR_CHECKSUM_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 0 : 1);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_VERSION_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 2 : 3);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_LENGTH_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 4 : 5);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_SIP_DIP_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 6 : 7);
                    break;

                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;

        case CPSS_IP_PROTOCOL_IPV6_E:
            switch (ipHeaderErrorType)
            {
                case CPSS_DXCH_IP_HEADER_ERROR_VERSION_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 8 : 9);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_LENGTH_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 10 : 11);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_SIP_DIP_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 12 : 13);
                    break;

                /* Checksum does not exist in IPv6 */
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).preRouteExceptionMasks;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 1, &value);
    if (rc == GT_OK)
    {
        *maskPtr = BIT2BOOL_MAC(value);
    }
    return rc;
}

/**
* @internal cpssDxChIpHeaderErrorMaskGet function
* @endinternal
*
* @brief   Get the masking status of an IP header error.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] ipHeaderErrorType        - the IP header error type
* @param[in] protocolStack            - whether to check the masking status for IPv4 or IPv6
* @param[in] prefixType               - whether to check the masking status for unicast or
*                                      multicast
*
* @param[out] maskPtr                  - GT_TRUE: mask the error
*                                      GT_FALSE: unmask the error
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note If the error is masked, then an IPv4/6 UC/MC header exception will not
*       be triggered for the relevant header error.
*
*/
GT_STATUS cpssDxChIpHeaderErrorMaskGet
(
    IN  GT_U8                               devNum,
    IN  CPSS_DXCH_IP_HEADER_ERROR_ENT       ipHeaderErrorType,
    IN  CPSS_IP_PROTOCOL_STACK_ENT          protocolStack,
    IN  CPSS_UNICAST_MULTICAST_ENT          prefixType,
    OUT GT_BOOL                             *maskPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpHeaderErrorMaskGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ipHeaderErrorType, protocolStack, prefixType, maskPtr));

    rc = internal_cpssDxChIpHeaderErrorMaskGet(devNum, ipHeaderErrorType, protocolStack, prefixType, maskPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ipHeaderErrorType, protocolStack, prefixType, maskPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpUcRouteAgingModeSet function
* @endinternal
*
* @brief   Sets the global route aging modes.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] refreshEnable            - Enables the global routing activity refresh mechanism
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpUcRouteAgingModeSet
(
    IN  GT_U8    devNum,
    IN  GT_BOOL  refreshEnable
)
{

    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    value;                /* value to write                     */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /* Get address of register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }


    /* update refreshEnable value */
    value = (refreshEnable == GT_TRUE) ? 1:0;
    rc = prvCpssHwPpSetRegField(devNum,regAddr,0,1,value);

    return rc;
}

/**
* @internal cpssDxChIpUcRouteAgingModeSet function
* @endinternal
*
* @brief   Sets the global route aging modes.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] refreshEnable            - Enables the global routing activity refresh mechanism
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpUcRouteAgingModeSet
(
    IN  GT_U8    devNum,
    IN  GT_BOOL  refreshEnable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRouteAgingModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, refreshEnable));

    rc = internal_cpssDxChIpUcRouteAgingModeSet(devNum, refreshEnable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, refreshEnable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpUcRouteAgingModeGet function
* @endinternal
*
* @brief   Gets the global route aging modes.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] refreshEnablePtr         - Enables the global routing activity refresh mechanism
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL ptr
*/
static GT_STATUS internal_cpssDxChIpUcRouteAgingModeGet
(
    IN  GT_U8    devNum,
    OUT GT_BOOL  *refreshEnablePtr
)
{
    GT_U32    regAddr;              /* register address */
    GT_STATUS rc = GT_OK;           /* return code */
    GT_U32    hwValue;              /* hw value */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(refreshEnablePtr);

    /* Get address of register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }

    /* get refreshEnable value */
    rc = prvCpssHwPpGetRegField(devNum,regAddr,0,1,&hwValue);
    if(GT_OK != rc)
    {
        return rc;
    }

    *refreshEnablePtr = (0 == hwValue) ? GT_FALSE : GT_TRUE;

    return GT_OK;
}

/**
* @internal cpssDxChIpUcRouteAgingModeGet function
* @endinternal
*
* @brief   Gets the global route aging modes.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] refreshEnablePtr         - Enables the global routing activity refresh mechanism
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL ptr
*/
GT_STATUS cpssDxChIpUcRouteAgingModeGet
(
    IN  GT_U8    devNum,
    OUT GT_BOOL  *refreshEnablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRouteAgingModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, refreshEnablePtr));

    rc = internal_cpssDxChIpUcRouteAgingModeGet(devNum, refreshEnablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, refreshEnablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterSourceIdSet function
* @endinternal
*
* @brief   set the router source id assignmnet.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] ucMcSet                  - whether to set it for unicast packets or multicast.
* @param[in] sourceId                 - the assigned source id.
* @param[in] sourceIdMask             - the assigned source id mask.
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_OUT_OF_RANGE          - on out of range parameter
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterSourceIdSet
(
    IN  GT_U8                           devNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    IN  GT_U32                          sourceId,
    IN  GT_U32                          sourceIdMask
)
{
    return cpssDxChIpPortGroupRouterSourceIdSet(devNum,
                                                CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                ucMcSet, sourceId, sourceIdMask);
}

/**
* @internal cpssDxChIpRouterSourceIdSet function
* @endinternal
*
* @brief   set the router source id assignmnet.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] ucMcSet                  - whether to set it for unicast packets or multicast.
* @param[in] sourceId                 - the assigned source id.
* @param[in] sourceIdMask             - the assigned source id mask.
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_OUT_OF_RANGE          - on out of range parameter
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterSourceIdSet
(
    IN  GT_U8                           devNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    IN  GT_U32                          sourceId,
    IN  GT_U32                          sourceIdMask
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterSourceIdSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ucMcSet, sourceId, sourceIdMask));

    rc = internal_cpssDxChIpRouterSourceIdSet(devNum, ucMcSet, sourceId, sourceIdMask);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ucMcSet, sourceId, sourceIdMask));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterSourceIdGet function
* @endinternal
*
* @brief   get the router source id.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] ucMcSet                  - whether to set it for unicast packets or multicast.
*
* @param[out] sourceIdPtr              - the assigned source id.
* @param[out] sourceIdMaskPtr          - the assigned source id mask.
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_OUT_OF_RANGE          - on out of range parameter
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterSourceIdGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    OUT GT_U32                          *sourceIdPtr,
    OUT GT_U32                          *sourceIdMaskPtr
)
{
    return cpssDxChIpPortGroupRouterSourceIdGet(devNum,
                                                CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                ucMcSet, sourceIdPtr, sourceIdMaskPtr);
}

/**
* @internal cpssDxChIpRouterSourceIdGet function
* @endinternal
*
* @brief   get the router source id.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] ucMcSet                  - whether to set it for unicast packets or multicast.
*
* @param[out] sourceIdPtr              - the assigned source id.
* @param[out] sourceIdMaskPtr          - the assigned source id mask.
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_OUT_OF_RANGE          - on out of range parameter
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterSourceIdGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    OUT GT_U32                          *sourceIdPtr,
    OUT GT_U32                          *sourceIdMaskPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterSourceIdGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ucMcSet, sourceIdPtr, sourceIdMaskPtr));

    rc = internal_cpssDxChIpRouterSourceIdGet(devNum, ucMcSet, sourceIdPtr, sourceIdMaskPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ucMcSet, sourceIdPtr, sourceIdMaskPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupRouterSourceIdSet function
* @endinternal
*
* @brief   set the router source id assignmnet.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] ucMcSet                  - whether to set it for unicast packets or multicast.
* @param[in] sourceId                 - the assigned source id.
* @param[in] sourceIdMask             - the assigned source id mask,
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_OUT_OF_RANGE          - on out of range parameter
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortGroupRouterSourceIdSet
(
    IN  GT_U8                           devNum,
    IN GT_PORT_GROUPS_BMP               portGroupsBmp,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    IN  GT_U32                          sourceId,
    IN  GT_U32                          sourceIdMask
)
{
    GT_U32    regAddr;      /* register address  */
    GT_STATUS rc;           /* return code       */
    GT_U32    offset;       /* register offset   */
    GT_U32    portGroupId;  /* the port group Id            */
    GT_U32    numOfBits;    /* number of bits to write to register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if (sourceId > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_SRC_ID_MAC(devNum))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE &&
        sourceIdMask >= BIT_12)
    {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    offset = 0; /* prevent compilation warning */
    if( CPSS_IP_UNICAST_E == ucMcSet )
    {
        if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            /*RouterUCSourceID*/
            regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
            offset = 8;
            numOfBits = 12;
        }
        else
        {
            if ((PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum)) &&
                (CPSS_DXCH_POLICY_BASED_ROUTING_ONLY_E ==
                            PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.ip.routingMode))
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ucRoutingEngineConfigurationReg;
                offset = 0;
            }
            else
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
                offset = 1;
            }
            numOfBits = 5;
        }

        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)
        {
            rc = prvCpssHwPpPortGroupSetRegField(
                devNum, portGroupId, regAddr,
                offset, numOfBits, sourceId);
            if (rc != GT_OK)
            {
                return rc;
            }

            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                GT_U32 regAddr1 = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl2; /* Router UC Source ID mask */
                /* set the value for the 'mask' bits 0..11 */
                rc = prvCpssHwPpPortGroupSetRegField(
                    devNum, portGroupId, regAddr1,
                    0, numOfBits, sourceIdMask);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }

        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)
    }
    else if ( CPSS_IP_MULTICAST_E == ucMcSet )
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            offset = 12;
            numOfBits = 12;
            regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLGlobalCtrl.MLLMCSourceID;
        }
        else if ((PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum)) &&
                 (CPSS_DXCH_POLICY_BASED_ROUTING_ONLY_E ==
                        PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.ip.routingMode))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllGlobalReg;
            numOfBits = 5;
        }

        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)
        {
            rc = prvCpssHwPpPortGroupSetRegField(
                devNum, portGroupId, regAddr,
                offset, numOfBits, sourceId);
            if (rc != GT_OK)
            {
                return rc;
            }

            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                /* set the value for the 'mask' bits 0..11 */
                rc = prvCpssHwPpPortGroupSetRegField(
                    devNum, portGroupId, regAddr,
                    0, numOfBits, sourceIdMask);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)
    }
    else
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    return GT_OK;

}

/**
* @internal cpssDxChIpPortGroupRouterSourceIdSet function
* @endinternal
*
* @brief   set the router source id assignmnet.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] ucMcSet                  - whether to set it for unicast packets or multicast.
* @param[in] sourceId                 - the assigned source id.
* @param[in] sourceIdMask             - the assigned source id mask.
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_OUT_OF_RANGE          - on out of range parameter
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortGroupRouterSourceIdSet
(
    IN  GT_U8                           devNum,
    IN GT_PORT_GROUPS_BMP               portGroupsBmp,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    IN  GT_U32                          sourceId,
    IN  GT_U32                          sourceIdMask
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupRouterSourceIdSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, ucMcSet, sourceId, sourceIdMask));

    rc = internal_cpssDxChIpPortGroupRouterSourceIdSet(devNum, portGroupsBmp, ucMcSet, sourceId, sourceIdMask);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, ucMcSet, sourceId, sourceIdMask));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupRouterSourceIdGet function
* @endinternal
*
* @brief   get the router source id assignmnet.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] ucMcSet                  - whether to set it for unicast packets or multicast.
*
* @param[out] sourceIdPtr              - the assigned source id.
* @param[out] sourceIdMaskPtr          - the assigned source id mask
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_OUT_OF_RANGE          - on out of range parameter
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL ptr
*/
static GT_STATUS internal_cpssDxChIpPortGroupRouterSourceIdGet
(
    IN  GT_U8                           devNum,
    IN  GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    OUT GT_U32                          *sourceIdPtr,
    OUT GT_U32                          *sourceIdMaskPtr
)
{
    GT_U32    regAddr;      /* register address  */
    GT_STATUS rc;           /* return code       */
    GT_U32    offset;       /* register offset   */
    GT_U32    portGroupId;  /* the port group Id            */
    GT_U32    numOfBits;    /* number of bits to read from register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    CPSS_NULL_PTR_CHECK_MAC(sourceIdPtr);
    CPSS_NULL_PTR_CHECK_MAC(sourceIdMaskPtr);

    /* Get the first active port group id */
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(devNum, portGroupsBmp,
                                                        portGroupId);

    offset = 0; /* prevent compilation warning */
    if( CPSS_IP_UNICAST_E == ucMcSet )
    {
        if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
            offset = 8;
            numOfBits = 12;
        }
        else
        {
            if ((PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum)) &&
                (CPSS_DXCH_POLICY_BASED_ROUTING_ONLY_E ==
                            PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.ip.routingMode))
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ucRoutingEngineConfigurationReg;
            }
            else
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
                offset = 1;
            }
            numOfBits = 5;
        }

        rc = prvCpssHwPpPortGroupGetRegField(
            devNum, portGroupId, regAddr,
            offset, numOfBits, sourceIdPtr);
        if (rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl2;
            /* get the value for the 'mask' bits 0..11 */
            rc = prvCpssHwPpPortGroupGetRegField(
                devNum, portGroupId, regAddr,
                0, numOfBits, sourceIdMaskPtr);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }
    else if ( CPSS_IP_MULTICAST_E == ucMcSet )
    {

        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            /* assumption : the value for the 'mask' bits 0..11 was already set by application / cpssInit */
            offset = 12;
            numOfBits = 12;
            regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLGlobalCtrl.MLLMCSourceID;
        }
        else
        {
            if ((PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum)) &&
                (CPSS_DXCH_POLICY_BASED_ROUTING_ONLY_E ==
                            PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.ip.routingMode))
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            else
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllGlobalReg;
            }

            numOfBits = 5;
        }

        rc = prvCpssHwPpPortGroupGetRegField(
            devNum, portGroupId, regAddr,
            offset, numOfBits, sourceIdPtr);
        if (rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            /* get the value for the 'mask' bits 0..11 */
            rc = prvCpssHwPpPortGroupGetRegField(
                devNum, portGroupId, regAddr,
                0, numOfBits, sourceIdMaskPtr);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }
    else
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    return GT_OK;
}

/**
* @internal cpssDxChIpPortGroupRouterSourceIdGet function
* @endinternal
*
* @brief   get the router source id assignmnet.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] ucMcSet                  - whether to set it for unicast packets or multicast.
*
* @param[out] sourceIdPtr              - the assigned source id.
* @param[out] sourceIdMaskPtr          - the assigned source id mask.
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_OUT_OF_RANGE          - on out of range parameter
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL ptr
*/
GT_STATUS cpssDxChIpPortGroupRouterSourceIdGet
(
    IN  GT_U8                           devNum,
    IN  GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    OUT GT_U32                          *sourceIdPtr,
    OUT GT_U32                          *sourceIdMaskPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupRouterSourceIdGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, ucMcSet, sourceIdPtr, sourceIdMaskPtr));

    rc = internal_cpssDxChIpPortGroupRouterSourceIdGet(devNum, portGroupsBmp, ucMcSet, sourceIdPtr, sourceIdMaskPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, ucMcSet, sourceIdPtr, sourceIdMaskPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterSourceIdOverrideEnableSet function
* @endinternal
*
* @brief   Enable/Disable overriding of source id by routing engine.
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] enable                   - GT_TRUE  -  override
*                                      GT_FALSE - disable override
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Lion2 device: applicable starting from revision B1
*
*/
static GT_STATUS internal_cpssDxChIpRouterSourceIdOverrideEnableSet
(
    IN  GT_U8                           devNum,
    IN  GT_BOOL                         enable
)
{
    GT_U32    regAddr;      /* register address  */
    GT_STATUS rc;           /* return code       */
    GT_U32    hwData;       /* HW data           */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E |
                                          CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    if (PRV_CPSS_DXCH_LION2_B1_AND_ABOVE_CHECK_MAC(devNum) == 0)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllMetalFix;
    hwData = BOOL2BIT_MAC(enable);

    rc = prvCpssHwPpSetRegField(
        devNum, regAddr,
        0 /*offset*/, 1/*fieldLength*/, hwData);

    return rc;
}

/**
* @internal cpssDxChIpRouterSourceIdOverrideEnableSet function
* @endinternal
*
* @brief   Enable/Disable overriding of source id by routing engine.
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] enable                   - GT_TRUE  -  override
*                                      GT_FALSE - disable override
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Lion2 device: applicable starting from revision B1
*
*/
GT_STATUS cpssDxChIpRouterSourceIdOverrideEnableSet
(
    IN  GT_U8                           devNum,
    IN  GT_BOOL                         enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterSourceIdOverrideEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpRouterSourceIdOverrideEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterSourceIdOverrideEnableGet function
* @endinternal
*
* @brief   Get Enable/Disable status of overriding of source id
*         by routing engine.
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
*
* @param[out] enablePtr                - (pointer to)enable:
*                                      GT_TRUE  - enable override
*                                      GT_FALSE - disable override
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Lion2 device: applicable starting from revision B1
*
*/
static GT_STATUS internal_cpssDxChIpRouterSourceIdOverrideEnableGet
(
    IN  GT_U8                           devNum,
    OUT GT_BOOL                         *enablePtr
)
{
    GT_U32    regAddr;      /* register address  */
    GT_STATUS rc;           /* return code       */
    GT_U32    hwData;       /* HW data           */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E |
                                          CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    if (PRV_CPSS_DXCH_LION2_B1_AND_ABOVE_CHECK_MAC(devNum) == 0)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllMetalFix;

    rc = prvCpssHwPpGetRegField(
        devNum, regAddr,
        0 /*offset*/, 1/*fieldLength*/, &hwData);
    if (rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(hwData);

    return GT_OK;
}

/**
* @internal cpssDxChIpRouterSourceIdOverrideEnableGet function
* @endinternal
*
* @brief   Get Enable/Disable status of overriding of source id
*         by routing engine.
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
*
* @param[out] enablePtr                - (pointer to)enable:
*                                      GT_TRUE  - enable override
*                                      GT_FALSE - disable override
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Lion2 device: applicable starting from revision B1
*
*/
GT_STATUS cpssDxChIpRouterSourceIdOverrideEnableGet
(
    IN  GT_U8                           devNum,
    OUT GT_BOOL                         *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterSourceIdOverrideEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpRouterSourceIdOverrideEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet function
* @endinternal
*
* @brief   Sets the multi-target TC queue assigned to multi-target Control
*         packets and to RPF Fail packets where the RPF Fail Command is assigned
*         from the MLL entry.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] ctrlMultiTargetTCQueue   - The multi-target TC queue for control
*                                      traffic. There are 4 possible queues (APPLICABLE RANGES: 0..3)
* @param[in] failRpfMultiTargetTCQueue - the multi-target TC queue for fail rpf
*                                      traffic. There are 4 possible queues (APPLICABLE RANGES: 0..3)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note A packet is considered as a multi-target control if it is a FROM_CPU DSA
*       Tagged with DSA<Use_Vidx> = 1 or a multi-target packet that is also to
*       be mirrored to the CPU
*
*/
static GT_STATUS internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  ctrlMultiTargetTCQueue,
    IN  GT_U32  failRpfMultiTargetTCQueue
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /* update ctrlMultiTargetTCQueue value */
    if(ctrlMultiTargetTCQueue > 3)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if(failRpfMultiTargetTCQueue > 3)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
            multitargetTCQueuesGlobalConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesGlobalReg;
    }

    rc = prvCpssHwPpSetRegField(devNum,regAddr, 16,4,ctrlMultiTargetTCQueue | (failRpfMultiTargetTCQueue << 2));
    return rc;
}

/**
* @internal cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet function
* @endinternal
*
* @brief   Sets the multi-target TC queue assigned to multi-target Control
*         packets and to RPF Fail packets where the RPF Fail Command is assigned
*         from the MLL entry.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] ctrlMultiTargetTCQueue   - The multi-target TC queue for control
*                                      traffic. There are 4 possible queues (APPLICABLE RANGES: 0..3)
* @param[in] failRpfMultiTargetTCQueue - the multi-target TC queue for fail rpf
*                                      traffic. There are 4 possible queues (APPLICABLE RANGES: 0..3)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note A packet is considered as a multi-target control if it is a FROM_CPU DSA
*       Tagged with DSA<Use_Vidx> = 1 or a multi-target packet that is also to
*       be mirrored to the CPU
*
*/
GT_STATUS cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  ctrlMultiTargetTCQueue,
    IN  GT_U32  failRpfMultiTargetTCQueue
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ctrlMultiTargetTCQueue, failRpfMultiTargetTCQueue));

    rc = internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet(devNum, ctrlMultiTargetTCQueue, failRpfMultiTargetTCQueue);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ctrlMultiTargetTCQueue, failRpfMultiTargetTCQueue));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet function
* @endinternal
*
* @brief   Gets the multi-target TC queue assigned to multi-target Control
*         packets and to RPF Fail packets where the RPF Fail Command is assigned
*         from the MLL entry.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] ctrlMultiTargetTCQueuePtr - The multi-target TC queue for control
*                                      traffic. There are 4 possible queues
* @param[out] failRpfMultiTargetTCQueuePtr - the multi-target TC queue for fail rpf
*                                      traffic. There are 4 possible queues
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL Ptr
*
* @note A packet is considered as a multi-target control if it is a FROM_CPU DSA
*       Tagged with DSA<Use_Vidx> = 1 or a multi-target packet that is also to
*       be mirrored to the CPU
*
*/
static GT_STATUS internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet
(
    IN   GT_U8   devNum,
    OUT  GT_U32  *ctrlMultiTargetTCQueuePtr,
    OUT  GT_U32  *failRpfMultiTargetTCQueuePtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(ctrlMultiTargetTCQueuePtr);
    CPSS_NULL_PTR_CHECK_MAC(failRpfMultiTargetTCQueuePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
            multitargetTCQueuesGlobalConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesGlobalReg;
    }

    rc = prvCpssHwPpGetRegField(devNum,regAddr,18,2,failRpfMultiTargetTCQueuePtr);
    if(GT_OK != rc)
        return rc;

    rc = prvCpssHwPpGetRegField(devNum,regAddr, 16,2,ctrlMultiTargetTCQueuePtr);

    return rc;
}

/**
* @internal cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet function
* @endinternal
*
* @brief   Gets the multi-target TC queue assigned to multi-target Control
*         packets and to RPF Fail packets where the RPF Fail Command is assigned
*         from the MLL entry.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] ctrlMultiTargetTCQueuePtr - The multi-target TC queue for control
*                                      traffic. There are 4 possible queues
* @param[out] failRpfMultiTargetTCQueuePtr - the multi-target TC queue for fail rpf
*                                      traffic. There are 4 possible queues
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL Ptr
*
* @note A packet is considered as a multi-target control if it is a FROM_CPU DSA
*       Tagged with DSA<Use_Vidx> = 1 or a multi-target packet that is also to
*       be mirrored to the CPU
*
*/
GT_STATUS cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet
(
    IN   GT_U8   devNum,
    OUT  GT_U32  *ctrlMultiTargetTCQueuePtr,
    OUT  GT_U32  *failRpfMultiTargetTCQueuePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ctrlMultiTargetTCQueuePtr, failRpfMultiTargetTCQueuePtr));

    rc = internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet(devNum, ctrlMultiTargetTCQueuePtr, failRpfMultiTargetTCQueuePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ctrlMultiTargetTCQueuePtr, failRpfMultiTargetTCQueuePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapSet function
* @endinternal
*
* @brief   Sets the Qos Profile to multi-target TC queue mapping.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] qosProfile               - QOS Profile index
* @param[in] multiTargetTCQueue       - the multi-target TC queue. There are 4 possible
*                                      queues.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  qosProfile,
    IN  GT_U32  multiTargetTCQueue
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    offset;               /* value to write                     */

    /* check parameters */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /* get reg_addr and offset within the address from qosProfile value */
    /* note that each QOS profile need 2 bits for Queue index so there  */
    /* are 16 entries in each 32bit register                            */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        if (qosProfile >= EARC_MAX_MAC_QOS_ENTRIES_CNS)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).
            mcLinkedListMLLTables.qoSProfileToMultiTargetTCQueuesReg[qosProfile/16];
    }
    else
    {
        if (qosProfile >= CHEETAH_MAX_MAC_QOS_ENTRIES_CNS)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.qoSProfile2MTTCQueuesMapTable[(qosProfile/16)];
    }

    offset = (qosProfile % 16) * 2;

    /* write mtTcQueue value */
    if( multiTargetTCQueue >= BIT_2)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    rc = prvCpssHwPpSetRegField(devNum,regAddr,offset,2,multiTargetTCQueue);

    return rc;
}

/**
* @internal cpssDxChIpQosProfileToMultiTargetTCQueueMapSet function
* @endinternal
*
* @brief   Sets the Qos Profile to multi-target TC queue mapping.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] qosProfile               - QOS Profile index
* @param[in] multiTargetTCQueue       - the multi-target TC queue. There are 4 possible
*                                      queues.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpQosProfileToMultiTargetTCQueueMapSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  qosProfile,
    IN  GT_U32  multiTargetTCQueue
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpQosProfileToMultiTargetTCQueueMapSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, qosProfile, multiTargetTCQueue));

    rc = internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapSet(devNum, qosProfile, multiTargetTCQueue);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, qosProfile, multiTargetTCQueue));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapGet function
* @endinternal
*
* @brief   gets the Qos Profile to multi-target TC queue mapping.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] qosProfile               - QOS Profile index
*
* @param[out] multiTargetTCQueuePtr    - the multi-target TC queue. There are 4 possible
*                                      queues.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  qosProfile,
    OUT GT_U32  *multiTargetTCQueuePtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    offset;               /* value to write                     */

    /* check parameters */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(multiTargetTCQueuePtr);

    /* get reg_addr and offset within the address from qosProfile value */
    /* note that each QOS profile need 2 bits for Queue index so there  */
    /* are 16 entires in each 32bit register                            */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        if (qosProfile >= EARC_MAX_MAC_QOS_ENTRIES_CNS)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).
            mcLinkedListMLLTables.qoSProfileToMultiTargetTCQueuesReg[qosProfile/16];
    }
    else
    {
        if (qosProfile >= CHEETAH_MAX_MAC_QOS_ENTRIES_CNS)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.qoSProfile2MTTCQueuesMapTable[(qosProfile/16)];
    }

    offset = (qosProfile % 16) * 2;

    rc = prvCpssHwPpGetRegField(devNum,regAddr,offset,2,multiTargetTCQueuePtr);

    return rc;
}

/**
* @internal cpssDxChIpQosProfileToMultiTargetTCQueueMapGet function
* @endinternal
*
* @brief   gets the Qos Profile to multi-target TC queue mapping.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] qosProfile               - QOS Profile index
*
* @param[out] multiTargetTCQueuePtr    - the multi-target TC queue. There are 4 possible
*                                      queues.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpQosProfileToMultiTargetTCQueueMapGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  qosProfile,
    OUT GT_U32  *multiTargetTCQueuePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpQosProfileToMultiTargetTCQueueMapGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, qosProfile, multiTargetTCQueuePtr));

    rc = internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapGet(devNum, qosProfile, multiTargetTCQueuePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, qosProfile, multiTargetTCQueuePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpTcDpToMultiTargetTcQueueMapSet function
* @endinternal
*
* @brief   Sets the packet's (TC,DP) to multi-target TC queue mapping.
*         (It is used for packets received on cascade ports configured to work in extended QoS mode)
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] tc                       - traffic class assigned to the packet.
*                                      (received on a cascade port configured for extended Global QoS mode)
*                                      (APPLICABLE RANGES: 0..7).
* @param[in] dp                       - drop precedence assigned to the packet for tail drop.
*                                      (received on a cascade port configured for extended Global QoS mode)
* @param[in] multiTargetTCQueue       - the multi-target TC queue. (APPLICABLE RANGES: 0..3).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpTcDpToMultiTargetTcQueueMapSet
(
    IN  GT_U8              devNum,
    IN  GT_U32             tc,
    IN  CPSS_DP_LEVEL_ENT  dp,
    IN  GT_U32             multiTargetTCQueue
)
{
    GT_U32 dpValue;
    GT_U32 index;
    GT_U32 regAddr;
    GT_U32 fieldOffset;
    GT_U32 fieldLength;
    PRV_CPSS_DXCH_PP_REGS_ADDR_VER1_STC *regsAddrPtr;
    /* check input parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_COS_DP_TO_HW_CHECK_AND_CONVERT_MAC(
        devNum, dp, dpValue);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(multiTargetTCQueue);
    /* build 5 bit {TC,DP) index */
    index = 0;
    index = (tc << 2) | dpValue;

    /* each register incorporates 16 mc priority queue values */
    regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum);
    regAddr = regsAddrPtr->MLL.mcLinkedListMLLTables.extQoSModeMCQueueSelectionReg[index/16];
    fieldLength = 2;
    fieldOffset = (index%16)*fieldLength;
    return prvCpssHwPpSetRegField(devNum, regAddr, fieldOffset, fieldLength, multiTargetTCQueue);
}

/**
* @internal cpssDxChIpTcDpToMultiTargetTcQueueMapSet function
* @endinternal
*
* @brief   Sets the packet's (TC,DP) to multi-target TC queue mapping.
*         (It is used for packets received on cascade ports configured to work in extended QoS mode)
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] tc                       - traffic class assigned to the packet.
*                                      (received on a cascade port configured for extended Global QoS mode)
*                                      (APPLICABLE RANGES: 0..7).
* @param[in] dp                       - drop precedence assigned to the packet for tail drop.
*                                      (received on a cascade port configured for extended Global QoS mode)
* @param[in] multiTargetTCQueue       - the multi-target TC queue. (APPLICABLE RANGES: 0..3).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpTcDpToMultiTargetTcQueueMapSet
(
    IN  GT_U8              devNum,
    IN  GT_U32             tc,
    IN  CPSS_DP_LEVEL_ENT  dp,
    IN  GT_U32             multiTargetTCQueue
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpTcDpToMultiTargetTcQueueMapSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tc, dp, multiTargetTCQueue));

    rc = internal_cpssDxChIpTcDpToMultiTargetTcQueueMapSet(devNum, tc, dp, multiTargetTCQueue);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tc, dp, multiTargetTCQueue));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpTcDpToMultiTargetTcQueueMapGet function
* @endinternal
*
* @brief   Gets the packet's (TC,DP) to multi-target TC queue mapping.
*         (It is used for packets received on cascade ports configured to work in extended QoS mode)
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] tc                       - traffic class assigned to the packet.
*                                      (received on a cascade port configured for extended Global QoS mode)
*                                      (APPLICABLE RANGES: 0..7).
* @param[in] dp                       - drop precedence assigned to the packet for tail drop.
*                                      (received on a cascade port configured for extended Global QoS mode)
*
* @param[out] multiTargetTCQueuePtr    - the multi-target TC queue. (APPLICABLE RANGES: 0..3).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpTcDpToMultiTargetTcQueueMapGet
(
    IN  GT_U8              devNum,
    IN  GT_U32             tc,
    IN  CPSS_DP_LEVEL_ENT  dp,
    OUT  GT_U32            *multiTargetTCQueuePtr
)
{
    GT_STATUS rc;
    GT_U32 dpValue;
    GT_U32 index;
    GT_U32 regAddr;
    GT_U32 fieldOffset;
    GT_U32 fieldLength;
    GT_U32 fieldValue;
    PRV_CPSS_DXCH_PP_REGS_ADDR_VER1_STC *regsAddrPtr;
    /* check input parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_COS_DP_TO_HW_CHECK_AND_CONVERT_MAC(
        devNum, dp, dpValue);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);
    CPSS_NULL_PTR_CHECK_MAC(multiTargetTCQueuePtr);

    /* build 5 bit {TC,DP) index */
    index = 0;
    index = (tc << 2) | dpValue;

    /* each register incorporates 16 mc priority queue values */
    regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum);
    regAddr = regsAddrPtr->MLL.mcLinkedListMLLTables.extQoSModeMCQueueSelectionReg[index/16];
    fieldLength = 2;
    fieldOffset = (index%16)*fieldLength;
    rc =  prvCpssHwPpGetRegField(devNum, regAddr, fieldOffset, fieldLength, &fieldValue);
    if (rc != GT_OK)
    {
        return rc;
    }
    *multiTargetTCQueuePtr = fieldValue;
    return rc;
}

/**
* @internal cpssDxChIpTcDpToMultiTargetTcQueueMapGet function
* @endinternal
*
* @brief   Gets the packet's (TC,DP) to multi-target TC queue mapping.
*         (It is used for packets received on cascade ports configured to work in extended QoS mode)
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] tc                       - traffic class assigned to the packet.
*                                      (received on a cascade port configured for extended Global QoS mode)
*                                      (APPLICABLE RANGES: 0..7).
* @param[in] dp                       - drop precedence assigned to the packet for tail drop.
*                                      (received on a cascade port configured for extended Global QoS mode)
*
* @param[out] multiTargetTCQueuePtr    - the multi-target TC queue. (APPLICABLE RANGES: 0..3).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpTcDpToMultiTargetTcQueueMapGet
(
    IN  GT_U8              devNum,
    IN  GT_U32             tc,
    IN  CPSS_DP_LEVEL_ENT  dp,
    OUT  GT_U32            *multiTargetTCQueuePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpTcDpToMultiTargetTcQueueMapGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tc, dp, multiTargetTCQueuePtr));

    rc = internal_cpssDxChIpTcDpToMultiTargetTcQueueMapGet(devNum, tc, dp, multiTargetTCQueuePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tc, dp, multiTargetTCQueuePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMultiTargetQueueFullDropCntGet function
* @endinternal
*
* @brief   Get the multi target queue full drop packet counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] dropPktsPtr              - the number of counted dropped packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMultiTargetQueueFullDropCntGet
(
    IN   GT_U8    devNum,
    OUT  GT_U32   *dropPktsPtr
)
{
    return cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet(devNum,
                                               CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                             dropPktsPtr);
}

/**
* @internal cpssDxChIpMultiTargetQueueFullDropCntGet function
* @endinternal
*
* @brief   Get the multi target queue full drop packet counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] dropPktsPtr              - the number of counted dropped packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMultiTargetQueueFullDropCntGet
(
    IN   GT_U8    devNum,
    OUT  GT_U32   *dropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetQueueFullDropCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropPktsPtr));

    rc = internal_cpssDxChIpMultiTargetQueueFullDropCntGet(devNum, dropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMultiTargetQueueFullDropCntSet function
* @endinternal
*
* @brief   set the multi target queue full drop packet counter.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - the device number
* @param[in] dropPkts                 - the counter value to set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMultiTargetQueueFullDropCntSet
(
    IN GT_U8     devNum,
    IN GT_U32    dropPkts
)
{
    return cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet(devNum,
                                               CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                             dropPkts);
}

/**
* @internal cpssDxChIpMultiTargetQueueFullDropCntSet function
* @endinternal
*
* @brief   set the multi target queue full drop packet counter.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - the device number
* @param[in] dropPkts                 - the counter value to set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMultiTargetQueueFullDropCntSet
(
    IN GT_U8     devNum,
    IN GT_U32    dropPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetQueueFullDropCntSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropPkts));

    rc = internal_cpssDxChIpMultiTargetQueueFullDropCntSet(devNum, dropPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropPkts));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMultiTargetQueuePerQueueFullDropCntGet function
* @endinternal
*
* @brief   Get the multi target queue full drop packet counter per MC queue.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - the device number
* @param[in] multiTargetMcQueue       - the multi-target MC queue.(APPLICABLE RANGES: 0..3).
*
* @param[out] dropPktsPtr             - (pointer to) the number of counted dropped MC packets per queue.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out-of-range parameter
*/
static GT_STATUS internal_cpssDxChIpMultiTargetQueuePerQueueFullDropCntGet
(
    IN   GT_U8                  devNum,
    IN   GT_U32                 multiTargetMcQueue,
    OUT  GT_U32                 *dropPktsPtr
)
{
    return cpssDxChIpPortGroupMultiTargetQueuePerQueueFullDropCntGet(devNum,CPSS_PORT_GROUP_UNAWARE_MODE_CNS,multiTargetMcQueue,dropPktsPtr);
}

/**
* @internal cpssDxChIpMultiTargetQueuePerQueueFullDropCntGet function
* @endinternal
*
* @brief   Get the multi target queue full drop packet counter per MC queue.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - the device number
* @param[in] multiTargetMcQueue       - the multi-target MC queue.(APPLICABLE RANGES: 0..3).
*
* @param[out] dropPktsPtr             - (pointer to) the number of counted dropped MC packets per queue.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out-of-range parameter
*/
GT_STATUS cpssDxChIpMultiTargetQueuePerQueueFullDropCntGet
(
    IN   GT_U8                  devNum,
    IN   GT_U32                 multiTargetMcQueue,
    OUT  GT_U32                 *dropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetQueuePerQueueFullDropCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, multiTargetMcQueue, dropPktsPtr));

    rc = internal_cpssDxChIpMultiTargetQueuePerQueueFullDropCntGet(devNum, multiTargetMcQueue, dropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, multiTargetMcQueue, dropPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMultiTargetTCQueueSchedModeSet function
* @endinternal
*
* @brief   sets the multi-target TC queue scheduling configuration.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] multiTargetTcQueue       - the multi-target TC queue.(APPLICABLE RANGES: 0..3).
* @param[in] schedulingMode           - the scheduling mode.
*                                       (APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2)
* @param[in] queueWeight              - the queue weight for SDWRR scheduler (APPLICABLE RANGES: 0..255)
*                                       (for devices: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*                                       relvant only if schedMode =
*                                       CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E).
* @param[in] queuePriority            - the queue priority (APPLICABLE RANGES: 0..3)
*                                       (APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out-of-range parameter
*/
static GT_STATUS internal_cpssDxChIpMultiTargetTCQueueSchedModeSet
(
    IN  GT_U8                                   devNum,
    IN  GT_U32                                  multiTargetTcQueue,
    IN  CPSS_DXCH_IP_MT_TC_QUEUE_SCHED_MODE_ENT schedulingMode,
    IN  GT_U32                                  queueWeight,
    IN  GT_U32                                  queuePriority
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32     value, offset;       /* value to write */
    GT_U32     fieldLength;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
            multitargetTCQueuesWeightConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesWeightReg;
    }

    if(multiTargetTcQueue > 3 )
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum) && queuePriority > 3)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    /*if schedMode = CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E,
            write weight value */
    if (schedulingMode == CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E || (PRV_CPSS_SIP_6_CHECK_MAC(devNum)))
    {
        /* find offset of weight field according to mtTcQueue */
        offset = multiTargetTcQueue *8;

        if(GT_FALSE == CHECK_BITS_DATA_RANGE_MAC(queueWeight,8))
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        /* write weight value */
        rc = prvCpssHwPpSetRegField(devNum,regAddr,
                             offset,8,queueWeight);
        if (rc != GT_OK)
            return rc;
    }

    /* find offset of schedulingMode field according to multiTargetTcQueue */
    offset = multiTargetTcQueue *1;
    fieldLength = 1;

    /* find enable/disable value to write according to schedulingMode */
    switch (schedulingMode)
    {
        case CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E:
            value = 0;
            break;
        case CPSS_DXCH_IP_MT_TC_QUEUE_SP_SCHED_MODE_E:
            value = 1;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
            multitargetTCQueuesPriorityConfig;

            offset = multiTargetTcQueue * 2;
            fieldLength = 2;
            value = queuePriority;
        }
        else
        {
            regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
                multitargetTCQueuesStrictPriorityEnableConfig;
        }
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesSpEnableReg;
    }

    /* write schedulingMode value */
    rc = prvCpssHwPpSetRegField(devNum,regAddr,offset,fieldLength,value);

    return rc;
}

/**
* @internal cpssDxChIpMultiTargetTCQueueSchedModeSet function
* @endinternal
*
* @brief   sets the multi-target TC queue scheduling configuration.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] multiTargetTcQueue       - the multi-target TC queue.(APPLICABLE RANGES: 0..3).
* @param[in] schedulingMode           - the scheduling mode.
*                                       (APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2)
* @param[in] queueWeight              - the queue weight for SDWRR scheduler (APPLICABLE RANGES: 0..255)
*                                       (for devices: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*                                       relvant only if schedMode =
*                                       CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E).
* @param[in] queuePriority            - the queue priority (APPLICABLE RANGES: 0..3)
*                                       (APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out-of-range parameter
*/
GT_STATUS cpssDxChIpMultiTargetTCQueueSchedModeSet
(
    IN  GT_U8                                   devNum,
    IN  GT_U32                                  multiTargetTcQueue,
    IN  CPSS_DXCH_IP_MT_TC_QUEUE_SCHED_MODE_ENT schedulingMode,
    IN  GT_U32                                  queueWeight,
    IN  GT_U32                                  queuePriority
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetTCQueueSchedModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, multiTargetTcQueue, schedulingMode, queueWeight, queuePriority));

    rc = internal_cpssDxChIpMultiTargetTCQueueSchedModeSet(devNum, multiTargetTcQueue, schedulingMode, queueWeight, queuePriority);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, multiTargetTcQueue, schedulingMode, queueWeight, queuePriority));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMultiTargetTCQueueSchedModeGet function
* @endinternal
*
* @brief   gets the multi-target TC queue scheduling configuration.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] multiTargetTcQueue       - the multi-target TC queue.(APPLICABLE RANGES: 0..3).
*
* @param[out] schedulingModePtr       - (pointer to) the scheduling mode.
*                                       (APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2)
* @param[out] queueWeightPtr          - (pointer to) the queue weight for SDWRR scheduler
*                                       (for devices: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*                                       relvant only if schedMode =
*                                       CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E).
* @param[out] queuePriorityPtr        - (pointer to) the queue priority (APPLICABLE RANGES: 0..3)
*                                       (APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL ptr
*/
static GT_STATUS internal_cpssDxChIpMultiTargetTCQueueSchedModeGet
(
    IN  GT_U8                                   devNum,
    IN  GT_U32                                  multiTargetTcQueue,
    OUT CPSS_DXCH_IP_MT_TC_QUEUE_SCHED_MODE_ENT *schedulingModePtr,
    OUT GT_U32                                  *queueWeightPtr,
    OUT GT_U32                                  *queuePriorityPtr
)
{
    GT_U32     regAddr;              /* register address  */
    GT_STATUS  rc = GT_OK;           /* return code  */
    GT_U32     hwValue = 0;              /* hw value */
    GT_U32     offset = 0;               /* offset */
    GT_U32     fieldLength=0;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(schedulingModePtr);
    CPSS_NULL_PTR_CHECK_MAC(queueWeightPtr);
    CPSS_NULL_PTR_CHECK_MAC(queuePriorityPtr);

    if(multiTargetTcQueue > 3 )
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    /* find offset of schedulingMode field according to multiTargetTcQueue */
    offset = multiTargetTcQueue *1;
    fieldLength = 1;

    /* read schedulingMode value */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
            multitargetTCQueuesPriorityConfig;

            offset = multiTargetTcQueue * 2;
            fieldLength = 2;
        }
        else
        {
            regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
                multitargetTCQueuesStrictPriorityEnableConfig;
        }
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesSpEnableReg;
    }

    rc = prvCpssHwPpGetRegField(devNum,regAddr,offset,fieldLength,&hwValue);
    if (rc != GT_OK)
        return rc;

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        *queuePriorityPtr = hwValue;
        *schedulingModePtr = 0; /* not relevant */
    }
    else
    {
        *queuePriorityPtr = 0; /* not relevant */
        switch (hwValue)
        {
            case 0:
                *schedulingModePtr = CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E;
                break;
            case 1:
                *schedulingModePtr = CPSS_DXCH_IP_MT_TC_QUEUE_SP_SCHED_MODE_E;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }

    /*if schedMode = CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E,
            read weight value */
    if ( *schedulingModePtr == CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E || PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
                multitargetTCQueuesWeightConfig;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesWeightReg;
        }

        /* find offset of weight field according to mtTcQueue */
        offset = multiTargetTcQueue *8;

        /* read weight value */
        rc = prvCpssHwPpGetRegField(devNum,regAddr,
                             offset,8,queueWeightPtr);
        if (rc != GT_OK)
            return rc;
    }

    return rc;
}

/**
* @internal cpssDxChIpMultiTargetTCQueueSchedModeGet function
* @endinternal
*
* @brief   gets the multi-target TC queue scheduling configuration.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] multiTargetTcQueue       - the multi-target TC queue.(APPLICABLE RANGES: 0..3).
*
* @param[out] schedulingModePtr       - (pointer to) the scheduling mode.
*                                       (APPLICABLE DEVICES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2)
* @param[out] queueWeightPtr          - (pointer to) the queue weight for SDWRR scheduler
*                                       (for devices: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*                                       relvant only if schedMode =
*                                       CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E).
* @param[out] queuePriorityPtr        - (pointer to) the queue priority (APPLICABLE RANGES: 0..3)
*                                       (APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL ptr
*/
GT_STATUS cpssDxChIpMultiTargetTCQueueSchedModeGet
(
    IN  GT_U8                                   devNum,
    IN  GT_U32                                  multiTargetTcQueue,
    OUT CPSS_DXCH_IP_MT_TC_QUEUE_SCHED_MODE_ENT *schedulingModePtr,
    OUT GT_U32                                  *queueWeightPtr,
    OUT GT_U32                                  *queuePriorityPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetTCQueueSchedModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, multiTargetTcQueue, schedulingModePtr, queueWeightPtr, queuePriorityPtr));

    rc = internal_cpssDxChIpMultiTargetTCQueueSchedModeGet(devNum, multiTargetTcQueue, schedulingModePtr, queueWeightPtr, queuePriorityPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, multiTargetTcQueue, schedulingModePtr, queueWeightPtr, queuePriorityPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpBridgeServiceEnable function
* @endinternal
*
* @brief   enable/disable a router bridge service.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] bridgeService            - the router bridge service
* @param[in] enableDisableMode        - Enable/Disable mode of this function (weather
*                                      to enable/disable for ipv4/ipv6/arp)
* @param[in] enableService            - weather to enable the service for the above more.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpBridgeServiceEnable
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENT                        bridgeService,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENABLE_DISABLE_MODE_ENT    enableDisableMode,
    IN  GT_BOOL                                             enableService
)
{
    GT_U32      value;      /* value to write */
    GT_STATUS   rc;         /* function return code */

    GT_U32    regAddr;              /* register address                   */
    GT_U32    offset = 0;
    GT_U32    offsetShift;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    offsetShift = PRV_CPSS_SIP6_10_ROUTER_GLB_REG_OFFSET_SHIFT(devNum);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }

    value = (enableService == GT_TRUE) ? 1:0;

    /* update enable values according to bridgeService */
    switch (bridgeService)
    {
        case CPSS_DXCH_IP_HEADER_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 14 + offsetShift;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 15 + offsetShift;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E: /* Not Valid value. */

                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

        case CPSS_DXCH_IP_UC_RPF_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 8 + offsetShift;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 10 + offsetShift;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                    /* update arpEnable value */
                    offset = 9 + offsetShift;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

        case CPSS_DXCH_IP_SIP_SA_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 11 + offsetShift;
                    break;
                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 13 + offsetShift;
                    break;
                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                    /* update arpEnable value */
                    offset = 12 + offsetShift;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

    case CPSS_DXCH_IP_SIP_FILTER_BRG_SERVICE_E:
        switch(enableDisableMode)
        {
            case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                /* update ipv4Enable value */
                offset = 16 + offsetShift;
                break;

            case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                /* update ipv6Enable value */
                offset = 18 + offsetShift;
                break;

            case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                /* update arpEnable value */
                offset = 17 + offsetShift;
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        break;

    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpSetRegField(devNum,regAddr,offset,1,value);
    return rc;
}

/**
* @internal cpssDxChIpBridgeServiceEnable function
* @endinternal
*
* @brief   enable/disable a router bridge service.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] bridgeService            - the router bridge service
* @param[in] enableDisableMode        - Enable/Disable mode of this function (weather
*                                      to enable/disable for ipv4/ipv6/arp)
* @param[in] enableService            - weather to enable the service for the above more.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpBridgeServiceEnable
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENT                        bridgeService,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENABLE_DISABLE_MODE_ENT    enableDisableMode,
    IN  GT_BOOL                                             enableService
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpBridgeServiceEnable);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, bridgeService, enableDisableMode, enableService));

    rc = internal_cpssDxChIpBridgeServiceEnable(devNum, bridgeService, enableDisableMode, enableService);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, bridgeService, enableDisableMode, enableService));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpBridgeServiceEnableGet function
* @endinternal
*
* @brief   enable/disable a router bridge service.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] bridgeService            - the router bridge service
* @param[in] enableDisableMode        - Enable/Disable mode of this function (weather
*                                      to enable/disable for ipv4/ipv6/arp)
*
* @param[out] enableServicePtr         - weather to enable the service for the above more.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL pointer
*/
static GT_STATUS internal_cpssDxChIpBridgeServiceEnableGet
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENT                        bridgeService,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENABLE_DISABLE_MODE_ENT    enableDisableMode,
    OUT GT_BOOL                                             *enableServicePtr
)
{
    GT_U32      hwValue;    /* read hwValue  */
    GT_STATUS   rc;         /* function return code */

    GT_U32    regAddr;              /* register address */
    GT_U32    offset = 0;
    GT_U32    offsetShift;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enableServicePtr);

    offsetShift = PRV_CPSS_SIP6_10_ROUTER_GLB_REG_OFFSET_SHIFT(devNum);

    /* update enable values according to bridgeService */
    switch (bridgeService)
    {
        case CPSS_DXCH_IP_HEADER_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 14 + offsetShift;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 15 + offsetShift;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E: /* Not Valid value. */

                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

        case CPSS_DXCH_IP_UC_RPF_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 8 + offsetShift;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 10 + offsetShift;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                    /* update arpEnable value */
                    offset = 9 + offsetShift;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

        case CPSS_DXCH_IP_SIP_SA_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 11 + offsetShift;
                    break;
                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 13 + offsetShift;
                    break;
                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                    /* update arpEnable value */
                    offset = 12 + offsetShift;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

    case CPSS_DXCH_IP_SIP_FILTER_BRG_SERVICE_E:
        switch(enableDisableMode)
        {
            case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                /* update ipv4Enable value */
                offset = 16 + offsetShift;
                break;

            case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                /* update ipv6Enable value */
                offset = 18 + offsetShift;
                break;

            case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                /* update arpEnable value */
                offset = 17 + offsetShift;
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        break;

    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 1, &hwValue);

    *enableServicePtr = (0 == hwValue) ? GT_FALSE : GT_TRUE;

    return rc;
}

/**
* @internal cpssDxChIpBridgeServiceEnableGet function
* @endinternal
*
* @brief   enable/disable a router bridge service.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] bridgeService            - the router bridge service
* @param[in] enableDisableMode        - Enable/Disable mode of this function (weather
*                                      to enable/disable for ipv4/ipv6/arp)
*
* @param[out] enableServicePtr         - weather to enable the service for the above more.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL pointer
*/
GT_STATUS cpssDxChIpBridgeServiceEnableGet
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENT                        bridgeService,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENABLE_DISABLE_MODE_ENT    enableDisableMode,
    OUT GT_BOOL                                             *enableServicePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpBridgeServiceEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, bridgeService, enableDisableMode, enableServicePtr));

    rc = internal_cpssDxChIpBridgeServiceEnableGet(devNum, bridgeService, enableDisableMode, enableServicePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, bridgeService, enableDisableMode, enableServicePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet function
* @endinternal
*
* @brief   Set exception counter for Special Services for Bridged Traffic.
*         it counts the number of Bridged packets failing any of the following checks:
*         - SIP Filter check for bridged IPv4/6 packets
*         - IP Header Check for bridged IPv4/6 packets
*         - Unicast RPF check for bridged IPv4/6 and ARP packets
*         - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] routerBridgedExceptionPkts - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad devNum
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet
(
    IN GT_U8                devNum,
    IN GT_PORT_GROUPS_BMP   portGroupsBmp,
    IN GT_U32               routerBridgedExceptionPkts
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerBridgedPktsExceptionCntr.routerBridgedPktExceptionsCntr;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerBridgedPktExcptCnt;
    }

    /* set the counter */
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32, routerBridgedExceptionPkts);

    return rc;
}

/**
* @internal cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet function
* @endinternal
*
* @brief   Set exception counter for Special Services for Bridged Traffic.
*         it counts the number of Bridged packets failing any of the following checks:
*         - SIP Filter check for bridged IPv4/6 packets
*         - IP Header Check for bridged IPv4/6 packets
*         - Unicast RPF check for bridged IPv4/6 and ARP packets
*         - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] routerBridgedExceptionPkts - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad devNum
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet
(
    IN GT_U8                devNum,
    IN GT_PORT_GROUPS_BMP   portGroupsBmp,
    IN GT_U32               routerBridgedExceptionPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, routerBridgedExceptionPkts));

    rc = internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet(devNum, portGroupsBmp, routerBridgedExceptionPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, routerBridgedExceptionPkts));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet function
* @endinternal
*
* @brief   Get exception counter for Special Services for Bridged Traffic.
*         it counts the number of Bridged packets failing any of the following checks:
*         - SIP Filter check for bridged IPv4/6 packets
*         - IP Header Check for bridged IPv4/6 packets
*         - Unicast RPF check for bridged IPv4/6 and ARP packets
*         - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] routerBridgedExceptionPktsPtr - the number of counted router bridged
*                                      exception  packets.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad devNum
* @retval GT_BAD_PTR               - on illegal pointer value
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *routerBridgedExceptionPktsPtr
)
{
    GT_STATUS rc;                   /* return code                        */
    GT_U32    regAddr;              /* register address                   */

    CPSS_NULL_PTR_CHECK_MAC(routerBridgedExceptionPktsPtr);

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);


    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerBridgedPktsExceptionCntr.routerBridgedPktExceptionsCntr;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerBridgedPktExcptCnt;
    }

    rc = prvCpssPortGroupsBmpCounterSummary(devNum,
                                                portGroupsBmp,
                                                regAddr,
                                                0,
                                                32,
                                                routerBridgedExceptionPktsPtr,
                                                NULL);
    return rc;
}

/**
* @internal cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet function
* @endinternal
*
* @brief   Get exception counter for Special Services for Bridged Traffic.
*         it counts the number of Bridged packets failing any of the following checks:
*         - SIP Filter check for bridged IPv4/6 packets
*         - IP Header Check for bridged IPv4/6 packets
*         - Unicast RPF check for bridged IPv4/6 and ARP packets
*         - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] routerBridgedExceptionPktsPtr - the number of counted router bridged
*                                      exception  packets.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad devNum
* @retval GT_BAD_PTR               - on illegal pointer value
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *routerBridgedExceptionPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, routerBridgedExceptionPktsPtr));

    rc = internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet(devNum, portGroupsBmp, routerBridgedExceptionPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, routerBridgedExceptionPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterBridgedPacketsExceptionCntGet function
* @endinternal
*
* @brief   Get exception counter for Special Services for Bridged Traffic.
*         it counts the number of Bridged packets failing any of the following checks:
*         - SIP Filter check for bridged IPv4/6 packets
*         - IP Header Check for bridged IPv4/6 packets
*         - Unicast RPF check for bridged IPv4/6 and ARP packets
*         - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] routerBridgedExceptionPktsPtr - the number of counted router bridged
*                                      exception  packets.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad devNum
* @retval GT_BAD_PTR               - on illegal pointer value
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterBridgedPacketsExceptionCntGet
(
    IN   GT_U8    devNum,
    OUT  GT_U32   *routerBridgedExceptionPktsPtr
)
{
    return cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet(devNum,
                                                                  CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                                  routerBridgedExceptionPktsPtr);
}

/**
* @internal cpssDxChIpRouterBridgedPacketsExceptionCntGet function
* @endinternal
*
* @brief   Get exception counter for Special Services for Bridged Traffic.
*         it counts the number of Bridged packets failing any of the following checks:
*         - SIP Filter check for bridged IPv4/6 packets
*         - IP Header Check for bridged IPv4/6 packets
*         - Unicast RPF check for bridged IPv4/6 and ARP packets
*         - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] routerBridgedExceptionPktsPtr - the number of counted router bridged
*                                      exception  packets.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad devNum
* @retval GT_BAD_PTR               - on illegal pointer value
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterBridgedPacketsExceptionCntGet
(
    IN   GT_U8    devNum,
    OUT  GT_U32   *routerBridgedExceptionPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterBridgedPacketsExceptionCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, routerBridgedExceptionPktsPtr));

    rc = internal_cpssDxChIpRouterBridgedPacketsExceptionCntGet(devNum, routerBridgedExceptionPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, routerBridgedExceptionPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpRouterBridgedPacketsExceptionCntSet function
* @endinternal
*
* @brief   Set exception counter for Special Services for Bridged Traffic.
*         it counts the number of Bridged packets failing any of the following checks:
*         - SIP Filter check for bridged IPv4/6 packets
*         - IP Header Check for bridged IPv4/6 packets
*         - Unicast RPF check for bridged IPv4/6 and ARP packets
*         - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] routerBridgedExceptionPkts - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad devNum
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterBridgedPacketsExceptionCntSet
(
    IN   GT_U8    devNum,
    IN  GT_U32    routerBridgedExceptionPkts
)
{
    return cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet(devNum,
                                                                  CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                                  routerBridgedExceptionPkts);
}

/**
* @internal cpssDxChIpRouterBridgedPacketsExceptionCntSet function
* @endinternal
*
* @brief   Set exception counter for Special Services for Bridged Traffic.
*         it counts the number of Bridged packets failing any of the following checks:
*         - SIP Filter check for bridged IPv4/6 packets
*         - IP Header Check for bridged IPv4/6 packets
*         - Unicast RPF check for bridged IPv4/6 and ARP packets
*         - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] routerBridgedExceptionPkts - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad devNum
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterBridgedPacketsExceptionCntSet
(
    IN   GT_U8    devNum,
    IN  GT_U32    routerBridgedExceptionPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterBridgedPacketsExceptionCntSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, routerBridgedExceptionPkts));

    rc = internal_cpssDxChIpRouterBridgedPacketsExceptionCntSet(devNum, routerBridgedExceptionPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, routerBridgedExceptionPkts));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllBridgeEnable function
* @endinternal
*
* @brief   enable/disable MLL based bridging.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] mllBridgeEnable          - enable /disable MLL based bridging.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllBridgeEnable
(
    IN   GT_U8      devNum,
    IN   GT_BOOL    mllBridgeEnable
)
{

    GT_U32    regAddr;          /* register address   */
    GT_U32    data;             /* value to write     */
    GT_STATUS rc;               /* return code        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /* Get address of MLL Global Control Register */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLGlobalCtrl.MLLGlobalCtrl;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllGlobalReg;
    }

    data = (GT_TRUE == mllBridgeEnable)? 1:0;

    rc = prvCpssHwPpSetRegField(devNum,regAddr,13,1,data);
    return rc;
}

/**
* @internal cpssDxChIpMllBridgeEnable function
* @endinternal
*
* @brief   enable/disable MLL based bridging.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] mllBridgeEnable          - enable /disable MLL based bridging.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMllBridgeEnable
(
    IN   GT_U8      devNum,
    IN   GT_BOOL    mllBridgeEnable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllBridgeEnable);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mllBridgeEnable));

    rc = internal_cpssDxChIpMllBridgeEnable(devNum, mllBridgeEnable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mllBridgeEnable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllBridgeEnableGet function
* @endinternal
*
* @brief   get state of MLL based bridging.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] mllBridgeEnablePtr       - enable /disable MLL based bridging.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL prt
*/
static GT_STATUS internal_cpssDxChIpMllBridgeEnableGet
(
    IN    GT_U8      devNum,
    OUT   GT_BOOL    *mllBridgeEnablePtr
)
{
    GT_U32    regAddr;          /* register address   */
    GT_U32    hwData;             /* value to write     */
    GT_STATUS rc;               /* return code        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(mllBridgeEnablePtr);

    /* Get address of MLL Global Control Register */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLGlobalCtrl.MLLGlobalCtrl;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllGlobalReg;
    }

    rc = prvCpssHwPpGetRegField(devNum,regAddr,13,1,&hwData);
    if(GT_OK != rc)
        return rc;

    *mllBridgeEnablePtr = (0 == hwData)? GT_FALSE : GT_TRUE;

    return GT_OK;
}

/**
* @internal cpssDxChIpMllBridgeEnableGet function
* @endinternal
*
* @brief   get state of MLL based bridging.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] mllBridgeEnablePtr       - enable /disable MLL based bridging.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL prt
*/
GT_STATUS cpssDxChIpMllBridgeEnableGet
(
    IN    GT_U8      devNum,
    OUT   GT_BOOL    *mllBridgeEnablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllBridgeEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mllBridgeEnablePtr));

    rc = internal_cpssDxChIpMllBridgeEnableGet(devNum, mllBridgeEnablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mllBridgeEnablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMultiTargetRateShaperSet function
* @endinternal
*
* @brief   set the Multi target Rate shaper params.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - the device number
* @param[in] multiTargetRateShaperEnable - weather to enable (disable) the Multi
*                                      target Rate shaper
* @param[in] windowSize               - if enabled then this is the shaper window size (APPLICABLE RANGES: 0..0xFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMultiTargetRateShaperSet
(
    IN   GT_U8      devNum,
    IN   GT_BOOL    multiTargetRateShaperEnable,
    IN   GT_U32     windowSize
)
{
    return cpssDxChIpPortGroupMultiTargetRateShaperSet(devNum,
                                               CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                               multiTargetRateShaperEnable,
                                               windowSize);
}

/**
* @internal cpssDxChIpMultiTargetRateShaperSet function
* @endinternal
*
* @brief   set the Multi target Rate shaper params.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - the device number
* @param[in] multiTargetRateShaperEnable - weather to enable (disable) the Multi
*                                      target Rate shaper
* @param[in] windowSize               - if enabled then this is the shaper window size (APPLICABLE RANGES: 0..0xFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMultiTargetRateShaperSet
(
    IN   GT_U8      devNum,
    IN   GT_BOOL    multiTargetRateShaperEnable,
    IN   GT_U32     windowSize
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetRateShaperSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, multiTargetRateShaperEnable, windowSize));

    rc = internal_cpssDxChIpMultiTargetRateShaperSet(devNum, multiTargetRateShaperEnable, windowSize);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, multiTargetRateShaperEnable, windowSize));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMultiTargetRateShaperGet function
* @endinternal
*
* @brief   set the Multi target Rate shaper params.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - the device number
*
* @param[out] multiTargetRateShaperEnablePtr - weather to enable (disable) the Multi
*                                      target Rate shaper
* @param[out] windowSizePtr            - if enabled then this is the shaper window size
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMultiTargetRateShaperGet
(
    IN    GT_U8      devNum,
    OUT   GT_BOOL    *multiTargetRateShaperEnablePtr,
    OUT   GT_U32     *windowSizePtr
)
{
    return cpssDxChIpPortGroupMultiTargetRateShaperGet(devNum,
                                               CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                               multiTargetRateShaperEnablePtr,
                                               windowSizePtr);
}

/**
* @internal cpssDxChIpMultiTargetRateShaperGet function
* @endinternal
*
* @brief   set the Multi target Rate shaper params.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - the device number
*
* @param[out] multiTargetRateShaperEnablePtr - weather to enable (disable) the Multi
*                                      target Rate shaper
* @param[out] windowSizePtr            - if enabled then this is the shaper window size
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMultiTargetRateShaperGet
(
    IN    GT_U8      devNum,
    OUT   GT_BOOL    *multiTargetRateShaperEnablePtr,
    OUT   GT_U32     *windowSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetRateShaperGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, multiTargetRateShaperEnablePtr, windowSizePtr));

    rc = internal_cpssDxChIpMultiTargetRateShaperGet(devNum, multiTargetRateShaperEnablePtr, windowSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, multiTargetRateShaperEnablePtr, windowSizePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMultiTargetUcSchedModeSet function
* @endinternal
*
* @brief   set the Multi target/unicast sheduler mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] ucSPEnable               weather the Unicast uses SP , if GT_FALSE then it means
*                                      both the Unicast and multi target uses DSWRR scheduling
* @param[in] ucWeight                 - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                                      is the unicast weight (APPLICABLE RANGES: 0..255).
* @param[in] mcWeight                 - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                                      is the multi target weight (APPLICABLE RANGES: 0..255).
* @param[in] schedMtu                 - The MTU used by the scheduler
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMultiTargetUcSchedModeSet
(
    IN   GT_U8                              devNum,
    IN   GT_BOOL                            ucSPEnable,
    IN   GT_U32                             ucWeight,
    IN   GT_U32                             mcWeight,
    IN   CPSS_DXCH_IP_MT_UC_SCHED_MTU_ENT   schedMtu
)
{
    GT_U32    regAddr;              /* register address  */
    GT_U32    data;                 /* value to write    */
    GT_STATUS rc;                   /* return code       */
    GT_U32    schedMtuData;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /* Get address of Multi Target Vs. Unicast SDWRR and Strict Priority Scheduler register */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetVsUcSDWRRAndStrictPriorityScheduler.
            mcUcSDWRRAndStrictPriorityConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtUcSchedulerModeReg;
    }

    switch (schedMtu)
    {
        case CPSS_DXCH_IP_MT_UC_SCHED_MTU_2K_E:
            schedMtuData = 0;
            break;
        case CPSS_DXCH_IP_MT_UC_SCHED_MTU_8K_E:
            schedMtuData = 1;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    data = (GT_TRUE == ucSPEnable)? 1:0;

    /* Enable/disable  Strict Priority for Unicast packets*/
    rc = prvCpssHwPpSetRegField(devNum,regAddr,16,1,data);
    if (GT_OK != rc)
        return rc;

    if (GT_FALSE == ucSPEnable)
    {
        if ( GT_FALSE == CHECK_BITS_DATA_RANGE_MAC(ucWeight,8))
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

        if ( GT_FALSE == CHECK_BITS_DATA_RANGE_MAC(mcWeight,8))
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

        rc = prvCpssHwPpSetRegField(devNum,regAddr,8,8,ucWeight);
        if (GT_OK != rc)
            return rc;

        rc = prvCpssHwPpSetRegField(devNum,regAddr,0,8,mcWeight);
        if (GT_OK != rc)
            return rc;
    }

    rc = prvCpssHwPpSetRegField(devNum,regAddr,17,1,schedMtuData);

    return rc;
}

/**
* @internal cpssDxChIpMultiTargetUcSchedModeSet function
* @endinternal
*
* @brief   set the Multi target/unicast sheduler mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] ucSPEnable               weather the Unicast uses SP , if GT_FALSE then it means
*                                      both the Unicast and multi target uses DSWRR scheduling
* @param[in] ucWeight                 - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                                      is the unicast weight (APPLICABLE RANGES: 0..255).
* @param[in] mcWeight                 - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                                      is the multi target weight (APPLICABLE RANGES: 0..255).
* @param[in] schedMtu                 - The MTU used by the scheduler
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMultiTargetUcSchedModeSet
(
    IN   GT_U8                              devNum,
    IN   GT_BOOL                            ucSPEnable,
    IN   GT_U32                             ucWeight,
    IN   GT_U32                             mcWeight,
    IN   CPSS_DXCH_IP_MT_UC_SCHED_MTU_ENT   schedMtu
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetUcSchedModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ucSPEnable, ucWeight, mcWeight, schedMtu));

    rc = internal_cpssDxChIpMultiTargetUcSchedModeSet(devNum, ucSPEnable, ucWeight, mcWeight, schedMtu);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ucSPEnable, ucWeight, mcWeight, schedMtu));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMultiTargetUcSchedModeGet function
* @endinternal
*
* @brief   get the Multi target/unicast sheduler mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] ucSPEnablePtr            weather the Unicast uses SP , if GT_FALSE then it means
*                                      both the Unicast and multi target uses DSWRR scheduling
* @param[out] ucWeightPtr              - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                                      is the unicast weight (APPLICABLE RANGES: 0..255).
* @param[out] mcWeightPtr              - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                                      is the multi target weight (APPLICABLE RANGES: 0..255).
* @param[out] schedMtuPtr              - The MTU used by the scheduler
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL ptr
* @retval GT_BAD_STATE             - on invalid hardware value read
*/
static GT_STATUS internal_cpssDxChIpMultiTargetUcSchedModeGet
(
    IN   GT_U8                              devNum,
    OUT  GT_BOOL                            *ucSPEnablePtr,
    OUT  GT_U32                             *ucWeightPtr,
    OUT  GT_U32                             *mcWeightPtr,
    OUT  CPSS_DXCH_IP_MT_UC_SCHED_MTU_ENT   *schedMtuPtr
)
{
    GT_U32    regAddr;                /* register address  */
    GT_U32    hwData;                 /* hw value   */
    GT_STATUS rc = GT_OK;             /* return code   */


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(ucSPEnablePtr);
    CPSS_NULL_PTR_CHECK_MAC(ucWeightPtr);
    CPSS_NULL_PTR_CHECK_MAC(mcWeightPtr);
    CPSS_NULL_PTR_CHECK_MAC(schedMtuPtr);

    /* Get address of Multi Target Vs. Unicast SDWRR and Strict Priority Scheduler register */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetVsUcSDWRRAndStrictPriorityScheduler.
            mcUcSDWRRAndStrictPriorityConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtUcSchedulerModeReg;
    }

    /* get MTU used by the scheduler */
    rc = prvCpssHwPpGetRegField(devNum,regAddr,17,1,&hwData);
    if (GT_OK != rc)
        return rc;

    switch (hwData)
    {
        case 0:
            *schedMtuPtr = CPSS_DXCH_IP_MT_UC_SCHED_MTU_2K_E;
            break;
        case 1 :
            *schedMtuPtr = CPSS_DXCH_IP_MT_UC_SCHED_MTU_8K_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* get ucSPEnable */
    rc = prvCpssHwPpGetRegField(devNum,regAddr,16,1,&hwData);
    if (GT_OK != rc)
        return rc;

    *ucSPEnablePtr = (0 == hwData) ? GT_FALSE : GT_TRUE;

    if (GT_FALSE == *ucSPEnablePtr)
    {
        /* get ucWeight */
        rc = prvCpssHwPpGetRegField(devNum,regAddr,8,8,ucWeightPtr);
        if (GT_OK != rc)
            return rc;

        /* get mcWeight */
        rc = prvCpssHwPpGetRegField(devNum,regAddr,0,8,mcWeightPtr);
        if (GT_OK != rc)
            return rc;
    }

    return rc;
}

/**
* @internal cpssDxChIpMultiTargetUcSchedModeGet function
* @endinternal
*
* @brief   get the Multi target/unicast sheduler mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] ucSPEnablePtr            weather the Unicast uses SP , if GT_FALSE then it means
*                                      both the Unicast and multi target uses DSWRR scheduling
* @param[out] ucWeightPtr              - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                                      is the unicast weight (APPLICABLE RANGES: 0..255).
* @param[out] mcWeightPtr              - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                                      is the multi target weight (APPLICABLE RANGES: 0..255).
* @param[out] schedMtuPtr              - The MTU used by the scheduler
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL ptr
* @retval GT_BAD_STATE             - on invalid hardware value read
*/
GT_STATUS cpssDxChIpMultiTargetUcSchedModeGet
(
    IN   GT_U8                              devNum,
    OUT  GT_BOOL                            *ucSPEnablePtr,
    OUT  GT_U32                             *ucWeightPtr,
    OUT  GT_U32                             *mcWeightPtr,
    OUT  CPSS_DXCH_IP_MT_UC_SCHED_MTU_ENT   *schedMtuPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetUcSchedModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ucSPEnablePtr, ucWeightPtr, mcWeightPtr, schedMtuPtr));

    rc = internal_cpssDxChIpMultiTargetUcSchedModeGet(devNum, ucSPEnablePtr, ucWeightPtr, mcWeightPtr, schedMtuPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ucSPEnablePtr, ucWeightPtr, mcWeightPtr, schedMtuPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpArpBcModeSet function
* @endinternal
*
* @brief   set a arp broadcast mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] arpBcMode                - the arp broadcast command. Possible Commands:
*                                      CPSS_PACKET_CMD_NONE_E,CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                                      CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note
*       GalTis:
*
*/
static GT_STATUS internal_cpssDxChIpArpBcModeSet
(
    IN GT_U8               devNum,
    IN CPSS_PACKET_CMD_ENT arpBcMode
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    data;
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /* Get address of IPv4 Control Register0 */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg0;
    }

    switch (arpBcMode)
    {
        case CPSS_PACKET_CMD_NONE_E:
            data = 0;
            break;
        case CPSS_PACKET_CMD_MIRROR_TO_CPU_E:
            data = 1;
            break;
        case CPSS_PACKET_CMD_TRAP_TO_CPU_E:
            data = 2;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpSetRegField(devNum,regAddr,30,2,data);
    return rc;
}

/**
* @internal cpssDxChIpArpBcModeSet function
* @endinternal
*
* @brief   set a arp broadcast mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] arpBcMode                - the arp broadcast command. Possible Commands:
*                                      CPSS_PACKET_CMD_NONE_E,CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                                      CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note
*       GalTis:
*
*/
GT_STATUS cpssDxChIpArpBcModeSet
(
    IN GT_U8               devNum,
    IN CPSS_PACKET_CMD_ENT arpBcMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpArpBcModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, arpBcMode));

    rc = internal_cpssDxChIpArpBcModeSet(devNum, arpBcMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, arpBcMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpArpBcModeGet function
* @endinternal
*
* @brief   get a arp broadcast mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] arpBcModePtr             - the arp broadcast command. Possible Commands:
*                                      CPSS_PACKET_CMD_NONE_E,CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                                      CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL pointer
*
* @note
*       GalTis:
*
*/
static GT_STATUS internal_cpssDxChIpArpBcModeGet
(
    IN  GT_U8               devNum,
    OUT CPSS_PACKET_CMD_ENT *arpBcModePtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    hwData;
    GT_STATUS rc = GT_OK;           /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(arpBcModePtr);

    /* Get address of IPv4 Control Register0 */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg0;
    }

    rc = prvCpssHwPpGetRegField(devNum,regAddr,30,2, &hwData);
    if(GT_OK != rc)
    {
        return rc;
    }

    switch (hwData)
    {
        case 0:
            *arpBcModePtr = CPSS_PACKET_CMD_NONE_E;
            break;
        case 1:
            *arpBcModePtr = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
            break;
        case 2:
            *arpBcModePtr = CPSS_PACKET_CMD_TRAP_TO_CPU_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @internal cpssDxChIpArpBcModeGet function
* @endinternal
*
* @brief   get a arp broadcast mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] arpBcModePtr             - the arp broadcast command. Possible Commands:
*                                      CPSS_PACKET_CMD_NONE_E,CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                                      CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL pointer
*
* @note
*       GalTis:
*
*/
GT_STATUS cpssDxChIpArpBcModeGet
(
    IN  GT_U8               devNum,
    OUT CPSS_PACKET_CMD_ENT *arpBcModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpArpBcModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, arpBcModePtr));

    rc = internal_cpssDxChIpArpBcModeGet(devNum, arpBcModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, arpBcModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpPortRoutingEnable function
* @endinternal
*
* @brief   Enable multicast/unicast IPv4/v6 routing and/or FCoE
*          forwarding on a port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port to enable on
* @param[in] ucMcEnable               - routing type to enable Unicast/Multicast
* @param[in] protocolStack            - what type of traffic to enable ipv4/ipv6/fcoe.
* @param[in] enableRouting            - enable IP routing / FCoE forwarding for this port
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note - for FCoE parameter ucMcEnable is ignored
*/
static GT_STATUS internal_cpssDxChIpPortRoutingEnable
(
    IN GT_U8                            devNum,
    IN GT_PORT_NUM                      portNum,
    IN CPSS_IP_UNICAST_MULTICAST_ENT    ucMcEnable,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    IN GT_BOOL                          enableRouting
)
{
    GT_U32    regAddr[2] ={0,0};              /* registers address             */
    GT_U32    data, i;
    GT_STATUS rc = GT_OK;                     /* return code                   */
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */
    GT_U32  fieldName;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

    switch (ucMcEnable)
    {
        case CPSS_IP_UNICAST_E:
        case CPSS_IP_MULTICAST_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
        case CPSS_IP_PROTOCOL_IPV6_E:
        case CPSS_IP_PROTOCOL_IPV4V6_E:
        case CPSS_IP_PROTOCOL_FCOE_E:
        case CPSS_IP_PROTOCOL_ALL_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        if ((protocolStack == CPSS_IP_PROTOCOL_IPV4_E) ||
            (protocolStack == CPSS_IP_PROTOCOL_IPV4V6_E) ||
            (protocolStack == CPSS_IP_PROTOCOL_ALL_E))
        {
            if (ucMcEnable == CPSS_IP_UNICAST_E)
            {
                fieldName = SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV4_UC_ROUTING_ENABLE_E;
            }
            else
            {
                fieldName = SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV4_MC_ROUTING_ENABLE_E;
            }
            rc = prvCpssDxChWriteTableEntryField(devNum,
                                                 CPSS_DXCH_SIP5_TABLE_IPVX_INGRESS_EPORT_E,
                                                 portNum,
                                                 PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                 fieldName,
                                                 PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                                 BOOL2BIT_MAC(enableRouting));
            if (rc != GT_OK)
                return rc;
        }

        if ((protocolStack == CPSS_IP_PROTOCOL_IPV6_E) ||
            (protocolStack == CPSS_IP_PROTOCOL_IPV4V6_E) ||
            (protocolStack == CPSS_IP_PROTOCOL_ALL_E))
        {
            if (ucMcEnable == CPSS_IP_UNICAST_E)
            {
                fieldName = SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV6_UC_ROUTING_ENABLE_E;
            }
            else
            {
                fieldName = SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV6_MC_ROUTING_ENABLE_E;
            }
            rc = prvCpssDxChWriteTableEntryField(devNum,
                                                 CPSS_DXCH_SIP5_TABLE_IPVX_INGRESS_EPORT_E,
                                                 portNum,
                                                 PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                 fieldName,
                                                 PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                                 BOOL2BIT_MAC(enableRouting));
            if (rc != GT_OK)
                return rc;
        }

        if ((protocolStack == CPSS_IP_PROTOCOL_FCOE_E) ||
            (protocolStack == CPSS_IP_PROTOCOL_ALL_E))
        {
            return cpssDxChIpPortFcoeForwardingEnableSet(devNum, portNum, enableRouting);
        }
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

        if(portNum == CPSS_CPU_PORT_NUM_CNS)
            localPort = 31;
        else
            localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        data = (GT_TRUE == enableRouting)? 1:0;

        switch (protocolStack)
        {
            case CPSS_IP_PROTOCOL_IPV4_E:
                switch (ucMcEnable)
                {
                    case CPSS_IP_UNICAST_E:
                        /* Unicast Enable Control Register*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ucEnCtrlReg;
                        break;
                    case CPSS_IP_MULTICAST_E:
                        /* MC Enable Control Register*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.mcEnCtrlReg;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                break;

            case CPSS_IP_PROTOCOL_IPV6_E:
                switch (ucMcEnable)
                {
                    case CPSS_IP_UNICAST_E:
                        /* Unicast Enable Control Register*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ucEnCtrlReg;
                        break;
                    case CPSS_IP_MULTICAST_E:
                        /* MC Enable Control Register*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.mcEnCtrlReg;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                break;

            case CPSS_IP_PROTOCOL_IPV4V6_E:
                switch (ucMcEnable)
                {
                    case CPSS_IP_UNICAST_E:
                        /*  Unicast Enable Control Register for Ipv6*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ucEnCtrlReg;

                        /* Unicast Enable Control Register*/
                        regAddr[1] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ucEnCtrlReg;

                        break;

                    case CPSS_IP_MULTICAST_E:
                        /* for Ipv6*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.mcEnCtrlReg;
                        /* MC Enable Control Register*/
                        regAddr[1] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.mcEnCtrlReg;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                 }
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* now write one or two registers */
        for (i = 0;(rc == GT_OK) && (i <2) ; i++)
        {
            if (regAddr[i] != 0)
                rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr[i],(GT_U32)localPort ,1,
                                               data);
        }
    }

    return rc;
}

/**
* @internal cpssDxChIpPortRoutingEnable function
* @endinternal
*
* @brief   Enable multicast/unicast IPv4/v6 routing and/or FCoE
*          forwarding on a port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port to enable on
* @param[in] ucMcEnable               - routing type to enable Unicast/Multicast
* @param[in] protocolStack            - what type of traffic to enable ipv4/ipv6/fcoe.
* @param[in] enableRouting            - enable IP routing / FCoE forwarding for this port
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note - for FCoE parameter ucMcEnable is ignored
*/
GT_STATUS cpssDxChIpPortRoutingEnable
(
    IN GT_U8                            devNum,
    IN GT_PORT_NUM                      portNum,
    IN CPSS_IP_UNICAST_MULTICAST_ENT    ucMcEnable,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    IN GT_BOOL                          enableRouting
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortRoutingEnable);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, ucMcEnable, protocolStack, enableRouting));

    rc = internal_cpssDxChIpPortRoutingEnable(devNum, portNum, ucMcEnable, protocolStack, enableRouting);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, ucMcEnable, protocolStack, enableRouting));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortRoutingEnableGet function
* @endinternal
*
* @brief   Get status of multicast/unicast IPv4/v6 routing or
*          FCoE forwarding on a port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port to enable on
* @param[in] ucMcEnable               - routing type to enable Unicast/Multicast
* @param[in] protocolStack            - what type of traffic: ipv4, ipv6 or fcoe.
*
* @param[out] enableRoutingPtr         - (pointer to)enable IP routing or FCoE forwarding for this port
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong protocolStack
* @retval GT_BAD_PTR               - on NULL pointer
*
* @note CPSS_IP_PROTOCOL_IPV4V6_E and CPSS_IP_PROTOCOL_ALL_E are
*       not supported in this get API. Can not get both values
*       for ipv4, ipv6, fcoe in the same get.
* @note - for FCoE parameter ucMcEnable is ignored
*
*/
static GT_STATUS internal_cpssDxChIpPortRoutingEnableGet
(
    IN  GT_U8                            devNum,
    IN  GT_PORT_NUM                      portNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT    ucMcEnable,
    IN  CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    OUT GT_BOOL                          *enableRoutingPtr
)
{
    GT_U32    regAddr;              /* registers address */
    GT_U32    data=0;
    GT_STATUS rc = GT_OK;           /* return code */
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */
    GT_U32  fieldName;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);
    CPSS_NULL_PTR_CHECK_MAC(enableRoutingPtr);

    switch (ucMcEnable)
    {
        case CPSS_IP_UNICAST_E:
        case CPSS_IP_MULTICAST_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
        case CPSS_IP_PROTOCOL_IPV6_E:
        case CPSS_IP_PROTOCOL_FCOE_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        if (protocolStack == CPSS_IP_PROTOCOL_IPV4_E)
        {
            if (ucMcEnable == CPSS_IP_UNICAST_E)
            {
                fieldName = SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV4_UC_ROUTING_ENABLE_E;
            }
            else
            {
                fieldName = SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV4_MC_ROUTING_ENABLE_E;
            }
        }
        else if(protocolStack == CPSS_IP_PROTOCOL_IPV6_E)
        {
            if (ucMcEnable == CPSS_IP_UNICAST_E)
            {
                fieldName = SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV6_UC_ROUTING_ENABLE_E;
            }
            else
            {
                fieldName = SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV6_MC_ROUTING_ENABLE_E;
            }
        }
        else
        {
            return cpssDxChIpPortFcoeForwardingEnableGet(devNum, portNum, enableRoutingPtr);
        }

        rc = prvCpssDxChReadTableEntryField(devNum,
                                            CPSS_DXCH_SIP5_TABLE_IPVX_INGRESS_EPORT_E,
                                            portNum,
                                            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                            fieldName,
                                            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                            &data);
        if (rc != GT_OK)
        {
            return rc;
        }

        *enableRoutingPtr = BIT2BOOL_MAC(data);
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

        if(portNum == CPSS_CPU_PORT_NUM_CNS)
            localPort = 31;
        else
            localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        switch (protocolStack)
        {
            case CPSS_IP_PROTOCOL_IPV4_E:
                switch (ucMcEnable)
                {
                    case CPSS_IP_UNICAST_E:
                        /* Unicast Enable Control Register*/
                        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ucEnCtrlReg;
                        break;
                    case CPSS_IP_MULTICAST_E:
                        /* MC Enable Control Register*/
                        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.mcEnCtrlReg;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
            break;

            case CPSS_IP_PROTOCOL_IPV6_E:
                switch (ucMcEnable)
                {
                    case CPSS_IP_UNICAST_E:
                        /* Unicast Enable Control Register*/
                        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ucEnCtrlReg;
                        break;
                    case CPSS_IP_MULTICAST_E:
                        /* MC Enable Control Register*/
                        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.mcEnCtrlReg;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

            break;
            case CPSS_IP_PROTOCOL_IPV4V6_E:
                /* can not get both values for ipv4 and ipv6 in the same get*/
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* now read the register */
        rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,(GT_U32)localPort ,1,&data);

        if(rc != GT_OK)
            return rc;

        *enableRoutingPtr = BIT2BOOL_MAC(data);
    }

    return rc;
}

/**
* @internal cpssDxChIpPortRoutingEnableGet function
* @endinternal
*
* @brief   Get status of multicast/unicast IPv4/v6 routing or
*          FCoE forwarding on a port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port to enable on
* @param[in] ucMcEnable               - routing type to enable Unicast/Multicast
* @param[in] protocolStack            - what type of traffic: ipv4, ipv6 or fcoe.
*
* @param[out] enableRoutingPtr         - (pointer to)enable IP routing or FCoE forwarding for this port
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong protocolStack
* @retval GT_BAD_PTR               - on NULL pointer
*
* @note CPSS_IP_PROTOCOL_IPV4V6_E and CPSS_IP_PROTOCOL_ALL_E are
*       not supported in this get API. Can not get both values
*       for ipv4, ipv6, fcoe in the same get.
* @note - for FCoE parameter ucMcEnable is ignored
*
*/
GT_STATUS cpssDxChIpPortRoutingEnableGet
(
    IN  GT_U8                            devNum,
    IN  GT_PORT_NUM                      portNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT    ucMcEnable,
    IN  CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    OUT GT_BOOL                          *enableRoutingPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortRoutingEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, ucMcEnable, protocolStack, enableRoutingPtr));

    rc = internal_cpssDxChIpPortRoutingEnableGet(devNum, portNum, ucMcEnable, protocolStack, enableRoutingPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, ucMcEnable, protocolStack, enableRoutingPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortFcoeForwardingEnableSet function
* @endinternal
*
* @brief   Enable FCoE Forwarding on a port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port to enable on
* @param[in] enable                   -  FCoE Forwarding for this port
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortFcoeForwardingEnableSet
(
    IN GT_U8                            devNum,
    IN GT_PORT_NUM                      portNum,
    IN GT_BOOL                          enable
)
{
    GT_STATUS   rc = GT_OK;           /* return code                   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

    rc = prvCpssDxChWriteTableEntryField(devNum,
                                         CPSS_DXCH_SIP5_TABLE_IPVX_INGRESS_EPORT_E,
                                         portNum,
                                         PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                         SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_FCOE_FORWARDING_ENABLE_E,/* field name */
                                         PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                         BOOL2BIT_MAC(enable));
    return rc;
}
/**
* @internal cpssDxChIpPortFcoeForwardingEnableSet function
* @endinternal
*
* @brief   Enable FCoE Forwarding on a port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port to enable on
* @param[in] enable                   -  FCoE Forwarding for this port
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortFcoeForwardingEnableSet
(
    IN GT_U8                            devNum,
    IN GT_PORT_NUM                      portNum,
    IN GT_BOOL                          enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortFcoeForwardingEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enable));

    rc = internal_cpssDxChIpPortFcoeForwardingEnableSet(devNum, portNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortFcoeForwardingEnableGet function
* @endinternal
*
* @brief   Get status of FCoE Forwarding on a port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port to enable on
*
* @param[out] enablePtr                - (pointer to)enable FCoE Forwarding for this port
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong protocolStack
* @retval GT_BAD_PTR               - on NULL pointer
*/
static GT_STATUS internal_cpssDxChIpPortFcoeForwardingEnableGet
(
    IN  GT_U8                            devNum,
    IN  GT_PORT_NUM                      portNum,
    OUT GT_BOOL                          *enablePtr
)
{
    GT_U32      data=0;
    GT_STATUS   rc = GT_OK;           /* return code */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

    rc = prvCpssDxChReadTableEntryField(devNum,
                                        CPSS_DXCH_SIP5_TABLE_IPVX_INGRESS_EPORT_E,
                                        portNum,
                                        PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                        SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_FCOE_FORWARDING_ENABLE_E,/* field name */
                                        PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                        &data);
    if (rc == GT_OK)
    {
        *enablePtr = BIT2BOOL_MAC(data);
    }
    return rc;
}

/**
* @internal cpssDxChIpPortFcoeForwardingEnableGet function
* @endinternal
*
* @brief   Get status of FCoE Forwarding on a port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port to enable on
*
* @param[out] enablePtr                - (pointer to)enable FCoE Forwarding for this port
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong protocolStack
* @retval GT_BAD_PTR               - on NULL pointer
*/
GT_STATUS cpssDxChIpPortFcoeForwardingEnableGet
(
    IN  GT_U8                            devNum,
    IN  GT_PORT_NUM                      portNum,
    OUT GT_BOOL                          *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortFcoeForwardingEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enablePtr));

    rc = internal_cpssDxChIpPortFcoeForwardingEnableGet(devNum, portNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpQosProfileToRouteEntryMapSet function
* @endinternal
*
* @brief   Sets the QoS profile to route entry offset mapping table.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] qosProfile               - QOS Profile index
* @param[in] routeEntryOffset         - The offset in the array of route entries to be
*                                      selected for this QOS profile
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note In QoS-based routing, the Route table entry is selected according to the
*       following index calculation:
*       1. in xCat3: <Route Entry Index> +
*       (QoSProfile-to-Route-Block-Offset(QoSProfile) %
*       (<Number of Paths> + 1)
*       2. in Lion : <Route Entry Index> +
*       Floor(QoSProfile-to-Route-Block-Offset(QoSProfile)
*       (<Number of Paths> + 1) / 8)
*
*/
static GT_STATUS internal_cpssDxChIpQosProfileToRouteEntryMapSet
(
    IN  GT_U8                devNum,
    IN  GT_U32               qosProfile,
    IN  GT_U32               routeEntryOffset
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        if (qosProfile >= EARC_MAX_MAC_QOS_ENTRIES_CNS)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* Each entry consists of 4 QoS Profile Offsets, and each offset is 3 bits long,
           so to calculate the entry in the table we divide qosProfile by 4, and
           to calculate the offset within the entry we use 3 * (qosProfile % 4) */
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                         CPSS_DXCH_SIP5_TABLE_IPVX_ROUTER_QOS_PROFILE_OFFSETS_E,
                                         qosProfile / 4,
                                         PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                         3 * (qosProfile % 4),
                                         3,
                                         routeEntryOffset);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        if (qosProfile >= CHEETAH_MAX_MAC_QOS_ENTRIES_CNS)                                   \
        {                                                        \
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);                                 \
        }

        /* Get address of the register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.qoSProfile2RouteBlockOffsetMapTable[qosProfile / 8];

        offset = (qosProfile % 8) * 4;
        rc = prvCpssHwPpSetRegField(devNum,regAddr,offset,3,routeEntryOffset);
    }

    return rc;
}

/**
* @internal cpssDxChIpQosProfileToRouteEntryMapSet function
* @endinternal
*
* @brief   Sets the QoS profile to route entry offset mapping table.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] qosProfile               - QOS Profile index
* @param[in] routeEntryOffset         - The offset in the array of route entries to be
*                                      selected for this QOS profile
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note In QoS-based routing, the Route table entry is selected according to the
*       following index calculation:
*       1. in xCat3: <Route Entry Index> +
*       (QoSProfile-to-Route-Block-Offset(QoSProfile) %
*       (<Number of Paths> + 1)
*       2. in Lion : <Route Entry Index> +
*       Floor(QoSProfile-to-Route-Block-Offset(QoSProfile)
*       (<Number of Paths> + 1) / 8)
*
*/
GT_STATUS cpssDxChIpQosProfileToRouteEntryMapSet
(
    IN  GT_U8                devNum,
    IN  GT_U32               qosProfile,
    IN  GT_U32               routeEntryOffset
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpQosProfileToRouteEntryMapSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, qosProfile, routeEntryOffset));

    rc = internal_cpssDxChIpQosProfileToRouteEntryMapSet(devNum, qosProfile, routeEntryOffset);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, qosProfile, routeEntryOffset));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpQosProfileToRouteEntryMapGet function
* @endinternal
*
* @brief   gets the QoS profile to route entry offset mapping table.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] qosProfile               - QOS Profile index
*
* @param[out] routeEntryOffsetPtr      - The offset in the array of route entries to be
*                                      selected for this QOS profile
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL ptr
*
* @note In QoS-based routing, the Route table entry is selected according to the
*       following index calculation:
*       1. in xCat3: <Route Entry Index> +
*       (QoSProfile-to-Route-Block-Offset(QoSProfile) %
*       (<Number of Paths> + 1)
*       2. in Lion : <Route Entry Index> +
*       Floor(QoSProfile-to-Route-Block-Offset(QoSProfile)
*       (<Number of Paths> + 1) / 8)
*
*/
static GT_STATUS internal_cpssDxChIpQosProfileToRouteEntryMapGet
(
    IN  GT_U8                devNum,
    IN  GT_U32               qosProfile,
    OUT GT_U32               *routeEntryOffsetPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(routeEntryOffsetPtr);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        if (qosProfile >= EARC_MAX_MAC_QOS_ENTRIES_CNS)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        /* Each entry consists of 4 QoS Profile Offsets, and each offset is 3 bits long,
           so to calculate the entry in the table we divide qosProfile by 4, and
           to calculate the offset within the entry we use 3 * (qosProfile % 4) */
        rc = prvCpssDxChReadTableEntryField(devNum,
                                         CPSS_DXCH_SIP5_TABLE_IPVX_ROUTER_QOS_PROFILE_OFFSETS_E,
                                         qosProfile / 4,
                                         PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                         3 * (qosProfile % 4),
                                         3,
                                         routeEntryOffsetPtr);
    }
    else
    {
        if (qosProfile >= CHEETAH_MAX_MAC_QOS_ENTRIES_CNS)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* Get address of the register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.qoSProfile2RouteBlockOffsetMapTable[qosProfile / 8];

        offset = (qosProfile % 8) * 4;
        rc = prvCpssHwPpGetRegField(devNum,regAddr,offset,3,routeEntryOffsetPtr);
    }

    return rc;
}

/**
* @internal cpssDxChIpQosProfileToRouteEntryMapGet function
* @endinternal
*
* @brief   gets the QoS profile to route entry offset mapping table.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] qosProfile               - QOS Profile index
*
* @param[out] routeEntryOffsetPtr      - The offset in the array of route entries to be
*                                      selected for this QOS profile
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL ptr
*
* @note In QoS-based routing, the Route table entry is selected according to the
*       following index calculation:
*       1. in xCat3: <Route Entry Index> +
*       (QoSProfile-to-Route-Block-Offset(QoSProfile) %
*       (<Number of Paths> + 1)
*       2. in Lion : <Route Entry Index> +
*       Floor(QoSProfile-to-Route-Block-Offset(QoSProfile)
*       (<Number of Paths> + 1) / 8)
*
*/
GT_STATUS cpssDxChIpQosProfileToRouteEntryMapGet
(
    IN  GT_U8                devNum,
    IN  GT_U32               qosProfile,
    OUT GT_U32               *routeEntryOffsetPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpQosProfileToRouteEntryMapGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, qosProfile, routeEntryOffsetPtr));

    rc = internal_cpssDxChIpQosProfileToRouteEntryMapGet(devNum, qosProfile, routeEntryOffsetPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, qosProfile, routeEntryOffsetPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRoutingEnable function
* @endinternal
*
* @brief   globally enable/disable routing.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] enableRouting            - enable /disable global routing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong devNum
*
* @note the ASIC defualt is routing enabled.
*
*/
static GT_STATUS internal_cpssDxChIpRoutingEnable
(
    IN GT_U8    devNum,
    IN GT_BOOL  enableRouting
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    data;
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    data = (GT_TRUE == enableRouting)? 1:0;
    /* Get address of  register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }
    rc = prvCpssHwPpSetRegField(devNum,regAddr, 6,1,data);

    return rc;
}

/**
* @internal cpssDxChIpRoutingEnable function
* @endinternal
*
* @brief   globally enable/disable routing.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] enableRouting            - enable /disable global routing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong devNum
*
* @note the ASIC defualt is routing enabled.
*
*/
GT_STATUS cpssDxChIpRoutingEnable
(
    IN GT_U8    devNum,
    IN GT_BOOL  enableRouting
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRoutingEnable);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enableRouting));

    rc = internal_cpssDxChIpRoutingEnable(devNum, enableRouting);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enableRouting));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRoutingEnableGet function
* @endinternal
*
* @brief   Get global routing status
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] enableRoutingPtr         -  (pointer to)enable /disable global routing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_BAD_PTR               - on NULL pointer
*/
static GT_STATUS internal_cpssDxChIpRoutingEnableGet
(
    IN  GT_U8    devNum,
    OUT GT_BOOL  *enableRoutingPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    data;
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enableRoutingPtr);

    /* Get address of  register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }
    rc = prvCpssHwPpGetRegField(devNum,regAddr, 6,1,&data);

    if(rc != GT_OK)
        return rc;

    *enableRoutingPtr = BIT2BOOL_MAC(data);

    return rc;
}

/**
* @internal cpssDxChIpRoutingEnableGet function
* @endinternal
*
* @brief   Get global routing status
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] enableRoutingPtr         -  (pointer to)enable /disable global routing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_BAD_PTR               - on NULL pointer
*/
GT_STATUS cpssDxChIpRoutingEnableGet
(
    IN  GT_U8    devNum,
    OUT GT_BOOL  *enableRoutingPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRoutingEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enableRoutingPtr));

    rc = internal_cpssDxChIpRoutingEnableGet(devNum, enableRoutingPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enableRoutingPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpCntGet function
* @endinternal
*
* @brief   Return the IP counter set requested.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] cntSet                   - counters set to retrieve.
*
* @param[out] countersPtr              - (pointer to)struct contains the counter values.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_FAIL                  - on error
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This function doesn't handle counters overflow.
*
*/
static GT_STATUS internal_cpssDxChIpCntGet
(
    IN  GT_U8                        devNum,
    IN  CPSS_IP_CNT_SET_ENT          cntSet,
    OUT CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    return cpssDxChIpPortGroupCntGet(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                     cntSet, countersPtr);
}

/**
* @internal cpssDxChIpCntGet function
* @endinternal
*
* @brief   Return the IP counter set requested.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] cntSet                   - counters set to retrieve.
*
* @param[out] countersPtr              - (pointer to)struct contains the counter values.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_FAIL                  - on error
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This function doesn't handle counters overflow.
*
*/
GT_STATUS cpssDxChIpCntGet
(
    IN  GT_U8                        devNum,
    IN  CPSS_IP_CNT_SET_ENT          cntSet,
    OUT CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cntSet, countersPtr));

    rc = internal_cpssDxChIpCntGet(devNum, cntSet, countersPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cntSet, countersPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpCntSetModeSet function
* @endinternal
*
* @brief   Sets a counter set's bounded inteface and interface mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] cntSet                   - the counter set
* @param[in] cntSetMode               - the counter set bind mode (interface or Next hop)
* @param[in] interfaceModeCfgPtr      - if cntSetMode = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E
*                                      this is the interface configuration
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpCntSetModeSet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_IP_CNT_SET_ENT                        cntSet,
    IN  CPSS_DXCH_IP_CNT_SET_MODE_ENT              cntSetMode,
    IN  CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceModeCfgPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    regAddr1;             /* register address                   */
    GT_U32    regAddr2=0;           /* register address                   */
    GT_U32    data,data1,data2;
    GT_STATUS rc;                   /* return code                        */
    GT_U8 setNum;
    GT_U32  portGroupId,portPortGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32  portValue;    /* port value */
    GT_U32  hwPort,hwDev;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(cntSetMode != CPSS_DXCH_IP_CNT_SET_ROUTE_ENTRY_MODE_E)
        CPSS_NULL_PTR_CHECK_MAC(interfaceModeCfgPtr);

    switch (cntSet)
    {
        case CPSS_IP_CNT_SET0_E:
            setNum =0;
            break;
        case CPSS_IP_CNT_SET1_E:
            setNum =1;
            break;
        case CPSS_IP_CNT_SET2_E:
            setNum =2;
            break;
        case CPSS_IP_CNT_SET3_E:
            setNum =3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
     }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        regAddr  = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementCntrsSetConfig0[setNum];
        regAddr1 = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementCntrsSetConfig1[setNum];
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            regAddr2 = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementCntrsSetConfig2[setNum];
        }

        data = 0;
        data1 = 0;
        data2 = 0;

        switch (cntSetMode)
        {
            case CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E:
                data |= (0x0 << 29); /* <bit 29> = 0 indicates interface mode */
                switch (interfaceModeCfgPtr->portTrunkCntMode)
                {
                    case CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E:
                        data |= (0x0 << 30); /* <bits 30:31> = 0 indicates count all */
                        break;
                    case CPSS_DXCH_IP_PORT_CNT_MODE_E:
                        data |= (0x1 << 30); /* <bits 30:31> = 1 indicates count ePortDevice */
                        if (interfaceModeCfgPtr->portTrunk.port > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_E_PORT_MAC(devNum))
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        if (interfaceModeCfgPtr->hwDevNum > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum))
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        if(PRV_CPSS_SIP_5_15_CHECK_MAC(devNum) == 0)
                        {
                            data1 |= ((interfaceModeCfgPtr->portTrunk.port & 0x1FFF) << 0);
                            data1 |= ((interfaceModeCfgPtr->hwDevNum & 0x3FF) << 13);
                        }
                        else
                        {
                            data1 |= ((interfaceModeCfgPtr->portTrunk.port & 0x7FFF) << 0);
                            data1 |= ((interfaceModeCfgPtr->hwDevNum & 0x3FF) << 15);
                        }
                        break;
                    case CPSS_DXCH_IP_TRUNK_CNT_MODE_E:
                        data |= (0x2 << 30); /* <bits 30:31> = 2 indicates count trunk */
                        if (interfaceModeCfgPtr->portTrunk.trunk > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum))
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
                        {
                            data2 |= ((interfaceModeCfgPtr->portTrunk.trunk & 0xFFF) << 0);
                        }
                        else
                        {
                            data1 |= ((interfaceModeCfgPtr->portTrunk.trunk & 0xFFF) << 0);
                        }
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                switch (interfaceModeCfgPtr->vlanMode)
                {
                    case CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E:
                        data |= (0x0 << 25); /* <bit 25> = 0 indicates count all */
                        break;
                    case CPSS_DXCH_IP_USE_VLAN_CNT_MODE_E:
                        if (interfaceModeCfgPtr->vlanId > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_VID_MAC(devNum))
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        data |= (0x1 << 25); /* <bit 25> = 1 indicates count eVlan */
                        data |= (interfaceModeCfgPtr->vlanId & 0x1FFF);
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                switch (interfaceModeCfgPtr->ipMode)
                {
                    case CPSS_IP_PROTOCOL_IPV4_E:
                        data |= (0x1 << 26); /* <bits 26:28> = 1 indicates count ipv4 */
                        break;
                    case CPSS_IP_PROTOCOL_IPV6_E:
                        data |= (0x2 << 26); /* <bits 26:28> = 2 indicates count ipv6 */
                        break;
                    case CPSS_IP_PROTOCOL_FCOE_E:
                        data |= (0x3 << 26); /* <bits 26:28> = 3 indicates count FCoE */
                        break;
                    case CPSS_IP_PROTOCOL_ALL_E:
                        data |= (0x0 << 26); /* <bits 26:28> = 0 indicates count all (IPv4, IPv6, and FCoE) */
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                break;
            case CPSS_DXCH_IP_CNT_SET_ROUTE_ENTRY_MODE_E:
                data |= (0x1 << 29); /* <bit 29> = 1 indicates route entry mode */
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        rc = prvCpssHwPpWriteRegister(devNum,regAddr,data);
        if (rc != GT_OK)
            return rc;

        /* on some cases, there is no need to set second register */
        if (cntSetMode == CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E)
        {
            if ((interfaceModeCfgPtr->portTrunkCntMode != CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E) ||
                (interfaceModeCfgPtr->vlanMode != CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E))
            {
                if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
                {
                    if (interfaceModeCfgPtr->portTrunkCntMode == CPSS_DXCH_IP_PORT_CNT_MODE_E)
                    {
                        rc = prvCpssHwPpWriteRegister(devNum,regAddr1,data1);
                        if (rc != GT_OK)
                            return rc;
                    }
                    else /* interfaceModeCfgPtr->portTrunkCntMode == CPSS_DXCH_IP_TRUNK_CNT_MODE_E */
                    {
                        rc = prvCpssHwPpWriteRegister(devNum,regAddr2,data2);
                        if (rc != GT_OK)
                            return rc;
                    }
                }
                else
                {
                    rc = prvCpssHwPpWriteRegister(devNum,regAddr1,data1);
                    if (rc != GT_OK)
                        return rc;
                }

            }
        }
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngCntSetCfgRegs[setNum];

        /* support multi-port-groups device - same configuration to all port groups */
        portPortGroupId = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        switch (cntSetMode)
        {
            /* Interface counter */
            case CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E:
                rc = prvCpssHwPpSetRegField(devNum,regAddr,29,1,0);
                if(GT_OK != rc)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

                /* Set Port/Trunk mode*/
                switch (interfaceModeCfgPtr->portTrunkCntMode)
                {
                    case  CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E:
                        data = 0;
                        break;
                    case CPSS_DXCH_IP_PORT_CNT_MODE_E:
                        /* FEr#3116: Wrong counting of IP counters per port - IP counters cannot be set by {device+port} */
                        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_LION_WRONG_COUNTING_OF_IP_COUNTERS_PER_PORT_WA_E))
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
                        }

                        PRV_CPSS_DXCH_DUAL_HW_DEVICE_AND_PORT_CHECK_MAC(
                            interfaceModeCfgPtr->hwDevNum,
                            interfaceModeCfgPtr->portTrunk.port);
                        hwDev =  PRV_CPSS_DXCH_DUAL_HW_DEVICE_CONVERT_DEV_MAC(
                            interfaceModeCfgPtr->hwDevNum,
                            interfaceModeCfgPtr->portTrunk.port);
                        hwPort = PRV_CPSS_DXCH_DUAL_HW_DEVICE_CONVERT_PORT_MAC(
                            interfaceModeCfgPtr->hwDevNum,
                            interfaceModeCfgPtr->portTrunk.port);

                        if(hwPort >= BIT_6)
                        {
                            /* 6 bits in HW */
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }

                        if(hwDev >= BIT_5)
                        {
                            /* 5 bits in HW */
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }

                        /* hold 'port filter' */
                        if(PRV_CPSS_HW_DEV_NUM_MAC(devNum) == interfaceModeCfgPtr->hwDevNum)
                        {
                            /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
                            portPortGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum,
                                interfaceModeCfgPtr->portTrunk.port);
                        }

                        data = 1;

                        /* loop on all port groups :
                            on the port group that 'own' the port , set the needed configuration
                            on other port groups put 'NULL port'
                        */
                        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
                        {
                            if(PRV_CPSS_HW_DEV_NUM_MAC(devNum) != interfaceModeCfgPtr->hwDevNum)
                            {
                                /* no conversion needed for remote device */
                                portValue = hwPort;
                            }
                            else if(portPortGroupId == portGroupId)
                            {
                                /* convert global to local port */
                                portValue = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,
                                    interfaceModeCfgPtr->portTrunk.port);
                            }
                            else
                            {
                                /* use NULL port , so no counting will happen */
                                portValue = PRV_CPSS_DXCH_NULL_PORT_NUM_CNS;
                            }

                            /* Set 6 bits of the port\trunk field and bits 7,8 are 0. */
                            rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr, 0, 8,
                                            portValue);
                            if(GT_OK != rc)
                                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                        }
                        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

                        /* Set device num*/
                        rc = prvCpssHwPpSetRegField(devNum,regAddr,8,5,hwDev);
                        if(GT_OK != rc)
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                        break;

                    case CPSS_DXCH_IP_TRUNK_CNT_MODE_E:
                        if(interfaceModeCfgPtr->portTrunk.trunk >= BIT_7)
                        {
                            /* 7 bits in HW */
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        /* Set 7 bits of the port\trunk field and the 8th is 0. */
                        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 8,
                                      interfaceModeCfgPtr->portTrunk.trunk);
                        if(GT_OK != rc)
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                        data = 2;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                rc = prvCpssHwPpSetRegField(devNum,regAddr,30,2,data);
                if(GT_OK != rc)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                /* Set IpMode */
                switch (interfaceModeCfgPtr->ipMode)
                {
                    case CPSS_IP_PROTOCOL_IPV4_E:
                        data = 1;
                        break;
                    case CPSS_IP_PROTOCOL_IPV6_E:
                        data = 2;
                        break;
                    case CPSS_IP_PROTOCOL_FCOE_E:
                        data = 3;
                        break;
                    case CPSS_IP_PROTOCOL_ALL_E:
                        data = 0;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                rc = prvCpssHwPpSetRegField(devNum,regAddr,27,2,data);
                if(GT_OK != rc)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                /* Set VLAN count mode */
                switch ( interfaceModeCfgPtr->vlanMode)
                {
                    case CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E:
                        rc = prvCpssHwPpSetRegField(devNum,regAddr,26,1,0);
                        break;
                    case CPSS_DXCH_IP_USE_VLAN_CNT_MODE_E:
                        if(interfaceModeCfgPtr->vlanId >= BIT_12)
                        {
                            /* 12 bits in HW */
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        rc = prvCpssHwPpSetRegField(devNum,regAddr,26,1,1);
                        if(GT_OK != rc)
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

                        /* Set VID*/
                        rc = prvCpssHwPpSetRegField(devNum,regAddr,14,12,
                                                       interfaceModeCfgPtr->vlanId);
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                break;

            case CPSS_DXCH_IP_CNT_SET_ROUTE_ENTRY_MODE_E:
                rc = prvCpssHwPpSetRegField(devNum,regAddr,29,1,1);
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    return rc;
}

/**
* @internal cpssDxChIpCntSetModeSet function
* @endinternal
*
* @brief   Sets a counter set's bounded inteface and interface mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] cntSet                   - the counter set
* @param[in] cntSetMode               - the counter set bind mode (interface or Next hop)
* @param[in] interfaceModeCfgPtr      - if cntSetMode = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E
*                                      this is the interface configuration
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpCntSetModeSet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_IP_CNT_SET_ENT                        cntSet,
    IN  CPSS_DXCH_IP_CNT_SET_MODE_ENT              cntSetMode,
    IN  CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceModeCfgPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpCntSetModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cntSet, cntSetMode, interfaceModeCfgPtr));

    rc = internal_cpssDxChIpCntSetModeSet(devNum, cntSet, cntSetMode, interfaceModeCfgPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cntSet, cntSetMode, interfaceModeCfgPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpCntSetModeGet function
* @endinternal
*
* @brief   Gets a counter set's bounded inteface and interface mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] cntSet                   - the counter set
*
* @param[out] cntSetModePtr            - the counter set bind mode (interface or Next hop)
* @param[out] interfaceModeCfgPtr      - if cntSetMode = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E
*                                      this is the interface configuration
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL ptr
*/
static GT_STATUS internal_cpssDxChIpCntSetModeGet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_IP_CNT_SET_ENT                        cntSet,
    OUT CPSS_DXCH_IP_CNT_SET_MODE_ENT              *cntSetModePtr,
    OUT CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceModeCfgPtr
)
{
    GT_U32    regAddr;              /*  register address  */
    GT_U32    regAddr1;             /*  register address  */
    GT_U32    regAddr2;             /*  register address  */
    GT_U32    hwData = 0;
    GT_U32    hwData1 = 0;
    GT_U32    hwData2 = 0;
    GT_U32    value = 0;
    GT_STATUS rc = GT_OK;
    GT_U8     setNum;
    GT_U32    portGroupId;
    GT_U32    portValue, tmpPortValue;
    GT_U32    hwDev;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(cntSetModePtr);
    CPSS_NULL_PTR_CHECK_MAC(interfaceModeCfgPtr);


    switch (cntSet)
    {
        case CPSS_IP_CNT_SET0_E:
            setNum =0;
            break;
        case CPSS_IP_CNT_SET1_E:
            setNum =1;
            break;
        case CPSS_IP_CNT_SET2_E:
            setNum =2;
            break;
        case CPSS_IP_CNT_SET3_E:
            setNum =3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
     }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        /* get first reg addr */
        regAddr  = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementCntrsSetConfig0[setNum];

        /* read hw data from first register */
        rc = prvCpssHwPpReadRegister(devNum,regAddr,&hwData);
        if(GT_OK != rc)
        {
           return rc;
        }

        value = (hwData >> 29) & 0x1;

        switch(value)
        {
            case 0:
                *cntSetModePtr = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E;

                /* get second reg addr */
                regAddr1 = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementCntrsSetConfig1[setNum];

                /* read hw data from second register */
                rc = prvCpssHwPpReadRegister(devNum,regAddr1,&hwData1);
                if (rc != GT_OK)
                    return rc;

                if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)){
                    regAddr2 = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementCntrsSetConfig2[setNum];
                    rc = prvCpssHwPpReadRegister(devNum,regAddr2,&hwData2);
                    if (rc != GT_OK)
                        return rc;
                }

                value = (hwData >> 30) & 0x3;
                switch(value)
                {
                    case 0:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E;

                        break;
                    case 1:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_PORT_CNT_MODE_E;
                        if(PRV_CPSS_SIP_5_15_CHECK_MAC(devNum) == 0)
                        {
                            interfaceModeCfgPtr->portTrunk.port = (GT_PORT_NUM)(hwData1 & 0x1FFF);
                            interfaceModeCfgPtr->hwDevNum = (GT_HW_DEV_NUM)((hwData1>>13)&0x3FF);
                        }
                        else
                        {
                            interfaceModeCfgPtr->portTrunk.port = (GT_PORT_NUM)(hwData1 & 0x7FFF);
                            interfaceModeCfgPtr->hwDevNum = (GT_HW_DEV_NUM)((hwData1>>15)&0x3FF);
                        }
                        break;
                    case 2:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_TRUNK_CNT_MODE_E;
                        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
                        {
                            interfaceModeCfgPtr->portTrunk.trunk = (GT_TRUNK_ID)(hwData2 & 0xFFF);
                        }
                        else
                        {
                            interfaceModeCfgPtr->portTrunk.trunk = (GT_TRUNK_ID)(hwData1 & 0xFFF);
                        }
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                value = (hwData >> 25) & 0x1;
                switch(value)
                {
                    case 0:
                        interfaceModeCfgPtr->vlanMode = CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E;
                        break;
                    case 1:
                        interfaceModeCfgPtr->vlanMode = CPSS_DXCH_IP_USE_VLAN_CNT_MODE_E;
                        interfaceModeCfgPtr->vlanId = (GT_U16)(hwData & 0x1FFF);
                        break;

                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                value = (hwData >> 26) & 0x7;
                switch (value)
                {
                    case 1:
                        interfaceModeCfgPtr->ipMode = CPSS_IP_PROTOCOL_IPV4_E;
                        break;
                    case 2 :
                        interfaceModeCfgPtr->ipMode = CPSS_IP_PROTOCOL_IPV6_E;
                        break;
                    case 3 :
                        interfaceModeCfgPtr->ipMode = CPSS_IP_PROTOCOL_FCOE_E;
                        break;
                    case 0:
                        interfaceModeCfgPtr->ipMode = CPSS_IP_PROTOCOL_ALL_E;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }
                break;

            case 1:
                *cntSetModePtr = CPSS_DXCH_IP_CNT_SET_ROUTE_ENTRY_MODE_E;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngCntSetCfgRegs[setNum];

        rc = prvCpssHwPpGetRegField(devNum,regAddr,29,1,&value);
        if(GT_OK != rc)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }

        switch (value)
        {
            case 0:
                *cntSetModePtr = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E;

                rc = prvCpssHwPpGetRegField(devNum,regAddr,30,2,&value);
                if(GT_OK != rc)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }

                switch (value)
                {
                    case 0:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E;
                        break;
                    case 1:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_PORT_CNT_MODE_E;

                        /* FEr#3116: Wrong counting of IP counters per port - IP counters cannot be set by {device+port} */
                        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_LION_WRONG_COUNTING_OF_IP_COUNTERS_PER_PORT_WA_E))
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
                        }

                        /*  Get device num  */
                        rc = prvCpssHwPpGetRegField(devNum,regAddr,8,5,&hwDev);
                        if(GT_OK != rc)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                        }

                        /*  loop on all port groups  */
                        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
                        {
                            /* Set 6 bits of the port\trunk filed and bits 7,8 are 0. */
                            rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr, 0, 8,
                                            &portValue);
                            if(GT_OK != rc)
                            {
                                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                            }

                            tmpPortValue = portValue;

                            if(portValue != PRV_CPSS_DXCH_NULL_PORT_NUM_CNS)
                            {
                                PRV_CPSS_DXCH_DUAL_HW_DEVICE_CONVERT_DEV_PORT_MAC(hwDev, tmpPortValue);

                                if(hwDev != PRV_CPSS_HW_DEV_NUM_MAC(devNum))
                                {
                                    /* no conversion needed for remote device */
                                    interfaceModeCfgPtr->portTrunk.port = tmpPortValue;
                                }
                                else
                                {
                                    /*  convert global to local port  */
                                    interfaceModeCfgPtr->portTrunk.port =
                                        PRV_CPSS_LOCAL_PORT_TO_GLOBAL_PORT_CONVERT_MAC(devNum,portGroupId,portValue);
                                }
                                break;
                            }
                        }
                        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

                        interfaceModeCfgPtr->hwDevNum = (GT_HW_DEV_NUM)hwDev;

                        break;
                    case 2:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_TRUNK_CNT_MODE_E;

                        /* Set 7 bits of the port\trunk filed and the 8th is 0. */
                        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 8, &value);

                        interfaceModeCfgPtr->portTrunk.trunk = (GT_TRUNK_ID)value;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                rc = prvCpssHwPpGetRegField(devNum,regAddr,27,2,&value);
                if(GT_OK != rc)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
                switch (value)
                {
                    case 1:
                        interfaceModeCfgPtr->ipMode = CPSS_IP_PROTOCOL_IPV4_E;
                        break;
                    case 2 :
                        interfaceModeCfgPtr->ipMode = CPSS_IP_PROTOCOL_IPV6_E;
                        break;
                    case 3 :
                        interfaceModeCfgPtr->ipMode = CPSS_IP_PROTOCOL_FCOE_E;
                        break;
                    case 0:
                        interfaceModeCfgPtr->ipMode = CPSS_IP_PROTOCOL_ALL_E;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                rc = prvCpssHwPpGetRegField(devNum,regAddr,26,1,&value);
                if(GT_OK != rc)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
                switch(value)
                {
                    case 0:
                        interfaceModeCfgPtr->vlanMode = CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E;
                        break;
                    case 1:
                        interfaceModeCfgPtr->vlanMode = CPSS_DXCH_IP_USE_VLAN_CNT_MODE_E;

                        rc = prvCpssHwPpGetRegField(devNum,regAddr,14,12,&value);
                        if(GT_OK != rc)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                        }
                        interfaceModeCfgPtr->vlanId = (GT_U16)(value & 0x1FFF);
                        break;

                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                break;
            case 1:
                *cntSetModePtr = CPSS_DXCH_IP_CNT_SET_ROUTE_ENTRY_MODE_E;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }

    return rc;
}

/**
* @internal cpssDxChIpCntSetModeGet function
* @endinternal
*
* @brief   Gets a counter set's bounded inteface and interface mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] cntSet                   - the counter set
*
* @param[out] cntSetModePtr            - the counter set bind mode (interface or Next hop)
* @param[out] interfaceModeCfgPtr      - if cntSetMode = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E
*                                      this is the interface configuration
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL ptr
*/
GT_STATUS cpssDxChIpCntSetModeGet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_IP_CNT_SET_ENT                        cntSet,
    OUT CPSS_DXCH_IP_CNT_SET_MODE_ENT              *cntSetModePtr,
    OUT CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceModeCfgPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpCntSetModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cntSet, cntSetModePtr, interfaceModeCfgPtr));

    rc = internal_cpssDxChIpCntSetModeGet(devNum, cntSet, cntSetModePtr, interfaceModeCfgPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cntSet, cntSetModePtr, interfaceModeCfgPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpCntSet function
* @endinternal
*
* @brief   set the requested IP counter set.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] cntSet                   - counters set to clear.
* @param[in] countersPtr              - the counter values to set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpCntSet
(
    IN GT_U8                         devNum,
    IN CPSS_IP_CNT_SET_ENT           cntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    return cpssDxChIpPortGroupCntSet(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                     cntSet, countersPtr);

}

/**
* @internal cpssDxChIpCntSet function
* @endinternal
*
* @brief   set the requested IP counter set.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] cntSet                   - counters set to clear.
* @param[in] countersPtr              - the counter values to set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpCntSet
(
    IN GT_U8                         devNum,
    IN CPSS_IP_CNT_SET_ENT           cntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpCntSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cntSet, countersPtr));

    rc = internal_cpssDxChIpCntSet(devNum, cntSet, countersPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cntSet, countersPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllSkippedEntriesCountersGet function
* @endinternal
*
* @brief   Get MLL entries skipped counter.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] skipCounterPtr           - (pointer to) number of MLL entries skipped.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllSkippedEntriesCountersGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *skipCounterPtr
)
{
    return cpssDxChIpMllPortGroupSkippedEntriesCountersGet(devNum,
                                            CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                            skipCounterPtr);
}

/**
* @internal cpssDxChIpMllSkippedEntriesCountersGet function
* @endinternal
*
* @brief   Get MLL entries skipped counter.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] skipCounterPtr           - (pointer to) number of MLL entries skipped.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMllSkippedEntriesCountersGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *skipCounterPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllSkippedEntriesCountersGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, skipCounterPtr));

    rc = internal_cpssDxChIpMllSkippedEntriesCountersGet(devNum, skipCounterPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, skipCounterPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllPortGroupSkippedEntriesCountersGet function
* @endinternal
*
* @brief   Get MLL entries skipped counter.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] skipCounterPtr           - (pointer to) number of MLL entries skipped.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllPortGroupSkippedEntriesCountersGet
(
    IN  GT_U8                    devNum,
    IN  GT_PORT_GROUPS_BMP       portGroupsBmp,
    OUT GT_U32                   *skipCounterPtr
)
{
    GT_STATUS rc;         /* return code      */
    GT_U32    regAddr;    /* register address */
    GT_U32    regData;    /* register data    */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(skipCounterPtr);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.IPMLLSkippedEntriesCntr;

    /* summary the counter from all port groups */
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                                0, 32, &regData,
                                                NULL);
    if( rc != GT_OK )
    {
        return rc;
    }

    *skipCounterPtr =  regData;

    return rc;

}

/**
* @internal cpssDxChIpMllPortGroupSkippedEntriesCountersGet function
* @endinternal
*
* @brief   Get MLL entries skipped counter.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] skipCounterPtr           - (pointer to) number of MLL entries skipped.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMllPortGroupSkippedEntriesCountersGet
(
    IN  GT_U8                    devNum,
    IN  GT_PORT_GROUPS_BMP       portGroupsBmp,
    OUT GT_U32                   *skipCounterPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllPortGroupSkippedEntriesCountersGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, skipCounterPtr));

    rc = internal_cpssDxChIpMllPortGroupSkippedEntriesCountersGet(devNum, portGroupsBmp, skipCounterPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, skipCounterPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpSetMllCntInterface function
* @endinternal
*
* @brief   Sets a mll counter set's bounded inteface.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] mllCntSet                - mll counter set
*                                      (APPLICABLE RANGES: 0..1)
* @param[in] interfaceCfgPtr          - the mll counter interface configuration
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpSetMllCntInterface
(
    IN GT_U8                                       devNum,
    IN GT_U32                                      mllCntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceCfgPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    regAddr2;             /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    fieldData = 0;        /* Data to read/write */
    GT_U32    data = 0;
    GT_U32    data2 = 0;
    GT_U32    hwPort,hwDev;
    GT_BOOL   setSecondReg;

    CPSS_NULL_PTR_CHECK_MAC(interfaceCfgPtr);

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /* DxCh supports 2 mll counters*/
    if(mllCntSet > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr  = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.IPMLLOutInterfaceCntrConfig[mllCntSet];
        regAddr2 = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.IPMLLOutInterfaceCntrConfig1[mllCntSet];

        data = 0;
        data2 = 0;
        setSecondReg = GT_FALSE;

        switch (interfaceCfgPtr->portTrunkCntMode)
        {
            case CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E:
                break;
            case CPSS_DXCH_IP_PORT_CNT_MODE_E:
                data |= (0x1 << 30); /* <bits 30:31> = 1 indicates count port */
                if (interfaceCfgPtr->portTrunk.port > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_E_PORT_MAC(devNum))
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                if (interfaceCfgPtr->hwDevNum > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum))
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                data2 |= interfaceCfgPtr->portTrunk.port & 0xFFFFF;
                data2 |= ((interfaceCfgPtr->hwDevNum ) & 0xFFF) << 20;
                setSecondReg = GT_TRUE;
                break;
            case CPSS_DXCH_IP_TRUNK_CNT_MODE_E:
                data |= (0x2 << 30); /* <bits 30:31> = 2 indicates count trunk */
                if (interfaceCfgPtr->portTrunk.trunk > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum))
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                data2 |= interfaceCfgPtr->portTrunk.trunk & 0xFFF;
                setSecondReg = GT_TRUE;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        switch (interfaceCfgPtr->vlanMode)
        {
            case CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E:
                break;
            case CPSS_DXCH_IP_USE_VLAN_CNT_MODE_E:
                if (interfaceCfgPtr->vlanId > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_VID_MAC(devNum))
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                data  |= (0x1 << 26); /* <bit 26> = 1 indicates count vlan */
                data  |= ((interfaceCfgPtr->vlanId & 0xFFFF) << 10);
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        switch (interfaceCfgPtr->ipMode)
        {
            case CPSS_IP_PROTOCOL_IPV4_E:
                data |= (0x1 << 27); /* <bits 27:28> = 1 indicates count ipv4 */
                break;
            case CPSS_IP_PROTOCOL_IPV6_E:
                data |= (0x2 << 27); /* <bits 27:28> = 2 indicates count ipv6 */
                break;
            case CPSS_IP_PROTOCOL_IPV4V6_E:
                data |= (0x0 << 27); /* <bits 27:28> = 0 indicates count all */
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        rc = prvCpssHwPpWriteRegister(devNum,regAddr,data);
        if (rc != GT_OK)
            return rc;

        /* on some cases, there is no need to set second register */
        if(setSecondReg == GT_TRUE)
        {
            rc = prvCpssHwPpWriteRegister(devNum,regAddr2,data2);
            if (rc != GT_OK)
                return rc;
        }
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllOutInterfaceCfg[mllCntSet];

        switch (interfaceCfgPtr->portTrunkCntMode)
        {

            case CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E:
                /*counter-set counts packets Received/Transmitted via binded Port+Dev*/
                rc = prvCpssHwPpSetRegField(devNum,regAddr,30,2,0);
                break;
            case CPSS_DXCH_IP_TRUNK_CNT_MODE_E:
                if(interfaceCfgPtr->portTrunk.trunk >= BIT_7)
                {
                    /* 7 bits in HW */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /* Set port\trunk mode to trunk */
                rc = prvCpssHwPpSetRegField(devNum,regAddr, 30, 2, 2);
                if(GT_OK != rc)
                    return rc;
                /* Set 7 bits of the port\trunk filed and the 8th is 0. */
                rc = prvCpssHwPpSetRegField(devNum,regAddr,0, 8,
                                               interfaceCfgPtr->portTrunk.trunk);

                break;
            case CPSS_DXCH_IP_PORT_CNT_MODE_E:
                PRV_CPSS_DXCH_DUAL_HW_DEVICE_AND_PORT_CHECK_MAC(
                    interfaceCfgPtr->hwDevNum,
                    interfaceCfgPtr->portTrunk.port);
                hwDev =  PRV_CPSS_DXCH_DUAL_HW_DEVICE_CONVERT_DEV_MAC(
                    interfaceCfgPtr->hwDevNum,
                    interfaceCfgPtr->portTrunk.port);
                hwPort = PRV_CPSS_DXCH_DUAL_HW_DEVICE_CONVERT_PORT_MAC(
                    interfaceCfgPtr->hwDevNum,
                    interfaceCfgPtr->portTrunk.port);
                if(hwPort >= BIT_6)
                {
                    /* 6 bits in HW */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                if(hwDev >= BIT_5)
                {
                    /* 5 bits in HW */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /* Set port\trunk mode to port */
                rc = prvCpssHwPpSetRegField(devNum,regAddr, 30, 2, 1);
                if(GT_OK != rc)
                    return rc;

                /* Set 6 bits of the port\trunk filed and bits 7,8 are 0. */
                rc = prvCpssHwPpSetRegField(devNum,regAddr, 0, 8,hwPort);
                if(GT_OK != rc)
                    return rc;

                /* Set Dev*/
                rc = prvCpssHwPpSetRegField(devNum,regAddr, 8, 5,hwDev);

                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

        }

        if(GT_OK != rc)
            return rc;

        /* Set IpMode */
        switch(interfaceCfgPtr->ipMode)
        {
            case CPSS_IP_PROTOCOL_IPV4_E:
                fieldData = 1;
                break;
            case CPSS_IP_PROTOCOL_IPV6_E:
                fieldData = 2;
                break;
            case CPSS_IP_PROTOCOL_IPV4V6_E:
                fieldData = 0;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        rc = prvCpssHwPpSetRegField(devNum,regAddr,27,2,fieldData);
        if(GT_OK != rc)
            return rc;


        /* Set vlan mode & vid*/
        switch (interfaceCfgPtr->vlanMode)
        {
            case CPSS_DXCH_IP_USE_VLAN_CNT_MODE_E:
                if(interfaceCfgPtr->vlanId >= BIT_12)
                {
                    /* 12 bits in HW */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                rc = prvCpssHwPpSetRegField(devNum,regAddr,26,1,1);
                if(GT_OK != rc)
                    return rc;

                rc = prvCpssHwPpSetRegField(devNum,regAddr,14,12,
                                               interfaceCfgPtr->vlanId);
                break;

            case CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E:
                rc = prvCpssHwPpSetRegField(devNum,regAddr,26,1,0);
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    return rc;

}

/**
* @internal cpssDxChIpSetMllCntInterface function
* @endinternal
*
* @brief   Sets a mll counter set's bounded inteface.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] mllCntSet                - mll counter set
*                                      (APPLICABLE RANGES: 0..1)
* @param[in] interfaceCfgPtr          - the mll counter interface configuration
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpSetMllCntInterface
(
    IN GT_U8                                       devNum,
    IN GT_U32                                      mllCntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceCfgPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpSetMllCntInterface);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mllCntSet, interfaceCfgPtr));

    rc = internal_cpssDxChIpSetMllCntInterface(devNum, mllCntSet, interfaceCfgPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mllCntSet, interfaceCfgPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllCntGet function
* @endinternal
*
* @brief   Get the mll counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number.
* @param[in] mllCntSet                - the mll counter set out of the 2
*
* @param[out] mllOutMCPktsPtr          - According to the configuration of this cnt set, The
*                                      number of routed IP Multicast packets Duplicated by the
*                                      MLL Engine and transmitted via this interface
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllCntGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  mllCntSet,
    OUT GT_U32  *mllOutMCPktsPtr
)
{
    return cpssDxChIpPortGroupMllCntGet(devNum,
                                        CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                        mllCntSet, mllOutMCPktsPtr);
}

/**
* @internal cpssDxChIpMllCntGet function
* @endinternal
*
* @brief   Get the mll counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number.
* @param[in] mllCntSet                - the mll counter set out of the 2
*
* @param[out] mllOutMCPktsPtr          - According to the configuration of this cnt set, The
*                                      number of routed IP Multicast packets Duplicated by the
*                                      MLL Engine and transmitted via this interface
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMllCntGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  mllCntSet,
    OUT GT_U32  *mllOutMCPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mllCntSet, mllOutMCPktsPtr));

    rc = internal_cpssDxChIpMllCntGet(devNum, mllCntSet, mllOutMCPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mllCntSet, mllOutMCPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllCntSet function
* @endinternal
*
* @brief   set an mll counter.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - the device number
* @param[in] mllCntSet                - the mll counter set out of the 2
* @param[in] mllOutMCPkts             - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllCntSet
(
    IN GT_U8    devNum,
    IN GT_U32   mllCntSet,
    IN GT_U32   mllOutMCPkts
)
{
    return cpssDxChIpPortGroupMllCntSet(devNum,
                                        CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                        mllCntSet, mllOutMCPkts);
}

/**
* @internal cpssDxChIpMllCntSet function
* @endinternal
*
* @brief   set an mll counter.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - the device number
* @param[in] mllCntSet                - the mll counter set out of the 2
* @param[in] mllOutMCPkts             - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMllCntSet
(
    IN GT_U8    devNum,
    IN GT_U32   mllCntSet,
    IN GT_U32   mllOutMCPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllCntSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mllCntSet, mllOutMCPkts));

    rc = internal_cpssDxChIpMllCntSet(devNum, mllCntSet, mllOutMCPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mllCntSet, mllOutMCPkts));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllSilentDropCntGet function
* @endinternal
*
* @brief   Get the silent drops in the MLL priority queues.
*         A silent drop is a drop that is applied to a replica of the packet that
*         was previously replicated in the TTI.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
*
* @param[out] silentDropPktsPtr        - (pointer to) the number of counted silent dropped packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllSilentDropCntGet
(
    IN  GT_U8  devNum,
    OUT GT_U32 *silentDropPktsPtr
)
{
    return cpssDxChIpMllPortGroupSilentDropCntGet(devNum,
                                         CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                         silentDropPktsPtr);
}

/**
* @internal cpssDxChIpMllSilentDropCntGet function
* @endinternal
*
* @brief   Get the silent drops in the MLL priority queues.
*         A silent drop is a drop that is applied to a replica of the packet that
*         was previously replicated in the TTI.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
*
* @param[out] silentDropPktsPtr        - (pointer to) the number of counted silent dropped packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMllSilentDropCntGet
(
    IN  GT_U8  devNum,
    OUT GT_U32 *silentDropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllSilentDropCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, silentDropPktsPtr));

    rc = internal_cpssDxChIpMllSilentDropCntGet(devNum, silentDropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, silentDropPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllPortGroupSilentDropCntGet function
* @endinternal
*
* @brief   Get the silent drops in the MLL priority queues.
*         A silent drop is a drop that is applied to a replica of the packet that
*         was previously replicated in the TTI.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] silentDropPktsPtr        - (pointer to) the number of counted silent dropped packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllPortGroupSilentDropCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *silentDropPktsPtr
)
{
    GT_STATUS rc;                   /* return code                        */
    GT_U32    regAddr;              /* register address                   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(silentDropPktsPtr);


    regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.MLLSilentDropCntr;

    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                                0, 32, silentDropPktsPtr, NULL);
    return rc;
}

/**
* @internal cpssDxChIpMllPortGroupSilentDropCntGet function
* @endinternal
*
* @brief   Get the silent drops in the MLL priority queues.
*         A silent drop is a drop that is applied to a replica of the packet that
*         was previously replicated in the TTI.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] silentDropPktsPtr        - (pointer to) the number of counted silent dropped packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMllPortGroupSilentDropCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *silentDropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllPortGroupSilentDropCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, silentDropPktsPtr));

    rc = internal_cpssDxChIpMllPortGroupSilentDropCntGet(devNum, portGroupsBmp, silentDropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, silentDropPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}
/**
* @internal internal_cpssDxChIpDropCntSet function
* @endinternal
*
* @brief   set the drop counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] dropPkts                 - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpDropCntSet
(
    IN GT_U8 devNum,
    IN GT_U32 dropPkts
)
{
    return cpssDxChIpPortGroupDropCntSet(devNum,
                                         CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                         dropPkts);
}

/**
* @internal cpssDxChIpDropCntSet function
* @endinternal
*
* @brief   set the drop counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] dropPkts                 - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpDropCntSet
(
    IN GT_U8 devNum,
    IN GT_U32 dropPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpDropCntSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropPkts));

    rc = internal_cpssDxChIpDropCntSet(devNum, dropPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropPkts));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpSetDropCntMode function
* @endinternal
*
* @brief   Sets the drop counter count mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] dropCntMode              - the drop counter count mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpSetDropCntMode
(
    IN GT_U8                          devNum,
    IN CPSS_DXCH_IP_DROP_CNT_MODE_ENT dropCntMode
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    value;                /* value to write to register         */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerDropCntr.routerDropCntrConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerDropCntCfgReg;
    }

    switch (dropCntMode)
    {
        case CPSS_DXCH_IP_DROP_CNT_COUNT_ALL_MODE_E             :
            value = 0;
            break;
        case CPSS_DXCH_IP_DROP_CNT_IP_HEADER_MODE_E             :
            value = 1;
            break;
        case CPSS_DXCH_IP_DROP_CNT_DIP_DA_MISMATCH_MODE_E       :
            value = 2;
            break;
        case CPSS_DXCH_IP_DROP_CNT_ILLEGAL_ADDRESS_MODE_E       :
            value = 3;
            break;
        case CPSS_DXCH_IP_DROP_CNT_SIP_ALL_ZEROS_MODE_E         :
            value = 4;
            break;
        case CPSS_DXCH_IP_DROP_CNT_SIP_SA_MISMATCH_MODE_E       :
            value = 5;
            break;
        case CPSS_DXCH_IP_DROP_CNT_UC_RPF_MODE_E                :
            value = 6;
            break;
        case CPSS_DXCH_IP_DROP_CNT_NH_CMD_MODE_E                :
            value = 7;
            break;
        case CPSS_DXCH_IP_DROP_CNT_MC_RPF_MODE_E                :
            value = 8;
            break;
        case CPSS_DXCH_IP_DROP_CNT_TTL_HOP_LIMIT_EXCEEDED_MODE_E:
            value = 9;
            break;
        case CPSS_DXCH_IP_DROP_CNT_MTU_EXCEEDED_MODE_E          :
            value = 10;
            break;
        case CPSS_DXCH_IP_DROP_CNT_OPTION_MODE_E                :
            value = 11;
            break;
        case CPSS_DXCH_IP_DROP_CNT_IPV6_SCOPE_MODE_E            :
            value = 13;
            break;
        case CPSS_DXCH_IP_DROP_CNT_UC_SIP_FILTER_MODE_E         :
            value = 14;
            break;
        case CPSS_DXCH_IP_DROP_CNT_ACCESS_MATRIX_MODE_E         :
            value = 15;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return prvCpssHwPpSetRegField(devNum,regAddr, 0,4, value);
}

/**
* @internal cpssDxChIpSetDropCntMode function
* @endinternal
*
* @brief   Sets the drop counter count mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] dropCntMode              - the drop counter count mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpSetDropCntMode
(
    IN GT_U8                          devNum,
    IN CPSS_DXCH_IP_DROP_CNT_MODE_ENT dropCntMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpSetDropCntMode);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropCntMode));

    rc = internal_cpssDxChIpSetDropCntMode(devNum, dropCntMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropCntMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpGetDropCntMode function
* @endinternal
*
* @brief   Gets the drop counter count mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] dropCntModePtr           - (pointer to) the drop counter count mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpGetDropCntMode
(
    IN  GT_U8                          devNum,
    OUT CPSS_DXCH_IP_DROP_CNT_MODE_ENT *dropCntModePtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    value;                /* value to write to register         */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if (dropCntModePtr == NULL)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PTR, LOG_ERROR_NO_MSG);
    }

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerDropCntr.routerDropCntrConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerDropCntCfgReg;
    }

    rc = prvCpssHwPpGetRegField(devNum,regAddr, 0,4, &value);
    if (rc != GT_OK)
        {
        return rc;
    }

    switch (value)
    {
        case 0:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_COUNT_ALL_MODE_E;
            break;
        case 1:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_IP_HEADER_MODE_E;
            break;
        case 2:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_DIP_DA_MISMATCH_MODE_E;
            break;
        case 3:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_ILLEGAL_ADDRESS_MODE_E;
            break;
        case 4:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_SIP_ALL_ZEROS_MODE_E;
            break;
        case 5:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_SIP_SA_MISMATCH_MODE_E;
            break;
        case 6:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_UC_RPF_MODE_E;
            break;
        case 7:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_NH_CMD_MODE_E;
            break;
        case 8:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_MC_RPF_MODE_E;
            break;
        case 9:
            *dropCntModePtr =
                            CPSS_DXCH_IP_DROP_CNT_TTL_HOP_LIMIT_EXCEEDED_MODE_E;
            break;
        case 10:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_MTU_EXCEEDED_MODE_E;
            break;
        case 11:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_OPTION_MODE_E;
            break;
        case 13:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_IPV6_SCOPE_MODE_E;
            break;
        case 14:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_UC_SIP_FILTER_MODE_E;
            break;
        case 15:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_ACCESS_MATRIX_MODE_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @internal cpssDxChIpGetDropCntMode function
* @endinternal
*
* @brief   Gets the drop counter count mode.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] dropCntModePtr           - (pointer to) the drop counter count mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpGetDropCntMode
(
    IN  GT_U8                          devNum,
    OUT CPSS_DXCH_IP_DROP_CNT_MODE_ENT *dropCntModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpGetDropCntMode);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropCntModePtr));

    rc = internal_cpssDxChIpGetDropCntMode(devNum, dropCntModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropCntModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpDropCntGet function
* @endinternal
*
* @brief   Get the drop counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] dropPktsPtr              - the number of counted dropped packets according to the
*                                      drop counter mode.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpDropCntGet
(
    IN  GT_U8  devNum,
    OUT GT_U32 *dropPktsPtr
)
{
    return cpssDxChIpPortGroupDropCntGet(devNum,
                                         CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                         dropPktsPtr);
}

/**
* @internal cpssDxChIpDropCntGet function
* @endinternal
*
* @brief   Get the drop counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] dropPktsPtr              - the number of counted dropped packets according to the
*                                      drop counter mode.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpDropCntGet
(
    IN  GT_U8  devNum,
    OUT GT_U32 *dropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpDropCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropPktsPtr));

    rc = internal_cpssDxChIpDropCntGet(devNum, dropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMtuProfileSet function
* @endinternal
*
* @brief   Sets the next hop interface MTU profile limit value.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] mtu                      - the mtu profile index out of the possible 8 (APPLICABLE RANGES: 0..7).
* @param[in] mtu                      - the maximum transmission unit (APPLICABLE RANGES: 0..0x3FFF).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMtuProfileSet
(
    IN GT_U8  devNum,
    IN GT_U32 mtuProfileIndex,
    IN GT_U32 mtu
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32  i,bits_offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(mtuProfileIndex > 7)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if(mtu > 0x3FFF)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    i = mtuProfileIndex/2;
    bits_offset = mtuProfileIndex % 2;

    /* for index =0,1 -> offset 0x4, 1,2 - 0x8 end and so on*/
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerMTUConfigReg[i];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMtuCfgRegs[i];
    }

    bits_offset *=14;

    rc = prvCpssHwPpSetRegField(devNum,regAddr,bits_offset ,14,mtu);
    return rc;
}

/**
* @internal cpssDxChIpMtuProfileSet function
* @endinternal
*
* @brief   Sets the next hop interface MTU profile limit value.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] mtu                      - the mtu profile index out of the possible 8 (APPLICABLE RANGES: 0..7).
* @param[in] mtu                      - the maximum transmission unit (APPLICABLE RANGES: 0..0x3FFF).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMtuProfileSet
(
    IN GT_U8  devNum,
    IN GT_U32 mtuProfileIndex,
    IN GT_U32 mtu
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMtuProfileSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mtuProfileIndex, mtu));

    rc = internal_cpssDxChIpMtuProfileSet(devNum, mtuProfileIndex, mtu);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mtuProfileIndex, mtu));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMtuProfileGet function
* @endinternal
*
* @brief   Gets the next hop interface MTU profile limit value.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] mtuProfileIndex          - the mtu profile index out of the possible 8 (APPLICABLE RANGES: 0..7).
*
* @param[out] mtuPtr                   - the maximum transmission unit
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL pointer
*/
static GT_STATUS internal_cpssDxChIpMtuProfileGet
(
    IN GT_U8  devNum,
    IN GT_U32 mtuProfileIndex,
    OUT GT_U32 *mtuPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32  i,bits_offset;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(mtuPtr);

    if(mtuProfileIndex > 7)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);


    i = mtuProfileIndex/2;
    bits_offset = mtuProfileIndex % 2;

    /* for index =0,1 -> offset 0x4, 1,2 - 0x8 end and so on*/
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerMTUConfigReg[i];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMtuCfgRegs[i];
    }

    bits_offset *=14;

    rc = prvCpssHwPpGetRegField(devNum,regAddr,bits_offset ,14,mtuPtr);
    return rc;
}

/**
* @internal cpssDxChIpMtuProfileGet function
* @endinternal
*
* @brief   Gets the next hop interface MTU profile limit value.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] mtuProfileIndex          - the mtu profile index out of the possible 8 (APPLICABLE RANGES: 0..7).
*
* @param[out] mtuPtr                   - the maximum transmission unit
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - on NULL pointer
*/
GT_STATUS cpssDxChIpMtuProfileGet
(
    IN GT_U8  devNum,
    IN GT_U32 mtuProfileIndex,
    OUT GT_U32 *mtuPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMtuProfileGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mtuProfileIndex, mtuPtr));

    rc = internal_cpssDxChIpMtuProfileGet(devNum, mtuProfileIndex, mtuPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mtuProfileIndex, mtuPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpv6AddrPrefixScopeSet function
* @endinternal
*
* @brief   Defines a prefix of a scope type.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] prefixPtr                - a pointer to IPv6 address prefix
* @param[in] prefixLen                - length of the prefix (APPLICABLE RANGES: 0..16)
* @param[in] addressScope             - type of the address scope spanned by the prefix
* @param[in] prefixScopeIndex         - index of the new prefix scope entry (APPLICABLE RANGES: 0..3)
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on error.
* @retval GT_BAD_PARAM             - case that the prefix length is out of range.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Configures an entry in the prefix look up table
*
*/
static GT_STATUS internal_cpssDxChIpv6AddrPrefixScopeSet
(
    IN  GT_U8                           devNum,
    IN  GT_IPV6ADDR                    *prefixPtr,
    IN  GT_U32                          prefixLen,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT      addressScope,
    IN  GT_U32                          prefixScopeIndex
)
{

    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_STATUS addressScopeValue;

    GT_U32      value=0, mask=0, prefixValue=0;     /* value to write   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if (prefixLen > 16)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    switch(addressScope)
    {
    case CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E:
        addressScopeValue = 0;
        break;
    case CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E:
        addressScopeValue = 1;
        break;
    case CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E:
        addressScopeValue = 2;
        break;
    case CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E:
        addressScopeValue = 3;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(prefixScopeIndex > 3)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    mask = (0xFFFF << (16-prefixLen))  & 0xFFFF;

    prefixValue = prefixPtr->arIP[0] << 8;
    prefixValue = prefixValue | prefixPtr->arIP[1];
    prefixValue = 0x0000FFFF & prefixValue;

    if((~mask & prefixValue) & 0xFFFF)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    mask = mask << 16;
    value = prefixValue | mask;

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopePrefix[prefixScopeIndex];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ipScopeRegs[prefixScopeIndex];
    }

    rc = prvCpssHwPpWriteRegister(devNum,regAddr,value);
    if (rc != GT_OK)
        {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopeLevel[prefixScopeIndex];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ipScopeLevel[prefixScopeIndex];
    }

    rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 2, addressScopeValue);

    return rc;

}

/**
* @internal cpssDxChIpv6AddrPrefixScopeSet function
* @endinternal
*
* @brief   Defines a prefix of a scope type.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] prefixPtr                - a pointer to IPv6 address prefix
* @param[in] prefixLen                - length of the prefix (APPLICABLE RANGES: 0..16)
* @param[in] addressScope             - type of the address scope spanned by the prefix
* @param[in] prefixScopeIndex         - index of the new prefix scope entry (APPLICABLE RANGES: 0..3)
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on error.
* @retval GT_BAD_PARAM             - case that the prefix length is out of range.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Configures an entry in the prefix look up table
*
*/
GT_STATUS cpssDxChIpv6AddrPrefixScopeSet
(
    IN  GT_U8                           devNum,
    IN  GT_IPV6ADDR                    *prefixPtr,
    IN  GT_U32                          prefixLen,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT      addressScope,
    IN  GT_U32                          prefixScopeIndex
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6AddrPrefixScopeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, prefixPtr, prefixLen, addressScope, prefixScopeIndex));

    rc = internal_cpssDxChIpv6AddrPrefixScopeSet(devNum, prefixPtr, prefixLen, addressScope, prefixScopeIndex);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, prefixPtr, prefixLen, addressScope, prefixScopeIndex));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpv6AddrPrefixScopeGet function
* @endinternal
*
* @brief   Get a prefix of a scope type.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] prefixScopeIndex         - index of the new prefix scope entry (APPLICABLE RANGES: 0..3)
*
* @param[out] prefixPtr                - an IPv6 address prefix
* @param[out] prefixLenPtr             - length of the prefix
* @param[out] addressScopePtr          - type of the address scope spanned by the prefix
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on error.
* @retval GT_BAD_PARAM             - case that the prefix length is out of range.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL ptr
*/
static GT_STATUS internal_cpssDxChIpv6AddrPrefixScopeGet
(
    IN  GT_U8                           devNum,
    OUT GT_IPV6ADDR                     *prefixPtr,
    OUT GT_U32                          *prefixLenPtr,
    OUT CPSS_IPV6_PREFIX_SCOPE_ENT      *addressScopePtr,
    IN  GT_U32                          prefixScopeIndex
)
{
    GT_U32      regAddr;              /* register address  */
    GT_STATUS   rc;                   /* return code  */
    GT_U32      addressScopeValue;
    GT_U32      hwValue;              /* hwValue */
    GT_U32      mask = 0;
    GT_U32      tmp = 0;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(prefixPtr);
    CPSS_NULL_PTR_CHECK_MAC(prefixLenPtr);
    CPSS_NULL_PTR_CHECK_MAC(addressScopePtr);

    if(prefixScopeIndex > 3)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopePrefix[prefixScopeIndex];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ipScopeRegs[prefixScopeIndex];
    }

    rc = prvCpssHwPpReadRegister(devNum,regAddr,&hwValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    /* calculate prefix len from hwValue */
    mask = hwValue >> 16;

    while ( ((mask >> (15 - tmp)) & 0x1)  &&  tmp <= 15)
    {
        tmp++;
    }

    *prefixLenPtr = tmp;


    /* calculate IPv6 address prefix from hwValue */
    prefixPtr->arIP[1] = (GT_U8)(hwValue & 0xFF);
    prefixPtr->arIP[0] = (GT_U8)((hwValue>>8) & 0xFF);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopeLevel[prefixScopeIndex];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ipScopeLevel[prefixScopeIndex];
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 2, &addressScopeValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    switch(addressScopeValue)
    {
    case 0:
        *addressScopePtr = CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E;
        break;
    case 1:
        *addressScopePtr = CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E;
        break;
    case 2:
        *addressScopePtr = CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E;
        break;
    case 3:
        *addressScopePtr = CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @internal cpssDxChIpv6AddrPrefixScopeGet function
* @endinternal
*
* @brief   Get a prefix of a scope type.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] prefixScopeIndex         - index of the new prefix scope entry (APPLICABLE RANGES: 0..3)
*
* @param[out] prefixPtr                - an IPv6 address prefix
* @param[out] prefixLenPtr             - length of the prefix
* @param[out] addressScopePtr          - type of the address scope spanned by the prefix
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on error.
* @retval GT_BAD_PARAM             - case that the prefix length is out of range.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL ptr
*/
GT_STATUS cpssDxChIpv6AddrPrefixScopeGet
(
    IN  GT_U8                           devNum,
    OUT GT_IPV6ADDR                     *prefixPtr,
    OUT GT_U32                          *prefixLenPtr,
    OUT CPSS_IPV6_PREFIX_SCOPE_ENT      *addressScopePtr,
    IN  GT_U32                          prefixScopeIndex
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6AddrPrefixScopeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, prefixPtr, prefixLenPtr, addressScopePtr, prefixScopeIndex));

    rc = internal_cpssDxChIpv6AddrPrefixScopeGet(devNum, prefixPtr, prefixLenPtr, addressScopePtr, prefixScopeIndex);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, prefixPtr, prefixLenPtr, addressScopePtr, prefixScopeIndex));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpv6UcScopeCommandSet function
* @endinternal
*
* @brief   sets the ipv6 Unicast scope commands.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] addressScopeSrc          - IPv6 address scope of source address
* @param[in] addressScopeDest         - IPv6 address scope of destination address
* @param[in] borderCrossed            - GT_TRUE if source site ID is diffrent to destination
*                                      site ID
* @param[in] scopeCommand             - action to be done on a packet that match the above
*                                      scope configuration.
*                                      possible commands:
*                                      CPSS_PACKET_CMD_ROUTE_E,
*                                      CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                                      CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                                      CPSS_PACKET_CMD_DROP_SOFT_E,
*                                      CPSS_PACKET_CMD_DROP_HARD_E
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error.
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_NO_RESOURCE           - if failed to allocate CPU memory
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpv6UcScopeCommandSet
(
    IN GT_U8                      devNum,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeSrc,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeDest,
    IN GT_BOOL                    borderCrossed,
    IN CPSS_PACKET_CMD_ENT        scopeCommand
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32      value=0;        /* value to write   */
    GT_U32   offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if ((addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if ((addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopeTableReg[addressScopeSrc];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ucScopeTblRegs[addressScopeSrc];
    }

    /* if the border was not crossed, meaning source Site ID == Dest Site ID
       the offset=4. if the border was crossed the offset=0 */
    if (borderCrossed == GT_FALSE)
    {
        offset = 4;
    }
    else
    {
        offset = 0;
    }

    offset += (addressScopeDest*8);

    switch (scopeCommand)
    {
    case CPSS_PACKET_CMD_ROUTE_E:
        value = 0;
        break;

    case CPSS_PACKET_CMD_TRAP_TO_CPU_E:
        value = 2;
        break;

    case CPSS_PACKET_CMD_DROP_SOFT_E:
        value = 4;
        break;

    case CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E:
        value = 1;
        break;

    case CPSS_PACKET_CMD_DROP_HARD_E:
        value = 3;
        break;

    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, 3, value);

    return rc;
}

/**
* @internal cpssDxChIpv6UcScopeCommandSet function
* @endinternal
*
* @brief   sets the ipv6 Unicast scope commands.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] addressScopeSrc          - IPv6 address scope of source address
* @param[in] addressScopeDest         - IPv6 address scope of destination address
* @param[in] borderCrossed            - GT_TRUE if source site ID is diffrent to destination
*                                      site ID
* @param[in] scopeCommand             - action to be done on a packet that match the above
*                                      scope configuration.
*                                      possible commands:
*                                      CPSS_PACKET_CMD_ROUTE_E,
*                                      CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                                      CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                                      CPSS_PACKET_CMD_DROP_SOFT_E,
*                                      CPSS_PACKET_CMD_DROP_HARD_E
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error.
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_NO_RESOURCE           - if failed to allocate CPU memory
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpv6UcScopeCommandSet
(
    IN GT_U8                      devNum,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeSrc,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeDest,
    IN GT_BOOL                    borderCrossed,
    IN CPSS_PACKET_CMD_ENT        scopeCommand
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6UcScopeCommandSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand));

    rc = internal_cpssDxChIpv6UcScopeCommandSet(devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpv6UcScopeCommandGet function
* @endinternal
*
* @brief   gets the ipv6 Unicast scope commands.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] addressScopeSrc          - IPv6 address scope of source address
* @param[in] addressScopeDest         - IPv6 address scope of destination address
* @param[in] borderCrossed            - GT_TRUE if source site ID is diffrent to destination
*                                      site ID
*
* @param[out] scopeCommandPtr          - action to be done on a packet that match the above
*                                      scope configuration.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error.
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_NO_RESOURCE           - if failed to allocate CPU memory
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL ptr
*/
static GT_STATUS internal_cpssDxChIpv6UcScopeCommandGet
(
    IN  GT_U8                      devNum,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeSrc,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeDest,
    IN  GT_BOOL                    borderCrossed,
    OUT CPSS_PACKET_CMD_ENT        *scopeCommandPtr
)
{
    GT_U32      regAddr;          /* register address  */
    GT_STATUS   rc;               /* return code  */
    GT_U32      hwValue = 0;      /* hw value  */
    GT_U32      offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(scopeCommandPtr);

    if ((addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if ((addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopeTableReg[addressScopeSrc];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ucScopeTblRegs[addressScopeSrc];
    }

    /* if the border was not crossed, meaning source Site ID == Dest Site ID
       the offset=4. if the border was crossed the offset=0 */
    if (borderCrossed == GT_FALSE)
    {
        offset = 4;
    }
    else
    {
        offset = 0;
    }

    offset += (addressScopeDest*8);

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 3, &hwValue);
    if(GT_OK != rc)
    {
        return rc;
    }

    switch (hwValue)
    {
    case 0:
        *scopeCommandPtr = CPSS_PACKET_CMD_ROUTE_E;
        break;
    case 2:
        *scopeCommandPtr = CPSS_PACKET_CMD_TRAP_TO_CPU_E;
        break;
    case 4:
        *scopeCommandPtr = CPSS_PACKET_CMD_DROP_SOFT_E;
        break;
    case 1:
        *scopeCommandPtr = CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E;
        break;
    case 3:
        *scopeCommandPtr = CPSS_PACKET_CMD_DROP_HARD_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal cpssDxChIpv6UcScopeCommandGet function
* @endinternal
*
* @brief   gets the ipv6 Unicast scope commands.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] addressScopeSrc          - IPv6 address scope of source address
* @param[in] addressScopeDest         - IPv6 address scope of destination address
* @param[in] borderCrossed            - GT_TRUE if source site ID is diffrent to destination
*                                      site ID
*
* @param[out] scopeCommandPtr          - action to be done on a packet that match the above
*                                      scope configuration.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error.
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_NO_RESOURCE           - if failed to allocate CPU memory
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL ptr
*/
GT_STATUS cpssDxChIpv6UcScopeCommandGet
(
    IN  GT_U8                      devNum,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeSrc,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeDest,
    IN  GT_BOOL                    borderCrossed,
    OUT CPSS_PACKET_CMD_ENT        *scopeCommandPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6UcScopeCommandGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr));

    rc = internal_cpssDxChIpv6UcScopeCommandGet(devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpv6McScopeCommandSet function
* @endinternal
*
* @brief   sets the ipv6 Multicast scope commands.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] addressScopeSrc          - IPv6 address scope of source address
* @param[in] addressScopeDest         - IPv6 address scope of destination address
* @param[in] borderCrossed            - GT_TRUE if source site ID is diffrent to destination
*                                      site ID
* @param[in] scopeCommand             - action to be done on a packet that match the above
*                                      scope configuration.
*                                      possible commands:
*                                      CPSS_PACKET_CMD_ROUTE_E,
*                                      CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                                      CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                                      CPSS_PACKET_CMD_DROP_SOFT_E,
*                                      CPSS_PACKET_CMD_DROP_HARD_E,
*                                      CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,
*                                      CPSS_PACKET_CMD_BRIDGE_E
* @param[in] mllSelectionRule         - rule for choosing MLL for IPv6 Multicast propogation
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error.
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_NO_RESOURCE           - if failed to allocate CPU memory
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpv6McScopeCommandSet
(
    IN GT_U8                            devNum,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeSrc,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeDest,
    IN GT_BOOL                          borderCrossed,
    IN CPSS_PACKET_CMD_ENT              scopeCommand,
    IN CPSS_IPV6_MLL_SELECTION_RULE_ENT mllSelectionRule
)
{

    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32      value=0;        /* value to write   */
    GT_U32   offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if ((addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if ((addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6McScopeTableReg[addressScopeSrc];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.mcScopeTblRegs[addressScopeSrc];
    }

    switch (scopeCommand)
    {
        case CPSS_PACKET_CMD_ROUTE_E:
            value = 0;
            break;
        case CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E:
            value = 1;
            break;
        case CPSS_PACKET_CMD_TRAP_TO_CPU_E:
            value = 2;
            break;
        case CPSS_PACKET_CMD_DROP_HARD_E:
            value = 3;
            break;

        case CPSS_PACKET_CMD_DROP_SOFT_E:
            value = 4;
            break;

        case CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E:
            value = 5;
            break;
        case CPSS_PACKET_CMD_BRIDGE_E:
            value = 6;
                break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* if the border was not crossed, meaning source Site ID == Dest Site ID
       the offset=4. if the border was crossed the offset=0 */
    if (borderCrossed == GT_FALSE)
    {
        offset = 4;
    }
    else
    {
        offset = 0;
    }

    offset += (addressScopeDest*8);

    rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, 3, value);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

        /* write MLL Select */

    switch(mllSelectionRule)
    {
        case CPSS_IPV6_MLL_SELECTION_RULE_LOCAL_E:
             value = 0;
             break;
        case CPSS_IPV6_MLL_SELECTION_RULE_GLOBAL_E:
             value = 1;
             break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    rc = prvCpssHwPpSetRegField(devNum, regAddr, offset+3, 1, value);
    return rc;
}

/**
* @internal cpssDxChIpv6McScopeCommandSet function
* @endinternal
*
* @brief   sets the ipv6 Multicast scope commands.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] addressScopeSrc          - IPv6 address scope of source address
* @param[in] addressScopeDest         - IPv6 address scope of destination address
* @param[in] borderCrossed            - GT_TRUE if source site ID is diffrent to destination
*                                      site ID
* @param[in] scopeCommand             - action to be done on a packet that match the above
*                                      scope configuration.
*                                      possible commands:
*                                      CPSS_PACKET_CMD_ROUTE_E,
*                                      CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                                      CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                                      CPSS_PACKET_CMD_DROP_SOFT_E,
*                                      CPSS_PACKET_CMD_DROP_HARD_E,
*                                      CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,
*                                      CPSS_PACKET_CMD_BRIDGE_E
* @param[in] mllSelectionRule         - rule for choosing MLL for IPv6 Multicast propogation
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error.
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_NO_RESOURCE           - if failed to allocate CPU memory
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpv6McScopeCommandSet
(
    IN GT_U8                            devNum,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeSrc,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeDest,
    IN GT_BOOL                          borderCrossed,
    IN CPSS_PACKET_CMD_ENT              scopeCommand,
    IN CPSS_IPV6_MLL_SELECTION_RULE_ENT mllSelectionRule
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6McScopeCommandSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand, mllSelectionRule));

    rc = internal_cpssDxChIpv6McScopeCommandSet(devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand, mllSelectionRule);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand, mllSelectionRule));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpv6McScopeCommandGet function
* @endinternal
*
* @brief   gets the ipv6 Multicast scope commands.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] addressScopeSrc          - IPv6 address scope of source address
* @param[in] addressScopeDest         - IPv6 address scope of destination address
* @param[in] borderCrossed            - GT_TRUE if source site ID is diffrent to destination
*                                      site ID
*
* @param[out] scopeCommandPtr          - action to be done on a packet that match the above
*                                      scope configuration.
*                                      possible commands:
*                                      CPSS_PACKET_CMD_ROUTE_E,
*                                      CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                                      CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                                      CPSS_PACKET_CMD_DROP_SOFT_E,
*                                      CPSS_PACKET_CMD_DROP_HARD_E,
*                                      CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,
*                                      CPSS_PACKET_CMD_BRIDGE_E
* @param[out] mllSelectionRulePtr      - rule for choosing MLL for IPv6 Multicast propogation
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error.
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_NO_RESOURCE           - if failed to allocate CPU memory
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL ptr
*/
static GT_STATUS internal_cpssDxChIpv6McScopeCommandGet
(
    IN  GT_U8                            devNum,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeSrc,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeDest,
    IN  GT_BOOL                          borderCrossed,
    OUT CPSS_PACKET_CMD_ENT              *scopeCommandPtr,
    OUT CPSS_IPV6_MLL_SELECTION_RULE_ENT *mllSelectionRulePtr
)
{
    GT_U32      regAddr;            /* register address  */
    GT_STATUS   rc;                 /* return code  */
    GT_U32      hwValue=0;          /* hw value */
    GT_U32      offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(scopeCommandPtr);
    CPSS_NULL_PTR_CHECK_MAC(mllSelectionRulePtr);

    if ((addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if ((addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6McScopeTableReg[addressScopeSrc];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.mcScopeTblRegs[addressScopeSrc];
    }

    /* if the border was not crossed, meaning source Site ID == Dest Site ID
       the offset=4. if the border was crossed the offset=0 */
    if (borderCrossed == GT_FALSE)
    {
        offset = 4;
    }
    else
    {
        offset = 0;
    }

    offset += (addressScopeDest*8);

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 3, &hwValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    switch (hwValue)
    {
        case 0:
            *scopeCommandPtr = CPSS_PACKET_CMD_ROUTE_E;
            break;
        case 1:
            *scopeCommandPtr = CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E;
            break;
        case 2:
            *scopeCommandPtr = CPSS_PACKET_CMD_TRAP_TO_CPU_E;
            break;
        case 3:
            *scopeCommandPtr = CPSS_PACKET_CMD_DROP_HARD_E;
            break;
        case 4:
            *scopeCommandPtr = CPSS_PACKET_CMD_DROP_SOFT_E;
            break;
        case 5:
            *scopeCommandPtr = CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E;
            break;
        case 6:
            *scopeCommandPtr = CPSS_PACKET_CMD_BRIDGE_E;
                break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* read MLL Select */
    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset+3, 1, &hwValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    switch(hwValue)
    {
        case 0:
             *mllSelectionRulePtr = CPSS_IPV6_MLL_SELECTION_RULE_LOCAL_E;
             break;
        case 1:
             *mllSelectionRulePtr = CPSS_IPV6_MLL_SELECTION_RULE_GLOBAL_E;
             break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal cpssDxChIpv6McScopeCommandGet function
* @endinternal
*
* @brief   gets the ipv6 Multicast scope commands.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] addressScopeSrc          - IPv6 address scope of source address
* @param[in] addressScopeDest         - IPv6 address scope of destination address
* @param[in] borderCrossed            - GT_TRUE if source site ID is diffrent to destination
*                                      site ID
*
* @param[out] scopeCommandPtr          - action to be done on a packet that match the above
*                                      scope configuration.
*                                      possible commands:
*                                      CPSS_PACKET_CMD_ROUTE_E,
*                                      CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                                      CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                                      CPSS_PACKET_CMD_DROP_SOFT_E,
*                                      CPSS_PACKET_CMD_DROP_HARD_E,
*                                      CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,
*                                      CPSS_PACKET_CMD_BRIDGE_E
* @param[out] mllSelectionRulePtr      - rule for choosing MLL for IPv6 Multicast propogation
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_FAIL                  - on error.
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_NO_RESOURCE           - if failed to allocate CPU memory
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_BAD_PTR               - on NULL ptr
*/
GT_STATUS cpssDxChIpv6McScopeCommandGet
(
    IN  GT_U8                            devNum,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeSrc,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeDest,
    IN  GT_BOOL                          borderCrossed,
    OUT CPSS_PACKET_CMD_ENT              *scopeCommandPtr,
    OUT CPSS_IPV6_MLL_SELECTION_RULE_ENT *mllSelectionRulePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6McScopeCommandGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr, mllSelectionRulePtr));

    rc = internal_cpssDxChIpv6McScopeCommandGet(devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr, mllSelectionRulePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr, mllSelectionRulePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterMacSaBaseSet function
* @endinternal
*
* @brief   Sets most significant bits of Router MAC SA Base address on specified device.
*          For xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 it sets the 40 most significant bits
*          For other devices (Falcon; AC5P; AC5X; Harrier; Ironman) it sets the 36 most significant bits
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] macPtr                   - (pointer to)The system Mac address to set.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterMacSaBaseSet
(
    IN  GT_U8           devNum,
    IN  GT_ETHERADDR    *macPtr
)
{
    GT_U32  macBytes1234;          /* Holds bits 8 - 39 of mac   (bytes 1,2,3,4)  */
    GT_U32  macMsbByte;            /* Holds bits 40 - 47 of mac  (byte 0)  */
    GT_STATUS rc = GT_OK;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(macPtr);

    macBytes1234 = (macPtr->arEther[4]        |
                  (macPtr->arEther[3] << 8)  |
                  (macPtr->arEther[2] << 16) |
                  (macPtr->arEther[1] << 24));
    macMsbByte =  macPtr->arEther[0];

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssHwPpWriteRegister(devNum,
               PRV_DXCH_REG1_UNIT_HA_MAC(devNum).routerMACSABaseReg0,
               macBytes1234);
        if(rc != GT_OK)
            return rc;

        rc = prvCpssHwPpSetRegField(devNum,
               PRV_DXCH_REG1_UNIT_HA_MAC(devNum).routerMACSABaseReg1,
               0,8,
               macMsbByte);
    }
    else
    {
    rc = prvCpssHwPpWriteRegister(devNum,
           PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerMacSaBaseReg[0],macBytes1234);
    if(rc != GT_OK)
        return rc;

    rc = prvCpssHwPpSetRegField(devNum,
           PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerMacSaBaseReg[1],0,8,macMsbByte);
    }

    return rc;
}

/**
* @internal cpssDxChIpRouterMacSaBaseSet function
* @endinternal
*
* @brief   Sets most significant bits of Router MAC SA Base address on specified device.
*          For xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 it sets the 40 most significant bits
*          For other devices (Falcon; AC5P; AC5X; Harrier; Ironman) it sets the 36 most significant bits
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] macPtr                   - (pointer to)The system Mac address to set.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterMacSaBaseSet
(
    IN  GT_U8           devNum,
    IN  GT_ETHERADDR    *macPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterMacSaBaseSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, macPtr));

    rc = internal_cpssDxChIpRouterMacSaBaseSet(devNum, macPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, macPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterMacSaBaseGet function
* @endinternal
*
* @brief   Gets most significant bits of Router MAC SA Base
*          address on specified device.
*          For xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 it gets the 40 most significant bits
*          For other devices (Falcon; AC5P; AC5X; Harrier; Ironman) it gets the 36 most significant bits
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] macPtr                   - (pointer to)The system Mac address to set.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterMacSaBaseGet
(
    IN  GT_U8           devNum,
    OUT GT_ETHERADDR    *macPtr
)
{
    GT_STATUS rc;
    GT_U32  macBytes1234;          /* Holds bits 8 - 39 of mac   (bytes 1,2,3,4)  */
    GT_U32  macMsbByte;            /* Holds bits 40 - 47 of mac  (byte 0)  */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(macPtr);


    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssHwPpReadRegister(devNum,
               PRV_DXCH_REG1_UNIT_HA_MAC(devNum).routerMACSABaseReg0,
               &macBytes1234);
        if(rc != GT_OK)
            return rc;

        rc = prvCpssHwPpGetRegField(devNum,
               PRV_DXCH_REG1_UNIT_HA_MAC(devNum).routerMACSABaseReg1,
               0,8,
               &macMsbByte);
    }
    else
    {
        rc = prvCpssHwPpReadRegister(devNum,
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerMacSaBaseReg[0],&macBytes1234);
        if(rc != GT_OK)
            return rc;

        rc = prvCpssHwPpGetRegField(devNum,
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerMacSaBaseReg[1],0,8,&macMsbByte);
    }

    if(rc != GT_OK)
        return rc;

    macPtr->arEther[4] = (GT_U8)(macBytes1234 >>  0);
    macPtr->arEther[3] = (GT_U8)(macBytes1234 >>  8);
    macPtr->arEther[2] = (GT_U8)(macBytes1234 >> 16);
    macPtr->arEther[1] = (GT_U8)(macBytes1234 >> 24);
    macPtr->arEther[0] = (GT_U8)macMsbByte;

    return GT_OK;
}

/**
* @internal cpssDxChIpRouterMacSaBaseGet function
* @endinternal
*
* @brief   Gets most significant bits of Router MAC SA Base
*          address on specified device.
*          For xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 it gets the 40 most significant bits
*          For other devices (Falcon; AC5P; AC5X; Harrier; Ironman) it gets the 36 most significant bits
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] macPtr                   - (pointer to)The system Mac address to set.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterMacSaBaseGet
(
    IN  GT_U8           devNum,
    OUT GT_ETHERADDR    *macPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterMacSaBaseGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, macPtr));

    rc = internal_cpssDxChIpRouterMacSaBaseGet(devNum, macPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, macPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortRouterMacSaLsbModeSet function
* @endinternal
*
* @brief   Sets the mode, per port, in which the device sets the packet's MAC SA
*         least significant bytes.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number
* @param[in] saLsbMode                - The MAC SA least-significant bit mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum/saLsbMode.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The device 5 most significant bytes are set by cpssDxChIpRouterMacSaBaseSet().
*       The least significant bytes are set by:
*       Port mode is set by cpssDxChIpRouterPortMacSaLsbSet().
*       Vlan mode is set by cpssDxChIpRouterVlanMacSaLsbSet().
*
*/
static GT_STATUS internal_cpssDxChIpPortRouterMacSaLsbModeSet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  CPSS_MAC_SA_LSB_MODE_ENT    saLsbMode
)
{
    GT_U32      hwData; /* value to write into register   */
    GT_U32      regAddr;
    GT_U32      offset;
    GT_STATUS   rc;
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32       localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_CHECK_MAC(devNum, portNum);

    /* setting the Lsb mode */
    switch (saLsbMode)
    {
        case CPSS_SA_LSB_PER_PORT_E:
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                /* this mode is obsolete in the device ! */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            hwData = 2;
            break;
        case CPSS_SA_LSB_PER_PKT_VID_E:
            if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                /* this mode is obsolete in the device ! */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            hwData = 0;
            break;
        case CPSS_SA_LSB_PER_VLAN_E:
            hwData = 1;
            break;
        case CPSS_SA_LSB_FULL_48_BIT_GLOBAL:
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            hwData = 3;
            break;
        default:

        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                                CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
                                                portNum,
                                                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_ROUTER_MAC_SA_ASSIGNMENT_MODE_E, /* field name */
                                                PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                               hwData);
    }
    else
    {
        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
        localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerHdrAltMacSaModifyMode[localPort / 16];
        offset = (localPort % 16) * 2;
        rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,offset,2,hwData);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Packets of Egress STC and Egress Mirroring are handled by global port in the Header Alteration.
           For multi-port-groups devices repeat configuration for global port */

        if(portNum == localPort)
        {
            /* Configuration of overlapped ports (identical global and local ports numbers)
               will lead to miss configuration for local ports in other port groups */
            return rc;
        }

        /* Port numbers range for the registers [0..63] */
        portNum &= 0x3f;
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerHdrAltMacSaModifyMode[portNum / 16];
        offset = (portNum % 16) * 2;

        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            rc = prvCpssHwPpPortGroupSetRegField(devNum,
                                                    portGroupId,
                                                    regAddr,
                                                    offset,
                                                    2, hwData);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    }
    return rc;
}

/**
* @internal cpssDxChIpPortRouterMacSaLsbModeSet function
* @endinternal
*
* @brief   Sets the mode, per port, in which the device sets the packet's MAC SA
*         least significant bytes.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number
* @param[in] saLsbMode                - The MAC SA least-significant bit mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum/saLsbMode.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The device 5 most significant bytes are set by cpssDxChIpRouterMacSaBaseSet().
*       The least significant bytes are set by:
*       Port mode is set by cpssDxChIpRouterPortMacSaLsbSet().
*       Vlan mode is set by cpssDxChIpRouterVlanMacSaLsbSet().
*
*/
GT_STATUS cpssDxChIpPortRouterMacSaLsbModeSet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  CPSS_MAC_SA_LSB_MODE_ENT    saLsbMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortRouterMacSaLsbModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, saLsbMode));

    rc = internal_cpssDxChIpPortRouterMacSaLsbModeSet(devNum, portNum, saLsbMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, saLsbMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpPortRouterMacSaLsbModeGet function
* @endinternal
*
* @brief   Gets the mode, per port, in which the device sets the packet's MAC SA least
*         significant bytes.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number
*
* @param[out] saLsbModePtr             - (pointer to) The MAC SA least-significant bit mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum/saLsbMode.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortRouterMacSaLsbModeGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT CPSS_MAC_SA_LSB_MODE_ENT    *saLsbModePtr
)
{
    GT_U32      hwData; /* value to write into register   */
    GT_U32      regAddr;
    GT_U32      offset;
    GT_STATUS   rc ;
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_CHECK_MAC(devNum, portNum);

    CPSS_NULL_PTR_CHECK_MAC(saLsbModePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChReadTableEntryField(devNum,
                                                CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
                                                portNum,
                                                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_ROUTER_MAC_SA_ASSIGNMENT_MODE_E, /* field name */
                                                PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                               &hwData);
    }
    else
    {
        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
        localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerHdrAltMacSaModifyMode[localPort / 16];
        offset = (localPort % 16) * 2;
        rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,offset,2,&hwData);
    }

    if(rc != GT_OK)
        return rc;

     /* setting the Lsb mode */
    switch (hwData)
    {
    case 2:
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum))
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            *saLsbModePtr = CPSS_SA_LSB_PER_PORT_E;
            break;
        case 0:
            if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            *saLsbModePtr = CPSS_SA_LSB_PER_PKT_VID_E;
            break;
        case 1:
            *saLsbModePtr = CPSS_SA_LSB_PER_VLAN_E;
            break;
        case 3:
            *saLsbModePtr = CPSS_SA_LSB_FULL_48_BIT_GLOBAL;
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @internal cpssDxChIpPortRouterMacSaLsbModeGet function
* @endinternal
*
* @brief   Gets the mode, per port, in which the device sets the packet's MAC SA least
*         significant bytes.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number
*
* @param[out] saLsbModePtr             - (pointer to) The MAC SA least-significant bit mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum/saLsbMode.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortRouterMacSaLsbModeGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT CPSS_MAC_SA_LSB_MODE_ENT    *saLsbModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortRouterMacSaLsbModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, saLsbModePtr));

    rc = internal_cpssDxChIpPortRouterMacSaLsbModeGet(devNum, portNum, saLsbModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, saLsbModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterPortMacSaLsbSet function
* @endinternal
*
* @brief   Sets the 8 LSB Router MAC SA for this EGRESS PORT.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - Eggress Port number
* @param[in] saMac                    - The 8 bits SA mac value to be written to the SA bits of
*                                      routed packet if SA alteration mode is configured to
*                                      take LSB according to Eggress Port number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterPortMacSaLsbSet
(
    IN GT_U8                    devNum,
    IN GT_PHYSICAL_PORT_NUM     portNum,
    IN GT_U8                    saMac
)
{
    GT_U32      hwData[1]; /* data to write to PP's table */
    GT_STATUS   rc;
    GT_U32      tableIndex;
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32       localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E |
                                          CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

    /*
        NOTE: this API is ch3 and above -
            because : the table added another 28 indexes : vlan - 0..4K , port 4K..+28
            --> added 2 APIs 'per vlan' 'per port'
    */

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

    hwData[0] = saMac;

    /* port entries start after 4096 vlan entries */
    tableIndex = localPort + 4096;

    rc = prvCpssDxChPortGroupWriteTableEntry(devNum,portGroupId,
                                    CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    tableIndex, hwData);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Packets of Egress STC and Egress Mirroring are handled by global port in the Header Alteration.
       For multi-port-groups devices repeat configuration for global port */

    if(portNum == localPort)
    {
        /* Configuration of overlapped ports (identical global and local ports numbers)
           will lead to miss configuration for local ports in other port groups */
        return rc;
    }

    /* Port numbers range for the table entry [0..63] */
    portNum &= 0x3f;
    tableIndex = portNum + 4096;

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
    {
        rc = prvCpssDxChPortGroupWriteTableEntry(devNum,
                                    portGroupId,
                                    CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    tableIndex, hwData);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

    return rc;
}

/**
* @internal cpssDxChIpRouterPortMacSaLsbSet function
* @endinternal
*
* @brief   Sets the 8 LSB Router MAC SA for this EGRESS PORT.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - Eggress Port number
* @param[in] saMac                    - The 8 bits SA mac value to be written to the SA bits of
*                                      routed packet if SA alteration mode is configured to
*                                      take LSB according to Eggress Port number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterPortMacSaLsbSet
(
    IN GT_U8                    devNum,
    IN GT_PHYSICAL_PORT_NUM     portNum,
    IN GT_U8                    saMac
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterPortMacSaLsbSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, saMac));

    rc = internal_cpssDxChIpRouterPortMacSaLsbSet(devNum, portNum, saMac);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, saMac));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterPortMacSaLsbGet function
* @endinternal
*
* @brief   Gets the 8 LSB Router MAC SA for this EGRESS PORT.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - Eggress Port number
*
* @param[out] saMacPtr                 - (pointer to) The 8 bits SA mac value written to the SA
*                                      bits of routed packet if SA alteration mode is configured
*                                      to take LSB according to Eggress Port number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterPortMacSaLsbGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_U8                   *saMacPtr
)
{
    GT_U32      hwData[1]; /* data read from PP's table */
    GT_STATUS   rc;
    GT_U32      tableIndex;
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32       localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E |
                                          CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);
    CPSS_NULL_PTR_CHECK_MAC(saMacPtr);

    /*
        NOTE: this API is ch3 and above -
            because : the table added another 28 indexes : vlan - 0..4K , port 4K..+28
            --> added 2 APIs 'per vlan' 'per port'
    */

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

    /* port entries start after 4096 vlan entries */
    tableIndex = localPort + 4096;

    rc = prvCpssDxChPortGroupReadTableEntry(devNum,portGroupId,
                                    CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    tableIndex, hwData);

    if(rc != GT_OK)
        return rc;

    *saMacPtr = (GT_U8)hwData[0];

    return rc;
}

/**
* @internal cpssDxChIpRouterPortMacSaLsbGet function
* @endinternal
*
* @brief   Gets the 8 LSB Router MAC SA for this EGRESS PORT.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - Eggress Port number
*
* @param[out] saMacPtr                 - (pointer to) The 8 bits SA mac value written to the SA
*                                      bits of routed packet if SA alteration mode is configured
*                                      to take LSB according to Eggress Port number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterPortMacSaLsbGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_U8                   *saMacPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterPortMacSaLsbGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, saMacPtr));

    rc = internal_cpssDxChIpRouterPortMacSaLsbGet(devNum, portNum, saMacPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, saMacPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterVlanMacSaLsbSet function
* @endinternal
*
* @brief   Sets the LSBs of Router MAC SA for this VLAN.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] vlan                     - VLAN Id
*                                      (APPLICABLE RANGES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 0..4095).
*                                      (APPLICABLE RANGES: Falcon; AC5P; AC5X; Harrier; Ironman 0..8191).
* @param[in] saMac                    - The Low Significant bits of SA mac value
*                                      be written to the SA bits of routed packet
*                                      if SA alteration mode is configured to
*                                      take LSB according to VLAN.
*                                      (APPLICABLE RANGES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 0..255).
*                                      (APPLICABLE RANGES: Falcon; AC5P; AC5X; Harrier; Ironman 0..4095).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum or vlanId
* @retval GT_OUT_OF_RANGE          - wrong saMac
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterVlanMacSaLsbSet
(
    IN GT_U8    devNum,
    IN GT_U16   vlan,
    IN GT_U32   saMac
)
{
    GT_U32      hwData[1]; /* data to write to PP's table */
    GT_STATUS   rc;
    GT_U32      saMacBound;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if (!PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* supports the 4K vlans */
        PRV_CPSS_VLAN_VALUE_CHECK_MAC(vlan);
    }
    else
    {
        /* supports the eVlans range */
        PRV_CPSS_DXCH_VLAN_INDEX_CHECK_MAC(devNum, vlan);
    }

    saMacBound = BIT_8;
    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        saMacBound = BIT_12;
    }
    if (saMac >= saMacBound)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "The saMac[0x%x] > max of [0x%x]",
            saMac,
            saMacBound-1);
    }

    /*
        NOTE: this API is ch3 and above -
            because : the table added another 28 indexes : vlan - 0..4K , port 4K..+28
            --> added 2 APIs 'per vlan' 'per port'
    */

    hwData[0] = saMac;

    rc = prvCpssDxChWriteTableEntry(devNum,
                                    CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    (GT_U32)vlan, hwData);
    return rc;
}

/**
* @internal cpssDxChIpRouterVlanMacSaLsbSet function
* @endinternal
*
* @brief   Sets the LSBs of Router MAC SA for this VLAN.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] vlan                     - VLAN Id
*                                      (APPLICABLE RANGES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 0..4095).
*                                      (APPLICABLE RANGES: Falcon; AC5P; AC5X; Harrier; Ironman 0..8191).
* @param[in] saMac                    - The Low Significant bits of SA mac value
*                                      be written to the SA bits of routed packet
*                                      if SA alteration mode is configured to
*                                      take LSB according to VLAN.
*                                      (APPLICABLE RANGES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 0..255).
*                                      (APPLICABLE RANGES: Falcon; AC5P; AC5X; Harrier; Ironman 0..4095).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum or vlanId
* @retval GT_OUT_OF_RANGE          - wrong saMac
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterVlanMacSaLsbSet
(
    IN GT_U8    devNum,
    IN GT_U16   vlan,
    IN GT_U32   saMac
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterVlanMacSaLsbSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vlan, saMac));

    rc = internal_cpssDxChIpRouterVlanMacSaLsbSet(devNum, vlan, saMac);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vlan, saMac));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterVlanMacSaLsbGet function
* @endinternal
*
* @brief   Gets the LSBs of Router MAC SA for this VLAN.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] vlan                     - VLAN Id
*                                      (APPLICABLE RANGES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 0..4095).
*                                      (APPLICABLE RANGES: Falcon; AC5P; AC5X; Harrier; Ironman 0..8191).
* @param[out] saMacPtr                 - (pointer to) The Low Significant bits of SA mac value
*                                      be written to the SA bits of routed packet
*                                      if SA alteration mode is configured to
*                                      take LSB according to VLAN.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum or vlanId
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterVlanMacSaLsbGet
(
    IN  GT_U8    devNum,
    IN  GT_U16   vlan,
    OUT GT_U32   *saMacPtr
)
{
    GT_U32      hwData[1]; /* data read from PP's table */
    GT_STATUS   rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if (!PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* supports the 4K vlans */
        PRV_CPSS_VLAN_VALUE_CHECK_MAC(vlan);
    }
    else
    {
        /* supports the eVlans range */
        PRV_CPSS_DXCH_VLAN_INDEX_CHECK_MAC(devNum, vlan);
    }
    CPSS_NULL_PTR_CHECK_MAC(saMacPtr);

    /*
        NOTE: this API is ch3 and above -
            because : the table added another 28 indexes : vlan - 0..4K , port 4K..+28
            --> added 2 APIs 'per vlan' 'per port'
    */

    rc = prvCpssDxChReadTableEntry(devNum,
                                    CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    vlan, hwData);

    if(rc != GT_OK)
        return rc;

    *saMacPtr = hwData[0];

    return rc;
}

/**
* @internal cpssDxChIpRouterVlanMacSaLsbGet function
* @endinternal
*
* @brief   Gets the LSBs of Router MAC SA for this VLAN.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] vlan                     - VLAN Id
*                                      (APPLICABLE RANGES: xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2 0..4095).
*                                      (APPLICABLE RANGES: Falcon; AC5P; AC5X; Harrier; Ironman 0..8191).
* @param[out] saMacPtr                 - (pointer to) The Low Significant bits of SA mac value
*                                      be written to the SA bits of routed packet
*                                      if SA alteration mode is configured to
*                                      take LSB according to VLAN.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum or vlanId
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterVlanMacSaLsbGet
(
    IN  GT_U8    devNum,
    IN  GT_U16   vlan,
    OUT GT_U32   *saMacPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterVlanMacSaLsbGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vlan, saMacPtr));

    rc = internal_cpssDxChIpRouterVlanMacSaLsbGet(devNum, vlan, saMacPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vlan, saMacPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpRouterGlobalMacSaSet function
* @endinternal
*
* @brief   Sets full 48-bit Router MAC SA in Global MAC SA table.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number.
* @param[in] routerMacSaIndex         - The index into the global MAC SA table.(APPLICABLE RANGES: 0..255)
* @param[in] macSaAddrPtr             - The 48 bits MAC SA.
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error.
* @retval GT_BAD_PARAM             - wrong devNum or routerMacSaIndex.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
* @note This API is applicable when per-egress-physical-port MAC SA assignment
*       mode is configured to global :CPSS_SA_LSB_FULL_48_BIT_GLOBAL by API
*       cpssDxChIpPortRouterMacSaLsbModeSet. The routerMacSaIndex is configured
*       by cpssDxChIpRouterPortGlobalMacSaIndexSet.
*
*/
static GT_STATUS internal_cpssDxChIpRouterGlobalMacSaSet
(
    IN GT_U8        devNum,
    IN GT_U32       routerMacSaIndex,
    IN GT_ETHERADDR *macSaAddrPtr
)
{
    GT_U32      hwData[2] = {0}; /* data to write to PP's table */
    GT_STATUS   rc;        /* return code                 */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    PRV_CPSS_GLOBAL_MAC_SA_INDEX_CHECK_MAC(routerMacSaIndex);

    CPSS_NULL_PTR_CHECK_MAC(macSaAddrPtr);

    /* convert the MAC address to hw format */
    hwData[0] =  macSaAddrPtr->arEther[5] |
                 (macSaAddrPtr->arEther[4] << 8) |
                 (macSaAddrPtr->arEther[3] << 16)|
                 (macSaAddrPtr->arEther[2] << 24);
    hwData[1] =  macSaAddrPtr->arEther[1] |
                 (macSaAddrPtr->arEther[0] << 8);


    rc = prvCpssDxChWriteTableEntry(devNum,
                                    CPSS_DXCH_SIP5_TABLE_HA_GLOBAL_MAC_SA_E,
                                    routerMacSaIndex, hwData);
    return rc;
}

/**
* @internal cpssDxChIpRouterGlobalMacSaSet function
* @endinternal
*
* @brief   Sets full 48-bit Router MAC SA in Global MAC SA table.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number.
* @param[in] routerMacSaIndex         - The index into the global MAC SA table.(APPLICABLE RANGES: 0..255)
* @param[in] macSaAddrPtr             - The 48 bits MAC SA.
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error.
* @retval GT_BAD_PARAM             - wrong devNum or routerMacSaIndex.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
* @note This API is applicable when per-egress-physical-port MAC SA assignment
*       mode is configured to global :CPSS_SA_LSB_FULL_48_BIT_GLOBAL by API
*       cpssDxChIpPortRouterMacSaLsbModeSet. The routerMacSaIndex is configured
*       by cpssDxChIpRouterPortGlobalMacSaIndexSet.
*
*/
GT_STATUS cpssDxChIpRouterGlobalMacSaSet
(
    IN GT_U8        devNum,
    IN GT_U32       routerMacSaIndex,
    IN GT_ETHERADDR *macSaAddrPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterGlobalMacSaSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, routerMacSaIndex, macSaAddrPtr));

    rc = internal_cpssDxChIpRouterGlobalMacSaSet(devNum, routerMacSaIndex, macSaAddrPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, routerMacSaIndex, macSaAddrPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpRouterGlobalMacSaGet function
* @endinternal
*
* @brief   Gets full 48-bit Router MAC SA from Global MAC SA table.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number.
* @param[in] routerMacSaIndex         - The index into the global MAC SA table.(APPLICABLE RANGES: 0..255)
*
* @param[out] macSaAddrPtr             - The 48 bits MAC SA.
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error.
* @retval GT_BAD_PARAM             - wrong devNum or routerMacSaIndex.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
* @note This API is applicable when per-egress-physical-port MAC SA assignment
*       mode is configured to global :CPSS_SA_LSB_FULL_48_BIT_GLOBAL by API
*       cpssDxChIpPortRouterMacSaLsbModeSet. The routerMacSaIndex is configured
*       by cpssDxChIpRouterPortGlobalMacSaIndexSet.
*
*/
static GT_STATUS internal_cpssDxChIpRouterGlobalMacSaGet
(
    IN  GT_U8        devNum,
    IN  GT_U32       routerMacSaIndex,
    OUT GT_ETHERADDR *macSaAddrPtr
)
{
    GT_U32      hwData[2] = {0}; /* data to write to PP's table */
    GT_STATUS   rc;              /* return code                 */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(macSaAddrPtr);

    PRV_CPSS_GLOBAL_MAC_SA_INDEX_CHECK_MAC(routerMacSaIndex);

    rc = prvCpssDxChReadTableEntry(devNum,
                                       CPSS_DXCH_SIP5_TABLE_HA_GLOBAL_MAC_SA_E,
                                       routerMacSaIndex,hwData);
    if (rc != GT_OK)
    {
        return rc;
    }


    macSaAddrPtr->arEther[5] = (GT_U8)U32_GET_FIELD_MAC(hwData[0],0,8);
    macSaAddrPtr->arEther[4] = (GT_U8)U32_GET_FIELD_MAC(hwData[0],8,8);
    macSaAddrPtr->arEther[3] = (GT_U8)U32_GET_FIELD_MAC(hwData[0],16,8);
    macSaAddrPtr->arEther[2] = (GT_U8)U32_GET_FIELD_MAC(hwData[0],24,8);
    macSaAddrPtr->arEther[1] = (GT_U8)U32_GET_FIELD_MAC(hwData[1],0,8);
    macSaAddrPtr->arEther[0] = (GT_U8)U32_GET_FIELD_MAC(hwData[1],8,8);

    return rc;
}

/**
* @internal cpssDxChIpRouterGlobalMacSaGet function
* @endinternal
*
* @brief   Gets full 48-bit Router MAC SA from Global MAC SA table.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number.
* @param[in] routerMacSaIndex         - The index into the global MAC SA table.(APPLICABLE RANGES: 0..255)
*
* @param[out] macSaAddrPtr             - The 48 bits MAC SA.
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on error.
* @retval GT_HW_ERROR              - on hardware error.
* @retval GT_BAD_PARAM             - wrong devNum or routerMacSaIndex.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
* @note This API is applicable when per-egress-physical-port MAC SA assignment
*       mode is configured to global :CPSS_SA_LSB_FULL_48_BIT_GLOBAL by API
*       cpssDxChIpPortRouterMacSaLsbModeSet. The routerMacSaIndex is configured
*       by cpssDxChIpRouterPortGlobalMacSaIndexSet.
*
*/
GT_STATUS cpssDxChIpRouterGlobalMacSaGet
(
    IN  GT_U8        devNum,
    IN  GT_U32       routerMacSaIndex,
    OUT GT_ETHERADDR *macSaAddrPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterGlobalMacSaGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, routerMacSaIndex, macSaAddrPtr));

    rc = internal_cpssDxChIpRouterGlobalMacSaGet(devNum, routerMacSaIndex, macSaAddrPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, routerMacSaIndex, macSaAddrPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpRouterPortGlobalMacSaIndexSet function
* @endinternal
*
* @brief   Set router mac sa index refered to global MAC SA table.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number.
* @param[in] routerMacSaIndex         - global MAC SA table index.(APPLICABLE RANGES: 0..255)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - wrong device or port.
* @retval GT_HW_ERROR              - on writing to HW error.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*/
static GT_STATUS internal_cpssDxChIpRouterPortGlobalMacSaIndexSet
(
    IN GT_U8                devNum,
    IN GT_PORT_NUM          portNum,
    IN GT_U32               routerMacSaIndex
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    PRV_CPSS_GLOBAL_MAC_SA_INDEX_CHECK_MAC(routerMacSaIndex);


    return prvCpssDxChWriteTableEntryField(devNum,
                                   CPSS_DXCH_SIP5_TABLE_HA_EGRESS_EPORT_1_E,
                                   portNum,
                                   PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                   SIP5_HA_EPORT_TABLE_1_FIELDS_ROUTER_MAC_SA_INDEX_E, /* field name */
                                   PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                   routerMacSaIndex);
}

/**
* @internal cpssDxChIpRouterPortGlobalMacSaIndexSet function
* @endinternal
*
* @brief   Set router mac sa index refered to global MAC SA table.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number.
* @param[in] routerMacSaIndex         - global MAC SA table index.(APPLICABLE RANGES: 0..255)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - wrong device or port.
* @retval GT_HW_ERROR              - on writing to HW error.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*/
GT_STATUS cpssDxChIpRouterPortGlobalMacSaIndexSet
(
    IN GT_U8                devNum,
    IN GT_PORT_NUM          portNum,
    IN GT_U32               routerMacSaIndex
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterPortGlobalMacSaIndexSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, routerMacSaIndex));

    rc = internal_cpssDxChIpRouterPortGlobalMacSaIndexSet(devNum, portNum, routerMacSaIndex);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, routerMacSaIndex));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterPortGlobalMacSaIndexGet function
* @endinternal
*
* @brief   Get router mac sa index refered to global MAC SA table.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number.
*
* @param[out] routerMacSaIndexPtr      - (pointer to) global MAC SA table index.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - wrong device or port.
* @retval GT_HW_ERROR              - on writing to HW error.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*/
static GT_STATUS internal_cpssDxChIpRouterPortGlobalMacSaIndexGet
(
    IN  GT_U8           devNum,
    IN  GT_PORT_NUM     portNum,
    OUT GT_U32          *routerMacSaIndexPtr
)
{
    GT_U32      hwValue;    /* hardware value */
    GT_STATUS   rc;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);
    CPSS_NULL_PTR_CHECK_MAC(routerMacSaIndexPtr);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    rc = prvCpssDxChReadTableEntryField(devNum,
                                   CPSS_DXCH_SIP5_TABLE_HA_EGRESS_EPORT_1_E,
                                   portNum,
                                   PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                   SIP5_HA_EPORT_TABLE_1_FIELDS_ROUTER_MAC_SA_INDEX_E, /* field name */
                                   PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                   &hwValue);
    if (rc != GT_OK)
    {
        return rc;
    }

   *routerMacSaIndexPtr = hwValue;

    return rc;
}

/**
* @internal cpssDxChIpRouterPortGlobalMacSaIndexGet function
* @endinternal
*
* @brief   Get router mac sa index refered to global MAC SA table.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] portNum                  - port number.
*
* @param[out] routerMacSaIndexPtr      - (pointer to) global MAC SA table index.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - wrong device or port.
* @retval GT_HW_ERROR              - on writing to HW error.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*/
GT_STATUS cpssDxChIpRouterPortGlobalMacSaIndexGet
(
    IN  GT_U8           devNum,
    IN  GT_PORT_NUM     portNum,
    OUT GT_U32          *routerMacSaIndexPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterPortGlobalMacSaIndexGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, routerMacSaIndexPtr));

    rc = internal_cpssDxChIpRouterPortGlobalMacSaIndexGet(devNum, portNum, routerMacSaIndexPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, routerMacSaIndexPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpRouterMacSaModifyEnable function
* @endinternal
*
* @brief   Per Egress port bit Enable Routed packets MAC SA Modification
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - physical or CPU port number.
* @param[in] enable                   - GT_FALSE: MAC SA Modification of routed packets is disabled
*                                      GT_TRUE: MAC SA Modification of routed packets is enabled
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum/portNum.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterMacSaModifyEnable
(
    IN  GT_U8                      devNum,
    IN  GT_PHYSICAL_PORT_NUM       portNum,
    IN  GT_BOOL                    enable
)
{
    GT_U32      bitNum;
    GT_U32      regAddr;
    GT_U32      value;
    GT_STATUS   rc ;
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

    value = (enable == GT_TRUE) ? 1 : 0;

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                                CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
                                                portNum,
                                                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_ROUTED_MAC_SA_MOD_EN_E, /* field name */
                                                PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                               value);
    }
    else
    {
        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
        localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        bitNum = (localPort == CPSS_CPU_PORT_NUM_CNS) ?
                     PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) :
                     localPort;

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.
                        routerHdrAltEnMacSaModifyReg[OFFSET_TO_WORD_MAC(bitNum)];

        rc =  prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,
                    OFFSET_TO_BIT_MAC(bitNum),1,value);

         /* Packets of Egress STC and Egress Mirroring are handled by global port in the Header Alteration.
           For multi-port-groups devices repeat configuration for global port */

        if(portNum == localPort)
        {
            /* Configuration of overlapped ports (identical global and local ports numbers)
               will lead to miss configuration for local ports in other port groups */
            return rc;
        }

        /* Port numbers range for the registers [0..63] */
        portNum &= 0x3f;
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.
                        routerHdrAltEnMacSaModifyReg[OFFSET_TO_WORD_MAC(portNum)];

        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            rc =  prvCpssHwPpPortGroupSetRegField(devNum,
                                                  portGroupId,
                                                  regAddr,
                                                  OFFSET_TO_BIT_MAC(portNum),
                                                  1,
                                                  value);

            if(rc != GT_OK)
            {
                return rc;
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    }

    return rc;
}

/**
* @internal cpssDxChIpRouterMacSaModifyEnable function
* @endinternal
*
* @brief   Per Egress port bit Enable Routed packets MAC SA Modification
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - physical or CPU port number.
* @param[in] enable                   - GT_FALSE: MAC SA Modification of routed packets is disabled
*                                      GT_TRUE: MAC SA Modification of routed packets is enabled
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum/portNum.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterMacSaModifyEnable
(
    IN  GT_U8                      devNum,
    IN  GT_PHYSICAL_PORT_NUM       portNum,
    IN  GT_BOOL                    enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterMacSaModifyEnable);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enable));

    rc = internal_cpssDxChIpRouterMacSaModifyEnable(devNum, portNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpRouterMacSaModifyEnableGet function
* @endinternal
*
* @brief   Per Egress port bit Get Routed packets MAC SA Modification State
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - physical or CPU port number.
*
* @param[out] enablePtr                - GT_FALSE: MAC SA Modification of routed packets is disabled
*                                      GT_TRUE: MAC SA Modification of routed packets is enabled
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum/portNum.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpRouterMacSaModifyEnableGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT GT_BOOL                     *enablePtr
)
{
    GT_U32  bitNum;
    GT_U32      regAddr;
    GT_U32      value;
    GT_STATUS   rc ;
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);
    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChReadTableEntryField(devNum,
                                                CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
                                                portNum,
                                                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_ROUTED_MAC_SA_MOD_EN_E, /* field name */
                                                PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                               &value);
    }
    else
    {
        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
        localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        bitNum = (localPort == CPSS_CPU_PORT_NUM_CNS) ?
                     PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) :
                     localPort;

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.
                        routerHdrAltEnMacSaModifyReg[OFFSET_TO_WORD_MAC(bitNum)];

        rc =  prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,
                    OFFSET_TO_BIT_MAC(bitNum),1,&value);
    }

    if(rc != GT_OK)
        return rc;

    *enablePtr = (value == 1) ? GT_TRUE : GT_FALSE;

    return rc;
}

/**
* @internal cpssDxChIpRouterMacSaModifyEnableGet function
* @endinternal
*
* @brief   Per Egress port bit Get Routed packets MAC SA Modification State
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - physical or CPU port number.
*
* @param[out] enablePtr                - GT_FALSE: MAC SA Modification of routed packets is disabled
*                                      GT_TRUE: MAC SA Modification of routed packets is enabled
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum/portNum.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpRouterMacSaModifyEnableGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT GT_BOOL                     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterMacSaModifyEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enablePtr));

    rc = internal_cpssDxChIpRouterMacSaModifyEnableGet(devNum, portNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpEcmpUcRpfCheckEnableSet function
* @endinternal
*
* @brief   Globally enables/disables ECMP/QoS unicast RPF check.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] enable                   - enable / disable
*       ECMP/Qos unicast RPF check
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpEcmpUcRpfCheckEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_U32      value, regAddr;
    GT_STATUS   rc ;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    value = (enable == GT_TRUE) ? 1 : 0;

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr =  PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
    }
    else
    {
        regAddr =  PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerAdditionalCtrlReg;
    }
    rc =  prvCpssHwPpSetRegField(devNum, regAddr, 5, 1, value);

    return rc;
}

/**
* @internal cpssDxChIpEcmpUcRpfCheckEnableSet function
* @endinternal
*
* @brief   Globally enables/disables ECMP/QoS unicast RPF check.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] enable                   - enable / disable
*       ECMP/Qos unicast RPF check
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpEcmpUcRpfCheckEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpEcmpUcRpfCheckEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpEcmpUcRpfCheckEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpEcmpUcRpfCheckEnableGet function
* @endinternal
*
* @brief   Gets globally enables/disables ECMP/QoS unicast RPF check state.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] enablePtr                - (points to) enable / disable ECMP/Qos unicast RPF check
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpEcmpUcRpfCheckEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32      value, regAddr;
    GT_STATUS   rc ;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr =  PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
    }
    else
    {
        regAddr =  PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerAdditionalCtrlReg;
    }
    rc =  prvCpssHwPpGetRegField(devNum, regAddr, 5, 1, &value);
    if(rc != GT_OK)
        return rc;

    *enablePtr = (value == 1) ? GT_TRUE : GT_FALSE;

    return rc;
}

/**
* @internal cpssDxChIpEcmpUcRpfCheckEnableGet function
* @endinternal
*
* @brief   Gets globally enables/disables ECMP/QoS unicast RPF check state.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
*
* @param[out] enablePtr                - (points to) enable / disable ECMP/Qos unicast RPF check
*
* @retval GT_OK                    - on success
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpEcmpUcRpfCheckEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpEcmpUcRpfCheckEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpEcmpUcRpfCheckEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupCntSet function
* @endinternal
*
* @brief   set the requested IP counter set.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] cntSet                   - counters set to clear.
* @param[in] countersPtr              - the counter values to set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortGroupCntSet
(
    IN GT_U8                         devNum,
    IN GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN CPSS_IP_CNT_SET_ENT           cntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U8 setNum;

    CPSS_NULL_PTR_CHECK_MAC(countersPtr);
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    switch(cntSet)
    {
        case CPSS_IP_CNT_SET0_E:
            setNum =0;
            break;
        case CPSS_IP_CNT_SET1_E:
            setNum =1;
            break;
        case CPSS_IP_CNT_SET2_E:
            setNum =2;
            break;
        case CPSS_IP_CNT_SET3_E:
            setNum =3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    /* Router Management In Unicast Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32, countersPtr->inUcPkts);

    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /* Router Management In Multicast Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngMcPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32, countersPtr->inMcPkts);

    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /*Router Management In Unicast Non-Routed Non-Exception Packets
     Counter Set<n> */

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcNonRoutedNonException[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcNonRoutedNonExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                            0, 32,
                                   countersPtr->inUcNonRoutedNonExcpPkts);

    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /*Router Management In Unicast Non-Routed Exception Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcNonRoutedExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcNonRoutedExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32,
                                   countersPtr->inUcNonRoutedExcpPkts);

    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /*Router Management In Multicast Non-Routed Non-Exception Packets
                                           Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcNonRoutedNonExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcNonRoutedNonExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32,
                                   countersPtr->inMcNonRoutedNonExcpPkts);

    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    /*Router Management In Multicast Non-Routed Exception Packets Counter
                                              Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcNonRoutedExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcNonRoutedExcptCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                            0, 32,
                                   countersPtr->inMcNonRoutedExcpPkts);
    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /* Router Management In Unicast Trapped / Mirrored Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcTrappedMirroredPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcTrapMrrPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum,portGroupsBmp, regAddr,
                                             0, 32,
                                   countersPtr->inUcTrappedMirrorPkts);
    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /* Router Management In Multicast Trapped / Mirrored Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcTrappedMirroredPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcTrapMrrPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                            0, 32,
                                   countersPtr->inMcTrappedMirrorPkts);
    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /* Router Management In Multicast RPF Fail Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcRPFFailCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcRPFFailCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32,
                                   countersPtr->mcRfpFailPkts);
    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /* Router Management Out Unicast Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementOutUcPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngOutUcPktCntSet[setNum];
    }

    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                            0, 32,
                                   countersPtr->outUcRoutedPkts);
    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    return GT_OK;

}

/**
* @internal cpssDxChIpPortGroupCntSet function
* @endinternal
*
* @brief   set the requested IP counter set.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] cntSet                   - counters set to clear.
* @param[in] countersPtr              - the counter values to set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortGroupCntSet
(
    IN GT_U8                         devNum,
    IN GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN CPSS_IP_CNT_SET_ENT           cntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupCntSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, cntSet, countersPtr));

    rc = internal_cpssDxChIpPortGroupCntSet(devNum, portGroupsBmp, cntSet, countersPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, cntSet, countersPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupCntGet function
* @endinternal
*
* @brief   Return the IP counter set requested.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] cntSet                   - counters set to retrieve.
*
* @param[out] countersPtr              - (pointer to)struct contains the counter values.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_FAIL                  - on error
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This function doesn't handle counters overflow.
*
*/
static GT_STATUS internal_cpssDxChIpPortGroupCntGet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_GROUPS_BMP           portGroupsBmp,
    IN  CPSS_IP_CNT_SET_ENT          cntSet,
    OUT CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U8 setNum;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(countersPtr);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    switch(cntSet)
    {
        case CPSS_IP_CNT_SET0_E:
            setNum =0;
            break;
        case CPSS_IP_CNT_SET1_E:
            setNum =1;
            break;
        case CPSS_IP_CNT_SET2_E:
            setNum =2;
            break;
        case CPSS_IP_CNT_SET3_E:
            setNum =3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }
    /* Router Management In Unicast Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                            0,32,&(countersPtr->inUcPkts),NULL);

    if(GT_OK != rc)
        return rc;

    /* Router Management In Multicast Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngMcPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                            0,32,&(countersPtr->inMcPkts),NULL);

    if(GT_OK != rc)
        return rc;

    /*Router Management In Unicast Non-Routed Non-Exception Packets
     Counter Set<n> */

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcNonRoutedNonException[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcNonRoutedNonExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inUcNonRoutedNonExcpPkts),NULL);

    if(GT_OK != rc)
        return rc;

    /*Router Management In Unicast Non-Routed Exception Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcNonRoutedExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcNonRoutedExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inUcNonRoutedExcpPkts),NULL);

    if(GT_OK != rc)
        return rc;

    /*Router Management In Multicast Non-Routed Non-Exception Packets
                                           Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcNonRoutedNonExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcNonRoutedNonExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inMcNonRoutedNonExcpPkts),NULL);

    if(GT_OK != rc)
        return rc;
   /*Router Management In Multicast Non-Routed Exception Packets Counter
                                          Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcNonRoutedExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcNonRoutedExcptCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inMcNonRoutedExcpPkts),NULL);
    if(GT_OK != rc)
        return rc;

    /* Router Management In Unicast Trapped / Mirrored Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcTrappedMirroredPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcTrapMrrPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inUcTrappedMirrorPkts),NULL);
    if(GT_OK != rc)
        return rc;

    /* Router Management In Multicast Trapped / Mirrored Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcTrappedMirroredPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcTrapMrrPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inMcTrappedMirrorPkts),NULL);
    if(GT_OK != rc)
        return rc;

    /* Router Management In Multicast RPF Fail Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcRPFFailCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcRPFFailCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->mcRfpFailPkts),NULL);
    if(GT_OK != rc)
        return rc;

    /* Router Management Out Unicast Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementOutUcPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngOutUcPktCntSet[setNum];
    }

    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->outUcRoutedPkts),NULL);
    if(GT_OK != rc)
        return rc;

    return GT_OK;

}

/**
* @internal cpssDxChIpPortGroupCntGet function
* @endinternal
*
* @brief   Return the IP counter set requested.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] cntSet                   - counters set to retrieve.
*
* @param[out] countersPtr              - (pointer to)struct contains the counter values.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_FAIL                  - on error
* @retval GT_NOT_INITIALIZED       - The library was not initialized.
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This function doesn't handle counters overflow.
*
*/
GT_STATUS cpssDxChIpPortGroupCntGet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_GROUPS_BMP           portGroupsBmp,
    IN  CPSS_IP_CNT_SET_ENT          cntSet,
    OUT CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, cntSet, countersPtr));

    rc = internal_cpssDxChIpPortGroupCntGet(devNum, portGroupsBmp, cntSet, countersPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, cntSet, countersPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupDropCntSet function
* @endinternal
*
* @brief   set the drop counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] dropPkts                 - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortGroupDropCntSet
(
    IN GT_U8                devNum,
    IN GT_PORT_GROUPS_BMP   portGroupsBmp,
    IN GT_U32               dropPkts
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerDropCntr.routerDropCntr;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerDropCnt;
    }

    /* set the counter */
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32, dropPkts);

    return rc;
}

/**
* @internal cpssDxChIpPortGroupDropCntSet function
* @endinternal
*
* @brief   set the drop counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] dropPkts                 - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortGroupDropCntSet
(
    IN GT_U8                devNum,
    IN GT_PORT_GROUPS_BMP   portGroupsBmp,
    IN GT_U32               dropPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupDropCntSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, dropPkts));

    rc = internal_cpssDxChIpPortGroupDropCntSet(devNum, portGroupsBmp, dropPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, dropPkts));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupDropCntGet function
* @endinternal
*
* @brief   Get the drop counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] dropPktsPtr              - the number of counted dropped packets according to the
*                                      drop counter mode.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortGroupDropCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *dropPktsPtr
)
{
    GT_STATUS rc;                   /* return code                        */
    GT_U32    regAddr;              /* register address                   */

    CPSS_NULL_PTR_CHECK_MAC(dropPktsPtr);
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerDropCntr.routerDropCntr;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerDropCnt;
    }

    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                                 0, 32, dropPktsPtr, NULL);


    return rc;
}

/**
* @internal cpssDxChIpPortGroupDropCntGet function
* @endinternal
*
* @brief   Get the drop counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] dropPktsPtr              - the number of counted dropped packets according to the
*                                      drop counter mode.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortGroupDropCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *dropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupDropCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, dropPktsPtr));

    rc = internal_cpssDxChIpPortGroupDropCntGet(devNum, portGroupsBmp, dropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, dropPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet function
* @endinternal
*
* @brief   Get the multi target queue full drop packet counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] dropPktsPtr              - the number of counted dropped packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet
(
    IN   GT_U8                  devNum,
    IN   GT_PORT_GROUPS_BMP     portGroupsBmp,
    OUT  GT_U32                 *dropPktsPtr
)
{
    GT_STATUS rc;                   /* return code                        */
    GT_U32    regAddr;              /* register address                   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(dropPktsPtr);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* NOTE: this is ROC counter -- 'read only , clear' so no ability to 'set' it */
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.
            MLLMCFIFODropCntr;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllMcFifoFullDropCnt;
    }

    /* summary the counter from all port groups */
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                                0, 32, dropPktsPtr, NULL);

    return rc;

}

/**
* @internal cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet function
* @endinternal
*
* @brief   Get the multi target queue full drop packet counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] dropPktsPtr              - the number of counted dropped packets.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet
(
    IN   GT_U8                  devNum,
    IN   GT_PORT_GROUPS_BMP     portGroupsBmp,
    OUT  GT_U32                 *dropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, dropPktsPtr));

    rc = internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet(devNum, portGroupsBmp, dropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, dropPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet function
* @endinternal
*
* @brief   set the multi target queue full drop packet counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] dropPkts                 - the counter value to set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet
(
    IN GT_U8                 devNum,
    IN GT_PORT_GROUPS_BMP    portGroupsBmp,
    IN GT_U32                dropPkts
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E |
                                          CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* NOTE: this is ROC counter -- 'read only , clear' so no ability to 'set' it */

        /* this is 'unreachable code' ! (see PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC) */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllMcFifoFullDropCnt;

    /* set the counter */
    rc =  prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32, dropPkts);
    return rc;

}

/**
* @internal cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet function
* @endinternal
*
* @brief   set the multi target queue full drop packet counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] dropPkts                 - the counter value to set.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet
(
    IN GT_U8                 devNum,
    IN GT_PORT_GROUPS_BMP    portGroupsBmp,
    IN GT_U32                dropPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, dropPkts));

    rc = internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet(devNum, portGroupsBmp, dropPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, dropPkts));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupMultiTargetQueuePerQueueFullDropCntGet function
* @endinternal
*
* @brief   Get the multi target queue full drop packet counter per MC queue.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] multiTargetMcQueue       - the multi-target MC queue.(APPLICABLE RANGES: 0..3).
*
* @param[out] dropPktsPtr             - (pointer to) the number of counted dropped MC packets per queue.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out-of-range parameter
*/
static GT_STATUS internal_cpssDxChIpPortGroupMultiTargetQueuePerQueueFullDropCntGet
(
    IN   GT_U8                  devNum,
    IN   GT_PORT_GROUPS_BMP     portGroupsBmp,
    IN   GT_U32                 multiTargetMcQueue,
    OUT  GT_U32                 *dropPktsPtr
)
{
    GT_STATUS rc;                   /* return code                        */
    GT_U32    regAddr;              /* register address                   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    CPSS_NULL_PTR_CHECK_MAC(dropPktsPtr);
    if(multiTargetMcQueue > 3 )
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    /* NOTE: this is ROC counter -- 'read only , clear' so no ability to 'set' it */
    regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.MLLMCQueueDropCnter[multiTargetMcQueue];

    /* summary the counter from all port groups */
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0, 32, dropPktsPtr, NULL);

    return rc;

}

/**
* @internal cpssDxChIpPortGroupMultiTargetQueuePerQueueFullDropCntGet function
* @endinternal
*
* @brief   Get the multi target queue full drop packet counter per MC queue.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] multiTargetMcQueue       - the multi-target MC queue.(APPLICABLE RANGES: 0..3).
*
* @param[out] dropPktsPtr             - (pointer to) the number of counted dropped MC packets per queue.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_OUT_OF_RANGE          - on out-of-range parameter
*/
GT_STATUS cpssDxChIpPortGroupMultiTargetQueuePerQueueFullDropCntGet
(
    IN   GT_U8                  devNum,
    IN   GT_PORT_GROUPS_BMP     portGroupsBmp,
    IN   GT_U32                 multiTargetMcQueue,
    OUT  GT_U32                 *dropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMultiTargetQueuePerQueueFullDropCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, multiTargetMcQueue, dropPktsPtr));

    rc = internal_cpssDxChIpPortGroupMultiTargetQueuePerQueueFullDropCntGet(devNum, portGroupsBmp, multiTargetMcQueue, dropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, multiTargetMcQueue, dropPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupMllCntGet function
* @endinternal
*
* @brief   Get the mll counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number.
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] mllCntSet                - the mll counter set out of the 2
*
* @param[out] mllOutMCPktsPtr          - According to the configuration of this cnt set, The
*                                      number of routed IP Multicast packets Duplicated by the
*                                      MLL Engine and transmitted via this interface
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortGroupMllCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    IN  GT_U32                  mllCntSet,
    OUT GT_U32                  *mllOutMCPktsPtr
)
{
    GT_STATUS rc;                   /* return code                        */
    GT_U32    regAddr;              /* register address                   */

    CPSS_NULL_PTR_CHECK_MAC(mllOutMCPktsPtr);
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if(mllCntSet > 1)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* NOTE: this is ROC counter -- 'read only , clear' so no ability to 'set' it */
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.IPMLLOutMcPktsCntr[mllCntSet];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllOutMcPktCnt[mllCntSet];
    }

    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                                0, 32, mllOutMCPktsPtr, NULL);
    return rc;

}

/**
* @internal cpssDxChIpPortGroupMllCntGet function
* @endinternal
*
* @brief   Get the mll counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number.
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] mllCntSet                - the mll counter set out of the 2
*
* @param[out] mllOutMCPktsPtr          - According to the configuration of this cnt set, The
*                                      number of routed IP Multicast packets Duplicated by the
*                                      MLL Engine and transmitted via this interface
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortGroupMllCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    IN  GT_U32                  mllCntSet,
    OUT GT_U32                  *mllOutMCPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMllCntGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, mllCntSet, mllOutMCPktsPtr));

    rc = internal_cpssDxChIpPortGroupMllCntGet(devNum, portGroupsBmp, mllCntSet, mllOutMCPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, mllCntSet, mllOutMCPktsPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupMllCntSet function
* @endinternal
*
* @brief   set an mll counter.
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] mllCntSet                - the mll counter set out of the 2
* @param[in] mllOutMCPkts             - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPortGroupMllCntSet
(
    IN GT_U8                    devNum,
    IN GT_PORT_GROUPS_BMP       portGroupsBmp,
    IN GT_U32                   mllCntSet,
    IN GT_U32                   mllOutMCPkts
)
{

    GT_U32    regAddr;              /* register address                   */

    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E |
                                          CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    /* NOTE: in sip5 devices : this is ROC counter -- 'read only , clear' so no ability to 'set' it */

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    if(mllCntSet > 1)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllOutMcPktCnt[mllCntSet];
    /* set the counter */
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                            0, 32, mllOutMCPkts);

    return rc;

}

/**
* @internal cpssDxChIpPortGroupMllCntSet function
* @endinternal
*
* @brief   set an mll counter.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] mllCntSet                - the mll counter set out of the 2
* @param[in] mllOutMCPkts             - the counter value to set
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - Illegal parameter in function called
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPortGroupMllCntSet
(
    IN GT_U8                    devNum,
    IN GT_PORT_GROUPS_BMP       portGroupsBmp,
    IN GT_U32                   mllCntSet,
    IN GT_U32                   mllOutMCPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMllCntSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, mllCntSet, mllOutMCPkts));

    rc = internal_cpssDxChIpPortGroupMllCntSet(devNum, portGroupsBmp, mllCntSet, mllOutMCPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, mllCntSet, mllOutMCPkts));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpUcRpfModeSet function
* @endinternal
*
* @brief   Defines the uRPF check mode for a given VID.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - the device number
* @param[in] vid                      - Vlan Id
* @param[in] uRpfMode                 - CPSS_DXCH_IP_URPF_DISABLE_MODE_E = uRPF check is disabled
*                                      for this VID.
*                                      CPSS_DXCH_IP_URPF_VLAN_MODE_E= Vlan: If ECMP uRPF is
*                                      globally enabled, then uRPF check is done
*                                      by comparing the packet VID to the VID
*                                      in the additional route entry, otherwise
*                                      it is done using the SIP-Next Hop Entry VID.
*                                      CPSS_DXCH_IP_URPF_PORT_TRUNK_MODE_E = uRPF check is done by
*                                      comparing the packet source {device,port}/Trunk to
*                                      the SIP-Next Hop Entry {device,port}/Trunk.
*                                      CPSS_DXCH_IP_URPF_LOOSE_MODE_E = uRPF check is done by checking
*                                      the SIP-Next Hop Entry Route Command.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, vid or uRpfMode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note If ucRPFCheckEnable field configured in cpssDxChIpLttWrite is enabled
*       then VLAN-based uRPF check is performed, regardless of this configuration.
*       Otherwise, uRPF check is performed for this VID according to this
*       configuration.
*       Port-based uRPF mode is not supported if the address is associated
*       with an ECMP/QoS block of nexthop entries.
*
*/
static GT_STATUS internal_cpssDxChIpUcRpfModeSet
(
    IN  GT_U8                           devNum,
    IN  GT_U16                          vid,
    IN  CPSS_DXCH_IP_URPF_MODE_ENT      uRpfMode
)
{
    GT_STATUS   rc = GT_OK;
    GT_U32      entryIndex;
    GT_U32      fieldOffset;
    GT_U32      fieldWordNum;
    GT_U32      fieldLength;
    GT_U32      fieldValue;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E);

    PRV_CPSS_DXCH_VLAN_INDEX_CHECK_MAC(devNum, vid);

    switch(uRpfMode)
    {
    case CPSS_DXCH_IP_URPF_DISABLE_MODE_E:
        fieldValue = 0;
        break;
    case CPSS_DXCH_IP_URPF_VLAN_MODE_E:
        fieldValue = 1;
        break;
    case CPSS_DXCH_IP_URPF_PORT_TRUNK_MODE_E:
        fieldValue = 2;
        break;
    case CPSS_DXCH_IP_URPF_LOOSE_MODE_E:
        fieldValue = 3;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }


    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                             CPSS_DXCH_SIP5_TABLE_IPVX_EVLAN_E,
                                             vid,
                                             PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                             0, /* offset */
                                             2, /* length */
                                             fieldValue);
    }
    else
    {
        PRV_CPSS_VLAN_VALUE_CHECK_MAC(vid);

        entryIndex      =   (GT_U32)(vid / 16);    /* 0 - 255 number of lines   */
        fieldOffset     =   (GT_U32)((vid % 16)*2);/* 16 vlans in each lines    */
        fieldWordNum    =   0;                     /* one word in each line     */
        fieldLength     =   2;                     /* 2 bits to hold uRpf VLAN mode */

        rc = prvCpssDxChWriteTableEntryField(devNum,
                                             CPSS_DXCH_LION_TABLE_ROUTER_VLAN_URPF_STC_E,
                                             entryIndex,
                                             fieldWordNum,
                                             fieldOffset,
                                             fieldLength,
                                             fieldValue);
    }

    return rc;
}

/**
* @internal cpssDxChIpUcRpfModeSet function
* @endinternal
*
* @brief   Defines the uRPF check mode for a given VID.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - the device number
* @param[in] vid                      - Vlan Id
* @param[in] uRpfMode                 - CPSS_DXCH_IP_URPF_DISABLE_MODE_E = uRPF check is disabled
*                                      for this VID.
*                                      CPSS_DXCH_IP_URPF_VLAN_MODE_E= Vlan: If ECMP uRPF is
*                                      globally enabled, then uRPF check is done
*                                      by comparing the packet VID to the VID
*                                      in the additional route entry, otherwise
*                                      it is done using the SIP-Next Hop Entry VID.
*                                      CPSS_DXCH_IP_URPF_PORT_TRUNK_MODE_E = uRPF check is done by
*                                      comparing the packet source {device,port}/Trunk to
*                                      the SIP-Next Hop Entry {device,port}/Trunk.
*                                      CPSS_DXCH_IP_URPF_LOOSE_MODE_E = uRPF check is done by checking
*                                      the SIP-Next Hop Entry Route Command.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device, vid or uRpfMode
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note If ucRPFCheckEnable field configured in cpssDxChIpLttWrite is enabled
*       then VLAN-based uRPF check is performed, regardless of this configuration.
*       Otherwise, uRPF check is performed for this VID according to this
*       configuration.
*       Port-based uRPF mode is not supported if the address is associated
*       with an ECMP/QoS block of nexthop entries.
*
*/
GT_STATUS cpssDxChIpUcRpfModeSet
(
    IN  GT_U8                           devNum,
    IN  GT_U16                          vid,
    IN  CPSS_DXCH_IP_URPF_MODE_ENT      uRpfMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRpfModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vid, uRpfMode));

    rc = internal_cpssDxChIpUcRpfModeSet(devNum, vid, uRpfMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vid, uRpfMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpUcRpfModeGet function
* @endinternal
*
* @brief   Read uRPF check mode for a given VID.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - the device number
* @param[in] vid                      - Vlan Id
*
* @param[out] uRpfModePtr              -  CPSS_DXCH_IP_URPF_DISABLE_MODE_E = uRPF check is disabled
*                                      for this VID.
*                                      CPSS_DXCH_IP_URPF_VLAN_MODE_E= Vlan: If ECMP uRPF is
*                                      globally enabled, then uRPF check is done
*                                      by comparing the packet VID to the VID
*                                      in the additional route entry, otherwise
*                                      it is done using the SIP-Next Hop Entry VID.
*                                      CPSS_DXCH_IP_URPF_PORT_TRUNK_MODE_E = uRPF check is done by
*                                      comparing the packet source {device,port}/Trunk to
*                                      the SIP-Next Hop Entry {device,port}/Trunk.
*                                      CPSS_DXCH_IP_URPF_LOOSE_MODE_E = uRPF check is done by checking
*                                      the SIP-Next Hop Entry Route Command.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*
* @note If ucRPFCheckEnable field configured in cpssDxChIpLttWrite is enabled
*       then VLAN-based uRPF check is performed, regardless of this configuration.
*       Otherwise, uRPF check is performed for this VID according to this
*       configuration.
*       Port-based uRPF mode is not supported if the address is associated
*       with an ECMP/QoS block of nexthop entries.
*
*/
static GT_STATUS internal_cpssDxChIpUcRpfModeGet
(
    IN  GT_U8                               devNum,
    IN  GT_U16                              vid,
    OUT CPSS_DXCH_IP_URPF_MODE_ENT          *uRpfModePtr
)
{
    GT_STATUS   rc = GT_OK;
    GT_U32      entryIndex;
    GT_U32      fieldOffset;
    GT_U32      fieldWordNum;
    GT_U32      fieldLength;
    GT_U32      fieldValue;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E);

    PRV_CPSS_DXCH_VLAN_INDEX_CHECK_MAC(devNum, vid);
    CPSS_NULL_PTR_CHECK_MAC(uRpfModePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChReadTableEntryField(devNum,
                                            CPSS_DXCH_SIP5_TABLE_IPVX_EVLAN_E,
                                            vid,
                                            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                            0, /* offset */
                                            2, /* length */
                                            &fieldValue);
        if(rc != GT_OK)
            return rc;
    }
    else
    {
        PRV_CPSS_VLAN_VALUE_CHECK_MAC(vid);

        entryIndex      =   (GT_U32)(vid / 16);    /* 0 - 255 number of lines   */
        fieldOffset     =   (GT_U32)((vid % 16)*2);/* 16 vlans in each lines    */
        fieldWordNum    =   0;                     /* one word in each line     */
        fieldLength     =   2;                     /* 2 bits to hold uRpf VLAN mode */

        rc = prvCpssDxChReadTableEntryField(devNum,
                                            CPSS_DXCH_LION_TABLE_ROUTER_VLAN_URPF_STC_E,
                                            entryIndex,
                                            fieldWordNum,
                                            fieldOffset,
                                            fieldLength,
                                            &fieldValue);
        if(rc != GT_OK)
            return rc;
    }

    switch(fieldValue)
    {
    case 0:
        *uRpfModePtr = CPSS_DXCH_IP_URPF_DISABLE_MODE_E;
        break;
    case 1:
        *uRpfModePtr = CPSS_DXCH_IP_URPF_VLAN_MODE_E;
        break;
    case 2:
        *uRpfModePtr = CPSS_DXCH_IP_URPF_PORT_TRUNK_MODE_E;
        break;
    case 3:
        *uRpfModePtr = CPSS_DXCH_IP_URPF_LOOSE_MODE_E;
        break;

    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @internal cpssDxChIpUcRpfModeGet function
* @endinternal
*
* @brief   Read uRPF check mode for a given VID.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - the device number
* @param[in] vid                      - Vlan Id
*
* @param[out] uRpfModePtr              -  CPSS_DXCH_IP_URPF_DISABLE_MODE_E = uRPF check is disabled
*                                      for this VID.
*                                      CPSS_DXCH_IP_URPF_VLAN_MODE_E= Vlan: If ECMP uRPF is
*                                      globally enabled, then uRPF check is done
*                                      by comparing the packet VID to the VID
*                                      in the additional route entry, otherwise
*                                      it is done using the SIP-Next Hop Entry VID.
*                                      CPSS_DXCH_IP_URPF_PORT_MODE_E = uRPF check is done by
*                                      comparing the packet source {device,port}/Trunk to
*                                      the SIP-Next Hop Entry {device,port}/Trunk.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*
* @note If ucRPFCheckEnable field configured in cpssDxChIpLttWrite is enabled
*       then VLAN-based uRPF check is performed, regardless of this configuration.
*       Otherwise, uRPF check is performed for this VID according to this
*       configuration.
*       Port-based uRPF mode is not supported if the address is associated
*       with an ECMP/QoS block of nexthop entries.
*
*/
GT_STATUS cpssDxChIpUcRpfModeGet
(
    IN  GT_U8                               devNum,
    IN  GT_U16                              vid,
    OUT CPSS_DXCH_IP_URPF_MODE_ENT          *uRpfModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRpfModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vid, uRpfModePtr));

    rc = internal_cpssDxChIpUcRpfModeGet(devNum, vid, uRpfModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vid, uRpfModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpUrpfLooseModeTypeSet function
* @endinternal
*
* @brief   This function set type of Urpf loose mode
*
* @note   APPLICABLE DEVICES:      Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.
*
* @param[in] devNum                   -  the device number
* @param[in] looseModeType            - value of urpf loose mode
*
* @retval GT_OK                    - on success.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
* @retval GT_FAIL                  - otherwise.
*
* @note none.
*
*/
GT_STATUS internal_cpssDxChIpUrpfLooseModeTypeSet
(
    IN  GT_U8                              devNum,
    IN  CPSS_DXCH_URPF_LOOSE_MODE_TYPE_ENT looseModeType
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;
    GT_U32      data;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_XCAT3_E | CPSS_AC5_E |
                                          CPSS_BOBCAT3_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E);

    if (PRV_CPSS_SIP_5_25_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl3;
        switch(looseModeType)
        {
            case CPSS_DXCH_URPF_LOOSE_MODE_TYPE_0_E:
                data = 0;
                break;
            case CPSS_DXCH_URPF_LOOSE_MODE_TYPE_1_E:
                data = 1;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, data);
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @internal cpssDxChIpUrpfLooseModeTypeSet function
* @endinternal
*
* @brief   This function set type of Urpf loose mode
*
* @note   APPLICABLE DEVICES:      Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.
*
* @param[in] devNum                   -  the device number
* @param[in] looseModeType            - value of urpf loose mode
*
* @retval GT_OK                    - on success.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
* @retval GT_FAIL                  - otherwise.
*
* @note none.
*
*/
GT_STATUS cpssDxChIpUrpfLooseModeTypeSet
(
    IN  GT_U8                              devNum,
    IN  CPSS_DXCH_URPF_LOOSE_MODE_TYPE_ENT looseModeType
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUrpfLooseModeTypeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, looseModeType));

    rc = internal_cpssDxChIpUrpfLooseModeTypeSet(devNum, looseModeType);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, looseModeType));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpUrpfLooseModeTypeGet function
* @endinternal
*
* @brief   This function get type of Urpf loose mode
*
* @note   APPLICABLE DEVICES:      Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.
*
* @param[in] devNum                   -  the device number
*
* @param[out] looseModeTypePtr         -  pointer to urpf loose mode
*
* @retval GT_OK                    - on success.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
* @retval GT_FAIL                  - otherwise.
*
* @note none.
*
*/
GT_STATUS internal_cpssDxChIpUrpfLooseModeTypeGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_DXCH_URPF_LOOSE_MODE_TYPE_ENT* looseModeTypePtr
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;
    GT_U32      looseModeType;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_XCAT3_E | CPSS_AC5_E |
                                          CPSS_BOBCAT3_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E);

    if (PRV_CPSS_SIP_5_25_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl3;
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 1, &looseModeType);
        switch(looseModeType)
        {
            case 0:
                *looseModeTypePtr = CPSS_DXCH_URPF_LOOSE_MODE_TYPE_0_E;
                break;
            case 1:
                *looseModeTypePtr = CPSS_DXCH_URPF_LOOSE_MODE_TYPE_1_E;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @internal cpssDxChIpUrpfLooseModeTypeGet function
* @endinternal
*
* @brief   This function get type of Urpf loose mode
*
* @note   APPLICABLE DEVICES:      Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.
*
* @param[in] devNum                   -  the device number
*
* @param[out] looseModeTypePtr         -  pointer to urpf loose mode
*
* @retval GT_OK                    - on success.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device.
* @retval GT_FAIL                  - otherwise.
*
* @note none.
*
*/
GT_STATUS cpssDxChIpUrpfLooseModeTypeGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_DXCH_URPF_LOOSE_MODE_TYPE_ENT * looseModeTypePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUrpfLooseModeTypeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, looseModeTypePtr));

    rc = internal_cpssDxChIpUrpfLooseModeTypeGet(devNum, looseModeTypePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, looseModeTypePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortSipSaEnableSet function
* @endinternal
*
* @brief   Enable SIP/SA check for packets received from the given port.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number (including CPU port)
* @param[in] enable                   - GT_FALSE: disable SIP/SA check on the port
*                                      GT_TRUE:  enable SIP/SA check on the port
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device or port
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note SIP/SA check is triggered only if either this flag or
*       the sipSaCheckMismatchEnable field configured in cpssDxChIpLttWrite
*       are enabled.
*
*/
static GT_STATUS internal_cpssDxChIpPortSipSaEnableSet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_NUM                  portNum,
    IN  GT_BOOL                      enable
)
{
    GT_U32      regAddr;
    GT_STATUS   rc = GT_OK; /* return code */
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32       localPort;  /* local port - support multi-port-groups device */
    GT_U32      data;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E);
    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

    data = BOOL2BIT_MAC(enable);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                             CPSS_DXCH_SIP5_TABLE_IPVX_INGRESS_EPORT_E,
                                             portNum,
                                             PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                             SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_ROUTER_PER_EPORT_SIP_SA_CHECK_ENABLE_E,
                                             PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                             data);
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

        if(portNum == CPSS_CPU_PORT_NUM_CNS)
            localPort = 31;
        else
            localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        /* Get address of register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerPerPortSipSaEnable0;

        rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,localPort,1,data);
    }

    return rc;
}

/**
* @internal cpssDxChIpPortSipSaEnableSet function
* @endinternal
*
* @brief   Enable SIP/SA check for packets received from the given port.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number (including CPU port)
* @param[in] enable                   - GT_FALSE: disable SIP/SA check on the port
*                                      GT_TRUE:  enable SIP/SA check on the port
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device or port
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note SIP/SA check is triggered only if either this flag or
*       the sipSaCheckMismatchEnable field configured in cpssDxChIpLttWrite
*       are enabled.
*
*/
GT_STATUS cpssDxChIpPortSipSaEnableSet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_NUM                  portNum,
    IN  GT_BOOL                      enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortSipSaEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enable));

    rc = internal_cpssDxChIpPortSipSaEnableSet(devNum, portNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortSipSaEnableGet function
* @endinternal
*
* @brief   Return the SIP/SA check status for packets received from the given port.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number (including CPU port)
*
* @param[out] enablePtr                - GT_FALSE: SIP/SA check on the port is disabled
*                                      GT_TRUE:  SIP/SA check on the port is enabled
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device or port
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*
* @note SIP/SA check is triggered only if either this flag or
*       the sipSaCheckMismatchEnable field configured in cpssDxChIpLttWrite
*       are enabled.
*
*/
static GT_STATUS internal_cpssDxChIpPortSipSaEnableGet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_NUM                  portNum,
    OUT GT_BOOL                      *enablePtr
)
{
    GT_U32      regAddr;
    GT_STATUS   rc = GT_OK; /* return code */
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32       localPort;  /* local port - support multi-port-groups device */
    GT_U32      data;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E);

    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChReadTableEntryField(devNum,
                                            CPSS_DXCH_SIP5_TABLE_IPVX_INGRESS_EPORT_E,
                                            portNum,
                                            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                            SIP5_IPVX_ROUTER_EPORT_TABLE_FIELDS_ROUTER_PER_EPORT_SIP_SA_CHECK_ENABLE_E,
                                            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                            &data);
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

        if(portNum == CPSS_CPU_PORT_NUM_CNS)
            localPort = 31;
        else
            localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        /* Get address of register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerPerPortSipSaEnable0;

        rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,localPort,1,&data);
        if(rc != GT_OK)
            return rc;
    }

    *enablePtr = BIT2BOOL_MAC(data);

    return rc;
}

/**
* @internal cpssDxChIpPortSipSaEnableGet function
* @endinternal
*
* @brief   Return the SIP/SA check status for packets received from the given port.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number (including CPU port)
*
* @param[out] enablePtr                - GT_FALSE: SIP/SA check on the port is disabled
*                                      GT_TRUE:  SIP/SA check on the port is enabled
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device or port
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*
* @note SIP/SA check is triggered only if either this flag or
*       the sipSaCheckMismatchEnable field configured in cpssDxChIpLttWrite
*       are enabled.
*
*/
GT_STATUS cpssDxChIpPortSipSaEnableGet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_NUM                  portNum,
    OUT GT_BOOL                      *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortSipSaEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enablePtr));

    rc = internal_cpssDxChIpPortSipSaEnableGet(devNum, portNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupMultiTargetRateShaperSet function
* @endinternal
*
* @brief   set the Multi target Rate shaper params.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] multiTargetRateShaperEnable - weather to enable (disable) the Multi
*                                      target Rate shaper
* @param[in] windowSize               - if enabled then this is the shaper window size (APPLICABLE RANGES: 0..0xFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note for multi port-group device, the multi-target rate shaping
*       shapes a traffic on per-port-group basis according to the
*       source port of the packet.
*
*/
static GT_STATUS internal_cpssDxChIpPortGroupMultiTargetRateShaperSet
(
    IN  GT_U8              devNum,
    IN  GT_PORT_GROUPS_BMP portGroupsBmp,
    IN  GT_BOOL            multiTargetRateShaperEnable,
    IN  GT_U32             windowSize
)
{
    GT_U32    regAddr;         /* register address  */
    GT_U32    data;            /* value to write    */
    GT_U32    portGroupId;/*the port group Id - support multi-port-groups device */
    GT_STATUS rc;              /* return code       */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E |
                                          CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum,portGroupsBmp);

    if ((multiTargetRateShaperEnable == GT_TRUE) &&
        (GT_FALSE == CHECK_BITS_DATA_RANGE_MAC(windowSize,16)))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

    /* Get address of Multi Target Rate Shaping Register */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.multiTargetRateShapingReg;

    data = (GT_TRUE == multiTargetRateShaperEnable)? 1:0;

    /* loop on all active port groups in the bmp */
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(devNum,portGroupsBmp,portGroupId)
    {
        rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,
                                                    24,1,data);
        if (GT_OK != rc)
        {
            return rc;
        }

        /*if enabled then this is the shaper window size*/
        if (GT_TRUE == multiTargetRateShaperEnable)
        {
            rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,
                                                        0,16,windowSize);
        }

        if (GT_OK != rc)
        {
            return rc;
        }

    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(devNum,portGroupsBmp,portGroupId)

    return GT_OK;
}

/**
* @internal cpssDxChIpPortGroupMultiTargetRateShaperSet function
* @endinternal
*
* @brief   set the Multi target Rate shaper params.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] multiTargetRateShaperEnable - weather to enable (disable) the Multi
*                                      target Rate shaper
* @param[in] windowSize               - if enabled then this is the shaper window size (APPLICABLE RANGES: 0..0xFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note for multi port-group device, the multi-target rate shaping
*       shapes a traffic on per-port-group basis according to the
*       source port of the packet.
*
*/
GT_STATUS cpssDxChIpPortGroupMultiTargetRateShaperSet
(
    IN  GT_U8              devNum,
    IN  GT_PORT_GROUPS_BMP portGroupsBmp,
    IN  GT_BOOL            multiTargetRateShaperEnable,
    IN  GT_U32             windowSize
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMultiTargetRateShaperSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, multiTargetRateShaperEnable, windowSize));

    rc = internal_cpssDxChIpPortGroupMultiTargetRateShaperSet(devNum, portGroupsBmp, multiTargetRateShaperEnable, windowSize);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, multiTargetRateShaperEnable, windowSize));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPortGroupMultiTargetRateShaperGet function
* @endinternal
*
* @brief   get the Multi target Rate shaper params.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] multiTargetRateShaperEnablePtr - weather to enable (disable) the Multi
*                                      target Rate shaper
* @param[out] windowSizePtr            - if enabled then this is the shaper window size
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note for multi port-group device, the multi-target rate shaping
*       shapes a traffic on per-port-group basis according to the
*       source port of the packet.
*
*/
static GT_STATUS internal_cpssDxChIpPortGroupMultiTargetRateShaperGet
(
    IN  GT_U8              devNum,
    IN  GT_PORT_GROUPS_BMP portGroupsBmp,
    OUT GT_BOOL            *multiTargetRateShaperEnablePtr,
    OUT GT_U32             *windowSizePtr
)
{
    GT_U32    regAddr;         /* register address  */
    GT_U32    hwData;          /* hw value */
    GT_U32    portGroupId;/*the port group Id - support multi-port-groups device */
    GT_STATUS rc = GT_OK;      /* return code       */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E |
                                          CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    CPSS_NULL_PTR_CHECK_MAC(multiTargetRateShaperEnablePtr);
    CPSS_NULL_PTR_CHECK_MAC(windowSizePtr);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum,portGroupsBmp);

    /* Get the first active port group id */
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(devNum, portGroupsBmp,
                                                        portGroupId);

    /* Get address of Multi Target Rate Shaping Register */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.multiTargetRateShapingReg;


    /* get multiTargetRateShaperEnable */
    rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,
                                                24,1,&hwData);
    if (GT_OK != rc)
        return rc;

    *multiTargetRateShaperEnablePtr = (0 == hwData) ? GT_FALSE : GT_TRUE;


    /* get windowSize */
    rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,
                                                0,16,windowSizePtr);

    return rc;
}

/**
* @internal cpssDxChIpPortGroupMultiTargetRateShaperGet function
* @endinternal
*
* @brief   get the Multi target Rate shaper params.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:   Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* @param[out] multiTargetRateShaperEnablePtr - weather to enable (disable) the Multi
*                                      target Rate shaper
* @param[out] windowSizePtr            - if enabled then this is the shaper window size
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note for multi port-group device, the multi-target rate shaping
*       shapes a traffic on per-port-group basis according to the
*       source port of the packet.
*
*/
GT_STATUS cpssDxChIpPortGroupMultiTargetRateShaperGet
(
    IN  GT_U8              devNum,
    IN  GT_PORT_GROUPS_BMP portGroupsBmp,
    OUT GT_BOOL            *multiTargetRateShaperEnablePtr,
    OUT GT_U32             *windowSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMultiTargetRateShaperGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, multiTargetRateShaperEnablePtr, windowSizePtr));

    rc = internal_cpssDxChIpPortGroupMultiTargetRateShaperGet(devNum, portGroupsBmp, multiTargetRateShaperEnablePtr, windowSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, multiTargetRateShaperEnablePtr, windowSizePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpUcRoutingVid1AssignEnableSet function
* @endinternal
*
* @brief   Enable/disable VID1 assignment by the unicast routing
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] enable                   - enable/disable VID1 assignment by the unicast routing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong devNum
*
* @note When VID1 assignment is enabled QoS attributes can't be set by the
*       router and the following fields in the unicast nexthop entries are not
*       applicable:
*       qosProfileMarkingEnable, qosProfileIndex, qosPrecedence, modifyUp,
*       modifyDscp.
*       When VID1 assignment is disabled QoS attributes are applicable and
*       nextHopVlanId1 field in the unicast nexthop entries is not applicable.
*       It's recommended to use this API before configuring the nexthop entries.
*       Using this API when nexthops are already configured can cause unexpected
*       results.
*
*/
static GT_STATUS internal_cpssDxChIpUcRoutingVid1AssignEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_ENT  muxMode;

    muxMode = enable ? CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_VID1_E : CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_QOS_E;
    return cpssDxChIpNhMuxModeSet(devNum, muxMode);
}

/**
* @internal cpssDxChIpUcRoutingVid1AssignEnableSet function
* @endinternal
*
* @brief   Enable/disable VID1 assignment by the unicast routing
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] enable                   - enable/disable VID1 assignment by the unicast routing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong devNum
*
* @note When VID1 assignment is enabled QoS attributes can't be set by the
*       router and the following fields in the unicast nexthop entries are not
*       applicable:
*       qosProfileMarkingEnable, qosProfileIndex, qosPrecedence, modifyUp,
*       modifyDscp.
*       When VID1 assignment is disabled QoS attributes are applicable and
*       nextHopVlanId1 field in the unicast nexthop entries is not applicable.
*       It's recommended to use this API before configuring the nexthop entries.
*       Using this API when nexthops are already configured can cause unexpected
*       results.
*
*/
GT_STATUS cpssDxChIpUcRoutingVid1AssignEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRoutingVid1AssignEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpUcRoutingVid1AssignEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpUcRoutingVid1AssignEnableGet function
* @endinternal
*
* @brief   Get the enabling status of VID1 assignment by the unicast routing
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
*
* @param[out] enablePtr                - (pointer to) VID1 unicast routing assignment enabling status
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong devNum
*
* @note When VID1 assignment is enabled QoS attributes can't be set by the
*       router and the following fields in the unicast nexthop entries are not
*       applicable:
*       qosProfileMarkingEnable, qosProfileIndex, qosPrecedence, modifyUp,
*       modifyDscp.
*       When VID1 assignment is disabled QoS attributes are applicable and
*       nextHopVlanId1 field in the unicast nexthop entries is not applicable.
*
*/
static GT_STATUS internal_cpssDxChIpUcRoutingVid1AssignEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_ENT  muxMode;

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    rc = cpssDxChIpNhMuxModeGet(devNum, &muxMode);
    if (rc != GT_OK)
    {
        return rc;
    }
    *enablePtr = (muxMode == CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_VID1_E) ? GT_TRUE : GT_FALSE;
    return rc;
}

/**
* @internal cpssDxChIpUcRoutingVid1AssignEnableGet function
* @endinternal
*
* @brief   Get the enabling status of VID1 assignment by the unicast routing
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
*
* @param[out] enablePtr                - (pointer to) VID1 unicast routing assignment enabling status
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong devNum
*
* @note When VID1 assignment is enabled QoS attributes can't be set by the
*       router and the following fields in the unicast nexthop entries are not
*       applicable:
*       qosProfileMarkingEnable, qosProfileIndex, qosPrecedence, modifyUp,
*       modifyDscp.
*       When VID1 assignment is disabled QoS attributes are applicable and
*       nextHopVlanId1 field in the unicast nexthop entries is not applicable.
*
*/
GT_STATUS cpssDxChIpUcRoutingVid1AssignEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRoutingVid1AssignEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpUcRoutingVid1AssignEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpMllMultiTargetShaperBaselineSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Set Token Bucket Baseline.
*         The Token Bucket Baseline is the "zero" level of the token bucket.
*         When the token bucket fill level < Baseline,
*         the respective packet is not served.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] baseline                 - Token Bucket Baseline value in bytes
*                                      (APPLICABLE RANGES: 0..0xFFFFFF).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range baseline
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Token Bucket Baseline must be configured as follows:
*       1. At least MTU (the maximum expected packet size in the system).
*       2. When packet based shaping is enabled, the following used as
*       shaper's MTU:
*       cpssDxChIpMllMultiTargetShaperMtuSet.
*
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperBaselineSet
(
    IN GT_U8    devNum,
    IN GT_U32   baseline
)
{
    GT_U32      regAddr;    /* register address             */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    if (baseline > 0xFFFFFF)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    /* Set Token Bucket Base Line */
    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.tokenBucketBaseLine;

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 24, baseline);
}

/**
* @internal cpssDxChIpMllMultiTargetShaperBaselineSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Set Token Bucket Baseline.
*         The Token Bucket Baseline is the "zero" level of the token bucket.
*         When the token bucket fill level < Baseline,
*         the respective packet is not served.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] baseline                 - Token Bucket Baseline value in bytes
*                                      (APPLICABLE RANGES: 0..0xFFFFFF).
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range baseline
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Token Bucket Baseline must be configured as follows:
*       1. At least MTU (the maximum expected packet size in the system).
*       2. When packet based shaping is enabled, the following used as
*       shaper's MTU:
*       cpssDxChIpMllMultiTargetShaperMtuSet.
*
*/
GT_STATUS cpssDxChIpMllMultiTargetShaperBaselineSet
(
    IN GT_U8    devNum,
    IN GT_U32   baseline
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperBaselineSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, baseline));

    rc = internal_cpssDxChIpMllMultiTargetShaperBaselineSet(devNum, baseline);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, baseline));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllMultiTargetShaperBaselineGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get Token Bucket Baseline.
*         The Token Bucket Baseline is the "zero" level of the token bucket.
*         When the token bucket fill level < Baseline, the respective packet
*         is not served.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
*
* @param[out] baselinePtr              - (pointer to) Token Bucket Baseline value in bytes.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperBaselineGet
(
    IN  GT_U8    devNum,
    OUT GT_U32   *baselinePtr
)
{
    GT_U32      regAddr;    /* register address                */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(baselinePtr);

    /* Get Token Bucket Base Line */
    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.tokenBucketBaseLine;

    return prvCpssHwPpGetRegField(devNum, regAddr, 0, 24, baselinePtr);
}

/**
* @internal cpssDxChIpMllMultiTargetShaperBaselineGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get Token Bucket Baseline.
*         The Token Bucket Baseline is the "zero" level of the token bucket.
*         When the token bucket fill level < Baseline, the respective packet
*         is not served.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
*
* @param[out] baselinePtr              - (pointer to) Token Bucket Baseline value in bytes.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMllMultiTargetShaperBaselineGet
(
    IN  GT_U8    devNum,
    OUT GT_U32   *baselinePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperBaselineGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, baselinePtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperBaselineGet(devNum, baselinePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, baselinePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpMllMultiTargetShaperMtuSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Set the packet length in bytes for updating the shaper token bucket.
*         Valid when <Token Bucket Mode>=Packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] mtu                      - MTU for egress rate shaper
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range parameter
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note <Token Bucket Mode> is configured in cpssDxChIpMllMultiTargetShaperConfigurationSet
*
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperMtuSet
(
    IN GT_U8   devNum,
    IN GT_U32  mtu
)
{
    GT_U32      regAddr;     /* register address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    if(mtu>0xFFFFFF)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetMTUReg;

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 24, mtu);
}

/**
* @internal cpssDxChIpMllMultiTargetShaperMtuSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Set the packet length in bytes for updating the shaper token bucket.
*         Valid when <Token Bucket Mode>=Packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] mtu                      - MTU for egress rate shaper
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range parameter
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note <Token Bucket Mode> is configured in cpssDxChIpMllMultiTargetShaperConfigurationSet
*
*/
GT_STATUS cpssDxChIpMllMultiTargetShaperMtuSet
(
    IN GT_U8   devNum,
    IN GT_U32  mtu
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperMtuSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mtu));

    rc = internal_cpssDxChIpMllMultiTargetShaperMtuSet(devNum, mtu);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mtu));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllMultiTargetShaperMtuGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get the packet length in bytes for updating the shaper token bucket.
*         Valid when <Token Bucket Mode>=Packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] mtuPtr                   -  pointer to MTU for egress rate shaper
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note <Token Bucket Mode> is configured in cpssDxChIpMllMultiTargetShaperConfigurationSet
*
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperMtuGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *mtuPtr
)
{
    GT_U32      regAddr;    /* register address                */
    GT_U32      value;      /* value to read from register     */
    GT_STATUS   rc;         /* function return value           */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(mtuPtr);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetMTUReg;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 24, &value);

    if (rc != GT_OK)
        return rc;

    *mtuPtr = value;

    return GT_OK;
}

/**
* @internal cpssDxChIpMllMultiTargetShaperMtuGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get the packet length in bytes for updating the shaper token bucket.
*         Valid when <Token Bucket Mode>=Packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] mtuPtr                   -  pointer to MTU for egress rate shaper
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_STATE             - on invalid hardware value read
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note <Token Bucket Mode> is configured in cpssDxChIpMllMultiTargetShaperConfigurationSet
*
*/
GT_STATUS cpssDxChIpMllMultiTargetShaperMtuGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *mtuPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperMtuGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mtuPtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperMtuGet(devNum, mtuPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mtuPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Set Token Bucket Mode Mll shaper.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] tokenBucketMode          -   Defines the packet length used to decrease the shaper token bucket.
*                                      In Byte mode, the token bucket rate shaper is decreased according to the
*                                      packet length as received by the switch.
*                                      In Packet mode, the token bucket rate shaper is decreased by the packet
*                                      length specified in cpssDxChIpMllMultiTargetShaperMtuSet.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeSet
(
    IN  GT_U8                                        devNum,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT            tokenBucketMode
)
{
    GT_U32      regAddr;     /* register address */
    GT_U32      value;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    switch(tokenBucketMode)
    {
    case  CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E:
        value = 0;
        break;
    case  CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E:
        value = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;

    return prvCpssHwPpSetRegField(devNum, regAddr, 25, 1,value);
}

/**
* @internal cpssDxChIpMllMultiTargetShaperTokenBucketModeSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Set Token Bucket Mode Mll shaper.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] tokenBucketMode          -   Defines the packet length used to decrease the shaper token bucket.
*                                      In Byte mode, the token bucket rate shaper is decreased according to the
*                                      packet length as received by the switch.
*                                      In Packet mode, the token bucket rate shaper is decreased by the packet
*                                      length specified in cpssDxChIpMllMultiTargetShaperMtuSet.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMllMultiTargetShaperTokenBucketModeSet
(
    IN  GT_U8                                        devNum,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT            tokenBucketMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperTokenBucketModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tokenBucketMode));

    rc = internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeSet(devNum, tokenBucketMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tokenBucketMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get Token Bucket Mode Mll shaper.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
*
* @param[out] tokenBucketModePtr       - (pointer to)Defines the packet length used to decrease the shaper token bucket.
*                                      In Byte mode, the token bucket rate shaper is decreased according to the
*                                      packet length as received by the switch.
*                                      In Packet mode, the token bucket rate shaper is decreased by the packet
*                                      length specified in cpssDxChIpMllMultiTargetShaperMtuSet.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note none.
*
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeGet
(
    IN  GT_U8                                        devNum,
    OUT CPSS_PORT_TX_DROP_SHAPER_MODE_ENT            *tokenBucketModePtr
)
{
    GT_U32      regAddr;    /* register address                */
    GT_U32      value;      /* value to read from register     */
    GT_STATUS   rc;         /* function return value           */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(tokenBucketModePtr);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 25, 1, &value);

    if (rc != GT_OK)
        return rc;

    switch(value)
    {
    case  0:
        *tokenBucketModePtr = CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E;
        break;
    case  1:
        *tokenBucketModePtr = CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_VALUE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal cpssDxChIpMllMultiTargetShaperTokenBucketModeGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get Token Bucket Mode Mll shaper.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
*
* @param[out] tokenBucketModePtr       - (pointer to)Defines the packet length used to decrease the shaper token bucket.
*                                      In Byte mode, the token bucket rate shaper is decreased according to the
*                                      packet length as received by the switch.
*                                      In Packet mode, the token bucket rate shaper is decreased by the packet
*                                      length specified in cpssDxChIpMllMultiTargetShaperMtuSet.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note none.
*
*/
GT_STATUS cpssDxChIpMllMultiTargetShaperTokenBucketModeGet
(
    IN  GT_U8                                        devNum,
    OUT CPSS_PORT_TX_DROP_SHAPER_MODE_ENT            *tokenBucketModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperTokenBucketModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tokenBucketModePtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeGet(devNum, tokenBucketModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tokenBucketModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllMultiTargetShaperEnableSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Enable/Disable Token Bucket rate shaping.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE,  Shaping
*                                      GT_FALSE, disable Shaping
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_U32      regAddr;
    GT_U32      value;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    value = BOOL2BIT_MAC(enable);

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, value);

}

/**
* @internal cpssDxChIpMllMultiTargetShaperEnableSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Enable/Disable Token Bucket rate shaping.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] enable                   - GT_TRUE,  Shaping
*                                      GT_FALSE, disable Shaping
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS  cpssDxChIpMllMultiTargetShaperEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpMllMultiTargetShaperEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllMultiTargetShaperEnableGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get Enable/Disable Token Bucket rate shaping status
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - Pointer to Token Bucket rate shaping status.
*                                      - GT_TRUE, enable Shaping
*                                      - GT_FALSE, disable Shaping
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL  *enablePtr
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;    /* register address for token bucket*/
    GT_U32      value;      /* register field value */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 1, &value);

    if (rc != GT_OK)
        return rc;

    *enablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/**
* @internal cpssDxChIpMllMultiTargetShaperEnableGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get Enable/Disable Token Bucket rate shaping status
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] enablePtr                - Pointer to Token Bucket rate shaping status.
*                                      - GT_TRUE, enable Shaping
*                                      - GT_FALSE, disable Shaping
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMllMultiTargetShaperEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL  *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChIpMllMultiTargetReCalcShaperTokenBucketRate function
* @endinternal
*
* @brief   Calculate shaping rate parameters for given tokenBucketRate:
*         1. TB refill value
*         2. slow rate enable value
*         3. TB interval update ratio value
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] tokenBucketIntervalSlowUpdateRatio - Increases the token bucket update interval to
*                                      <TokenBucketIntervalSlowUpdateRatio>+1>  <TokenBucketUpdateInterval>
*                                      (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                      Enabled by setting SlowRateEn = GT_TRUE.
*                                      (APPLICABLE RANGES: 1...16)
* @param[in] tokenBucketUpdateInterval - Defines the token update interval for the egress rate shapers.
*                                      The update interval = <TokenBucketIntervalSlowUpdateRatio>+1>
*                                      <TokenBucketUpdateInterval>  (64 or 1024 depends on
*                                      <TokenBucketIntervalUpdateRatio>)2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                      Upon every interval expiration, a configured amount of tokens is added to the
*                                      token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                      NOTE:
*                                      - This field must not be 0.
*                                      - The inclusion of <TokenBucketIntervalSlowUpdateRatio>+1> is enabled per shaper.
*                                      (APPLICABLE RANGES: 1...15)
* @param[in] tokenBucketIntervalUpdateRatio - Token Bucket Interval Update Ratio : 64 or 1024
* @param[in] tokenBucketMode          - Defines the packet length used to decrease the shaper token bucket.
* @param[in] tokenBucketRate          - the shaping rate - actual Rate in Kbps.
* @param[in] burstSize                - burst size in bytes
*                                      (already adjusted for baseline)
*
* @param[out] slowRateEnPtr            - (pointer to) slow rate enable value
* @param[out] tbUpdateRatioPtr         - (pointer to) TB interval update ratio value
* @param[out] tokenRefillValuePtr      - (pointer to) TB refill value
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS prvCpssDxChIpMllMultiTargetReCalcShaperTokenBucketRate
(
    IN  GT_U8                                           devNum,
    IN  GT_U32                                          tokenBucketIntervalSlowUpdateRatio,
    IN  GT_U32                                          tokenBucketUpdateInterval,
    IN  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   tokenBucketIntervalUpdateRatio,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT               tokenBucketMode,
    IN  GT_U32                                          tokenBucketRate,
    IN  GT_U32                                          burstSize,
    OUT GT_BOOL                                         *slowRateEnPtr,
    OUT GT_U32                                          *tbUpdateRatioPtr,
    OUT GT_U32                                          *tokenRefillValuePtr
)
{
    GT_STATUS                             rc = GT_OK;
    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC   txShaperConfig;
    GT_U32                                multiTargetMtu;

    /* emulate a txq shaper struct from MLL Multi Target shaper struct */
    txShaperConfig.tokensRate = tokenBucketUpdateInterval;

    txShaperConfig.slowRateRatio = tokenBucketIntervalSlowUpdateRatio;

    switch(tokenBucketIntervalUpdateRatio)
    {
        case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E:
            txShaperConfig.tokensRateGran=CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_64_CORE_CLOCKS_E;
            break;
        case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
            txShaperConfig.tokensRateGran=CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    rc = prvCpssHwPpGetRegField(devNum,
                                PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetMTUReg,
                                0, 24, &multiTargetMtu);

    if(rc != GT_OK)
        return rc;

    txShaperConfig.portsPacketLength = multiTargetMtu;
    txShaperConfig.cpuPacketLength   = multiTargetMtu;


    return prvCpssDxChPortTxReCalcShaperTokenBucketRate_rev1(devNum,
                                                          0,
                                                          GT_TRUE,
                                                          &txShaperConfig,
                                                          tokenBucketMode,
                                                          tokenBucketRate,
                                                          burstSize,
                                                          GT_TRUE,
                                                          slowRateEnPtr,
                                                          tbUpdateRatioPtr,
                                                          tokenRefillValuePtr);
}

/**
* @internal prvCpssDxChIpMllMultiTargetCalcShaperTokenBucketRate function
* @endinternal
*
* @brief   Get shaper parameters for token bucket:
*         - Token refill value.
*         - slow-rate mode.
*         - tokens rate
*         - slow rate ratio.
*         The Formula is:
*         <Core Clock Frequency in Kbps> <Token refill value in bits>
*         Rate in Kbps = -------------------------------------------------------------
*         <Refill period in clock cycles>
*         Refill period in clock cycles when slow rate is enabled =
*         <tokensRate> <tokensRateGran> <Slow Rate>
*         Refill period in clock cycles when slow rate is disabled =
*         <tokensRate> <tokensRateGran> 2 ^ < tbUpdateRatio >
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] tokenBucketIntervalSlowUpdateRatio - Increases the token bucket update interval to
*                                      <TokenBucketIntervalSlowUpdateRatio>+1>  <TokenBucketUpdateInterval>
*                                      (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                      Enabled by setting SlowRateEn = GT_TRUE.
*                                      (APPLICABLE RANGES: 1...16)
* @param[in] tokenBucketUpdateInterval - Defines the token update interval for the egress rate shapers.
*                                      The update interval = <TokenBucketIntervalSlowUpdateRatio>+1>
*                                      <TokenBucketUpdateInterval>  (64 or 1024 depends on
*                                      <TokenBucketIntervalUpdateRatio>)2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                      Upon every interval expiration, a configured amount of tokens is added to the
*                                      token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                      NOTE:
*                                      - This field must not be 0.
*                                      - The inclusion of <TokenBucketIntervalSlowUpdateRatio>+1> is enabled per shaper.
*                                      (APPLICABLE RANGES: 1...15)
* @param[in] tokenBucketIntervalUpdateRatio - Token Bucket Interval Update Ratio : 64 or 1024
* @param[in] tokenBucketMode          - Defines the packet length used to decrease the shaper token bucket.
* @param[in] slowRateEn               - slow rate enable value
* @param[in] tbUpdateRatio            - TB interval update ratio value
* @param[in] tokenRefillValue         - TB refill value
*
* @param[out] tokenBucketRatePtr       - (pointer to) the actual Rate in Kbps or pps.
*
* @retval GT_OK                    - on success
*/
static GT_STATUS prvCpssDxChIpMllMultiTargetCalcShaperTokenBucketRate
(
    IN  GT_U8                                           devNum,
    IN  GT_U32                                          tokenBucketIntervalSlowUpdateRatio,
    IN  GT_U32                                          tokenBucketUpdateInterval,
    IN  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   tokenBucketIntervalUpdateRatio,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT               tokenBucketMode,
    IN  GT_BOOL                                         slowRateEn,
    IN  GT_U32                                          tbUpdateRatio,
    IN  GT_U32                                          tokenRefillValue,
    OUT GT_U32                                          *tokenBucketRatePtr
)
{
    GT_STATUS                             rc = GT_OK;
    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC   txShaperConfig;
    GT_U32                                multiTargetMtu;

    /* emulate a txq shaper struct from MLL Multi Target shaper struct */
    txShaperConfig.tokensRate = tokenBucketUpdateInterval;

    txShaperConfig.slowRateRatio = tokenBucketIntervalSlowUpdateRatio;

    switch(tokenBucketIntervalUpdateRatio)
    {
        case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E:
            txShaperConfig.tokensRateGran=CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_64_CORE_CLOCKS_E;
            break;
        case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
            txShaperConfig.tokensRateGran=CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    rc = prvCpssHwPpGetRegField(devNum,
                                PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetMTUReg,
                                0, 24, &multiTargetMtu);

    if(rc != GT_OK)
        return rc;

    txShaperConfig.portsPacketLength = multiTargetMtu;
    txShaperConfig.cpuPacketLength   = multiTargetMtu;

    return prvDxChPortTxCalcShaperTokenBucketRate_rev1(devNum,
                                                     0,
                                                     &txShaperConfig,
                                                     tokenBucketMode,
                                                     slowRateEn,
                                                     tbUpdateRatio,
                                                     tokenRefillValue,
                                                     tokenBucketRatePtr);
}

/**
* @internal internal_cpssDxChIpMllMultiTargetShaperConfigurationSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Set configuration for Mll shaper.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] maxBucketSize            - Maximum bucket size in bytes. The field resolution is 4096 bytes.
*                                      The actual burst size is approximately
*                                      <MaxBucketSize>4096 - <Token Bucket Base Line>
*                                      When the CPU writes to this field, the value is also written
*                                      to the Token Bucket counter.
*                                      <MaxBucketSize>4096 must be set to be greater than both <Tokens>
*                                      and <Token Bucket Base Line>.
*                                      0 means 4k and 0xFFF means 16M
*                                      The bucket size ranges from 4 KB to 16 MB, in steps of 4K.
*                                      (APPLICABLE RANGES: 0...0xFFF)
* @param[in,out] maxRatePtr               - Requested Rate in Kbps or packets per second
*                                      according to shaper mode.
* @param[in,out] maxRatePtr               - (pointer to) the actual Rate value in Kbps or packets per second.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note When packet based shaping is enabled, the following used as shaper's MTU:
*       see:
*       cpssDxChIpMllMultiTargetShaperMtuSet
*       cpssDxChIpMllMultiTargetShaperBaselineSet.
*
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperConfigurationSet
(
    IN  GT_U8                                        devNum,
    IN  GT_U32                                       maxBucketSize,
    INOUT GT_U32                                     *maxRatePtr
)
{
    GT_U32      value1, value2;     /* value to write into register */
    GT_U32      hwData1, hwData2;   /* hwData from register */
    GT_STATUS   rc;                 /* return code */
    GT_U32      regAddr1, regAddr2; /* register address             */
    GT_U32      mask1, mask2;       /* register mask */
    GT_U32      hwTokenBucketMode;
    GT_U32      hwTokenBucketIntervalUpdateRatio;
    GT_U32      tokenBucketBaseLine;
    GT_U32      tokenRefillValue;
    CPSS_PORT_TX_DROP_SHAPER_MODE_ENT            tokenBucketMode;

    GT_U32 tokenBucketIntervalSlowUpdateRatio;/* Increases the token bucket update interval (1-16)*/
    GT_U32 tokenBucketUpdateInterval;/* Defines the token update interval for the egress rate shapers (1-15) */
    CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT tokenBucketIntervalUpdateRatio;/* Token Bucket Interval Update Ratio : 64 or 1024*/


    GT_U32      tbUpdateRatio;    /* TB interval update ratio value */
    GT_BOOL     slowRateEnable;   /* slow rate enable value */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(maxRatePtr);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);


    if(maxBucketSize > CPSS_DXCH_MULTI_TARGET_SHAPER_MAX_BUCKET_SIZE_CNS)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    /* MaxBucketSize*4096 must be set to be greater than both <Tokens> and <Token Bucket Base Line>.
       number of tokens equal to (Token Refill Value + 1) --> this validation will be done in
       prvCpssDxChIpMllMultiTargetReCalcShaperTokenBucketRate  */
    rc = prvCpssHwPpGetRegField(devNum,
                                PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.tokenBucketBaseLine,
                                0, 24, &tokenBucketBaseLine);
    if (rc != GT_OK)
    {
        return rc;
    }
    /* maxBucketSize=0 --> means maxBucketSize is 4K
       maxBucketSize=1 --> means maxBucketSize is 8K
       and so on .... until 16M */
    if(((maxBucketSize+1) * _4KB) <= tokenBucketBaseLine)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr1 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;
    regAddr2 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig2;

    /* read data from HW used for calculation of slowRateEnable, tbUpdateRatio
       and tokenRefillValue according to the maxRatePtr input parameter. */
    rc = prvCpssHwPpReadRegister(devNum,regAddr1,&hwData1);
    if (rc != GT_OK)
    {
        return rc;
    }

    switch(U32_GET_FIELD_MAC(hwData1, 25, 1))
    {
        case 0:
            tokenBucketMode=CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E;
            break;
        case 1:
            tokenBucketMode=CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_VALUE, LOG_ERROR_NO_MSG);
    }

    tokenBucketIntervalSlowUpdateRatio = U32_GET_FIELD_MAC(hwData1, 27, 4) + 1;

    rc = prvCpssHwPpReadRegister(devNum,regAddr2,&hwData2);
    if (rc != GT_OK)
    {
        return rc;
    }

    tokenBucketUpdateInterval = U32_GET_FIELD_MAC(hwData2, 0, 4);
    switch(U32_GET_FIELD_MAC(hwData2, 8, 1))
    {
    case 0:
        tokenBucketIntervalUpdateRatio = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E;
        break;
    case 1:
        tokenBucketIntervalUpdateRatio = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* calculate per TB configurations */
    rc = prvCpssDxChIpMllMultiTargetReCalcShaperTokenBucketRate(devNum,
                                                                tokenBucketIntervalSlowUpdateRatio,
                                                                tokenBucketUpdateInterval,
                                                                tokenBucketIntervalUpdateRatio,
                                                                tokenBucketMode,
                                                                *maxRatePtr,
                                                                (maxBucketSize*_4KB) -
                                                                        tokenBucketBaseLine,
                                                                &slowRateEnable,
                                                                &tbUpdateRatio,
                                                                &tokenRefillValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Maximum value of tocken refill value in Multi-Target Rate Shaping Configuration Register is 0xFFF */
    if(tokenRefillValue > PRV_CPSS_DXCH_TXQREV1_TOKENS_REFILL_MAX_CNS)
    {
        tokenRefillValue = PRV_CPSS_DXCH_TXQREV1_TOKENS_REFILL_MAX_CNS;
    }

    /* calculate the actual Rate value */
    rc = prvCpssDxChIpMllMultiTargetCalcShaperTokenBucketRate(devNum,
                                                        tokenBucketIntervalSlowUpdateRatio,
                                                        tokenBucketUpdateInterval,
                                                        tokenBucketIntervalUpdateRatio,
                                                        tokenBucketMode,
                                                        slowRateEnable,
                                                        tbUpdateRatio,
                                                        tokenRefillValue,
                                                        maxRatePtr);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* for value 1:
       bits [1:12] maxBucketSize, [13:24] tokenRefillValue, [25]tokenBucketMode
       bits [26] slowRateEn, [27:30] tokenBucketIntervalSlowUpdateRatio, [31] tbScanEn */
    value1 = (((maxBucketSize & 0xFFF) << 1) |
              ((tokenRefillValue & 0xFFF) << 13));

    switch(tokenBucketMode)
    {
    case CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E:
        hwTokenBucketMode = 0;
        break;
    case CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E:
        hwTokenBucketMode = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    value1 |= (hwTokenBucketMode << 25) | (BOOL2BIT_MAC(slowRateEnable) << 26) |
              (((tokenBucketIntervalSlowUpdateRatio - 1) & 0xF) << 27);

    mask1  = 0x7FFFFFFE;

    rc = prvCpssHwPpWriteRegBitMask(devNum, regAddr1, mask1, value1);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* for value 2:
       bits [0:3] tokenBucketUpdateInterval, [4:7] tbIntervalUpdateRatio,
       bits [8] tokenBucketIntervalUpdateRatio*/
    value2 = (tokenBucketUpdateInterval & 0xF) |
             ((tbUpdateRatio & 0xF) << 4);

    switch(tokenBucketIntervalUpdateRatio)
    {
    case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E:
        hwTokenBucketIntervalUpdateRatio = 0;
        break;
    case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
        hwTokenBucketIntervalUpdateRatio = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    value2 |= (hwTokenBucketIntervalUpdateRatio << 8);
    mask2  = 0x1FF;

    rc = prvCpssHwPpWriteRegBitMask(devNum, regAddr2, mask2, value2);
    if (rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/**
* @internal cpssDxChIpMllMultiTargetShaperConfigurationSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Set configuration for Mll shaper.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] maxBucketSize            - Maximum bucket size in bytes. The field resolution is 4096 bytes.
*                                      The actual burst size is approximately
*                                      <MaxBucketSize>4096 - <Token Bucket Base Line>
*                                      When the CPU writes to this field, the value is also written
*                                      to the Token Bucket counter.
*                                      <MaxBucketSize>4096 must be set to be greater than both <Tokens>
*                                      and <Token Bucket Base Line>.
*                                      0 means 4k and 0xFFF means 16M
*                                      The bucket size ranges from 4 KB to 16 MB, in steps of 4K.
*                                      (APPLICABLE RANGES: 0...0xFFF)
* @param[in,out] maxRatePtr               - Requested Rate in Kbps or packets per second
*                                      according to shaper mode.
* @param[in,out] maxRatePtr               - (pointer to) the actual Rate value in Kbps or packets per second.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note When packet based shaping is enabled, the following used as shaper's MTU:
*       see:
*       cpssDxChIpMllMultiTargetShaperMtuSet
*       cpssDxChIpMllMultiTargetShaperBaselineSet.
*
*/
GT_STATUS cpssDxChIpMllMultiTargetShaperConfigurationSet
(
    IN  GT_U8                                        devNum,
    IN  GT_U32                                       maxBucketSize,
    INOUT GT_U32                                     *maxRatePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperConfigurationSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, maxBucketSize, maxRatePtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperConfigurationSet(devNum, maxBucketSize, maxRatePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, maxBucketSize, maxRatePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllMultiTargetShaperConfigurationGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get configuration for shaper.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
*
* @param[out] maxBucketSizePtr         - (pointer to) Maximum bucket size in bytes. The field resolution is 4096 bytes.
*                                      The actual burst size is approximately
*                                      <MaxBucketSize>4096 - <Token Bucket Base Line>
*                                      When the CPU writes to this field, the value is also written
*                                      to the Token Bucket counter.
*                                      <MaxBucketSize>4096 must be set to be greater than both <Tokens>
*                                      and <Token Bucket Base Line>.
*                                      0 equal 4k all 12'bFFF equal 16M
*                                      The bucket size ranges from 4 KB to 16 MB, in steps of 4K.
*                                      (APPLICABLE RANGES: 0...0xFFF)
* @param[out] maxRatePtr               - (pointer to) the actual Rate value in Kbps or packets per second.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note none.
*
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperConfigurationGet
(
    IN  GT_U8                                        devNum,
    OUT GT_U32                                       *maxBucketSizePtr,
    OUT GT_U32                                       *maxRatePtr
)
{
    GT_U32      value1, value2;     /* value to write into register */
    GT_STATUS   rc;                 /* return code                  */
    GT_U32      regAddr1,regAddr2;  /* register address             */
    GT_BOOL     slowRateEn;
    GT_U32      tbIntervalUpdateRatio;
    GT_U32      tokenRefillValue;
    GT_U32      tokenBucketRate;

    GT_U32 tokenBucketIntervalSlowUpdateRatio;/* Increases the token bucket update interval (1-16)*/
    GT_U32 tokenBucketUpdateInterval;/* Defines the token update interval for the egress rate shapers (1-15) */
    CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT tokenBucketIntervalUpdateRatio;/* Token Bucket Interval Update Ratio : 64 or 1024*/
    CPSS_PORT_TX_DROP_SHAPER_MODE_ENT             tokenBucketMode;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(maxBucketSizePtr);
    CPSS_NULL_PTR_CHECK_MAC(maxRatePtr);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);


    regAddr1 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;
    regAddr2 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig2;

    rc = prvCpssHwPpReadRegister(devNum, regAddr1, &value1);
    if (rc != GT_OK)
    {
        return rc;
    }
    rc = prvCpssHwPpReadRegister(devNum, regAddr2, &value2);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* for value 1:
       bits [1:12] maxBucketSize, [13:24] tokenRefillValue, [25]tokenBucketMode
       bits [26] slowRateEn, [27:30] tokenBucketIntervalSlowUpdateRatio, [31] tbScanEn */
    *maxBucketSizePtr = U32_GET_FIELD_MAC(value1, 1, 12);
    tokenRefillValue = U32_GET_FIELD_MAC(value1, 13, 12);

    switch(U32_GET_FIELD_MAC(value1, 25, 1))
    {
    case 0:
        tokenBucketMode = CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E;
        break;
    case 1:
        tokenBucketMode = CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    slowRateEn = BIT2BOOL_MAC(U32_GET_FIELD_MAC(value1, 26, 1));

    tokenBucketIntervalSlowUpdateRatio = U32_GET_FIELD_MAC(value1, 27, 4) + 1;

    /* for value 2:
       bits [0:3] tokenBucketUpdateInterval, [4:7] tbIntervalUpdateRatio,
       bits [8] tokenBucketIntervalUpdateRatio */

    tokenBucketUpdateInterval = U32_GET_FIELD_MAC(value2, 0, 4);
    tbIntervalUpdateRatio = U32_GET_FIELD_MAC(value2, 4, 4);

    switch(U32_GET_FIELD_MAC(value2, 8, 1))
    {
    case 0:
        tokenBucketIntervalUpdateRatio = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E;
        break;
    case 1:
        tokenBucketIntervalUpdateRatio = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }



    rc = prvCpssDxChIpMllMultiTargetCalcShaperTokenBucketRate(devNum,
                                                              tokenBucketIntervalSlowUpdateRatio,
                                                              tokenBucketUpdateInterval,
                                                              tokenBucketIntervalUpdateRatio,
                                                              tokenBucketMode,
                                                              slowRateEn,
                                                              tbIntervalUpdateRatio,
                                                              tokenRefillValue,
                                                              &tokenBucketRate);
    if (rc != GT_OK)
    {
        return rc;
    }
    *maxRatePtr = tokenBucketRate;

    return GT_OK;
}

/**
* @internal cpssDxChIpMllMultiTargetShaperConfigurationGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get configuration for shaper.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
*
* @param[out] maxBucketSizePtr         - (pointer to) Maximum bucket size in bytes. The field resolution is 4096 bytes.
*                                      The actual burst size is approximately
*                                      <MaxBucketSize>4096 - <Token Bucket Base Line>
*                                      When the CPU writes to this field, the value is also written
*                                      to the Token Bucket counter.
*                                      <MaxBucketSize>4096 must be set to be greater than both <Tokens>
*                                      and <Token Bucket Base Line>.
*                                      0 equal 4k all 12'bFFF equal 16M
*                                      The bucket size ranges from 4 KB to 16 MB, in steps of 4K.
*                                      (APPLICABLE RANGES: 0...0xFFF)
* @param[out] maxRatePtr               - (pointer to) the actual Rate value in Kbps or packets per second.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note none.
*
*/
GT_STATUS cpssDxChIpMllMultiTargetShaperConfigurationGet
(
    IN  GT_U8                                        devNum,
    OUT GT_U32                                       *maxBucketSizePtr,
    OUT GT_U32                                       *maxRatePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperConfigurationGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, maxBucketSizePtr, maxRatePtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperConfigurationGet(devNum, maxBucketSizePtr, maxRatePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, maxBucketSizePtr, maxRatePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Set configuration for Mll shaper Interval.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] tokenBucketIntervalSlowUpdateRatio - Increases the token bucket update interval to
*                                      <TokenBucketIntervalSlowUpdateRatio>+1>  <TokenBucketUpdateInterval>
*                                      (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                      Enabled by setting SlowRateEn = GT_TRUE.
*                                      (APPLICABLE RANGES: 1...16)
* @param[in] tokenBucketUpdateInterval -   Defines the token update interval for the egress rate shapers.
*                                      The update interval = <TokenBucketIntervalSlowUpdateRatio>+1>
*                                      <TokenBucketUpdateInterval>  (64 or 1024 depends on
*                                      <TokenBucketIntervalUpdateRatio>)2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                      Upon every interval expiration, a configured amount of tokens is added to the
*                                      token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                      NOTE:
*                                      - This field must not be 0.
*                                      (APPLICABLE RANGES: 1...15)
* @param[in] tokenBucketIntervalUpdateRatio - Token Bucket Interval Update Ratio : 64 or 1024
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet
(
    IN  GT_U8                                           devNum,
    IN  GT_U32                                          tokenBucketIntervalSlowUpdateRatio,
    IN  GT_U32                                          tokenBucketUpdateInterval,
    IN  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   tokenBucketIntervalUpdateRatio
)
{
    GT_STATUS rc = GT_OK;
    GT_U32      regAddr1,regAddr2;     /* register address */
    GT_U32      value;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    if((tokenBucketIntervalSlowUpdateRatio < PRV_CPSS_DXCH_TXQREV1_SLOW_TOKEN_BCKT_UPD_RATIO_MIN_CNS) ||
        (tokenBucketIntervalSlowUpdateRatio > PRV_CPSS_DXCH_TXQREV1_SLOW_TOKEN_BCKT_UPD_RATIO_MAX_CNS))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

    if((tokenBucketUpdateInterval < PRV_CPSS_DXCH_TXQREV1_TOKEN_BCKT_UPD_RATE_MIN_CNS)||
       (tokenBucketUpdateInterval > PRV_CPSS_DXCH_TXQREV1_TOKEN_BCKT_UPD_RATE_MAX_CNS))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

    switch(tokenBucketIntervalUpdateRatio)
    {
    case  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E:
        value = 0;
        break;
    case  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
        value = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    regAddr1 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;
    regAddr2 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig2;

    rc = prvCpssHwPpSetRegField(devNum, regAddr1, 27, 4, (tokenBucketIntervalSlowUpdateRatio-1));
    if(rc != GT_OK)
        return rc;

    rc = prvCpssHwPpSetRegField(devNum, regAddr2, 0, 4, tokenBucketUpdateInterval);
    if(rc != GT_OK)
        return rc;

     rc = prvCpssHwPpSetRegField(devNum, regAddr2, 8, 1, value);
    if(rc != GT_OK)
        return rc;

    return rc;
}

/**
* @internal cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Set configuration for Mll shaper Interval.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
* @param[in] tokenBucketIntervalSlowUpdateRatio - Increases the token bucket update interval to
*                                      <TokenBucketIntervalSlowUpdateRatio>+1>  <TokenBucketUpdateInterval>
*                                      (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                      Enabled by setting SlowRateEn = GT_TRUE.
*                                      (APPLICABLE RANGES: 1...16)
* @param[in] tokenBucketUpdateInterval -   Defines the token update interval for the egress rate shapers.
*                                      The update interval = <TokenBucketIntervalSlowUpdateRatio>+1>
*                                      <TokenBucketUpdateInterval>  (64 or 1024 depends on
*                                      <TokenBucketIntervalUpdateRatio>)2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                      Upon every interval expiration, a configured amount of tokens is added to the
*                                      token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                      NOTE:
*                                      - This field must not be 0.
*                                      (APPLICABLE RANGES: 1...15)
* @param[in] tokenBucketIntervalUpdateRatio - Token Bucket Interval Update Ratio : 64 or 1024
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_OUT_OF_RANGE          - on out of range value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet
(
    IN  GT_U8                                           devNum,
    IN  GT_U32                                          tokenBucketIntervalSlowUpdateRatio,
    IN  GT_U32                                          tokenBucketUpdateInterval,
    IN  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   tokenBucketIntervalUpdateRatio
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tokenBucketIntervalSlowUpdateRatio, tokenBucketUpdateInterval, tokenBucketIntervalUpdateRatio));

    rc = internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet(devNum, tokenBucketIntervalSlowUpdateRatio, tokenBucketUpdateInterval, tokenBucketIntervalUpdateRatio);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tokenBucketIntervalSlowUpdateRatio, tokenBucketUpdateInterval, tokenBucketIntervalUpdateRatio));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get configuration for shaper Interval.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
*
* @param[out] tokenBucketIntervalSlowUpdateRatioPtr - (pointer to) Increases the token bucket update interval to
*                                      <TokenBucketIntervalSlowUpdateRatio>+1>  <TokenBucketUpdateInterval>
*                                      (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                      Enabled by setting SlowRateEn = GT_TRUE.
*                                      (APPLICABLE RANGES: 1...16)
* @param[out] tokenBucketUpdateIntervalPtr -   (pointer to) the token update interval for the egress rate shapers.
*                                      The update interval = <TokenBucketIntervalSlowUpdateRatio>+1>
*                                      <TokenBucketUpdateInterval>  (64 or 1024 depends on
*                                      <TokenBucketIntervalUpdateRatio>)2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                      Upon every interval expiration, a configured amount of tokens is added to the
*                                      token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                      NOTE:
*                                      - This field must not be 0.
*                                      (APPLICABLE RANGES: 1...15)
* @param[out] tokenBucketIntervalUpdateRatioPtr - (pointer to) Token Bucket Interval Update Ratio : 64 or 1024
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note none.
*
*/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet
(
    IN   GT_U8                                           devNum,
    OUT  GT_U32                                          *tokenBucketIntervalSlowUpdateRatioPtr,
    OUT  GT_U32                                          *tokenBucketUpdateIntervalPtr,
    OUT  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   *tokenBucketIntervalUpdateRatioPtr
)
{
    GT_STATUS   rc = GT_OK;
    GT_U32      regAddr1,regAddr2;     /* register address */
    GT_U32      value;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(tokenBucketIntervalSlowUpdateRatioPtr);
    CPSS_NULL_PTR_CHECK_MAC(tokenBucketUpdateIntervalPtr);
    CPSS_NULL_PTR_CHECK_MAC(tokenBucketIntervalUpdateRatioPtr);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);



    regAddr1 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;
    regAddr2 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig2;

    rc = prvCpssHwPpGetRegField(devNum, regAddr1, 27, 4, &value);
    if(rc != GT_OK)
        return rc;

    *tokenBucketIntervalSlowUpdateRatioPtr = value + 1;

    rc = prvCpssHwPpGetRegField(devNum, regAddr2, 0, 4, &value);
    if(rc != GT_OK)
        return rc;

    *tokenBucketUpdateIntervalPtr = value;

    rc = prvCpssHwPpGetRegField(devNum, regAddr2, 8, 1,  &value);
    if(rc != GT_OK)
        return rc;

    switch(value)
    {
        case  0:
            *tokenBucketIntervalUpdateRatioPtr = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E;
            break;
        case  1:
            *tokenBucketIntervalUpdateRatioPtr = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }
    return rc;
}

/**
* @internal cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet function
* @endinternal
*
* @brief   Relevant for L2 and L3 MLL.
*         Get configuration for shaper Interval.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number.
*
* @param[out] tokenBucketIntervalSlowUpdateRatioPtr - (pointer to) Increases the token bucket update interval to
*                                      <TokenBucketIntervalSlowUpdateRatio>+1>  <TokenBucketUpdateInterval>
*                                      (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                      Enabled by setting SlowRateEn = GT_TRUE.
*                                      (APPLICABLE RANGES: 1...16)
* @param[out] tokenBucketUpdateIntervalPtr -   (pointer to) the token update interval for the egress rate shapers.
*                                      The update interval = <TokenBucketIntervalSlowUpdateRatio>+1>
*                                      <TokenBucketUpdateInterval>  (64 or 1024 depends on
*                                      <TokenBucketIntervalUpdateRatio>)2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                      Upon every interval expiration, a configured amount of tokens is added to the
*                                      token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                      NOTE:
*                                      - This field must not be 0.
*                                      (APPLICABLE RANGES: 1...15)
* @param[out] tokenBucketIntervalUpdateRatioPtr - (pointer to) Token Bucket Interval Update Ratio : 64 or 1024
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note none.
*
*/
GT_STATUS cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet
(
    IN   GT_U8                                           devNum,
    OUT  GT_U32                                          *tokenBucketIntervalSlowUpdateRatioPtr,
    OUT  GT_U32                                          *tokenBucketUpdateIntervalPtr,
    OUT  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   *tokenBucketIntervalUpdateRatioPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tokenBucketIntervalSlowUpdateRatioPtr, tokenBucketUpdateIntervalPtr, tokenBucketIntervalUpdateRatioPtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet(devNum, tokenBucketIntervalSlowUpdateRatioPtr, tokenBucketUpdateIntervalPtr, tokenBucketIntervalUpdateRatioPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tokenBucketIntervalSlowUpdateRatioPtr, tokenBucketUpdateIntervalPtr, tokenBucketIntervalUpdateRatioPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet function
* @endinternal
*
* @brief   Enable/disable bypassing the router triggering requirements for policy
*         based routing packets
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   -  bypassing the router triggering requirements for PBR
*                                      packets:
*                                      GT_FALSE: Policy based routing uses the normal router
*                                      triggering requirements
*                                      GT_TRUE:  Policy based routing bypasses the router triggering
*                                      requirement for the FDB DA entry <DA Route> to be
*                                      set for UC routing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_U32    regAddr;
    GT_U32      hwData;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    /* Get address of register */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;

    hwData = BOOL2BIT_MAC(enable);
    return prvCpssHwPpSetRegField(devNum, regAddr, 7, 1, hwData);
}

/**
* @internal cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet function
* @endinternal
*
* @brief   Enable/disable bypassing the router triggering requirements for policy
*         based routing packets
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   -  bypassing the router triggering requirements for PBR
*                                      packets:
*                                      GT_FALSE: Policy based routing uses the normal router
*                                      triggering requirements
*                                      GT_TRUE:  Policy based routing bypasses the router triggering
*                                      requirement for the FDB DA entry <DA Route> to be
*                                      set for UC routing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet function
* @endinternal
*
* @brief   Get the enabling status of bypassing the router triggering requirements
*         for policy based routing packets
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - the router triggering requirements enabling status for PBR
*                                      packets:
*                                      GT_FALSE: Policy based routing uses the normal router
*                                      triggering requirements
*                                      GT_TRUE:  Policy based routing bypasses the router triggering
*                                      requirement for the FDB DA entry <DA Route> to be
*                                      set for UC routing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    /* Get address of register */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 7, 1, &hwData);
    if (rc == GT_OK)
    {
        *enablePtr = BIT2BOOL_MAC(hwData);
    }
    return rc;
}

/**
* @internal cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet function
* @endinternal
*
* @brief   Get the enabling status of bypassing the router triggering requirements
*         for policy based routing packets
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - the router triggering requirements enabling status for PBR
*                                      packets:
*                                      GT_FALSE: Policy based routing uses the normal router
*                                      triggering requirements
*                                      GT_TRUE:  Policy based routing bypasses the router triggering
*                                      requirement for the FDB DA entry <DA Route> to be
*                                      set for UC routing
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_PARAM             - on wrong device number
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpVlanMrstBitmapSet function
* @endinternal
*
* @brief   Set the next-hop MRST state bitmap per eVLAN.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] vlanId                   - VLAN ID
* @param[in] mrstBmpPtr               - Pointer to Multicast
*       Routing Shared Tree ID 64 bit bitmap
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong input parameter
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS internal_cpssDxChIpVlanMrstBitmapSet
(
    IN  GT_U8                           devNum,
    IN  GT_U16                          vlanId,
    IN  GT_U64                          *mrstBmpPtr
)
{
    GT_STATUS rc;
    GT_U32    word;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_VLAN_INDEX_CHECK_MAC(devNum, vlanId);
    CPSS_NULL_PTR_CHECK_MAC(mrstBmpPtr);

    for (word = 0; word < 2; word++)
    {
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                             CPSS_DXCH_SIP5_TABLE_IPVX_EVLAN_E,
                                             vlanId,
                                             PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                             2+(word*32),
                                             32,
                                             mrstBmpPtr->l[word]);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChIpVlanMrstBitmapSet function
* @endinternal
*
* @brief   Set the next-hop MRST state bitmap per eVLAN.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] vlanId                   - VLAN ID
* @param[in] mrstBmpPtr               - pointer to Multicast
*       Routing Shared Tree ID 64 bit bitmap
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong input parameter
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpVlanMrstBitmapSet
(
    IN  GT_U8     devNum,
    IN  GT_U16    vlanId,
    IN  GT_U64    *mrstBmpPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpVlanMrstBitmapSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vlanId, mrstBmpPtr));

    rc = internal_cpssDxChIpVlanMrstBitmapSet(devNum, vlanId, mrstBmpPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vlanId, mrstBmpPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpVlanMrstBitmapGet function
* @endinternal
*
* @brief   Get the next-hop MRST state bitmap per eVLAN.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] vlanId                   - VLAN ID
*
* @param[out] mrstBmpPtr               - pointer to Multicast Routing Shared Tree ID 64 bit bitmap
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong input parameter
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS internal_cpssDxChIpVlanMrstBitmapGet
(
    IN  GT_U8     devNum,
    IN  GT_U16    vlanId,
    OUT GT_U64    *mrstBmpPtr
)
{
    GT_STATUS rc;
    GT_U32    word;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_VLAN_INDEX_CHECK_MAC(devNum, vlanId);
    CPSS_NULL_PTR_CHECK_MAC(mrstBmpPtr);

    for (word = 0; word < 2; word++)
    {
        rc = prvCpssDxChReadTableEntryField (devNum,
                                             CPSS_DXCH_SIP5_TABLE_IPVX_EVLAN_E,
                                             vlanId,
                                             PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                             2+(word*32),
                                             32,
                                             &mrstBmpPtr->l[word]);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChIpVlanMrstBitmapGet function
* @endinternal
*
* @brief   Get the next-hop MRST state bitmap per eVLAN.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] vlanId                   - VLAN ID
*
* @param[out] mrstBmpPtr               - pointer to Multicast Routing Shared Tree ID 64 bit bitmap
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_BAD_PARAM             - on wrong input parameter
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpVlanMrstBitmapGet
(
    IN  GT_U8     devNum,
    IN  GT_U16    vlanId,
    OUT GT_U64    *mrstBmpPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpVlanMrstBitmapGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vlanId, mrstBmpPtr));

    rc = internal_cpssDxChIpVlanMrstBitmapGet(devNum, vlanId, mrstBmpPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vlanId, mrstBmpPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpFcoeExceptionPacketCommandSet function
* @endinternal
*
* @brief   Set packet command of invalid FCoE packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] command                  -  to set
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
static GT_STATUS internal_cpssDxChIpFcoeExceptionPacketCommandSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PACKET_CMD_ENT                 command
)
{
    GT_U32      regAddr;
    GT_U32      value;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    PRV_CPSS_CONVERT_PACKET_CMD_TO_HW_VAL_MAC(value,command);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    return prvCpssHwPpSetRegField(devNum, regAddr, 5, 3, value);
}

/**
* @internal cpssDxChIpFcoeExceptionPacketCommandSet function
* @endinternal
*
* @brief   Set packet command of invalid FCoE packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] command                  -  to set
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
GT_STATUS cpssDxChIpFcoeExceptionPacketCommandSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PACKET_CMD_ENT                 command
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeExceptionPacketCommandSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, command));

    rc = internal_cpssDxChIpFcoeExceptionPacketCommandSet(devNum, command);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, command));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeExceptionPacketCommandGet function
* @endinternal
*
* @brief   Get packet command of invalid FCoE packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] commandPtr               - points to the command for invalid FCoE packets
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
static GT_STATUS internal_cpssDxChIpFcoeExceptionPacketCommandGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_PACKET_CMD_ENT                 *commandPtr
)
{
    GT_U32      regAddr;
    GT_U32      value;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(commandPtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 5, 3, &value);
    if (rc == GT_OK)
    {
        PRV_CPSS_CONVERT_HW_VAL_TO_PACKET_CMD_MAC(*commandPtr,value);
    }
    return rc;

}

/**
* @internal cpssDxChIpFcoeExceptionPacketCommandGet function
* @endinternal
*
* @brief   Get packet command of invalid FCoE packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] commandPtr               - points to the command for invalid FCoE packets
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
GT_STATUS cpssDxChIpFcoeExceptionPacketCommandGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_PACKET_CMD_ENT                 *commandPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeExceptionPacketCommandGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, commandPtr));

    rc = internal_cpssDxChIpFcoeExceptionPacketCommandGet(devNum, commandPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, commandPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeExceptionCpuCodeSet function
* @endinternal
*
* @brief   Set FCoE exception CPU code.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] cpuCode                  - If the FCoE exception packet command is TRAP, MIRROR or Drop
*                                      the CPU Code is determined by this field.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeExceptionCpuCodeSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_NET_RX_CPU_CODE_ENT            cpuCode
)
{
    PRV_CPSS_DXCH_NET_DSA_TAG_CPU_CODE_ENT dsaCpuCode;
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    rc = prvCpssDxChNetIfCpuToDsaCode(cpuCode, &dsaCpuCode);
    if (rc != GT_OK)
    {
        return rc;
    }

    rc = prvCpssHwPpSetRegField(devNum,
                                PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig,/* regAddr */
                                8,/* offset */
                                8,/* num of bits */
                                (GT_U32)dsaCpuCode);
    if (rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/**
* @internal cpssDxChIpFcoeExceptionCpuCodeSet function
* @endinternal
*
* @brief   Set FCoE exception CPU code.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
* @param[in] cpuCode                  - If the FCoE exception packet command is TRAP, MIRROR or Drop
*                                      the CPU Code is determined by this field.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeExceptionCpuCodeSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_NET_RX_CPU_CODE_ENT            cpuCode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeExceptionCpuCodeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cpuCode));

    rc = internal_cpssDxChIpFcoeExceptionCpuCodeSet(devNum, cpuCode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cpuCode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeExceptionCpuCodeGet function
* @endinternal
*
* @brief   Get FCoE exception CPU code.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] cpuCodePtr               - (points to) the CPU Code used if the FCoE exception
*                                      packet command is TRAP, MIRROR or Drop
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeExceptionCpuCodeGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_NET_RX_CPU_CODE_ENT            *cpuCodePtr
)
{
    GT_U32      value;
    GT_STATUS   rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(cpuCodePtr);

    rc = prvCpssHwPpGetRegField(devNum,
                                PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig,/* regAddr */
                                8,/* offset */
                                8,/* num of bits */
                                &value);
    if (rc != GT_OK)
    {
        return rc;
    }

    rc = prvCpssDxChNetIfDsaToCpuCode((PRV_CPSS_DXCH_NET_DSA_TAG_CPU_CODE_ENT)value,
                                      cpuCodePtr);
    if (rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/**
* @internal cpssDxChIpFcoeExceptionCpuCodeGet function
* @endinternal
*
* @brief   Get FCoE exception CPU code.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] cpuCodePtr               - (points to) the CPU Code used if the FCoE exception
*                                      packet command is TRAP, MIRROR or Drop
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeExceptionCpuCodeGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_NET_RX_CPU_CODE_ENT            *cpuCodePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeExceptionCpuCodeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cpuCodePtr));

    rc = internal_cpssDxChIpFcoeExceptionCpuCodeGet(devNum, cpuCodePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cpuCodePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeSoftDropRouterEnableSet function
* @endinternal
*
* @brief   When enabled, FCoE packets with a SOFT_DROP command can trigger FCoE Forwarding.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeSoftDropRouterEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{
    GT_U32      regAddr;
    GT_U32      hwData;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    hwData = ((enable == GT_TRUE) ? 1 : 0);

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, hwData);
}

/**
* @internal cpssDxChIpFcoeSoftDropRouterEnableSet function
* @endinternal
*
* @brief   When enabled, FCoE packets with a SOFT_DROP command can trigger FCoE Forwarding.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeSoftDropRouterEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeSoftDropRouterEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpFcoeSoftDropRouterEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeSoftDropRouterEnableGet function
* @endinternal
*
* @brief   Return if FCoE packets with a SOFT_DROP command can trigger FCoE Forwarding.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeSoftDropRouterEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 1, &hwData);
    if (rc == GT_OK)
    {
        *enablePtr = ((hwData == 1) ? GT_TRUE : GT_FALSE);
    }
    return rc;
}
/**
* @internal cpssDxChIpFcoeSoftDropRouterEnableGet function
* @endinternal
*
* @brief   Return if FCoE packets with a SOFT_DROP command can trigger FCoE Forwarding.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeSoftDropRouterEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeSoftDropRouterEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpFcoeSoftDropRouterEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeTrapRouterEnableSet function
* @endinternal
*
* @brief   When enabled, FCoE packets with a TRAP command can trigger FCoE Forwarding.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeTrapRouterEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{
    GT_U32      regAddr;
    GT_U32      hwData;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    hwData = ((enable == GT_TRUE) ? 1 : 0);

    return prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, hwData);
}
/**
* @internal cpssDxChIpFcoeTrapRouterEnableSet function
* @endinternal
*
* @brief   When enabled, FCoE packets with a TRAP command can trigger FCoE Forwarding.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeTrapRouterEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeTrapRouterEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpFcoeTrapRouterEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeTrapRouterEnableGet function
* @endinternal
*
* @brief   Return if FCoE packets with a TRAP command can trigger FCoE Forwarding.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeTrapRouterEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 1, 1, &hwData);
    if (rc == GT_OK)
    {
        *enablePtr = ((hwData == 1) ? GT_TRUE : GT_FALSE);
    }
    return rc;
}
/**
* @internal cpssDxChIpFcoeTrapRouterEnableGet function
* @endinternal
*
* @brief   Return if FCoE packets with a TRAP command can trigger FCoE Forwarding.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeTrapRouterEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeTrapRouterEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpFcoeTrapRouterEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeBridgedUrpfCheckEnableSet function
* @endinternal
*
* @brief   When enabled, Unicast RPF check is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedUrpfCheckEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{
    GT_U32      regAddr;
    GT_U32      hwData;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    hwData = ((enable == GT_TRUE) ? 1 : 0);

    return prvCpssHwPpSetRegField(devNum, regAddr, 2, 1, hwData);
}
/**
* @internal cpssDxChIpFcoeBridgedUrpfCheckEnableSet function
* @endinternal
*
* @brief   When enabled, Unicast RPF check is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeBridgedUrpfCheckEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedUrpfCheckEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpFcoeBridgedUrpfCheckEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeBridgedUrpfCheckEnableGet function
* @endinternal
*
* @brief   Return if Unicast RPF check is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedUrpfCheckEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 2, 1, &hwData);
    if (rc == GT_OK)
    {
        *enablePtr = ((hwData == 1) ? GT_TRUE : GT_FALSE);
    }
    return rc;
}
/**
* @internal cpssDxChIpFcoeBridgedUrpfCheckEnableGet function
* @endinternal
*
* @brief   Return if Unicast RPF check is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeBridgedUrpfCheckEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedUrpfCheckEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpFcoeBridgedUrpfCheckEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChIpFcoeBridgedUrpfCheckCommandSet function
* @endinternal
*
* @brief   Set packet command assigned to FCoE traffic that fails the UC RPF check.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] command                  -  to set
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedUrpfCheckCommandSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PACKET_CMD_ENT                 command
)
{
    GT_U32      regAddr;
    GT_U32      value;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    PRV_CPSS_CONVERT_PACKET_CMD_TO_HW_VAL_MAC(value,command);

    return prvCpssHwPpSetRegField(devNum, regAddr, 19, 3, value);
}
/**
* @internal cpssDxChIpFcoeBridgedUrpfCheckCommandSet function
* @endinternal
*
* @brief   Set packet command assigned to FCoE traffic that fails the UC RPF check.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] command                  -  to set
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
GT_STATUS cpssDxChIpFcoeBridgedUrpfCheckCommandSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PACKET_CMD_ENT                 command
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedUrpfCheckCommandSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, command));

    rc = internal_cpssDxChIpFcoeBridgedUrpfCheckCommandSet(devNum, command);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, command));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeBridgedUrpfCheckCommandGet function
* @endinternal
*
* @brief   Get packet command assigned to FCoE traffic that fails the UC RPF check.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] commandPtr               - points to the command for invalid FCoE packets
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedUrpfCheckCommandGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_PACKET_CMD_ENT                 *commandPtr
)
{
    GT_U32              regAddr;
    GT_U32              hwData;
    CPSS_PACKET_CMD_ENT command;
    GT_STATUS           rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(commandPtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 19, 3, &hwData);
    if (rc == GT_OK)
    {
        PRV_CPSS_CONVERT_HW_VAL_TO_PACKET_CMD_MAC(command,hwData);
        *commandPtr = command;
    }
    return rc;
}
/**
* @internal cpssDxChIpFcoeBridgedUrpfCheckCommandGet function
* @endinternal
*
* @brief   Get packet command assigned to FCoE traffic that fails the UC RPF check.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] commandPtr               - points to the command for invalid FCoE packets
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
GT_STATUS cpssDxChIpFcoeBridgedUrpfCheckCommandGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_PACKET_CMD_ENT                 *commandPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedUrpfCheckCommandGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, commandPtr));

    rc = internal_cpssDxChIpFcoeBridgedUrpfCheckCommandGet(devNum, commandPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, commandPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeUcRpfAccessLevelSet function
* @endinternal
*
* @brief   Set the SIP Access Level for FCoE Unicast packets where SIP is associated
*         with ECMP block, and Unicast RPF with ECMP is enabled.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] accessLevel              - SIP Access Level
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeUcRpfAccessLevelSet
(
    IN  GT_U8                               devNum,
    IN  GT_U32                              accessLevel
)
{
    GT_U32      regAddr;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    if (accessLevel >= BIT_6)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    return prvCpssHwPpSetRegField(devNum, regAddr, 23, 6, accessLevel);
}

/**
* @internal cpssDxChIpFcoeUcRpfAccessLevelSet function
* @endinternal
*
* @brief   Set the SIP Access Level for FCoE Unicast packets where SIP is associated
*         with ECMP block, and Unicast RPF with ECMP is enabled.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] accessLevel              - SIP Access Level
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeUcRpfAccessLevelSet
(
    IN  GT_U8                               devNum,
    IN  GT_U32                              accessLevel
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeUcRpfAccessLevelSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, accessLevel));

    rc = internal_cpssDxChIpFcoeUcRpfAccessLevelSet(devNum, accessLevel);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, accessLevel));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeUcRpfAccessLevelGet function
* @endinternal
*
* @brief   Get the SIP Access Level for FCoE Unicast packets where SIP is associated
*         with ECMP block, and Unicast RPF with ECMP is enabled.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] accessLevelPtr           - points to the SIP Access Level
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeUcRpfAccessLevelGet
(
    IN  GT_U8                               devNum,
    OUT GT_U32                              *accessLevelPtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(accessLevelPtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 23, 6, &hwData);
    if (rc == GT_OK)
    {
        *accessLevelPtr = hwData;
    }
    return rc;
}
/**
* @internal cpssDxChIpFcoeUcRpfAccessLevelGet function
* @endinternal
*
* @brief   Get the SIP Access Level for FCoE Unicast packets where SIP is associated
*         with ECMP block, and Unicast RPF with ECMP is enabled.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] accessLevelPtr           - points to the SIP Access Level
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeUcRpfAccessLevelGet
(
    IN  GT_U8                               devNum,
    OUT GT_U32                              *accessLevelPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeUcRpfAccessLevelGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, accessLevelPtr));

    rc = internal_cpssDxChIpFcoeUcRpfAccessLevelGet(devNum, accessLevelPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, accessLevelPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableSet function
* @endinternal
*
* @brief   When enabled, S_ID / SA mismatch check is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{
    GT_U32      regAddr;
    GT_U32      hwData;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    hwData = ((enable == GT_TRUE) ? 1 : 0);

    return prvCpssHwPpSetRegField(devNum, regAddr, 3, 1, hwData);
}

/**
* @internal cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableSet function
* @endinternal
*
* @brief   When enabled, S_ID / SA mismatch check is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableGet function
* @endinternal
*
* @brief   Return if S_ID / SA mismatch check is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 3, 1, &hwData);
    if (rc == GT_OK)
    {
        *enablePtr = ((hwData == 1) ? GT_TRUE : GT_FALSE);
    }
    return rc;
}
/**
* @internal cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableGet function
* @endinternal
*
* @brief   Return if S_ID / SA mismatch check is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpFcoeBridgedSidSaMismatchCheckEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeBridgedSidSaMismatchCommandSet function
* @endinternal
*
* @brief   Set packet command for S_ID/SA mismatch exception
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] command                  -  to set
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedSidSaMismatchCommandSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PACKET_CMD_ENT                 command
)
{
    GT_U32      regAddr;
    GT_U32      value;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    PRV_CPSS_CONVERT_PACKET_CMD_TO_HW_VAL_MAC(value,command);

    return prvCpssHwPpSetRegField(devNum, regAddr, 16, 3, value);
}
/**
* @internal cpssDxChIpFcoeBridgedSidSaMismatchCommandSet function
* @endinternal
*
* @brief   Set packet command for S_ID/SA mismatch exception
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] command                  -  to set
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
GT_STATUS cpssDxChIpFcoeBridgedSidSaMismatchCommandSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_PACKET_CMD_ENT                 command
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedSidSaMismatchCommandSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, command));

    rc = internal_cpssDxChIpFcoeBridgedSidSaMismatchCommandSet(devNum, command);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, command));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeBridgedSidSaMismatchCommandGet function
* @endinternal
*
* @brief   Get packet command for S_ID/SA exceptions.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] commandPtr               - points to the command for invalid FCoE packets
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedSidSaMismatchCommandGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_PACKET_CMD_ENT                 *commandPtr
)
{
    GT_U32              regAddr;
    GT_U32              hwData;
    CPSS_PACKET_CMD_ENT command;
    GT_STATUS           rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(commandPtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 16, 3, &hwData);
    if (rc == GT_OK)
    {
        PRV_CPSS_CONVERT_HW_VAL_TO_PACKET_CMD_MAC(command,hwData);
        *commandPtr = command;
    }
    return rc;
}
/**
* @internal cpssDxChIpFcoeBridgedSidSaMismatchCommandGet function
* @endinternal
*
* @brief   Get packet command for S_ID/SA exceptions.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - physical device number
*
* @param[out] commandPtr               - points to the command for invalid FCoE packets
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The commands are:
*       CPSS_PACKET_CMD_FORWARD_E
*       CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*       CPSS_PACKET_CMD_TRAP_TO_CPU_E
*       CPSS_PACKET_CMD_DROP_HARD_E
*       CPSS_PACKET_CMD_DROP_SOFT_E
*
*/
GT_STATUS cpssDxChIpFcoeBridgedSidSaMismatchCommandGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_PACKET_CMD_ENT                 *commandPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedSidSaMismatchCommandGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, commandPtr));

    rc =internal_cpssDxChIpFcoeBridgedSidSaMismatchCommandGet(devNum, commandPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, commandPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeBridgedSidFilterEnableSet function
* @endinternal
*
* @brief   When enabled, S_ID filtering is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedSidFilterEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{
    GT_U32      regAddr;
    GT_U32      hwData;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    hwData = ((enable == GT_TRUE) ? 1 : 0);

    return prvCpssHwPpSetRegField(devNum, regAddr, 4, 1, hwData);
}
/**
* @internal cpssDxChIpFcoeBridgedSidFilterEnableSet function
* @endinternal
*
* @brief   When enabled, S_ID filtering is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeBridgedSidFilterEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedSidFilterEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpFcoeBridgedSidFilterEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeBridgedSidFilterEnableGet function
* @endinternal
*
* @brief   Return if S_ID filtering is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedSidFilterEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 4, 1, &hwData);
    if (rc == GT_OK)
    {
        *enablePtr = ((hwData == 1) ? GT_TRUE : GT_FALSE);
    }
    return rc;
}
/**
* @internal cpssDxChIpFcoeBridgedSidFilterEnableGet function
* @endinternal
*
* @brief   Return if S_ID filtering is performed for Bridged FCoE traffic.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeBridgedSidFilterEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedSidFilterEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpFcoeBridgedSidFilterEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}
/**
* @internal internal_cpssDxChIpFcoeBridgedHeaderErrorCheckEnableSet function
* @endinternal
*
* @brief   When enabled, FCoE header error checking is performed
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedHeaderErrorCheckEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{

    GT_U32      regAddr;
    GT_U32      hwData;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    hwData = ((enable == GT_TRUE) ? 1 : 0);

    return prvCpssHwPpSetRegField(devNum, regAddr, 22, 1, hwData);
}
/**
* @internal cpssDxChIpFcoeBridgedHeaderErrorCheckEnableSet function
* @endinternal
*
* @brief   When enabled, FCoE header error checking is performed
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeBridgedHeaderErrorCheckEnableSet
(
    IN GT_U8        devNum,
    IN GT_BOOL      enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedHeaderErrorCheckEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpFcoeBridgedHeaderErrorCheckEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFcoeBridgedHeaderErrorCheckEnableGet function
* @endinternal
*
* @brief   Return if FCoE header error checking is performed,
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFcoeBridgedHeaderErrorCheckEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FCoEGlobalCtrl.routerFCoEGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 22, 1, &hwData);
    if (rc == GT_OK)
    {
        *enablePtr = ((hwData == 1) ? GT_TRUE : GT_FALSE);
    }
    return rc;
}
/**
* @internal cpssDxChIpFcoeBridgedHeaderErrorCheckEnableGet function
* @endinternal
*
* @brief   Return if FCoE header error checking is performed,
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFcoeBridgedHeaderErrorCheckEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFcoeBridgedHeaderErrorCheckEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpFcoeBridgedHeaderErrorCheckEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFdbRoutePrefixLenSet function
* @endinternal
*
* @brief   set the IPv4/6 prefix length when accessing the FDB
*          table for IPv4/6 Route lookup
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] protocolStack            - the type of protocol
* @param[in] prefixLen                - FDB lookup prefix length.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFdbRoutePrefixLenSet
(
    IN GT_U8                        devNum,
    IN CPSS_IP_PROTOCOL_STACK_ENT   protocolStack,
    IN GT_U32                       prefixLen
)
{
    GT_STATUS rc = GT_OK;   /* Return value */
    GT_U32 regAddr;         /* Register address */
    GT_U32 value;           /* Register value */
    GT_U32 wordItr;         /* Word iterator */
    GT_U32 wordPrefix;      /* Number of set bits in mask word */
    GT_U32 numPrefixWords;  /* Number of mask words that contain set bits */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_SIP6_SUPPORTED_CHECK_MAC(devNum);

    switch(protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
            if (prefixLen > 32)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "prefixLen must be in range[0..32]");
            }
            else
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FdbIpLookup.FdbIpv4RouteLookupMask;
                if (prefixLen < 32)
                    value = ((1 << (prefixLen)) - 1) << (32 - prefixLen);
                else
                    value = 0xFFFFFFFF;
                /* Write FDB lookup mask to register */
                return prvCpssHwPpWriteRegister(devNum, regAddr, value);
            }
            break;
        case CPSS_IP_PROTOCOL_IPV6_E:
            if (prefixLen > 128)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "prefixLen must be in range[0..128]");
            }
            else
            {
                numPrefixWords = prefixLen/32;
                if (prefixLen % 32)
                {
                    numPrefixWords++;
                }
                /* Write mask value for 4 register */
                for (wordItr = 0; wordItr < 4; wordItr++)
                {
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FdbIpLookup.FdbIpv6RouteLookupMask[3-wordItr];
                    if (numPrefixWords == (wordItr + 1))
                    {
                        wordPrefix = prefixLen % 32;
                        if (wordPrefix != 0)
                            value = ((1 << (wordPrefix)) - 1) << (32 - wordPrefix);
                        else
                            value = 0xFFFFFFFF;
                    }
                    else if (numPrefixWords > wordItr)
                    {
                        value = 0xFFFFFFFF;
                    }
                    else
                    {
                        value = 0;
                    }
                    rc = prvCpssHwPpWriteRegister(devNum, regAddr, value);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @internal cpssDxChIpFdbRoutePrefixLenSet function
* @endinternal
*
* @brief   set the IPv4/6 prefix length when accessing the FDB
*          table for IPv4/6 Route lookup
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] protocolStack            - the type of protocol
* @param[in] prefixLen                - FDB lookup prefix length.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFdbRoutePrefixLenSet
(
    IN GT_U8                        devNum,
    IN CPSS_IP_PROTOCOL_STACK_ENT   protocolStack,
    IN GT_U32                       prefixLen
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFdbRoutePrefixLenSet);

    CPSS_API_LOCK_MAC(devNum, PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, protocolStack, prefixLen));

    rc = internal_cpssDxChIpFdbRoutePrefixLenSet(devNum, protocolStack, prefixLen);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, protocolStack, prefixLen));
    CPSS_API_UNLOCK_MAC(devNum, PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFdbRoutePrefixLenGet function
* @endinternal
*
* @brief   Get the IPv4/6 prefix length when accessing the FDB
*          table for IPv4/6 Route lookup
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] protocolStack            - the type of protocol
*
* @param[out] prefixLenPtr            - (pointer to) FDB lookup prefix length.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_BAD_VALUE             - on bad output value
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChIpFdbRoutePrefixLenGet
(
    IN GT_U8                        devNum,
    IN CPSS_IP_PROTOCOL_STACK_ENT   protocolStack,
    OUT GT_U32                      *prefixLenPtr
)
{
    GT_STATUS rc = GT_OK;
    GT_U32 regAddr;
    GT_U32 value;
    GT_32 wordItr;
    GT_U32 prefixLen = 0;
    GT_U32 prefixLenPrev;
    GT_U32 tmpValue;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_SIP6_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(prefixLenPtr);

    switch(protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
                regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FdbIpLookup.FdbIpv4RouteLookupMask;
                rc =  prvCpssHwPpReadRegister(devNum, regAddr, &value);
                if (rc != GT_OK)
                {
                    return rc;
                }
                /* Check if mask has '0' holes */
                tmpValue = ~value;
                if (tmpValue & (tmpValue + 1))
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_VALUE, "Wrong IPv4 Lookup Mask value");
                }
                /* Calculating prefix length using "Hamming Weight" */
                tmpValue = value;
                tmpValue = tmpValue - ((tmpValue >> 1) & 0x55555555);
                tmpValue = (tmpValue & 0x33333333) + ((tmpValue >> 2) & 0x33333333);
                prefixLen = (((tmpValue + (tmpValue >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
            break;
        case CPSS_IP_PROTOCOL_IPV6_E:
            prefixLen = 0;
            prefixLenPrev = 0;
            for (wordItr = 0; wordItr < 4; wordItr++)
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FdbIpLookup.FdbIpv6RouteLookupMask[wordItr];
                rc = prvCpssHwPpReadRegister(devNum, regAddr, &value);
                if (rc != GT_OK)
                {
                    return rc;
                }
                /* Check if mask has '0' holes */
                tmpValue = ~value;
                if (tmpValue & (tmpValue + 1))
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_VALUE, "Wrong IPv6 Lookup Mask value");
                }
                prefixLenPrev = prefixLen;
                /* Calculating number of set bits using "Hamming Weight" */
                tmpValue = value;
                tmpValue = tmpValue - ((tmpValue >> 1) & 0x55555555);
                tmpValue = (tmpValue & 0x33333333) + ((tmpValue >> 2) & 0x33333333);
                prefixLen +=  (((tmpValue + (tmpValue >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
                if (prefixLenPrev > 0 && (prefixLen - prefixLenPrev) != 32)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_VALUE, "Wrong IPv6 Lookup Mask value");
                }
            }
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    *prefixLenPtr = prefixLen;

    return rc;
}

/**
* @internal cpssDxChIpFdbRoutePrefixLenGet function
* @endinternal
*
* @brief   Get the IPv4/6 prefix length when accessing the FDB
*          table for IPv4/6 Route lookup
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] protocolStack            - the type of protocol
*
* @param[out] prefixLenPtr            - (pointer to) FDB lookup prefix length.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_BAD_VALUE             - on bad output value
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChIpFdbRoutePrefixLenGet
(
    IN GT_U8                        devNum,
    IN CPSS_IP_PROTOCOL_STACK_ENT   protocolStack,
    OUT GT_U32                      *prefixLenPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFdbRoutePrefixLenGet);

    CPSS_API_LOCK_MAC(devNum, PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, protocolStack, prefixLenPtr));

    rc = internal_cpssDxChIpFdbRoutePrefixLenGet(devNum, protocolStack, prefixLenPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, protocolStack, prefixLenPtr));
    CPSS_API_UNLOCK_MAC(devNum, PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFdbUnicastRouteForPbrEnableSet function
* @endinternal
*
* @brief   Enable/Disable FDB Unicast routing for PBR (Policy Based
*          Routed) packets
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable FDB
*                                       routing for PBR packets
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong devNum parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This is useful for overriding the PBR forwarding
*    decision by a matching FDB Route entry.
*/
GT_STATUS internal_cpssDxChIpFdbUnicastRouteForPbrEnableSet
(
    IN GT_U8                        devNum,
    IN GT_BOOL                      enable
)
{
    GT_U32      regAddr;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_DXCH_PP_HW_INFO_SIP6_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FdbRouteLookup.FdbHostLookup;

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, (enable == GT_TRUE) ? 1 : 0);
}

/**
* @internal cpssDxChIpFdbUnicastRouteForPbrEnableSet function
* @endinternal
*
* @brief   Enable/Disable FDB Unicast routing for PBR (Policy Based
*          Routed) packets
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable FDB
*                                       routing for PBR packets
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong devNum parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This is useful for overriding the PBR forwarding
*    decision by a matching FDB Route entry.
*/
GT_STATUS cpssDxChIpFdbUnicastRouteForPbrEnableSet
(
    IN GT_U8                        devNum,
    IN GT_BOOL                      enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFdbUnicastRouteForPbrEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpFdbUnicastRouteForPbrEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFdbUnicastRouteForPbrEnableGet function
* @endinternal
*
* @brief   Return if FDB Unicast routing for PBR value (Policy Based
*          Routed) packets is enabled
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[out] enablePtr               - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong devNum parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This is useful for overriding the PBR forwarding
*    decision by a matching FDB Route entry.
*/
GT_STATUS internal_cpssDxChIpFdbUnicastRouteForPbrEnableGet
(
    IN GT_U8                        devNum,
    OUT GT_BOOL                     *enablePtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_DXCH_PP_HW_INFO_SIP6_SUPPORTED_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FdbRouteLookup.FdbHostLookup;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 1, &hwData);
    if (rc == GT_OK)
    {
        *enablePtr = ((hwData == 1) ? GT_TRUE : GT_FALSE);
    }
    return rc;
}

/**
* @internal cpssDxChIpFdbUnicastRouteForPbrEnableGet function
* @endinternal
*
* @brief   Return if FDB Unicast routing for PBR value (Policy Based
*          Routed) packets is enabled
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[out] enablePtr               - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong devNum parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This is useful for overriding the PBR forwarding
*    decision by a matching FDB Route entry.
*/
GT_STATUS cpssDxChIpFdbUnicastRouteForPbrEnableGet
(
    IN GT_U8                        devNum,
    OUT GT_BOOL                     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFdbUnicastRouteForPbrEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpFdbUnicastRouteForPbrEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFdbMulticastRouteForPbrEnableSet function
* @endinternal
*
* @brief   Enable/Disable FDB Multicast routing for PBR (Policy Based
*          Routed) packets
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable FDB
*                                       routing for PBR packets
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong devNum parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This is useful for overriding the PBR forwarding
*    decision by a matching FDB Route entry.
*/
GT_STATUS internal_cpssDxChIpFdbMulticastRouteForPbrEnableSet
(
    IN GT_U8                        devNum,
    IN GT_BOOL                      enable
)
{
    GT_U32      regAddr;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum) == GT_FALSE)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FdbRouteLookup.FdbHostLookup;

    return prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, (enable == GT_TRUE) ? 1 : 0);
}

/**
* @internal cpssDxChIpFdbMulticastRouteForPbrEnableSet function
* @endinternal
*
* @brief   Enable/Disable FDB Multicast routing for PBR (Policy Based
*          Routed) packets
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - enable/disable FDB
*                                       routing for PBR packets
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong devNum parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This is useful for overriding the PBR forwarding
*    decision by a matching FDB Route entry.
*/
GT_STATUS cpssDxChIpFdbMulticastRouteForPbrEnableSet
(
    IN GT_U8                        devNum,
    IN GT_BOOL                      enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFdbMulticastRouteForPbrEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpFdbMulticastRouteForPbrEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpFdbMulticastRouteForPbrEnableGet function
* @endinternal
*
* @brief   Return if FDB Multicast routing for PBR value (Policy Based
*          Routed) packets is enabled
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[out] enablePtr               - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong devNum parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This is useful for overriding the PBR forwarding
*    decision by a matching FDB Route entry.
*/
GT_STATUS internal_cpssDxChIpFdbMulticastRouteForPbrEnableGet
(
    IN GT_U8                        devNum,
    OUT GT_BOOL                     *enablePtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum) == GT_FALSE)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.FdbRouteLookup.FdbHostLookup;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 1, 1, &hwData);
    if (rc == GT_OK)
    {
        *enablePtr = ((hwData == 1) ? GT_TRUE : GT_FALSE);
    }
    return rc;
}

/**
* @internal cpssDxChIpFdbMulticastRouteForPbrEnableGet function
* @endinternal
*
* @brief   Return if FDB Multicast routing for PBR value (Policy Based
*          Routed) packets is enabled
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2;
*          Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[out] enablePtr               - (pointer to) enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong devNum parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This is useful for overriding the PBR forwarding
*    decision by a matching FDB Route entry.
*/
GT_STATUS cpssDxChIpFdbMulticastRouteForPbrEnableGet
(
    IN GT_U8                        devNum,
    OUT GT_BOOL                     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFdbMulticastRouteForPbrEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpFdbMulticastRouteForPbrEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpNhMuxModeSet function
* @endinternal
*
* @brief   globally set the next hop muxing mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2;
*
* @param[in] devNum             - the device number
* @param[in] muxMode            - the next hop muxing mode to set
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong devNum
*/
static GT_STATUS internal_cpssDxChIpNhMuxModeSet
(
    IN GT_U8    devNum,
    IN CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_ENT  muxMode
)
{
    GT_U32 regAddr;
    GT_U32  value = 0;
    GT_U32  bitLen = 1;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
        bitLen = 2;

    switch(muxMode)
    {
        case CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_QOS_E:
        value = 0;
        break;

        case CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_VID1_E:
        value = 1;
        break;

        case CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_TRG_EPG_FOR_UC_E:
        if (0 == PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_ONE_PARAM_FORMAT_MAC(devNum));
        }
        value = 2;
        break;

        case CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_TRG_EPG_FOR_UC_MC_E:
        if (0 == PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_ONE_PARAM_FORMAT_MAC(devNum));
        }
        value = 3;
        break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        break;
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;

    return prvCpssHwPpSetRegField(devNum, regAddr, 7, bitLen, value);
}
/**
* @internal cpssDxChIpNhMuxModeSet function
* @endinternal
*
* @brief   globally set the next hop muxing mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2;
*
* @param[in] devNum             - the device number
* @param[in] muxMode            - the next hop muxing mode to set
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong devNum
*/
GT_STATUS cpssDxChIpNhMuxModeSet
(
    IN GT_U8    devNum,
    IN CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_ENT  muxMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpNhMuxModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, muxMode));

    rc = internal_cpssDxChIpNhMuxModeSet(devNum, muxMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, muxMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChIpNhMuxModeGet function
* @endinternal
*
* @brief   globally get the next hop muxing mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2;
*
* @param[in] devNum             - the device number
* @param[out] muxModePtr        - (pointer to) the next hop muxing mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*/
static GT_STATUS internal_cpssDxChIpNhMuxModeGet
(
    IN GT_U8    devNum,
    OUT CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_ENT  *muxModePtr
)
{
    GT_U32 regAddr;
    GT_STATUS rc;
    GT_U32  value;
    GT_U32  bitLen = 1;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);
    CPSS_NULL_PTR_CHECK_MAC(muxModePtr);

    if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
        bitLen = 2;

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 7, bitLen, &value);
    if (rc != GT_OK)
    {
        return rc;
    }
    switch(value)
    {
        case 0:
            *muxModePtr = CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_QOS_E;
            break;
        case 1:
            *muxModePtr = CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_VID1_E;
            break;
        case 2:
            *muxModePtr = CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_TRG_EPG_FOR_UC_E;
            break;
        case 3:
            *muxModePtr = CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_TRG_EPG_FOR_UC_MC_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }
    return rc;
}

/**
* @internal cpssDxChIpNhMuxModeGet function
* @endinternal
*
* @brief   globally get the next hop muxing mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2;
*
* @param[in] devNum             - the device number
* @param[out] muxModePtr        - (pointer to) the next hop muxing mode
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*/
GT_STATUS cpssDxChIpNhMuxModeGet
(
    IN GT_U8    devNum,
    OUT CPSS_DXCH_IP_NEXT_HOP_MUX_MODE_ENT  *muxModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpNhMuxModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, muxModePtr));

    rc = internal_cpssDxChIpNhMuxModeGet(devNum, muxModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, muxModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
*/
/**
********************************************************************************
* @file cpssDxChHwInit.c
*
* @brief Includes CPSS DXCH level basic Hw initialization functions.
*
* @version   444
********************************************************************************
*/
/* use cpssSharedGlobalVarsPtr->mainPpDrvMod.dxChCpssHwInit.dxCh_prvCpssPpConfig[dev]  :
   for debugging MACRO PRV_CPSS_DXCH_PP_MAC(dev)*/
#define CPSS_LOG_IN_MODULE_ENABLE

#include <cpss/dxCh/dxChxGen/diag/cpssDxChDiagDataIntegrityTables.h>
#include <cpss/generic/cos/cpssCosTypes.h>
#include <cpss/generic/cpssHwInit/cpssHwInit.h>
#include <cpss/dxCh/dxChxGen/pha/private/prvCpssDxChPha.h>
#include <cpss/generic/config/private/prvCpssConfigTypes.h>
#include <cpss/generic/private/prvCpssCommonDefs.h>
#include <cpss/generic/tm/prvCpssTmCtl.h>

#include <cpss/driver/interrupts/cpssDrvComIntEvReqQueues.h>
#include <cpss/driver/interrupts/cpssDrvComIntSvcRtn.h>

#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChInfo.h>
#include <cpss/dxCh/dxChxGen/config/cpssDxChCfgInit.h>
#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChModuleConfig.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/cpssDxChHwInit.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChHwInitSoftReset.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChHwInit.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChHwTables.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChHwInitLedCtrl.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChHwInitGlobal2localDma.h>
#include <cpss/dxCh/dxChxGen/networkIf/cpssDxChNetIf.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChCpssHwInitLog.h>

#include <cpss/dxCh/dxChxGen/port/cpssDxChPortCtrl.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortBufMg.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortTx.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortStat.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortPfc.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortPip.h>
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortCtrl.h>
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortIfModeCfgResource.h>
#include <cpss/dxCh/dxChxGen/port/PizzaArbiter/cpssDxChPortPizzaArbiter.h>
#include <cpss/dxCh/dxChxGen/port/PizzaArbiter/DynamicPizzaArbiter/prvCpssDxChPortTxQHighSpeedPortsDrv.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortCn.h>
#include <cpss/dxCh/dxChxGen/port/PizzaArbiter/DynamicPizzaArbiter/prvCpssDxChPortDynamicPizzaArbiterWS.h>
#include <cpss/dxCh/dxChxGen/port/PizzaArbiter/DynamicPizzaArbiter/cpssDxChPortDynamicPizzaArbiterWorkConserving.h>

#include <cpss/dxCh/dxChxGen/systemRecovery/hsu/private/prvCpssDxChHsu.h>
#include <cpss/dxCh/dxChxGen/systemRecovery/catchUp/private/prvCpssDxChCatchUp.h>

#include <cpss/dxCh/dxChxGen/policer/cpssDxChPolicer.h>

#include <cpss/dxCh/dxChxGen/diag/cpssDxChDiag.h>
#include <cpss/dxCh/dxChxGen/diag/private/prvCpssDxChDiag.h>
#include <cpss/dxCh/dxChxGen/diag/cpssDxChDiagDataIntegrity.h>
#include <cpss/dxCh/dxChxGen/diag/private/prvCpssDxChDiagDataIntegrityMainMappingDb.h>
#include <cpss/dxCh/dxChxGen/diag/cpssDxChDiagPacketGenerator.h>

#include <cpss/dxCh/dxChxGen/trunk/private/prvCpssDxChTrunk.h>
#include <cpss/dxCh/dxChxGen/pcl/private/prvCpssDxChPcl.h>

#include <cpss/dxCh/dxChxGen/private/routerTunnelTermTcam/prvCpssDxChRouterTunnelTermTcam.h>
#include <cpss/dxCh/dxChxGen/bridge/private/prvCpssDxChBrg.h>
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgE2Phy.h>
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgL2Dlb.h>

#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgFdb.h>
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgGen.h>
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgMc.h>
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgL2Ecmp.h>
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgSecurityBreach.h>
#include <cpss/dxCh/dxChxGen/tunnel/cpssDxChTunnel.h>
#include <cpss/dxCh/dxChxGen/tti/cpssDxChTti.h>
#include <cpss/dxCh/dxChxGen/nst/cpssDxChNstPortIsolation.h>
#include <cpss/dxCh/dxChxGen/nst/cpssDxChNst.h>
#include <cpss/dxCh/dxChxGen/mirror/cpssDxChMirror.h>
#include <cpss/dxCh/dxChxGen/cnc/cpssDxChCnc.h>
#include <cpss/dxCh/dxChxGen/cos/private/prvCpssDxChCoS.h>
#include <cpss/dxCh/dxChxGen/ip/cpssDxChIpCtrl.h>
#include <cpss/dxCh/dxChxGen/cscd/cpssDxChCscd.h>
#include <cpss/dxCh/dxChxGen/cscd/private/prvCpssDxChCscd.h>
#include <cpss/dxCh/dxChxGen/ptp/cpssDxChPtp.h>
#include <cpss/dxCh/dxChxGen/l2mll/cpssDxChL2Mll.h>
#include <cpss/dxCh/dxChxGen/phy/cpssDxChPhySmi.h>
#include <cpss/dxCh/dxChxGen/phy/prvCpssDxChSmiUnitDrv.h>
#include <cpss/dxCh/dxChxGen/phy/private/prvCpssDxChPhySmi.h>
#include <cpss/dxCh/dxChxGen/ip/private/prvCpssDxChIp.h>
#include <cpss/dxCh/dxChxGen/ip/cpssDxChIp.h>
#include <cpss/common/smi/cpssGenSmi.h>
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgSrcId.h> /* for cpssDxChBrgSrcIdAddTag1LocationSet */
#include <cpss/dxCh/dxChxGen/stream/cpssDxChStream.h> /* for cpssDxChStreamSrfDaemonInfoSet */

#include <cpss/dxCh/dxChxGen/tmGlue/private/prvCpssDxChTmGlue.h>
#include <cpss/dxCh/dxChxGen/cutThrough/private/prvCpssDxChCutThrough.h>
#include <cpss/dxCh/dxChxGen/cutThrough/cpssDxChCutThrough.h>

#include <cpssDriver/pp/config/prvCpssDrvPpCfgInit.h>
#include <cpssDriver/pp/interrupts/generic/prvCpssDrvInterruptsInit.h>
#include <cpssDriver/pp/interrupts/generic/prvCpssDrvInterrupts.h>
#include <cpssDriver/pp/interrupts/dxExMx/prvCpssDrvDxChEventsXcat3.h>
#include <cpssDriver/pp/interrupts/dxExMx/prvCpssDrvDxChEventsLion2.h>
#include <cpssDriver/pp/interrupts/dxExMx/prvCpssDrvDxChEventsAlleyCat5.h>
#include <cpssDriver/pp/prvCpssDrvPpDefs.h>
#include <cpssDriver/pp/prvCpssDrvErrataMng.h>


#include <cpss/common/labServices/port/gop/port/pcs/mvHwsPcsIf.h>
#include <cpss/common/labServices/port/gop/port/mvPortModeElements.h>
#include <cpss/extServices/private/prvCpssBindFunc.h>

#include <cpss/common/srvCpu/prvCpssGenericSrvCpuLoad.h>
#include <cpss/common/port/private/prvCpssPortManager.h>
#include <cpss/common/private/prvCpssCyclicLogger.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChHwRegAddrVer1_ppDb.h>

#include <cpss/dxCh/dxChxGen/port/cpssDxChPortTxDba.h>
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortTxDba.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortPacketBuffer.h>
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortPacketBuffer.h>
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortTxPizzaResourceFalcon.h>
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortTxPizzaResourceHawk.h>
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortDpIronman.h>
#include <cpss/dxCh/dxChxGen/txq/private/units/prvCpssDxChTxqPfcc.h>
#include <cpssDriver/pp/interrupts/dxExMx/prvCpssDrvDxExMxInterrupts.h>
#include <cpss/dxCh/dxChxGen/ptp/private/prvCpssDxChPtp.h>
#include <cpss/dxCh/dxChxGen/packetAnalyzer/private/prvCpssDxChPacketAnalyzer.h>
#include <cpss/dxCh/dxChxGen/lpm/cpssDxChLpm.h>
#include <cpss/dxCh/dxChxGen/ipfix/cpssDxChIpfix.h>
#include <cpss/dxCh/dxChxGen/systemRecovery/hitlessStartup/cpssDxChHitlessStartup.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDb.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDbInterface.h>

#define DXCH_HWINIT_GLOVAR(_x) PRV_SHARED_GLOBAL_VAR_GET(mainPpDrvMod.dxChCpssHwInit._x)
#define HWINIT_GLOVAR(_var) \
    PRV_SHARED_GLOBAL_VAR_GET(commonMod.genericHwInitDir._var)

/* debug flag for Falcon WA for 'port delete' of part 'channel_reset_part' */
extern const GT_U32 prvFalconPortDeleteWa_disabled_channel_reset_part;

#if (!(defined ASIC_SIMULATION_ENV_FORBIDDEN) && defined ASIC_SIMULATION)
    /* need to run with simulation lib exists */
    #define WM_IMPLEMENTED
#endif

static GT_STATUS hwPpSip5StartInitSet
(
    IN  GT_U8               devNum,
    IN  GT_BOOL             ignoreInitDone
);

static GT_VOID prvCpssDxChFalconRavenBitmapSet
(
    IN GT_U8   devNum
);

#define NUM_OF_TAI_IN_HAWK  34
#define NUM_OF_TAI_IN_PHOENIX 21

/* Array of units that not generated interrupts */
static const PRV_CPSS_DXCH_UNIT_ENT prvCpssDxChNoInterruptsGenerationUnits[]={
        PRV_CPSS_DXCH_UNIT_GOP_E,
        PRV_CPSS_DXCH_UNIT_MIB_E,
        PRV_CPSS_DXCH_UNIT_SERDES_E,
        PRV_CPSS_DXCH_UNIT_ILKN_E,
        PRV_CPSS_DXCH_UNIT_LMS0_0_E,
        PRV_CPSS_DXCH_UNIT_LMS0_1_E,
        PRV_CPSS_DXCH_UNIT_LMS0_2_E,
        PRV_CPSS_DXCH_UNIT_LMS0_3_E,
        PRV_CPSS_DXCH_UNIT_LMS1_0_E,
        PRV_CPSS_DXCH_UNIT_LMS1_1_E,
        PRV_CPSS_DXCH_UNIT_LMS1_2_E,
        PRV_CPSS_DXCH_UNIT_LMS1_3_E,
        PRV_CPSS_DXCH_UNIT_LMS2_0_E,
        PRV_CPSS_DXCH_UNIT_LMS2_1_E,
        PRV_CPSS_DXCH_UNIT_LMS2_2_E,
        PRV_CPSS_DXCH_UNIT_LMS2_3_E,
        PRV_CPSS_DXCH_UNIT_CNC_0_E,
        PRV_CPSS_DXCH_UNIT_CNC_1_E,
        /* There is no more LMS unit starting from Bobcat2 B0. LMS was split to SMI , LED units */
        PRV_CPSS_DXCH_UNIT_SMI_0_E,
        PRV_CPSS_DXCH_UNIT_SMI_1_E,
        PRV_CPSS_DXCH_UNIT_SMI_2_E,
        PRV_CPSS_DXCH_UNIT_SMI_3_E,
        PRV_CPSS_DXCH_UNIT_LED_0_E,
        PRV_CPSS_DXCH_UNIT_LED_1_E,
        PRV_CPSS_DXCH_UNIT_LED_2_E,
        PRV_CPSS_DXCH_UNIT_LED_3_E,
        PRV_CPSS_DXCH_UNIT_LED_4_E
#ifndef ASIC_SIMULATION
        /* There is no interrupt generation in MTI unit */
        /* but in WM simulation ... allow to check the tree of CPSS and of WM ! */
        ,PRV_CPSS_DXCH_UNIT_BASE_RAVEN_0_E
        ,PRV_CPSS_DXCH_UNIT_BASE_RAVEN_1_E
        ,PRV_CPSS_DXCH_UNIT_BASE_RAVEN_2_E
        ,PRV_CPSS_DXCH_UNIT_BASE_RAVEN_3_E
#endif  /*ASIC_SIMULATION*/
};

#define PRV_SIP6_DEFAULT_POOL_CNS 0

extern void hwsChange1GSpeedCfgV43(void);

#define SWAP(X,Y) { GT_U32 T = X; X = Y; Y = T; }

#ifdef ASIC_SIMULATION
    #define DEBUG_OPENED
#endif /*ASIC_SIMULATION*/

#ifdef DEBUG_OPENED
    #ifdef STR
        #undef STR
    #endif /*STR*/

    #define STR(strname)    \
        #strname

    #define ERRATA_NAMES                                                                 \
    STR(PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E),                          \
    STR(PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E),                  \
    STR(PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E),                              \
    STR(PRV_CPSS_DXCH3_VLT_TABLES_WRITE_DIRECT_ACCESS_WA_E),                            \
    STR(PRV_CPSS_DXCH3_RM_BM_GE_XG_PORT_GROUP_LIMIT_CFG_REG_WA_E),                      \
    STR(PRV_CPSS_DXCH3_RM_GE_PORTS_MODE1_REG_WA_E),                                     \
    STR(PRV_CPSS_DXCH3_RM_XG_PORTS_MODE_REG_WA_E),                                      \
    STR(PRV_CPSS_DXCH3_RM_LMS0_1_GROUP1_LED_INTERFACE_WA_E),                            \
    STR(PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E),                         \
    STR(PRV_CPSS_DXCH3_TXQ_PARITY_CALCULATION_E),                                       \
    STR(PRV_CPSS_DXCH3_SDMA_WA_E),                                                      \
    STR(PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E),                               \
    STR(PRV_CPSS_DXCH3_TXQ_FULL_INTERRUPT_NOT_FUNCTION_WA_E),                           \
    STR(PRV_CPSS_DXCH3_POLICY_AND_ROUTER_TCAM_TABLES_INDIRECT_READ_WA_E),               \
    STR(PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E),                                     \
    STR(PRV_CPSS_DXCH3_LIMITED_NUMBER_OF_POLICY_BASED_ROUTES_WA_E),                     \
    STR(PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E),                        \
    STR(PRV_CPSS_DXCH_XCAT_RM_TOTAL_BUFFER_LIMIT_CONF_IN_TXQ_E),                        \
    STR(PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E),                                   \
    STR(PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E),                                   \
    STR(PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E),              \
    STR(PRV_CPSS_DXCH_XCAT_RM_POLICY_ENGINE_CONFIGURATION_REGISTER_WA_E),               \
    STR(PRV_CPSS_DXCH_XCAT_RM_TXQ_DEQUEUE_SWRR_WEIGHT_REGISTER_3_WA_E),                 \
    STR(PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E),                           \
    STR(PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E),                           \
    STR(PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E),                                   \
    STR(PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E),                \
    STR(PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E),                                        \
    STR(PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E),                          \
    STR(PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E),                      \
    STR(PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E),                         \
    STR(PRV_CPSS_DXCH_XCAT_RM_PORT_SERIAL_PARAMETERS_CONFIGURATION_WA_E),               \
    STR(PRV_CPSS_DXCH_XCAT_RM_LMS0_LMS1_MISC_CONFIGURATIONS_WA_E),                      \
    STR(PRV_CPSS_DXCH_XCAT_TX_CPU_CORRUPT_BUFFER_WA_E),                                 \
    STR(PRV_CPSS_DXCH_XCAT_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E),                        \
    STR(PRV_CPSS_DXCH_XCAT_IEEE_RESERVED_MC_CONFG_REG_READ_WA_E),                       \
    STR(PRV_CPSS_DXCH_XCAT_RM_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E),                     \
    STR(PRV_CPSS_DXCH_XCAT_GIGA_PORT_PRBS_PARAM_INIT_WA_E),                             \
    STR(PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E),                          \
    STR(PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E),    \
    STR(PRV_CPSS_DXCH_XCAT_TOD_NANO_SEC_SET_WA_E),                                      \
    STR(PRV_CPSS_DXCH_XCAT_ETH_OVER_IPV4_GRE_WA_E),                                     \
    STR(PRV_CPSS_DXCH_XCAT_PASSENGER_ETH_PACKET_CRC_CANT_BE_RETAINED_WA_E),             \
    STR(PRV_CPSS_DXCH_XCAT_RM_MAC_CTRL_REG3_PCS_PREAMBLE_WA_E),                         \
    STR(PRV_CPSS_DXCH_XCAT_RM_METAL_FIX_SGMII25G_DPCLK_SEL_WA_E),                       \
    STR(PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_CCFC_SRC_PORT_WA_E),                          \
    STR(PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E),                                       \
    STR(PRV_CPSS_DXCH_XCAT_FC_FORWARD_NOT_FUNCTIONAL_WA_E),                             \
    STR(PRV_CPSS_DXCH_XCAT_RM_SSMII_PAD_ZNR_ZPR_WA_E),                                  \
    STR(PRV_CPSS_DXCH_XCAT_RM_PASSENGER_TPID_REG_WA_E),                                 \
                                                                                        \
    STR(PRV_CPSS_DXCH_LION_RM_SDMA_ACTIVATION_WA_E),                                    \
    STR(PRV_CPSS_DXCH_LION_INDIRECT_ACCESS_TO_TCAM_IS_NOT_SUPPORTED_WA_E),              \
    STR(PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E),                          \
    STR(PRV_CPSS_DXCH_LION_RM_TCAM_CONFIG_WA_E),                                        \
    STR(PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E),                                      \
    STR(PRV_CPSS_DXCH_LION_POLICER_COUNTING_MEM_ACCESS_WA_E),                           \
    STR(PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_FDB_LIMIT_WA_E),                         \
    STR(PRV_CPSS_DXCH_LION_RM_ORIG_SRC_PORT_FILTERING_WA_E),                            \
    STR(PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_CPU_IN_VIDX_WA_E),                       \
    STR(PRV_CPSS_DXCH_LION_CN_GLOBAL_REG_WA_E),                                         \
    STR(PRV_CPSS_DXCH_LION_TEMPERATURE_SENSOR_INITIALIZATION_WA_E),                     \
    STR(PRV_CPSS_DXCH_LION_RM_SD_PLL_REG_WA_E),                                         \
    STR(PRV_CPSS_DXCH_LION_SLOW_RATE_ON_PORT_TB_NOT_SUPPORTED_WA_E),                    \
    STR(PRV_CPSS_DXCH_LION_RM_UC_STRICT_OVER_MC_WA_E),                                  \
    STR(PRV_CPSS_DXCH_LION_RM_SCHEDULER_DEFICIT_MODE_WA_E),                             \
    STR(PRV_CPSS_DXCH_LION_RM_TX_MC_IN_CHUNKS_WA_E),                                    \
    STR(PRV_CPSS_DXCH_LION_RM_BUFF_LIMIT_EGRESS_QUEUE_WA_E),                            \
    STR(PRV_CPSS_DXCH_LION_XLG_WS_SUPPORT_WA_E),                                        \
    STR(PRV_CPSS_DXCH_LION_QCN_FORMAT_COMPLIANT_WA_E),                                  \
    STR(PRV_CPSS_DXCH_LION_INACCURATE_PFC_XOFF_WA_E),                                   \
    STR(PRV_CPSS_DXCH_LION_INCOMPLETE_CPU_MAILBOX_INFO_WA_E),                           \
    STR(PRV_CPSS_DXCH_LION_WRONG_COUNTING_OF_IP_COUNTERS_PER_PORT_WA_E),                \
    STR(PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E),                                           \
    STR(PRV_CPSS_DXCH_XCAT2_RM_POLICER_MEM_CONTROL_WA_E),                               \
    STR(PRV_CPSS_DXCH_XCAT2_RM_INCORRECT_XG_SHAPER_TOKEN_BUCKET_WA_E),                  \
    STR(PRV_CPSS_DXCH_XCAT2_RM_BYPASS_PACKET_REFRESH_FDB_AGE_WA_E),                     \
    STR(PRV_CPSS_DXCH_XCAT2_RM_PIPE_SELECT_WA_E),                                       \
    STR(PRV_CPSS_DXCH_XCAT2_RM_FLEX_LINK_PORTS_RATE_LIMIT_WA_E),                        \
    STR(PRV_CPSS_DXCH_XCAT2_PTP_UDP_FRAGMENT_WA_E),                                     \
    STR(PRV_CPSS_DXCH_XCAT2_100FX_WA_E),                                                \
    STR(PRV_CPSS_DXCH_LION2_FAST_FAILOVER_WA_E),                                        \
    STR(PRV_CPSS_DXCH_LION2_RM_TTI_DUAL_DEV_ENABLE_WA_E),                               \
    STR(PRV_CPSS_DXCH_LION2_HGL_MAC_INT_WA_E),                                          \
    STR(PRV_CPSS_DXCH_XCAT2_PTP_FRAGMENT_PACKET_TRAP_WA_E),                             \
                                                                                        \
    STR(PRV_CPSS_DXCH_LION_RM_ENABLE_PFC_TRIGGER_WA_E),                                 \
    STR(PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_CPFC_THRESHOLDS_WA_E),                     \
    STR(PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_PFC_THRESHOLDS_WA_E),                      \
    STR(PRV_CPSS_DXCH_LION2_RM_LLFC_TRIGGER_GLOBAL_CONFIGURATION_WA_E),                 \
    STR(PRV_CPSS_DXCH_LION2_RM_ENABLE_PFC_TRIGGER_WA_E),                                \
    STR(PRV_CPSS_DXCH_LION2_RM_GLOBAL_XOFF_ACTIVATION_ON_PORT_WA_E),                    \
    STR(PRV_CPSS_DXCH_LION2_LOCAL_SRC_PORT_DEV_MAP_ENABLE_WA_E),                        \
    STR(PRV_CPSS_DXCH_LION2_SHARE_EN_CHANGE_WA_E),                                      \
    STR(PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E),                          \
    STR(PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E),                             \
    STR(PRV_CPSS_DXCH_LION2_SCHEDULER_PROFILE_UNDER_TRAFFIC_WA_E),                      \
    STR(PRV_CPSS_DXCH_LION2_DISMATCH_PORTS_LINK_WA_E),                                  \
    STR(PRV_CPSS_DXCH_LION2_GIGE_MAC_LINK_STATUS_WA_E),                                 \
    STR(PRV_CPSS_DXCH_LION2_CUT_THROUGH_SLOW_TO_FAST_WA_E),                             \
    STR(PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_MLL_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E),    \
    STR(PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_BMA_MC_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E), \
    STR(PRV_CPSS_DXCH_LION2_RM_WRONG_GIG_DESC_FIFO_THRESHOLD_WA_E),                     \
    STR(PRV_CPSS_DXCH_LION2_PORT_MAC_MIB_COUNTERS_CORRUPTION_WA_E),                     \
    STR(PRV_CPSS_DXCH_BOBCAT2_NON_ORIG_VID_ON_TRAP_TO_CPU_WA_E),                        \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_TXDMA_FIFO_THRESHOLD_WA_E),                      \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_RATE_LIMIT_DEFICIT_COUNT_EN_WA_E),                     \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_STRICT_PRIORITY_FOR_UC_PACKETS_WA_E),                  \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_TTI_BAD_DEFAULT_VALUE_FIX_WA_E),                       \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_GLOBAL_EPORT_RANGE_VALUE_AND_MASK_WA_E),               \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_BRIDGE_COMMANDS_DEFAULTS_WA_E),                        \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_CONTROL_FROM_CPU_EGRESS_FILTER_WA_E),                  \
    STR(PRV_CPSS_DXCH_BOBCAT2_MPLS_TRANSIT_TUNNEL_PARSING_WA_E),                        \
    STR(PRV_CPSS_DXCH_BOBCAT2_EGRESS_MIB_COUNTERS_NOT_ROC_WA_E),                        \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_TXQ_PORT_REQUEST_MASK_WA_E),                           \
    STR(PRV_CPSS_DXCH_BOBCAT2_NOT_ALLOW_TTI_ACTION_TO_SET_MODIFY_UP_DSCP_WA_E),         \
    STR(PRV_CPSS_DXCH_BOBCAT2_ILKN_PACKET_SIZE_LIMITATION_NOT_ENFORCED_WA_E),           \
    STR(PRV_CPSS_DXCH_BOBCAT2_ENH_TAILDROP_MODE_WRED_CONFLICT_WA_E),                    \
    STR(PRV_CPSS_DXCH_BOBCAT2_PFC_NOT_SUPPORTED_PORTS_48_71_WA_E),                      \
    STR(PRV_CPSS_DXCH_BOBCAT2_FC_802_3X_NOT_SUPPORTED_TM_MAPPED_PORTS_WA_E),            \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_PROT_SWITCH_STAGE_EN_DEFAULT_VALUE_WA_E),              \
    STR(PRV_CPSS_DXCH_BOBCAT2_FC_SENT_COUNTERS_PROBLEM_WHEN_FCU_BYPASS_DISABLE_WA_E),   \
    STR(PRV_CPSS_DXCH_BOBCAT2_DESCRIPTOR_ECC_PROTECTION_CORRUPTION_WITH_REMOTE_PORTS_WA_E), \
    STR(PRV_CPSS_DXCH_BOBCAT2_FDB_ROUTE_UC_DELETE_BY_MESSAGE_WA_E),                     \
    STR(PRV_CPSS_DXCH_BOBCAT2_TCAM_WRITE_PARITY_ERROR_WA_E),                            \
    STR(PRV_CPSS_DXCH_BOBCAT2_EQ_TO_CPU_RATE_LIMIT_WINDOW_RESOLUTION_WA_E),             \
    STR(PRV_CPSS_DXCH_BOBCAT2_EPLR_TO_CPU_OAM_WA_E),                                    \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_AVS_INIT_WA_E),                                  \
    STR(PRV_CPSS_DXCH_BOBCAT2_RXDMA_PIP_IPV6_WRONG_TC_BITS_WA_E),                       \
    STR(PRV_CPSS_DXCH_BOBCAT2_LED_LINK_GIG_INDICATION_WA_E),                            \
    STR(PRV_CPSS_DXCH_BOBCAT2_GPP_INTERRUPT_WA_E),                                      \
    STR(PRV_CPSS_DXCH_BOBCAT2_SGMII_TO_CPU_NOT_SUPPORTED_WA_E),                         \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E),                 \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_DFX_REGISTERS_MISSCONFIGURATION_WA_E),                 \
    STR(PRV_CPSS_DXCH_BOBCAT2_PACKET_GENERATOR_SPECIFIC_PORTS_WA_E),                    \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_PORT_MAC_CONTROL_REG4_WA_E),             \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_CNM_HEADER_CONFIGURATION_WA_E),          \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_PTP_UDP_CHECKSUM_TRAILER_BIT_WA_E),                    \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_INGRESS_FORWARDING_RESTRICTIONS_DROP_CODE_WA_E),       \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_TRUNK_LTT_ENTRY_WRONG_DEFAULT_VALUES_WA_E),            \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_SHAPER_PARITY_ERROR_INTERRUPT_WA_E),                   \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_FDB_SCHEDULER_SWRR_CONTROL_WA_E),                      \
    STR(PRV_CPSS_DXCH_BOBCAT2_TAI_MINIMAL_TOD_DRIFT_CONSTRAIN_WA_E),                    \
                                                                                        \
    STR(PRV_CPSS_DXCH_XCAT3_UC_LOCAL_SWITCH_FILTER_FOR_VIRTUAL_PORTS_WA_E),             \
    STR(PRV_CPSS_DXCH_XCAT3_TRUNK_ID_ASSIGN_INSTEAD_OF_VIRTUAL_PORT_WA_E),              \
    STR(PRV_CPSS_DXCH_XCAT3_OAM_LB_PORT_NOT_GETTING_HIGHEST_QOS_WA_E),                  \
    STR(PRV_CPSS_DXCH_XCAT3_GIG_MAC_HALF_DUPLEX_COLLISION_DOMAIN_RM_E),                 \
    STR(PRV_CPSS_DXCH_XCAT3_XLG_PORT_DROP_EVENT_PROBLEM_RM_E),                          \
    STR(PRV_CPSS_DXCH_XCAT3_RM_RX_SDMA_WRONG_QUEUE_WA_E),                               \
    STR(PRV_CPSS_DXCH_MISCONFIG_100BASEX_AN_DISABLE_WA_E),                              \
                                                                                        \
    STR(PRV_CPSS_DXCH_CAELUM_EGRESS_MEMORIES_NOT_RESET_WA_E),                           \
    STR(PRV_CPSS_DXCH_CAELUM_TOD_DECREMENT_OPERATION_E),                                \
    STR(PRV_CPSS_DXCH_CAELUM_INGRESS_VLAN_RANGE_CONFIG_WA_E),                           \
    STR(PRV_CPSS_DXCH_CAELUM_RM_PLR_METERING_INACCURACY_IN_START_TRAFFIC_WA_E),         \
    STR(PRV_CPSS_DXCH_CAELUM_RM_PLR_UNUSED_IPLR_STAGES_MUST_BE_BYPASSED_WA_E),          \
                                                                                        \
    STR(PRV_CPSS_DXCH_IMPLEMENT_WA_2_5G_SGMII_LINK_UP_E),                               \
    STR(PRV_CPSS_DXCH_CAELUM_10G_XLG_LINK_UP_E),                                  \
                                                                                        \
    STR(PRV_CPSS_DXCH_ALDRIN_WRONG_DEFAULT_CLEARED_UC_DIST_WA_E),                       \
    STR(PRV_CPSS_DXCH_ALDRIN_WRONG_DEFAULT_BM_GLOBAL_GFG_3_WA_E),                       \
    STR(PRV_CPSS_DXCH_ALDRIN_TCAM_CONTENTS_NOT_INITALIZED_WA_E),                        \
                                                                                        \
    STR(PRV_CPSS_DXCH_BOBCAT3_RM_TCAM_SEGMENT_MODE_OBSOLETE_WA_E),                      \
    STR(PRV_CPSS_DXCH_BOBCAT3_RM_EQ_ARBITERS_WA_E),                                     \
    STR(PRV_CPSS_DXCH_BOBCAT3_RM_PERFORMANCE_DEGRADATION_IN_EGF_QAG_WA_E),              \
    STR(PRV_CPSS_DXCH_BOBCAT3_RM_TXQ_IP_BMX_FILL_LEVEL_DEBUG_WA_E),                     \
    STR(PRV_CPSS_DXCH_BOBCAT3_RM_CUT_THROUGH_NUMBERS_OF_BUFFERS_WA_E),                  \
    STR(PRV_CPSS_DXCH_BOBCAT3_CG_REGFILE_UNRESET_WA_E),                                 \
    STR(PRV_CPSS_DXCH_BOBCAT3_DESC_SHARED_POOL_TAILDROP_THRESHOLDS_WA_E),               \
    STR(PRV_CPSS_DXCH_BOBCAT3_RM_CUT_THROUGH_PACKET_CORRUPTION_WA_E),                   \
    STR(PRV_CPSS_DXCH_BOBCAT3_RM_ROUTER_FIFOS_THRESHOLD_1_WA_E),                        \
    STR(PRV_CPSS_DXCH_BOBCAT3_PORT_LED_POSITION_JUST_ON_USED_MAC_WA_E),                 \
    STR(PRV_CPSS_DXCH_BOBCAT3_LINK_DOWN_100G_PORT_BLOCKS_THE_TRANSMIT_PATH_WA_E),       \
    STR(PRV_CPSS_DXCH_BOBCAT3_PLR_INDIRECT_READ_COUNTERS_ON_DISABLED_MODE_WA_E),        \
    STR(PRV_CPSS_DXCH_BOBCAT3_RM_TXQ_TX_SHAPER_BASELINE_WA_E),                          \
    STR(PRV_CPSS_DXCH_BOBCAT3_100G_SYNC_ETHERNET_WA_E),                                 \
    STR(PRV_CPSS_DXCH_BOBCAT2_FORCE_DOWN_LINK_PARTNER_WA_E),                            \
    STR(PRV_CPSS_DXCH_GIGE_MAC_TX_FIFO_WA_E),                                           \
    STR(PRV_CPSS_DXCH_BOBCAT2_TXQ_TAIL_DROP_TABLES_R_W_PENDS_BUS_WA_E),                 \
    STR(PRV_CPSS_DXCH_CAELUM_TAI_FREQUENCY_ADJUST_TIME_WINDOW_INIT_VAL_WA_E),           \
    STR(PRV_CPSS_DXCH_ALDRIN2_EPCL_TCAM_LOOKUP_LATENCY_WA_E),                           \
    STR(PRV_CPSS_DXCH_ALDRIN2_BRIDGE_RATE_LIMIT_UC_WA_E),                               \
    STR(PRV_CPSS_DXCH_BOBCAT2_PBR_PACKETS_TREATED_AS_UNKNOWN_DA_WA_E),                  \
    STR(PRV_CPSS_DXCH_ALDRIN2_TCAM_ANSWERS_FLOOR_SAMPLES_INIT_VALUE_WA_E),              \
    STR(PRV_CPSS_DXCH_ALDRIN2_QUEUE_VALUE_DISABLE_WA_E),                                \
    STR(PRV_CPSS_DXCH_BOBCAT3_RM_PFC_IND_FIFO_CROSS_MODE_THRESHOLD_WA_E),               \
    STR(PRV_CPSS_DXCH_FALCON_L2I_AND_EQ_READ_TABLE_BEFORE_TRAFFIC_WA_E),                \
    STR(PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CONFIG_FOR_TAI_CTRL_1_E),                    \
    STR(PRV_CPSS_DXCH_FALCON_SBM_XOR_CLIENTS_READ_WRITE_BEFORE_SW_RESET_WA_E),          \
    STR(PRV_CPSS_DXCH_FALCON_TXQ_SKIP_TABLES_BACKUP_WA_E),                              \
    STR(PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CONFIG_SIP_LOOKUP_E),                        \
    STR(PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_IPV6_TT_HBH_EXT_EXCEPTION_CMD_E),            \
    STR(PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_IPV6_TT_NON_HBH_EXT_EXCEPTION_CMD_E),        \
    STR(PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CT_BC_LEN_CHECK_E),                          \
    STR(PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CT_HEADER_INTEGRITY_EXCEPTION_CMD_E),        \
    STR(PRV_CPSS_DXCH_FALCON_MRU_PER_DEFAULT_EPORT_WA_E),                               \
    STR(PRV_CPSS_DXCH_FALCON_MRU_BRIDGE_EVLAN_WA_E),                                    \
    STR(PRV_CPSS_DXCH_XCAT3_TCP_SYN_WITH_DATA_E),                                       \
    STR(PRV_CPSS_DXCH_AC5P_MPLS_CUT_THROW_ENABLE_E),                                    \
    STR(PRV_CPSS_DXCH_BOBCAT2_TCAM_ARRAY_SPEED_MATCH_CFG_INIT_E),                       \
    STR(PRV_CPSS_DXCH_AC5P_RM_MASTER_TAI_DEFAULT_MANCHESTER_HALF_BIT_SYMBOL_LENGTH_E),  \
    STR(PRV_CPSS_DXCH_AC5P_RM_RELOCATE_EQ_DROP_TO_EREP_WA_E),                           \
    STR(PRV_CPSS_DXCH_FALCON_TAIL_DROP_ON_VIRTUAL_BUFFERS_E),                           \
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_DEFAULT_DOMAIN_ID_PER_DOMAIN_INDEX_E),                 \
    STR(PRV_CPSS_DXCH_FALCON_RM_HASH_MODE_WA_E),                                        \
    STR(PRV_CPSS_DXCH_AC5P_TIMESTAMP_TO_THE_FUTURE_WA_E),                               \
    STR(PRV_CPSS_DXCH_AC5P_TOD_UPDATE_SECONDS_WA_E),                                    \
    STR(PRV_CPSS_DXCH_ERRATA_ALDRIN_SDWRR_WA_E),                                        \
    STR(PRV_CPSS_DXCH_AC5P_RM_DRIFT_MIN_THRESHOLD_WA_E),                                \
    STR(PRV_CPSS_DXCH_FALCON_SKIP_REGISTERS_SW_RESET_NOT_SUPPORTED_WA_E),               \
    STR(PRV_CPSS_DXCH_AC5P_RM_IPFIX_FIRST_PACKET_CMD_WA_E),                             \
    STR(PRV_CPSS_DXCH_AC5P_RM_BRIDGE_CHECK_IP_HEADER_WA_E),                             \
    STR(PRV_CPSS_DXCH_HARRIER_RM_PTP_PLL_SET_GLOBAL_REF_CLOCK_WA_E),                    \
    STR(PRV_CPSS_DXCH_AC5P_RM_PTP_FREQ_UPDATE_FOR_PCLK_IS_DONE_INACCURATELY_WA_E),      \
                                                                                        \
    "--last one--"

    static const char * errataNames[PRV_CPSS_DXCH_ERRATA_MAX_NUM_E+1] = {ERRATA_NAMES};
#endif /*DEBUG_OPENED*/

/* used print routine   */
#define DUMP_PRINT_MAC(x) cpssOsPrintf x
/* get the name (string) and value of field */
#define NAME_AND_VALUE_MAC(field)   #field , field

/* define constant for quick search for code that not support device types */
#define GT_DEVICE_FAMILY_NOT_SUPPORTED_CNS      GT_NOT_SUPPORTED
#define HW_INIT_SMI_POOLING_TIMEOUT_CNS 200000

/* definitions for interrupt coalescing */
#define MIN_INTERRUPT_COALESCING_PERIOD_CNS 320
#define MAX_INTERRUPT_COALESCING_PERIOD_CNS 5242560

/* number of VIDXs in the device */
#define VIDX_NUM_CNS  (_4K-1)

/* number of target device */
#define TARGET_DEV_NUM_CNS  15

/* number of target port */
#define TARGET_PORT_NUM_CNS 63

/* number of STG (spanning tree groups) in the device */
#define STG_NUM_CNS     256

/* 127 trunks support */
#define TRUNKS_127_NUM_CNS   127

/* 4 TX Queues number */
#define TX_QUEUE_NUM_4_CNS                4

/* in Lion only portGroupId#3 has the RGMII registers for the CPU port */
#define LION_RGMII_PORT_GROUP_ID_CNS  3

/* indication that there was no need to replace a tcam row using the efuse */
#define NO_TCAM_ROW_TO_REPLACE_CNS 0xFFFFFFFF

/* maximum number of PLL recovery loops in the first level wrapper */
#define PLL_UNLOCK_WORKAROUND_MAX_LOOPS_1ST_WRAPPER_CNS 25

/* maximum number of PLL recovery loops in the second level wrapper for each setting change */
#define PLL_UNLOCK_WORKAROUND_MAX_LOOPS_2ND_WRAPPER_CNS 5

/* maximum number of PLL setting changes in the second level wrapper */
#define PLL_UNLOCK_WORKAROUND_MAX_LOOPS_SET_CHANGE_CNS 15

/* maximum number of PLL recovery loops in the third level wrapper for each setting change */
#define PLL_UNLOCK_WORKAROUND_MAX_LOOPS_3RD_WRAPPER_CNS 5

/* number of network SERDES */
#define PRV_CH3_NETWORK_SERDES_NUM_CNS 24

/* pre allocated descriptors - HW value used for resource calculations */
#define PRV_DXCH_XCAT_PRE_ALLOC_DESC_CNS 242

/* Maximal address range inside one unit in words ((bits 0..22) >> 2) */
#define PRV_DXCH_MAX_UNIT_ADDR_RANGE_CNS    (1 << 21)

/* Calculate the last row of the TCAM logical sub-block for the row that was replaced */
/* to invalidate. A TCAM logical sub-block comprises 128 rows.                        */
#define LAST_SUB_BLOCK_ROW_CALC_MAC(_row)  _row = (_row/128 + 1)*128 - 1

/* Lion2 data integrity - max number of memory location per memory type for errata */
#define LION2_DATA_INTEGRITY_MAX_LOCATION_NUM_PER_MEMORY_CNS 8

/* bitmap of MC relay ports between hemispheres */
#define PRV_MC_RELAY_PORTS_BMP_CNS 0x10001000

/* needed by Falcon  : 32 words to support 1024 ports (designated table , non-trunk)*/
/* needed by Bobcat3 : 16 words to support 512 ports */
#define EGF_SHT_MAX_PORTS_BMP_NUM_CNS       CPSS_MAX_PORTS_BMP_NUM_CNS

/* Falcon SAR2 register address on tile 0 - use it when register addresses DB is not created yet */
#define PRV_CPSS_FALCON_DFX_SAR2_REG_ADDR_CNS    (PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS + PRV_CPSS_FALCON_DFX_BASE_ADDRESS_CNS)
/* Hawk  SAR2 register address            - use it when register addresses DB is not created yet */
#define PRV_CPSS_AC5P_DFX_SAR2_REG_ADDR_CNS    (PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS + PRV_CPSS_AC5P_DFX_BASE_ADDRESS_CNS)
/* Phoenix  SAR2 register address            - use it when register addresses DB is not created yet */
#define PRV_CPSS_PHOENIX_DFX_SAR2_REG_ADDR_CNS    (PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS + PRV_CPSS_PHOENIX_DFX_BASE_ADDRESS_CNS)
/* Harrier  SAR2 register address            - use it when register addresses DB is not created yet */
#define PRV_CPSS_HARRIER_DFX_SAR2_REG_ADDR_CNS    (PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS + PRV_CPSS_HARRIER_DFX_BASE_ADDRESS_CNS)
/* Ironman  SAR2 register address            - use it when register addresses DB is not created yet */
#define PRV_CPSS_IRONMAN_DFX_SAR2_REG_ADDR_CNS    (PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS + PRV_CPSS_IRONMAN_DFX_BASE_ADDRESS_CNS)

/* maximal MPP selector numbers */
#define PRV_CPSS_MAX_MPP_SELECTORS_NUM_CNS                  64
/* Hawk maximal MPP selector numbers */
#define PRV_CPSS_AC5P_MAX_MPP_SELECTORS_NUM_CNS             48
/* Harrier maximal MPP selector numbers */
#define PRV_CPSS_HARRIER_MAX_MPP_SELECTORS_NUM_CNS          32

GT_VOID prvCpssDxChPortTypeSet
(
    IN  GT_U8                          devNum,
    IN  GT_PHYSICAL_PORT_NUM           portNum,
    IN  CPSS_PORT_INTERFACE_MODE_ENT   ifMode,
    IN  CPSS_PORT_SPEED_ENT             speed
);

static GT_STATUS hwPpPhase1Part4
(
    IN  GT_U8               devNum
);

static GT_STATUS hwPpPhase1Part5
(
    IN  GT_U8               devNum
);

static GT_STATUS hwPpPhase1Part6
(
    IN  GT_U8               devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr
);

GT_STATUS prvCpssDxChBrgMcEntryWrite
(
    IN GT_U8                devNum,
    IN GT_U16               vidx,
    IN CPSS_PORTS_BMP_STC   *portBitmapPtr
);

/*extern*/ GT_STATUS prvCpssDxChPortMappingTxQPort2TxDMAMapSet
(
    IN GT_U8  devNum,
    IN GT_U32 portGroupId,
    IN GT_U32 txqNum,
    IN GT_U32 txDmaNum
);
GT_STATUS prvCpssDxChPortMappingEGFTargetLocalPhys2TxQPortMapSet
(
    IN GT_U8                devNum,
    IN GT_U32               portGroupId,
    IN GT_PHYSICAL_PORT_NUM physPort,
    IN GT_U32               txqNum
);
static GT_STATUS prvCpssDxChHwEgfEftCpuCodeMapToCpuPortInit
(
    IN  GT_U8   devNum
);
static GT_STATUS prvCpssDxChHwEgfQagTcDpMapperInit
(
    IN  GT_U8   devNum
);
static GT_STATUS internal_cpssDxChHwPpMaxNumOfPhyPortsToUseSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  maxPhysicalPorts
);

static GT_STATUS prvCpssDxChUnitInterruptGenerationCheck
(
    IN GT_SW_DEV_NUM  devNum,
    IN GT_U32 causeReg
);

static GT_STATUS prvCpssDxChEventGenericConvert
(
    IN  GT_SW_DEV_NUM                   devNum,
    IN  CPSS_UNI_EV_CAUSE_ENT           uniEvent,
    IN  GT_U32                          IN_evExtData,
    IN  PRV_CPSS_EV_CONVERT_DIRECTION_ENT    evConvertType,
    OUT GT_U32                          *OUT_evExtDataPtr
);
extern GT_BOOL prvCpssDrvPpUniEvPerPortHit
(
    IN GT_U32               uniEvent,
    OUT GT_U32              *portBitPtr,
    OUT GT_U32              *portMaskPtr
);

/* Check for SERDES existence and skip if SERDES does not exist */
#define PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(_serdes, _sbitmap) \
    if (((_sbitmap) & (1 << (_serdes))) == 0) \
        continue;

/* Check for power down SERDES bitmap and skip if SERDES should not be powered up */
#define PRV_CPSS_DXCH_SKIP_POWER_DOWN_PORTS_MAC(_port, _sbitmap) \
    if (((_sbitmap) & (1 << (_port))) != 0) \
        continue;

/* interrupt register for the GE MAC port
 * APPLICABLE DEVICES: xCat3; AC5.
 */
#define GE_MAC_PORT_INTERRUPT_CAUSE_MAC(port) (0x0A800020  + ((port) * 0x400))

/* interrupt cause index for the GE MAC port link status change
 * APPLICABLE DEVICES: xCat3; AC5.
 */
#define GE_MAC_PORT_INTERRUPT_INDEX_MAC(dev, port)   \
            (PRV_CPSS_XCAT3_PORT_0_LINK_STATUS_CHANGED_E + ((port)*32))

/* #define FLEX_LINK_UP_WA_DBG */
#ifdef FLEX_LINK_UP_WA_DBG
    #define FLEX_LINK_UP_WA_DBG_PRINT_MAC(x) cpssOsPrintf x
#else
    #define FLEX_LINK_UP_WA_DBG_PRINT_MAC(x)
#endif

/* Alleycat xCat3 devs 24FE */
#define ALLEYCAT_XCAT3_DEVS_24FE_MAC    \
    CPSS_98DX1233_CNS,  \
    CPSS_98DX1235_CNS,  \
    CPSS_98DX123S_CNS,  \
    CPSS_98DX125S_CNS

/* Alleycat xCat3 devs 24GE */
#define ALLEYCAT_XCAT3_DEVS_24GE_MAC    \
    CPSS_98DX3233_CNS,  \
    CPSS_98DX3234_CNS,  \
    CPSS_98DX3235_CNS,  \
    CPSS_98DX3236_CNS,  \
    CPSS_98DXH333_CNS,  \
    CPSS_98DXT321_CNS,  \
    CPSS_98DXT323_CNS,  \
    CPSS_98DXC323_CNS,  \
    CPSS_98DX233S_CNS,  \
    CPSS_98DX234S_CNS,  \
    CPSS_98DX235S_CNS,  \
    CPSS_98DX236S_CNS

#define ALLEYCAT_XCAT3_DEVS_24GE_LIGHT_MAC    \
    CPSS_98DXH201_CNS,                        \
    CPSS_98DXH201_1_CNS

#define ALLEYCAT_XCAT3_DEVS_MAC   \
    ALLEYCAT_XCAT3_DEVS_24FE_MAC, \
    ALLEYCAT_XCAT3_DEVS_24GE_MAC

#define ALLEYCAT_XCAT3_REDUCED_DEVS_MAC   \
    CPSS_98DX3223_1_CNS,\
    CPSS_98DX3224_CNS,  \
    CPSS_98DX3225_CNS,  \
    CPSS_98DX3226_CNS,  \
    CPSS_98DX223S_CNS,  \
    CPSS_98DX224S_CNS,  \
    CPSS_98DX225S_CNS,  \
    CPSS_98DX226S_CNS

/* Alleycat Plus xCat3  */
#define ALLEYCAT_PLUS_XCAT3_DEVS_MAC    \
    CPSS_98DX3243_CNS,                  \
    CPSS_98DX3244_CNS,                  \
    CPSS_98DX3245_CNS,                  \
    CPSS_98DX3246_CNS,                  \
    CPSS_98DX3247_CNS

/* poncat xCat3 devs 24FE */
#define PONCAT_XCAT3_DEVS_24FE_MAC    \
    CPSS_98DX1333_CNS,  \
    CPSS_98DX1335_CNS,  \
    CPSS_98DX1336_CNS

/* poncat xCat3 devs 24GE */
#define PONCAT_XCAT3_DEVS_24GE_MAC    \
    CPSS_98DX3333_CNS,  \
    CPSS_98DX3334_CNS,  \
    CPSS_98DX3335_CNS,  \
    CPSS_98DX3336_CNS,  \
    CPSS_98DX333S_CNS,  \
    CPSS_98DX334S_CNS,  \
    CPSS_98DX335S_CNS,  \
    CPSS_98DX336S_CNS,  \
    CPSS_98DXC333_CNS,  \
    CPSS_98DXC334_CNS,  \
    CPSS_98DXC336_CNS

#define PONCAT_XCAT3_DEVS_MAC   \
    PONCAT_XCAT3_DEVS_24FE_MAC, \
    PONCAT_XCAT3_DEVS_24GE_MAC

#define ALLEYCAT_UNMANAGED_DEVS_MAC     \
    CPSS_98DX215S_CNS,                  \
    CPSS_98DX216S_CNS

/* poncat xCat3S lite devs 24GE */
#define PONCAT_XCAT3S_DEVS_24GE_LITE_MAC  \
    CPSS_98DX336E_CNS,  \
    CPSS_98DX336R_CNS


/* ----------------------xCat3 Restricted Address Range ----------------------------- */

/* xCat3 Unit 0, unitName: MG_IP, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit0RangesArray[] =
{
    {0x00040018,0x0007FFFC,0x0,0x0},
    {0x000910E4,0x00FFFFFC,0x0,0x0}
};

/* xCat3 Unit 2, unitName: Egr TxQ, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit2RangesArray[] =
{
    {0x02000000,0x027FFFFC,0x0,0x0},
    {0x02B33604,0x02B37DFC,0x0,0x0},
    {0x02B3FE04,0x02B40143,0x0,0x0},
    {0x02B40160,0x02B40163,0x0,0x0},
    {0x02B40188,0x02CBFFFC,0x0,0x0},
    {0x02CC0010,0x02D3FFFC,0x0,0x0},
    {0x02D43610,0x02E3FFFC,0x0,0x0},
    {0x02E48800,0x02E7FFFC,0x0,0x0},
    {0x02E80020,0x02FFFFFC,0x0,0x0}
};

/* xCat3 Unit 4, unitName: IPvX, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit4RangesArray[] =
{
    {0x04000D70,0x04000E38,0x0,0x0},
    {0x04002000,0x042FFFFC,0x0,0x0},
    {0x04310000,0x04FFFFFC,0x0,0x0}
};

/* xCat3, Unit 6, unitName: EPLR, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit6RangesArray[] =
{
    {0x06000940,0x060017FC,0x0,0x0},
    {0x06080280,0x06FFFFFC,0x0,0x0}
};

/* xCat3, Unit 14, unitName: MEM, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit14RangesArray[] =
{
    {0x0E60010C,0x0EFFFFFC,0x0,0x0}
};

/* xCat3, No unit exist in this range, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit15RangesArray[] =
{
    {0x0F000000,0x0FFFFFFC,0x0,0x0}
};

/* xCat3, Unit 17, unitName: MSM MIB, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit17RangesArray[] =
{
    {0x11007500,0x11007BFC,0x0,0x0},
    {0x11007D00,0x11FFFFFC,0x0,0x0}
};

/* xCat3, Unit 18, unitName: GOP, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit18RangesArray[] =
{
    {0x1201D0E0,0x1201EFFC,0x0,0x0},
    {0x1201F0E0,0x120D7FFC,0x0,0x0},
    {0x120DD0A0,0x120DEFFC,0x0,0x0},
    {0x120DF098,0x121805FC,0x0,0x0},
    {0x12180CD0,0x121815FC,0x0,0x0},
    {0x12181720,0x121825FC,0x0,0x0},
    {0x12182720,0x121835FC,0x0,0x0},
    {0x12183720,0x121845FC,0x0,0x0},
    {0x12184CD0,0x121855FC,0x0,0x0},
    {0x12185720,0x121865FC,0x0,0x0},
    {0x12186720,0x121875FC,0x0,0x0},
    {0x12187720,0x121885FC,0x0,0x0},
    {0x12188CD0,0x121895FC,0x0,0x0},
    {0x12189720,0x1218A5FC,0x0,0x0},
    {0x1218A720,0x1218B5FC,0x0,0x0},
    {0x1218B720,0x1218C5FC,0x0,0x0},
    {0x1218CCD0,0x1218D5FC,0x0,0x0},
    {0x1218D720,0x1218E5FC,0x0,0x0},
    {0x1218E720,0x1218F5FC,0x0,0x0},
    {0x1218F720,0x121905FC,0x0,0x0},
    {0x12190CD0,0x121915FC,0x0,0x0},
    {0x12191720,0x121925FC,0x0,0x0},
    {0x12192720,0x121935FC,0x0,0x0},
    {0x12193720,0x121945FC,0x0,0x0},
    {0x12194CD0,0x121955FC,0x0,0x0},
    {0x12195720,0x121965FC,0x0,0x0},
    {0x12196720,0x121975FC,0x0,0x0},
    {0x12197720,0x12197FFC,0x0,0x0},
    {0x12198200,0x121983FC,0x0,0x0},
    {0x12199200,0x121995FC,0x0,0x0},
    {0x12199720,0x12199FFC,0x0,0x0},
    {0x1219A200,0x1219A3FC,0x0,0x0},
    {0x1219A720,0x1219AFFC,0x0,0x0},
    {0x1219B200,0x1219B5FC,0x0,0x0},
    {0x1219B720,0x1219BFFC,0x0,0x0},
    {0x1219C200,0x1219C3FC,0x0,0x0},
    {0x1219C720,0x1219CFFC,0x0,0x0},
    {0x1219D200,0x1219D3FC,0x0,0x0},
    {0x1219DCD0,0x1219EFFC,0x0,0x0},
    {0x1219F200,0x1219F5FC,0x0,0x0},
    {0x1219F720,0x121B1FFC,0x0,0x0},
    {0x121B2180,0x12FFFFFC,0x0,0x0}
};

/* xCat3, Unit 19, unitName: SD, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit19RangesArray[] =
{
    {0x1300B01C,0x1300B7FC,0x0,0x0},
    {0x1300BC9C,0x13FFFFFC,0x0,0x0}
};

/* xCat3, Unit 21, unitName: IPCL, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit21RangesArray[] =
{
    {0x15000270,0x1500FFFC,0x0,0x0},
    {0x15028400,0x15FFFFFC,0x0,0x0}
};

/* xCat3, Unit 22, unitName: TTI, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit22RangesArray[] =
{
    {0x160003C0,0x160003FC,0x0,0x0},
    {0x16000500,0x16000520,0x0,0x0},
    {0x16000600,0x160008FC,0x0,0x0},
    {0x16001400,0x160015FC,0x0,0x0},
    {0x16001700,0x16003FFC,0x0,0x0},
    {0x16006000,0x1600BFFC,0x0,0x0},
    {0x16010100,0x16FFFFFC,0x0,0x0}
};

/* xCat3, Unit 23, unitName: IPLR 0,restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit23RangesArray[] =
{
    {0x17000A04,0x170017FC,0x0,0x0},
    {0x17080400,0x17FFFFFC,0x0,0x0}
};

/* xCat3, Unit 24, unitName: IPLR 1,restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit24RangesArray[] =
{
    {0x18000A04,0x180017FC,0x0,0x0},
    {0x18080400,0x18FFFFFC,0x0,0x0}
};

/*  xCat3, Unit 26, unitName: IPCL TCC, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit26RangesArray[] =
{
    {0x1A000240,0x1A03FFFC,0x0,0x0},
    {0x1A0D3000,0x1AFFFFFC,0x0,0x0}
};

/* xCat3, Unit 27, unitName: IPvX TCC, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit27RangesArray[] =
{
    {0x1B000D80,0x1B03FFFC,0x0,0x0},
    {0x1B0DA000,0x1BFFFFFC,0x0,0x0}
};

/* xCat3, Unit 28, unitName: HA, restricted ranges */
static const PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat3Unit28RangesArray[] =
{
    {0x1C000794,0x1C007FFC,0x0,0x0},
    {0x1C00C100,0x1C00FFFC,0x0,0x0},
    {0x1C014000,0x1C0187FC,0x0,0x0},
    {0x1C048000,0x1CFFFFFC,0x0,0x0}
};

/*------------------------------------------------------------------------------------- */

/* definition for empty (restricted addresses) unit ranges */
#define EMPTY_UNIT_MAC  {0,NULL}

/* definition for total number of units */
#define UNITS_NUM_CNS \
    (sizeof(DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)) \
    / sizeof(DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges[0])))

/**
* @struct BUFFER_MANAGEMENT_PARAMS_STC
 *
 * @brief structure for buffer,descriptors sizes/numbers
*/
typedef struct{

    /** Buffer Memory */
    GT_U32 bufferMemory;

    /** @brief Transmit Descriptors
     *  Comment:
     */
    GT_U32 transmitDescr;

} BUFFER_MANAGEMENT_PARAMS_STC;

/**
* @struct FINE_TUNING_BUFFER_MANAGEMENT_PARAMS_STC
 *
 * @brief structure for the devices flavors,
 * about buffer,descriptors sizes/numbers
*/
typedef struct{

    CPSS_PP_DEVICE_TYPE *devTypePtr;

    /** @brief buffer,descriptors sizes/numbers
     *  Comment:
     */
    BUFFER_MANAGEMENT_PARAMS_STC config;

} FINE_TUNING_BUFFER_MANAGEMENT_PARAMS_STC;


/* list of the alleycat xCat3 devices */
static const CPSS_PP_DEVICE_TYPE devs_alleycat_xCat3[]=
        {
            ALLEYCAT_XCAT3_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the alleycat plus xCat3 devices */
static const CPSS_PP_DEVICE_TYPE devs_alleycat_plus_xCat3[]=
        {
            ALLEYCAT_PLUS_XCAT3_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the alleycat xCat3 devices with reduced table sizes */
static const CPSS_PP_DEVICE_TYPE devs_alleycat_xCat3_reduced[]=
        {
            ALLEYCAT_XCAT3_REDUCED_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the alleycat xCat3 devices with reduced table sizes */
static const CPSS_PP_DEVICE_TYPE devs_alleycat_xCat3_light[]=
        {
            ALLEYCAT_XCAT3_DEVS_24GE_LIGHT_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };


/* list of the poncat xCat3 devices */
static const CPSS_PP_DEVICE_TYPE devs_poncat_xCat3[]=
        {
            PONCAT_XCAT3_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the xCat3 unmanaged devices */
static const CPSS_PP_DEVICE_TYPE devs_xCat3_unmanaged[]=
        {
            ALLEYCAT_UNMANAGED_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the poncat xCat3S devices */
static const CPSS_PP_DEVICE_TYPE devs_poncat_xCat3S_lite[]=
        {
            PONCAT_XCAT3S_DEVS_24GE_LITE_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* xCat3 - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC dxChXcatTables[]=
{
    { /* start "AlleyCat xCat3" */
        devs_alleycat_xCat3,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                _2K,            /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _1K/4,          /* GT_U32 router;                             */
                512,            /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                _1K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                _1K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _1K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _1K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                _1K,            /* policersNum                                */
                128,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                _1K            /* bpePointToPointEChannels                    */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }    /* end "AlleyCat xCat3" */
    ,
    {   /* start "AlleyCat Plus xCat3" */
        devs_alleycat_plus_xCat3,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                _2K,            /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _6K/4,          /* GT_U32 router;                             */
                _1K,            /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                512,            /* GT_U32  tunnelStart;                       */
                _2K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                _2K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _4K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _3K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                _1K,            /* policersNum                                */
                128,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                _1K            /* bpePointToPointEChannels                    */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }   /* end "AlleyCat Plus xCat3" */
    ,
    { /* start "AlleyCat xCat3" reduced */
        devs_alleycat_xCat3_reduced,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                _1K,            /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                512/4,          /* GT_U32 router;                             */
                256,            /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                _1K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                512,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _1K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                512/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                512,            /* policersNum                                */
                128,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                512            /* bpePointToPointEChannels                    */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }    /* end "AlleyCat xCat3" reduced */
    ,
    { /* start "PonCat xCat3" */
        devs_poncat_xCat3,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                VIDX_NUM_CNS,   /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _13K/4,         /* GT_U32 router;                             */
                _13K/4,         /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                _1K,            /* GT_U32  tunnelStart;                       */
                AUTO_CALC_FIELD_CNS,/* GT_U32  routerArp;                     */
                                /*                                            */
                /* ip section                                                 */
                _4K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _4K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _3K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                _2K,            /* policersNum                                */
                512,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                              */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                _4K            /* bpePointToPointEChannels                    */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }    /* end "PonCat xCat3" */
    ,

    { /* start "PonCat xCat3S Lite" */
        devs_poncat_xCat3S_lite,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                VIDX_NUM_CNS,   /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _4K/4,         /* GT_U32 router;                              */
                _1K,           /* GT_U32 tunnelTerm;                          */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                _5K/2,/* GT_U32  routerArp;                                   */
                                /*                                            */
                /* ip section                                                 */
                _3K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _2K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _2K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                1366,           /* policersNum                                */
                342,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                _4K            /* bpePointToPointEChannels                    */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }    /* end "PonCat xCat3" */
    ,

    { /* start "AlleyCat xCat3" light */
        devs_alleycat_xCat3_light,
        {
            NULL,
            {
                /* bridge section                                             */
                _8K,           /* fdb                                         */
                _1K,            /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                512/4,            /* GT_U32 router;                           */
                256,              /* GT_U32 tunnelTerm;                       */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                _1K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                512,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _1K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                512/4,            /* GT_U32 policyTcamRaws;                   */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                512,            /* policersNum                                */
                128,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                512            /* bpePointToPointEChannels                    */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }    /* end "AlleyCat xCat3" reduced */
    ,
    {   /* start "xCat3"  unmanaged */
        devs_xCat3_unmanaged,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                NA_TABLE_CNS,   /* vidxNum                                    */
                NA_TABLE_CNS,   /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                NA_TABLE_CNS,   /* GT_U32 router;                             */
                NA_TABLE_CNS,   /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                NA_TABLE_CNS,   /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                NA_TABLE_CNS,   /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                NA_TABLE_CNS,     /* GT_U32 policyTcamRaws;                   */
                                /*                                            */
                /* CNC section                                                */
                NA_TABLE_CNS,   /* GT_U32 cncBlocks;                          */
                NA_TABLE_CNS,   /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                NA_TABLE_CNS,   /* policersNum                                */
                NA_TABLE_CNS,   /* egressPolicersNum                          */
                NA_TABLE_CNS,   /* trunksNum                                  */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
               ,NA_TABLE_CNS   /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support                                      */
                GT_FALSE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_FALSE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_FALSE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    } /* end "xCat3"  unmanaged */
};

static const GT_U32 dxChXcatTables_size = sizeof(dxChXcatTables)/sizeof(dxChXcatTables[0]);


/* list of the AC5+ devices with same table sizes */
static const CPSS_PP_DEVICE_TYPE devs_ac5_plus[]=
{
    CPSS_98DX2538_CNS,
    CPSS_98DX2535_CNS,
    CPSS_98DX2532_CNS,
    CPSS_98DX2531_CNS,
    LAST_DEV_IN_LIST_CNS /* must be last one */
};

/* list of the AC5 devices with same table sizes */
static const CPSS_PP_DEVICE_TYPE devs_ac5[]=
{
    CPSS_98DX2528_CNS,
    CPSS_98DX2525_CNS,
    CPSS_98DX2522_CNS,
    CPSS_98DX2521_CNS,
    LAST_DEV_IN_LIST_CNS /* must be last one */
};

/* list of the AC5 light devices with same table sizes */
static const CPSS_PP_DEVICE_TYPE devs_ac5_light[]=
{
    CPSS_98DX2518_CNS,
    CPSS_98DX2515_CNS,
    CPSS_98DX2512_CNS,
    CPSS_98DX2511_CNS,
    LAST_DEV_IN_LIST_CNS /* must be last one */
};

/* AC5+ - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC dxChAc5Tables[]=
{
    { /* start "AC5+" */
        devs_ac5_plus,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                VIDX_NUM_CNS,   /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _13K/4,         /* GT_U32 router;                             */
                _13K/4,         /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                _1K,            /* GT_U32  tunnelStart;                       */
                AUTO_CALC_FIELD_CNS,/* GT_U32  routerArp;                     */
                                /*                                            */
                /* ip section                                                 */
                _4K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _4K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section -- each of the 2 tcams support the same number of entries */
                _3K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                2* _4K,         /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                _2K,            /* policersNum                                */
                512,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                              */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                _4K            /* bpePointToPointEChannels                    */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },    /* end "AC5+" */
    {
        devs_ac5,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                VIDX_NUM_CNS,   /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _4K/4,         /* GT_U32 router;                              */
                _4K/4,         /* GT_U32 tunnelTerm;                          */
                                /*                                            */
                /* tunnel section                                             */
                512,            /* GT_U32  tunnelStart;                       */
                AUTO_CALC_FIELD_CNS,/* GT_U32  routerArp;                     */
                                /*                                            */
                /* ip section                                                 */
                _2K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _2K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section -- each of the 2 tcams support the same number of entries */
                _2K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                2* _4K,         /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                _1K,            /* policersNum                                */
                256,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                              */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                _2K            /* bpePointToPointEChannels                    */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_1K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },  /* end "AC5" */
    {
        devs_ac5_light,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                VIDX_NUM_CNS,   /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _1K/4,         /* GT_U32 router;                              */
                _1K/4,         /* GT_U32 tunnelTerm;                          */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,       /* GT_U32  tunnelStart;                   */
                _1K,/* GT_U32  routerArp;                     */
                                /*                                            */
                /* ip section                                                 */
                _1K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _1K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section -- each of the 2 tcams support the same number of entries */
                _1K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,         /* GT_U32 cncBlockNumEntries;                    */
                                /*                                            */
                512,            /* policersNum                                */
                128,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                              */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                _1K            /* bpePointToPointEChannels                    */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_1K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }   /* end "AC5 light" */
};/*end of dxChAc5Tables */
static const GT_U32 dxChAc5Tables_size = sizeof(dxChAc5Tables)/sizeof(dxChAc5Tables[0]);


/* list of the Lion2-DC/Metro Data Center/Metro devices */
static const CPSS_PP_DEVICE_TYPE devs_Lion2_DC_metro[]=
        {
            CPSS_98CX8296_CNS,
            CPSS_98CX8297_CNS,
            CPSS_98CX8308_CNS,
            CPSS_98CX8297_1_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Lion2 Hooper devices */
static const CPSS_PP_DEVICE_TYPE devs_Lion2_Hooper[]=
        {
            CPSS_98CX8121_CNS,
            CPSS_98CX8123_CNS,
            CPSS_98CX8124_CNS,
            CPSS_98CX8129_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };


/* list of the Lion2-Crossbar devices */
static const CPSS_PP_DEVICE_TYPE devs_Lion2_Crossbar[]=
        {
            CPSS_98FX9287_CNS,
            CPSS_98FX9288_CNS,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* Lion2 - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC lion2Tables[]=
{
{ /* Lion2 Hooper devices */
        devs_Lion2_Hooper,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _64K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                _2K,             /* GT_U32 router;            */
                _2K,             /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _2K,             /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                _2K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _2K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,   /* GT_U32 cncBlocks;         */
                _4K,             /*GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,             /*policersNum                */
                512,             /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,          /*trunksNum */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number*/
                0,               /* lpmRam */
                0,               /* pipeBWCapacityInGbps */
                0                /* bpePointToPointEChannels */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }, /* end "Lion2 Hooper devices" */

    { /* Lion2-DC/Metro Data Center/Metro devices */
        devs_Lion2_DC_metro,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _64K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                _2K,             /* GT_U32 router;            */
                _2K,             /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _2K,             /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                _2K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _2K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,   /* GT_U32 cncBlocks;         */
                _4K,             /*GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,             /*policersNum                */
                512,             /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,          /*trunksNum */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },    /* end "Lion2-DC/Metro Data Center/Metro devices" */

    { /* Lion2-Crossbar devices */
        devs_Lion2_Crossbar,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _64K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                0,               /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                0,               /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                0,               /*GT_U32  tunnelStart;       */
                0,               /*GT_U32  routerArp;         */
                                 /*                           */
                /* ip section                                 */
                0,               /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                0,               /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _2K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,   /*GT_U32 cncBlocks;          */
                _4K,             /*GT_U32 cncBlockNumEntries; */
                /* Policer Section                            */
                _2K,             /*policersNum                */
                512,             /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,  /*trunksNum         */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_FALSE, /*tr101Supported*/

                /* VLAN translation support */
                GT_FALSE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag */
                GT_FALSE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }    /* end "Lion2-Crossbar devices" */
};

static const GT_U32 lion2Tables_size = sizeof(lion2Tables)/sizeof(lion2Tables[0]);

/* list of the Bobcat2/Metro Data Center/Metro devices */
static const CPSS_PP_DEVICE_TYPE devs_Bobcat2_DC_metro[]=
        {
            CPSS_98DX42XX_CNS,
            CPSS_98DX4251_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Bobcat2/Metro stackable devices */
static const CPSS_PP_DEVICE_TYPE devs_Bobcat2_DC_metro_stackable[]=
        {
            CPSS_98DX4220_CNS,
            CPSS_98DX4221_CNS,
            CPSS_98DX4222_CNS,
            CPSS_98DX4223_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Bobcat2-bobk caelum devices - 48+12 */
static const CPSS_PP_DEVICE_TYPE devs_Bobcat2_bobk_carrier_48and12[]=
        {
            CPSS_98DX42KK_CNS,
            CPSS_98DX4203_CNS,
            CPSS_98DX4204_CNS,
            CPSS_98DX4211_CNS,
            CPSS_98DX4210_CNS,
            CPSS_98DX4212_CNS,
            CPSS_98DX8332_Z0_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Bobcat2-bobk caelum campus low scale devices - 48+12 */
static const CPSS_PP_DEVICE_TYPE devs_Bobcat2_bobk_low_scale_48and12[]=
        {
            CPSS_98DX3347_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the Bobcat2-bobk caelum campus low scale devices - 24+12 */
static const CPSS_PP_DEVICE_TYPE devs_Bobcat2_bobk_low_scale_24and12[]=
        {
            CPSS_98DX3346_CNS,
            CPSS_98DX3345_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the Bobcat2-bobk cetus devices */
static const CPSS_PP_DEVICE_TYPE devs_Bobcat2_bobk_cetus[]=
        {
            CPSS_98DX4235_CNS,
            CPSS_98DX8212_CNS,
            CPSS_98DX8208_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Aldrin devices */
static const CPSS_PP_DEVICE_TYPE devs_Aldrin[]=
        {
            CPSS_98DX8308_CNS,
            CPSS_98DX8312_CNS,
            CPSS_98DX8315_CNS,
            CPSS_98DX8316_CNS,
            CPSS_98DX8324_CNS,
            CPSS_98DX8332_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the Aldrin - Small scale devices */
static const CPSS_PP_DEVICE_TYPE devs_Aldrin_small[]=
        {
            CPSS_98DXZ832_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the Aldrin Light scale devices */
static const CPSS_PP_DEVICE_TYPE devs_Aldrin_light[]=
        {
            CPSS_98DXH831_CNS,
            CPSS_98DXH832_CNS,
            CPSS_98DXH833_CNS,
            CPSS_98DXH834_CNS,
            CPSS_98DXH835_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the AC3+ devices */
static const CPSS_PP_DEVICE_TYPE devs_xCat3_Plus[]=
        {
            CPSS_98DX3248_CNS,
            CPSS_98DX3249_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the AC3X/24 devices */
static const CPSS_PP_DEVICE_TYPE devs_xCat3x_24[]=
        {
            /* AlleyCat3X */
            CPSS_98DX3255_CNS,
            CPSS_98DX3256_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the AC3X/24 Plus devices */
static const CPSS_PP_DEVICE_TYPE devs_xCat3x_24_Plus[]=
        {
            CPSS_98DX3265_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the AC3X/48 devices */
static const CPSS_PP_DEVICE_TYPE devs_xCat3x_48[]=
        {
            /* AlleyCat3X */
            CPSS_98DX3257_CNS,
            CPSS_98DX3258_CNS,
            CPSS_98DX3259_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the AC3X Plus devices */
static const CPSS_PP_DEVICE_TYPE devs_xCat3x_Plus[]=
        {
            /* AlleyCat3X */
            CPSS_98DX3268_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the Bobcat2-control plane switch medium scale devices */
static const CPSS_PP_DEVICE_TYPE devs_Bobcat2_control_plane[]=
        {
            CPSS_98DX8216_CNS,
            CPSS_98DX8219_CNS,
            CPSS_98DX8224_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Bobcat2/Carrier small scale */
static const CPSS_PP_DEVICE_TYPE devs_Bobcat2_Carrier_small[]=
        {
            CPSS_98DX4253_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* Bobcat2 - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC bobcat2Tables[]=
{
    { /* Bobcat2/Metro Data Center/Metro devices */
        devs_Bobcat2_DC_metro,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _128K,           /*fdb                        */
                _4K,             /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                36*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _32K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _24K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                _16K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _8K,           /*policersNum                  */
                _8K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                _16K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _32M,                 /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _128K,               /* GT_U32  lpmRam,  128K --> 320K LPM lines */
                168,                 /* pipeBWCapacityInGbps for revision B0, revision A0 is set from code , abd not from table*/
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }   /* end "Bobcat2/Metro Data Center/Metro devices" */
    ,
    {
        devs_Bobcat2_DC_metro_stackable,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _128K,           /*fdb                        */
                _4K,             /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                36*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _32K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _24K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                _16K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _8K,           /*policersNum                  */
                _8K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                _16K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _32M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _128K,       /* GT_U32  lpmRam, 128K --> 320K LPM lines */
                168,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },   /* end "Bobcat2/Metro stackable devices" */

    /* Caelum - Campus (48+12)*/
    /* Carrier (48+12, Medium scale)
       Carrier (24+12, Medium scale) */
    {
        devs_Bobcat2_bobk_carrier_48and12,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _64K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _6K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                _16K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _32M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _48K,       /* GT_U32  lpmRam, 48K --> 120K LPM lines */
                120,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }   /* Caelum - Campus (48+12) */,

    /* Caelum - Campus Low Scale (48+12)*/
    {
        devs_Bobcat2_bobk_low_scale_48and12,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                256,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                12*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _4K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _4K,              /*GT_U32  routerNextHop;    */
                _2K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _8K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _4K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                TRUNKS_127_NUM_CNS, /*trunk                   */
                                 /*                           */
                /* Transmit Descriptors                       */
                _16K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _32M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _24K,       /* GT_U32  lpmRam, 48K --> 120K LPM lines */
                120,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_1K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }   /* Caelum - Campus (48+12) */,

    /* Caelum - Campus Low Scale (24+12)*/
    {
        devs_Bobcat2_bobk_low_scale_24and12,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                256,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                12*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _4K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _4K,              /*GT_U32  routerNextHop;    */
                _2K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _8K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                TRUNKS_127_NUM_CNS, /*trunk                   */
                                 /*                           */
                /* Transmit Descriptors                       */
                _12K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _24M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _24K,                 /* GT_U32  lpmRam, 24K lines */
                120,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_1K           /* oamEntriesNum                               */
            },

            {
                    /* TR101 Feature support */
                    GT_TRUE, /*tr101Supported*/

                    /* VLAN translation support */
                    GT_TRUE, /*vlanTranslationSupported*/

                    /* Policer Ingress second stage support flag                  */
                    GT_TRUE, /*iplrSecondStageSupported*/

                    /* trunk CRC hash support flag */
                    GT_TRUE, /*trunkCrcHashSupported*/

                    /* TM support flag */
                    GT_FALSE  /* TmSupported */
            }
        }

    }   /* Caelum - Campus (48+12) */,

    /* Carrier Low End (6+6), control plane low scale (8*10G) and (12*10G) */
    {
        devs_Bobcat2_bobk_cetus,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _6K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                _8K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _16M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _16K,       /* GT_U32  lpmRam, 16K --> 40K LPM lines */
                67 ,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }   /* Carrier Low End (6+6), control plane low scale (8*10G) and (12*10G) */,

    {   /* Aldrin devices */
        devs_Aldrin,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                9*_1K,          /* GT_U32 tunnelTerm;         */
                                 /*                           */
                /* tunnel section                             */
                _16K,              /*GT_U32  tunnelStart;     */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                _12K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _24M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _16K,       /* GT_U32  lpmRam, 16K --> 40K LPM lines */
                161 ,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        } /* Aldrin devices */
    },

    {   /* Aldrin Small scale devices */
        devs_Aldrin_small,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _8K,             /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                9*_1K,          /* GT_U32 tunnelTerm;         */
                                 /*                           */
                /* tunnel section                             */
                _1K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _4K,              /*GT_U32  routerNextHop;    */
                _1K,              /*GT_U32  ecmpQos;          */
                _2K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _8K,            /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,           /*policersNum                  */
                _1K / 2,       /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(_1K),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _6K,              /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _12M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _8K,        /* GT_U32  lpmRam, 16K --> 40K LPM lines */
                161,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,NA_TABLE_CNS  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        } /* Aldrin Small scale devices */
    },
    {   /* Aldrin Light devices */
        devs_Aldrin_light,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                9*_1K,          /* GT_U32 tunnelTerm;         */
                                 /*                           */
                /* tunnel section                             */
                _4K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _1K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                _12K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _24M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _8K,       /* GT_U32  lpmRam  */
                161 ,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        } /* Aldrin light devices */
    },

    {   /* AC3+ devices */
        devs_xCat3_Plus,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                9*_1K,          /* GT_U32 tunnelTerm;         */
                                 /*                           */
                /* tunnel section                             */
                _16K,              /*GT_U32  tunnelStart;     */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                _12K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _24M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _16K,       /* GT_U32  lpmRam, 16K --> 40K LPM lines */
                161,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        } /* AC3+ devices */
    },

    {   /* AC3X/24 devices */
        devs_xCat3x_24,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _16K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                9*_1K,          /* GT_U32 tunnelTerm;         */
                                 /*                           */
                /* tunnel section                             */
                _1K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _4K,              /*GT_U32  routerNextHop;    */
                _1K,              /*GT_U32  ecmpQos;          */
                _2K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _8K,            /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,           /*policersNum                  */
                _1K / 2,       /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(_1K),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _6K,              /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _12M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _13K,       /* GT_U32  lpmRam, 16K --> 40K LPM lines */
                141,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        } /* AC3X/24 devices */
    },

    {   /* AC3X/24 Plus devices */
        devs_xCat3x_24_Plus,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                9*_1K,          /* GT_U32 tunnelTerm;         */
                                 /*                           */
                /* tunnel section                             */
                _4K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _8K,            /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(_4K),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _6K,              /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _12M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _16K,       /* GT_U32  lpmRam, 16K --> 40K LPM lines */
                105,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        } /* AC3X/24 Plus devices */
    },

    {   /* AC3X/48 devices */
        devs_xCat3x_48,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _16K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                9*_1K,          /* GT_U32 tunnelTerm;         */
                                 /*                           */
                /* tunnel section                             */
                _1K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _4K,              /*GT_U32  routerNextHop;    */
                _1K,              /*GT_U32  ecmpQos;          */
                _2K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _8K,            /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,           /*policersNum                  */
                _1K / 2,       /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(_1K),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _12K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _24M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _13K,       /* GT_U32  lpmRam, 16K --> 40K LPM lines */
                161,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        } /* AC3X/48 devices */
    },

    {   /* AC3X Plus devices */
        devs_xCat3x_Plus,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                9*_1K,          /* GT_U32 tunnelTerm;         */
                                 /*                           */
                /* tunnel section                             */
                _4K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _8K,            /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(_1K),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _12K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _24M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _16K,       /* GT_U32  lpmRam, 16K --> 40K LPM lines */
                169,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        } /* AC3X/48 Plus devices */
    },

    {   /* Medium scale), Drake - Control Plane Medium Scale (16/24G) */
        devs_Bobcat2_control_plane,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _64K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _8K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _6K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                _16K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _32M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _48K,       /* GT_U32  lpmRam, 48K --> 120K LPM lines */
                168,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        } /* Medium scale), Drake - Control Plane Medium Scale (16/24G) */
    },
    { /* Bobcat2/Carrier Small scale devices */
        devs_Bobcat2_Carrier_small,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K,             /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                _12K,            /*GT_U32  ecmpQos;           */
                _8K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                6*_1K,          /*policersNum                 */
                _4K,            /*egressPolicersNum           */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                _8K,              /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _16M,                 /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _16K,                /* GT_U32  lpmRam,  128K --> 320K LPM lines */
                58,                  /* pipeBWCapacityInGbps for revision B0, revision A0 is set from code , abd not from table*/
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }   /* end "Bobcat2/Carrier Small scale devices" */
};
static const GT_U32 bobcat2Tables_size = sizeof(bobcat2Tables)/sizeof(bobcat2Tables[0]);

/* list of the Bobcat3 : Data center switch fabric High scale */
static const CPSS_PP_DEVICE_TYPE devs_Bobcat3_DC[]=
        {
            CPSS_98CX8410_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

static const CPSS_PP_DEVICE_TYPE devs_Bobcat3_DC_fabric[]=
        {
            CPSS_98CX8420_CNS,
            CPSS_98CX8420_GM_USED_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Bobcat3 : Data center switch interconnect */
static const CPSS_PP_DEVICE_TYPE devs_Bobcat3_DC_interconnect[]=
        {
            CPSS_98CX8405_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* Bobcat3 - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC bobcat3Tables[]=
{
    { /* Bobcat3 : Data center switch fabric */
        devs_Bobcat3_DC,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                               */
                _64K,            /*fdb                        v */
                _4K,             /*vidxNum                    v */
                _1K,             /*stgNum                       */
                                 /*                             */
                /* TCAM section                                 */
                0,               /* GT_U32 router;              */
                18*_1K,          /* GT_U32 tunnelTerm;        v */
                                 /*                             */
                /* tunnel section                               */
                _16K,             /*GT_U32  tunnelStart;        */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;        */
                                 /*                             */
                /* ip section                                   */
                _12K,             /*GT_U32  routerNextHop;    v */
                _12K,             /*GT_U32  ecmpQos;            */
                _8K,             /*GT_U32  mllPairs;           */
                                 /*                             */
                /* PCL section                                  */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                             */
                /* CNC section                                  */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          v */
                _16K,           /* GT_U32 cncBlockNumEntries; v */

                /*  Policer Section                             */
                /* NOTE: 4K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _4K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                48*_1K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                96*_1M,              /*GT_U32 bufferMemory;      */  /*96 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _32K,               /* GT_U32  lpmRam,  128K --> 320K LPM lines */
                310,                 /* pipeBWCapacityInGbps */
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },

    { /* Bobcat3 : Data center switch fabric High scale */
        devs_Bobcat3_DC_fabric,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _256K,           /*fdb                        */
                _4K,             /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                36*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _64K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _24K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                _16K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 16K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _16K,           /*policersNum                  */
                _16K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                48*_1K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                96*_1M,              /*GT_U32 bufferMemory;      */  /*96 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _128K,               /* GT_U32  lpmRam,  128K --> 320K LPM lines */
                168,                 /* pipeBWCapacityInGbps for revision B0, revision A0 is set from code , abd not from table*/
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_8K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },

    { /* Bobcat3 : Data center switch interconnect */
        devs_Bobcat3_DC_interconnect,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                               */
                _64K,            /*fdb                        v */
                _4K,             /*vidxNum                    v */
                _1K,             /*stgNum                       */
                                 /*                             */
                /* TCAM section                                 */
                0,               /* GT_U32 router;              */
                18*_1K,          /* GT_U32 tunnelTerm;        v */
                                 /*                             */
                /* tunnel section                               */
                _16K,             /*GT_U32  tunnelStart;        */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;        */
                                 /*                             */
                /* ip section                                   */
                _12K,             /*GT_U32  routerNextHop;    v */
                _12K,             /*GT_U32  ecmpQos;            */
                _8K,             /*GT_U32  mllPairs;           */
                                 /*                             */
                /* PCL section                                  */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                             */
                /* CNC section                                  */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          v */
                _16K,           /* GT_U32 cncBlockNumEntries; v */

                /*  Policer Section                             */
                /* NOTE: 4K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _4K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                48*_1K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                96*_1M,              /*GT_U32 bufferMemory;      */  /*96 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _32K,               /* GT_U32  lpmRam,  32K --> 80K LPM lines */
                310,                 /* pipeBWCapacityInGbps */
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }
    /* end : Bobcat3 : Data center switch fabric High scale */
};
static const GT_U32 bobcat3Tables_size = sizeof(bobcat3Tables)/sizeof(bobcat3Tables[0]);

/* list of the Armstrong : Enterprise High scale */
static const CPSS_PP_DEVICE_TYPE devs_Armstrong_Enterprise_high_scale[]=
        {
            CPSS_98EX5424_CNS,
            CPSS_98EX5430_CNS,
            CPSS_98EX5431_CNS,
            CPSS_98EX5432_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Armstrong : Enterprise Mid scale */
static const CPSS_PP_DEVICE_TYPE devs_Armstrong_Enterprise_mid_scale[]=
        {
            CPSS_98EX5410_CNS,
            CPSS_98EX5420_CNS,
            CPSS_98EX5422_CNS,
            CPSS_98EX5421_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* Armstrong - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC armstrongTables[]=
{
    { /* Armstrong : Enterprise High scale */
        devs_Armstrong_Enterprise_high_scale,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _256K,           /*fdb                        */
                _4K,             /*vidxNum                    */
                _2K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                36*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _32K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _24K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                _16K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 16K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _16K,           /*policersNum                  */
                _16K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                48*_1K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                96*_1M,              /*GT_U32 bufferMemory;      */  /*96 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _128K,               /* GT_U32  lpmRam,  128K --> 320K LPM lines */
                168,                 /* pipeBWCapacityInGbps for revision B0, revision A0 is set from code , abd not from table*/
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }   /* end : Armstrong : Enterprise High scale */
    ,
    { /* Armstrong : Enterprise Mid scale */
        devs_Armstrong_Enterprise_mid_scale,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _128K,           /*fdb                        */
                _4K,             /*vidxNum                    */
                _2K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _16K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                 _8K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                 _8K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _16K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 8K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _8K,           /*policersNum                  */
                _8K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                40*_1K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                80*_1M,              /*GT_U32 bufferMemory;      */  /*80 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _64K,                /* GT_U32  lpmRam,  64K --> 160K LPM lines */
                168,                 /* pipeBWCapacityInGbps for revision B0, revision A0 is set from code , abd not from table*/
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }   /* end : Armstrong : Enterprise Mid scale */

};
static const GT_U32 armstrongTables_size = sizeof(armstrongTables)/sizeof(armstrongTables[0]);

/* list of the Aldrin2 : Enterprise High scale */
static const CPSS_PP_DEVICE_TYPE devs_Aldrin2_Enterprise_high_scale[]=
        {
            CPSS_98EX5520_CNS,
            CPSS_98EX5524_CNS,
            CPSS_98DX4310_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Aldrin2 : Enterprise Mid scale */
static const CPSS_PP_DEVICE_TYPE devs_Aldrin2_Enterprise_mid_scale[]=
        {
            CPSS_98DX8524_CNS,
            CPSS_98DX8525_CNS,
            CPSS_98DX8548_CNS,
            CPSS_98DX8548_H_CNS,
            CPSS_98DX8448_CNS,
            CPSS_98DX8410_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Aldrin2 : Enterprise Low scale */
static const CPSS_PP_DEVICE_TYPE devs_Aldrin2_Enterprise_low_scale[]=
        {
            CPSS_98DX8515_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Aldrin2 : Enterprise Mid scale light */
static const CPSS_PP_DEVICE_TYPE devs_Aldrin2_Enterprise_mid_scale_light[]=
        {
            CPSS_98DX8648_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* Aldrin2 - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC aldrin2Tables[]=
{
    { /* Aldrin2 : Enterprise High scale */
        devs_Aldrin2_Enterprise_high_scale,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _128K,           /*fdb                        */
                _4K,             /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _16K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _24K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                _8K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 8K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _8K,           /*policersNum                  */
                _8K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                40*_1K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                80*_1M,              /*GT_U32 bufferMemory;      */  /*10 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _64K,               /* GT_U32  lpmRam,  64K --> 160K LPM lines */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_8K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },   /* end : Aldrin2 : Enterprise High scale */

    { /* Aldrin2 : Enterprise Mid scale */
        devs_Aldrin2_Enterprise_mid_scale,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                _9K,             /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;    */
                _8K,             /*GT_U32  ecmpQos;          */
                _8K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 8K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                24*_1K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                48*_1M,              /*GT_U32 bufferMemory;      */  /*10 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _16K,               /* GT_U32  lpmRam,  64K --> 160K LPM lines */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },   /* end : Aldrin2 : Enterprise Mid scale */

    { /* Aldrin2 : Enterprise Low scale */
        devs_Aldrin2_Enterprise_low_scale,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                _9K,             /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _4K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                _4K,             /*GT_U32  ecmpQos;           */
                _4K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _8K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 2K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                24*_1K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                48*_1M,              /*GT_U32 bufferMemory;      */  /*10 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _16K,               /* GT_U32  lpmRam,  64K --> 160K LPM lines */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },   /* end : Aldrin2 : Enterprise Low scale */

    { /* Aldrin2 : Enterprise Mid scale light */
        devs_Aldrin2_Enterprise_mid_scale_light,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                _9K,             /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _4K,             /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _4K,             /*GT_U32  routerNextHop;     */
                _8K,             /*GT_U32  ecmpQos;           */
                _8K/2,           /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 2K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                _1K,        /*trunk                           */
                                 /*                           */
                /* Transmit Descriptors                       */
                24*_1K,             /*GT_U32 transmitDescr;   */
                                 /*                           */
                /* Buffer Memory                              */
                48*_1M,              /*GT_U32 bufferMemory;      */  /*10 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _8K,               /* GT_U32  lpmRam */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
               ,NA_TABLE_CNS  /* emNum                            */
               ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }   /* end : Aldrin2 : Enterprise Mid scale light */
};
static const GT_U32 aldrin2Tables_size = sizeof(aldrin2Tables)/sizeof(aldrin2Tables[0]);

/* list of the Aldrin2 XL */
static const CPSS_PP_DEVICE_TYPE devs_Aldrin2_XL[]=
        {
            CPSS_98DX8572_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* Aldrin XL - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC aldrinXlTables[]=
{
    { /* Aldrin2 XL */
        devs_Aldrin2_XL,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _64K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _16K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _16K,             /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _8K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 8K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _4K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                48*_1K,             /*GT_U32 transmitDescr;   */
                                 /*                           */
                /* Buffer Memory                              */
                96*_1M,              /*GT_U32 bufferMemory;   */  /*96 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _128K,               /* GT_U32  lpmRam,  128K --> 320K LPM lines */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS         /* bpePointToPointEChannels  */
                ,NA_TABLE_CNS  /* emNum                                       */
                ,_4K           /* vrfIdNum                                    */
                ,_2K           /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }   /* end : Armstrong : Enterprise High scale */
};

static const GT_U32 aldrinXlTables_size = sizeof(aldrinXlTables)/sizeof(aldrinXlTables[0]);

/* list of the Falcon : Data center switch fabric High scale */
static const CPSS_PP_DEVICE_TYPE devs_Falcon_1_tile[]=
        {
            CPSS_98CX8513_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };
static const CPSS_PP_DEVICE_TYPE devs_Falcon_2_tiles[]=
        {
            CPSS_98CX8520_CNS,
            CPSS_98CX8525_CNS,
            CPSS_98CX8540_CNS,
            CPSS_98CX8540_H_CNS,
            CPSS_98CX8522_CNS,
            CPSS_98CX8530_CNS,
            CPSS_98CX8535_CNS,
            CPSS_98CX8535_H_CNS,
            CPSS_98CX8512_CNS,
            CPSS_98CX8514_CNS,
            CPSS_98EX5610_CNS,
            CPSS_98EX5614_CNS,
            CPSS_98EX5630_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };
static const CPSS_PP_DEVICE_TYPE devs_Falcon_4_tiles[]=
        {
            CPSS_98CX8580_CNS,
            CPSS_98CX8580_E_CNS,
            CPSS_98CX8550_CNS,
            CPSS_98CX8580_10_CNS,
            CPSS_98CX8542_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

#ifndef _14K
    #define _14K    (14 * _1K)
#endif
/* max lines in falcon */
#define FALCON_MAX_LPM_CNS ((_14K*28)+(2*640))
/* max lines in Hawk */
#define HAWK_MAX_LPM_CNS   ((_10K*28)+(2*640))
/* max lines in AC5P (98DX4504, 98DX4504M)  - 4 banks */
#define HAWK_MAX_LPM_4_BANKS_CNS   ((_10K*4)+(20*640))
/* max lines in Phoenix */
#define PHOENIX_MAX_LPM_CNS ((_1K*28)+(2*640))

/* Falcon - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC falconTables[]=
{
    { /* Falcon : Data center switch fabric */
        devs_Falcon_1_tile,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _256K,           /*fdb                        */  /*shared tables:FDB,ARP,LPM,EM */
                _4K,             /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _48K,             /*GT_U32  tunnelStart;      */  /*shared tables:FDB,ARP,LPM,EM */
        /*192K*/AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */  /*shared tables:FDB,ARP,LPM,EM */
                                 /*                           */
                /* ip section                                 */
                _24K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                _8K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 4K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _4K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                (96 *_1K),             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                (96 / 8)*_1M,              /*GT_U32 bufferMemory;      */  /*96 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                PRV_CPSS_DXCH_SIP6_LPM_RAM_GET_NUM_OF_PREFIXES_MAC(FALCON_MAX_LPM_CNS),       /* GT_U32  lpmRam,  */  /*shared tables:FDB,ARP,LPM,EM */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS,        /* bpePointToPointEChannels  */
                _128K,               /*emNum                      */  /*shared tables:FDB,ARP,LPM,EM */
                _4K,                 /* vrfIdNum                                    */
                _1K                  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },
    { /* Falcon : Data center switch fabric */
        devs_Falcon_2_tiles,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _256K,           /*fdb                        */  /*shared tables:FDB,ARP,LPM,EM */
                _4K,             /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _48K,             /*GT_U32  tunnelStart;      */  /*shared tables:FDB,ARP,LPM,EM */
        /*192K*/AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */  /*shared tables:FDB,ARP,LPM,EM */
                                 /*                           */
                /* ip section                                 */
                _24K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                _8K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 4K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _4K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                (192 *_1K),             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                (192 / 8)*_1M,              /*GT_U32 bufferMemory;      */  /*192 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                PRV_CPSS_DXCH_SIP6_LPM_RAM_GET_NUM_OF_PREFIXES_MAC(FALCON_MAX_LPM_CNS),       /* GT_U32  lpmRam,  */  /*shared tables:FDB,ARP,LPM,EM */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS,        /* bpePointToPointEChannels  */
                _128K,               /*emNum                      */  /*shared tables:FDB,ARP,LPM,EM */
                _4K,                 /* vrfIdNum                                    */
                _1K                  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },
    { /* Falcon : Data center switch fabric */
        devs_Falcon_4_tiles,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _256K,           /*fdb                        */  /*shared tables:FDB,ARP,LPM,EM */
                _4K,             /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _48K,             /*GT_U32  tunnelStart;      */  /*shared tables:FDB,ARP,LPM,EM */
        /*192K*/AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */  /*shared tables:FDB,ARP,LPM,EM */
                                 /*                           */
                /* ip section                                 */
                _24K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                _8K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 4K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _4K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                (384 *_1K),             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                (384 / 8)*_1M,              /*GT_U32 bufferMemory;      */  /*384 MBits*/
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                PRV_CPSS_DXCH_SIP6_LPM_RAM_GET_NUM_OF_PREFIXES_MAC(FALCON_MAX_LPM_CNS),       /* GT_U32  lpmRam,  */  /*shared tables:FDB,ARP,LPM,EM */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS,        /* bpePointToPointEChannels  */
                _128K,               /*emNum                      */  /*shared tables:FDB,ARP,LPM,EM */
                _4K,                 /* vrfIdNum                                    */
                _1K                  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }
};
static const GT_U32 falconTables_size = sizeof(falconTables)/sizeof(falconTables[0]);

static const CPSS_PP_DEVICE_TYPE devs_hawk_98DX4504[]=
        {
            PRV_CPSS_AC5P_98DX4504_DEVICE,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

static const CPSS_PP_DEVICE_TYPE devs_hawk_common[]=
        {
            PRV_CPSS_AC5P_COMMON_DEVICES,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

static const CPSS_PP_DEVICE_TYPE devs_hawk_extended[]=
        {
            PRV_CPSS_AC5P_EXTENDED_DEVICES,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* Hawk - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC hawkTables[]=
{
    { /* hawk : Data center switch fabric */
        devs_hawk_common,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _128K,           /*fdb                        */  /*shared tables:FDB,ARP,LPM,EM */
                _12K,            /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
               36 *_1K,          /* GT_U32 tunnelTerm;        */ /* 18K * 20bytes (36K * 10) */
                                 /*                           */
                /* tunnel section                             */
                (_192K/*ARPs*//4),   /*GT_U32  tunnelStart;   */  /*shared tables:FDB,ARP,LPM,EM */
        /*_192K*/AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;     */  /*shared tables:FDB,ARP,LPM,EM */
                                 /*                           */
                /* ip section                                 */
                _16K,            /*GT_U32  routerNextHop;     */
                _4K,             /*GT_U32  ecmpQos;           */
                _16K/2,          /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 4K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _4K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                64*_1K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                64*_1M,              /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                PRV_CPSS_DXCH_SIP6_LPM_RAM_GET_NUM_OF_PREFIXES_MAC(HAWK_MAX_LPM_CNS),       /* GT_U32  lpmRam,  */  /*shared tables:FDB,ARP,LPM,EM */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS,        /* bpePointToPointEChannels  */
                _128K,               /*emNum                      */  /*shared tables:FDB,ARP,LPM,EM */
                _4K,                 /* vrfIdNum                                    */
                _2K                  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },
    { /* hawk : 98DX4504 */
        devs_hawk_98DX4504,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,           /*fdb                        */  /*shared tables:FDB,ARP,LPM,EM */
                _12K,            /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */ /* 9K * 20bytes (18K * 10bytes) */
                                 /*                           */
                /* tunnel section                             */
                (_16K/*ARPs*//4),   /*GT_U32  tunnelStart;   */  /*shared tables:FDB,ARP,LPM,EM */
        /*_16K*/AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;     */  /*shared tables:FDB,ARP,LPM,EM */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                _4K,             /*GT_U32  ecmpQos;           */
                _8K/2,           /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _16K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 2K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                64*_1K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                64*_1M,              /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                PRV_CPSS_DXCH_SIP6_LPM_RAM_GET_NUM_OF_PREFIXES_MAC(HAWK_MAX_LPM_4_BANKS_CNS), /* GT_U32  lpmRam,  */  /*shared tables:FDB,ARP,LPM,EM */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS,        /* bpePointToPointEChannels  */
                _32K,                 /*emNum                      */  /*shared tables:FDB,ARP,LPM,EM */
                _4K,                 /* vrfIdNum                                    */
                _2K                  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },
    { /* hawk with extended memories */
        devs_hawk_extended,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _256K,           /*fdb                        */  /*shared tables:FDB,ARP,LPM,EM */
                _12K,            /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
               48 *_1K,          /* GT_U32 tunnelTerm;        */ /* 24K * 20bytes (48K * 10) */
                                 /*                           */
                /* tunnel section                             */
                (_256K/*ARPs*//4),   /*GT_U32  tunnelStart;   */  /*shared tables:FDB,ARP,LPM,EM */
        /*_256K*/AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;     */  /*shared tables:FDB,ARP,LPM,EM */
                                 /*                           */
                /* ip section                                 */
                _16K,            /*GT_U32  routerNextHop;     */
                _4K,             /*GT_U32  ecmpQos;           */
                _16K/2,          /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _64K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 4K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _4K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                64*_1K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                64*_1M,              /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                PRV_CPSS_DXCH_SIP6_LPM_RAM_GET_NUM_OF_PREFIXES_MAC(HAWK_MAX_LPM_CNS),       /* GT_U32  lpmRam,  */  /*shared tables:FDB,ARP,LPM,EM */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS,        /* bpePointToPointEChannels  */
                _256K,               /*emNum                      */  /*shared tables:FDB,ARP,LPM,EM */
                _4K,                 /* vrfIdNum                                    */
                _2K                  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    }
};
static const GT_U32 hawkTables_size = sizeof(hawkTables)/sizeof(hawkTables[0]);

/* list of the Phoenix : common */
static const CPSS_PP_DEVICE_TYPE devs_phoenix_common[]=
        {
            PRV_CPSS_AC5X_ALL_DEVICES,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* Phoenix - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC phoenixTables[]=
{
    { /* Phoenix : common */
        devs_phoenix_common,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _12K,            /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,/*9K@20B*//* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                (_16K/*ARPs*//4),   /*GT_U32  tunnelStart;   */
        /*_16K*/AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;     */
                                 /*                          */
                /* ip section                                */
                _8K,             /*GT_U32  routerNextHop;    */
                _4K,             /*GT_U32  ecmpQos;          */
                _4K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _16K,/*single unit*//* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 2K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                24*_1K,          /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                24*_1M,              /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                PRV_CPSS_DXCH_SIP6_LPM_RAM_GET_NUM_OF_PREFIXES_MAC(PHOENIX_MAX_LPM_CNS),       /* GT_U32  lpmRam,  */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS,        /* bpePointToPointEChannels  */
                _32K,               /*emNum                      */
                _4K,                 /* vrfIdNum                                    */
                _2K                  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },
};
static const GT_U32 phoenixTables_size = sizeof(phoenixTables)/sizeof(phoenixTables[0]);

/* list of the Harrier : common */
static const CPSS_PP_DEVICE_TYPE devs_harrier_common[]=
        {
            PRV_CPSS_HARRIER_ALL_DEVICES,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };
/* Harrier - fine tuning table  sizes according to devices flavors */
static const FINE_TUNING_STC harrierTables[]=
{
    { /* Harrier : common */
        devs_harrier_common,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _12K,            /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                9*_1K,/*4.5K@20B*//* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                (_16K/*ARPs*//4),   /*GT_U32  tunnelStart;   */
        /*_16K*/AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;     */
                                 /*                          */
                /* ip section                                */
                _8K,             /*GT_U32  routerNextHop;    */
                _4K,             /*GT_U32  ecmpQos;          */
                _4K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _16K,/*single unit*//* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                /* NOTE: 2K is shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members (using hwInfo.parametericTables.numEntriesL2Ecmp)*/
                                 /*                           */
                /* Transmit Descriptors                       */
                40*_1K,             /*GT_U32 transmitDescr;     */  CPSS_TBD_BOOKMARK_PHOENIX
                                 /*                           */
                /* Buffer Memory                              */
                6*_1M,              /*GT_U32 bufferMemory;      */  /*6 MBits - 128B/buffer */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                PRV_CPSS_DXCH_SIP6_LPM_RAM_GET_NUM_OF_PREFIXES_MAC(PHOENIX_MAX_LPM_CNS),       /* GT_U32  lpmRam,  */
                AUTO_CALC_FIELD_CNS, /* pipeBWCapacityInGbps auto calculated by hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet */
                NA_TABLE_CNS,        /* bpePointToPointEChannels  */
                _32K,               /*emNum                      */
                _4K,                 /* vrfIdNum                                    */
                _2K                  /* oamEntriesNum                               */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE  /* TmSupported */
            }
        }
    },
};
static const GT_U32 harrierTables_size = sizeof(harrierTables)/sizeof(harrierTables[0]);


/* array of additional FEr/RM WA for the xcat and above */
static const GT_U32 xcatA1ErrAndRmArray[]=
{
    /* RM - xcat */
    PRV_CPSS_DXCH_XCAT_RM_TOTAL_BUFFER_LIMIT_CONF_IN_TXQ_E,/*RM#3008*/
    PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E,/*RM#3009*/
    PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICY_ENGINE_CONFIGURATION_REGISTER_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_TXQ_DEQUEUE_SWRR_WEIGHT_REGISTER_3_WA_E,/*RM#3007*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E,/*RM#3005*/
    PRV_CPSS_DXCH_XCAT_RM_PORT_SERIAL_PARAMETERS_CONFIGURATION_WA_E,/*RM#3004*/
    PRV_CPSS_DXCH_XCAT_RM_LMS0_LMS1_MISC_CONFIGURATIONS_WA_E,/*RM#3002*,RM#3003*/
    PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E,/*RM#3024*/
    PRV_CPSS_DXCH_XCAT_TOD_NANO_SEC_SET_WA_E,/*FEr#2773*/
    PRV_CPSS_DXCH_XCAT_ETH_OVER_IPV4_GRE_WA_E,
    PRV_CPSS_DXCH_XCAT_PASSENGER_ETH_PACKET_CRC_CANT_BE_RETAINED_WA_E, /*FEr#2785*/

    PRV_CPSS_DXCH_XCAT_RM_MAC_CTRL_REG3_PCS_PREAMBLE_WA_E,
    PRV_CPSS_DXCH_XCAT_RM_METAL_FIX_SGMII25G_DPCLK_SEL_WA_E,
    PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_CCFC_SRC_PORT_WA_E,

    PRV_CPSS_DXCH_XCAT_TX_CPU_CORRUPT_BUFFER_WA_E,/*FEr#3048*/
    PRV_CPSS_DXCH_XCAT_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E,/*FEr#3033*/
    PRV_CPSS_DXCH_XCAT_IEEE_RESERVED_MC_CONFG_REG_READ_WA_E,/*FEr#3060*/
    PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E, /*FEr#2739*/
    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E, /*FEr#2794*/
    PRV_CPSS_DXCH_XCAT_FC_FORWARD_NOT_FUNCTIONAL_WA_E, /*FEr#3102*/
    PRV_CPSS_DXCH_XCAT_RM_SSMII_PAD_ZNR_ZPR_WA_E, /*RM#3042*/
    PRV_CPSS_DXCH_XCAT_RM_PASSENGER_TPID_REG_WA_E, /*RM#3043*/

    /* FEr from legacy device */
    PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E,/*FEr#47*/
    PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E,/*FEr#3119*/

    PRV_CPSS_DXCH3_POLICY_AND_ROUTER_TCAM_TABLES_INDIRECT_READ_WA_E,/*FEr#2004*/
    PRV_CPSS_DXCH3_RM_LMS0_1_GROUP1_LED_INTERFACE_WA_E,/*RM#2024*/
    PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E,/*FEr#2028*/
    PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E,/*FEr#2033,FEr#2050*/

    /* RM - from legacy device */
    PRV_CPSS_DXCH3_RM_BM_GE_XG_PORT_GROUP_LIMIT_CFG_REG_WA_E,/*RM#2003*/
    PRV_CPSS_DXCH3_RM_GE_PORTS_MODE1_REG_WA_E,/*RM#2007*/
    PRV_CPSS_DXCH3_RM_XG_PORTS_MODE_REG_WA_E,/*RM#2008*/
    PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E,/*RM#3018*/
    PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E,/*RM#3014*/

    /*  VLT direct access write problem with VLAN and STP tables (entry > 1 word) */
    PRV_CPSS_DXCH3_VLT_TABLES_WRITE_DIRECT_ACCESS_WA_E,

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of additional FEr/RM WA for the xcat3 */
static const GT_U32 xcat3ErrAndRmArray[]=
{
    PRV_CPSS_DXCH_XCAT3_UC_LOCAL_SWITCH_FILTER_FOR_VIRTUAL_PORTS_WA_E,/*FEr#31600*/
    PRV_CPSS_DXCH_XCAT3_TRUNK_ID_ASSIGN_INSTEAD_OF_VIRTUAL_PORT_WA_E,/*FEr#1000365*/
    PRV_CPSS_DXCH_XCAT3_OAM_LB_PORT_NOT_GETTING_HIGHEST_QOS_WA_E,/*FEr#27970*/
    PRV_CPSS_DXCH_BOBCAT2_FC_SENT_COUNTERS_PROBLEM_WHEN_FCU_BYPASS_DISABLE_WA_E,/* FE-5101126 */
    PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E,
    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E,
    PRV_CPSS_DXCH_XCAT3_GIG_MAC_HALF_DUPLEX_COLLISION_DOMAIN_RM_E,/*RM-6302994*/
    PRV_CPSS_DXCH_LION2_PORT_MAC_MIB_COUNTERS_CORRUPTION_WA_E,
    PRV_CPSS_DXCH_XCAT3_XLG_PORT_DROP_EVENT_PROBLEM_RM_E,/*RM#6565603*/
    PRV_CPSS_DXCH_XCAT3_RM_RX_SDMA_WRONG_QUEUE_WA_E, /* RM-8732277*/
    PRV_CPSS_DXCH_IMPLEMENT_WA_2_5G_SGMII_LINK_UP_E, /*HWEr#3065*/
    PRV_CPSS_DXCH_BOBCAT2_FORCE_DOWN_LINK_PARTNER_WA_E, /* FEr#7371866 */
    PRV_CPSS_DXCH_XCAT3_TCP_SYN_WITH_DATA_E, /* FE-2001166 */

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of additional FEr/RM WA for the Lion2 */
static const GT_U32 lion2ErrAndRmArray[]=
{
    /* Lion2 FEr */
    PRV_CPSS_DXCH_LION2_FAST_FAILOVER_WA_E,
    PRV_CPSS_DXCH_LION2_RM_TTI_DUAL_DEV_ENABLE_WA_E,
    PRV_CPSS_DXCH_LION2_HGL_MAC_INT_WA_E,
    PRV_CPSS_DXCH_LION2_LOCAL_SRC_PORT_DEV_MAP_ENABLE_WA_E,

    PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_MLL_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E, /* FE-8054972 */
    PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_BMA_MC_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E, /* FE-8071239 */
    PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_CPFC_THRESHOLDS_WA_E, /* RM-9082194*/
    PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_PFC_THRESHOLDS_WA_E,  /* RM-8035267*/
    PRV_CPSS_DXCH_LION2_RM_LLFC_TRIGGER_GLOBAL_CONFIGURATION_WA_E, /*RM-8439088*/
    PRV_CPSS_DXCH_LION2_RM_ENABLE_PFC_TRIGGER_WA_E, /*RM-9987707*/
    PRV_CPSS_DXCH_LION2_RM_GLOBAL_XOFF_ACTIVATION_ON_PORT_WA_E, /*RM-2466587*/
    PRV_CPSS_DXCH_LION2_RM_WRONG_GIG_DESC_FIFO_THRESHOLD_WA_E,  /* RM-261461 */

    /* Lion FEr */
#if 0 /* this erratum was partially fixed , and can be together with filter according to hemisphere# */
    PRV_CPSS_DXCH_LION_PREVENT_REDUNDANT_AU_FU_MESSAGES_NOT_SUPPORTED_WA_E,/*2769*/
#endif/*0*/
    PRV_CPSS_DXCH_LION_POLICER_COUNTING_MEM_ACCESS_WA_E, /*FEr#2771*/
    PRV_CPSS_DXCH_LION_CN_GLOBAL_REG_WA_E,/*FEr#2768*/
    PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E,/*???*/
    PRV_CPSS_DXCH_LION_TEMPERATURE_SENSOR_INITIALIZATION_WA_E , /*???*/
    PRV_CPSS_DXCH_LION_RM_SD_PLL_REG_WA_E, /* HWE#27060 */
    PRV_CPSS_DXCH_LION_SLOW_RATE_ON_PORT_TB_NOT_SUPPORTED_WA_E,
    PRV_CPSS_DXCH_LION_WRONG_COUNTING_OF_IP_COUNTERS_PER_PORT_WA_E, /* FEr#3116 */

    /* RM Lion */
    PRV_CPSS_DXCH_LION_RM_SDMA_ACTIVATION_WA_E,/*Rm#2701*/
    PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E,/*RM#2705*/
    PRV_CPSS_DXCH_LION_RM_TCAM_CONFIG_WA_E,/*RM#3013*/
    PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_FDB_LIMIT_WA_E,/*RM#2702*/
    PRV_CPSS_DXCH_LION_RM_ORIG_SRC_PORT_FILTERING_WA_E,/*RM#2706*/
    PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_CPU_IN_VIDX_WA_E,/*RM#2707*/
    PRV_CPSS_DXCH_LION_RM_UC_STRICT_OVER_MC_WA_E, /*RM#2710*/
    PRV_CPSS_DXCH_LION_RM_SCHEDULER_DEFICIT_MODE_WA_E, /*RM#2709*/
    PRV_CPSS_DXCH_LION_RM_TX_MC_IN_CHUNKS_WA_E, /*RM#2711*/
    PRV_CPSS_DXCH_LION_RM_BUFF_LIMIT_EGRESS_QUEUE_WA_E, /*RM#2712*/
    PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E,/*???*/

    /* FEr from legacy devices */
    PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E,/*FEr#47*/
    PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E,/*FEr#2033,FEr#2050*/
    PRV_CPSS_DXCH3_POLICY_AND_ROUTER_TCAM_TABLES_INDIRECT_READ_WA_E,/*FEr#2004 --> part of FEr#2744*/
    PRV_CPSS_DXCH_XCAT_IEEE_RESERVED_MC_CONFG_REG_READ_WA_E,/*FEr#3060*/
    PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E,/*FEr#2028*/

    /* RM - from legacy device */
/*  not needed in Lion-B (like xcat) already in correct values.  PRV_CPSS_DXCH3_RM_MAC2ME_LOW_REG_WA_E, RM#2026*/
    PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E,/*RM# 30160*/
    PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E,/*RM#3005*/
    PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E,/*RM#3009*/
    PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E,/*RM#3024*/
    PRV_CPSS_DXCH_XCAT_TOD_NANO_SEC_SET_WA_E,/*FEr#2773*/

    PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICY_ENGINE_CONFIGURATION_REGISTER_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/
/* not relevant to lion   PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E,(part of RM#3012)*/
/* not relevant to lion   PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E,(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/

    PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E,/*RM#3018*/
    PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E,/*RM#3014*/

    PRV_CPSS_DXCH_LION_XLG_WS_SUPPORT_WA_E, /* FEr#2709 */
    /* not relevant to lion2 PRV_CPSS_DXCH_LION_PFC_FOR_MANY_PRIORITY_WA_E*, *FEr#2787 */
    PRV_CPSS_DXCH_LION_QCN_FORMAT_COMPLIANT_WA_E, /* FEr#2703 */
    PRV_CPSS_DXCH_LION_INACCURATE_PFC_XOFF_WA_E, /* RM#2788 */
    PRV_CPSS_DXCH_LION_INCOMPLETE_CPU_MAILBOX_INFO_WA_E, /* FEr#2776 */

    PRV_CPSS_DXCH_XCAT2_RM_POLICER_MEM_CONTROL_WA_E, /*RM#3029*/

    PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E,/* FE-7263524 */

    PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E, /*FE_6041254*/

    PRV_CPSS_DXCH_LION2_SCHEDULER_PROFILE_UNDER_TRAFFIC_WA_E, /* FE-221066 */

    PRV_CPSS_DXCH3_SDMA_WA_E,
    PRV_CPSS_DXCH_LION2_PORT_MAC_MIB_COUNTERS_CORRUPTION_WA_E, /* FE-9085687 */
    PRV_CPSS_DXCH_BOBCAT2_FORCE_DOWN_LINK_PARTNER_WA_E, /* FEr#7371866 */

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of FEr/RM WA for the Bobcat2 */
static const GT_U32 bobcat2ErrAndRmArray[]=
{
    /* Lion2 FEr */
/* Bobcat2; Caelum; Bobcat3 fixed - no hemisphere limitations -   PRV_CPSS_DXCH_LION2_FAST_FAILOVER_WA_E,*/
/* Bobcat2; Caelum; Bobcat3 - no dual device issues -   PRV_CPSS_DXCH_LION2_RM_TTI_DUAL_DEV_ENABLE_WA_E,*/
/* Bobcat2; Caelum; Bobcat3 - no meaning for simulation , and cause crash ...    PRV_CPSS_DXCH_LION2_HGL_MAC_INT_WA_E,*/
/* Bobcat2; Caelum; Bobcat3 fixed - no local port limitations -       PRV_CPSS_DXCH_LION2_LOCAL_SRC_PORT_DEV_MAP_ENABLE_WA_E,*/

    PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_PFC_THRESHOLDS_WA_E,  /* RM-8035267*/
    PRV_CPSS_DXCH_LION2_RM_LLFC_TRIGGER_GLOBAL_CONFIGURATION_WA_E, /*RM-8439088*/
    PRV_CPSS_DXCH_LION2_RM_ENABLE_PFC_TRIGGER_WA_E, /*RM-9987707*/

    /* Lion FEr */
/* Bobcat2; Caelum; Bobcat3 fixed - as only single FDB instance - PRV_CPSS_DXCH_LION_PREVENT_REDUNDANT_AU_FU_MESSAGES_NOT_SUPPORTED_WA_E,2769*/
/*    PRV_CPSS_DXCH_LION_POLICER_COUNTING_MEM_ACCESS_WA_E, */ /*FEr#2771*/

    CPSS_TBD_BOOKMARK_EARCH
/*  closed only for TXQ alignment - should be checked later  PRV_CPSS_DXCH_LION_CN_GLOBAL_REG_WA_E, */ /*FEr#2768*/

/* removed in Bobcat2; Caelum; Bobcat3 - not relevant   PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E,*???*/
/* Bobcat2; Caelum; Bobcat3 - removed until proven needed -   PRV_CPSS_DXCH_LION_TEMPERATURE_SENSOR_INITIALIZATION_WA_E ,*/ /*???*/
/* Bobcat2; Caelum; Bobcat3 - (no such MG registers that relevant to the WA)-
    PRV_CPSS_DXCH_LION_RM_SD_PLL_REG_WA_E,  HWE#27060 */
/* removed in Bobcat2; Caelum; Bobcat3 - not relevant       PRV_CPSS_DXCH_LION_WRONG_COUNTING_OF_IP_COUNTERS_PER_PORT_WA_E, --- FEr#3116 */

    /* RM Lion */
    PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E,/*RM#2705*/
/*  removed Bobcat2; Caelum; Bobcat3 - PRV_CPSS_DXCH_LION_RM_TCAM_CONFIG_WA_E, RM#3013*/
/* Bobcat2; Caelum; Bobcat3 fixed - as only single FDB instance    PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_FDB_LIMIT_WA_E,RM#2702*/
    PRV_CPSS_DXCH_LION_RM_ORIG_SRC_PORT_FILTERING_WA_E,/*RM#2706*/
/* Bobcat2; Caelum; Bobcat3 fixed - as all EGF uses the same CPU port -   PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_CPU_IN_VIDX_WA_E, RM#2707*/
/* removed Bobcat2; Caelum; Bobcat3 - no such configuration    PRV_CPSS_DXCH_LION_RM_UC_STRICT_OVER_MC_WA_E, RM#2710*/

/* removed Bobcat2; Caelum; Bobcat3 - the default value is OK   PRV_CPSS_DXCH_LION_RM_TX_MC_IN_CHUNKS_WA_E, RM#2711*/

/*  closed only for TXQ alignment - should be checked later PRV_CPSS_DXCH_LION_RM_BUFF_LIMIT_EGRESS_QUEUE_WA_E,*/ /*RM#2712*/
    PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E,/*???*/

    /* FEr from legacy devices */
    PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E,/*FEr#47*/
/*  removed Bobcat2; Caelum; Bobcat3 -  PRV_CPSS_DXCH_XCAT_IEEE_RESERVED_MC_CONFG_REG_READ_WA_E,FEr#3060*/
/* removed in Bobcat2; Caelum; Bobcat3 - no indirect registers ! -    PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E, FEr#2028*/

    /* RM - from legacy device */
/*  not needed in Lion-B (like xcat) already in correct values.  PRV_CPSS_DXCH3_RM_MAC2ME_LOW_REG_WA_E, RM#2026*/
    PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E,/*RM# 30160*/
    PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E,/*RM#3005*/
    PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E,  /* RM#3009*/
    PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E,/*RM#3024*/
    PRV_CPSS_DXCH_XCAT_TOD_NANO_SEC_SET_WA_E,/*FEr#2773*/

    PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E,/*(part of RM#3012)*/
/*removed in Bobcat2; Caelum; Bobcat3 -already correct value - PRV_CPSS_DXCH_XCAT_RM_POLICY_ENGINE_CONFIGURATION_REGISTER_WA_E,(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E,/*(part of RM#3012)*/
/*removed in Bobcat2; Caelum; Bobcat3 -register not exists -     PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E, (part of RM#3012)*/
/* not relevant to lion   PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E,(part of RM#3012)*/
/* not relevant to lion   PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E,(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/
/* not relevant to Bobcat2; Caelum; Bobcat3 - defaults are ok -  PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E, RM#3018*/
    PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E,/*RM#3014*/

    /* not relevant to lion2 PRV_CPSS_DXCH_LION_PFC_FOR_MANY_PRIORITY_WA_E*, *FEr#2787 */
/* metal fix - not relevant to Bobcat2; Caelum; Bobcat3 -  PRV_CPSS_DXCH_LION_INACCURATE_PFC_XOFF_WA_E, * RM#2788 */

/*  closed only for TXQ alignment - should be checked later     PRV_CPSS_DXCH_LION_INCOMPLETE_CPU_MAILBOX_INFO_WA_E,*/ /* FEr#2776 */

    PRV_CPSS_DXCH_XCAT2_RM_POLICER_MEM_CONTROL_WA_E, /*RM#3029*/
    PRV_CPSS_DXCH_BOBCAT2_RM_BRIDGE_COMMANDS_DEFAULTS_WA_E, /* RM: L2I-503 , L2I-546 */
    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E, /*XCAT FEr#2794*/
    PRV_CPSS_DXCH_LION2_PORT_MAC_MIB_COUNTERS_CORRUPTION_WA_E, /* FE-9085687 */

    /* bobcat2 new FEr */
    PRV_CPSS_DXCH_BOBCAT2_NON_ORIG_VID_ON_TRAP_TO_CPU_WA_E,         /* FE-7089929 */
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_TXDMA_FIFO_THRESHOLD_WA_E,       /* RM-3702958 */
    PRV_CPSS_DXCH_BOBCAT2_RM_RATE_LIMIT_DEFICIT_COUNT_EN_WA_E,      /* RM: L2I-451 */
    PRV_CPSS_DXCH_BOBCAT2_RM_STRICT_PRIORITY_FOR_UC_PACKETS_WA_E,   /* RM: TTI-1088 */
    PRV_CPSS_DXCH_BOBCAT2_RM_TTI_BAD_DEFAULT_VALUE_FIX_WA_E,        /* FE: TTI-1114, TTI-1459 */
    PRV_CPSS_DXCH_BOBCAT2_RM_GLOBAL_EPORT_RANGE_VALUE_AND_MASK_WA_E,/* RM: L2I-517 */
    PRV_CPSS_DXCH_BOBCAT2_RM_CONTROL_FROM_CPU_EGRESS_FILTER_WA_E,   /* EGF-868 */
    PRV_CPSS_DXCH_BOBCAT2_MPLS_TRANSIT_TUNNEL_PARSING_WA_E,         /* FE-4300730 */
    PRV_CPSS_DXCH_BOBCAT2_RM_TXQ_PORT_REQUEST_MASK_WA_E,            /* FE: TXQ-901 */
    PRV_CPSS_DXCH_BOBCAT2_NOT_ALLOW_TTI_ACTION_TO_SET_MODIFY_UP_DSCP_WA_E, /* FE: TTI-1267 */
#ifndef ASIC_SIMULATION
    PRV_CPSS_DXCH_BOBCAT2_ILKN_PACKET_SIZE_LIMITATION_NOT_ENFORCED_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_ENH_TAILDROP_MODE_WRED_CONFLICT_WA_E, /* (FE-4381191)*/
    PRV_CPSS_DXCH_BOBCAT2_PFC_NOT_SUPPORTED_PORTS_48_71_WA_E,   /* (FE-6841659)*/
    PRV_CPSS_DXCH_BOBCAT2_FC_802_3X_NOT_SUPPORTED_TM_MAPPED_PORTS_WA_E, /* (FE-7583456)*/
    PRV_CPSS_DXCH_BOBCAT2_FC_SENT_COUNTERS_PROBLEM_WHEN_FCU_BYPASS_DISABLE_WA_E, /* FE-5101126 */
    PRV_CPSS_DXCH_BOBCAT2_DESCRIPTOR_ECC_PROTECTION_CORRUPTION_WITH_REMOTE_PORTS_WA_E, /* FE-9897292 */
    PRV_CPSS_DXCH_BOBCAT2_TCAM_WRITE_PARITY_ERROR_WA_E, /* FE-5092995 */
#endif /* ASIC_SIMULATION */
    PRV_CPSS_DXCH_BOBCAT2_EGRESS_MIB_COUNTERS_NOT_ROC_WA_E,/* [JIRA] [TXQ-1097] - (BC2_A0) the TXQ egress mib counters should do 'clear on read' , but are not */
    PRV_CPSS_DXCH_BOBCAT2_RM_PROT_SWITCH_STAGE_EN_DEFAULT_VALUE_WA_E,  /* RM-7299863 */
    PRV_CPSS_DXCH_BOBCAT2_FDB_ROUTE_UC_DELETE_BY_MESSAGE_WA_E,/* [JIRA]:[MT-231] [FE-2293984] CPU NA message for deleting an entry does not work for UC route entries */
    PRV_CPSS_DXCH_BOBCAT2_EQ_TO_CPU_RATE_LIMIT_WINDOW_RESOLUTION_WA_E,/* [JIRA]: [EQ-559] CPU rate limiter is not working at low values of Conf<ToCPU RLWindow Resolution> */
    PRV_CPSS_DXCH_BOBCAT2_EPLR_TO_CPU_OAM_WA_E, /* JIRA [POLICER-1465] */
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_AVS_INIT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RXDMA_PIP_IPV6_WRONG_TC_BITS_WA_E,/* JIRA [RXDMA-982] : PIP : the 'TC' for the IPv6 packets should be bits 116..123 of the packet but actually taken from bits 118..125 */
    PRV_CPSS_DXCH_BOBCAT2_LED_LINK_GIG_INDICATION_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_GPP_INTERRUPT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E,          /* RM-7056426 */
    PRV_CPSS_DXCH_BOBCAT2_PACKET_GENERATOR_SPECIFIC_PORTS_WA_E,             /* FE-143364 */
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_PORT_MAC_CONTROL_REG4_WA_E,      /* RM-2141433 */
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_CNM_HEADER_CONFIGURATION_WA_E,   /* RM-5288408 */
    PRV_CPSS_DXCH_BOBCAT2_RM_PTP_UDP_CHECKSUM_TRAILER_BIT_WA_E,             /* RM-644887*/
    PRV_CPSS_DXCH_BOBCAT2_RM_INGRESS_FORWARDING_RESTRICTIONS_DROP_CODE_WA_E,/* RM-4480490*/
    PRV_CPSS_DXCH_BOBCAT2_RM_TRUNK_LTT_ENTRY_WRONG_DEFAULT_VALUES_WA_E,     /* RM-8499271*/
    PRV_CPSS_DXCH_BOBCAT2_RM_SHAPER_PARITY_ERROR_INTERRUPT_WA_E,            /* HWE-3984090*/
    PRV_CPSS_DXCH_BOBCAT2_RM_FDB_SCHEDULER_SWRR_CONTROL_WA_E,               /* Should add RM number*/
    PRV_CPSS_DXCH_IMPLEMENT_WA_2_5G_SGMII_LINK_UP_E,                        /* HWEr#3065 */
    /* the WA make problems on BC2 systems with TM disabled. The problem under investigation. */
    /*PRV_CPSS_DXCH_BOBCAT2_RM_DFX_REGISTERS_MISSCONFIGURATION_WA_E,  *//* RM-9308357 */

    PRV_CPSS_DXCH_BOBCAT2_TAI_MINIMAL_TOD_DRIFT_CONSTRAIN_WA_E,  /*FE-8248885*/

    PRV_CPSS_DXCH_GIGE_MAC_TX_FIFO_WA_E, /* RM-9725147 */

    PRV_CPSS_DXCH_BOBCAT2_PBR_PACKETS_TREATED_AS_UNKNOWN_DA_WA_E, /* FE-1436291*/

    PRV_CPSS_DXCH_XCAT3_TCP_SYN_WITH_DATA_E, /* FE-2001166 */

    PRV_CPSS_DXCH_BOBCAT2_TCAM_ARRAY_SPEED_MATCH_CFG_INIT_E, /* RM-9545365 */

    PRV_CPSS_DXCH_BOBCAT2_RM_DEFAULT_DOMAIN_ID_PER_DOMAIN_INDEX_E, /* RM-7451262 */

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* list of Errata/RM that not exist in bobcat2_A0 (that existed in bobcat2) */
static const GT_U32 notExistsInBobcat2A0ErrAndRmArray[]=
{
    PRV_CPSS_DXCH_BOBCAT2_GPP_INTERRUPT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_PROT_SWITCH_STAGE_EN_DEFAULT_VALUE_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_EPLR_TO_CPU_OAM_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_PTP_UDP_CHECKSUM_TRAILER_BIT_WA_E,

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* list of Errata/RM that not exist in bobcat2_B0 (that existed in bobcat2) */
static const GT_U32 notExistsInBobcat2B0ErrAndRmArray[]=
{
    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E,

    LAST_DEV_IN_LIST_CNS/* must be last */
};


/* list of Errata/RM that are fixed in bobk (that existed in bobcat2) */
static const GT_U32 fixedInBobkErrAndRmArray[]=
{
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_AVS_INIT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_FC_SENT_COUNTERS_PROBLEM_WHEN_FCU_BYPASS_DISABLE_WA_E,
    PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_ILKN_PACKET_SIZE_LIMITATION_NOT_ENFORCED_WA_E,
#ifndef  GM_USED
    PRV_CPSS_DXCH_BOBCAT2_EGRESS_MIB_COUNTERS_NOT_ROC_WA_E,
#endif /*! GM_USED*/
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_PORT_MAC_CONTROL_REG4_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_CNM_HEADER_CONFIGURATION_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_DFX_REGISTERS_MISSCONFIGURATION_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_PACKET_GENERATOR_SPECIFIC_PORTS_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_TCAM_WRITE_PARITY_ERROR_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_FDB_ROUTE_UC_DELETE_BY_MESSAGE_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_BRIDGE_COMMANDS_DEFAULTS_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_TCAM_ARRAY_SPEED_MATCH_CFG_INIT_E,

    LAST_DEV_IN_LIST_CNS/* must be last */
};


/* list of Errata/RM that are fixed in bobcat3 (that existed in bobcat2/bobk) */
static const GT_U32 fixedInBobcat3ErrAndRmArray[]=
{
    PRV_CPSS_DXCH_BOBCAT2_GPP_INTERRUPT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_PROT_SWITCH_STAGE_EN_DEFAULT_VALUE_WA_E,
    PRV_CPSS_DXCH_LION2_PORT_MAC_MIB_COUNTERS_CORRUPTION_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_LED_LINK_GIG_INDICATION_WA_E,
    PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E,
    PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E,
    /* PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E, - fixed partially */
    PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E,
    PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E,
    PRV_CPSS_DXCH_IMPLEMENT_WA_2_5G_SGMII_LINK_UP_E,
    PRV_CPSS_DXCH_XCAT2_RM_POLICER_MEM_CONTROL_WA_E,
    PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_PFC_THRESHOLDS_WA_E,
    PRV_CPSS_DXCH_LION2_RM_LLFC_TRIGGER_GLOBAL_CONFIGURATION_WA_E,
    PRV_CPSS_DXCH_LION2_RM_ENABLE_PFC_TRIGGER_WA_E,

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of 'extra' FEr/RM WA for the Bobcat3 (on top of other sip5 devices) */
static const GT_U32 bobcat3ExtraErrAndRmArray[]=
{
    PRV_CPSS_DXCH_BOBCAT3_RM_TCAM_SEGMENT_MODE_OBSOLETE_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_EQ_ARBITERS_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_PERFORMANCE_DEGRADATION_IN_EGF_QAG_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_TXQ_IP_BMX_FILL_LEVEL_DEBUG_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_CUT_THROUGH_NUMBERS_OF_BUFFERS_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_CG_REGFILE_UNRESET_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_DESC_SHARED_POOL_TAILDROP_THRESHOLDS_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_CUT_THROUGH_PACKET_CORRUPTION_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_ROUTER_FIFOS_THRESHOLD_1_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_PORT_LED_POSITION_JUST_ON_USED_MAC_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_LINK_DOWN_100G_PORT_BLOCKS_THE_TRANSMIT_PATH_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_PLR_INDIRECT_READ_COUNTERS_ON_DISABLED_MODE_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_TXQ_TX_SHAPER_BASELINE_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_100G_SYNC_ETHERNET_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_PFC_IND_FIFO_CROSS_MODE_THRESHOLD_WA_E,

    LAST_DEV_IN_LIST_CNS/* must be last */
};


/* list of Errata/RM that are fixed in aldrin2 (that existed in bobcat3 ) */
static const PRV_CPSS_DXCH_ERRATA_ENT  fixedInAldrin2ErrAndRmArray[]=
{
    PRV_CPSS_DXCH_BOBCAT3_RM_CUT_THROUGH_PACKET_CORRUPTION_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_PERFORMANCE_DEGRADATION_IN_EGF_QAG_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_TXQ_IP_BMX_FILL_LEVEL_DEBUG_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_DESC_SHARED_POOL_TAILDROP_THRESHOLDS_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_CUT_THROUGH_NUMBERS_OF_BUFFERS_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_FORCE_DOWN_LINK_PARTNER_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_100G_SYNC_ETHERNET_WA_E,

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of 'extra' FEr/RM WA for the Aldrin2 (on top of other sip5 devices) */
static const PRV_CPSS_DXCH_ERRATA_ENT aldrin2ExtraErrAndRmArray[]=
{
    PRV_CPSS_DXCH_ALDRIN2_EPCL_TCAM_LOOKUP_LATENCY_WA_E,
    PRV_CPSS_DXCH_ALDRIN2_BRIDGE_RATE_LIMIT_UC_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_CG_REGFILE_UNRESET_WA_E,
    PRV_CPSS_DXCH_ALDRIN2_TCAM_ANSWERS_FLOOR_SAMPLES_INIT_VALUE_WA_E,
    PRV_CPSS_DXCH_ALDRIN2_QUEUE_VALUE_DISABLE_WA_E, /* FE-6025612 : Packets comes from a queue to the CPU even after disabling the queue */

    LAST_DEV_IN_LIST_CNS/* must be last */
};


/* array of 'extra' FEr/RM WA for the Falcon (on top of other sip5 devices) */
static const GT_U32 falconExtraErrAndRmArray[]=
{
    PRV_CPSS_DXCH_ALDRIN2_QUEUE_VALUE_DISABLE_WA_E, /* FE-6025612 : Packets comes from a queue to the CPU even after disabling the queue */
    PRV_CPSS_DXCH_FALCON_L2I_AND_EQ_READ_TABLE_BEFORE_TRAFFIC_WA_E,
    PRV_CPSS_DXCH_FALCON_SBM_XOR_CLIENTS_READ_WRITE_BEFORE_SW_RESET_WA_E,
    PRV_CPSS_DXCH_FALCON_TXQ_SKIP_TABLES_BACKUP_WA_E,
    PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CONFIG_SIP_LOOKUP_E,
    PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_IPV6_TT_HBH_EXT_EXCEPTION_CMD_E,
    PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_IPV6_TT_NON_HBH_EXT_EXCEPTION_CMD_E,
    PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CT_BC_LEN_CHECK_E,
    PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CT_HEADER_INTEGRITY_EXCEPTION_CMD_E,
    PRV_CPSS_DXCH_FALCON_MRU_PER_DEFAULT_EPORT_WA_E,
    PRV_CPSS_DXCH_FALCON_MRU_BRIDGE_EVLAN_WA_E,
    PRV_CPSS_DXCH_FALCON_TAIL_DROP_ON_VIRTUAL_BUFFERS_E,
    PRV_CPSS_DXCH_FALCON_RM_HASH_MODE_WA_E,
    PRV_CPSS_DXCH_FALCON_SKIP_REGISTERS_SW_RESET_NOT_SUPPORTED_WA_E,
    LAST_DEV_IN_LIST_CNS/* must be last */
};
/* list of Errata/RM that are fixed in falcon (that existed in Bobcat3) */
static const GT_U32 fixedInFalconErrAndRmArray[]=
{
    /* start of remove all the Errata relate to the SIP5 TXQ !!! */
    PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_TXQ_PORT_REQUEST_MASK_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_CUT_THROUGH_NUMBERS_OF_BUFFERS_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_TXQ_IP_BMX_FILL_LEVEL_DEBUG_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_TXQ_TX_SHAPER_BASELINE_WA_E,
    /* end of removed all the Errata relate to the SIP5 TXQ !!! */
    /* start of remove all the Errata relate to the SIP5 TXDMA, TXFIFO !!! */
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_TXDMA_FIFO_THRESHOLD_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_DESCRIPTOR_ECC_PROTECTION_CORRUPTION_WITH_REMOTE_PORTS_WA_E,
    /* end of removed all the Errata relate to the SIP5 TXDMA, TXFIFO !!! */
    PRV_CPSS_DXCH_XCAT3_GIG_MAC_HALF_DUPLEX_COLLISION_DOMAIN_RM_E,
    PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_PFC_IND_FIFO_CROSS_MODE_THRESHOLD_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_PORT_LED_POSITION_JUST_ON_USED_MAC_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_100G_SYNC_ETHERNET_WA_E,
    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* list of Errata/RM that are fixed in Hawk(AC5P) (that existed in Facon) */
static const GT_U32 fixedInHawkErrAndRmArray[]=
{
    /* start of remove all the Errata relate to the SIP6 */
    PRV_CPSS_DXCH_FALCON_MRU_PER_DEFAULT_EPORT_WA_E,
    PRV_CPSS_DXCH_BOBCAT3_RM_ROUTER_FIFOS_THRESHOLD_1_WA_E,
    PRV_CPSS_DXCH_FALCON_L2I_AND_EQ_READ_TABLE_BEFORE_TRAFFIC_WA_E,
    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of 'extra' FEr/RM WA for the Hawk (on top of Falcon devices) */
static const GT_U32 hawkExtraErrAndRmArray[] =
{
    PRV_CPSS_DXCH_AC5P_MPLS_CUT_THROW_ENABLE_E,
    PRV_CPSS_DXCH_AC5P_RM_MASTER_TAI_DEFAULT_MANCHESTER_HALF_BIT_SYMBOL_LENGTH_E,
    PRV_CPSS_DXCH_AC5P_RM_RELOCATE_EQ_DROP_TO_EREP_WA_E,
    PRV_CPSS_DXCH_AC5P_TIMESTAMP_TO_THE_FUTURE_WA_E,
    PRV_CPSS_DXCH_AC5P_TOD_UPDATE_SECONDS_WA_E,
    PRV_CPSS_DXCH_AC5P_RM_DRIFT_MIN_THRESHOLD_WA_E,
    PRV_CPSS_DXCH_AC5P_RM_IPFIX_FIRST_PACKET_CMD_WA_E,
    PRV_CPSS_DXCH_AC5P_RM_BRIDGE_CHECK_IP_HEADER_WA_E,
    PRV_CPSS_DXCH_AC5P_RM_PTP_FREQ_UPDATE_FOR_PCLK_IS_DONE_INACCURATELY_WA_E,
    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of 'extra' FEr/RM WA for the Harrier (on top of Hawk/Phoenix devices) */
static const GT_U32 harrierExtraErrAndRmArray[] =
{
    PRV_CPSS_DXCH_HARRIER_RM_PTP_PLL_SET_GLOBAL_REF_CLOCK_WA_E,
    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* list of Errata/RM that are fixed in Harrier (that existed in Hawk/Phoenix devices) */
static const GT_U32 fixedInHarrierErrAndRmArray[] =
{
    PRV_CPSS_DXCH_AC5P_TIMESTAMP_TO_THE_FUTURE_WA_E,
    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of 'extra' FEr/RM WA for the Ironman (on top of Harrier devices) */
static const GT_U32 ironmanExtraErrAndRmArray[] =
{
    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* list of Errata/RM that are fixed in Ironman (that existed in Harrier) */
static const GT_U32 fixedInIronmanErrAndRmArray[]=
{
#ifdef  GM_USED
    PRV_CPSS_DXCH_BOBCAT2_EGRESS_MIB_COUNTERS_NOT_ROC_WA_E,/* Finally fixed in the 'TF' release (Top freeze) 10/11/2021 */
#endif /* GM_USED*/
    /* start of remove all the Errata relate to the SIP6_30 */
    PRV_CPSS_DXCH_AC5P_RM_MASTER_TAI_DEFAULT_MANCHESTER_HALF_BIT_SYMBOL_LENGTH_E,
    PRV_CPSS_DXCH_AC5P_TOD_UPDATE_SECONDS_WA_E,
    PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CONFIG_FOR_TAI_CTRL_1_E,
    PRV_CPSS_DXCH_AC5P_RM_DRIFT_MIN_THRESHOLD_WA_E,
    PRV_CPSS_DXCH_HARRIER_RM_PTP_PLL_SET_GLOBAL_REF_CLOCK_WA_E,
    LAST_DEV_IN_LIST_CNS/* must be last */
};

/*
static GT_STATUS deviceListSearch
(
   IN CPSS_PP_DEVICE_TYPE * devList,
   IN CPSS_PP_DEVICE_TYPE devType
)
{
    GT_U32 i;
    for (i = 0 ; devList[i] != LAST_DEV_IN_LIST_CNS ; i++)
    {
        if (devList[i] == devType)
        {
            return GT_OK;
        }
    }
    return GT_NOT_FOUND;
}
*/

/**
* @internal prvCpssDxChHwMacSecInit function
* @endinternal
*
* @brief   Disables the core clock towards the MacSec shell using a clock gate
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; xCat3; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                - physical device number
* @param[in] macSecClockDisable    - Disables the core clock towards the MacSec shell using a clock gate
*                                    GT_TRUE  - core clock is disabled
*                                    GT_FALSE - core clock is enabled
*
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_FAIL                  - otherwise
*
*/
GT_STATUS prvCpssDxChHwMacSecInit
(
    IN GT_U8    devNum,
    IN GT_BOOL  macSecClockDisable
)
{
    GT_STATUS rc = GT_OK;     /* return code status */
    GT_U32    macSecDpId;     /* represents MACSec Data Path ID: 0,1                    */
    GT_U32    macSecType;     /* represents MACSec type: Classifier, Transformer        */
    GT_U32    macSecDir;      /* represents MACSec direction: Ingress, Egress           */
    GT_U32    macSecMaxNumDp; /* holds maximum number of Data Paths connected to MACSec */
    GT_U32    regAddr;        /* register's address */
    GT_U32    fieldData;      /* register's field data */

    /* Access to the registers addresses of the 'eArch' device */
    PRV_CPSS_DXCH_PP_REGS_ADDR_VER1_STC *regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum);

    /* Get maximum number of Data path units connected to MACSec */
    macSecMaxNumDp = ((PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.macSecInfo.macSecDpBmp) >> 1) + 1;

    fieldData = (macSecClockDisable == GT_TRUE) ? 1 : 0;

    /* Loop over the maximum number of Data paths. For AC5P:2 for AC5X:1 */
    for (macSecDpId = 0; (macSecDpId < macSecMaxNumDp); macSecDpId++)
    {
        /* Loop over MACSec Classifier and MACSec Transformer */
        for (macSecType = 0; (macSecType < 2); macSecType++)
        {
            /* Loop over Ingress and Egress directions */
            for (macSecDir = 0; (macSecDir < 2); macSecDir++)
            {
                /* Get MacSec Wrapper Misc register address for this specific MACSec unit */
                regAddr = regsAddrPtr->PCA_MACSEC_EXT[macSecDpId][macSecType][macSecDir].msWrapperMisc;

                /* Enable/disable clock. Sets core_clk_disable field (bit#1) in MacSec Wrapper Misc register */
                rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 1/*fieldOffset*/, 1/*fieldLength*/, fieldData);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
    }

    return rc;
}

/* Reserved ports map array for SIP5 (not SIP_5_20) devices
   with 256 physical ports */
static const GT_PHYSICAL_PORT_NUM reservedSip5_256PortsMapArr[] =
{
    255, 254, GT_NA
};

/* Reserved ports map array for SIP5 (not SIP_5_20) devices
   with 128 physical ports */
static const GT_PHYSICAL_PORT_NUM reservedSip5_128PortsMapArr[] =
{
    127, 126, GT_NA
};
/**
* @internal prvCpssDxChPortReservedPhysicalPortsMapSet function
* @endinternal
*
* @brief   Sets pointer to reserved ports array for specific device.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK               - on success
* @retval GT_FAIL             - on wrong logic
*/
static GT_STATUS prvCpssDxChPortReservedPhysicalPortsMapSet
(
    IN   GT_U8                      devNum
)
{
    if (256 == PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->port.reservedPortsPtr = reservedSip5_256PortsMapArr;
    }
    else if (128 == PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->port.reservedPortsPtr = reservedSip5_128PortsMapArr;
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

#define PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS       0x000f8204
#define PRV_CPSS_DFX_SERVER_SAR2_REG_PLL2_TM_OFFS_CNS  15
#define PRV_CPSS_DFX_SERVER_SAR2_REG_PLL2_TM_LEN_CNS   3

/**
* @internal prvCpssDxChTMFreqGet function
* @endinternal
*
* @brief   Get TM Dram Frequency.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - Device number.
*
* @param[out] tmFreqPtr                - (pointer of) tmFreqency
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on hardware error.
* @retval GT_BAD_PARAM             - on bad params.
*
* @note tmFreqency 0: tm not supported.
*       tmFreqency 1: CPSS_DRAM_FREQ_800_MHZ_E.
*       tmFreqency 2: CPSS_DRAM_FREQ_933_MHZ_E.
*       tmFreqency 3: CPSS_DRAM_FREQ_667_MHZ_E.
*
*/
GT_STATUS prvCpssDxChTMFreqGet
(
    IN  GT_U8    devNum,
    OUT GT_U32 * tmFreqPtr
)
{
    GT_U32 tmFreq;
    GT_STATUS rc;
    GT_U32    sar2_reg_data;
    GT_U32    tmMask;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    rc = cpssDrvHwPpResetAndInitControllerReadReg(devNum, PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS, &sar2_reg_data);
    if (GT_OK != rc)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }


    tmMask = (1<<PRV_CPSS_DFX_SERVER_SAR2_REG_PLL2_TM_LEN_CNS)-1;
    tmFreq = (sar2_reg_data >>= PRV_CPSS_DFX_SERVER_SAR2_REG_PLL2_TM_OFFS_CNS) & tmMask;        /* shift right 15 bits         */

    #ifdef ASIC_SIMULATION
            tmFreq = 2;/*933_MHZ*/
    #endif /*ASIC_SIMULATION*/

    if (tmFreqPtr == NULL)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PTR, LOG_ERROR_NO_MSG);
    }
    *tmFreqPtr = tmFreq;

    return GT_OK;
}

/**
* @internal hwPpDxChBobkEplrMemoriesDefaultSet function
* @endinternal
*
* @brief   Write correct default values into registers.
*
* @note   APPLICABLE DEVICES:      Caelum, Aldrin, AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
static GT_STATUS hwPpDxChBobkEplrMemoriesDefaultSet
(
    IN GT_U8 devNum
)
{
    GT_STATUS rc = GT_OK; /* return code */
    GT_U32 regAddr;      /* register's address */

    CPSS_DXCH_POLICER_STAGE_TYPE_ENT stage = CPSS_DXCH_POLICER_STAGE_EGRESS_E;

    GT_U32                           entryIndex;
    GT_U32                           entryValue[2] = {0, 0};

    /* Initialize Egress Policer Remarking Table to 0 */
    for (entryIndex = 0; entryIndex < 80; entryIndex++)
    {
        rc = prvCpssDxChWriteTableEntry(devNum,
                                        CPSS_DXCH_XCAT_TABLE_EGRESS_POLICER_REMARKING_E,
                                        entryIndex,
                                        &entryValue[0]);
        if(rc != GT_OK)
            return rc;
    }

    /* Initialize IP Fix Port Group Wraparound Table */
    regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,stage).ipfixWrapAroundAlertTbl;
    for (entryIndex = 0; entryIndex < 128; entryIndex++)
    {
        rc = prvCpssHwPpWriteRegister(devNum,
                                            (regAddr + entryIndex*4),
                                            0);
        if(rc != GT_OK)
            return rc;
    }

    /* Initialize IP Fix Port Group Aging Status Table */
    regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,stage).ipfixAgingAlertTbl;
    for (entryIndex = 0; entryIndex < 128; entryIndex++)
    {
        rc = prvCpssHwPpWriteRegister(devNum,
                                            (regAddr + entryIndex*4),
                                            0);
        if(rc != GT_OK)
            return rc;
    }

    /* Initialize Egress Policer Trigger Table to 0 */
    for (entryIndex = 0; entryIndex < _6K; entryIndex++)
    {
        rc = prvCpssDxChWriteTableEntry(devNum,
                                           CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_E_ATTRIBUTES_E,
                                           entryIndex,
                                           &entryValue[0]);
        if(rc != GT_OK)
            return rc;
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChCpuDmaNumGet function
* @endinternal
*
* @brief   Get the DMA number of the cpu port according to its Dq number
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Bobcat3; Aldrin; Caelum.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] dqNum                    - The dq number
* @param[in] localDpPort              - The local Dp Port number
*                                       relevant fro sip6.15 devices and above
*
* @param[out] dmaNumPtr                - (pointer to) the CPU port DMA number
*
* @retval TRUE                     - if CPU dma matching the dq number was found.
* @retval FALSE                    - if no dma matching the dq was found
*/
static GT_BOOL prvCpssDxChCpuDmaNumGet
(
    IN GT_U8    devNum,
    IN GT_U32   dqNum,
    IN GT_U32   localDpPort,
    OUT GT_U32  *dmaNumPtr
)
{
    PRV_CPSS_DXCH_PP_CONFIG_STC *dxDevPtr = PRV_CPSS_DXCH_PP_MAC(devNum);
    GT_U32  ii;/*iterator*/

    for (ii = 0; ii < CPSS_MAX_SDMA_CPU_PORTS_CNS; ii ++)
    {
        if((dxDevPtr->hwInfo.cpuPortInfo.info[ii].valid == GT_TRUE) && (dxDevPtr->hwInfo.cpuPortInfo.info[ii].dqNum == dqNum))
        {
            if(PRV_CPSS_SIP_6_15_CHECK_MAC(devNum) &&
               dxDevPtr->hwInfo.cpuPortInfo.info[ii].localDmaNum != localDpPort)
            {
                continue;
            }

          *dmaNumPtr = dxDevPtr->hwInfo.cpuPortInfo.info[ii].dmaNum;
          return GT_TRUE;
        }
    }
    return GT_FALSE;
}


/**
* @internal hwPpCheetahCommonRegsDefault function
* @endinternal
*
* @brief   Set mandatory default values for Cheetah registers
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
static GT_STATUS hwPpCheetahCommonRegsDefault
(
    IN GT_U8   devNum
)
{
    GT_U32 regAddr;      /* register's address */

    if(PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
              PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E) == GT_TRUE)
    {
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_FDB_MAC(devNum).FDBCore.FDBGlobalConfig.FDBGlobalConfig;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.macControlReg;
        }

        if (prvCpssHwPpSetRegField(devNum, regAddr, 7, 1, 0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;
}

/**
* @internal hwPpCheetah3RegsDefault function
* @endinternal
*
* @brief   Set mandatory default values for Cheetah registers
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
static GT_STATUS hwPpCheetah3RegsDefault
(
    IN GT_U8                                       devNum
)
{
    GT_U32 regAddr;     /* register's address */
    GT_STATUS rc;       /* return code */

    /* start with the common settings */
    rc =  hwPpCheetahCommonRegsDefault(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(GT_TRUE ==
        PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E))
    {
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            /* Disable dropping ARP packets with MAC SA not equal to the ARP
               payload data contains a field called <source hardware address> */
           rc = cpssDxChNstProtSanityCheckSet(devNum,
                    CPSS_NST_CHECK_ARP_MAC_SA_MISMATCH_E,
                    GT_FALSE);
            if(rc != GT_OK)
            {
                return rc;
            }

            /*
                NOTE: this is anyway 'default' of the device
            */

            /* Disable all TCP Sanity checks */
           rc = cpssDxChNstProtSanityCheckSet(devNum,
                    CPSS_NST_CHECK_TCP_ALL_E,
                    GT_FALSE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /* Reset NST( Network Shield ) registers  -
               Bridge Global Configuration Registers */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                         bridgeRegs.bridgeGlobalConfigRegArray[0];

            /* Disable dropping ARP packets with MAC SA not equal to the ARP
               payload data contains a field called <source hardware address>
               + all TCP Sanity checks */
            if(prvCpssHwPpWriteRegBitMask(devNum, regAddr, 0x20030000, 0x0) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                         bridgeRegs.bridgeGlobalConfigRegArray[2];
            /* Disable all TCP related bits(0-4) + disable ICMP dropping(bit 5) */
            if(prvCpssHwPpWriteRegBitMask(devNum,regAddr,0x0000003F, 0x0)
                != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
    }

    /* Enable tagged packets transmitted from the device have their CFI bit set
     according to the received packet CFI bit if the received packet was tagged,
     or set to 0 if the received packet is untagged.*/
    rc = cpssDxChBrgGenCfiRelayEnableSet(devNum,GT_TRUE);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* RM#2003 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_RM_BM_GE_XG_PORT_GROUP_LIMIT_CFG_REG_WA_E))
    {
        /* Buffer Management GbE Ports Group Limits Configuration Registers */
        if (prvCpssHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.bufMngGigaPortGroupLimit,
                0xBFEFFDFF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        /* Buffer Management HyperG.Stack Ports Group Limits Configuration Registers */
        if (prvCpssHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.bufMngHyperGStackPortGroupLimit,
                0xBFEFFDFF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }
    /* RM#2007 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_RM_GE_PORTS_MODE1_REG_WA_E))
    {
        /* LMS GigE Ports Mode Register1 */
        if (prvCpssHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms1GigPortsModeReg1[1],
                0x00000000) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }
    /* RM#2008 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_RM_XG_PORTS_MODE_REG_WA_E))
    {
        /* LMS HyperG.Stack Ports Mode Register */
        if (prvCpssHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms0GigPortsModeReg1[1], 0x000000FF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }
    /* RM#2024 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_RM_LMS0_1_GROUP1_LED_INTERFACE_WA_E))
    {
        /* LED Interface0 Control Register 1 and Class6 Manipulation Register (for ports 0 through 11) */
        /* <LEDClkInvert> */
        if (prvCpssHwPpSetRegField(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ledRegs.ledClass[0][6], 16, 1, 1) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        /* LED Interface1 Control Register1 and class6 manipulation (for ports 12 through 23) */
        /* <LEDClkInvert> */
        if (prvCpssHwPpSetRegField(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ledRegs.ledClass[1][6], 16, 1, 1) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E))
    {
        /* WA for: Under heavy traffic stress, FDB accesses from the CPU can get stuck */
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_FDB_MAC(devNum).FDBCore.FDBGlobalConfig.FDBGlobalConfig;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.macControlReg;
        }
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 6, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_GLOBAL_EPORT_RANGE_VALUE_AND_MASK_WA_E) ||

        PRV_CPSS_SIP_6_CHECK_MAC(devNum)
        /* SIP6 : the default values are 0x1FFFF that are more than 'max eport' in the device.
            meaning that with default values : the 'Get' function will return those values , but the 'Set' function will deny it !
            So let the 'initialization' to set is as 'disabled'
        */
    )
    {
        CPSS_DXCH_CFG_GLOBAL_EPORT_STC        ecmpEportCfg;
        CPSS_DXCH_CFG_GLOBAL_EPORT_STC        globalEportCfg;
        CPSS_DXCH_CFG_GLOBAL_EPORT_STC        dlbEportCfg;

        /* L2i : Default for the couple <Global Eport Range Value> and <Global
                 ePort Range Mask> should be 'never match' */
        globalEportCfg.enable = CPSS_DXCH_CFG_GLOBAL_EPORT_CONFG_DISABLE_E;
        ecmpEportCfg.enable = CPSS_DXCH_CFG_GLOBAL_EPORT_CONFG_DISABLE_E;
        dlbEportCfg.enable = CPSS_DXCH_CFG_GLOBAL_EPORT_CONFG_DISABLE_E;
        rc = cpssDxChCfgGlobalEportSet(devNum,&globalEportCfg,&ecmpEportCfg,&dlbEportCfg);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    return GT_OK;
}

/**
* @internal rmPlrCountingWa function
* @endinternal
*
* @brief   fix RM (Registers misconfigurations) relate to PLR counting mode.
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - PP device number
* @param[in] stage                    - Policer Stage type: Ingress #0, Ingress #1 or Egress.
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong devNum or stage.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS   rmPlrCountingWa
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_POLICER_STAGE_TYPE_ENT stage
)
{
    GT_STATUS   rc;
    GT_U32  value;
    GT_U32  regAddr;
    GT_U32  ii;

    regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,stage).globalConfig.statisticalCountingConfig0;
    /*<Counting Rate Adapt FIFO Always Sample Threshold>*/
    value = 0x5;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 13, 6, value);
    if(rc != GT_OK)
    {
        return rc;
    }

    /*<Counting Sampling Factor>*/
    value = 0x29;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 8, value);
    if(rc != GT_OK)
    {
        return rc;
    }


    regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,stage).globalConfig.statisticalCountingConfig1;
    /*<Packet Mode Counting Number Of Packets Estimation>*/
    value = 0x10;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 8, 8, value);
    if(rc != GT_OK)
    {
        return rc;
    }

    /*<Packet Mode Counting Packet Length For Sampling>*/
    value = 0xA4;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 8, value);
    if(rc != GT_OK)
    {
        return rc;
    }

    for(ii = 0 ; ii < 8; ii++)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,stage).globalConfig.countingConfigTableSegment[ii];

        /*<Packet Size Mode> = <L2>*/
        value = 0x1/*<L2>*/;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, value);
        if(rc != GT_OK)
        {
            return rc;
        }

        /*<Byte Or Packet Counting Mode> = <Packets>*/
        value = 0x1/*<Packets>*/;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, value);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    for(ii = 0 ; ii < 7; ii++)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,stage).globalConfig.countingConfigTableThreshold[ii];

        /*<Counting Configuration Table Threshold>*/
        value = 0xFF;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 8, value);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal hwPpDxChXcatRegsDefault function
* @endinternal
*
* @brief   Set mandatory default values for xCat registers
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
static GT_STATUS hwPpDxChXcatRegsDefault
(
    IN GT_U8                                    devNum
)
{
    GT_U32      i;          /* iterator */
    GT_U32      j;          /* iterator */
    GT_STATUS   rc;         /* return code */
    GT_U32      port;       /* iterator over ports */
    GT_U32      regAddr;    /* register address */
    GT_U32      fieldOffset;/* offset of field in register */
    GT_U32      regData;    /* register data */

    /* start with the same ch3 settings */
    rc =  hwPpCheetah3RegsDefault(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E))
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
            {
                regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.tokenBucketUpdateRate;
                fieldOffset = 29;
            }
            else
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.shaper.tokenBucketUpdateRate;
                fieldOffset = 30;
            }
            rc = prvCpssHwPpSetRegField(devNum, regAddr, fieldOffset, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /* Wrong default value of bit#28 of Transmit Queue Extended Control
               register. The bit should be set by default. */
            rc = prvCpssHwPpSetRegField(
                devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfigExt,
                28, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /*********************/
    /* xcat and above */
    /*********************/

    for (i = 0; i <= CPSS_DXCH_POLICER_STAGE_EGRESS_E; i++)
    {
        /*(part of RM#3012)*/

        if( i != CPSS_DXCH_POLICER_STAGE_EGRESS_E )/* not for egress policer */
        {
            /*
                1. Set Qos model to be Qos Profile in Policer Control0 reg.
                2. Enable QosProfile update for IP packets in Policer Control1 reg.
                   (for Policer Ingress #0 and Policer Ingress #1
            */
            if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E))
            {
                if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
                {
                    regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,i).policerCtrl0;
                }
                else
                {
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                                PLR[i].policerControlReg;
                }

                rc = prvCpssHwPpSetRegField(
                    devNum,
                    regAddr,
                    21, 1, 1);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }

            if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E))
            {
                if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
                {
                    regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,i).policerCtrl1;
                }
                else
                {
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                                PLR[i].policerControl1Reg;
                }

                rc = prvCpssHwPpSetRegField(
                    devNum,
                    regAddr,
                    0, 1, 1);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }
        }

        /* skip not supported IPLR0 */
        if ((CPSS_DXCH_POLICER_STAGE_INGRESS_0_E == i) &&
            (PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.policersNum == 0))
        {
            continue;
        }

        /* skip not supported IPLR1 */
        if ((CPSS_DXCH_POLICER_STAGE_INGRESS_1_E == i) &&
            (PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.featureInfo.iplrSecondStageSupported == GT_FALSE))
        {
            continue;
        }

        /* skip not supported EPLR */
        if ((CPSS_DXCH_POLICER_STAGE_EGRESS_E == i) &&
            (PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.egressPolicersNum == 0))
        {
            continue;
        }

        /* for all policers configure Flow mode */
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E))
        {
            rc = cpssDxChPolicerStageMeterModeSet(
                    devNum, i, CPSS_DXCH_POLICER_STAGE_METER_MODE_FLOW_E);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                         PRV_CPSS_DXCH_CAELUM_RM_PLR_METERING_INACCURACY_IN_START_TRAFFIC_WA_E))
        {
            for (j = 0; j < 2; j++)
            {
                regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum, i).debug_LFSRSeed[j];
                /* set LFSR seed pseudo random value */
                regData = cpssOsRand();
                rc = prvCpssHwPpWriteRegister(devNum, regAddr, regData);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }

            regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum, i).debug_PrngControl1;
            /* set bit1 to value 1 - counting seed configuration upload trigger */
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
            /* reset bit1 to value 0 - counting seed configuration upload finished */
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, 0);
            if(rc != GT_OK)
            {
                return rc;
            }
            /* set bit0 to value 1 - counting free running */
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }


            if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                for (j = 0; j < 2; j++)
                {
                    regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum, i).debug_LFSRSeed[j];
                    /* set LFSR seed pseudo random value */
                    regData = cpssOsRand();
                    rc = prvCpssHwPpWriteRegister(devNum, regAddr, regData);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }

                regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum, i).debug_PrngControl2;
                /* set bit1 to value 1 - metering seed configuration upload trigger */
                rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, 1);
                if(rc != GT_OK)
                {
                    return rc;
                }
                /* reset bit1 to value 0 - metering seed configuration upload finished */
                rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, 0);
                if(rc != GT_OK)
                {
                    return rc;
                }
                /* set bit0 to value 1 - metering free running */
                rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }

            /* only Bobcat3 need this settings and NOT Aldrin2 */
            /* modifications here relate to JIRA: CPSS-6439 :
                Defaults need to be changed for statistical counting*/
            if (PRV_CPSS_PP_MAC(devNum)->devFamily ==
                CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
            {
                /* fix RM relate to PLR counting mode. */
                rc = rmPlrCountingWa(devNum, i);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_CAELUM_TAI_FREQUENCY_ADJUST_TIME_WINDOW_INIT_VAL_WA_E))
    {
        /* RM-7969777 WA implemented for for BobK and above. */
        /*  Frequency adjust time window should be internalized and configured to 0x1 only (default is 0x0!)*/
        PRV_CPSS_DXCH_PP_REGS_ADDR_VER1_STC *regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum);
        GT_U32 numOfGop = (sizeof(regsAddrPtr->GOP.TAI) / sizeof(regsAddrPtr->GOP.TAI[0]));
        GT_U32 numOfTai = (sizeof(regsAddrPtr->GOP.TAI[0]) / sizeof(regsAddrPtr->GOP.TAI[0][0]));
        GT_U32 gopIndex, taiIndex;

        for (gopIndex = 0; (gopIndex < numOfGop); gopIndex++)
        {
            for (taiIndex = 0; (taiIndex < numOfTai); taiIndex++)
            {
                regAddr = regsAddrPtr->GOP.TAI[gopIndex][taiIndex].frequencyAdjustTimeWindow;
                /* skip not relevant GOP and TAI indexes */
                if (regAddr == PRV_CPSS_SW_PTR_ENTRY_UNUSED) continue;
                /* write initial value fixed by errata */
                rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 3, 1);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E))
    {
        /*(part of RM#3012)*/

        /* Enable Mirror on Drop */
        for(i = 0; i < 7; i++)
        {
            rc = cpssDxChMirrorAnalyzerMirrorOnDropEnableSet(devNum,i,GT_TRUE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_TOTAL_BUFFER_LIMIT_CONF_IN_TXQ_E))
        {
            /* TxQ Total Buffer Limit */
            rc = prvCpssHwPpWriteRegister(devNum,
                                            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                            egrTxQConf.totalBufferLimitConfig,
                                            0x00001800);
            if (rc != GT_OK)
            {
                return rc;
            }
        }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E))
    {
        /*(part of RM#3012)*/
        /* PCL Counting Mode Configuration register,
           field Enable Counting */
        /*enable CNC for IPCL */
        rc = cpssDxChCncCountingEnableSet(devNum,CPSS_DXCH_CNC_COUNTING_ENABLE_UNIT_PCL_E,GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E))
    {
        if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            /*(part of RM#3012) - fixed in SIP_5_20 (BC3) */
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
            {
                regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).TTIUnitGlobalConfigs.TTIUnitGlobalConfig;
            }
            else
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiUnitConfig;
            }

            /* TTI Unit Global Configuration register,
               field disable CCFC */
            rc = prvCpssHwPpSetRegField(devNum,regAddr,19, 1, 0);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* TTI Unit Global Configuration register,
           field Enable Counting */
        rc = cpssDxChCncCountingEnableSet(devNum,CPSS_DXCH_CNC_COUNTING_ENABLE_UNIT_TTI_E,GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_POLICY_ENGINE_CONFIGURATION_REGISTER_WA_E))
    {
        /*(part of RM#3012)*/
        /* Enable full lookup for Ingress PCL lookup0 sublookup1 */
        rc = cpssDxChPclPortIngressLookup0Sublookup1TypeSet(devNum,
            CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_FULL_E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E))
    {
        /*(part of RM#3012)*/

        /* Enable Egress Policer and set ERLR counting mode to be
           Billing/IP FIX */
        rc = prvCpssHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.eplrGlobalConfig,
            0, 3, 3);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_TXQ_DEQUEUE_SWRR_WEIGHT_REGISTER_3_WA_E))
    {
        /* fields of XG and Gig1 weights are swapped */
        rc = prvCpssHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.dequeueSWRRWeightReg3,
            0, 9, 0x4b);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E))
    {
        /*(part of RM#3012)*/

        /* BCN Aware Packet Type */
        rc = prvCpssHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bcnRegs.bcnControlReg,
            1, 1, 0);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* En MC BCN Aware */
        rc = prvCpssHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bcnRegs.bcnControlReg,
            3, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E))
    {
        /*(part of RM#3012)*/

        /* BCN Awareness Entry */
        rc = prvCpssHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bcnRegs.portsBcnAwarenessTbl,
            0, 28, 0x0FFFFFFF);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_CCFC_SRC_PORT_WA_E))
    {
        rc = prvCpssHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bcnRegs.bcnControlReg,
            15, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_MAC_CTRL_REG3_PCS_PREAMBLE_WA_E))
    {/* prevent PCS from losing one of 8 packet preamble bytes */
        for( port = 0; port < PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,port);

            if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
            {
                PRV_CPSS_DXCH_PORT_MAC_CTRL4_REG_MAC(devNum, port,
                                                    PRV_CPSS_PORT_GE_E, &regAddr);
                fieldOffset = 2;
            }
            else
            {
                break;
            }

            rc = prvCpssHwPpSetRegField(devNum, regAddr, fieldOffset, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_PORT_SERIAL_PARAMETERS_CONFIGURATION_WA_E))
    {
        for( port = 0; port <= PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            if(port == PRV_CPSS_PP_MAC(devNum)->numOfPorts)
            {
                port = CPSS_CPU_PORT_NUM_CNS; /* CPU port */
            }
            else
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, port);
            }

            PRV_CPSS_DXCH_PORT_SERIAL_PARAM_CTRL_REG_MAC(devNum,port,&regAddr);

            rc = prvCpssHwPpSetRegField(
                devNum,regAddr, 1, 1, 0);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_LMS0_LMS1_MISC_CONFIGURATIONS_WA_E))
    {
        GT_U32  lmsAddr[2];

        lmsAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms0MiscConfig;
        lmsAddr[1] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms1MiscConfig;

        for(i = 0 ; i < 2 ; i++)
        {
            rc = prvCpssHwPpWriteRegBitMask(
                devNum,
                lmsAddr[i],
                0x118000,
                0x010000);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E))
    {
        rc = prvCpssHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ttiRegs.ttiMetalFix, 17, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_GIGA_PORT_PRBS_PARAM_INIT_WA_E))
    {
        /* FEr#3054: Gig port PRBS is not functional. */
        /* XCAT A2 and above, initial PRBS parameters */
        for (port = 24 ; port < 28 ; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, port);

            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                        perPortRegs[port].serialParameters;

            /* set PBRS parameters */
            if (prvCpssHwPpSetRegField(
                devNum, regAddr, 14 /*offset*/, 2/*length*/, 3/*value*/)
                != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E))
    {
        /* Set the < Enable Passenger Vlan Translation For TS > field, bit[10] in the Header Alteration Global Configuration
            register (offset: 0x0E800100) to 0x0 (disable). */
        rc = cpssDxChTunnelStartPassengerVlanTranslationEnableSet(devNum,GT_FALSE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if((GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_ETH_OVER_IPV4_GRE_WA_E)) &&
       PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        /* Enable HA fix - tunneling support for Eth-over-IPv4 */
        rc = prvCpssHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig,
            15, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_RM_INCORRECT_XG_SHAPER_TOKEN_BUCKET_WA_E))
    {
        /* Ports 24-27 shaping rate defaults are different than that of the ports */
        /* 0-23.                                                                  */
        /* To enable the ports 24-27 to support shaping rates identical to ports  */
        /* 0-23, set the <XgPortsTbAsGig> field, bit[31] in the Token Bucket      */
        /* Update Rate and MC FIFO Configuration Register (0x0180000C) to         */
        /* "Gig mode" (0x1).                                                      */
        /* (RM#3030)                                                              */
        rc = prvCpssHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQMcFifoEccConfig,
            31, 1, 1);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_RM_BYPASS_PACKET_REFRESH_FDB_AGE_WA_E))
    {
        /* Packets that bypass the Ingress Pipe perform a refresh of the age bit   */
        /* in the FDB.                                                             */
        /* Set the value of the <Avoid_Age_Refresh> field, bit[22] in the Bridge   */
        /* Global Configuration2, to 0x1 (enable), so that packets that bypass the */
        /* Ingress Pipe will not perform refresh of the age bit in the FDB.        */
        /* (RM#3031)                                                               */
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            /*<Avoid_Age_Refresh>*/
            regAddr = PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).
                        bridgeEngineConfig.bridgeGlobalConfig1;
            rc = prvCpssHwPpSetRegField(devNum,regAddr,
                9, 1, 1);
        }
        else
        {
            rc = prvCpssHwPpSetRegField(
                devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                bridgeRegs.bridgeGlobalConfigRegArray[2],
                22, 1, 1);
        }
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_RM_PIPE_SELECT_WA_E))
    {
        /* Wrong default in Pipe Select register and some new DFX settings. */
        /* (RM#3032)                                                        */
        rc = prvCpssHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.pipeSelect,
             0x00000001);
        if(GT_OK != rc)
        {
            return rc;
        }

        rc = prvCpssHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                dfxUnits.ingressLower.tcBist.tcamBistConfigStatus,
             0x00020003);
        if(GT_OK != rc)
        {
            return rc;
        }

        rc = prvCpssHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                dfxUnits.ingressUpper.tcBist.tcamBistConfigStatus,
             0x00020003);
        if(GT_OK != rc)
        {
            return rc;
        }
        rc = prvCpssHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.gppPadControl,
             0x00000048);
        if(GT_OK != rc)
        {
            return rc;
        }

        rc = prvCpssHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.ssmiiPadControl,
             0x00000048);
        if(GT_OK != rc)
        {
            return rc;
        }

        rc = prvCpssHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.rgmiiPadControl,
             0x00000048);
        if(GT_OK != rc)
        {
            return rc;
        }

        rc = prvCpssHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.ledPadControl,
             0x00000048);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    /* When rate limit is enabled on the FlexLink ports causes all packets
    to be dropped. (RM#3038)*/
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_RM_FLEX_LINK_PORTS_RATE_LIMIT_WA_E))
    {
        for( port = 24; port < PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, port);

            /* Configure 1Gbps port speed  */
            rc = cpssDxChBrgGenPortRateLimitSpeedGranularitySet(devNum, port,
                                                        CPSS_PORT_SPEED_1000_E);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }
    /* Wrong non-initial UDP fragments packets trap to CPU.*/
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_PTP_UDP_FRAGMENT_WA_E))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ttiRegs.ttiMetalFix;

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 17, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if((GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_XCAT_RM_PASSENGER_TPID_REG_WA_E)) &&
       (GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC(devNum)))
    {
        /* NOTE: (xcat-C0/Xcat3) we can set regardless to 'vpls enabled'
            because it suppose to be the HW defaults anyway */

        /* The registers HA/Passenger TPID0_TPID1<%n> have default value 0x0 instead of 0x81008100  */
        for(i=0; i<=7; i++)
        {
            rc = cpssDxChBrgVlanTpidEntrySet(devNum,CPSS_DXCH_ETHERTYPE_TABLE_EGRESS_LOGICAL_PORT_E,i,0x8100);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if (PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum) != GT_FALSE)
    {
        /* Bridge Global Configuration2 Register */
        /* Bit17: VPLS Mode */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.bridgeGlobalConfigRegArray[2];

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 17, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Ingress Policy Global Configuration Register */
        /* Bit15: VPLS Mode */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.control;

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 15, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiUnitConfig, 29, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig, 16, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.passengerEgressPortTagTpidSourceSelect, 0, 32, 0xFFFFFFFF);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.eqBlkCfgRegs.preEgrEngineGlobal, 24, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllGlobalReg, 14, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
             PRV_CPSS_DXCH_XCAT3_GIG_MAC_HALF_DUPLEX_COLLISION_DOMAIN_RM_E))
    {
        for (i = 0; (i < PRV_CPSS_PP_MAC(devNum)->numOfPorts); i++)
        {

            if( !PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, i) )
                continue;

            /* Set <ColDomainLimit> in Port Serial Parameters Configuration register */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[i].serialParameters;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 6, 6, 0x1d);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
        {
            /* "Internal" MAC28 and MAC29 configuration */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[0].serialParameters + 0x1c * 0x1000;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 6, 6, 0x1d);
            if(rc != GT_OK)
            {
                return rc;
            }
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[0].serialParameters + 0x1d * 0x1000;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 6, 6, 0x1d);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* CPU MAC configuration */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.cpuPortRegs.serialParameters;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 6, 6, 0x1d);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    return GT_OK;
}

/**
* @internal hwPpDxChXcat3RegsDefault function
* @endinternal
*
* @brief   Set mandatory default values for xCat3 registers
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
static GT_STATUS hwPpDxChXcat3RegsDefault
(
    IN GT_U8                                    devNum
)
{
    GT_STATUS   rc;         /* return code */
    GT_U32      regAddr;    /* register address */
    GT_U32      serdes;     /* serdes index */
    GT_U32      i;          /* loop iterator */
    GT_U8       port;       /* iterator */
    GT_U32      value;      /* register data */

    /* start with the same xCat settings */
    rc =  hwPpDxChXcatRegsDefault(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }

    if((PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_AC5_E) && PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        /* set <Tsen Reset> , otherwise can not get temperature from the sensors */
        regAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                      DFXServerUnits.DFXServerRegs.temperatureSensor28nmCtrlMSB;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                                                 devNum, regAddr, 8, 1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* Change reason: Input clock existing AC cap coupling, TERM must be set to 0 */
        /* Connects to port init parameter - clock source that changed to SECONDARY */
        regAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl0;

        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                                                 devNum, regAddr, 6, 1, 0);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    /* Unicast local switching filtering is not functional with logical ports */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
             PRV_CPSS_DXCH_XCAT3_UC_LOCAL_SWITCH_FILTER_FOR_VIRTUAL_PORTS_WA_E))
    {
        /* Set <EnaAc3FixVPortSupportForPacketDrop> in Bridge Global Configuration2 register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                    bridgeRegs.bridgeGlobalConfigRegArray[2];

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 23, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* Ingress traffic is assigned with TrunkID rather than logical port */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
             PRV_CPSS_DXCH_XCAT3_TRUNK_ID_ASSIGN_INSTEAD_OF_VIRTUAL_PORT_WA_E))
    {
        /* Set <EnaAc3FixSrcIsTrunkEq0ForVPort> in Bridge Global Configuration2 register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                    bridgeRegs.bridgeGlobalConfigRegArray[2];

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 22, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    /* Traffic on OAM loopback port is not getting highest QoS */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
             PRV_CPSS_DXCH_XCAT3_OAM_LB_PORT_NOT_GETTING_HIGHEST_QOS_WA_E))
    {
        /* Set <Metal Fix Set DP On OAM Loopback Enable> in TTI Metal Fix register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ttiRegs.ttiMetalFix;

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 19, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* NA and FU message size configuration - should be as in xCat - 2 words*/
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.auqConfig_generalControl;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 17, 2, 0);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Set to enable - avoid TTL modification for inner label for MPLS swap.
       Avoid packet corruption whaen MPLS label swap and no further label after the swapped label. */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 20, 1, 1);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                               PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E))
    {
        /* set bit <15> */
        for ( serdes = 0; serdes < 12 ; serdes++ )
        {
            rc = prvCpssHwPpSetRegField(
                 devNum,
                 PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[serdes].serdesExternalReg2,
                 15,
                 1,
                 1);
            if(rc != GT_OK)
            {
                return rc;
            }
            /* AC5 needs bit 11 to be set as well */
            if ( PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E )
            {
                rc = prvCpssHwPpSetRegField(
                     devNum,
                     PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[serdes].serdesExternalReg2,
                     11,
                     1,
                     1);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
    }

    if(PRV_CPSS_DXCH_XCAT3_A1_AND_ABOVE_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* Enable fix for the following bug:
                read address to tcam gets corrupted if reqest fifo is full  */

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTcamControl;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 29, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclTccRegs.policyTcamControl;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 29, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Enable fix for the following bug:
                IP multicast LPM mode: VID or VRF-ID  */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.bridgeInternal.dft;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 26, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* JIRA : CPSS-5097 : Packets dropped due to known UC local switching in FDB */
        /* do not enable this bit .... otherwise packets may be dropped
            (under massive FDB access by CPU) */
#if 0
        /* Enable fix for the following bug:
                CPU priority over pipe in FDB writes */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.fdbInternal.metalFix;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
#endif

        /* Enable fix for RX Activity + TX Activity */
        for(i = 0; i < 2; i++)
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ledRegs.ledHyperGStackDebugSelect[i];
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 12, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /* JIRA-8791: xCat3 devices have false DI events during Power up of Silicon
     * due to PCL CFG Table assert. Clearing the relevant interrupt cause register
     * bits.
     */
    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ipclEngineInterruptCause;
        rc = prvCpssHwPpReadRegister(devNum, regAddr/* Policy Engine Interrupt Cause */, &value);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* DMA Write access weight is increased in port RxFIFO.
       This change ensures that packets are written to memory
       If there is congestion on memory access.
       The Buffer Memory Tx Fifo Threshold and MPPM Aceess Arbiter Configuration
       Register 0x0E00006C is set as 0x4C4E6106
       For XLG ports Port Rx FIFO is set to 4 to accomodate the pressure.
       The Port FIFO Thresholds Configuration Registers 0x120D8010, 0x120D9010,
       0x120DA010, 0x120DB010 are set as 0x7BE4.
       (RM#6565603) */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                               PRV_CPSS_DXCH_XCAT3_XLG_PORT_DROP_EVENT_PROBLEM_RM_E))
    {
        /* TXDMA Buffer Memory Tx Fifo Threshold and MPPM access Arbiter Configuration Register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.txdmaBufMemTxFifoThreshold;
        rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x4c4e6106);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Port FIFO Thresholds Confiruration Registers */
        for (port= 0; (port < PRV_CPSS_PP_MAC(devNum)->numOfPorts); port++)
        {
            if((PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum, port) == PRV_CPSS_PORT_XLG_E) || (PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum, port) == PRV_CPSS_PORT_XG_E))
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                            perPortRegs[port].xlgPortFIFOsThresholdsConfig;
                rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x7BE4);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
        /* "Internal" MAC28 and MAC29 configuration */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                    perPortRegs[27].xlgPortFIFOsThresholdsConfig + 0x1000;
        rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x7BE4);
        if(rc != GT_OK)
        {
            return rc;
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                    perPortRegs[27].xlgPortFIFOsThresholdsConfig + 2 * 0x1000;
        rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x7BE4);
        if(rc != GT_OK)
        {
            return rc;
        }

    }

    /*
        xCat3 behavior:
            forward FC feature does not work due to
            PRV_CPSS_DXCH_XCAT_FC_FORWARD_NOT_FUNCTIONAL_WA_E (FE#3102).
            But MAC configuration of this feature should be done in order to
            solve another erratum - FE-8957081 (count received FC packets not functional).
            WA for FE-8957081 (FC counting) propose to enable FC forward + add TTI rule to terminate it.
            Following FE#3102 - it is not needed to add TTI rule - packet is dropped by ASIC.
            Therefore WA for FE-8957081 may be implemented as RM for XCAT3.
    */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
             PRV_CPSS_DXCH_XCAT_FC_FORWARD_NOT_FUNCTIONAL_WA_E))
    {
        for (i = 0; (i < PRV_CPSS_PP_MAC(devNum)->numOfPorts); i++)
        {

            if( !PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, i) )
                continue;

            /* Set <forward_802_3x_fc_en> in Port Serial Parameters Configuration register */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[i].serialParameters;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 3, 1, 0x1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* "Internal" MAC28 and MAC29 configuration */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[0].serialParameters + 0x1c * 0x1000;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 3, 1, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[0].serialParameters + 0x1d * 0x1000;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 3, 1, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* CPU MAC configuration */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.cpuPortRegs.serialParameters;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 3, 1, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)
    {
        /*-----------------------------------------------------------------------------------
         *  enable global dequeue
         *  - To disable dequeue, both this flag and the PortGroupDequeueEn must be 0x0.
         *   0x0 = Disabled; Disabled
         *   0x1 = Enabled; Enabled
         *-----------------------------------------------------------------------------------*/
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.globalDequeueConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 9, 1, 0x1);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal hwPpDxChLionRegsDefault function
* @endinternal
*
* @brief   Set mandatory default values for Lion2 registers
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
static GT_STATUS hwPpDxChLionRegsDefault
(
    IN GT_U8                                    devNum
)
{
    GT_STATUS   rc;             /* return code      */
    GT_U32      regAddr;        /* register address */
    GT_U32      portGroupId;    /* port group id    */
    GT_U32      serdes;         /* SERDES number    */
    GT_U32      data;
    GT_U8       port;/* port number */
    GT_U32      pclUnitBaseAddr;/* pcl unit base address */
    GT_U32      routerUnitBaseAddr;/* router unit base address */
    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC shaperConfig; /* shaper configuration */

    /* start with the same xCat settings */
    rc =  hwPpDxChXcatRegsDefault(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* add here DxCh Lion specifics */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                               PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E))
    {
        switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
        {
            case CPSS_PP_FAMILY_DXCH_LION2_E:
                for ( serdes = 0; serdes < 24 ; serdes++ )
                {
                    /* set bit <11> and <15> */
                    rc = prvCpssHwPpWriteRegBitMask(
                         devNum,
                         PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[serdes].serdesExternalReg2,
                         0x8800,
                         0x8800);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
                break;

            case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
                for ( serdes = 0; serdes < 36; serdes++ )
                {
                    /* set bit <11> and <15> */
                    rc = prvCpssHwPpWriteRegBitMask(
                         devNum,
                         PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[serdes].serdesExternalReg2,
                         0x8800,
                         0x8800);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
                break;

            default:
                break;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                               PRV_CPSS_DXCH_LION_RM_TCAM_CONFIG_WA_E))
    {
        pclUnitBaseAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclTcamConfig0 & 0xFFF00000;
        routerUnitBaseAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTcamConfig0 & 0xFFF00000;


        /*Change bits[9:8] (Read Delay field) in Policy TCAM Configuration 0 Register*/
        regAddr = pclUnitBaseAddr + 0x208;/*0x0D000208*/
        rc = prvCpssHwPpSetRegField(devNum,regAddr,8,2,0x3);
        if(rc != GT_OK)
        {
            return rc;
        }

        if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
        {
            /*Change bits[9:8] (Read Delay field) in Router TCAM Configuration 0 Register*/
            regAddr = routerUnitBaseAddr + 0x96C;/*0x0D80096C*/
            rc = prvCpssHwPpSetRegField(devNum,regAddr,8,2,0x3);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /*Change bits[15:8] (RdToRdDelay field) in Policy TCAM Configuration 2 Register Offset*/
        regAddr = pclUnitBaseAddr + 0x220;/*0x0D000220*/
        rc = prvCpssHwPpSetRegField(devNum,regAddr,8,8,0x17);
        if(rc != GT_OK)
        {
            return rc;
        }

        if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
        {
            /* fix the compare read delay after read for the TCAM:
                Register CPU 0x0D800978 Bits[15:8] should be set to 0x24.
                This is important for proper TCAM bist & Router activation */
            regAddr = routerUnitBaseAddr + 0x978;/*0x0D800978*/
            rc = prvCpssHwPpSetRegField(devNum,regAddr,8,8,0x24);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /*Change bits[27:24] (ECCCycleReset field) in Policy TCAM Control Register*/
        regAddr = pclUnitBaseAddr + 0x148;/*0x0D000148*/
        rc = prvCpssHwPpSetRegField(devNum,regAddr,24,4,0xf);
        if(rc != GT_OK)
        {
            return rc;
        }

        if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
        {
            /*Change bits[27:24] (ECCCycleReset field) in Router TCAM Control Register*/
            regAddr = routerUnitBaseAddr + 0x978;/*0x0D800978*/
            rc = prvCpssHwPpSetRegField(devNum,regAddr,24,4,0xf);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /* WA for "Token Buckets are not supported" */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E))
    {
        /* check that device Lion B0A revision */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.chipId;/*0xD4*/
        portGroupId = 0;
        rc = prvCpssDrvHwPpPortGroupReadRegister(devNum, portGroupId,
                                                 regAddr, &data);
        if(rc != GT_OK)
        {
            return rc;
        }

        if ( (data != 0) || (PRV_CPSS_PP_MAC(devNum)->revision > 2) ||
             (PRV_CPSS_PP_MAC(devNum)->devFamily >= CPSS_PP_FAMILY_DXCH_LION2_E) )
        {
            /* this is Lion B0A revision or B1 and above.
               Set the <TxQStartInit> field to '0x1' */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl4;/*0x00000364*/
            rc = prvCpssDrvHwPpPortGroupSetRegField(devNum, portGroupId, regAddr,
                                                    3, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* disable the old WA in order to enable shaper API */
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum,
                                           PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E);
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_FDB_LIMIT_WA_E))
    {
        /* Disable Auto-learning, per port */
        for( port = 0; port < PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,port);

            rc = cpssDxChBrgFdbPortLearnStatusSet(devNum, port, GT_FALSE, CPSS_LOCK_FRWRD_E);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /*Set the Age mode to Age-without-delete*/
        rc = cpssDxChBrgFdbActionModeSet(devNum,CPSS_FDB_ACTION_AGE_WITHOUT_REMOVAL_E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
    {
        /*Set the Age mode to Age-without-delete*/
        rc = cpssDxChBrgFdbActionModeSet(devNum,CPSS_FDB_ACTION_AGE_WITHOUT_REMOVAL_E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_ORIG_SRC_PORT_FILTERING_WA_E))
    {
        /* set the device to filter the srcPort of own device on DSA tag frames */
        rc = cpssDxChCscdOrigSrcPortFilterEnableSet(devNum,GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_CN_GLOBAL_REG_WA_E))
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            /*Set the CnDropEn field, bit[5] in the CN Global Configuration register,
            (offset: 0x0A0B0000) to 0x1 (enable).*/
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.
                congestNotification.cnGlobalConfigReg;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 5, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_TEMPERATURE_SENSOR_INITIALIZATION_WA_E))
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            /* need to Calibrate sensor on init in every power up
             (all below registers are in PortGroup0) */
            portGroupId = 0;

            /* 1) Change Temperature sensor average num from 2 to 8 and enable On-The-Fly
                  calibration -
                  Register 0x118F0D88 Bits[21:19] = 0x3 & & Bit[23] = 0x1 */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.sht.dfx.dfx2;/*0x118F0D88*/
            rc = prvCpssHwPpPortGroupWriteRegBitMask(devNum, portGroupId ,regAddr,
                                                         0xB80000, 0x980000);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* 2) Change Temperature sensor RefCalCount from 0x113 to 0xf1 -
                  Register 0x118F0D8C Bits[17:9] = 0xF1 */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.sht.dfx.dfx3;/*0x118F0D8C*/
            rc = prvCpssHwPpPortGroupSetRegField(devNum, portGroupId ,regAddr, 9, 9, 0xf1);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* 3) Start init -
                  Register 0x118F0D8C Bit[31] = 0x0*/
            rc = prvCpssHwPpPortGroupSetRegField(devNum, portGroupId ,regAddr, 31, 1, 0);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* 4) Start init -
                  Register 0x118F0D8C Bit[31] = 0x1 */
            rc = prvCpssHwPpPortGroupSetRegField(devNum, portGroupId ,regAddr, 31, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_SD_PLL_REG_WA_E))
    {
        /*
            for XLG port proper work :
            Set the following registers in portGroup 0:
            1) Set register 0x378 = 0xD
            2) Delay 20uSec
            3) Set register 0x374 = 0x36203001
            4) Set register 0x378 = 0xC
            5) Delay 50uSec
            6) Set register 0x378 = 0x9E
        */
        portGroupId = 0;

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sdPllCtrl; /* 0x378 */

        /*1) Set register 0x378 = 0xD*/
        rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, regAddr,0xD);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* 2) Delay 20uSec */
        cpssOsTimerWkAfter(1);/*1 msec --> 1000 usec */

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sdPllParams; /* 0x374 */

        /* 3) Set register 0x374 = 0x36203001 */
        rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, regAddr,0x36203001);
        if(rc != GT_OK)
        {
            return rc;
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sdPllCtrl; /* 0x378 */

        /* 4) Set register 0x378 = 0xC */
        rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, regAddr,0xC);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* 5) Delay 50uSec */
        cpssOsTimerWkAfter(1);/*1 msec --> 1000 usec */

        /* 6) Set register 0x378 = 0x9E */
        rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, regAddr,0x9E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_UC_STRICT_OVER_MC_WA_E))
    {
        /*  With default configurations, the UC are not served at WS in presence of */
        /*  MC, therfore give UC Strict Priority over MC.                           */
        /*  Set bit 2 in the MC FIFO Global Configurations Register (0x01801000).   */
        /* (RM#2710)                                                                */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.egr.mcFifoConfig.globalConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 2, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_SCHEDULER_DEFICIT_MODE_WA_E))
    {
        /* The TxDMA isn't always ready to receive descriptor from the TxQ when      */
        /* instantaneous burstiness of data occurs.                                  */
        /* (RM#2709)                                                                 */
        /* The workaround consists of 2 steps:                                       */
        /* 1. Enabling the Deficit mode (handles higher burstiness of data on the    */
        /*    ports).                                                                */
        rc = cpssDxChPortTxSchedulerDeficitModeEnableSet(devNum, GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* 2. Set <Token Bucket Base Line> value to at least eight times the MTU.     */
        /* Get MTU value */
        rc = cpssDxChPortTxShaperConfigurationGet(devNum,&shaperConfig);
        if(rc != GT_OK)
        {
            return rc;
        }

        if( shaperConfig.portsPacketLength >= _2M )
        {
            /* MTU is too large and multiply by 8 will cause overflow. */
            /* Set max value for Base Line.                            */
            data = BIT_24 - 1;
        }
        else
        {
            /* Get Base Line value */
            rc = cpssDxChPortTxShaperBaselineGet(devNum, &data);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* If <Base Line> >= 8*MTU, do nothing, */
            /* Else <Base Line> = 8*MTU.            */
            if( data >= (8 * shaperConfig.portsPacketLength) )
            {
                data = 0;
            }
            else
            {
                data = (8 * shaperConfig.portsPacketLength);
            }
        }

        if( data > 0 )
        {
            /* Set Base Line value */
            rc = cpssDxChPortTxShaperBaselineSet(devNum, data);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_TX_MC_IN_CHUNKS_WA_E))
    {
        /* WS is not achieved in "one to many" traffic at 316 Bytes and below.        */
        /* Set the number of MC descriptors duplications done per UC descriptor       */
        /* to 4:1.                                                                    */
        /* Clear bits 1:0 in the MC FIFO Global Configurations Register (0x01801000). */
        /* (RM#2711)                                                                  */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.egr.mcFifoConfig.globalConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 2, 0);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_BUFF_LIMIT_EGRESS_QUEUE_WA_E))
    {
        /* Wrong total number of buffers limit in egress queues.                     */
        /* Set bits 13:0 in the Global Buffer Limit Register (0x0A0A0310) to 0x1e70. */
        /* (RM#2712)                                                                 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.globalBufferLimit;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 14, 0x1e70);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

     if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_QCN_FORMAT_COMPLIANT_WA_E))
     {
         /* QCN frame format is partially compliant with IEEE 802.1 Qau.   */
         /* Set bit 0 in the HA Misc Configuration Register (0xE800710). */
         /* (FEr#2703)                                                     */
         regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.miscConfig;
         rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
         if(rc != GT_OK)
         {
             return rc;
         }
     }

     if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_INCOMPLETE_CPU_MAILBOX_INFO_WA_E))
     {
         /* CPU Mailbox to Neighbor CPU Device source information is not */
         /* complete.                                                    */
         /* (FEr#2776)                                                   */
         /* Lion2, Bobcat2, Caelum, Bobcat3 */
         regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                     txqVer1.queue.tailDrop.config.config;
         rc = prvCpssHwPpSetRegField(devNum, regAddr, 7, 1, 1);
         if(rc != GT_OK)
         {
             return rc;
         }
     }

     if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_INACCURATE_PFC_XOFF_WA_E))
     {
         /* The response to the XOFF PFC frame is inaccurate.              */
         /* Set bit 19 in the TTI Misc Confuguration Register (0x1000200). */
         /* (RM#2788)                                                      */
         regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ttiRegs.ttiMiscConfig;
         rc = prvCpssHwPpSetRegField(devNum, regAddr, 19, 1, 1);
         if(rc != GT_OK)
         {
             return rc;
         }
     }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                    PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E))
    {
        PRV_CPSS_PORT_TYPE_ENT portMacType;

        for(port = 0; (port < PRV_CPSS_PP_MAC(devNum)->numOfPorts)
                                                    && (port < 12); port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,port);

            for(portMacType = PRV_CPSS_PORT_GE_E; portMacType <
                                            PRV_CPSS_PORT_NOT_APPLICABLE_E;
                portMacType++)
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                    perPortRegs[port].macRegsPerType[portMacType].fcDsaTag2;
                if(regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
                {
                    rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x0101);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                    perPortRegs[port].macRegsPerType[portMacType].fcDsaTag3;
                if(regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
                {
                    rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x8808);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }

                /* extended ports of Lion2 will be configured when reach XLG MAC */

            }/* end of for(portMacType = PRV_CPSS_PORT_GE_E*/

        }/* end of for(port = 0; */

     }/* end of PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E */

     /*  RM number not set yet - Enable the PFC trigger*/
     if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_LION_RM_ENABLE_PFC_TRIGGER_WA_E))
     {
         regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.pfcRegs.pfcGlobalConfigReg;
         rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
         if (rc != GT_OK)
         {
             return rc;
         }
     }
     return GT_OK;
}


/**
* @internal prvCpssLion2FalseInterruptRegReset function
* @endinternal
*
* @brief   Reset false interrupt after reset in cause register.
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in] memType                  - memory type
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
static GT_STATUS prvCpssLion2FalseInterruptRegReset
(
    IN GT_U8 devNum,
    IN CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_ENT  memType
)
{
    GT_STATUS rc = GT_OK; /* return code */
    GT_U32 i;             /* iterator */
    GT_U32 regValue;      /* register's value */
    GT_U32 arraySize;     /* memory locations array size */
    CPSS_DIAG_DATA_INTEGRITY_MEMORY_LOCATION_STC memLocationArr[LION2_DATA_INTEGRITY_MAX_LOCATION_NUM_PER_MEMORY_CNS]; /* memory locations array */
    CPSS_DIAG_DATA_INTEGRITY_MEM_ERROR_PROTECTION_TYPE_ENT  protType; /* memory protection type */

    arraySize = LION2_DATA_INTEGRITY_MAX_LOCATION_NUM_PER_MEMORY_CNS;

    rc = prvCpssDxChDiagDataIntegrityMemoryIndexesGet(devNum,
                                                      memType,
                                                      GT_FALSE, 0,
                                                      &arraySize,
                                                      memLocationArr,
                                                      &protType);
    if (rc != GT_OK)
    {
        return rc;
    }

    if (protType != CPSS_DIAG_DATA_INTEGRITY_MEM_ERROR_PROTECTION_TYPE_NONE_E)
    {
        for (i = 0; i < arraySize; i++)
        {
            rc = prvCpssDfxMemoryRegRead(devNum,
                                         memLocationArr[i].dfxPipeId,
                                         memLocationArr[i].dfxClientId,
                                         memLocationArr[i].dfxMemoryId,
                                         0x1c/* Interrupt Cause Register */,
                                         &regValue);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    return GT_OK;
}

/**
* @internal lion2PortUnitHglSumIndex function
* @endinternal
*
* @brief   Set mandatory default values for Lion2 registers
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
extern PRV_CPSS_LION2_INT_CAUSE_ENT lion2PortUnitHglSumIndex
(
    IN GT_PHYSICAL_PORT_NUM localPort
);

/**
* @internal prvCpssDxChDfxWtcRtcMemoryWrite function
* @endinternal
*
* @brief   Function configures the minimal WTC/RTC values to the memories.
*
* @note   APPLICABLE DEVICES:      Bobcat2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2;
*
* @param[in] devNum                   - PP device number
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on wrong device
* @retval GT_TIMEOUT               - on BIST timeout
* @retval GT_BAD_STATE             - on BIST failure
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note RM-9308357 -
*       DFX Register Misconfiguration
*       Need to write the minimal values to the memories during device init.
*
*/
static GT_STATUS prvCpssDxChDfxWtcRtcMemoryWrite
(
    IN  GT_U8   devNum
)
{
    GT_STATUS rc;               /* return code */
    GT_U32 index = 0;
    struct{
        GT_U32  address;
        GT_U32  data;
    }dfxDataRegs[] =
    {
      {0x000f8000, 0x00000007},  /* enable all pipes                                    */
      {0x000e2000, 0x0807E100},  /* ram select = 126  , BC Addr.                        */
      {0x000e2008, 0x00040000},  /* RAM MC Group = RF2, BC Addr.                        */
      {0x000e1f80, 0x00000000},  /* RTC=0x0, WTC=0, BC Addr , MC RAM                    */
      {0x000e2008, 0x00038000},  /* RAM MC Group = RF1, BC Addr.                        */
      {0x000e1f80, 0x00000000},  /* RTC=0x0, WTC=0, BC Addr , MC RAM                    */
      {0x000e2008, 0x00028000},  /* RAM MC Group = SR1, BC Addr.                        */
      {0x000e1f80, 0x00000048},  /* RTC=0x1, WTC=0, BC Addr , MC RAM                    */
      {0x000e2008, 0x00030000},  /* RAM MC Group = SR2, BC Addr.                        */
      {0x000e1f80, 0x00000048},  /* RTC=0x1, WTC=0, BC Addr , MC RAM                    */
      {0x000e2000, 0x00000040},  /* Restore Client Control register default value       */
      {0x000e2008, 0x0000001f},  /* Restore Client Data Control register default value  */
      {0xFFFFFFFF, 0xFFFFFFFF}
    };

    while(dfxDataRegs[index].address != 0xFFFFFFFF)
    {
        /* Timing Adjustment Configurations */
        rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, dfxDataRegs[index].address, dfxDataRegs[index].data);
        if (rc != GT_OK)
        {
            return rc;
        }
        index++;
    }

    return GT_OK;
}

extern GT_STATUS clientGroupForRepresentativePortGroupSet
(
    IN  GT_U8                               devNum,
    IN  GT_PORT_GROUPS_BMP                  portGroupsBmp,
    IN  GT_U32                              hwClientId,
    IN  GT_U32                              tcamGroup,
    IN  GT_U32                              representativePortGroupId,
    IN  GT_BOOL                             enable
);
/* set the GM with 'Hard wired' values of the bobcat3 */
static GT_STATUS GM_bobcat3TcamClientsHardWireSet(IN GT_U8 devNum)
{
    GT_STATUS rc;
    GT_U32  ii;

    for(ii = 0 ; ii < 5 ; ii++)
    {
        rc = clientGroupForRepresentativePortGroupSet(devNum,
            BIT_0/*single pipe*/, ii , ii , 0 , GT_TRUE);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChCgMacUnitDisable function
* @endinternal
*
* @brief   CG MAC unit enable/disable for power reduction purposes.
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X.
*
* @param[in] devNum                   - physical device number
* @param[in] disable                  - CG MAC unit disable
*                                      GT_TRUE - CG Unit disabled
*                                      GT_FALSE - CG Unit enabled
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong port number or device
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChCgMacUnitDisable
(
    IN  GT_U8 devNum,
    IN  GT_BOOL disable
)
{
    GT_STATUS rc;
    GT_U32 portNum;
    GT_U32 regAddr;
    GT_U32 regValue = (disable == GT_TRUE) ? 0 : 1;

    /* Unresetting the CG regfile registers reset bit in order to be able to access them.
       Setting the reset bit back to reset will cause error when accessing the CG regfile
       registers, hence the reset bit should be unreset at init and never be reset again. */
    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                                PRV_CPSS_DXCH_BOBCAT3_CG_REGFILE_UNRESET_WA_E))
    {
        for (portNum = 0; portNum < PRV_CPSS_PP_MAC(devNum)->numOfPorts; portNum++)
        {
            /* CG ports (BC3/Aldrin2...) */
            PRV_CPSS_DXCH_REG1_CG_CONVERTERS_RESETS_REG_MAC(devNum, portNum, &regAddr);
            if (regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
            {
                rc = prvCpssHwPpSetRegField(devNum, regAddr, 26, 1, regValue);
                if (rc != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "CG regfile unreset operation failed");
                }

                if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)
                {
                    rc = prvCpssHwPpSetRegField(devNum, regAddr, 30, 1, regValue);
                    if (rc != GT_OK)
                    {
                        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "CG regfile unreset operation failed");
                    }
                }

                /* invalidate CG port register database */
                rc = prvCpssDxChCgPortDbInvalidate(devNum, portNum, disable);
                if (rc != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                /* the port is not CG .. it is ok .. skip it */
            }
        }
    }

    return GT_OK;
}

/* duplicate register content from MG0 to other MGs
    NOTE: the implementation assumes that the duplication engine recognize the
    register as one that allowed to be duplicated per MG.
*/
static GT_STATUS sip6Mg0RegDupToOtherMgs(
    IN GT_U8  devNum,
    IN GT_U32    regAddr
)
{
    GT_STATUS rc;
    GT_U32  regValue;

    /* read value from MG0 */
    rc = prvCpssHwPpReadRegister(devNum, regAddr , &regValue);
    if(rc != GT_OK)
    {
        return rc;
    }
    /* write value to ALL MG units */
    return prvCpssHwPpWriteRegister(devNum, regAddr , regValue);
}


/* duplicate 'SDMA windows/connctions' from MG0 to other MGs

    NOTE: in sip6 the MG0 register set by application only AFTER 'phase 1'
    therefore this function is called only from 'phase 2'
*/
static GT_STATUS sdmaMultiMgSupport(IN GT_U8  devNum)
{
    GT_STATUS rc; /* return code */
    GT_U32 baseAddress, windowSize, highAddressRemap, windowControl;
    GT_U32  regAddr;
    GT_U32  ii,jj;

    if(!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        /* not relevant */
        return GT_OK;
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* the Driver did not synch this register for all the MGs because at that
           stage the cpss engine of conversion of MG0 address to other MG was not
           ready
           so we synch all MGs to MG0 now....
        */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->sdmaRegs.sdmaCfgReg;/*SDMA_CFG_REG_ADDR*/
        /* copy configuration from MG0 to all other MGs */
        /* configure ALL MGs for address decoding       */
        rc = sip6Mg0RegDupToOtherMgs(devNum,regAddr);
        if(rc != GT_OK)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.UnitDefaultID;
        /* copy configuration from MG0 to all other MGs */
        /* configure ALL MGs for address decoding       */
        rc = sip6Mg0RegDupToOtherMgs(devNum,regAddr);
        if(rc != GT_OK)
        {
            return rc;
        }

        for(jj = 0 ; jj < 6 ; jj ++)/* support 6 windows */
        {
            regAddr = PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.baseAddress[jj];
            /* copy configuration from MG0 to all other MGs */
            /* configure ALL MGs for address decoding       */
            rc = sip6Mg0RegDupToOtherMgs(devNum,regAddr);
            if(rc != GT_OK)
            {
                return rc;
            }
            regAddr = PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.windowSize[jj];
            /* copy configuration from MG0 to all other MGs */
            /* configure ALL MGs for address decoding       */
            rc = sip6Mg0RegDupToOtherMgs(devNum,regAddr);
            if(rc != GT_OK)
            {
                return rc;
            }
            regAddr = PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.highAddressRemap[jj];
            /* copy configuration from MG0 to all other MGs */
            /* configure ALL MGs for address decoding       */
            rc = sip6Mg0RegDupToOtherMgs(devNum,regAddr);
            if(rc != GT_OK)
            {
                return rc;
            }
            regAddr = PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.windowControl[jj];
            /* copy configuration from MG0 to all other MGs */
            /* configure ALL MGs for address decoding       */
            rc = sip6Mg0RegDupToOtherMgs(devNum,regAddr);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }
    else /* sip5_25 (Bobcat3/Aldrin2) */
    {
        /* configure MG#1-3 for address decoding*/
        GT_BOOL activeMg[CPSS_4_SDMA_CPU_PORTS_CNS-1] = {GT_FALSE,GT_FALSE,GT_FALSE};

        for(jj = 0 ; jj < 6 ; jj++) /* support 6 windows */
        {
            /*Read address decoding registers from MG#0*/
            rc = prvCpssHwPpReadRegister(devNum, PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.baseAddress[jj], &baseAddress);
            if(rc != GT_OK)
            {
                return rc;
            }
            rc = prvCpssHwPpReadRegister(devNum, PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.windowSize[jj], &windowSize);
            if(rc != GT_OK)
            {
                return rc;
            }
            rc = prvCpssHwPpReadRegister(devNum, PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.highAddressRemap[jj], &highAddressRemap);
            if(rc != GT_OK)
            {
                return rc;
            }
            rc = prvCpssHwPpReadRegister(devNum, PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.windowControl[jj], &windowControl);
            if(rc != GT_OK)
            {
                return rc;
            }
            /*Write address decoding registers to MG#1-3 (if mapped)*/
            if (PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->hwInfo[0].resource.mg1.start != 0)
            {
                activeMg[0] = GT_TRUE;
            }
            if (PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->hwInfo[0].resource.mg2.start != 0)
            {
                activeMg[1] = GT_TRUE;
            }
            if (PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->hwInfo[0].resource.mg3.start != 0)
            {
                activeMg[2] = GT_TRUE;
            }
            for (ii = 0; ii< (CPSS_4_SDMA_CPU_PORTS_CNS-1); ii++)
            {
                if (activeMg[ii] == GT_TRUE)
                {
                    rc = prvCpssDrvHwPpResourceWriteRegister(devNum, 0, CPSS_DRV_HW_RESOURCE_MG1_CORE_E+ii, PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.baseAddress[jj], baseAddress);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                    rc = prvCpssDrvHwPpResourceWriteRegister(devNum, 0, CPSS_DRV_HW_RESOURCE_MG1_CORE_E+ii, PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.windowSize[jj], windowSize);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                    rc = prvCpssDrvHwPpResourceWriteRegister(devNum, 0, CPSS_DRV_HW_RESOURCE_MG1_CORE_E+ii, PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.highAddressRemap[jj], highAddressRemap);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                    rc = prvCpssDrvHwPpResourceWriteRegister(devNum, 0, CPSS_DRV_HW_RESOURCE_MG1_CORE_E+ii, PRV_DXCH_REG1_UNIT_MG_MAC(devNum).addressDecoding.windowControl[jj], windowControl);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }
    }

    return GT_OK;
}

/* sip5 : check that the init TCAM default values was done */
GT_STATUS prvCpssHwInitSip5IsInitTcamDefaultsDone(IN GT_U8   devNum, GT_BOOL tcamDaemonEnable)
{
    GT_STATUS   rc;
    GT_U32 regAddr;
    GT_U32 numOfFloorsInTcam;
    GT_U32 tcamTableEntriesAmount;
    GT_U32 tcamTableRuleIndexLast;
    GT_U32 tcamTableEntriesXLast, tcamTableEntriesYLast;
    GT_U32 data[3];
    GT_U32 checkCnt;

    numOfFloorsInTcam = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.tcam.maxFloors;

    tcamTableEntriesAmount =
        (numOfFloorsInTcam * 12 /*banks*/ * 256 /*rows*/ * 2 /*X and Y*/);
    tcamTableRuleIndexLast = ((tcamTableEntriesAmount / 2) - 1);
    rc = prvCpssDxChTcamRuleIndexToEntryNumber(
        devNum, tcamTableRuleIndexLast,
        &tcamTableEntriesXLast, &tcamTableEntriesYLast);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* check that the end of TCAM updated */
    for (checkCnt = 10000; (checkCnt != 0); checkCnt--)
    {
        rc = prvCpssDxChReadTableEntry(
            devNum, CPSS_DXCH_SIP5_TABLE_TCAM_E,
            tcamTableEntriesYLast, data);
        if (rc != GT_OK) return rc;
        if (data[0] != 0) break;
        cpssOsTimerWkAfter(1); /* wait 1 millisecond */
    }

    if (checkCnt == 0)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, "The tcam not finished initializing the last entry");
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->TCAM.parityDaemonRegs.parityDaemonCtrl;
    /* Deactivate reload of TCAM with default data */
    rc = prvCpssHwPpSetRegField(
        devNum, regAddr,
        1/*offset*/, 1/*length*/, 1/*data*/);
    if (rc != GT_OK)
    {
        return rc;
    }

    if (tcamDaemonEnable == GT_FALSE)
    {
        /* disable TCAM daemon because it was disabled before init TCAM */
        rc = cpssDxChDiagDataIntegrityTcamParityDaemonEnableSet(devNum,CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_POLICY_TCAM_E, GT_FALSE);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChHwInitSip5TcamDefaultsInit function
* @endinternal
*
* @brief   Set whole TCAM to HW default values.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                - device number
*
* @retval GT_OK                    - on success
* @retval GT_TIMEOUT               - on failure by timeout
* @retval GT_BAD_PARAM             - on bad parameter
*/
GT_STATUS prvCpssDxChHwInitSip5TcamDefaultsInit(IN GT_U8   devNum)
{
    GT_STATUS   rc;
    GT_U32 regAddr;
    GT_U32 numOfFloorsInTcam;
    GT_U32 tcamTableEntriesAmount;
    GT_U32 tcamTableRuleIndexLast;
    GT_U32 tcamTableEntriesXLast, tcamTableEntriesYLast;
    GT_BOOL tcamDaemonEnable;

    numOfFloorsInTcam = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.tcam.maxFloors;

    tcamTableEntriesAmount =
        (numOfFloorsInTcam * 12 /*banks*/ * 256 /*rows*/ * 2 /*X and Y*/);
    tcamTableRuleIndexLast = ((tcamTableEntriesAmount / 2) - 1);
    rc = prvCpssDxChTcamRuleIndexToEntryNumber(
        devNum, tcamTableRuleIndexLast,
        &tcamTableEntriesXLast, &tcamTableEntriesYLast);
    if (rc != GT_OK)
    {
        return rc;
    }

    #ifndef ASIC_SIMULATION /* Yet not implemented in simulation */
    {
        GT_U32 data[3];
        /* write zero to the end of TCAM */
        data[0] = 0; data[1] = 0; data[2] = 0;
        rc = prvCpssDxChWriteTableEntry(
            devNum, CPSS_DXCH_SIP5_TABLE_TCAM_E,
            tcamTableEntriesYLast, data);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    #endif /*!ASIC_SIMULATION*/

    /* get TCAM daemon status */
    rc = cpssDxChDiagDataIntegrityTcamParityDaemonEnableGet(devNum,CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_POLICY_TCAM_E, &tcamDaemonEnable);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* disable TCAM daemon before change configurations */
    rc = cpssDxChDiagDataIntegrityTcamParityDaemonEnableSet(devNum,CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_POLICY_TCAM_E, GT_FALSE);
    if (rc != GT_OK)
    {
        return rc;
    }

    /**************************************/
    /* set proper boundary for the deamon */
    /**************************************/
    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->TCAM.parityDaemonRegs.parityDaemonWriteAdressEnd;
    rc = prvCpssHwPpWriteRegister(
        devNum, regAddr,tcamTableEntriesYLast);
    if (rc != GT_OK)
    {
        return rc;
    }
    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->TCAM.parityDaemonRegs.parityDaemonReadAdressEnd;
    rc = prvCpssHwPpWriteRegister(
        devNum, regAddr,tcamTableEntriesYLast);
    if (rc != GT_OK)
    {
        return rc;
    }

    if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        /* change step to load all entries */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->TCAM.parityDaemonRegs.parityDaemonWriteAdressJump;
        rc = prvCpssHwPpWriteRegister(devNum, regAddr, 1);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->TCAM.parityDaemonRegs.parityDaemonCtrl;
    /* Activate reload of TCAM with default data */
    rc = prvCpssHwPpSetRegField(
        devNum, regAddr,
        1/*offset*/, 1/*length*/, 0/*data*/);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* enable TCAM daemon */
    rc = cpssDxChDiagDataIntegrityTcamParityDaemonEnableSet(devNum,CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_POLICY_TCAM_E, GT_TRUE);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(!cpssDeviceRunCheck_onEmulator())
    {
        /****************************************/
        /* wait now for the tcam to finish init */
        /****************************************/
        rc = prvCpssHwInitSip5IsInitTcamDefaultsDone(devNum, tcamDaemonEnable);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}


/**
* @internal prvCpssDxChHwLmuInit function
* @endinternal
*
* @brief  Init LMU Unit
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                - device number
*
* @retval GT_OK                    - on success.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
*/
static GT_STATUS prvCpssDxChHwLmuInit
(
    IN  GT_U8   devNum
)
{
    GT_STATUS       rc;      /* return code */
    GT_U32          lmuIdx;  /* LMU index   */
    GT_U32          lmuNum;  /* number of LMUs in device */
    GT_U32          regAddr; /* address of register */

    if(0 == PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lmuInfo.numLmuUnits)
    {
        /* support Ironman without LMU unit */
        return GT_OK;
    }

    if (!PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    /* Hawk has 1 LMU per datapath */
    lmuNum = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.maxDp;

    for (lmuIdx = 0; lmuIdx < lmuNum; lmuIdx++)
    {
        /* Hawk use channel0 of LMUs. Enable it. */
        regAddr = PRV_DXCH_REG1_UNIT_LMU_MAC(devNum, lmuIdx).channelEnable;
        rc = prvCpssHwPpSetRegField(devNum,regAddr, 0, 1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal tseneReadoutBusyWait function
* @endinternal
*
* @brief   Query the temperature sensor readout bit in busy wait.
*
* @note   APPLICABLE DEVICES:      AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                - device number
* @param[in] regaddr               - register address
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_READY             - the temperature reading is not valid
*/
static GT_STATUS tseneReadoutBusyWait
(
    IN  GT_U8   devNum,
    IN  GT_U32  regAddr
)
{
    GT_STATUS   rc;
    GT_U32      busyIterator; /* busy wait iterator */
    GT_U32      hwValue;

    busyIterator = 0;

    /* use "busy" wait */
    do
    {
        /* check if TSENE is active(power up) */
        /* bit 17 in the register */
        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 18, &hwValue);
        if(rc != GT_OK)
        {
            return rc;
        }
        /* check that number of iteration not over the limit */
        PRV_CPSS_MAX_NUM_ITERATIONS_CHECK_CNS(devNum,(busyIterator++));
    }
    while((hwValue & BIT_17) == 0);

    return GT_OK;
}

/**
* @internal tseneMandatoryRegValuesSet function
* @endinternal
*
* @brief   This routine sets mandatory register value for tsene.
*
* @note   APPLICABLE DEVICES:      AC5; AC5P; AC5X.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; Harrier; Ironman.
*
* @param[in] devNum                - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - otherwise
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS tseneMandatoryRegValuesSet
(
    IN  GT_U8  devNum
)
{
    GT_STATUS   rc;
    GT_U32      regAddr, regAddr1, regAddr2; /* addresses of registers */
    GT_U32      data; /* data of register  */
    GT_BOOL     manualRead; /* is manual read procedure needed */

    if ( cpssDeviceRunCheck_onEmulator() )
    {
        return GT_OK;
    }

    /* AC5 and AC5X need manual procedure to read TSEN data */
    manualRead = (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E ||
                  PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E) ? GT_TRUE : GT_FALSE;

    if (manualRead)
    {
        /* External Temperature Sensor 12 nm Status (0x000F80DC) */
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                      DFXServerUnits.DFXServerRegs.externalTemperatureSensorStatus;

        /* External Temperature Sensor 12 nm Control 0 (0x000F80D0) */
        regAddr1 = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                      DFXServerUnits.DFXServerRegs.externalTemperatureSensorControlLSB;

        /* External Temperature Sensor 12 nm Control 2 (0x000F80D8) */
        regAddr2 = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                      DFXServerUnits.DFXServerRegs.externalTemperatureSensorControlMSB;

        rc = prvCpssHwPpGetRegField(devNum, regAddr1, 0, 3, &data);
        if(rc != GT_OK)
        {
            return rc;
        }

        if (data == 0x5)
        {
            /* TSEN already configured. It's may happen after Soft Reset or init without Soft/Hard reset */
            return GT_OK;
        }

        /* S1:Check TESENE is active (only once) */
        /* Read TSENE Power Up Active field(BIT#17) in busy wait until 1(ACTIVE) */
        rc  = tseneReadoutBusyWait(devNum, regAddr);
        if(rc != GT_OK)
        {
            return rc;
        }
        /*
         * S2:Move TSENE to SW control (only once)
         * Write below bits to External Temperature Sensor 12 nm Control 0 register
         * bit[0] : 1 (keep conversion/measurement active)
         * bit[1] : 0 (keep TSENE out of reset active)
         * bit[2] : 1 (keep TSENE enable)
         */
        rc = prvCpssHwPpSetRegField(devNum, regAddr1, 0, 3, 0x5);
        if(rc != GT_OK)
        {
            return rc;
        }

        /*
         * Write below bits to External Temperature Sensor 12 nm Control 2 register
         * bit[26] : 1 (Disable the automated Power-Up State Machine)
         */
        rc = prvCpssHwPpSetRegField(devNum, regAddr2, 26, 1, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* HW default is too low, need to increase it.   */
    rc = cpssDxChDiagDeviceTemperatureThresholdSet(devNum, 115/* Degrees Celsius*/);
    if(rc != GT_OK)
    {
        return rc;
    }

    /*
     * enable TSENE interrupt (TSEN_INT pin)
     */
    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
    {
        regAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl34;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 16, 1, 0x0);
    }
    else
    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E)
    {
        regAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl44;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 16, 1, 0x0);
    }
    else
    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E)
    {
        regAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl21;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 2, 1, 0x0);
    }

    return rc;
}

/**
* @internal hwPpDxChLion2RegsDefault function
* @endinternal
*
* @brief   Set mandatory default register values
*
* @note   APPLICABLE DEVICES:       Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   xCat3; AC5.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
static GT_STATUS hwPpDxChLion2RegsDefault
(
    IN GT_U8                                    devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC       *ppPhase1ParamsPtr
)
{
    GT_STATUS rc = GT_OK; /* return code */
    GT_U32 regAddr;       /* register's address */
    GT_U32 xData[8];      /* memory data */
    GT_U32 yData[8];      /* memory data */
    GT_U32 regValue = 0;  /* register's value */
    GT_U32 i;             /* iterator */
    GT_U32 ii;            /* iterator */
    GT_U32 portGroupId;   /* number of local core */
    GT_PHYSICAL_PORT_NUM localPort; /* number of port in local core */
    CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_ENT  memType; /* memory type for register reset */
    GT_U32 xParity;       /* X parity */
    GT_U32 yParity;       /* Y parity */
    GT_U32 ruleIndex;     /* TCAM rule index */
    GT_U32 index;         /* TCAM rule index */
    GT_BOOL ucSPEnable;   /* use SP or DSWRR sceduling */
    GT_U32 ucWeight;      /* unicast weight */
    GT_U32 mcWeight;      /* multicast weight */
    CPSS_DXCH_IP_MT_UC_SCHED_MTU_ENT schedMtu;  /* Scheduler MTU */
    CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT profile;       /* scheduler profile */
    GT_U32                          ptpClkInKhz; /* PTP clock in KHz */
    CPSS_DXCH_PTP_TAI_ID_STC        taiId;      /* TAI Units identification */
    CPSS_DXCH_PTP_TAI_TOD_STEP_STC  todStep;    /* TOD Step */
    GT_U32 totalTaiGop;
    CPSS_SYSTEM_RECOVERY_INFO_STC oldSystemRecoveryInfo;
    CPSS_SYSTEM_RECOVERY_INFO_STC newSystemRecoveryInfo;
    GT_U8                           tileIndex;
    GT_U8                           ravenIndex;
    GT_U8                           taiNumber;
    GT_U32                          *frameLatencyArrPtr = NULL;
    GT_U32                          *frameLatencyFracArrPtr = NULL;
    CPSS_DXCH_PORT_PIP_MAC_DA_CLASSIFICATION_STC   entry;
    CPSS_DXCH_TRUNK_LBH_CRC_MODE_ENT     crcMode;
    GT_U32                               crcSeed;
    GT_U32                               crcSeedHash1;


    if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        /* Get the internal Policer MRU value - get from IPLR0 - should be the same in all */
        rc = prvCpssHwPpReadRegister(devNum,
                PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,0/*IPLR0*/).policerMRU,
                &PRV_CPSS_DXCH_PP_MAC(devNum)->policer.internalMru);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    rc = cpssSystemRecoveryStateGet(&oldSystemRecoveryInfo);
    if (rc != GT_OK)
    {
        return rc;
    }
    if ((oldSystemRecoveryInfo.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
        (oldSystemRecoveryInfo.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E) )
    {
        if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)||
            (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E) ||
            (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E) ||
            (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E) ||
            (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_HARRIER_E))
        {
            PRV_CPSS_DXCH_PP_CONFIG_STC *pDev;

            rc = prvCpssDxChSMIDrvInit(devNum);
            if(rc != GT_OK)
            {
                return rc;
            }

            pDev = PRV_CPSS_DXCH_PP_MAC(devNum);
            for (i = 0; pDev->hwInfo.smi_support.activeSMIList[i] != (GT_U32)CPSS_PHY_SMI_INTERFACE_INVALID_E; i++)
            {
                rc = prvCpssDxChSMIInvertMDCSet(devNum,0,pDev->hwInfo.smi_support.activeSMIList[i],GT_FALSE);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
            if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT3_PORT_LED_POSITION_JUST_ON_USED_MAC_WA_E))
            {
                rc = prvCpssDxChLedErrataPortLedInit(devNum);
                if (GT_OK != rc)
                {
                    return rc;
                }
            }
            return GT_OK;
        }
    }

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                              DFXServerUnitsDeviceSpecificRegs.deviceResetCtrl;

        /* reset device skip init controls. It can be activated after Soft Reset
           and block DFX Memories registers access. This configuration enables
           access blocked by Soft Reset. */
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 23, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* enable back the device skip init controls */
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 23, 1, 0);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* the WA resets memories of egress units. It should be executed
       before other WAs to avoid data rewrite */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_CAELUM_EGRESS_MEMORIES_NOT_RESET_WA_E))
    {
        /* Fix default value of BIST register */
        rc = prvCpssDxChDiagBistCaelumFixBist(devNum);
        if(rc != GT_OK)
            return rc;

        /* Fix default value of EPLR memories */
        rc = hwPpDxChBobkEplrMemoriesDefaultSet(devNum);
        if(rc != GT_OK)
            return rc;
    }

    rc = hwPpDxChLionRegsDefault(devNum);
    if(rc != GT_OK)
        return rc;

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION2_RM_TTI_DUAL_DEV_ENABLE_WA_E))
    {
        if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
        {
            /* <Dual Device Id> */
            rc = prvCpssHwPpSetRegField(devNum,0x01000204,5, 1, 1);
            if(GT_OK != rc)
            {
                return rc;
            }
        }
    }

        /* RM 9987707   - CPfcEn should be enabled by default */
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_LION2_RM_ENABLE_PFC_TRIGGER_WA_E))
        {
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_PFC_MAC(devNum).PFCTriggerGlobalConfig;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.pfcRegs.pfcGlobalConfigReg;
        }
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }
    }


    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        /* <FdbMultiCoreEn> :
        Enables using Mask UnKnown DA Enable Port Group4/5/6/7.
        When this feature is enabled, the Mask UnKnown DA Enable Port Group
        is chosen by this selector: {OwnDev[0], PipeId[1:0]}
        */
        rc = prvCpssDrvHwPpSetRegField(devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.bridgeGlobalConfigRegArray[2],
            28, 1, 1);
        if(GT_OK != rc)
        {
            return rc;
        }

        /* RM-9082194 - Drop and xoff thresholds should be initialized to the maximal value*/
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_CPFC_THRESHOLDS_WA_E))
        {
            for(i = 0; i < CPSS_TC_RANGE_CNS; i++)
            {
                rc = cpssDxChPortPfcGlobalQueueConfigSet(devNum,(GT_U8)i,0x7FF,0x7FF,0x7FF/*don't care*/);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }

            /* RM-9082194 - Set default Xoff thresholds for profiles*/
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.pfcRegs.pfcProfileXoffThresholds;

            /* Per profile*/
            for (i=0;i<PROFILE_NUM_CNS;i++)
            {
                /* Per TC*/
                for (ii=0;ii<CPSS_TC_RANGE_CNS;ii++)
                {
                    rc = prvCpssHwPpSetRegField(devNum, regAddr+(i*0x20) + (ii*0x4), 0, 11, 0x7FF);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }

        for( i = 0; i < PRV_CPSS_PP_MAC(devNum)->numOfPorts; i++)
        {
             PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,i);
             portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, i);

             if(PRV_CPSS_DXCH_LION2_B0_AND_ABOVE_CHECK_MAC(devNum))
             {
                 /* 523 (DIP) / 1332 (LionB0) - PFC status updates are ignored
                    when the port FC TX is disabled */
                 PRV_CPSS_DXCH_PORT_MAC_CTRL4_REG_MAC(devNum, i,
                                                      PRV_CPSS_PORT_XLG_E,
                                                      &regAddr);
                 rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,9,1,1);
                 if (rc != GT_OK)
                 {
                     return rc;
                 }

                 /* FE-31330 - Periodic PFC messages may be lost */
                 U32_SET_FIELD_MAC(regValue, 8, 2, 0x3);
             }
             else
             {
                 /* RM-2466587 - Enable Global Xoff activation on port */
                 if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                     PRV_CPSS_DXCH_LION2_RM_GLOBAL_XOFF_ACTIVATION_ON_PORT_WA_E))
                 {
                     U32_SET_FIELD_MAC(regValue, 0, 8, 0xFF);
                 }
             }
             regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                 perPortRegs[i].macRegsPerType[PRV_CPSS_PORT_GE_E].ppfcControl;
             if(regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
             {
                 rc = prvCpssHwPpPortGroupSetRegField(devNum, portGroupId,
                                                      regAddr, 0, 10, regValue);
                 if (rc != GT_OK)
                 {
                    return rc;
                 }
             }
             regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                 perPortRegs[i].macRegsPerType[PRV_CPSS_PORT_XLG_E].ppfcControl;
             if(regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
             {
                 rc = prvCpssHwPpPortGroupSetRegField(devNum, portGroupId,
                                                      regAddr, 0, 10, regValue);
                 if (rc != GT_OK)
                 {
                    return rc;
                 }
             }
        }

        /*         RM-8439088   - PfcEn (LLFC in Lion 2) should be enabled by default */
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_LION2_RM_LLFC_TRIGGER_GLOBAL_CONFIGURATION_WA_E))
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.llfcRegs.pfcGlobalConfigReg;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_PFC_THRESHOLDS_WA_E))
        {
            /* RM-8035267 - Set default Xoff thresholds for profiles*/
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.llfcRegs.pfcProfileXoffThresholds;

            /* Per profile*/
            for (i=0;i<PROFILE_NUM_CNS;i++)
            {
                /* Per TC*/
                for (ii=0;ii<CPSS_TC_RANGE_CNS;ii++)
                {
                    rc = prvCpssHwPpSetRegField(devNum, regAddr+(ii*0x4)+(i*0x20), 0, 11, 0x7FF);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }

            /* RM-8035267 - Drop and xoff thresholds should be initialized to the maximal value*/
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.llfcRegs.pfcGlobalGroupOfPortsThresholds;

            /* set the value for all port groups*/
            for (i=0; i < PRV_CPSS_LION2_PORT_GROUPS_NUM_CNS; i++)
            {
                /* For each traffic class*/
                for(ii = 0; ii < CPSS_TC_RANGE_CNS; ii++)
                {
                    /* Write 0x7FF to both drop and xoff thresholds, 11 bits each*/
                    rc = prvCpssHwPpSetRegField(devNum, regAddr + (ii*0x4)+ (i*0x20), 0, 22, 0x3FFFFF);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }

        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_LION2_HGL_MAC_INT_WA_E))
        {/* mask the HGL MAC interrupts */
            for( i = 0; i < PRV_CPSS_PP_MAC(devNum)->numOfPorts; i++)
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,i);
                localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,i);

                /* mask - i.e. event disable.                 */
                /* prvCpssDrvEventsMask may return not GT_OK  */
                /* if interrupt was not binded by application */
                /* or interrupts are not used.                */
                /* Need to ignore this fail.                  */
                (GT_VOID)prvCpssDrvEventsMask(devNum,
                                            lion2PortUnitHglSumIndex(localPort),
                                            GT_TRUE);
                if((9 == localPort) || (11 == localPort))
                {
                    localPort += 3;
                    (GT_VOID)prvCpssDrvEventsMask(devNum,
                        lion2PortUnitHglSumIndex(localPort),
                        GT_TRUE);
                }
            }
        }
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* no relay port */
    }
    else
    {
        /* Set relayed IF (internal port 12) to be served by MC FIFO 3 */
        rc = prvCpssHwPpWriteRegister(devNum,0x12001028,0x1000 );
        if (rc != GT_OK)
        {
            return rc;
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
                            mcFifoConfig.distributionMask[0][0];

        /* relayed IF (internal port 12) should not be served by MC FIFO 0/1 */
        rc = prvCpssHwPpWriteRegBitMask(devNum,regAddr,0x1000,0);
        if (rc != GT_OK)
        {
            return rc;
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
                            mcFifoConfig.distributionMask[1][0];
        rc = prvCpssHwPpWriteRegBitMask(devNum,regAddr,0x1000,0);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if( (PRV_CPSS_SIP_5_CHECK_MAC(devNum)) &&
        !(PRV_CPSS_SIP_6_CHECK_MAC(devNum)) &&
        (PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE) )
    {
        /* set <Tsen Reset> , otherwise can not get temperature from the sensors */
        regAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                      DFXServerUnits.DFXServerRegs.temperatureSensor28nmCtrlMSB;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                                                 devNum, regAddr, 8, 1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    if( (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) &&
        (PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE) )
    {
        /* Set OTF bit in all 5 temp sensors */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            dfxUnits.server.temperatureSensorControlMsb;

        for(i = 0; i < 5; i++)
        {
            regValue = 0x0000010 + (i * 0x02000000);
            rc = prvCpssHwPpWriteRegBitMask(devNum, regAddr, 0xE000010, regValue);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }
    /* For Lion2 - 4 ports groups - init the localTrgPortMapOwnDevEn and localSrcPortMapOwnDevEn
       in order to enable odd device id */
    if ( (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) &&
         (PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_2_MAC(devNum) == 0 ) )
    {
        /* make sure that all the local traffic in the device uses the distributed TXQ mapper to
           direct all traffic to hemisphare 0.
           so set all 128 ports of src and trg to use the 'device map table' of the distributed TXQ.
           this without change the device map table in the hemisphere.
           */
        for(ii = 0 ; ii < 4; ii++)
        {
            /* configure localSrcPortMapOwnDevEn */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)-> txqVer1.dist.deviceMapTable.
                                localSrcPortMapOwnDevEn[ii];
            rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0xFFFFFFFF);
            if (rc != GT_OK)
            {
                return rc;
            }

            /* configure localTrgPortMapOwnDevEn */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)-> txqVer1.dist.deviceMapTable.
                                localTrgPortMapOwnDevEn[ii];
            rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0xFFFFFFFF);
            if (rc != GT_OK)
            {
                return rc;
            }

        } /* ii */
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_BRIDGE_COMMANDS_DEFAULTS_WA_E))
    {
        if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
        {
            /* JIRA : L2I-546 : wrong default values : "Non-IP Multicast Command" and
                "IP Multicast Command" should be forward not soft drop */
            /* the default in B0 is 'soft drop' */
            rc = cpssDxChBrgGenDropIpMcEnable(devNum,GT_FALSE);
            if (rc != GT_OK)
            {
                return rc;
            }

            /* the default in B0 is 'soft drop' */
            rc = cpssDxChBrgGenDropNonIpMcEnable(devNum,GT_FALSE);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        else /* JIRA : L2I-503 : Wrong registers defaults*/
        {
            /* set bridge command config registers 0 - default values
               to be backward compatible with lion2
               since all default values (in bobcat2) are set to 0 */

            /*************/
            /* set bits 0..2 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0 */
            /*************/
            /* soft drop of 'Invalid SA' */
            /* right now cpssDxChBrgGenDropInvalidSaEnable supports only 2 commands.
               It should be extended to 5 commands - need to set to soft drop */
            CPSS_TBD_BOOKMARK_EARCH
            rc = cpssDxChBrgGenDropInvalidSaEnable(devNum,GT_TRUE);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* set the drop of 'Invalid SA' to be 'soft' */
            rc = cpssDxChBrgSecurBreachEventDropModeSet(devNum,
                CPSS_BRG_SECUR_BREACH_EVENTS_INVALID_MAC_SA_E,
                CPSS_DROP_MODE_SOFT_E);
            if(rc != GT_OK)
            {
                return rc;
            }

            /*************/
            /* set bits 3..5 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0 */
            /*************/
            /* set the drop of 'Invalid Vlan' to be 'soft' */
            rc = cpssDxChBrgSecurBreachEventDropModeSet(devNum,
                CPSS_BRG_SECUR_BREACH_EVENTS_INVALID_VLAN_E,
                CPSS_DROP_MODE_SOFT_E);
            if(rc != GT_OK)
            {
                return rc;
            }

            /*************/
            /* set bits 6..8 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0 */
            /*************/
            /* set the drop of 'Port Not in VLAN Ingress' to be 'soft' */
            rc = cpssDxChBrgSecurBreachEventDropModeSet(devNum,
                CPSS_BRG_SECUR_BREACH_EVENTS_PORT_NOT_IN_VLAN_E,
                CPSS_DROP_MODE_SOFT_E);
            if(rc != GT_OK)
            {
                return rc;
            }

            /*************/
            /* set bits 9..11 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0 */
            /*************/
            /* set the drop of 'VLAN Range' to be 'soft' */
            rc = cpssDxChBrgSecurBreachEventDropModeSet(devNum,
                CPSS_BRG_SECUR_BREACH_EVENTS_VLAN_RANGE_DROP_E,
                CPSS_DROP_MODE_SOFT_E);
            if(rc != GT_OK)
            {
                return rc;
            }


            /*************/
            /* set bits 15..17 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0 */
            /*************/
            /* set the command of 'SA static moved' to be 'forward' because this command
               applied also on non security breach event !
                rc = cpssDxChBrgSecurBreachEventPacketCommandSet(devNum,
                    CPSS_BRG_SECUR_BREACH_EVENTS_MOVED_STATIC_E,
                    CPSS_PACKET_CMD_FORWARD_E);
                if(rc != GT_OK)
                {
                    return rc;
                }
            */

            /****************************
               bits 21..23 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0
               not needed to set like Lion2 default because Lion2 had 'RM' on this one !
               see PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E
               So DON'T set the 'Arp mac sa mismatch' to be 'hard drop'
            ****************************/

            /* set bits 12..14 <VLAN MRU Command> to be 'hard drop' */
            regAddr = PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 12, 3 , 3/*hard drop*/);
            if(rc != GT_OK)
            {
                return rc;
            }
            /* set bits 24..26 <Secure Auto Learning Unknown Source Command> to be 'trap' */
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 24, 3 , 2/*trap*/);
            if(rc != GT_OK)
            {
                return rc;
            }
            /* set bits 27..29 <Accept Frame Type Command> to be 'soft drop' */
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 27, 3 , 4/*soft drop*/);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        /* needed for ALL sip5 devices */
        /* legacy devices got implicit 'trap' command for 'ARP BC '*/
        /* in sip5 devices the command is from next register */

        /* set bits 24..26 <ePort ARP Broadcast Command> to be 'Trap To CPU' */
        regAddr = PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig1;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 24, 3 , 2/*TrapToCPU*/);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* Egress Queue CNC Client mode BWC with Bobcat3 and Aldrin2 */
        rc = cpssDxChCncEgressQueueClientModeSet(
            devNum, CPSS_DXCH_CNC_EGRESS_QUEUE_CLIENT_MODE_TAIL_DROP_REDUCED_E);
        if( GT_OK != rc )
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_NON_ORIG_VID_ON_TRAP_TO_CPU_WA_E))
    {
        /* allow to the CPU to get the original vlan tag as payload after
           the DSA tag , so the info is not changed. */
        rc = cpssDxChBrgVlanForceNewDsaToCpuEnableSet(devNum,GT_TRUE);
        if( GT_OK != rc )
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_TXDMA_FIFO_THRESHOLD_WA_E))
    {

        /* Reduce the threshold of the TxDMA read request FIFO for the
           header and payload */

        /* Set the Header Reorder FIFO Thresholds register to 0x9d */
        rc = prvCpssHwPpSetRegField(devNum,
             PRV_DXCH_REG1_UNIT_TXDMA_MAC(devNum).txDMAThresholdsConfigs.headerReorderFifoThreshold,
             0, 10, 0x9D);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* Set the Payload Reorder FIFO Thresholds register to 0x9d */
        rc = prvCpssHwPpSetRegField(devNum,
             PRV_DXCH_REG1_UNIT_TXDMA_MAC(devNum).txDMAThresholdsConfigs.payloadReorderFifoThreshold,
             0 ,10, 0x9D);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_RATE_LIMIT_DEFICIT_COUNT_EN_WA_E))
    {
        if(!PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
        {
            /* RateLimitDefecitCountEn default value should be set */
            rc = prvCpssHwPpSetRegField(devNum,
                 PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).ingrPortsRateLimitConfig.ingrRateLimitConfig1,
                 16 ,1, 1);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /* RateLimitDefecitCountEn default value should be set */
            rc = prvCpssHwPpSetRegField(devNum,
                 PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).ingrPortsRateLimitConfig.ingrRateLimitConfig1,
                 28 ,1, 1);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_STRICT_PRIORITY_FOR_UC_PACKETS_WA_E))
    {
        /* default value of <UC Strict Mode Enable> is wrong */
        rc = prvCpssHwPpSetRegField(devNum,
             PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).duplicationConfigs.duplicationConfigs0,
             8 ,1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* Enable strict priority for unicast packets */
        rc = cpssDxChIpMultiTargetUcSchedModeGet(devNum, &ucSPEnable,
                                                 &ucWeight, &mcWeight,
                                                 &schedMtu);
        if (rc != GT_OK)
        {
            return rc;
        }

        ucSPEnable = GT_TRUE;    /* strict priority */
        rc = cpssDxChIpMultiTargetUcSchedModeSet(devNum, ucSPEnable,
                                                 ucWeight, mcWeight,
                                                 schedMtu);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_TTI_BAD_DEFAULT_VALUE_FIX_WA_E))
    {
        rc = prvCpssHwPpSetRegField(devNum,
             PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).TTIMetalFix,
             0 ,1, 0);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum, PRV_CPSS_DXCH_BOBCAT2_RM_CONTROL_FROM_CPU_EGRESS_FILTER_WA_E))
    {
        /* <Control_from_CPU_Egress_Filter_En> -
           set value to Enable VLAN filtering for control traffic from CPU */
        rc = prvCpssHwPpSetRegField(devNum,
            PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.SHTGlobalConfigs,
            14,1,1);
        if( GT_OK != rc )
        {
            return rc;
        }
    }

    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT2_RM_TXQ_PORT_REQUEST_MASK_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.portShaper.portRequestMask;
        regValue =   0x00000004
              | 0x00000400
              | 0x00040000
              | 0x04000000;

        rc = prvCpssHwPpWriteRegister(devNum, regAddr, regValue);
        if( GT_OK != rc )
        {
            return rc;
        }
    }

    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT2_ILKN_PACKET_SIZE_LIMITATION_NOT_ENFORCED_WA_E))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->GOP.ILKN_WRP.rxdmaConverterPacketSizeRestriction;
        regValue = 0x3FFF;

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 14, 14, regValue);
        if( GT_OK != rc )
        {
            return rc;
        }
    }


    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_AVS_INIT_WA_E))
    {
        if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
        {
            regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                                    DFXServerUnits.DFXServerRegs.AVSDisabledCtrl1[0];
            /* AVS <%a> Select Vsense0  - avs_vdd_sense0 is selected */
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr,
                                                                        23, 1, 1);
            if( GT_OK != rc )
            {
                return rc;
            }

            regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                                    DFXServerUnits.DFXServerRegs.AVSEnabledCtrl[0];
            /* AVS <%a> Low VDD Limit and AVS <%a> High VDD Limit */
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr,
                                                                4, 16,
                                                                ((0x26<<8)|0x26));
            if( GT_OK != rc )
            {
                return rc;
            }
        }
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* check relevancy for device by using PRV_CPSS_DXCH_ERRATA_GET_MAC
           instead of using PRV_CPSS_SIP_5_CHECK_MAC */
        CPSS_TBD_BOOKMARK_EARCH

        /* set <IP MLL MC Source ID Mask> for BWC with previous device */
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLGlobalCtrl.MLLMCSourceID;
        rc = prvCpssHwPpSetRegField(devNum,regAddr,0, 12, 0xFFF);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum, PRV_CPSS_DXCH_LION2_GIGE_MAC_LINK_STATUS_WA_E))
    {
        for( i = 0; i < PRV_CPSS_PP_MAC(devNum)->numOfPorts; i++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, i);

            rc = prvCpssDxChPortLion2GeLinkStatusWaEnableSet(devNum,i,GT_TRUE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /* in order to fix false interrupt, read BMA MC cause register */
    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum, PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_BMA_MC_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E))
    {
        memType = CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_BMA_MC_CLEAR_SHIFTER_E;

        rc = prvCpssLion2FalseInterruptRegReset(devNum, memType);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    /* in order to fix false interrupt, read MLL FIFO cause register */
    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum, PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_MLL_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E))
    {
        memType = CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_MLL_PCL2MLL_UNUSED_FIFO_E;

        rc = prvCpssLion2FalseInterruptRegReset(devNum, memType);
        if(GT_OK != rc)
        {
            return rc;
        }
    }


    /* DFX ECC Interrupts Summary Mask Register init */
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalInterrupt.dfxInterruptMask;

        rc = prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFFFFFFFF, 0xFFFFFFFC);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) && (ppPhase1ParamsPtr->tcamParityCalcEnable))
    {
        /* PCL TCAM Parity Daemon duty cycle config */

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclTccRegs.policyTcamControl;
        /* set maximal period */
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 24, 4, 0xF);
        if(rc != GT_OK)
        {
            return rc;
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTccRegs.ipTcamControl;
        /* set maximal period */
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 24, 4, 0xF);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Default PCL X/Y Parity Calculation */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
        {
            for(ruleIndex = 0; ruleIndex < (PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.policyTcamRaws * 4); ruleIndex++)
            {
                for(i = 0; i < 8; i++)
                {
                    /* X */
                    rc = prvCpssDxChPclTcamReadStdRuleAddrGet(
                        devNum, 0 /*tcamIndex*/, ruleIndex, i, GT_TRUE, &regAddr);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                    rc = prvCpssDrvHwPpPortGroupReadRegister(
                        devNum, portGroupId, regAddr, &(xData[i]));
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                    /* Y */
                    rc = prvCpssDxChPclTcamReadStdRuleAddrGet(
                        devNum, 0 /*tcamIndex*/, ruleIndex, i, GT_FALSE, &regAddr);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                    rc = prvCpssDrvHwPpPortGroupReadRegister(
                        devNum, portGroupId, regAddr, &(yData[i]));
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }

                prvCpssDxChLion2PclTcamParityCalc(xData, yData, &xParity, &yParity);

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.tcamReadPatternParityBase;

                /* Write Parity_X table */
                rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, (regAddr + (ruleIndex * 4)), xParity);
                if (rc != GT_OK)
                {
                    return rc;
                }

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.tcamReadMaskParityBase;

                /* Write Parity_Y table */
                rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, (regAddr + (ruleIndex * 4)), yParity);
                if (rc != GT_OK)
                {
                    return rc;
                }

            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)


        /* Default Router X/Y Parity Calculation */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
        {
            for(index = 0; index < PRV_CPSS_DXCH_ROUTER_TUNNEL_TERM_GET_MAX_SIZE_MAC(devNum); index++)
            {
                for(i = 0; i < 4; i++)
                {
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerTtTcamBankAddr[0] + (index*4 + i) * 0x10;

                    rc = prvCpssDrvHwPpPortGroupReadRam(devNum, portGroupId, regAddr, 2, &(xData[i*2]));
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                    rc = prvCpssDrvHwPpPortGroupReadRam(devNum, portGroupId, (regAddr + 8), 2, &(yData[i*2]));
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                }

                prvCpssDxChLion2RouterTcamParityCalc(xData, &xParity);

                prvCpssDxChLion2RouterTcamParityCalc(yData, &yParity);

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTccRegs.ipTcamReadPatternParityBase;

                /* Write Parity_X table */
                rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, (regAddr + (index * 4)), xParity);
                if (rc != GT_OK)
                {
                    return rc;
                }

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTccRegs.ipTcamReadMaskParityBase;

                /* Write Parity_Y table */
                rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, (regAddr + (index * 4)), yParity);
                if (rc != GT_OK)
                {
                    return rc;
                }

            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

    }

    if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                     PRV_CPSS_DXCH_LION2_RM_WRONG_GIG_DESC_FIFO_THRESHOLD_WA_E))
    {
        if(PRV_CPSS_DXCH_LION2_B0_AND_ABOVE_CHECK_MAC(devNum))
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.
                txdmaBufMemFifosThreshold[CPSS_DXCH_PORT_BUF_MEM_FIFO_TYPE_GIGA_E];
            /* GigDescFifoThreshold bits 0:5 */
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 6, 0x4);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        PRV_CPSS_DXCH_PP_CONFIG_STC *pDev;

        rc = prvCpssDxChSMIDrvInit(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }

        pDev = PRV_CPSS_DXCH_PP_MAC(devNum);

        if (oldSystemRecoveryInfo.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
        {
            for (i = 0; pDev->hwInfo.smi_support.activeSMIList[i] != (GT_U32)CPSS_PHY_SMI_INTERFACE_INVALID_E; i++)
            {
                rc = prvCpssDxChSMIInvertMDCSet(devNum,0,pDev->hwInfo.smi_support.activeSMIList[i],GT_FALSE);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }


        /* TAIs UNRESET*/
        if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.gop_tai.supportSingleInstance)
        {
            regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, 0, 0).TAICtrlReg0;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
            {
                totalTaiGop = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.gop_tai.numOfTaiUnits;
            }
            else
            if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                totalTaiGop = PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles *
                                FALCON_PER_TILE_TAI_SUB_UNITS_NUMBER_CNS;
            }
            else
            {
                totalTaiGop = (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? 1 : 10;
            }

            /* loop on GOPs */
            for ( i = 0 ; i < totalTaiGop; i++ )
            {
                /* Master TAI pair is present on eagle tile #0 only, not 1,2,3. */
                /* Skip the master TAIs UNRESET (except TILE0 master TAI)*/
                if(PRV_CPSS_SIP_6_CHECK_MAC(devNum) && (!PRV_CPSS_SIP_6_10_CHECK_MAC(devNum)) && (i != PRV_CPSS_DXCH_PTP_TAI_INSTANCE_SUB_TYPE_MASTER_E) &&
                  ((i % FALCON_PER_TILE_TAI_SUB_UNITS_NUMBER_CNS) == PRV_CPSS_DXCH_PTP_TAI_INSTANCE_SUB_TYPE_MASTER_E))
                {
                    continue;
                }

                /* loop on TAIs */
                for ( ii = 0 ; ii < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.maxNumOfTais ; ii++ )
                {
                    regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, i, ii).TAICtrlReg0;

                    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum) && !PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
                    {
                        PRV_CPSS_SKIP_NOT_EXIST_RAVEN_ADDRESS_MAC(devNum, regAddr);
                    }

                    rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }

            if ((GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CONFIG_FOR_TAI_CTRL_1_E)))
            {
                /* loop on GOPs */
                for ( i = 0 ; i < totalTaiGop; i++ )
                {
                    /* Master TAI pair is present on eagle tile #0 only, not 1,2,3. */
                    /* Skip the master TAIs UNRESET (except TILE0 master TAI)*/
                    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum) && (!PRV_CPSS_SIP_6_10_CHECK_MAC(devNum)) && (i != PRV_CPSS_DXCH_PTP_TAI_INSTANCE_SUB_TYPE_MASTER_E) &&
                      ((i % FALCON_PER_TILE_TAI_SUB_UNITS_NUMBER_CNS) == PRV_CPSS_DXCH_PTP_TAI_INSTANCE_SUB_TYPE_MASTER_E))
                    {
                        continue;
                    }

                    /* loop on TAIs */
                    for ( ii = 0 ; ii < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.maxNumOfTais ; ii++ )
                    {
                        regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, i, ii).TAICtrlReg1;

                        PRV_CPSS_SKIP_NOT_EXIST_RAVEN_ADDRESS_MAC(devNum, regAddr);

                        rc = prvCpssHwPpSetRegField(devNum, regAddr, 16, 10, 0x1);
                        if (rc != GT_OK)
                        {
                            return rc;
                        }
                    }
                }
            }

            if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E)
            {
                /* RM-1231981: EPI_100G + PHA TOD slaves should have configured delay of 6cc in order to synch master TAI with it's slaves. */

                /* Epi 100g Tai Enc Out0 Dly Sel: bits [0..3] set value 6
                   Epi 100g Tai Enc Out1 Dly Sel: bits [4..7] set value 6 */
                regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl33;
                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum,regAddr, 0, 8, 0x66);
                if (rc != GT_OK)
                {
                    return rc;
                }

                /* Pha Tai Enc Out0 Dly Sel: bits [8..11] set value 6
                   Pha Tai Enc Out1 Dly Sel: bits [12..15] set value 6 */
                regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl34;
                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum,regAddr, 8, 8, 0x66);
                if (rc != GT_OK)
                {
                    return rc;
                }

                /* Set LED DFX related registers */

                /* Controls led sampling for each led_inst, only last led in chain need to be sampled[0..4] set value 0x10  */
                regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl38;
                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 0, 5, 0x10);
                if(rc != GT_OK)
                {
                    return rc;
                }

                /* Set LED related MPP registers */

                /* MPP 43 - LED_CLK, MPP 44 - LED_STB, MPP 45 - LED_DATA */
                regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->CNM.MPP_RFU.MPPControl40_47;
                rc = prvCpssHwPpSetRegField(devNum, regAddr,  12, 12, 0x111);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }

            if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_AC5P_RM_DRIFT_MIN_THRESHOLD_WA_E))
            {
                /* loop on GOPs */
                for ( i = 0 ; i < totalTaiGop; i++ )
                {
                    /* loop on TAIs */
                    for (taiNumber = 0; taiNumber < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.maxNumOfTais ;taiNumber++)
                    {
                        /* TAI "Drift Min Threshold" default value should be 0x1 (instead of 5) */
                        regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, i, taiNumber).driftThresholdConfigHigh;
                        /* Determines the minimal drift in nanoseconds that triggers the drift asjustment */
                        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 8, 0x1);
                        if (rc != GT_OK)
                        {
                            return rc;
                        }
                    }
                }
            }

            if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_AC5P_RM_PTP_FREQ_UPDATE_FOR_PCLK_IS_DONE_INACCURATELY_WA_E))
            {
                /* loop on GOPs */
                for ( i = 0 ; i < totalTaiGop; i++ )
                {
                     /* loop on TAIs */
                    for (taiNumber = 0; taiNumber < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.maxNumOfTais ;taiNumber++)
                    {
                        /* TAI "PClk Drift Adjustment Enable" default value should be 0x1 */
                        regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, i, taiNumber).clockControl;
                        rc = prvCpssHwPpSetRegField(devNum, regAddr, 10, 1, 0x1);
                        if (rc != GT_OK)
                        {
                            return rc;
                        }
                    }
                }
            }

            if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_HARRIER_RM_PTP_PLL_SET_GLOBAL_REF_CLOCK_WA_E))
            {
                if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_HARRIER_E)
                {
                    /* Select PTP_PLL ref_clk source; global ref clock */
                    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl5;
                    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum,regAddr,29, 3, 0);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }

            if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_AC5P_RM_MASTER_TAI_DEFAULT_MANCHESTER_HALF_BIT_SYMBOL_LENGTH_E))
            {
                /* Need to configure tod step & PTP PLL before the errata; to resolve Master Tx to malfunction and need reset. */
                if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E) || (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_HARRIER_E))
                {
                    ptpClkInKhz = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.ptpClkInKhz;

                    /* Configure TAIs nanosec step values */
                    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
                    taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                    todStep.nanoSeconds = 1000000/ptpClkInKhz;
                    todStep.fracNanoSeconds = (GT_U32)(0xFFFFFFFF *
                                  (1000000.0/ptpClkInKhz - todStep.nanoSeconds) +
                                  (1000000.0/ptpClkInKhz - todStep.nanoSeconds));

                    rc = cpssDxChPtpTaiTodStepSet(devNum, &taiId, &todStep);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }

                    /* Configures input TAI clock's selection to PTP PLL */
                    for (taiNumber = 0; taiNumber < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.maxNumOfTais ;taiNumber++)
                    {
                        rc = cpssDxChPtpTaiInputClockSelectSet(devNum,taiNumber,CPSS_DXCH_PTP_TAI_CLOCK_SELECT_PTP_PLL_E,CPSS_DXCH_PTP_25_FREQ_E);
                        if(rc != GT_OK)
                        {
                            return rc;
                        }
                    }
                }

                for (taiNumber = 0; taiNumber < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.maxNumOfTais ;taiNumber++)
                {
                    /* Apply SW reset to the Master TAI Tx */
                    regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, 0, taiNumber).TAICtrlReg0;
                    /* Soft reset for SER-TX logic: 0x1 = Reset Enter */
                    rc = prvCpssHwPpSetRegField(devNum, regAddr, 3, 1, 0x1);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                    /* Set Master TAI Manchester half-bit time */
                    regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, 0, taiNumber).manchesterControl;
                    rc = prvCpssHwPpSetRegField(devNum, regAddr , 0, 15, 0x7);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                    /* Release the SW reset of the Master TAI Tx */
                    regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, 0, taiNumber).TAICtrlReg0;
                    /* Soft reset for SER-TX logic: 0x0 = Reset Exit; normal mode */
                    rc = prvCpssHwPpSetRegField(devNum, regAddr, 3, 1, 0x0);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }

            frameLatencyArrPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.frameLatencyArr;
            frameLatencyFracArrPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.frameLatencyFracArr;

            if(frameLatencyArrPtr)
            {
                if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
                {
                    for (tileIndex = 0; tileIndex < PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles; tileIndex++)
                    {
                        for (ravenIndex = 0; ravenIndex < FALCON_RAVENS_PER_TILE; ravenIndex++)
                        {
                            PRV_CPSS_SKIP_NOT_EXIST_RAVEN_MAC(devNum, tileIndex, ravenIndex);

                            for (taiNumber = 0; taiNumber < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.maxNumOfTais ;taiNumber++ )
                            {
                                regAddr  = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(
                                 devNum, (5 + ravenIndex) + 9 * tileIndex, taiNumber/*0 or 1*/).frameLatency;
                                rc = prvCpssHwPpSetRegField(devNum, regAddr , 0, 16, frameLatencyArrPtr[tileIndex*4 + ravenIndex]);
                            }
                        }
                    }
                }
                else
                {
                    for ( i = 1 ; i < totalTaiGop; i++ )
                    {
                        for (taiNumber = 0; taiNumber < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.maxNumOfTais ;taiNumber++ )
                        {
                            regAddr  = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(
                             devNum, i, taiNumber/*0 or 1*/).frameLatency;
                            rc = prvCpssHwPpSetRegField(devNum, regAddr , 0, 16, frameLatencyArrPtr[i-1]);
                            if (rc != GT_OK)
                            {
                                return rc;
                            }
                            rc = prvCpssHwPpSetRegField(devNum, regAddr , 24, 8, frameLatencyFracArrPtr[i-1]);
                            if (rc != GT_OK)
                            {
                                return rc;
                            }
                        }
                    }
                }
            }
            else
            if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) != GT_TRUE)
            {
                /* configure TOD interface rate for Global TAIs */
                i = 9;
                /* loop on TAIs */
                for ( ii = 0 ; ii < 2 ; ii++ )
                {
                    regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, i, ii).
                                                                        TAICtrlReg1;
                    rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 12, 0x6db);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }


        /* Enables shaper token bucket update (periodic addition of tokens).
           Must be enabled to support shaping or PFC response.*/
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 31, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(!PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            /* Disable global legacy exact shaping and scheduling */
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.schedulerConfig.schedulerConfig;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 22, 1, 0);
            if(rc != GT_OK)
            {
                return rc;
            }

            for(profile = CPSS_PORT_TX_SCHEDULER_PROFILE_1_E; profile <= PRV_CPSS_DXCH_PORT_TX_SCHEDULER_PROFILE_MAX_MAC(devNum); profile++)
            {
                /* bit  9 :Configure Shaper byte count mode to transmitted packet size */
                /* bit 10 :Configure Scheduler byte count mode to transmitted packet size */
                /* bit 11 :Configure Scheduler byte count mode to enable High speed */
                regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.profileByteCountModification[profile];
                rc = prvCpssHwPpWriteRegBitMask(CAST_SW_DEVNUM(devNum), regAddr, 0x0E00, 0x0E00);

                if(rc != GT_OK)
                {
                    return rc;
                }
            }

            if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE)
            {
                /* set comon mode voltage range of the clock input. bit 4 of
                   Reset and Init Controller/DFX Server Units - BC2 specific registers/Device Control 0
                   should be '0' */
                regAddr =
                    PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl0;
                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                                                         devNum, regAddr, 4, 1, 0);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }
        }

        if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                         PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E))
        {
            regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl14;
            /* PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E
                           set bits#[31..29]  = rf_debug_clock_sel to 4 */
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 29, 3, 0x4);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                         PRV_CPSS_DXCH_BOBCAT2_RM_DFX_REGISTERS_MISSCONFIGURATION_WA_E))
        {
            /* Configure the minimal values to the WTC/RTC memories */
            rc = prvCpssDxChDfxWtcRtcMemoryWrite(devNum);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

    } /* if (PRV_CPSS_SIP_5_CHECK_MAC(devNum)) */

    if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                     PRV_CPSS_DXCH_BOBCAT2_RM_PROT_SWITCH_STAGE_EN_DEFAULT_VALUE_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_EQ_MAC(devNum).ePort.ePortGlobalConfig;
        /* PRV_CPSS_DXCH_BOBCAT2_RM_PROT_SWITCH_STAGE_EN_DEFAULT_VALUE_WA_E
           set bit#3  = Protection_Switching_Stage_Enable
                      = to be always 1 - cannot be configured under traffic - internal bit */
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 2, 1, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                               PRV_CPSS_DXCH_BOBCAT2_DESCRIPTOR_ECC_PROTECTION_CORRUPTION_WITH_REMOTE_PORTS_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXDMA_MAC(devNum).txDMADescCriticalFieldsECCConfigs.dataECCConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 2, 0x3);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).global.ECCConf;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 0x1);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.globalDequeueConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 11, 2, 0x3);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.globalTailDropConfig;
        if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 12, 2, 0x3);
        }
        else
        {
           rc = prvCpssHwPpSetRegField(devNum, regAddr, 11, 2, 0x3);
        }
        if(GT_OK != rc)
        {
           return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_QCN_MAC(devNum).txqECCConf;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 0x1);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).duplicationConfigs.duplicationConfigs0;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 11, 1, 0x1);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_EQ_MAC(devNum).criticalECCCntrs.criticalECCConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 5, 0x1F);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* Enable SERDES delay write for BC2 B0 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.genxsRateConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 23, 1, 1);
        if(GT_OK != rc)
        {
            return rc;
        }

        if(!PRV_CPSS_SIP_6_CHECK_MAC(devNum))/* sip6 not hold such bit */
        {
            /* Enable the Flow Control indication pause toward the port to allow
                FCA functionality. In A0 this bit by default was 1. */
            /* loop on all valid RxDMAs : singleChannelDMAConfigs.SCDMAConfig0[x] */
            /* it also supports ALL 4 CPU-SDMA ports of BC3/Aldrin2 */
            for (i = 0; i < PRV_CPSS_MAX_DMA_NUM_CNS; i++)
            {
                regAddr = PRV_DXCH_REG1_UNIT_RXDMA_MAC(devNum).
                                        singleChannelDMAConfigs.SCDMAConfig0[i];

                if(regAddr == PRV_CPSS_SW_PTR_ENTRY_UNUSED)
                {
                    /* the port RxDMA not valid */
                    continue;
                }

                rc = prvCpssHwPpPortGroupSetRegField(devNum,
                                                        CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                        regAddr,
                                                        28, /* Flow Control En<<%n>> filed offset */
                                                        1,  /* field length */
                                                        1); /* Enable Flow Control */
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
    }

    if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                     PRV_CPSS_DXCH_BOBCAT2_EPLR_TO_CPU_OAM_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum, CPSS_DXCH_POLICER_STAGE_EGRESS_E).policerCtrl1;
        /* set bit#10 <En To Cpu Meter And Count> to be enable metering and
           counting for TO CPU packets in EPLR*/
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 10, 1, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                        PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E))
        {
            for (i = 0; i < 72; i++)
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,i);
                regAddr = PRV_DXCH_REG1_UNIT_GOP_FCA_MAC(devNum, i).DSATag32To47;
                rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x0101);
                if(rc != GT_OK)
                {
                    return rc;
                }

                regAddr = PRV_DXCH_REG1_UNIT_GOP_FCA_MAC(devNum, i).DSATag48To63;
                rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x8808);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
         }/* end of PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E */

        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                        PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_PORT_MAC_CONTROL_REG4_WA_E))
        {
            for (i = 0; i < 72; i++)
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, i);
                PRV_CPSS_DXCH_PORT_MAC_CTRL4_REG_MAC(devNum, i ,PRV_CPSS_PORT_GE_E, &regAddr);
                rc = prvCpssHwPpSetRegField(devNum, regAddr, 8, 1, 1);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }/* end of PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_PORT_MAC_CONTROL_REG4_WA_E*/

        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                        PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_CNM_HEADER_CONFIGURATION_WA_E))
        {
            regAddr = PRV_DXCH_REG1_UNIT_HA_MAC(devNum).CNMHeaderConfig;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 20, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                        PRV_CPSS_DXCH_BOBCAT2_RM_FDB_SCHEDULER_SWRR_CONTROL_WA_E))
        {
            regAddr = PRV_DXCH_REG1_UNIT_FDB_MAC(devNum).FDBCore.FDBScedulerConfiguration.FDBScedulerSWRRControl;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
    {
        /* disable local source device packets filtering         */
        /* BobK implements this feature to from CPU packets also */
        /* not as legacy devices                                 */
        rc = cpssDxChCscdDsaSrcDevFilterSet(devNum, GT_FALSE);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Allign rate limit configuration with 128 physical ports for BobK/Aldrin/Aldrin2 devices.
           Falcon use 128 port mode.
           Default value of register is for 256 ports devices.
           Use formulas:
           10G/CG - 25.6 us/(num_of_ports x 0.04us)
           Other  - 256 us/(num_of_ports x 0.04 us), where num_of_ports = 128 */
        if((PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort == 7) ||
           (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E))
        {
            rc = prvCpssHwPpWriteRegister(devNum,
                  PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).ingrPortsRateLimitConfig.ingrRateLimitConfig2,
                  0x5005032);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /* PIP feature initialization (serves also cut trough feature) */
    if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
    {
        /* default value for the <generic etherType <n>> '0' is wrong and should
           be '0x0800' , to avoid entering this case by 'accident' (as 0x0800 is
           previous case of ipv4) */
        for(ii = 0 ; ii < 4 ; ii++)
        {
            rc = cpssDxChPortPipGlobalEtherTypeProtocolSet(devNum,
                CPSS_DXCH_PORT_PIP_PROTOCOL_UDE_E,
                ii,
                0x0800);/* Ipv4 etherType */
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* index 1   - should be 0x88a8 (and not 0x8a88)
           index 2,3 - default value for the <VLAN EtherType Conf <n>> '0' is wrong and should
           be '0x8100' , to avoid entering this case by 'accident' (as 0x8100 is
           in index 0) */
        for(ii = 1 ; ii < 4 ; ii++)
        {
            rc = cpssDxChPortPipGlobalEtherTypeProtocolSet(devNum,
                CPSS_DXCH_PORT_PIP_PROTOCOL_VLAN_TAG_E,
                ii,
                (ii == 1)  ? 0x88A8 :
                /*index 2,3*/0x8100);/* index 2,3 --> 'vlan tag' - the same value as index 0 */
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        /* ipv6 etherType - should be 0x86dd (and not 0x8600) */
        rc = cpssDxChPortPipGlobalEtherTypeProtocolSet(devNum,
            CPSS_DXCH_PORT_PIP_PROTOCOL_IPV6_E,
            0,/*don't care*/
            0x86dd);/* Ipv6 etherType */
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Set PIP Mac Da default MASK
         * HW default value(0x0) which makes all DA as generic,
         * Updated mask to 0xFF to avoid such behavior
         */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        for(ii = 0; ii < 6; ii++)
        {
            entry.macAddrMask.arEther[ii] = 0xFF;
        }
        for(ii = 0 ; ii < 4 ; ii++)
        {
            rc = cpssDxChPortPipGlobalMacDaClassificationEntrySet(devNum, ii, &entry);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_PTP_UDP_CHECKSUM_TRAILER_BIT_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_ERMRK_MAC(devNum).timestampingUDPChecksumMode;
        /* Enable checksum trailer bit */
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 12, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_INGRESS_FORWARDING_RESTRICTIONS_DROP_CODE_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_EQ_MAC(devNum).
                  ingrForwardingRestrictions.ingrForwardingRestrictionsDropCode;

        /*<Ingress Forwarding Restrictions Drop Code> need to fix value from 0x63 */
        rc = prvCpssHwPpSetRegField(
            devNum, regAddr,
            0/*offset*/, 8/*length*/, 0x3f/*data*/);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_CAELUM_INGRESS_VLAN_RANGE_CONFIG_WA_E))
    {
        /* Set default VLAN range to 4.5K - 1 */
        rc = cpssDxChBrgVlanRangeSet(devNum, _4K + (_1K/2) - 1);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_ALDRIN_WRONG_DEFAULT_CLEARED_UC_DIST_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).global.clearedUCDist;
        rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x2);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_ALDRIN_WRONG_DEFAULT_BM_GLOBAL_GFG_3_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_BM_MAC(devNum).BMGlobalConfigs.BMGlobalConfig3;
        rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x100);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_ALDRIN_TCAM_CONTENTS_NOT_INITALIZED_WA_E))
    {
        GT_U32 numOfFloorsInTcam = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.tcam.maxFloors;

        /* set all TCAM floors to be active */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->TCAM.tcamArrayConf.tcamActiveFloors;
        rc = prvCpssHwPpSetRegField(
            devNum, regAddr,
            0/*offset*/, 8/*length*/, numOfFloorsInTcam/*data*/);
        if (rc != GT_OK)
        {
            return rc;
        }
        /* init the default values */
        rc = prvCpssDxChHwInitSip5TcamDefaultsInit(devNum);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum) && cpssDeviceRunCheck_onEmulator()
        && (! PRV_CPSS_SIP_6_10_CHECK_MAC(devNum)))
    {
        /* init the default values */
        rc = prvCpssDxChHwInitSip5TcamDefaultsInit(devNum);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT3_RM_TCAM_SEGMENT_MODE_OBSOLETE_WA_E))
    {
        /*********************************/
        /*all 3 bits fields with value 4 */
        /*********************************/
        regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).TTIEngine.TTIKeySegmentMode0;
        rc = prvCpssHwPpWriteRegister(
            devNum, regAddr,0x24924924);
        if (rc != GT_OK)
        {
            return rc;
        }
        regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).TTIEngine.TTIKeySegmentMode1;
        rc = prvCpssHwPpWriteRegister(
            devNum, regAddr,0x24924924);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT3_RM_PERFORMANCE_DEGRADATION_IN_EGF_QAG_WA_E))
    {
        /*<MC_FIFO_Idle_Cnt>*/
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->EGF_eft.MCFIFO.MCFIFOConfigs.MCFIFOGlobalConfigs;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 2, 8, 0);
        if(rc != GT_OK)
        {
            return rc;
        }

        /*<UCMC_SWRR_Idle_Cnt>*/
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->EGF_qag.uniMultiArb.uniMultiCtrl;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 18, 11, 0);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* set all 4 arbiters to 0xF */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->EGF_qag.uniMultiArb.uniWeights;
        rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0xFFFF);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* set all 4 arbiters to 0xF */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->EGF_qag.uniMultiArb.multiWeights;
        rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0xFFFF);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT3_RM_TXQ_IP_BMX_FILL_LEVEL_DEBUG_WA_E))
    {
        /*
            The default value of the field random_input_wr_if should be changed from 0x0 to 0x1.
            The default value of the field max_allowed_fef_diff should be changed from 0xc63 to 0xF.
            The default value of the field fill_level_rng_en_bits should be changed from 0x63 to 0x1.
        */

        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->TXQ.bmx.fillLevelDebugRegister;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 24, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 11, 13, 0xf);
        if(rc != GT_OK)
        {
            return rc;
        }
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 10, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT3_RM_CUT_THROUGH_NUMBERS_OF_BUFFERS_WA_E))
    {
        /*
            Change the default CT number of buffer configuration to 0x1.
            This must be configured in the following registers:
                TxQ_QUEUE: <EnqConstPacketLength> field in the Packet Length for Tail Drop - Enqueue register
                TxQ_DQ (Per Pipe/DQ*): "Packet Length for Tail Drop - Dequeue" Register
        */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->TXQ.queue.tailDrop.tailDropConfig.pktLengthForTailDropEnqueue;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 6, 1);
        if( GT_OK != rc )
        {
            return rc;
        }
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.schedulerConfig.pktLengthForTailDropDequeue;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 6, 1);
        if( GT_OK != rc )
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT3_RM_CUT_THROUGH_PACKET_CORRUPTION_WA_E))
    {
        /* Set minCT = 256B. This is set in the <Maximal Non Cut-Through Byte
        Count> field in the SCDMA <%n> CT Packet Identification Register.*/
        for (ii = 0; ii < PRV_CPSS_MAX_DMA_NUM_CNS; ii++)
        {
            if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                regAddr = PRV_DXCH_REG1_UNIT_SIP6_RXDMA_MAC(devNum).
                    configs.cutThrough.channelCTConfig[ii];

                if(regAddr == PRV_CPSS_SW_PTR_ENTRY_UNUSED)
                {
                    /* the port RxDMA not valid */
                    continue;
                }

                rc = prvCpssHwPpSetRegField(devNum, regAddr, 2, 14, 256);
                if( GT_OK != rc )
                {
                    return rc;
                }
            }
            else
            {
                regAddr = PRV_DXCH_REG1_UNIT_RXDMA_MAC(devNum).
                    singleChannelDMAConfigs.SCDMACTPktIndentification[ii];

                if(regAddr == PRV_CPSS_SW_PTR_ENTRY_UNUSED)
                {
                    /* the port RxDMA not valid */
                    continue;
                }

                rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 7, 2);
                if( GT_OK != rc )
                {
                    return rc;
                }
            }
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT3_RM_ROUTER_FIFOS_THRESHOLD_1_WA_E))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerFifoThreshold1Reg;
        /*stg5_desc_fifo_threshold*/
        regValue = 342;
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)) {
            regValue = 259;
        }
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 10, regValue);
        if (rc != GT_OK)
        {
            return rc;
        }
        if(!(PRV_CPSS_SIP_6_CHECK_MAC(devNum))) {
            /*stg7_desc_fifo_threshold*/
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 10, 10, 342);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT3_PORT_LED_POSITION_JUST_ON_USED_MAC_WA_E))
    {
        rc = prvCpssDxChLedErrataPortLedInit(devNum);
        if (GT_OK != rc)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT3_RM_EQ_ARBITERS_WA_E))
    {
        /*
            <Internal Weight> = 16 (decimal)
            <TxQ Weight> = 16 (decimal)
            <Ingress Pipe Weight> = 31 (decimal)
        */

        regAddr = PRV_DXCH_REG1_UNIT_EQ_MAC(devNum).
            preEgrEngineGlobalConfig.incomingWrrArbiterWeights;
        rc = prvCpssHwPpSetRegField(
            devNum, regAddr,
            0/*offset*/, 15/*length*/,
            (0x1f |         /* 31 :  0..4 */
            ((0x10)<<5) |   /* 16 :  5..9 */
            ((0x10)<<10))   /* 16 : 10..14*/
            /*data*/);
        if (rc != GT_OK)
        {
            return rc;
        }
        /*
            This configuration provides maximum bandwidth allocation to mirror to CPU
            <STC Dup Weight> = 1
            <Sniffer Dup Weight> = 1
            <Mirror Weight> = 31 (decimal)
        */
        regAddr = PRV_DXCH_REG1_UNIT_EQ_MAC(devNum).
            preEgrEngineGlobalConfig.dupFifoWrrArbiterWeights;
        rc = prvCpssHwPpSetRegField(
            devNum, regAddr,
            0/*offset*/, 15/*length*/,
            (0x1f |         /* 31 :  0..4 */
            ((0x1)<<5) |   /*  1  :  5..9 */
            ((0x1)<<10))   /*  1  : 10..14*/
            /*data*/);
        if (rc != GT_OK)
        {
            return rc;
        }

        if(!PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            /*<SP To QCN> = SP to QCN*/
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).
                peripheralAccess.peripheralAccessMisc.QCNIncArbiterCtrl;
            rc = prvCpssHwPpSetRegField(
                devNum, regAddr,
                0/*offset*/, 1/*length*/, 1 /*data*/);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    newSystemRecoveryInfo = oldSystemRecoveryInfo;

    newSystemRecoveryInfo.systemRecoveryProcess = CPSS_SYSTEM_RECOVERY_PROCESS_NOT_ACTIVE_E;
    newSystemRecoveryInfo.systemRecoveryState = CPSS_SYSTEM_RECOVERY_COMPLETION_STATE_E;
    prvCpssSystemRecoveryStateUpdate(&newSystemRecoveryInfo);

    rc = prvCpssDxChCgMacUnitDisable(devNum, GT_FALSE);
    if (rc != GT_OK)
    {
        return rc;
    }
    prvCpssSystemRecoveryStateUpdate(&oldSystemRecoveryInfo);

    if(PRV_CPSS_SIP_5_16_CHECK_MAC(devNum))
    {
        /* configure CN EtherType to be according to QCN EEEE802.1Qua.
           The default value of registers is 0 and packets with EthreType == 0
           erroneously treated as QCN and are sent to remote physical ports
           with CCFC DSA instead of FROM_CPU */
        rc = cpssDxChPortCnEtherTypeSet(devNum,0x22E7);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if(PRV_CPSS_PP_MAC(devNum)->isGmDevice && PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
    {
        /* set the GM with 'Hard wired' values of the bobcat3 */
        rc = GM_bobcat3TcamClientsHardWireSet(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT3_RM_TXQ_TX_SHAPER_BASELINE_WA_E))
    {
        /*
            setting according to :
            JIRA : CPSS-5972 : Shaper on 100G ports not working properly
        */

        regValue = 10 * _10K;
        rc = cpssDxChPortTxShaperBaselineSet(devNum,regValue);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_ALDRIN2_EPCL_TCAM_LOOKUP_LATENCY_WA_E))
    {
        /*
            Set "Egress Policy FIFO Configuration" register address 0x160000A0 to value 48 (0x30).
        */

        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCLFifoConfiguration;
        regValue = 48;
        rc = prvCpssHwPpWriteRegister(devNum, regAddr, regValue);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
    {
        GT_U32  nextHopIndex;
        /* Check if ECMP Indirect table is initialized properly
           In SIP6 devices each line includes 4 entries.
           Check second entry in second line */
        rc = cpssDxChIpEcmpIndirectNextHopEntryGet(devNum,5,&nextHopIndex);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(nextHopIndex == 0)
        {
            /* table was not properly initialized */
            /* set it 1:1 */
            for(nextHopIndex = 0 ;
                nextHopIndex < prvCpssDxchTableIpvxRouterEcmpPointerNumEntriesGet(devNum);
                nextHopIndex++)
            {
                rc = cpssDxChIpEcmpIndirectNextHopEntrySet(devNum,nextHopIndex,nextHopIndex);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }

#ifdef ASIC_SIMULATION
        /*-----------------------------------------------------------------------------------
         *  set default register value. (simulation code currently not support it)
         *-----------------------------------------------------------------------------------*/
        regAddr = PRV_DXCH_REG1_UNIT_HA_MAC(devNum).haGlobalConfig2;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 6, 0x3F);
        if(GT_OK != rc)
        {
            return rc;
        }
#endif

        if(!PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            /* enable HW WA for PRV_CPSS_DXCH_BOBCAT2_TXQ_TAIL_DROP_TABLES_R_W_PENDS_BUS_WA_E */
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).global.debugBus.queueMetalFix;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 16/*offset*/, 1/*length*/, 1 /*data*/);
            if (rc != GT_OK)
            {
                return rc;
            }
            /* enable by default the performance fix by the chicken bit */
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_LL_MAC(devNum).global.debugBus.llMetalFix;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0/*offset*/, 16/*length*/, 0xFD01/*data*/);
            if (rc != GT_OK)
            {
                return rc;
            }
            /*
             * This is fix to errata 7397144
             * Set "Global Tail Drop Configuration" register address 0x550A0000 bit 16 to value 1 (0x01).
             */
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.globalTailDropConfig;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 16/*offset*/, 1/*length*/, 1 /*data*/);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if( PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* need to set the entry of 'flood vidx' that is the last entry in the
           vidx table with all the ports (for BWC) */
        CPSS_PORTS_BMP_STC allMembers;
        GT_U32  numOfPorts = PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).phyPort; /* 64, ..1024*/

        /* get the bmp of supported ports in the device */
        prvCpssDrvPortsFullMaskGet(
                numOfPorts ,
                &allMembers);

        /* the 'tables manager' will convert the 'flood vidx' (0xFFF) to proper index in the VIDX table */
        rc = cpssDxChBrgMcEntryWrite(devNum,FLOOD_VIDX_CNS,&allMembers);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* the default value is 'hop-by-hop' but this value is not supported any more */
        /* so set the only supported value : End-to-End */
        regAddr = PRV_DXCH_REG1_UNIT_EQ_MAC(devNum).
            mirrToAnalyzerPortConfigs.analyzerPortGlobalConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 2, 0/*End-to-End*/);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_ALDRIN2_TCAM_ANSWERS_FLOOR_SAMPLES_INIT_VALUE_WA_E))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->TCAM.tcamAnswersFloorSample;
        rc = prvCpssHwPpWriteRegister(
            devNum, regAddr, 0x2A);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT3_RM_PFC_IND_FIFO_CROSS_MODE_THRESHOLD_WA_E))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->TXQ.pfc.PFCTriggerGlobalConfig;
        regValue = 10;

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 2, 8, regValue);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_FALCON_L2I_AND_EQ_READ_TABLE_BEFORE_TRAFFIC_WA_E))
    {
        static const CPSS_DXCH_TABLE_ENT tablesToRead[4] = {
             CPSS_DXCH_SIP5_TABLE_BRIDGE_INGRESS_EPORT_LEARN_PRIO_E /* 8 bytes alignment - 2 words */
            ,CPSS_DXCH_SIP5_TABLE_BRIDGE_SOURCE_TRUNK_ATTRIBUTE_E   /* 8 bytes alignment - 2 words */
            ,CPSS_DXCH_SIP5_TABLE_EQ_EPORT_TO_LOC_MAPPING_E         /* 4 bytes alignment - 1 word */
            ,CPSS_DXCH_SIP5_TABLE_EQ_L2_ECMP_E                      /* 4 bytes alignment - 1 word */
        };
        GT_U32  entryMemoBufArr[2]; /* use maximum entry alignment of all tables from list above */
        CPSS_DXCH_TABLE_ENT tableType;

        /*  the 2 JIRAs :
            L2I-773 - cmn_tbl_acc_2p_2wr_top has wrong behavior when getting burst of packets after init
            EQ-789  - 2 ports table access missed reply after init
        */

        /* need to read single entry from all the tables from all the 'port groups' */
        for(ii = 0; ii < 4; ii++)
        {
            tableType = tablesToRead[ii];

            /* loop on all active port groups in the device */
            PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
            {
                /* read the entry at index 0 from the table at the port group */
                rc = prvCpssDxChPortGroupReadTableEntry(devNum,portGroupId,tableType,
                    0,/* index 0 */
                    entryMemoBufArr);
                if(rc != GT_OK)
                {
                    break;
                }
            }
            PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_AC5P_MPLS_CUT_THROW_ENABLE_E))
    {
        rc = cpssDxChCutThroughMplsPacketEnableSet(devNum, GT_FALSE);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_TCAM_ARRAY_SPEED_MATCH_CFG_INIT_E))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->TCAM.tcamArrayConf.tcamArraySpeed;
        /* bits[2:1] Match Cfg set to 2 */
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 2, 2);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* need to enable the option to count drops in the RxDma unit */
        regAddr = PRV_DXCH_REG1_UNIT_SIP6_RXDMA_MAC(devNum).
            debug.dp_rx_enable_debug_counters;

        /* the GM not support this register */
        if(regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
        {
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
    {
        /* open the ability to generate interrupt by the temperature sensor */
        /* current default is wrong */

        /*
            Temperature Sensor Threshold  is currently 0x341. Based on the TSEN_ADC Spec the formula
            is Tc = Tstatus[9:0] * 0.394 + 128.9
            Currently the default Thd is set to 53 Celsius which is very low.
            Need to set by default to 110 Celsius.
        */
        rc = cpssDxChDiagDeviceTemperatureThresholdSet(devNum,110/* Degrees Celsius*/);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        /* init LMU unit */
        rc = prvCpssDxChHwLmuInit(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Init HW MACSec unit - disable core clock */
        rc = prvCpssDxChHwMacSecInit(devNum, GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_AC5P_RM_RELOCATE_EQ_DROP_TO_EREP_WA_E))
    {
        /* There are new debug/monitor features in AC5P and above devices.
           These features require that dropped packets got to end of processing pipe.
           Need to disable drop in ingress part of pipe for that. */
        rc =  cpssDxChCfgIngressDropEnableSet(devNum, GT_FALSE);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_AC5P_RM_IPFIX_FIRST_PACKET_CMD_WA_E))
    {
        CPSS_DXCH_POLICER_STAGE_TYPE_ENT        plrStage;       /* Policer stage ID */
        CPSS_DXCH_IPFIX_FIRST_PACKET_CONFIG_STC firstPacketCfg; /* configuration */

        for (plrStage = CPSS_DXCH_POLICER_STAGE_INGRESS_0_E;
             plrStage <= CPSS_DXCH_POLICER_STAGE_EGRESS_E; plrStage++)
        {
            rc = cpssDxChIpfixFirstPacketConfigGet(devNum, plrStage, &firstPacketCfg);
            if (rc != GT_OK)
            {
                /* skip not supported stages */
                continue;
            }
            /* default command should be Mirror To CPU */
            firstPacketCfg.packetCmd = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
            rc = cpssDxChIpfixFirstPacketConfigSet(devNum, plrStage, &firstPacketCfg);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_AC5P_RM_BRIDGE_CHECK_IP_HEADER_WA_E))
    {
        /* change IPM Classification Mode to be MAC DA + EtherType one. */
        regAddr = PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeGlobalConfig1;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 10, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_BOBCAT2_RM_DEFAULT_DOMAIN_ID_PER_DOMAIN_INDEX_E))
    {
        /* change default domain ID; init all domain indexes to Reserved PTP<DomainNumber> */
        for (ii=0; ii<=3; ii++)
        {
            rc = cpssDxChPtpDomainV2IdSet(devNum,ii,255);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_FALCON_RM_HASH_MODE_WA_E))
    {
        /* PCL: Packet hash calculation
           Falcon: Default trunk hash mode and hash selection function value should be fixed to 0x1
           But the default value is 0x0
           Need to fix the register default value to be 0x1
        */
        rc = cpssDxChTrunkHashCrcParametersGet(devNum, &crcMode, &crcSeed, &crcSeedHash1);
        if (rc != GT_OK)
        {
            return rc;
        }

        rc =  cpssDxChTrunkHashCrcParametersSet(devNum, CPSS_DXCH_TRUNK_LBH_CRC_32_MODE_E, crcSeed, crcSeedHash1);
        if (rc != GT_OK)
        {
            return rc;
        }

        rc =  cpssDxChTrunkHashGlobalModeSet(devNum, CPSS_DXCH_TRUNK_LBH_PACKETS_INFO_CRC_E);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    /* mandatory tsen register settings for AC5P/X */
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E)
    {
        rc = tseneMandatoryRegValuesSet(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_HARRIER_E)
    {
        rc = prvCpssDxChDiagDataIntegrityDfxServerClientsIntMaskSet(devNum,CPSS_EVENT_UNMASK_E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
    {
        rc = prvCpssDxChDiagDataIntegrityAllDfxServersClientsIntUnMask(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E)
    {
        /* Set MPP_38 to work with SyncE */
        rc = cpssDxChHwMppSelectSet(devNum, 38, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
        /* Set MPP_39 to work with SyncE */
        rc = cpssDxChHwMppSelectSet(devNum, 39, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E)
    {
        /* Set MPP_29 to work with SyncE */
        rc = cpssDxChHwMppSelectSet(devNum, 29, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
        /* Set MPP_30 to work with SyncE */
        rc = cpssDxChHwMppSelectSet(devNum, 30, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_HARRIER_E)
    {
        /* Set MPP_21 to work with SyncE */
        rc = cpssDxChHwMppSelectSet(devNum, 21, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
        /* Set MPP_22 to work with SyncE */
        rc = cpssDxChHwMppSelectSet(devNum, 22, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* the External Temperature threshold Interrupt is wrongly asserted during power UP.
           Need to clean this indication to avoid false interrupts. */
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnits.DFXServerRegs.serverInterruptCause;
        rc = prvCpssHwPpReadRegister(devNum, regAddr, &regValue);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (PRV_CPSS_SIP_6_30_CHECK_MAC(devNum) &&
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesStreamSrf)
    {
        CPSS_DXCH_STREAM_SRF_DAEMON_INFO_STC daemonInfo;

        rc = cpssDxChStreamSrfDaemonInfoGet(devNum,&daemonInfo);
        if(rc != GT_OK)
        {
            return rc;
        }
        /* 1. disable PREQ daemon , until needed */
        /* 2. fix defaults of HW for the period times , to fit the core clock
            to 100ms and 10ms */
        daemonInfo.restartDaemonEnable                      = GT_FALSE;
        daemonInfo.restartPeriodTimeInMicroSec              =  10*1000;/* 10 ms */
        daemonInfo.latentErrorDetectionPeriodTimeInMicroSec = 100*1000;/*100 ms */
        rc = cpssDxChStreamSrfDaemonInfoSet(devNum,&daemonInfo);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* set the default to use 802.1cbdb (instead of 802.1cb) */
        rc = prvCpssDxChStreamSrfUse802_1cbdb(devNum,GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }



    return GT_OK;
}

/**
* @internal hwPpPhase1NeededWaSettings function
* @endinternal
*
* @brief   Part 1 of "phase 1"
*         initialize all the WA that needed for the device
*         function called from the "phase 1" sequence.
* @param[in] devNum                   - The Pp's device number to set the errata Wa needed.
*
* @retval GT_OK                    - on success
* @retval GT_OUT_OF_CPU_MEM        - on failing memory allocation
*/
static GT_STATUS hwPpPhase1NeededWaSettings
(
    IN GT_U8    devNum
)
{
    GT_U32  ii;/*iterator*/
    PRV_CPSS_DXCH_ERRATA_STC *errataPtr =
        &PRV_CPSS_DXCH_PP_MAC(devNum)->errata;/*pointer to errata info of the device */

    /* set that the device need the fix of the :
       Errata FEr# */

      /* Disabling the Egress Rate Shaper under traffic may hang its
     relevant transmit queue. (FEr#47) */
    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                 PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E);

    /* needed WA for deadlock in the PP , between 'learning' and 'scanning' in
        FDB .
        see detailed info in description of:
        PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E */
    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E);

    /* Wrong default in FDB Global Configuration register - RM# 30160*/
    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E);

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E ||
                PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
        {
            /* fill additional errata/RM for the Lion2 */
            for(ii = 0 ; lion2ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
            {
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, lion2ErrAndRmArray[ii]);
            }
        }
        else /* Bobcat2; Caelum; Bobcat3 */
        {
            CPSS_PORTS_BMP_STC *portPcsRxErMaskDisableBmpPtr;

            /* bobcat2 fill errata/RM for the device */
            for(ii = 0 ; bobcat2ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
            {
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, bobcat2ErrAndRmArray[ii]);
            }

            /* When disabling the Auto-Neg on 100M or 10M interface, CRC error will be reported.
               It is due to a missing byte in the packets.
               It is related to all devices which support EEE.
               Set field rf_pcs_rx_er_mask_disable to 0 in register Gige_MAC_IP_Unit */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH_MISCONFIG_100BASEX_AN_DISABLE_WA_E);

            portPcsRxErMaskDisableBmpPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                        info_PRV_CPSS_DXCH_MISCONFIG_100BASEX_AN_DISABLE_WA_E.
                        portPcsRxErMaskDisableBmpPtr =
                    (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC));
            if (portPcsRxErMaskDisableBmpPtr == NULL)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
            }
            /* The default value is 1. In case LINK_DOWN is reported first */
            PRV_CPSS_PORTS_BMP_PORT_SET_ALL_MAC(portPcsRxErMaskDisableBmpPtr);

            if (0 == PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
            {
                /* set BC2 A0 specific WAs */

                /* FE-5613945 */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_BOBCAT2_SGMII_TO_CPU_NOT_SUPPORTED_WA_E);

                /* clean WAs not relevant for BC2 A0 devices */
                for(ii = 0 ; notExistsInBobcat2A0ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, notExistsInBobcat2A0ErrAndRmArray[ii]);
                }
            }

            if (1 == PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
            {
                /* clean WAs not relevant for BC2 B0 devices */
                for(ii = 0 ; notExistsInBobcat2B0ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, notExistsInBobcat2B0ErrAndRmArray[ii]);
                }
                /* set errata for BC2 B0 and above devices */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT2_FORCE_DOWN_LINK_PARTNER_WA_E);
            }

            /* Caelum (BobK), Aldrin, AC3X, Bobcat3 */
            if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                /* remove fixed errata/RM */
                for(ii = 0 ; fixedInBobkErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, fixedInBobkErrAndRmArray[ii]);
                }

                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) /* exclude Bobcat3 */
                {
                    /* Caelum, Cetus (BobK) A0 revision specific erratum */
                    if ((!PRV_CPSS_SIP_5_16_CHECK_MAC(devNum)) && (PRV_CPSS_PP_MAC(devNum)->revision == 0))
                    {
                        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_CAELUM_EGRESS_MEMORIES_NOT_RESET_WA_E);
                    }

                    /* Caelum, Cetus, Aldrin, AC3X specific errata/RM */
                    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_CAELUM_INGRESS_VLAN_RANGE_CONFIG_WA_E);
                    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_CAELUM_RM_PLR_UNUSED_IPLR_STAGES_MUST_BE_BYPASSED_WA_E);

                    /* aldrin specific errata/RM*/
                    if (PRV_CPSS_SIP_5_16_CHECK_MAC(devNum))
                    {
                        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_ALDRIN_WRONG_DEFAULT_CLEARED_UC_DIST_WA_E);
                        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_ALDRIN_WRONG_DEFAULT_BM_GLOBAL_GFG_3_WA_E);
                        /* Yet not implemented in simulation */
                        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_ALDRIN_TCAM_CONTENTS_NOT_INITALIZED_WA_E);
                    }
                }
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_CAELUM_TOD_DECREMENT_OPERATION_E);
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_CAELUM_RM_PLR_METERING_INACCURACY_IN_START_TRAFFIC_WA_E);
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_XCAT3_GIG_MAC_HALF_DUPLEX_COLLISION_DOMAIN_RM_E);
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_CAELUM_10G_XLG_LINK_UP_E);
                if (! PRV_CPSS_SIP_6_CHECK_MAC(devNum))
                {
                    PRV_CPSS_DXCH_ERRATA_SET_MAC(
                        devNum, PRV_CPSS_DXCH_CAELUM_TAI_FREQUENCY_ADJUST_TIME_WINDOW_INIT_VAL_WA_E);
                }
            }
            /* Bobcat2 B0, Caelum (BobK), Aldrin, AC3X, Bobcat3 */
            if (PRV_CPSS_SIP_5_10_CHECK_MAC(devNum) && (! PRV_CPSS_SIP_5_25_CHECK_MAC(devNum)))
            {
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_BOBCAT2_TXQ_TAIL_DROP_TABLES_R_W_PENDS_BUS_WA_E);
            }

            if (PRV_CPSS_SIP_5_16_CHECK_MAC(devNum))
            {
                /* fixed starting from Aldrin */
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_BOBCAT2_RXDMA_PIP_IPV6_WRONG_TC_BITS_WA_E);
            }

            /* Not relevant to AC3X */
            if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC3X_E)
            {
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_LION_RM_ORIG_SRC_PORT_FILTERING_WA_E);
            }

            if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                /* add extra sip5_20 Errata */
                for(ii = 0 ; bobcat3ExtraErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, bobcat3ExtraErrAndRmArray[ii]);
                }

                /* remove fixed errata/RM */
                for(ii = 0 ; fixedInBobcat3ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, fixedInBobcat3ErrAndRmArray[ii]);
                }
            }

            if (PRV_CPSS_SIP_5_25_CHECK_MAC(devNum) &&
                (PRV_CPSS_SIP_6_CHECK_MAC(devNum) == GT_FALSE))
            {
                /* add extra sip5_25 Errata */
                for(ii = 0 ; aldrin2ExtraErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, aldrin2ExtraErrAndRmArray[ii]);
                }

                /* remove fixed errata/RM */
                for(ii = 0 ; fixedInAldrin2ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, fixedInAldrin2ErrAndRmArray[ii]);
                }
            }

            if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                /* add extra sip6 Errata */
                for(ii = 0 ; falconExtraErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.sip6_sbmInfo.sharedMemoryNotUsed &&
                       falconExtraErrAndRmArray[ii] == PRV_CPSS_DXCH_FALCON_SBM_XOR_CLIENTS_READ_WRITE_BEFORE_SW_RESET_WA_E)
                    {
                        /* this erratum not relevant to device without shared memory */
                        /* AC5X , Harrier */
                        continue;
                    }

                    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, falconExtraErrAndRmArray[ii]);
                }

                /* remove fixed errata/RM */
                for(ii = 0 ; fixedInFalconErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, fixedInFalconErrAndRmArray[ii]);
                }

                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CONFIG_FOR_TAI_CTRL_1_E);

                if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
                {
                    /* falconPortCreateInfo : this DB is small so not created by 'malloc' */
                    PRV_CPSS_DXCH_PP_MAC(devNum)->port.falconPortCreateInfo.isWaNeeded = GT_TRUE;

                    if(! DXCH_HWINIT_GLOVAR(prvFalconPortDeleteWa_disabled))
                    {
                        /* falconPortDeleteInfoPtr : this DB is big so created by 'malloc' */
                        PRV_CPSS_DXCH_PP_MAC(devNum)->port.falconPortDeleteInfoPtr =
                            cpssOsMalloc(sizeof(PRV_CPSS_DXCH_WA_FALCON_PORT_DELETE_STC));
                        if(NULL == PRV_CPSS_DXCH_PP_MAC(devNum)->port.falconPortDeleteInfoPtr)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
                        }
                        /* reset the info */
                        cpssOsMemSet(PRV_CPSS_DXCH_PP_MAC(devNum)->port.falconPortDeleteInfoPtr,
                            0,sizeof(PRV_CPSS_DXCH_WA_FALCON_PORT_DELETE_STC));

                        PRV_CPSS_DXCH_PP_MAC(devNum)->port.falconPortDeleteInfoPtr->isWaNeeded = GT_TRUE;
                        PRV_CPSS_DXCH_PP_MAC(devNum)->port.falconPortDeleteInfoPtr->isWaNeeded_channel_reset_part =
                            prvFalconPortDeleteWa_disabled_channel_reset_part ?
                                GT_FALSE :/* for debug we disable it */
                                GT_TRUE;  /* we need the WA          */

                        if(PRV_CPSS_DXCH_PP_MAC(devNum)->port.falconPortDeleteInfoPtr->isWaNeeded_channel_reset_part == GT_TRUE)
                        {
                            /* this part of the WA in the 'port delete' also fix the limitations of port create ! */
                            PRV_CPSS_DXCH_PP_MAC(devNum)->port.falconPortCreateInfo.isWaNeeded = GT_FALSE;
                        }
                    }
                }
            }
        }
        if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
        {
            /* remove fixed errata/RM */
            for(ii = 0 ; fixedInHawkErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
            {
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, fixedInHawkErrAndRmArray[ii]);
            }

            for(ii = 0; (hawkExtraErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS); ii++)
            {
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, hawkExtraErrAndRmArray[ii]);
            }
        }

        if (PRV_CPSS_SIP_6_20_CHECK_MAC(devNum))
        {
            /* remove fixed errata/RM */
            for(ii = 0 ; fixedInHarrierErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
            {
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, fixedInHarrierErrAndRmArray[ii]);
            }

            for(ii = 0; (harrierExtraErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS); ii++)
            {
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, harrierExtraErrAndRmArray[ii]);
            }
        }

        if (PRV_CPSS_SIP_6_30_CHECK_MAC(devNum))
        {
            /* remove fixed errata/RM */
            for(ii = 0 ; fixedInIronmanErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
            {
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, fixedInIronmanErrAndRmArray[ii]);
            }

            for(ii = 0; (ironmanExtraErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS); ii++)
            {
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, ironmanExtraErrAndRmArray[ii]);
            }
        }



        if (PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_MAC(devNum) <= 1)
        {
            /* This errata relevant only to devices with more than one hemisphere */
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E);
        }

        if(PRV_CPSS_DXCH_LION2_B0_AND_ABOVE_CHECK_MAC(devNum))
        {
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                                     PRV_CPSS_DXCH_LION2_SHARE_EN_CHANGE_WA_E);
#ifndef ASIC_SIMULATION
/* simulation doesn't support status bits needed for this WA */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                                     PRV_CPSS_DXCH_LION2_DISMATCH_PORTS_LINK_WA_E);
#endif
        }

        if(PRV_CPSS_DXCH_LION2_B0_AND_ABOVE_CHECK_MAC(devNum)
           || (PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
        {
            CPSS_PORTS_BMP_STC *portForceLinkDownBmpPtr;

            portForceLinkDownBmpPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                        info_PRV_CPSS_DXCH_LION2_DISMATCH_PORT_LINK_WA_E.
                        portForceLinkDownBmpPtr =
                    (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC));
            if (portForceLinkDownBmpPtr == NULL)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
            }
            PRV_CPSS_PORTS_BMP_PORT_CLEAR_ALL_MAC(portForceLinkDownBmpPtr);
        }

        if(PRV_CPSS_DXCH_LION2_B1_AND_ABOVE_CHECK_MAC(devNum))
        {
            PRV_CPSS_DXCH_ERRATA_SET_MAC(
                devNum, PRV_CPSS_DXCH_LION2_GIGE_MAC_LINK_STATUS_WA_E);
            PRV_CPSS_DXCH_ERRATA_SET_MAC(
                devNum, PRV_CPSS_DXCH_LION2_CUT_THROUGH_SLOW_TO_FAST_WA_E);
        }

        /* must fill info for PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E */
        /* PCL */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptCauseRegAddr =
            0x0D0001A4; /* TCC (lower) for PCL register */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptIndex =
            PRV_CPSS_LION2_TCC_LOWER_GEN_TCAM_ERROR_DETECTED_E;

        /* Router */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptCauseRegAddr =
            0x0D800060; /* TCC (upper) for router register */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptIndex =
            PRV_CPSS_LION2_TCC_UPPER_GEN_TCAM_ERROR_DETECTED_E;

        if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) &&
           (PRV_CPSS_DXCH_PP_MAC(devNum)->diagInfo.tcamParityCalcEnable))

        {
            /* IP and Policy parity TCAM daemon is supported, no interrupt during direct read */
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum,
                        PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E);
        }

        if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
        {
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_NON_ORIG_VID_ON_TRAP_TO_CPU_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_TXDMA_FIFO_THRESHOLD_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_RM_RATE_LIMIT_DEFICIT_COUNT_EN_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_RM_STRICT_PRIORITY_FOR_UC_PACKETS_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_RM_TTI_BAD_DEFAULT_VALUE_FIX_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_RM_CONTROL_FROM_CPU_EGRESS_FILTER_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_MPLS_TRANSIT_TUNNEL_PARSING_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_RM_TXQ_PORT_REQUEST_MASK_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_NOT_ALLOW_TTI_ACTION_TO_SET_MODIFY_UP_DSCP_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_RM_GLOBAL_EPORT_RANGE_VALUE_AND_MASK_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_PFC_NOT_SUPPORTED_PORTS_48_71_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_FC_802_3X_NOT_SUPPORTED_TM_MAPPED_PORTS_WA_E);
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_BOBCAT2_DESCRIPTOR_ECC_PROTECTION_CORRUPTION_WITH_REMOTE_PORTS_WA_E);
        }
        if ((PRV_CPSS_SIP_5_16_CHECK_MAC(devNum)) && (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)))
        {
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT2_RM_TTI_BAD_DEFAULT_VALUE_FIX_WA_E);
        }
    }
    else if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        CPSS_PORTS_BMP_STC *portForceLinkDownBmpPtr;
        CPSS_PORTS_BMP_STC *portPcsRxErMaskDisableBmpPtr;

        /*  VLT direct access write problem with VLAN and STP tables (entry > 1 word) */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                                     PRV_CPSS_DXCH3_VLT_TABLES_WRITE_DIRECT_ACCESS_WA_E);

        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E);

        /* layer 4 sanity checks are enabled by default - RM#3018*/
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E);

        /* FEr#2018 - Policy base routing LTT index can be written only to array0 of the LTT line */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_LIMITED_NUMBER_OF_POLICY_BASED_ROUTES_WA_E);

        /* RM#2003: Buffer Management GbE and HyperG.Stack Ports Group Limits Configuration Registers */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_RM_BM_GE_XG_PORT_GROUP_LIMIT_CFG_REG_WA_E);

        /* FEr#2004 - Policy and Router TCAM Tables indirect read is not functional*/
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_POLICY_AND_ROUTER_TCAM_TABLES_INDIRECT_READ_WA_E);

        /* RM#2024: LMS0/1 Group1LED Interface0 Control Register 1 and Class6 Manipulation Register */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_RM_LMS0_1_GROUP1_LED_INTERFACE_WA_E);

        /* FEr#2028 - Direct access to EQ (Pre-Egress) engine address space is
           not functional under traffic */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E);

        /* FEr#2033,FEr#2050: When the CPU reads the POLICY TCAM or ROUTER TCAM
           via direct address space the ECC error exception signaled */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E);

        /* PCL */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptCauseRegAddr =
            0x1A0001A4; /* TCC (lower) for PCL register */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptIndex =
            PRV_CPSS_XCAT3_TCC_LOWER_TCAM_ERROR_DETECTED_E;/* value for xcat3 */

        /* Router */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptCauseRegAddr =
            0x1B000060; /* TCC (upper) for router register */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptIndex =
            PRV_CPSS_XCAT3_TCC_UPPER_TCAM_ERROR_DETECTED_E;/* value for xcat3 */

        if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        {
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptCauseRegAddr1 =
                0x200001A4; /* AC5 TCAM1 TCC (lower) for PCL register */

            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptIndex =
                PRV_CPSS_AC5_TCC_LOWER_TCAM_ERROR_DETECTED_E;
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptIndex1 =
                PRV_CPSS_AC5_TCC1_LOWER_TCAM_ERROR_DETECTED_E;
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptIndex =
                PRV_CPSS_AC5_TCC_UPPER_TCAM_ERROR_DETECTED_E;
        }

        /* When disabling the Auto-Neg on 100M or 10M interface, CRC error will be reported.
           It is due to a missing byte in the packets.
           It is related to all devices which support EEE.
           Set field rf_pcs_rx_er_mask_disable to 0 in register Gige_MAC_IP_Unit */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH_MISCONFIG_100BASEX_AN_DISABLE_WA_E);

        /* fill additional errata/RM for the xcat */
        for(ii = 0 ; xcatA1ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
        {
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,xcatA1ErrAndRmArray[ii]);
        }


       /* XCAT A2 and above, do not set 256*n+[1..4] padding WA */
        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_XCAT_TX_CPU_CORRUPT_BUFFER_WA_E);

       /* RM#3017 - Enable CPU lacks source port information on traffic received from trunk workaround */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_XCAT_RM_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E);

        for(ii = 0 ; xcat3ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
        {
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,xcat3ErrAndRmArray[ii]);
        }

        /* xCat3 tables access info is already initialized with the indirect access when required */
        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E);

        /* The following ERRATAs are cleared from xCat3 for initial bringup */
        /* Port related ones might be no longer valid due to new GOP.       */

        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_XCAT_RM_MAC_CTRL_REG3_PCS_PREAMBLE_WA_E);
        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_XCAT_RM_PORT_SERIAL_PARAMETERS_CONFIGURATION_WA_E);

        portForceLinkDownBmpPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION2_DISMATCH_PORT_LINK_WA_E.
                    portForceLinkDownBmpPtr =
                (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC));
        if (portForceLinkDownBmpPtr == NULL)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }
        PRV_CPSS_PORTS_BMP_PORT_CLEAR_ALL_MAC(portForceLinkDownBmpPtr);

        portPcsRxErMaskDisableBmpPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_MISCONFIG_100BASEX_AN_DISABLE_WA_E.
                    portPcsRxErMaskDisableBmpPtr =
                (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC));
        if (portPcsRxErMaskDisableBmpPtr == NULL)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }
        /* The default value is 1. In case LINK_DOWN is reported first */
        PRV_CPSS_PORTS_BMP_PORT_SET_ALL_MAC(portPcsRxErMaskDisableBmpPtr);

        /* remove cause PCL tests to fail :
        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E);
        */
        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH3_RM_GE_PORTS_MODE1_REG_WA_E);
        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH3_RM_XG_PORTS_MODE_REG_WA_E);
        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_XCAT_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E);

        /* AC5: RM-2141433 */
        if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        {
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_PORT_MAC_CONTROL_REG4_WA_E);
        }
    }

    /* Aldrin, AC3X, BC3, Aldrin2 */
    if (PRV_CPSS_SIP_5_16_CHECK_MAC(devNum) && (! PRV_CPSS_SIP_6_CHECK_MAC(devNum)))
    {
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_ERRATA_ALDRIN_SDWRR_WA_E);
    }

    if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E))
    {
        /* ports state shadow */
        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E.
            portTxQueuesBmpPtr = (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC)*CPSS_TC_RANGE_CNS);
        if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E.
                portTxQueuesBmpPtr == NULL)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }

        for (ii = 0; ii < CPSS_TC_RANGE_CNS; ii++)
        {
            /* assume initial state of ports TX queues - enabled */
            PRV_CPSS_PORTS_BMP_PORT_SET_ALL_MAC(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                 info_PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E.portTxQueuesBmpPtr + ii);
        }

    }

    return GT_OK;
}



/**
* @struct PLL0_FLD_DEF_STC
 *
 * @brief A structure defines PPL0 register and field
*/
typedef struct{

    /** register address */
    GT_U32 addr;

    /** field start bit */
    GT_U32 startBit;

    /** field length */
    GT_U32 length;

    /** field default value */
    GT_U32 defValue;

} PLL0_FLD_DEF_STC;
/**
* @struct PRV_CPSS_DXCH_FAMILY_SUBFAM_REV_x_CORECLOCK_LIST_CONV_STC
 *
 * @brief A structure to Core Clock PLL config tables pointers
*/
typedef struct{

    CPSS_PP_FAMILY_TYPE_ENT family;

    CPSS_PP_SUB_FAMILY_TYPE_ENT subFamily;

    /** @brief The device's revision number.
     *  tablePtr   - pointer to PLL config to core clock table
     */
    GT_U32 revision;

    PLL0_FLD_DEF_STC sar1_pll0_def;

    GT_U16 *tablePtr;

    /** size of table */
    GT_U16 tableSize;

} PRV_CPSS_DXCH_FAMILY_SUBFAM_REV_x_CORECLOCK_LIST_CONV_STC;

extern GT_U32 simCoreClockOverwrittenGet(GT_VOID);

/**
* @internal hwPpAutoDetectCoreClock function
* @endinternal
*
* @brief   Retrieves Core Clock value
*
* @param[in] devNum                   - The Pp's device numer.
*
* @param[out] coreClkPtr               - Pp's core clock in MHz
*
* @retval GT_OK                    - on success,
* @retval GT_BAD_STATE             - can't map HW value to core clock value.
* @retval GT_FAIL                  - otherwise.
*
* @note Function is using hard coded registers address since registers DB is not
*       yet initialized.
*
*/
static GT_STATUS hwPpAutoDetectCoreClock
(
    IN  GT_U8   devNum,
    OUT GT_U32  *coreClkPtr
)
{

    GT_U32 data = 0;
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr;/* pointer to common device info */
    GT_BOOL valueReadFromHw = GT_TRUE;

    devPtr = PRV_CPSS_PP_MAC(devNum);

    switch(devPtr->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_AC5_E:
            if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE)
            {
                /* can not rely on PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsDeviceSpecificRegs.initializationStatusDone because :
                          initRegAddrDb(...) was not called yet !!!  */

                /* retrieve PP Core Clock from "Device SAR2" */
                if (prvCpssDrvHwPpResetAndInitControllerGetRegField(
                                    devNum, PRV_CPSS_AC5_DFX_BASE_ADDRESS_CNS + PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS, 22, 2, &data) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }
            switch(data)
            {
                case 0x0:  *coreClkPtr = 395; /*395.833*/ break;
                case 0x1:  *coreClkPtr = 290; /*290.625*/ break;
                case 0x2:  *coreClkPtr = 167; /*167.500*/ break;
                case 0x3:  /*Bypass; PLL0 is bypassed.*/
                default:    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            break;
        case CPSS_PP_FAMILY_DXCH_XCAT3_E:
            if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE)
            {
                /* retrieve PP Core Clock from "Device SAR2" */
                if (prvCpssDrvHwPpResetAndInitControllerGetRegField(
                                    devNum, PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS, 21, 3, &data) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                valueReadFromHw = GT_FALSE;
            }

            switch(data)
            {
                case 0x0:  *coreClkPtr = 290; break;
                case 0x1:  *coreClkPtr = 250; break;
                case 0x2:  *coreClkPtr = 220; break;
                case 0x3:  *coreClkPtr = 167; break;
                case 0x4:  *coreClkPtr = 200; break;
                case 0x5:  *coreClkPtr = 133; break;
                case 0x6:  *coreClkPtr = (devPtr->devType == CPSS_98DX3247_CNS) ? 395 : 360; break;
                case 0x7:  /*Bypass; PLL0 is bypassed.*/
                default:    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            break;

        case CPSS_PP_FAMILY_DXCH_LION2_E:
            if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE)
            {
                /* retrieve PP Core Clock from "Functional SAR Status LSB" */
                if (prvCpssHwPpGetRegField(devNum, 0x018F8200, 0, 3, &data) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                valueReadFromHw = GT_FALSE;
            }

            switch(data)
            {
                case 0x0:  *coreClkPtr = 480; break;
                case 0x1:  *coreClkPtr = 360; break;
                case 0x2:  *coreClkPtr = 270; break;
                case 0x3:  *coreClkPtr = 450; break;
                case 0x4:  *coreClkPtr = 312; break; /* 312.5Mhz */
                case 0x5:  *coreClkPtr = 240; break;
                case 0x6:  *coreClkPtr = 210; break;
                case 0x7:  /*Bypass; PLL0 is bypassed.*/
                default:    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            break;
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
        case CPSS_PP_FAMILY_DXCH_AC3X_E:
        case CPSS_PP_FAMILY_DXCH_ALDRIN2_E:
        case CPSS_PP_FAMILY_DXCH_FALCON_E:
        case CPSS_PP_FAMILY_DXCH_AC5P_E:
        case CPSS_PP_FAMILY_DXCH_AC5X_E:
        case CPSS_PP_FAMILY_DXCH_HARRIER_E:
        case CPSS_PP_FAMILY_DXCH_IRONMAN_E:
        {
            const PRV_CPSS_DXCH_FAMILY_SUBFAM_REV_x_CORECLOCK_LIST_CONV_STC *clockTbl = NULL;

            static const GT_U16 clockMHzByPLL0_bc2_Status_x_revision_0[] =
            {                    /*   0,    1,   2,   3,   4,   5.   6   */
                    /* 0 */         362, /* 362.500000 Mhz */
                    /* 1 */         221, /* 220.833333 Mhz */
                    /* 2 */         250, /* 250.000000 Mhz */
                    /* 3 */         400, /* 400.000000 Mhz */
                    /* 4 */         500, /* 500.000000 Mhz */
                    /* 5 */         521, /* 520.833333 Mhz */
                    /* 6 */         450  /* 450.000000 Mhz */
            };
            static const GT_U16 clockMHzByPLL0_bc2_Status_x_revision_1[] =
            {
                    /* 0 */         362, /* 362.500000 Mhz */
                    /* 1 */         221, /* 220.833333 Mhz */
                    /* 2 */         250, /* 250.000000 Mhz */
                    /* 3 */         400, /* 400.000000 Mhz */
                    /* 4 */         175, /* ???            */
                    /* 5 */         521, /* 520.833333 Mhz */
                    /* 6 */         450  /* 450.000000 Mhz */
            };

            static const GT_U16 clockMHzByPLL0_bobk_Status_x_revision_0[] =
            {
                    /* 0 */         365,      /* 0 = 365.625 MHz    */
                    /* 1 */         220,      /* 1 = 220.833 MHz    */
                    /* 2 */         250,      /* 2 = 250.000 MHz    */
                    /* 3 */         200,      /* 3 = 200.000 MHz    */
                    /* 4 */         167,      /* 4 = 167.188 MHz    */
                    /* 5 */         133,      /* 5 = 133.333 Mhz Reserved  */
                    /* 6 */         225,      /* 6 = 225.000 Mhz Reserved  */
                    /* 7 */          25       /* 7 = Bypass mode (PLL in power down), output is 25Mhz */
            };
            static const GT_U16 clockMHzByPLL0_aldrin_Status_x_all_revisions[] =
            {
                    /* 0 */         365,      /* 0 = 365.625 MHz    */
                    /* 1 */         220,      /* 1 = 220.833 MHz Reserved   */
                    /* 2 */         250,      /* 2 = 250.000 MHz    */
                    /* 3 */         200,      /* 3 = 200.000 MHz    */
                    /* 4 */         480,      /* 4 = 480.000 MHz    */
                    /* 5 */         510,      /* 5 = 510.333 Mhz Reserved  */
                    /* 6 */         540,      /* 6 = 540.000 Mhz Reserved  */
                    /* 7 */          25       /* 7 = Bypass mode (PLL in power down), output is 25Mhz */
            };

            static const GT_U16 clockMHzByPLL0_bc3_Status_x_revision_0[] =
            {
                    /* 0 */         525,      /*  0 = 450      Reserved    */
                    /* 1 */           0,      /*  1 = 487.5    Reserved    */
                    /* 2 */         525,      /*  2 = 525                  */
                    /* 3 */           0,      /*  3 = 583.334  Reserved    */
                    /* 4 */         600,      /*  4 = 600                  */
                    /* 5 */         625,      /*  5 = 625      Reserved    */
                    /* 6 */           0,      /*  6 = 556.250  Reserved    */
                    /* 7 */           0,      /*  7 = 250      Reserved    */
                    /* 8 */         572,      /*  8 = 572.917              */
                    /* 9 */           0,      /*  9 = 577.083  Reserved    */
                    /*10 */           0,      /* 10 = 585.417  Reserved    */
                    /*11 */           0,      /* 11 = 400      Reserved    */
                    /*12 */           0,      /* 12 = 535.416  Reserved    */
                    /*13 */           0,      /* 13 = 545.8335 Reserved    */
                    /*14 */           0,      /* 14 = 593.75   Reserved    */
                    /*15 */           0       /* 15 = PLL bypass Reserved  */
            };


            static const GT_U16 clockMHzByPLL0_aldrin2_Status_x_revision_0[] =
            {
                    /* 0 */         450,
                    /* 1 */         0,
                    /* 2 */         600,
                    /* 3 */         525,
                    /* 4 */         0,
                    /* 5 */         0,
                    /* 6 */         0,
                    /* 7 */          25       /* 7 = Bypass mode (PLL in power down), output is 25Mhz */
            };

            static const GT_U16 clockMHzByPLL1_falcon_Status_x_revision_0[] =
            {
                    /* 0 */         700, /* 700.1201923 */
                    /* 1 */         732, /* 732.421875  */
                    /* 2 */         661, /* 660.8072917 */
                    /* 3 */         818, /* 818.1423611 */
                    /* 4 */         618, /* 618.4895833 */
                    /* 5 */         553, /* 553.3854167 */
                    /* 6 */         420, /* 419.921875  */
                    /* 7 */         78   /* 78.125      */  /* 7 = Bypass mode (PLL in power down), output is 78.125 Mhz */
            };

            static const GT_U16 clockMHzByPLL1_hawk_Status_x_revision_0[] =
            {
                    /* 0 */         812, /* 812.500 */
                    /* 1 */         844, /* 843.750 */
                    /* 2 */         781, /* 781.250 */
                    /* 3 */         875, /* 875.000 */
                    /* 4 */         750, /* 750.000 */
                    /* 5 */         650, /* 650.000 */
                    /* 6 */         487, /* 487.500 */
                    /* 7 */         25   /* 25      */  /* 7 = Bypass mode (PLL in power down), output is 25 Mhz */
            };

            static const GT_U16 clockMHzByPLL1_phoenix_Status_x_revision_0[] =
            {
                                          /* core clock    */ /* core clock X2                 */
                    /* 0 */          510, /* 510.4166667   */ /* 1020.8333                     */
                    /* 1 */          535, /* 535.4166667   */ /* 1070.8333                     */
                    /* 2 */          485, /* 485.4166667   */ /* 970.83333                     */
                    /* 3 */          140, /* 139.84375     */ /* 1118.75 divider 4 --> 279.688 */
                    /* 4 */          147, /* 146.875       */ /* 1175    divider 4 --> 293.750 */
                    /* 5 */          133, /* 132.8125      */ /* 1062.5  divider 4 --> 265.625 */
                    /* 6 */            0, /* --------- */
                    /* 7 */         25   /* 25      */  /* 7 = Bypass mode (PLL in power down), output is 25 Mhz */
            };

            static const GT_U16 clockMHzByPLL1_harrier_Status_x_revision_0[] = CPSS_TBD_BOOKMARK_HARRIER
            {
                    /* 0 */         812, /* 812.500 */
                    /* 1 */         844, /* 843.750 */
                    /* 2 */         781, /* 781.250 */
                    /* 3 */         875, /* 875.000 */
                    /* 4 */         750, /* 750.000 */
                    /* 5 */         650, /* 650.000 */
                    /* 6 */         487, /* 487.500 */
                    /* 7 */         25   /* 25      */  /* 7 = Bypass mode (PLL in power down), output is 25 Mhz */
            };
            static const GT_U16 clockMHzByPLL1_ironman_l_Status_x_revision_0[] = CPSS_TBD_BOOKMARK_IRONMAN
            {
                    /* 0 */         600, /* 600.000 according to IAS 1.3 */
                    /* 1 */         844, /* 843.750 */
                    /* 2 */         781, /* 781.250 */
                    /* 3 */         875, /* 875.000 */
                    /* 4 */         750, /* 750.000 */
                    /* 5 */         650, /* 650.000 */
                    /* 6 */         487, /* 487.500 */
                    /* 7 */         25   /* 25      */  /* 7 = Bypass mode (PLL in power down), output is 25 Mhz */
            };


#define CLK_TBL(T) (GT_U16*)&T[0], (GT_U16)(sizeof(T)/sizeof(T[0]))

            static const PRV_CPSS_DXCH_FAMILY_SUBFAM_REV_x_CORECLOCK_LIST_CONV_STC fam_subFam_rev_x_coreClockList[] =
            {     /*                       family,                  subfamily,      rev, {fldAddr, startBit, len, defValue}, table    */
                  { CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_NONE_E,         0, {PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS,  21,  3,  0} , CLK_TBL(clockMHzByPLL0_bc2_Status_x_revision_0)        }
                 ,{ CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_NONE_E,         1, {PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS,  21,  3,  0} , CLK_TBL(clockMHzByPLL0_bc2_Status_x_revision_1)        }
                 ,{ CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E, 0, {PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS,  21,  3,  0} , CLK_TBL(clockMHzByPLL0_bobk_Status_x_revision_0)       }
                 ,{ CPSS_PP_FAMILY_DXCH_BOBCAT3_E, CPSS_PP_SUB_FAMILY_NONE_E,         0, {PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS,  20,  4,  2} , CLK_TBL(clockMHzByPLL0_bc3_Status_x_revision_0)        }
                 ,{ CPSS_PP_FAMILY_DXCH_ALDRIN_E,  CPSS_PP_SUB_FAMILY_NONE_E,         0, {PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS,  21,  3,  0} , CLK_TBL(clockMHzByPLL0_aldrin_Status_x_all_revisions)  }
                 ,{ CPSS_PP_FAMILY_DXCH_AC3X_E,    CPSS_PP_SUB_FAMILY_NONE_E,         0, {PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS,  21,  3,  0} , CLK_TBL(clockMHzByPLL0_aldrin_Status_x_all_revisions)  }
                 ,{ CPSS_PP_FAMILY_DXCH_ALDRIN2_E, CPSS_PP_SUB_FAMILY_NONE_E,         0, {PRV_CPSS_DFX_SERVER_SAR2_REG_ADDR_CNS,  21,  3,  2} , CLK_TBL(clockMHzByPLL0_aldrin2_Status_x_revision_0)    }
                 ,{ CPSS_PP_FAMILY_DXCH_FALCON_E,  CPSS_PP_SUB_FAMILY_NONE_E,         0, {PRV_CPSS_FALCON_DFX_SAR2_REG_ADDR_CNS,  18,  3,  0} , CLK_TBL(clockMHzByPLL1_falcon_Status_x_revision_0)     }
                 ,{ CPSS_PP_FAMILY_DXCH_AC5P_E,    CPSS_PP_SUB_FAMILY_NONE_E,         0, {PRV_CPSS_AC5P_DFX_SAR2_REG_ADDR_CNS  ,  18,  3,  0} , CLK_TBL(clockMHzByPLL1_hawk_Status_x_revision_0)       }
                 ,{ CPSS_PP_FAMILY_DXCH_AC5X_E, CPSS_PP_SUB_FAMILY_NONE_E,         0, {PRV_CPSS_PHOENIX_DFX_SAR2_REG_ADDR_CNS, 18,  3,  0} , CLK_TBL(clockMHzByPLL1_phoenix_Status_x_revision_0)    }
                 ,{ CPSS_PP_FAMILY_DXCH_HARRIER_E, CPSS_PP_SUB_FAMILY_NONE_E,         0, {PRV_CPSS_HARRIER_DFX_SAR2_REG_ADDR_CNS, 18,  3,  0} , CLK_TBL(clockMHzByPLL1_harrier_Status_x_revision_0)    }
        /*IM-L*/ ,{ CPSS_PP_FAMILY_DXCH_IRONMAN_E, CPSS_PP_SUB_FAMILY_NONE_E,         0, {PRV_CPSS_IRONMAN_DFX_SAR2_REG_ADDR_CNS, 18,  3,  0} , CLK_TBL(clockMHzByPLL1_ironman_l_Status_x_revision_0)    }

            };

            GT_U32 i;

            /*-------------------------------------------------*/
            /* find greatest revision smaller or equal to given */
            /*-------------------------------------------------*/

            /* find first suitable revision */
            for (i = 0 ; i < sizeof(fam_subFam_rev_x_coreClockList)/sizeof(fam_subFam_rev_x_coreClockList[0]); i++)
            {
                if (fam_subFam_rev_x_coreClockList[i].family    == PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.devFamily &&
                    fam_subFam_rev_x_coreClockList[i].subFamily == PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.devSubFamily)
                {
                    if (fam_subFam_rev_x_coreClockList[i].revision <= PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.revision)
                    {
                        if (clockTbl != NULL)
                        {
                            if (fam_subFam_rev_x_coreClockList[i].revision <= clockTbl->revision)
                            {
                                continue;
                            }
                        }
                        clockTbl = fam_subFam_rev_x_coreClockList+i;
                    }
                }
            }
            if (clockTbl == NULL)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            }

            /* read from HW */
            if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE)
            {
                /* retrieve PP Core Clock from "Device SAR2 PLL0 " */
                /* /Cider/EBU/Bobcat2B/Bobcat2 {Current}/Reset and Init Controller/DFX Server Units - BC2 specific registers/Device SAR2                */
                /* /Cider/EBU/BobK/BobK {Current}/Reset And Init Controller/DFX Units/Units/DFX Server Registers/Device Sample at Reset (SAR) Status<1> */
                if (prvCpssDrvHwPpResetAndInitControllerGetRegField(
                             devNum,
                             clockTbl->sar1_pll0_def.addr,
                             clockTbl->sar1_pll0_def.startBit,
                             clockTbl->sar1_pll0_def.length, &data) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                /* DFX server is not supported at device, take default value */
                data = clockTbl->sar1_pll0_def.defValue;
                valueReadFromHw = GT_FALSE;
            }
            if (data >= clockTbl->tableSize)  /*Bypass; PLL0 is bypassed.*/
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            *coreClkPtr = (GT_U32)clockTbl->tablePtr[data];
        }
        break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    if( valueReadFromHw == GT_FALSE)
    {
        #ifdef WM_IMPLEMENTED
        if(simCoreClockOverwrittenGet() != 0)
        {
            *coreClkPtr = simCoreClockOverwrittenGet();
        }
        #endif
    }

    return GT_OK;
}

/**
* @internal devDbBusBaseAddrAttachKeyGet function
* @endinternal
*
* @brief   Calculate unique BusBaseAddr key for prvCpssPpConfigDevDbBusBaseAddrAttach call.
*
* @param[in] ppPhase1ParamsPtr        - Packet processor hardware specific parameters.
* @param[in] multiPortGroupDevice     - indication that the device supposed to be 'multi port groups' device.
* @param[in] firstActivePortGroupId   - first Active Port GroupId, pelevant for multi Port Group Device only
*                                       bus Base Addr Key value
*/
static GT_UINTPTR devDbBusBaseAddrAttachKeyGet
(
    IN      CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr,
    IN      GT_BOOL                             multiPortGroupDevice,
    IN      GT_U32                              firstActivePortGroupId
)
{
    CPSS_HW_INFO_STC *hwInfoPtr;

    if (multiPortGroupDevice == GT_FALSE)
        firstActivePortGroupId = 0;

    hwInfoPtr = &(ppPhase1ParamsPtr->hwInfo[firstActivePortGroupId]);

    if (ppPhase1ParamsPtr->mngInterfaceType == CPSS_CHANNEL_PEX_KERNEL_E)
    {
        return (3 |
            (hwInfoPtr->hwAddr.busNo << 2) |
            (hwInfoPtr->hwAddr.devSel << 12) |
            (hwInfoPtr->hwAddr.funcNo << 22));
    }
    else
    {
        return hwInfoPtr->resource.switching.start;
    }
}
/**
* @internal setSipVersion function
* @endinternal
*
* @brief   set the sip version (legacy / 5 / 5_10 / 5_15 /...).
*
* @param[in] devNum                   -  the device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS setSipVersion
(
    IN GT_U8    devNum
)
{
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = PRV_CPSS_PP_MAC(devNum);

    if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
    {
        if(devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
        {
            /* supports sip 5_15 */
            PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_15_E);
        }
        else if (devPtr->revision > 0)
        {
            /* supports sip 5_10 */
            PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_10_E);
        }
        else
        {
            /* supports sip 5 */
            PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_E);
        }
    }
    else if((devPtr->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E) ||
            (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_AC3X_E))
    {
        /* supports sip 5_16 */
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_16_E);
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
    {
        /* supports sip 5_20 */
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_20_E);
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)
    {
        /* supports sip 5_25 */
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_25_E);
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
    {
        /* supports sip 6 */
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_6_E);
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E)
    {
        /* supports sip 6.10 */
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_6_10_E);
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E)
    {
        /* supports sip 6.15 */
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_6_15_E);
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_HARRIER_E)
    {
        /* supports sip 6.20 */
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_6_20_E);
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_IRONMAN_E)
    {
        /* supports sip 6.30 */
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_6_30_E);
    }
    else
    {
        /* we do not hold differentiation between legacy devices */
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_LEGACY_E);
        return GT_OK;
    }

    /* set additional flags needed by 'higher' SIP version */
    if(PRV_CPSS_SIP_CHECK_MAC(devNum,CPSS_GEN_SIP_6_30_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_6_20_E);
    }

    if(PRV_CPSS_SIP_CHECK_MAC(devNum,CPSS_GEN_SIP_6_20_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_6_15_E);
    }

    if(PRV_CPSS_SIP_CHECK_MAC(devNum,CPSS_GEN_SIP_6_15_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_6_10_E);
    }

    if(PRV_CPSS_SIP_CHECK_MAC(devNum,CPSS_GEN_SIP_6_10_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_6_E);
    }

    if(PRV_CPSS_SIP_CHECK_MAC(devNum,CPSS_GEN_SIP_6_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_25_E);
    }

    if(PRV_CPSS_SIP_CHECK_MAC(devNum,CPSS_GEN_SIP_5_25_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_20_E);
    }

    if(PRV_CPSS_SIP_CHECK_MAC(devNum,CPSS_GEN_SIP_5_20_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_16_E);
    }

    if(PRV_CPSS_SIP_CHECK_MAC(devNum,CPSS_GEN_SIP_5_16_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_15_E);
    }

    if(PRV_CPSS_SIP_CHECK_MAC(devNum,CPSS_GEN_SIP_5_15_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_10_E);
    }

    if(PRV_CPSS_SIP_CHECK_MAC(devNum,CPSS_GEN_SIP_5_10_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,CPSS_GEN_SIP_5_E);
    }

    return GT_OK;
}

void debug_force_numOfDp_set(GT_U32 num)
{
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfDp) = num;
}
GT_U32 debug_force_numOfDp_get(void)
{
    return DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfDp);
}
void debug_force_numOfPipes_set(GT_U32 num)
{
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfPipes) = num;
}
GT_U32 debug_force_numOfPipes_get(void)
{
    return DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfPipes);
}

/* local DMAs existing in aldrin DP 0 and 1  */
static const GT_U32 aldrinLocalDma_dp_0_1_Arr[12] = {56, 57, 58, 59, 64, 65, 66, 67, 68, 69, 70, 71};

/* local DMAs existing in aldrin DP 2 */
static const GT_U32 aldrinLocalDma_dp_2_Arr[10] = {56, 57, 58, 59, 64, 65, 66, 67, 62, 72};

static GT_STATUS init_phyPortInfoArray(IN GT_U8 devNum)
{
    if(PRV_CPSS_PP_MAC(devNum)->phyPortInfoArray)
    {
        return GT_OK;
    }
    /* allocation of physical ports information - phyPortInfoArray */
    PRV_CPSS_PP_MAC(devNum)->phyPortInfoArray = (PRV_CPSS_PORT_INFO_ARRAY_STC*)
        cpssOsMalloc(sizeof(PRV_CPSS_PORT_INFO_ARRAY_STC) * PRV_CPSS_PP_MAC(devNum)->numOfPorts);

    if (PRV_CPSS_PP_MAC(devNum)->phyPortInfoArray == NULL)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
    }
    cpssOsMemSet(PRV_CPSS_PP_MAC(devNum)->phyPortInfoArray, 0,
                 (sizeof(PRV_CPSS_PORT_INFO_ARRAY_STC) * PRV_CPSS_PP_MAC(devNum)->numOfPorts));
    return GT_OK;
}
/**
* @internal setSip5FlexInfo function
* @endinternal
*
* @brief   set sip5 flex parameters.
*
* @param[in] devNum                   -  the device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS setSip5FlexInfo
(
    IN GT_U8    devNum
)
{
    GT_STATUS rc;
    PRV_CPSS_DXCH_PP_CONFIG_STC *dxDevPtr = PRV_CPSS_DXCH_PP_MAC(devNum);
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = &dxDevPtr->genInfo;
    GT_U32  isBobkCetus=0;/* indication that this is bobk-cetus */
    GT_U32  ii;/*iterator*/

    /* don't use macro PRV_CPSS_SIP_5_CHECK_MAC before this line */
    /* in Bobcat2; Caelum; Bobcat3 eArch is supported */
    dxDevPtr->hwInfo.eArch.supported = GT_TRUE;

    PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) = GT_TRUE;
    PRV_CPSS_DEV_DFX_MULTI_INSTANCE_CHECK_MAC(devNum) = GT_FALSE;

    if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
    {
        PRV_CPSS_DEV_DFX_MULTI_INSTANCE_CHECK_MAC(devNum) = GT_TRUE;
    }
    if(PRV_CPSS_PP_MAC(devNum)->isGmDevice)
    {
        /* the GM device not supports the DFX server unit */
        PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) = GT_FALSE;
    }

    dxDevPtr->hwInfo.dedicatedCpuMac.isNotSupported = GT_TRUE;
    dxDevPtr->hwInfo.portMapping.isUsedPortMappingCheck = GT_TRUE;

    dxDevPtr->hwInfo.tti.numDefaultEports = 512;

    dxDevPtr->hwInfo.tcam.numBanksForHitNumGranularity = 2;
    dxDevPtr->hwInfo.tcam.maxFloors = 12;
    dxDevPtr->hwInfo.tcam.maxClientGroups = 5;

    dxDevPtr->hwInfo.lpm.numOfBlocks = 20;
    dxDevPtr->hwInfo.lpm.numOfLinesInBlock = _16K;
    dxDevPtr->hwInfo.lpm.totalNumOfLinesInBlockIncludingGap = _16K;

    rc = prvCpssDxChSMIInfoByPPSet(devNum);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* single core device */
    dxDevPtr->hwInfo.cpuPortInfo.info[0].valid = GT_TRUE;
    dxDevPtr->hwInfo.cpuPortInfo.info[0].usedAsCpuPort = GT_TRUE;
    dxDevPtr->hwInfo.cpuPortInfo.info[0].dmaNum = 72;
    dxDevPtr->hwInfo.cpuPortInfo.info[0].dqNum = 0;

    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).portGroupId = 3;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).trunkId  = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).hwDevNum = 10;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).vidx     = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).fid      = 13;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).fdbUserDefined = 8;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).vid      = 13;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).eVidx    = 14;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).stgId    = 12;


    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL2Ecmp  = _8K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL3Ecmp  = _12K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIpNh    = _24K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMllLtt  = _32K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMllPairs = _8K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIplrMetering = _8K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesEplrMetering = _8K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesOam     = _2K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesTxqQueue = 72*8/*576*/;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesProtectionLoc = _2K;

    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.maxNumOfTais = 2;
    if(PRV_CPSS_SIP_5_16_CHECK_MAC(devNum))
    {
        /* Aldrin,Aldrin2,Bobcat3 and Falcon have 500 MHz PTP clock */
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ptpInfo.ptpClkInKhz = 500000;
    }

    if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        /*indication about two instances of TAI */
        dxDevPtr->hwInfo.gop_tai.supportSingleInstance = GT_FALSE;
        /*indication that no support for ILKN */
        dxDevPtr->hwInfo.gop_ilkn.supported = GT_FALSE;
        /*indication that LMS unit is not supported.(need to use SMI unit,LED unit)*/
        dxDevPtr->hwInfo.gop_lms.notSupported = GT_TRUE;

        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort  = 9;
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).ePort    = 14;
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).sstId    = 12 ;

        dxDevPtr->hwInfo.tcam.numBanksForHitNumGranularity =  2;

        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL2Ecmp  = _16K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL3Ecmp  = _12K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIpNh    = _24K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMllPairs = _16K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIplrMetering = _16K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesEplrMetering = _16K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesOam     = _8K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesTxqQueue = 576*8/*4608*/;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesProtectionLoc = _8K;

        dxDevPtr->port.portMibCounters64Bits = GT_TRUE;

        if(PRV_CPSS_PP_MAC(devNum)->isGmDevice)
        {
            /* GM currently not support it */
            dxDevPtr->port.portMibCounters64Bits = GT_FALSE;
        }

        if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            /* The GM not support the DFX */
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cnc.cncUploadUseDfxUnit = GT_TRUE;
        }

    }
    else
    {
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort  = 8;
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).ePort    = 13;
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).sstId    = 12;

        dxDevPtr->hwInfo.trafficManager.supported = GT_TRUE;

        if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
        {
            /*indication that LMS unit is not supported.(need to use SMI unit,LED unit)*/
            dxDevPtr->hwInfo.gop_lms.notSupported = GT_TRUE;
        }

        if(PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
        {
            /*indication about single instance of TAI */
            dxDevPtr->hwInfo.gop_tai.supportSingleInstance = GT_TRUE;
            /*indication that no support for ILKN */
            dxDevPtr->hwInfo.gop_ilkn.supported = GT_FALSE;

            /* support 128 physical ports */
            PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort = 7;
            PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).stgId   = 10;

            /* resources that are lower than the 'flex bits' */
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).ePort = _6K;/*6144*/

            if (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_AC3X_E)
            {
                if(devPtr->devType == CPSS_98DX3265_CNS || devPtr->devType == CPSS_98DX3268_CNS)
                {
                    PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid   = _4K + 512;/*_4.5K = 4608 */
                }
                else
                {
                    PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid   = _4K;/* 4096 */
                }
            }
            else
            {
                PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid   = _4K + 512;/*_4.5K = 4608 */
            }

            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).l2LttMll = _8K;

            dxDevPtr->hwInfo.tcam.numBanksForHitNumGranularity = 6;

            if(PRV_CPSS_SIP_5_16_CHECK_MAC(devNum))
            {
                /* Aldrin */
                dxDevPtr->hwInfo.tcam.maxFloors = 3;
            }
            else
            {
                dxDevPtr->hwInfo.tcam.maxFloors = 6;
            }

            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL2Ecmp  = _4K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL3Ecmp  = _4K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIpNh    = _8K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMllLtt  = _8K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMllPairs = _4K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIplrMetering = _6K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesEplrMetering = _4K;
        }
        else
        {
            dxDevPtr->hwInfo.gop_ilkn.supported = GT_TRUE;
        }

    }

    if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
    {
        /* the bobcat2 hold sub families */
        if(devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
        {
            switch(devPtr->devType)
            {
                case CPSS_BOBK_CETUS_DEVICES_CASES_MAC:
                    isBobkCetus = 1;
                    break;
                default:
                    isBobkCetus = 0;
                    break;
            }

            if (isBobkCetus)
            {
                dxDevPtr->hwInfo.lpm.numOfLinesInBlock = _2K;
            }
            else
            {
                dxDevPtr->hwInfo.lpm.numOfLinesInBlock = _6K;
            }


            if(!PRV_CPSS_PP_MAC(devNum)->isGmDevice)
            {
                /* the GM supports single Data path : single RxDma , TxDma (TxFifo is not emulated anyway) */
                dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 1;
                dxDevPtr->hwInfo.multiDataPath.rxNumPortsPerDp = 73;
                dxDevPtr->hwInfo.multiDataPath.txNumPortsPerDp = 74;
                dxDevPtr->hwInfo.multiDataPath.maxDp = 2;
                dxDevPtr->hwInfo.multiDataPath.numTxqDq = 1;
            }

            dxDevPtr->hwInfo.multiDataPath.info[0].dataPathFirstPort  = 0;/*first port*/
            dxDevPtr->hwInfo.multiDataPath.info[0].dataPathNumOfPorts = 48;/* 48 GE ports */
            dxDevPtr->hwInfo.multiDataPath.info[1].dataPathFirstPort  = 56;/*first port*/
            dxDevPtr->hwInfo.multiDataPath.info[1].dataPathNumOfPorts = 16 + 2;/* the CPU,TM */
            dxDevPtr->hwInfo.multiDataPath.info[1].cpuPortDmaNum = 72;
            dxDevPtr->hwInfo.multiDataPath.info[1].tmDmaNum      = 73;
            if (isBobkCetus) /* also for GM distinguish */
            {
                dxDevPtr->hwInfo.multiDataPath.info[0].dataPathNumOfPorts = 0;/* no lower 48 ports */
            }
        }
        else
        if (dxDevPtr->genInfo.devType == CPSS_98DX4253_CNS)
        {
            /* CPSS_98DX4253_CNS Bobcat2 Carrier Small Scale*/
            /* resources that are lower than the 'flex bits' */
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).ePort = _6K;/*6144*/
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid   = _4K + 512;/*_4.5K = 4608 */

            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).l2LttMll = _8K;
            dxDevPtr->hwInfo.gop_ilkn.supported = GT_FALSE;
        }
    }
    else if((devPtr->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E) ||
            (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_AC3X_E))
    {
        dxDevPtr->hwInfo.lpm.numOfLinesInBlock = _2K;
        switch(devPtr->devType) {

            case CPSS_98DXH831_CNS:
            case CPSS_98DXH832_CNS:
            case CPSS_98DXH833_CNS:
            case CPSS_98DXH834_CNS:
            case CPSS_98DXH835_CNS:
            case CPSS_98DXZ832_CNS:
                dxDevPtr->hwInfo.lpm.numOfLinesInBlock = _1K;
                break;

            case CPSS_98DX3255_CNS:
            case CPSS_98DX3256_CNS:
            case CPSS_98DX3257_CNS:
            case CPSS_98DX3258_CNS:
            case CPSS_98DX3259_CNS:
                dxDevPtr->hwInfo.lpm.numOfLinesInBlock = 1664;
                break;

            default:
                break;
        }

        dxDevPtr->hwInfo.trafficManager.supported = GT_FALSE;

        if(!PRV_CPSS_PP_MAC(devNum)->isGmDevice)
        {
            /* the GM supports single Data path : single RxDma , TxDma (TxFifo is not emulated anyway) */
            dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 1;
            dxDevPtr->hwInfo.multiDataPath.rxNumPortsPerDp = 12;
            dxDevPtr->hwInfo.multiDataPath.txNumPortsPerDp = 12;
            dxDevPtr->hwInfo.multiDataPath.maxDp = 3;
            dxDevPtr->hwInfo.multiDataPath.numTxqDq = 1;
            dxDevPtr->hwInfo.multiDataPath.supportRelativePortNum = 1;
        }

        dxDevPtr->hwInfo.multiDataPath.info[0].dataPathFirstPort  = 0;
        dxDevPtr->hwInfo.multiDataPath.info[0].dataPathNumOfPorts = 12;
        dxDevPtr->hwInfo.multiDataPath.info[0].localDmaMapArr = aldrinLocalDma_dp_0_1_Arr;
        dxDevPtr->hwInfo.multiDataPath.info[1].dataPathFirstPort  = 12;
        dxDevPtr->hwInfo.multiDataPath.info[1].dataPathNumOfPorts = 12;
        dxDevPtr->hwInfo.multiDataPath.info[1].localDmaMapArr = aldrinLocalDma_dp_0_1_Arr;
        dxDevPtr->hwInfo.multiDataPath.info[2].dataPathFirstPort  = 24;
        dxDevPtr->hwInfo.multiDataPath.info[2].dataPathNumOfPorts = 10;
        dxDevPtr->hwInfo.multiDataPath.info[2].localDmaMapArr = aldrinLocalDma_dp_2_Arr;
        dxDevPtr->hwInfo.multiDataPath.info[2].cpuPortDmaNum = 72;
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
    {
        if(PRV_CPSS_PP_MAC(devNum)->isGmDevice)
        {
            /* the GM NOT supports multi data path */
            debug_force_numOfDp_set(1);
            /* the GM supports single pipe */
            debug_force_numOfPipes_set(1);
        }

        dxDevPtr->hwInfo.cpuPortInfo.info[0].usedAsCpuPort = GT_FALSE;/* the 'port mapping' should bind it */
        dxDevPtr->hwInfo.cpuPortInfo.info[0].dmaNum = 74;
        dxDevPtr->hwInfo.cpuPortInfo.info[0].dqNum = 0;
        dxDevPtr->hwInfo.cpuPortInfo.info[1].dmaNum = 75;
        dxDevPtr->hwInfo.cpuPortInfo.info[1].dqNum = 1;
        dxDevPtr->hwInfo.cpuPortInfo.info[2].dmaNum = 76;
        dxDevPtr->hwInfo.cpuPortInfo.info[2].dqNum = 3;
        dxDevPtr->hwInfo.cpuPortInfo.info[3].dmaNum = 77;
        dxDevPtr->hwInfo.cpuPortInfo.info[3].dqNum = 4;
        for (ii = 0; ii < CPSS_4_SDMA_CPU_PORTS_CNS; ii ++)
        {
              dxDevPtr->hwInfo.cpuPortInfo.info[ii].valid = GT_TRUE;
        }

        devPtr->multiPipe.numOfPipes = 2;
        if(DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfPipes))
        {
            devPtr->multiPipe.numOfPipes = DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfPipes);
        }
        /* number of GOP ports per pipe , NOT including the 'CPU Port' . */
        devPtr->multiPipe.numOfPortsPerPipe = 12 * 3;/* 3 DP[] per pipe */


        if(devPtr->multiPipe.numOfPipes >= 2)
        {
            /* for  Bobcat3 the function prvCpssNonMultiPortGroupsDeviceSet was
               called because the device hold single 'PEX address' for accessing to it
               ('cpssDrv' point of view) :
            */
            devPtr->portGroupsInfo.activePortGroupsBmp        = BIT_MASK_0_31_MAC(devPtr->multiPipe.numOfPipes);
            devPtr->portGroupsInfo.firstActivePortGroup       = CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS;
            devPtr->portGroupsInfo.lastActivePortGroup        = CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS + devPtr->multiPipe.numOfPipes - 1;
            devPtr->portGroupsInfo.isMultiPortGroupDevice     = GT_TRUE;
            devPtr->portGroupsInfo.numOfPortGroups            = devPtr->multiPipe.numOfPipes;

            /* this needed to allow code to do :
                PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC
                and
                PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC
            */
        }

        dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 1;
        dxDevPtr->hwInfo.multiDataPath.rxNumPortsPerDp = 13;
        dxDevPtr->hwInfo.multiDataPath.txNumPortsPerDp = 13;
        dxDevPtr->hwInfo.multiDataPath.maxDp = 6;
        dxDevPtr->hwInfo.multiDataPath.numTxqDq = 6;/* there is TXQ,dq per 'data path' */
        dxDevPtr->hwInfo.multiDataPath.txqDqNumPortsPerDp = 96;
        dxDevPtr->hwInfo.multiDataPath.supportRelativePortNum = 1;

        if(DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfDp))
        {
            dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 0;
            dxDevPtr->hwInfo.multiDataPath.maxDp = DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfDp);
            dxDevPtr->hwInfo.multiDataPath.numTxqDq = DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfDp);
        }

        for(ii = 0 ; ii < dxDevPtr->hwInfo.multiDataPath.maxDp ; ii++)
        {
            dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathFirstPort  = ii*12;
            dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathNumOfPorts = 12 + 1;/* support CPU port*/
            dxDevPtr->hwInfo.multiDataPath.info[ii].cpuPortDmaNum = 12;
        }

        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesTunnelStart = _64K;/* used only by ENTRY_TYPE_TUNNEL_START_E */

        switch(dxDevPtr->genInfo.devType)
        {
            case CPSS_98EX5410_CNS:   /*Armstrong*/
            case CPSS_98EX5420_CNS:   /*Armstrong*/
            case CPSS_98EX5421_CNS:   /*Armstrong*/
            case CPSS_98EX5422_CNS:   /*Armstrong*/
                /* we not have fine tuning for those values , so use 'limited resource' */
                PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).ePort = _8K;
                PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid   = _6K;

                /* support 512 ports mode that entry is split on 2 halfs of the table */
                /* set 8K although the (8K/2) + (6K/2) = 7K is enough                 */
                /* NOTE: the vlan APIs are not subject to this number , but check :
                   PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid = _6K */
                PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesVlanMembers = _8K;
                break;
            default:
                break;
        }
    }

    if(PRV_CPSS_SIP_5_25_CHECK_MAC(devNum))
    {
        dxDevPtr->hwInfo.tcam.numBanksForHitNumGranularity =  6;
        dxDevPtr->hwInfo.tcam.maxFloors = 6;

        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort  = 7;
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).ePort    = 13;

        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMllLtt  = _16K;/*32K in BC3*/
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMllPairs = _8K; /*16K in BC3*/
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIplrMetering = _8K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesEplrMetering = _8K;

        /* we not have fine tuning for those values , so use 'limited resource' */
        PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).ePort = _8K;

        dxDevPtr->hwInfo.lpm.numOfLinesInBlock = _8K;/*half the 'max' size (half from BC3)*/
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        dxDevPtr->hwInfo.tti.numDefaultEports = _1K;

        dxDevPtr->hwInfo.tcam.numBanksForHitNumGranularity =  2;
        dxDevPtr->hwInfo.tcam.maxFloors = 6;

        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass = GT_TRUE;

        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIplrMetering = _4K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesEplrMetering = _4K;

        /* falcon support up to 1024 ports*/
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort  = 10;

        /* Port Default Source ePort, ECMP entry holds 13 bits for ePort */
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).ePort = 13;

        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesProtectionLoc = _1K;

        /* actual 11 bits but one of them used internally by the CPSS for the 'multi-core FDB aging'.
           other 10 bits to support 'physical port number 0..1023' */
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).fdbUserDefined = 10;

        /* !!! there is NO TXQ-dq in Falcon !!! */
        dxDevPtr->hwInfo.multiDataPath.numTxqDq = 0;
        dxDevPtr->hwInfo.multiDataPath.txqDqNumPortsPerDp = 0;
        dxDevPtr->hwInfo.multiDataPath.supportRelativePortNum = 1;
        /* currently this parameter used only for TXQ-DQ number of entries .
           so TBD value when needed */
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesTxqQueue = 0;
    }

    /* in legacy devices (before sip6_10) the IPFix used with same counting (1:1 with metering) index   */
    /* but in sip6_10 the ipfix gets it's own indexing (desc->flowId) (still in the counting table) but with larger scale */
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIplrIpfix =
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIplrMetering;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesEplrIpfix =
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesEplrMetering;

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        dxDevPtr->hwInfo.tti.numDefaultEports = 128;
        /* hawk support only 128 ports */
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort  = 7;
        /* hawk support 12K vidx entries */
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).vidx     = 14;
        PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vidx           = _12K;

        /* hawk support the 3 IPCL !!! (Falcon only 2) */
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass = GT_FALSE;

        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL2Ecmp  = _8K;       /* Falcon 16K*/
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesProtectionLoc = _2K; /* Falcon 1K */
        /* need to align to : routerNextHop */
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIpNh    = _16K;      /* Falcon 24K*/

        /* in sip6_10 the ipfix hold dedicated enabler and index (desc->ipfixEn + desc->flowId) from the IPCL/TTI action */
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIplrIpfix = _64K;    /* Falcon 4K */
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesEplrIpfix = _64K;    /* Falcon 4K */
    }

    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass == GT_TRUE)
    {
        /* the IPCL0 is not valid to use */
        dxDevPtr->hwInfo.tcam.maxClientGroups --;/* 4 instead of 5 */
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* give default . the Ironman will override this value to '8' */
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.preqInfo.portMappingNum = 128;
    }

    if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->port.numLanesPerPort = 4;
        dxDevPtr->hwInfo.cpuPortInfo.info[0].usedAsCpuPort = GT_FALSE;/* the 'port mapping' should bind it */
        dxDevPtr->hwInfo.cpuPortInfo.info[0].dmaNum = 74;
        dxDevPtr->hwInfo.cpuPortInfo.info[0].dqNum = 3;
        dxDevPtr->hwInfo.cpuPortInfo.info[1].dmaNum = 75;
        dxDevPtr->hwInfo.cpuPortInfo.info[1].dqNum = 1;
        dxDevPtr->hwInfo.cpuPortInfo.info[2].dmaNum = 76;
        dxDevPtr->hwInfo.cpuPortInfo.info[2].dqNum = 2;
        dxDevPtr->hwInfo.cpuPortInfo.info[3].dmaNum = 77;
        dxDevPtr->hwInfo.cpuPortInfo.info[3].dqNum = 0;
        for (ii = 0; ii < CPSS_4_SDMA_CPU_PORTS_CNS; ii ++)
        {
            dxDevPtr->hwInfo.cpuPortInfo.info[ii].valid = GT_TRUE;
        }

        dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 1;
        dxDevPtr->hwInfo.multiDataPath.rxNumPortsPerDp = 25;
        dxDevPtr->hwInfo.multiDataPath.txNumPortsPerDp = 25;
        dxDevPtr->hwInfo.multiDataPath.maxDp = 4;
        dxDevPtr->hwInfo.multiDataPath.numTxqDq = 4;/* there is TXQ,dq per 'data path' */
        dxDevPtr->hwInfo.multiDataPath.txqDqNumPortsPerDp = 25;
        dxDevPtr->hwInfo.multiDataPath.supportRelativePortNum = 1;

        ii = 0;
        dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathFirstPort  = 0;
        dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathNumOfPorts = 12;/*+CPU SDMA+CPU ETH*/
        dxDevPtr->hwInfo.multiDataPath.info[ii].cpuPortDmaNum      = 23;/*CPU SDMA*/
        ii++;
        dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathFirstPort  = 12;
        dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathNumOfPorts = 12;/*+CPU SDMA*/
        dxDevPtr->hwInfo.multiDataPath.info[ii].cpuPortDmaNum      = 24;/*CPU SDMA*/
        ii++;
        dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathFirstPort  = 24;
        dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathNumOfPorts = 24;/*+CPU SDMA*/
        dxDevPtr->hwInfo.multiDataPath.info[ii].cpuPortDmaNum      = 24;/*CPU SDMA*/
        ii++;
        dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathFirstPort  = 48;
        dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathNumOfPorts = 24;/*+CPU SDMA*/
        dxDevPtr->hwInfo.multiDataPath.info[ii].cpuPortDmaNum      = 24;/*CPU SDMA*/

        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesTxqQueue = 100*8/*800*/;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesTunnelStart = _16K;/* used only by ENTRY_TYPE_TUNNEL_START_E */
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
    {
        if(PRV_CPSS_PP_MAC(devNum)->isGmDevice)
        {
            /* the GM NOT supports multi data path */
            debug_force_numOfDp_set(1);
            /* the GM supports single pipe */
            debug_force_numOfPipes_set(1);
        }
        /****************************************************/
        /* call to init DB with first info about the device */
        /****************************************************/
        rc = prvCpssFalconInitParamsSet(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfPipes))
        {
            devPtr->multiPipe.numOfPipes = DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfPipes);
        }

        if(devPtr->multiPipe.numOfPipes >= 2)
        {
            /* for  Bobcat3 the function prvCpssNonMultiPortGroupsDeviceSet was
               called because the device hold single 'PEX address' for accessing to it
               ('cpssDrv' point of view) :
            */
            devPtr->portGroupsInfo.activePortGroupsBmp        = BIT_MASK_0_31_MAC(devPtr->multiPipe.numOfPipes);
            devPtr->portGroupsInfo.firstActivePortGroup       = CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS;
            devPtr->portGroupsInfo.lastActivePortGroup        = CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS + devPtr->multiPipe.numOfPipes - 1;
            devPtr->portGroupsInfo.isMultiPortGroupDevice     = GT_TRUE;
            devPtr->portGroupsInfo.numOfPortGroups            = devPtr->multiPipe.numOfPipes;

            /* this needed to allow code to do :
                PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC
                and
                PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC
            */
        }

        dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 1;
        dxDevPtr->hwInfo.multiDataPath.rxNumPortsPerDp = FALCON_PORTS_PER_DP_CNS+1;
        dxDevPtr->hwInfo.multiDataPath.txNumPortsPerDp = FALCON_PORTS_PER_DP_CNS+1;

        if(DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfDp))
        {
            dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 0;
            dxDevPtr->hwInfo.multiDataPath.maxDp = DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfDp);
        }
        /* Falcon has 1K OAM entries per control pipe */
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesOam     = _1K;

        prvCpssDxChFalconRavenBitmapSet(devNum);
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E)
    {
        rc = init_phyPortInfoArray(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }

        /****************************************************/
        /* call to init DB with first info about the device */
        /****************************************************/
        rc = prvCpssHawkInitParamsSet(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }

        dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 1;
        dxDevPtr->hwInfo.multiDataPath.rxNumPortsPerDp = HAWK_PORTS_PER_DP_CNS+1;
        dxDevPtr->hwInfo.multiDataPath.txNumPortsPerDp = HAWK_PORTS_PER_DP_CNS+1;

        if(DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfDp))
        {
            dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 0;
            dxDevPtr->hwInfo.multiDataPath.maxDp = DXCH_HWINIT_GLOVAR(dxChHwInitSrc.debug_force_numOfDp);
        }
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E)
    {
        /****************************************************/
        /* call to init DB with first info about the device */
        /****************************************************/
        rc = prvCpssPhoenixInitParamsSet(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_HARRIER_E)
    {
        rc = init_phyPortInfoArray(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
        /****************************************************/
        /* call to init DB with first info about the device */
        /****************************************************/
        rc = prvCpssHarrierInitParamsSet(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_IRONMAN_E)
    {
        rc = init_phyPortInfoArray(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
        /****************************************************/
        /* call to init DB with first info about the device */
        /****************************************************/
        rc = prvCpssIronmanInitParamsSet(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* set hwInfo.parametericTables.numEntriesVlanMembers according to the
       number of HW entries that is not manipulated like PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid
       later by the 'physical port mode' (BC3: 256/512 , Falcon : 64/128/256/512/1024) */
    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesVlanMembers == 0)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesVlanMembers =
            1 + PRV_CPSS_DXCH_PP_HW_INFO_RESOURCE_MAX_VALUE_GET_MAC(devNum,vid);
    }

    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesStgMembers == 0)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesStgMembers =
            1 + PRV_CPSS_DXCH_PP_HW_INFO_RESOURCE_MAX_VALUE_GET_MAC(devNum,stgId);
    }

    if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesSrcIdMembers == 0)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesSrcIdMembers = 1 + PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_SRC_ID_MAC(devNum);
    }

    if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesNonTrunkMembers == 0)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesNonTrunkMembers = 1 + PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum);
    }

    return GT_OK;
}

/**
* @internal setSip6FlexInfo function
* @endinternal
*
* @brief   set sip6 flex parameters.
*
* @param[in] devNum                   -  the device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS setSip6FlexInfo
(
    IN GT_U8    devNum
)
{
    return setSip5FlexInfo(devNum);
}
/**
* @internal baseCoreClockSet function
* @endinternal
*
* @brief   set 'baseCoreClock' : base core clock parameter.
*
* @param[in] devNum                   -  the device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS baseCoreClockSet
(
    IN GT_U8    devNum
)
{
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = PRV_CPSS_PP_MAC(devNum);

    if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        devPtr->baseCoreClock   = 360;
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E ||
            PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        devPtr->baseCoreClock   = 480;
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal initEgfForceStatusBitMap function
* @endinternal
*
* @brief   initialize portEgfForceStatusBitmapPtr
*
* @param[in] devNum                   -  the device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS initEgfForceStatusBitMap
(
    IN GT_U8 devNum
)
{
    /* init Egf force status */
    if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        GT_U32  port;

        if (PRV_CPSS_PP_MAC(devNum)->portEgfForceStatusBitmapPtr == NULL)
        {
            PRV_CPSS_PP_MAC(devNum)->portEgfForceStatusBitmapPtr = (CPSS_PORTS_BMP_STC *)cpssOsMalloc
                (sizeof(CPSS_PORTS_BMP_STC));
        }
        if (PRV_CPSS_PP_MAC(devNum)->portEgfForceStatusBitmapPtr == NULL)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, "portEgfForceStatusBitmap allocation failed");
        }
        for (port = 0; port < CPSS_MAX_PORTS_NUM_CNS; port++)
        {
            /* init the whole bitmap to same value */
            CPSS_PORTS_BMP_PORT_CLEAR_MAC(PRV_CPSS_PP_MAC(devNum)->portEgfForceStatusBitmapPtr, port);
        }
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, "Egf force status bitmap relevant for sip_5_20 devices");
    }

    return GT_OK;
}

/**
* @internal initPortTypeArray function
* @endinternal
*
* @brief   initialize phyPortInfoArray[]
*
* @param[in] devNum                   -  the device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS initPortTypeArray
(
    IN GT_U8    devNum
)
{
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = PRV_CPSS_PP_MAC(devNum);
    GT_U32  port, numRegularPorts;
    GT_U32  stackPortsMode = 0;
    GT_U32  localPortIndex = 0;
    GT_STATUS   rc;

    rc = init_phyPortInfoArray(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }

    if (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E)
    {
        /* get the stacking ports mode*/
        if (prvCpssHwPpGetRegField(devNum,0x00000028,26,4,&stackPortsMode) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    /* init The port info struct to all ports */
    for (port = 0; port < devPtr->numOfPorts; port++)
    {
        if(!CPSS_PORTS_BMP_IS_PORT_SET_MAC(&devPtr->existingPorts , port))
        {
            /* set the non-exists ports*/
            devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_NOT_EXISTS_E;
            devPtr->phyPortInfoArray[port].portIfMode = CPSS_PORT_INTERFACE_MODE_NA_E;
            devPtr->phyPortInfoArray[port].portSpeed = CPSS_PORT_SPEED_NA_E;
                continue;
        }
        devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_GE_E;
        devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_GE_PORT_GE_ONLY_E;
        devPtr->phyPortInfoArray[port].vctLengthOffset = 0;
        devPtr->phyPortInfoArray[port].portIfMode = CPSS_PORT_INTERFACE_MODE_NA_E;
        devPtr->phyPortInfoArray[port].portSpeed = CPSS_PORT_SPEED_NA_E;

        devPtr->phyPortInfoArray[port].portRefClock.enableOverride = GT_FALSE;
        devPtr->phyPortInfoArray[port].portRefClock.portRefClockSource = CPSS_PORT_REF_CLOCK_SOURCE_LAST_E;
        devPtr->phyPortInfoArray[port].portLedInfo.ledPosition = 0x3F;

        /* initializing port SMI and PHY address DB to indicate that these parameters have */
        /* not been set yet. */
        PRV_CPSS_PHY_SMI_PORT_ADDR_MAC(devNum,port)     = PRV_CPSS_PHY_SMI_NO_PORT_ADDR_CNS;
        PRV_CPSS_PHY_SMI_INSTANCE_MAC(devNum,port)      = PRV_CPSS_PHY_INVALID_SMI_INSTANCE_CNS;

        /* initializing the SMI interfaces to relevant port group */
        /* Each port's PHY is access by its associated port group's SMI*/
        PRV_CPSS_PHY_SMI_GROUP_PORT_MAC(devNum,port)=
            PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, port);

        if (port < 24 &&
            devPtr->devFamily != CPSS_PP_FAMILY_DXCH_LION2_E &&
            (0 == PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
        {
            devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_GE_E;
        }
        else
        {
           devPtr->phyPortInfoArray[port].portType =        PRV_CPSS_PORT_XG_E;
           devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_XG_ONLY_E;

            if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum)||
               (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E))
            {
                devPtr->phyPortInfoArray[port].portTypeOptions =
                    (PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum)) ?
                        PRV_CPSS_XG_PORT_XLG_SGMII_E : PRV_CPSS_XG_PORT_CG_SGMII_E;
                devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;
            }
            else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
            {
                if(devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_NONE_E)
                {
                    if(port < 48)
                    {
                        devPtr->phyPortInfoArray[port].portType        = PRV_CPSS_PORT_GE_E;
                        devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_GE_PORT_GE_ONLY_E;
                        devPtr->phyPortInfoArray[port].isFlexLink = GT_FALSE;
                    }
                    else
                    {
                        devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;
                        devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;
                    }
                }
                else if(devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
                {
                    if((port < 48) || (port == 62))
                    {
                        devPtr->phyPortInfoArray[port].portType        = PRV_CPSS_PORT_GE_E;
                        devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_GE_PORT_GE_ONLY_E;
                        devPtr->phyPortInfoArray[port].isFlexLink = GT_FALSE;
                    }
                    else
                    {
                        devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;
                        devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;
                    }
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }
            }
            else if((devPtr->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E) ||
                    (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_AC3X_E))
            {
                if (port == 32)
                {
                    devPtr->phyPortInfoArray[port].portType        = PRV_CPSS_PORT_GE_E;
                    devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_GE_PORT_GE_ONLY_E;
                    devPtr->phyPortInfoArray[port].isFlexLink = GT_FALSE;
                }
                else
                {
                    devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_XLG_SGMII_E;
                    devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;
                }
            }
            else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
            {
                if (0 == (port %4) && port < 72)
                {
                    devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;
                }
                else
                {
                    devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_XLG_SGMII_E;
                }
                devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;
            }
            else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)
            {
                if (0 == (port %4) && port < 24)/* 6 ports of 100G */
                {
                    devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;
                }
                else
                {
                    devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_XLG_SGMII_E;
                }
                devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;
            }
            else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
            {

                CPSS_TBD_BOOKMARK_FALCON
                /* Port type options field should be updated to the relevant one */

                /* Falcon as 3.2 Tera device */
                if (0 == (port %4) && port < 64)
                {
                    devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;
                }
                else
                {
                    devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_XLG_SGMII_E;
                }
                devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;

                numRegularPorts = PRV_CPSS_DXCH_PP_MAC(devNum)->port.numRegularPorts;
                if(port < numRegularPorts)
                {
                    devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_MTI_100_E;
                }
                else
                {
                    devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_MTI_CPU_E;
                }
            }
            else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E)
            {
                if(port < (devPtr->numOfPorts - 1))
                {
                    localPortIndex = (port % 26);
                    if((localPortIndex == 3) || (localPortIndex == 4) || (localPortIndex == 5) ||
                       (localPortIndex == 7) || (localPortIndex == 8) || (localPortIndex == 9) ||

                       (localPortIndex == 11) || (localPortIndex == 12) || (localPortIndex == 13) ||
                       (localPortIndex == 15) || (localPortIndex == 16) || (localPortIndex == 17) ||

                       (localPortIndex == 19) || (localPortIndex == 20) || (localPortIndex == 21) ||
                       (localPortIndex == 23) || (localPortIndex == 24) || (localPortIndex == 25))
                    {
                        devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_MTI_USX_E;
                    }
                    else
                    {
                        devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_MTI_100_E;
                    }
                }
                else /* last port is 'CPU port' */
                {
                    devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_MTI_CPU_E;
                }

                devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;/* is it needed ??? */
            }
            else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E)
            {
                if(port < 48)
                {
                    devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_MTI_USX_E;
                }
                else if(port < 50)
                {
                    devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_MTI_CPU_E;
                }
                else
                {
                    devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_MTI_100_E;
                }
                devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;/* is it needed ??? */
            }
            else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_HARRIER_E)
            {
                devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_MTI_100_E;
                devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;/* is it needed ??? */
            }
            else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_IRONMAN_E)
            {
                devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_MTI_USX_E;
                devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;/* is it needed ??? */
            }
        }/*end of port >= 24 || lion ports */
    }

    return GT_OK;
}
/**
* @internal initPortMibShadow function
* @endinternal
*
* @brief   initialize portsMibShadowArr[]
*
* @param[in] devNum                   -  the device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS initPortMibShadow
(
    IN GT_U8    devNum
)
{
    PRV_CPSS_DXCH_PP_CONFIG_STC *dxDevPtr = PRV_CPSS_DXCH_PP_MAC(devNum);
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = &dxDevPtr->genInfo;
    GT_U32  port;

    if (devPtr->devFamily != CPSS_PP_FAMILY_DXCH_LION2_E &&
        (!PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum)) &&
        (0 == PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
    {
        /* not needed */
        return GT_OK;
    }

    for (port = 0; port < devPtr->numOfPorts; port++)
    {
        if(!CPSS_PORTS_BMP_IS_PORT_SET_MAC(&devPtr->existingPorts , port))
        {
            /* skip the non-exists ports*/
            continue;
        }

        /* allocate the memory for the MIB shadow */
        PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMibShadowArr[port] =
            cpssOsMalloc(sizeof(PRV_CPSS_DXCH_PORT_XLG_MIB_SHADOW_STC));

        if(PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMibShadowArr[port] == NULL)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }
        cpssOsMemSet(PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMibShadowArr[port],
                     0,sizeof(PRV_CPSS_DXCH_PORT_XLG_MIB_SHADOW_STC));

        /* set "clear on read" for XGL MAC counters default to true */
        PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMibShadowArr[port]->clearOnReadEnable = GT_TRUE;
    }

    return GT_OK;
}

/**
* @internal setCncParameters function
* @endinternal
*
* @brief   initialize cnc parameters
*
* @param[in] devNum                   -  the device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS setCncParameters
(
    IN GT_U8    devNum
)
{
    PRV_CPSS_DXCH_PP_CONFIG_STC *dxDevPtr = PRV_CPSS_DXCH_PP_MAC(devNum);
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = &dxDevPtr->genInfo;

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        if(!PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits = 2;
        }
        else
        {
            /* was already set 1 or 2 or 4 ...*/
        }

        if(!PRV_CPSS_SIP_6_30_CHECK_MAC(devNum))
        {
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 16;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = _1K;
        }
        else
        {
            /* give defaults only if not set before */
            if(PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks == 0)
            {
                PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 16;
            }
            if(PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries == 0)
            {
                PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = _1K;
            }
        }

        return GT_OK;
    }

        /* CNC parameter initialization */
    switch (devPtr->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_LION2_E:
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits = 1;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 8;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = 512;
            break;

        case CPSS_PP_FAMILY_DXCH_XCAT3_E:
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits = 1;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 2;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = _2K;
        break;

        case CPSS_PP_FAMILY_DXCH_AC5_E:
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits  = 2;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 2;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = _2K;
        break;

        default:
            /* the device not supports CNC */
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits = 0;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 0;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = 0;
            break;
    }

    return GT_OK;
}

/**
* @internal initRegAddrDb function
* @endinternal
*
* @brief   initialize the DB of 'register address'
*
* @param[in] devNum                   -  the device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS initRegAddrDb
(
    IN GT_U8    devNum
)
{
    GT_STATUS   rc;
    PRV_CPSS_DXCH_PP_CONFIG_STC *dxDevPtr = PRV_CPSS_DXCH_PP_MAC(devNum);
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = &dxDevPtr->genInfo;

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
         return prvCpssDxChBobcat2HwRegAddrInit(devNum);
    }
    /* allocate and fill the values of the registers addresses of the device */
        /* init the registers addresses inside
            PRV_CPSS_EXMX_DEV_REGS_MAC(devNum) and get the number of
           virtual ports */
    switch (devPtr->devFamily)
    {

        case CPSS_PP_FAMILY_DXCH_LION2_E:
            /* this code call to Lion2 specific function */
             rc = prvCpssDxChLion2HwRegAddrInit(devNum);
             if(rc != GT_OK)
             {
                 return rc;
             }
             break;/* end Lion2 */

        case PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_CASES_MAC:
             /* this code call to xCat3 specific function */
             rc = prvCpssDxChXcat3HwRegAddrInit(devNum);
             if(rc != GT_OK)
             {
                 return rc;
             }
             break;/* end xcat3 */

        default:
            /* we may get here due to improper compilation flag used ! */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_DEVICE_FAMILY_NOT_SUPPORTED_CNS, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal checkMultiPortGroupIndication function
* @endinternal
*
* @brief   For Multi-Group devices check that correct base address per port group as configured.
*
* @param[in] devNum                   -  the device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*
* @note relevant to multi-core device
*
*/
static GT_STATUS checkMultiPortGroupIndication
(
    IN GT_U8    devNum,
    IN GT_BOOL  pciCompatible,
    IN PRV_CPSS_DRV_PP_PHASE_1_INPUT_INFO_STC  *drvPpPhase1InInfoPtr
)
{
    GT_STATUS           rc;
    GT_U32              portGroupId;/*iterator for port group Id*/
    GT_U32              startBit = 9;
    GT_U32              pgNumOfBits; /* number of bits for Port Group Id */
    GT_U32              port;

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        pgNumOfBits = pciCompatible ? 3 : 5;
    }
    else
    {
        pgNumOfBits = 2;
    }

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    {
        /* The 2 LSbs - bits [10:9] - of field <DevicePhy Addr> - bits [13:9] */
        /* are the port group number.                                         */
        rc = prvCpssDrvHwPpPortGroupGetRegField(devNum, portGroupId,
                                                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                                    globalRegs.globalControl,
                                                startBit, pgNumOfBits, &port);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(pciCompatible)
        {
            if( port != portGroupId )
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }
        else
        {/* for SMI devices value of PHY address field must be equal to address,
            where SMI scan found current port group */
            if(port != drvPpPhase1InInfoPtr->hwInfo[portGroupId].hwAddr.devSel)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

    return GT_OK;
}

/**
* @internal prvCpssDxChHwRegAddrDbRemove function
* @endinternal
*
* @brief   remove the DB of 'register address'
*
* @param[in] devNum                   -  the device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
GT_STATUS prvCpssDxChHwRegAddrDbRemove
(
    IN GT_U8    devNum
)
{
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
         return prvCpssDxChLion2HwRegAddrRemove(devNum);
    }

    /* free the registers addresses memory */
    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_CASES_MAC:
            prvCpssDxChXcat3HwRegAddrRemove(devNum);
            break;
        case CPSS_PP_FAMILY_DXCH_LION2_E:
            prvCpssDxChLion2HwRegAddrRemove(devNum);
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_DEVICE_FAMILY_NOT_SUPPORTED_CNS, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal hwPpPhase1Part1_existingUnitsListAtMGInit function
* @endinternal
*
* @brief   For devices BobK-Cetus Aldrin init allowed unit map at MG
*         function called from the hwPpPhase1Part1() sequence.
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_SUPPORTED         - the device not supported by CPSS
* @retval GT_BAD_VALUE             - the driver found unknown device type
* @retval GT_NOT_IMPLEMENTED       - the CPSS was not compiled properly
*/
GT_STATUS hwPpPhase1Part1_existingUnitsListAtMGInit
(
    GT_U8 devNum
)
{
    #define BAD_VALUE (GT_U32)(~0)
    typedef struct
    {
        GT_U32 regAddr;
        GT_U32 value;
    }REGADDR_VALUE_STC;

    static const REGADDR_VALUE_STC cetus_MG_InitValue[] =
    {
         {      0xe4, 0xfb7fffff }
        ,{      0xe8, 0xffffff31 }
        ,{      0xec, 0xff3fffff }
        ,{ BAD_VALUE, 0      }
    };

    static const REGADDR_VALUE_STC aldrin_MG_InitValue[] =
    {
         { 0x000000e4 , 0x70fde87f }
        ,{ 0x000000e8 , 0xf820e0c7 }
        ,{ 0x000000ec , 0xff30ff81 }
        ,{ 0x000000f0 , 0x00000ffb }
        ,{ 0x000000f4 , 0x00000000 }
        ,{ 0x000000f8 , 0x00000000 }
        ,{ 0x000000fc , 0x00000000 }
        ,{ 0x00000100 , 0x00000000 }
        ,{  BAD_VALUE , 0     }
    };

    const REGADDR_VALUE_STC * writeListPtr; /* pointer to array of {address, data}*/
    GT_U32 i;
    GT_STATUS rc;

    writeListPtr = (REGADDR_VALUE_STC*)NULL;
    /*---------------------------------------*
     * select suitable list per device       *
     *---------------------------------------*/
    switch (PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
            if (PRV_CPSS_PP_MAC(devNum)->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
            {
                switch (PRV_CPSS_PP_MAC(devNum)->devType)
                {
                    case CPSS_BOBK_CETUS_DEVICES_CASES_MAC:
                        writeListPtr = &cetus_MG_InitValue[0];

                    break;

                    default:
                        break;
                }
            }
            break;

        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
        case CPSS_PP_FAMILY_DXCH_AC3X_E:
            writeListPtr = &aldrin_MG_InitValue[0];
            break;

        default:
            break;
    }
    /*---------------------------------------*
     * confugure MG unit                     *
     *---------------------------------------*/
    if (writeListPtr != NULL)
    {
        for (i = 0 ; writeListPtr[i].regAddr != BAD_VALUE; i++)
        {
            rc =  prvCpssHwPpWriteRegister(devNum,  writeListPtr[i].regAddr, writeListPtr[i].value);
            if(rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "hwPpPhase1Part1(..) : hwPpPhase1Part1_existingUnitsListAtMGInit()");
            }

        }
    }
    return GT_OK;
}

/**
* @internal prvCpssSip5ReadMbusMappingWindow function
* @endinternal
*
* @brief   Part of prvCpssCheckSip5Mappings
*         Read CPUx address mapping window
* @param[in] cnm                      - Control And Management base address
* @param[in] cpuConfBase              - CPU configuration base,
*                                      for CPU0: 0x20000
*                                      for CPU1: 0x24000
* @param[in] win                      - window number
*                                       None
*/
static void prvCpssSip5ReadMbusMappingWindow(
    IN  GT_UINTPTR          cnm,
    IN  GT_U32              cpuConfBase,
    IN  GT_U32              win,
    OUT GT_U32             *ctrlPtr,
    OUT GT_U32             *basePtr
)
{
    GT_U32 ctrlReg, ctrl, base;
    ctrlReg = cpuConfBase+0x0+0x10*win;
    if (win >= 8)
        ctrlReg = cpuConfBase+0x90+8*(win-8);
    ctrl = *((volatile GT_U32*)(cnm+(GT_UINTPTR)ctrlReg));
    base = *((volatile GT_U32*)(cnm+(GT_UINTPTR)(ctrlReg+4)));
    *ctrlPtr = CPSS_32BIT_LE(ctrl);
    *basePtr = CPSS_32BIT_LE(base);
}
/**
* @internal prvCpssCheckSip5MbusMappings function
* @endinternal
*
* @brief   Part of prvCpssCheckSip5Mappings
*         Check CPUx address mapping to be without overlaps
* @param[in] cnm                      - Control And Management base address
* @param[in] cpuConfBase              - CPU configuration base,
*                                      for CPU0: 0x20000
*                                      for CPU1: 0x24000
*                                       GT_OK, GT_FAIL
*/
static GT_STATUS prvCpssCheckSip5MbusMappings(
    IN  GT_UINTPTR          cnm,
    IN  GT_U32              cpuConfBase
)
{
    GT_U32 win, win1, ctrl, base, szMask, ctrl1, base1, szMask1;
    GT_BOOL overlapped = GT_FALSE;

    for (win = 0; win < 20; win++)
    {
        prvCpssSip5ReadMbusMappingWindow(cnm, cpuConfBase, win, &ctrl, &base);
        if ((ctrl & 1) == 0)
            continue; /* not enabled */
        base &= 0xffff0000;
        szMask = ctrl | 0x0000ffff;
        /* check szMask to be 2^n-1 */
        if (((szMask + 1) & szMask) != 0)
        {
            CPSS_LOG_INFORMATION_MAC("MBUS win %d szMask incorrect: 0x%x, must be 2^n-1", win, szMask);
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }
        /* check base to be size aligned */
        if ((base & szMask) != 0)
        {
            CPSS_LOG_INFORMATION_MAC("MBUS win %d base(0x%x) must be size(0x%x) aligned", win, base, szMask+1);
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }
        CPSS_LOG_INFORMATION_MAC("MBUS win %d base=0x%x size=0x%x target=0x%x:0x%x",
                win, base, szMask+1,
                (ctrl >> 4)&0x0f, (ctrl >> 8)&0x0ff);
        for (win1 = win+1; win1 < 20; win1++)
        {
            prvCpssSip5ReadMbusMappingWindow(cnm, cpuConfBase, win1, &ctrl1, &base1);
            if ((ctrl1 & 1) == 0)
                continue; /* not enabled */
            base1 &= 0xffff0000;
            szMask1 = ctrl1 | 0x0000ffff;
#define _INSIDE_RANGE(_base,_szMask,_addr) ((_base|_szMask) == ((_addr)|_szMask))
#define _CHECK_OVERLAP \
            if (_INSIDE_RANGE(base,szMask,base1)) \
                overlapped = GT_TRUE; \
            if (_INSIDE_RANGE(base,szMask,base1|szMask1)) \
                overlapped = GT_TRUE; \
            if (_INSIDE_RANGE(base1,szMask1,base)) \
                overlapped = GT_TRUE; \
            if (_INSIDE_RANGE(base1,szMask1,base|szMask)) \
                overlapped = GT_TRUE;
            _CHECK_OVERLAP;
            if (overlapped == GT_TRUE)
            {
                CPSS_LOG_INFORMATION_MAC("MBUS win %d overlaps with win %d", win, win1);
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
            }
        }
    }
    return GT_OK;
}

/**
* @internal prvCpssSip5ReadPexMappingWindow function
* @endinternal
*
* @brief   Part of prvCpssCheckSip5Mappings
*         Read PEX address mapping window
* @param[in] cnm                      - Control And Management base address
* @param[in] win                      - window number
*                                       None
*/
static void prvCpssSip5ReadPexMappingWindow(
    IN  GT_UINTPTR          cnm,
    IN  GT_U32              win,
    OUT GT_U32             *ctrlPtr,
    OUT GT_U32             *basePtr
)
{
    GT_U32 ctrlReg, ctrl, base;
    ctrlReg = 0x41820+0x10*win;
    if (win == 5)
        ctrlReg = 0x41880;
    if (win > 5)
        ctrlReg = 0x41c00+0x10*(win-6);
    ctrl = *((volatile GT_U32*)(cnm+(GT_UINTPTR)ctrlReg));
    base = *((volatile GT_U32*)(cnm+(GT_UINTPTR)(ctrlReg+4)));
    *ctrlPtr = CPSS_32BIT_LE(ctrl);
    *basePtr = CPSS_32BIT_LE(base);
}
/**
* @internal prvCpssCheckSip5PexMappings function
* @endinternal
*
* @brief   Part of prvCpssCheckSip5Mappings
*         Check PEX address mapping to be without overlaps
* @param[in] cnm                      - Control And Management base address
*                                       GT_OK, GT_FAIL
*/
static GT_STATUS prvCpssCheckSip5PexMappings(
    IN  GT_UINTPTR          cnm
)
{
    GT_U32 win, win1, ctrl, base, szMask, bar, ctrl1, base1, szMask1;
    GT_BOOL overlapped = GT_FALSE;
    GT_BOOL fitToBar = GT_TRUE;
    GT_U32 barSize[2], barBase[2];

    barSize[0] = CPSS_32BIT_LE(*((volatile GT_U32*)(cnm+(GT_UINTPTR)0x41804)));
    barSize[1] = CPSS_32BIT_LE(*((volatile GT_U32*)(cnm+(GT_UINTPTR)0x41808)));
    barBase[0] = CPSS_32BIT_LE(*((volatile GT_U32*)(cnm+(GT_UINTPTR)0x40018)));
    barBase[1] = CPSS_32BIT_LE(*((volatile GT_U32*)(cnm+(GT_UINTPTR)0x40020)));

    for (win = 0; win < 20; win++)
    {
        prvCpssSip5ReadPexMappingWindow(cnm, win, &ctrl, &base);
        if ((ctrl & 1) == 0)
            continue; /* not enabled */
        bar = (ctrl & 2) ? 1 : 0;
        base &= 0xffff0000;
        szMask = ctrl | 0x0000ffff;
        /* check szMask to be 2^n-1 */
        if (((szMask + 1) & szMask) != 0)
        {
            CPSS_LOG_INFORMATION_MAC("PEX win %d szMask incorrect: 0x%x, must be 2^n-1", win, szMask);
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }
        /* check base to be size aligned */
        if ((base & szMask) != 0)
        {
            CPSS_LOG_INFORMATION_MAC("PEX win %d base(0x%x) must be size(0x%x) aligned", win, base, szMask+1);
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }
        CPSS_LOG_INFORMATION_MAC("PEX win %d on BAR%d base=0x%x size=0x%x target=0x%x:0x%x",
                win, bar+1, base, szMask+1,
                (ctrl>>4)&0x0f, (ctrl>>8)&0x0ff);
        if ((barSize[bar] & 1) == 0)
        {
            CPSS_LOG_INFORMATION_MAC("PEX win %d on disabled BAR%d", win, bar+1);
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }
        if ((base | barSize[bar] | 0x0000ffff) != (barBase[bar] | barSize[bar] | 0x0000ffff))
            fitToBar = GT_FALSE;
        if (szMask > (barSize[bar] | 0x0000ffff))
            fitToBar = GT_FALSE;
        if (fitToBar == GT_FALSE)
        {
            CPSS_LOG_INFORMATION_MAC("PEX win %d don't fit BAR%d", win, bar+1);
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }

        for (win1 = win+1; win1 < 16; win1++)
        {
            prvCpssSip5ReadPexMappingWindow(cnm, win1, &ctrl1, &base1);
            if ((ctrl1 & 1) == 0)
                continue; /* not enabled */
            if ((GT_U32)((ctrl1 & 2)?1:0) != bar)
                continue; /* not same bar */
            base1 &= 0xffff0000;
            szMask1 = ctrl1 | 0x0000ffff;
            _CHECK_OVERLAP;
            if (overlapped == GT_TRUE)
            {
                CPSS_LOG_INFORMATION_MAC("PEX win %d overlaps with win %d", win, win1);
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
            }
        }
    }
    return GT_OK;
}
#undef _CHECK_OVERLAP
#undef _INSIDE_RANGE

/**
* @internal prvCpssCheckSip5Mappings function
* @endinternal
*
* @brief   Check CPU/PEX address mapping to be without overlaps
*
* @param[in] hwInfo                   - HW info
*                                       GT_OK, GT_FAIL
*/
static GT_STATUS prvCpssCheckSip5Mappings(
    IN      CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr,
    IN CPSS_HW_INFO_STC *hwInfo
)
{
    GT_UINTPTR DFXBaseAddr = hwInfo->resource.resetAndInitController.start;

    #ifdef ASIC_SIMULATION
       /* to bypass calling to prvCpssCheckSip5PexMappings(...) in simulation*/
       DFXBaseAddr = 0;
    #endif /*ASIC_SIMULATION*/

    if (hwInfo->busType == CPSS_HW_INFO_BUS_TYPE_MBUS_E &&
        ppPhase1ParamsPtr->mngInterfaceType == CPSS_CHANNEL_PEX_EAGLE_E)
    {
        /* MBUS ! (internal CPU) */
        /* AC5 , AC5X            */
        CPSS_TBD_BOOKMARK_AC5
        CPSS_TBD_BOOKMARK_PHOENIX
        return GT_OK;
    }

    if (hwInfo->busType == CPSS_HW_INFO_BUS_TYPE_MBUS_E)
    {
        if (hwInfo->resource.cnm.size < 0x21000)
            return GT_OK; /* PEX configuration registers not accessible */
        /* check CPU0 mappings */
        return prvCpssCheckSip5MbusMappings(hwInfo->resource.cnm.start, 0x20000);
    }
    if (hwInfo->busType != CPSS_HW_INFO_BUS_TYPE_PEX_E)
        return GT_OK; /* not a PEX, ignore */
    if ( DFXBaseAddr == 0)
        return GT_OK; /* don't have DFX, possible legacy device, ignore */
    if (hwInfo->resource.cnm.size < 0x42000)
        return GT_OK; /* PEX configuration registers not accessible */
    return prvCpssCheckSip5PexMappings(hwInfo->resource.cnm.start);
}

/**
* @internal hwPpPhase1Part1EarlyWABobcat3 function
* @endinternal
*
* @brief   Early WA code for Bobcat3
*         function called from the hwPpPhase1Part1() sequence,
*         after prvCpssDrvHwPpPhase1Init() done
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @param[in] devNum                   - device number of the device
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part1EarlyWABobcat3(
    IN  GT_U8   devNum
)
{
#ifndef ASIC_SIMULATION
    GT_U32  val, dro, coreClock;
    GT_U32  avs, avs_value, fin_avs_value;
    GT_STATUS rc;

    /***************************************************/
    /* Part 1:                                         */
    /*   Read DRO value, and set SVC AVG using formula */
    /***************************************************/

        /* Read DRO value:
         * Bits 202-214 of ID0 Efuse.
         * ID0 Efuse starts at 0xf8f00, so 0xf8f18 represents bits 223..192
         */
        /* Read Core Clock value:
         * core clock: 0xf82d8, bits 23..20
         *      0:  450
         *      1:  487.5
         *      2:  525 (default) <==
         *      3:  583.3335
         *      4:  600           <==
         *      5:  625
         *      6:  556.25
         *      7:  250
         *      8:  572.917       <==
         *      9:  577.0835
         *     10:  585.4165
         *     11:  400
         *     12:  535.4165
         *     13:  545.8335
         *     14:  593.75
         *     15:  Reserved
         */
        rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, 0xf82d8, &val);
        if (rc != GT_OK)
            return rc;
        coreClock = (val >> 20) & 0x0f;

        rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, 0xf8f18, &val);
        if (rc != GT_OK)
            return rc;

        if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)) {
            dro = (val >> 16) & 0x3ff;
            /* If DRO not burned, leave default AVS */
            if (dro == 0)
                return GT_OK;
            /* Enforce low and high limits */
            if (dro > 766)
                dro = 766;
            if (dro < 630)
                dro = 630;

            /* For Aldrin2 only 600MHz is supported (check removed as requested by IlanE) */
            /* if (coreClock != 4) */
                /* return GT_OK; */ /* Not supported */
            avs = ((GT_U32)(1431.789*65536.)) - (dro * ((GT_U32)(0.64669*65536.)));

        }
        else
        {  /* BC3 */
            dro = (val >> 14) & 0x3ff;
            if (dro == 0)
                return GT_OK;

            /* use fixed point operations, 16bit precision */
            switch (coreClock)
            {
                case 2: /* 525MHz,   AVS = 1407.647 - (DRO * 0.68029) */
                    avs = ((GT_U32)(1407.647*65536.)) - (dro * ((GT_U32)(0.68029*65536.)));
                    break;
                case 8: /* 572.9MHz, AVS = 1485.038 - (DRO * 0.76027) */
                    avs = ((GT_U32)(1485.038*65536.)) - (dro * ((GT_U32)(0.76027*65536.)));
                    break;
                case 4: /* 600MHz,   AVS = 1510.299 - (DRO * 0.77007) */
                    avs = ((GT_U32)(1510.299*65536.)) - (dro * ((GT_U32)(0.77007*65536.)));
                    break;
                default:
                    /* not supported */
                    return GT_OK;
            }
        }
        avs = (avs + 0xffff) >> 16;   /* roundup and shift */
        avs = ((avs + 9) / 10) * 10;  /* roundup 10mV */
        avs_value = (avs - 640)/10;
        if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)) {
            fin_avs_value = 0x10000000 + avs_value * 0x2000 + avs_value * 0x8 + 5;

        } else {
            fin_avs_value = 0x10000000 + avs_value * 0x1000 + avs_value * 0x10 + 5;
        }
        rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, 0xf8130, fin_avs_value);
    /***************************************************/
    /* End of Part 1                                   */
    /***************************************************/
    return rc;
#else /* defined(ASIC_SIMULATION) */
    (void)devNum;
    return GT_OK;
#endif
}

/**
* @internal prvCpssDxChDro2AvsFalconSet function
* @endinternal
*
* @brief  set AVS value from falcon eFuse registers
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @param[in] devNum                - device number of the device
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS prvCpssDxChDro2AvsFalconSet(
    IN  GT_U8   devNum
)
{
#ifndef ASIC_SIMULATION
    GT_U32  val,dro=0xff;
    GT_U32  avs;
    GT_U32  tileIndex=0,tileAddr=0x10000000 ,regAddr;
    GT_STATUS rc=GT_OK;

    /* Read DRO value from tiles:
     * Bits 0-7 of IDO Efuse.
     * get min value from all tiles
     * minIDO*4
     * get avs value from equation
     * set value useing mvHwsAvsVoltageSet in all tiles
     */

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
    {
        for(tileIndex = 0; tileIndex < PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles; tileIndex++)
        {
            regAddr = (tileIndex * tileAddr*2) + tileAddr + 0xBEF8F0C;
            rc = prvCpssHwPpReadRegister(devNum, regAddr, &val);
            if (rc != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);

            val=val&0xff;   /*bits 0..7*/
            dro = dro>val ? val : dro;
        }
        /* If DRO not burned, set default value */
        if (dro == 0) {
            avs=880;
        }
        else
        {
            dro = dro * 4;
            if (dro>700)
                avs=800;
            else if (dro<500)
                    avs=880;
                else
                    avs=1080 - dro*0.4;
        }

        for(tileIndex = 0; tileIndex < PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles; tileIndex++)
        {
            rc = mvHwsAvsVoltageSet(devNum,Eagle_0+tileIndex,avs);
            if (rc != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
        return rc;
    }
    /*do nothing return GT_OK*/
    return GT_OK;
#else /* defined(ASIC_SIMULATION) */
    (void)devNum;
    return GT_OK;
#endif
}
/**
* @internal sip6SmiInitPart2 function
* @endinternal
*
* @brief   set extra SMI config for the Raven connection on the SMI master(s)
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @param[in] devNum                   - device number of the device
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS    sip6SmiInitPart2(
    IN GT_U8   devNum
)
{
    GT_STATUS   rc;
    GT_U32  regAddr;
    GT_U32 smiInd;
    /*
        Please note that the SMI master at Eagle is configured by default to periodically
        scan all the PHY addresses, sending a read transaction to register address 0 of
        each PHY address from time to time. This is done because the SMI master originally
        was used for controlling PHYs and for out of band auto negotiation the SMI should
        poll the PHYs from time to time.
        In order to stop this scanning bit[11] of "SMI Misc Configurations" should be cleared
        and bit[17] of "PHY Auto-Negotiation Configuration Register" should be set to 1.
    */


    /* must be done before doing SMI access to the Raven */
    /* SMI access fisrt called from :
        prvCpssDxChPortIfCfgInit(...) -->
            hwsFalconStep0(...) -->
                hwsFalconRavenD2dInit(...)
    */
    for(smiInd = 0; smiInd < 4; smiInd++)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->GOP.SMI[smiInd].SMIMiscConfiguration;
        if (regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
        {
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 11, 1, 0);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->GOP.SMI[smiInd].PHYAutoNegotiationConfig;
        if (regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
        {
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 17, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    return GT_OK;
}

/**
* @internal sip6FalconInterruptsMppInit function
* @endinternal
*
* @brief   This routine sets MPPs (GPIOs) in Eagle (per Raven) and in Raven(s) to change the 'direction' of the MPP from IN to OUT or from OUT to IN.
* @brief
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - otherwise
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The MPPs are used before calling prvCpssDrvInterruptsInit(...)
*       during 'init stage' as 'INPUT to Raven' from Eagle (SMI address).
*/
static GT_STATUS sip6FalconInterruptsMppInit
(
    IN  GT_U8                   devNum
)
{
    GT_STATUS   rc;
    GT_U32      tileIndex;
    GT_U32      ravenIndex;
    GT_U32      regAddr;
    GT_U32      ravenOffset;
    GT_U32      tileOffset;

#ifdef DEBUG_MPP_INIT
    GT_U32      regValue, regValue1;
#define REGISTER_SET_MAC(dev, addr, start, len, val)                                                            \
            rc = prvCpssHwPpReadRegister(dev, addr, &regValue);                                                 \
            if (rc != GT_OK)                                                                                    \
            {                                                                                                   \
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);                                   \
            }                                                                                                   \
            rc = prvCpssHwPpSetRegField(dev, addr, start, len, val);                                            \
            if (rc != GT_OK)                                                                                    \
            {                                                                                                   \
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);                                   \
            }                                                                                                   \
            rc = prvCpssHwPpReadRegister(dev, addr, &regValue1);                                                \
            if (rc != GT_OK)                                                                                    \
            {                                                                                                   \
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);                                   \
            }                                                                                                   \
            cpssOsPrintf("0x%08x  0x%08x  0x%08x\n", regAddr, regValue, regValue1)
#else
#define REGISTER_SET_MAC(dev, addr, start, len, val)                                                            \
            rc = prvCpssHwPpSetRegField(dev, addr, start, len, val);                                            \
            if (rc != GT_OK)                                                                                    \
            {                                                                                                   \
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);                                   \
            }
#endif

    for (tileIndex = 0; tileIndex < PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles; tileIndex++)
    {
        tileOffset = prvCpssSip6TileOffsetGet(devNum, tileIndex);

        for (ravenIndex = 0; ravenIndex < FALCON_RAVENS_PER_TILE; ravenIndex++)
        {
            PRV_CPSS_SKIP_NOT_EXIST_RAVEN_MAC(devNum, tileIndex, ravenIndex);

            ravenOffset = prvCpssDxChHwUnitBaseAddrGet(devNum, (PRV_CPSS_DXCH_UNIT_BASE_RAVEN_0_E + ravenIndex), NULL);

            /* Interrupt output configuration */
            regAddr = 0x00118210 + tileOffset + ravenOffset;
            /* Set bit 0 to 0x1 (conf_int_out_en)
               Set bits 3:1 to 0x1 (conf_int_out_sel) */
            REGISTER_SET_MAC(devNum, regAddr, 0, 4, 3);
            /* MPP Control 0-7 */
            regAddr = 0x00118000 + tileOffset + ravenOffset;
            /* Selects MPP1 to be INTR0 */
            REGISTER_SET_MAC(devNum, regAddr, 4, 4, 0);


            /* Setting the corresponding GPIO in Eagle to input */
            regAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl18;

            regAddr += tileOffset;
            rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, (ravenIndex * 4) + 1, 1, 1);
            if (rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            /* Force GPIO 4 to toggle */
            regAddr = 0x00118110 + tileOffset + ravenOffset;
            /* Corresponds to GPIO4 - bit 4 */
            REGISTER_SET_MAC(devNum, regAddr, 4, 1, 1);

            /* Unmasking the GPIO interrupt in Raven */
            regAddr = 0x00118118 + tileOffset + ravenOffset;
            /* Unmask bit 4  */
            REGISTER_SET_MAC(devNum, regAddr, 4, 1, 1);
        }
    }

    return GT_OK;
}

/**
* @internal sip6FalconComphyEccInterruptsClear function
* @endinternal
*
* @brief   This routine masks the ECC related interrupts seen on PCIE((PIN_MEM_ECC_ERR).
*
* @note   APPLICABLE DEVICES:      Falcon.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - otherwise
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS sip6FalconComphyEccInterruptsClear
(
    IN  GT_U8                   dev
)
{
    GT_STATUS   rc;

    /* Disable PRAM ECC and set clear CNM ECC */
    rc = prvCpssHwPpWriteRegister(dev, 0x1C14A22C, 0x000FB404);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Unset clear CNM ECC */
    rc = prvCpssHwPpWriteRegister(dev, 0x1C14A22C, 0x00003404);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Select lane 0 */
    rc = prvCpssHwPpWriteRegister(dev, 0x1C14A314, 0x0C030324);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Set clear lane 0 ECC */
    rc = prvCpssHwPpWriteRegister(dev, 0x1C142294, 0x003FFC05);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Unset clear lane 0 ECC */
    rc = prvCpssHwPpWriteRegister(dev, 0x1C142294, 0x0000FC05);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Select lane 1 */
    rc = prvCpssHwPpWriteRegister(dev, 0x1C14a314, 0x2C030324);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Set clear lane 1 ECC */
    rc = prvCpssHwPpWriteRegister(dev, 0x1C142294, 0x003FFC05);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Unset clear lane 1 ECC */
    rc = prvCpssHwPpWriteRegister(dev, 0x1C142294, 0x0000FC05);
    if (rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/**
* @internal sip6HawkSdwPramEccInterruptsClear function
* @endinternal
*
* @brief   This routine cleans the ECC related interrupts seen on SDW PRAM.
*
* @note   APPLICABLE DEVICES:      AC5P; Harrier.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5X; Ironman.
*
* @param[in] dev                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - otherwise
* @retval GT_HW_ERROR              - on hardware error
*
*/
static GT_STATUS sip6HawkSdwPramEccInterruptsClear
(
    IN  GT_U8                   dev
)
{
    GT_STATUS                      rc; /* return code */
    GT_U32                         i; /* serdes index iterator */
    GT_U32                         data; /* serdes interrupt cause register data */
    GT_U32                         serdesInterruptCauseReg; /* serdes interrupt cause register address */
    GT_U32                         startSerdesIndx; /* start serdes index */
    GT_U32                         maxSerdesIndx; /* amount of SerDes */
    PRV_CPSS_DXCH_PP_REGS_ADDR_STC *addrPtr = PRV_CPSS_DXCH_DEV_REGS_MAC(dev);

    maxSerdesIndx = addrPtr->serdesConfigRegsSize / sizeof(struct _lpSerdesConfig);
    startSerdesIndx = 0;
    /* maxSerdesIndx loops over both SDW_56 and SDW_28 instances. There is one
     * SDW instance per 4 SERDES index.
     * For AC5P: need to skip SDW_28 so iterator ends
     * after 28 SERDES indexes which fetches the desired 8 SDW instances.
     */
    for (i = startSerdesIndx; (i < maxSerdesIndx) && i <= 28; i+=4)
    {
        /* Read Serdes General Control 0 Register */
        rc = prvCpssHwPpReadRegister(dev, addrPtr->serdesConfig[i].serdesExternalReg1, &data);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* reset SRAM SINGLE & DOUBLE ECC error bits[17-16] */
        data |= 0x00030000;
        /* Write back Serdes Control 0 Register after resetting the ECC bits */
        rc = prvCpssHwPpWriteRegister(dev, addrPtr->serdesConfig[i].serdesExternalReg1, data);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* unset SRAM SINGLE & DOUBLE ECC error bits[17-16] */
        data &= 0xFFFCFFFF;
        /* Write back Serdes Control 0 Register after resetting the ECC bits */
        rc = prvCpssHwPpWriteRegister(dev, addrPtr->serdesConfig[i].serdesExternalReg1, data);
        if (rc != GT_OK)
        {
            return rc;
        }

        serdesInterruptCauseReg = addrPtr->serdesConfig[i].serdesExternalReg1 + 0x300;
        /* Read SDW Interrupt Cause Register to clean them */
        rc = prvCpssHwPpReadRegister(dev, serdesInterruptCauseReg, &data);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/* flag to allow running the phase 1 init in short cycle inclusive to 'd2d init' */
GT_U32 falcon_force_stop_init_after_d2d_init_get(void)
{
    return DXCH_HWINIT_GLOVAR(dxChHwInitSrc.falcon_force_stop_init_after_d2d_init);
}

GT_STATUS falcon_force_stop_init_after_d2d_init_set(void)
{
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.falcon_force_stop_init_after_d2d_init) = 1;

    return GT_OK;
}

/* flag to allow to recognize if Falcon did reset before 'd2d init' .
    this to avoid potential SMI/PCIe access issues.
*/
GT_U32 falcon_force_early_check_for_device_not_reset_get(void)
{
    return DXCH_HWINIT_GLOVAR(dxChHwInitSrc.falcon_force_early_check_for_device_not_reset);
}

GT_STATUS falcon_force_early_check_for_device_not_reset_set(void)
{
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.falcon_force_early_check_for_device_not_reset) = 1;

    return GT_OK;
}

GT_VOID prvBindDuplicatedAddrGetFunc(IN GT_U8 devNum)
{

    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_LION2_E:
            DUPLICATED_ADDR_GETFUNC(devNum) =
                prvCpssLion2DuplicatedMultiPortGroupsGet;
            break;
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
            if(PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
            {
                DUPLICATED_ADDR_GETFUNC(devNum)  =
                    prvCpssBobkDuplicatedMultiPortGroupsGet_byDevNum;
            }
            break;
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
            DUPLICATED_ADDR_GETFUNC(devNum)  =
                prvCpssBobcat3DuplicatedMultiPortGroupsGet_byDevNum;
            break;
        case CPSS_PP_FAMILY_DXCH_ALDRIN2_E:
            DUPLICATED_ADDR_GETFUNC(devNum)  =
                prvCpssAldrin2DuplicatedMultiPortGroupsGet_byDevNum;
            break;
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
        case CPSS_PP_FAMILY_DXCH_AC3X_E:
            DUPLICATED_ADDR_GETFUNC(devNum)  =
                prvCpssAldrinDuplicatedMultiPortGroupsGet_byDevNum;
            break;
        case CPSS_PP_FAMILY_DXCH_FALCON_E:
            DUPLICATED_ADDR_GETFUNC(devNum)  =
                prvCpssFalconDuplicatedMultiPortGroupsGet_byDevNum;
            break;
        case CPSS_PP_FAMILY_DXCH_AC5P_E:
            DUPLICATED_ADDR_GETFUNC(devNum)  =
                prvCpssHawkDuplicatedMultiPortGroupsGet_byDevNum;
            break;
        case CPSS_PP_FAMILY_DXCH_AC5X_E:
            DUPLICATED_ADDR_GETFUNC(devNum)  =
                prvCpssPhoenixDuplicatedMultiPortGroupsGet_byDevNum;
            break;
        case CPSS_PP_FAMILY_DXCH_HARRIER_E:
            DUPLICATED_ADDR_GETFUNC(devNum)  =
                prvCpssHarrierDuplicatedMultiPortGroupsGet_byDevNum;
            break;
        case CPSS_PP_FAMILY_DXCH_IRONMAN_E:
            /* no unit in the Ironman need duplication support */
            DUPLICATED_ADDR_GETFUNC(devNum)  = NULL;
            break;
        default:
            DUPLICATED_ADDR_GETFUNC(devNum)  = NULL;
    }
}

/* give indication if the device did reset before we started */
/* use the MG1 user defined register                         */
/* supported on sip6 devices that hold MG1 unit              */
GT_BOOL cpssDxChCheckIsHwDidHwReset(IN GT_U8 devNum)
{
    GT_U32  regAddr,regValue;
    GT_BOOL isError,didHwReset;

    regAddr = prvCpssDxChHwUnitBaseAddrGet(devNum,PRV_CPSS_DXCH_UNIT_MG_0_1_E,&isError);
    if(isError == GT_TRUE)
    {
        /* 1. GM not support it */
        /* 2. maybe the device not support MG1 ? */
        return GT_TRUE;/* did HW reset */
    }

    regAddr += 0x00000074;/* user defined register */
    cpssDrvPpHwRegisterRead(devNum,0,regAddr,&regValue);
    if(regValue != 0)
    {
        didHwReset = GT_FALSE;
        cpssOsPrintf("WARNING: (potential ERROR) the device did not do HW reset (soft/hard) before initialization \n");
    }
    else
    {
        didHwReset = GT_TRUE;
    }
    /* make sure that the register will not hold value 0 ... to catch 'no HW reset' case */
    regValue = 0xa5968402;
    cpssDrvPpHwRegisterWrite(devNum,0,regAddr,regValue);

    return didHwReset;
}



GT_VOID hwPpPhase1DeviceSpecificIntCallbacksInit
(
    IN      GT_U8                                   devNum
)
{

    /* attach the generic code with the DX function */
     PRV_INTERRUPT_FUNC_GET(devNum,unitIntGenerationCheckFunc) = prvCpssDxChUnitInterruptGenerationCheck;
     PRV_INTERRUPT_FUNC_GET(devNum,eventPortMapConvertFunc) = prvCpssDxChPortEventPortMapConvert;
     PRV_INTERRUPT_FUNC_GET(devNum,macEventPortMapConvertFunc) = prvCpssPortMacEventConvert;
     PRV_INTERRUPT_FUNC_GET(devNum,eventGenericConvertFunc) = prvCpssDxChEventGenericConvert;
}

/**
* @internal hwPpPhase1Part1 function
* @endinternal
*
* @brief   Part 1 of "phase 1"
*         Performs configures that should be done at the start of "Phase 1" :
*         initialize the cpssDriver
*         build the DB needed for the device
*         function called from the "phase 1" sequence.
* @param[in] ppPhase1ParamsPtr        - Packet processor hardware specific parameters.
*                                      multiPortGroupDevice    - indication that the device supposed to be 'multi port groups' device.
*
* @param[out] deviceTypePtr            - (pointer to) The Pp's device type.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_CPU_MEM        - failed to allocate CPU memory,
* @retval GT_NOT_SUPPORTED         - the device not supported by CPSS
* @retval GT_BAD_VALUE             - the driver found unknown device type
* @retval GT_NOT_IMPLEMENTED       - the CPSS was not compiled properly
* @retval GT_OUT_OF_RANGE          - the value is out of range
*
* @note was called "pre start init"
*
*/
static GT_STATUS hwPpPhase1Part1
(
    IN      CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr,
    OUT     CPSS_PP_DEVICE_TYPE                 *deviceTypePtr
)
{
    GT_STATUS           rc;
    GT_U8               devNum; /* device number of the device */
    GT_U32              port, ii,jj;   /* iterator */
    GT_U32              portGroupId;/*iterator for port group Id*/
    GT_U32              firstActivePortGroupId;/* port group Id for the first active port group */
    GT_U32              ttiMetalFixData; /* tunnel termination metal fix register */
    GT_BOOL             legacyVplsModeSupported; /* if legcay VPLS mode is supported in the device */
    GT_U32 fidBitsCount = 0;  /* bits count used to store FID value */
    GT_U32 bmpBytesCount = 0; /* bytes count to store bitmap pointed by bridge.keyModePerFidBmpPtr */
    GT_U32 *bmpPtr = NULL;    /* pointer to a bitmap */
    GT_UINTPTR busBaseAddrAttachKey; /* key for prvCpssPpConfigDevDbBusBaseAddrAttach call */
    GT_BOOL multiPortGroupDevice = GT_FALSE;

    /* info needed by the cpssDriver */
    PRV_CPSS_DRV_PP_PHASE_1_INPUT_INFO_STC drvPpPhase1InInfo;
    /* info returned from the cpssDriver */
    PRV_CPSS_DRV_PP_PHASE_1_OUTPUT_INFO_STC drvPpPhase1OutInfo;
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr;/* pointer to common device info */
    PRV_CPSS_DXCH_MODULE_CONFIG_STC *moduleCfgPtr;/* module config of the device */
    GT_BOOL         pciCompatible;
    GT_U32          i = 0;
    GT_U32          pllCoreParamsRegData;
    GT_U32          pllCoreConfigRegData;
    GT_U32          regAddr;
    CPSS_SYSTEM_RECOVERY_INFO_STC tempSystemRecovery_Info;
    CPSS_SYSTEM_RECOVERY_INFO_STC newSystemRecoveryInfo;

    rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
    if (rc != GT_OK)
    {
        return rc;
    }


    devNum = ppPhase1ParamsPtr->devNum;

    if (ppPhase1ParamsPtr->numOfPortGroups > 1)
        multiPortGroupDevice = GT_TRUE;


    /* prepare INPUT info for the cpssDriver */
    drvPpPhase1InInfo.mngInterfaceType = ppPhase1ParamsPtr->mngInterfaceType;

    if(CPSS_CHANNEL_IS_PCI_COMPATIBLE_MAC(ppPhase1ParamsPtr->mngInterfaceType))
    {
        pciCompatible = GT_TRUE;
    }
    else
    {
        pciCompatible = GT_FALSE;
    }

    firstActivePortGroupId = 0xFF;
    /* the per port group information taken from ppPhase1ParamsPtr->hwInfo[portGroupId] */
    /* NOTE: can't use macro PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
            at this stage because the macro uses DB that was not created yet */
    for(portGroupId = 0 ; portGroupId < ppPhase1ParamsPtr->numOfPortGroups ; portGroupId++)
    {
        drvPpPhase1InInfo.hwInfo[portGroupId] = ppPhase1ParamsPtr->hwInfo[portGroupId];
        if(firstActivePortGroupId == 0xFF &&/*not initialized yet*/
           drvPpPhase1InInfo.hwInfo[portGroupId].busType != CPSS_HW_INFO_BUS_TYPE_NONE_E)/*active port group*/
        {
            firstActivePortGroupId = portGroupId;
        }
    }

    drvPpPhase1InInfo.numOfPortGroups = ppPhase1ParamsPtr->numOfPortGroups;

    drvPpPhase1InInfo.ppHAState = ppPhase1ParamsPtr->ppHAState;

    drvPpPhase1InInfo.devIdLocationType = PRV_CPSS_DRV_DEV_ID_LOCATION_DEVICE_ADDR_0x0000004C_E;

    drvPpPhase1InInfo.isrAddrCompletionRegionsBmp = ppPhase1ParamsPtr->isrAddrCompletionRegionsBmp;
    drvPpPhase1InInfo.appAddrCompletionRegionsBmp = ppPhase1ParamsPtr->appAddrCompletionRegionsBmp;

    for (portGroupId = 0 ; portGroupId < ppPhase1ParamsPtr->numOfPortGroups ; portGroupId++)
    {
        if (ppPhase1ParamsPtr->hwInfo[portGroupId].busType == CPSS_HW_INFO_BUS_TYPE_NONE_E)
            continue;
        rc = prvCpssCheckSip5Mappings(ppPhase1ParamsPtr,&(ppPhase1ParamsPtr->hwInfo[portGroupId]));
        if (rc != GT_OK)
        {
            /* prvCpssCheckSip5Mappings will print detailed info */
            return rc;
        }
    }

    /* allocate the memory for the non-shared device DB */
    PRV_NON_SHARED_GLOBAL_VAR_GET(nonSharedDeviceSpecificDb[devNum]) = cpssOsMalloc(sizeof(PRV_CPSS_NON_SHARED_DEVICE_SPECIFIC_DATA));
    if (PRV_NON_SHARED_GLOBAL_VAR_GET(nonSharedDeviceSpecificDb[devNum]) == NULL)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : PRV_NON_SHARED_GLOBAL_VAR_GET(nonSharedDeviceSpecificDb[devNum]) == NULL : GT_OUT_OF_CPU_MEM");
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
    }

    /* reset the device DB */
    cpssOsMemSet(PRV_NON_SHARED_GLOBAL_VAR_GET(nonSharedDeviceSpecificDb[devNum]) , 0 ,
                                sizeof(PRV_CPSS_NON_SHARED_DEVICE_SPECIFIC_DATA));

    /* call cpssDriver to initialize itself - phase 1 */
    rc = prvCpssDrvHwPpPhase1Init(devNum,
                                  &drvPpPhase1InInfo,
                                  &drvPpPhase1OutInfo);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpPhase1Init(..) : return code is %d", rc);
        return rc;
    }
    /* set the out put parameter */
    *deviceTypePtr = drvPpPhase1OutInfo.devType;


    if(! CPSS_IS_DXCH_FAMILY_MAC(drvPpPhase1OutInfo.devFamily))
    {
            /* we got bad value from the cpssDriver !
                that means that there is problem in the cpssDriver or that the
                PP , is not Dx supported device.
            */
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : problem in prvCpssDrvHwPpPhase1Init(..) or PP is not Dx supported device");
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_VALUE, LOG_ERROR_NO_MSG);
    }

    /* allocate the memory for the device DB */
    PRV_CPSS_PP_CONFIG_ARR_MAC[devNum] = cpssOsMalloc(sizeof(PRV_CPSS_DXCH_PP_CONFIG_STC));


    if (PRV_CPSS_PP_MAC(devNum) == NULL)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : PRV_CPSS_PP_MAC(devNum) == NULL : GT_OUT_OF_CPU_MEM");
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
    }



    DXCH_HWINIT_GLOVAR(dxCh_prvCpssPpConfig[devNum]) = PRV_CPSS_PP_CONFIG_ARR_MAC[devNum];

    /* reset the device DB */
    cpssOsMemSet(
        PRV_CPSS_PP_MAC(devNum) , 0 ,
        sizeof(PRV_CPSS_DXCH_PP_CONFIG_STC));

    devPtr = PRV_CPSS_PP_MAC(devNum);
    moduleCfgPtr = PRV_CPSS_DXCH_DEV_MODULE_CFG_MAC(devNum);
    /*******************************************/
    /* start filling the info to the device DB */
    /*******************************************/
    /* set the device number */
    devPtr->devNum = devNum;

    /* fill info retrieved from the cpssDriver */
    devPtr->devType = drvPpPhase1OutInfo.devType;
#ifdef GM_USED
    devPtr->isGmDevice = 1;
#endif /*GM_USED*/
#ifdef ASIC_SIMULATION
    devPtr->isWmDevice = 1;
#endif /*ASIC_SIMULATION*/

    /* Lion2 Hooper support - update hooper revision as descendant of Lion2 B1  */
    switch(devPtr->devType)
    {
        case CPSS_LION2_HOOPER_PORT_GROUPS_0123_DEVICES_CASES_MAC:
            devPtr->revision = (GT_U8)(drvPpPhase1OutInfo.revision + 2);
            break;
        default:
            devPtr->revision = drvPpPhase1OutInfo.revision;
            break;
    }

    devPtr->devFamily = drvPpPhase1OutInfo.devFamily;
    devPtr->numOfPorts = drvPpPhase1OutInfo.numOfPorts;
    devPtr->multiPipe.numOfTiles = drvPpPhase1OutInfo.numOfTiles;
    devPtr->existingPorts = drvPpPhase1OutInfo.existingPorts;
    devPtr->numOfVirtPorts = devPtr->numOfPorts;

    /* set default CPU port mode to none */
    devPtr->cpuPortMode = CPSS_NET_CPU_PORT_MODE_NONE_E;

    devPtr->devSubFamily = drvPpPhase1OutInfo.devSubFamily;

    /* Flow Manager ID is initialized to 0 by default during CPSS init
     * so assigning not valid ID value for this field.
     */
    PRV_CPSS_DXCH_PP_MAC(devNum)->flowMgrInfo.flowManagerId = 0xFFFFFFFF;

    /* Special early WA */
    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_ALDRIN2_E:
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
            if (!((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
                 (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E)) )
            {
                rc = hwPpPhase1Part1EarlyWABobcat3(devNum);
                if (rc != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "hwPpPhase1Part1(): hwPpPhase1Part1EarlyWABobcat3() failed");
                }
            }
            break;
        default:
            break;
    }

    /* attach the generic code with the Dx function */
    prvBindDuplicatedAddrGetFunc(devNum);

    /*set the sip version (legacy / 5 / 5_10 / 5_15 /...)*/
    rc = setSipVersion(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : setSipVersion(..) : return code is %d", rc);
        return rc;
    }

    /* Events config */
    if(multiPortGroupDevice == GT_FALSE)
    {
        /* set the device as 'non multi-port-groups' device '*/
        rc = prvCpssNonMultiPortGroupsDeviceSet(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssNonMultiPortGroupsDeviceSet(..) : return code is %d", rc);
            return rc;
        }
        /* from this point on we can start use the macros of:
           PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC,
           PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC
        */

        moduleCfgPtr->ppEventsCfg[CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS].intVecNum = ppPhase1ParamsPtr->hwInfo[0].irq.switching;
        moduleCfgPtr->ppEventsCfg[CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS].intMask   = ppPhase1ParamsPtr->hwInfo[0].intMask.switching;

        devPtr->useIsr = (ppPhase1ParamsPtr->hwInfo[0].irq.switching == CPSS_PP_INTERRUPT_VECTOR_NOT_USED_CNS) ?
                        GT_FALSE : GT_TRUE;

        /* attach the device with it base address , needed to support re-init after
           'shutdown' */
        busBaseAddrAttachKey = devDbBusBaseAddrAttachKeyGet(
                ppPhase1ParamsPtr,
                GT_FALSE /*multiPortGroupDevice*/,
                0 /*firstActivePortGroupId*/);
        rc = prvCpssPpConfigDevDbBusBaseAddrAttach(devNum, busBaseAddrAttachKey);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssPpConfigDevDbBusBaseAddrAttach(..) : return code is %d", rc);
            return rc;
        }
    }
    else
    {
        devPtr->portGroupsInfo.isMultiPortGroupDevice = GT_TRUE;

        devPtr->portGroupsInfo.numOfPortGroups = ppPhase1ParamsPtr->numOfPortGroups;
        for(portGroupId = 0 ; portGroupId < ppPhase1ParamsPtr->numOfPortGroups ; portGroupId++)
        {
            if(ppPhase1ParamsPtr->hwInfo[portGroupId].busType !=
               CPSS_HW_INFO_BUS_TYPE_NONE_E)
            {
                devPtr->portGroupsInfo.activePortGroupsBmp |= (1 << portGroupId);

                if(devPtr->portGroupsInfo.firstActivePortGroup > portGroupId)
                {
                    devPtr->portGroupsInfo.firstActivePortGroup = portGroupId;
                }

                if(devPtr->portGroupsInfo.lastActivePortGroup < portGroupId)
                {
                    devPtr->portGroupsInfo.lastActivePortGroup = portGroupId;
                }
            }
        }

        firstActivePortGroupId = devPtr->portGroupsInfo.firstActivePortGroup;

        /* set the devPtr->portGroupsInfoPtr->cpuPortPortGroupId

           NOTE: 1. Lion: For RGMII should be 3
                 2. For SDMA should be CPSS_PORT_GROUP_UNAWARE_MODE_CNS
                 3. This portGroupId used only for 'cpu port' and not for all networkIf
                    configurations that may use firstActivePortGroup!!!
        */
        if(pciCompatible == GT_TRUE)
        {
            devPtr->portGroupsInfo.cpuPortPortGroupId       = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
        }

        devPtr->portGroupsInfo.auqPortGroupIdLastServed = firstActivePortGroupId;
        devPtr->portGroupsInfo.fuqPortGroupIdLastServed = firstActivePortGroupId;
        devPtr->portGroupsInfo.secureBreachNextPortGroupToServe = firstActivePortGroupId;
        devPtr->portGroupsInfo.ptpNextPortGroupToServe = firstActivePortGroupId;
        devPtr->portGroupsInfo.phaViolationCapturedNextPortGroupToServe = firstActivePortGroupId;
        for (ii = 0; ii < PRV_CPSS_MAX_DIRECTIONS_CNS ; ii ++)
        {
            for (jj = 0; jj < PRV_CPSS_MAX_PTP_TIMESTAMP_QUEUES_CNS; jj++)
            {
                  devPtr->portGroupsInfo.ptpIngressEgressNextPortGroupToServe[ii][jj] = firstActivePortGroupId;
            }
        }

        /* from this point on we can start use the macros of:
           PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC,
           PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC
        */

        devPtr->useIsr = GT_FALSE;

        /* the per port group information taken from ppPhase1ParamsPtr->hwInfo[portGroupId] */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
        {
            moduleCfgPtr->ppEventsCfg[portGroupId].intVecNum  = ppPhase1ParamsPtr->hwInfo[portGroupId].irq.switching;
            moduleCfgPtr->ppEventsCfg[portGroupId].intMask    = ppPhase1ParamsPtr->hwInfo[portGroupId].intMask.switching;
            if(ppPhase1ParamsPtr->hwInfo[portGroupId].irq.switching != CPSS_PP_INTERRUPT_VECTOR_NOT_USED_CNS)
            {
                /* at least one active port group , needs the ISR */
                devPtr->useIsr = GT_TRUE;
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

        /* attach the device with it base address , needed to support re-init after
           'shutdown' */
        /* NOTE: we use a 'designated' for a 'multi-port-groups' device base address , to identify the device .
                 so we not need to change implementation */
        busBaseAddrAttachKey = devDbBusBaseAddrAttachKeyGet(
                ppPhase1ParamsPtr,
                GT_TRUE /*multiPortGroupDevice*/,
                firstActivePortGroupId);
        rc = prvCpssPpConfigDevDbBusBaseAddrAttach(devNum, busBaseAddrAttachKey);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssPpConfigDevDbBusBaseAddrAttach(..) : return code is %d", rc);
            return rc;
        }
    }

    /* set this device to support the "DxCh" functions */
    devPtr->functionsSupportedBmp = PRV_CPSS_DXCH_FUNCTIONS_SUPPORT_CNS;
    devPtr->appDevFamily = CPSS_CH1_E;

    PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) = 31;
    PRV_CPSS_DXCH_PP_HW_INFO_L2I_MAC(devNum).supportIngressRateLimiter = GT_TRUE;

    /* flexFieldNumBitsSupport default values */
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort  = 6;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).trunkId  = 7;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).ePort    =
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort;/*for checking purposes ePort=phyPort*/
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).vid      = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).vidx     = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).eVidx    = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).hwDevNum = 5;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).sstId    = 5;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).stgId    = 8;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).fid      = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).fdbUserDefined = 4;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).portGroupId = 2;

    /* eArch is not supported by default */
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.eArch.supported = GT_FALSE;

    /* VPLS mode is not supported by default */
    PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_MAC(devNum).supported = GT_FALSE;
    PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_MAC(devNum).enabled = GT_FALSE;

    /* IPCL-0 is not bypassed by default */
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass = GT_FALSE;

    ttiMetalFixData = 0;

    /* Bobcat3 CM3 SRAM size */
    if ((PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E) ||
        (PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E))
    {
        PRV_CPSS_DXCH_PP_HW_INFO_MG_MAC(devNum).confiProcessorMemorySize =
                                                                     0x30000;
    }
    if (PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
    {
         PRV_CPSS_DXCH_PP_HW_INFO_MG_MAC(devNum).confiProcessorMemorySize =
                                                                     0x60000;
    }
    /* default value for devices other then xCat C0 is 0 */
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.tti.metalFix = ttiMetalFixData;

    /* dedicated MAC for CPU port */
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dedicatedCpuMac.isNotSupported = GT_FALSE;

    /* port mapping related configurations */
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.portMapping.isUsedPortMappingCheck = GT_FALSE;

    /* the device not supports DFX server unit */
    PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) = GT_FALSE;

    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.info[0].valid = GT_TRUE;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.info[0].usedAsCpuPort = GT_TRUE;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.info[0].dmaNum = CPSS_CPU_PORT_NUM_CNS;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.info[0].dqNum = 0;
    for (ii = 1; ii < CPSS_MAX_SDMA_CPU_PORTS_CNS; ii ++)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.info[ii].valid = GT_FALSE;
    }

    if (drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
    {
        if (!((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
             (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E)) )
        {
            rc = hwPpPhase1Part1_existingUnitsListAtMGInit(devNum);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : hwPpPhase1Part1_existingUnitsListAtMGInit(..) : return code is %d", rc);
                return rc;
            }
        }
    }

    /* set this device ALSO support the "Cheetah 2" functions */
    devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH2_FUNCTIONS_SUPPORT_CNS;

    /* set this device ALSO support the "Cheetah 3" functions */
    devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH3_FUNCTIONS_SUPPORT_CNS;

    /* set this device ALSO support the "DxCh xCat" functions */
    devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_XCAT_FUNCTIONS_SUPPORT_CNS;

    legacyVplsModeSupported = GT_FALSE;

    switch(drvPpPhase1OutInfo.devFamily)
    {
        case PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_CASES_MAC:
            if (PRV_CPSS_DXCH_XCAT3_UNMANAGED_CHECK_MAC(devNum) == GT_FALSE)
            {
                legacyVplsModeSupported = GT_TRUE;
            }
            break;

        default:
            break;
    }

    if(legacyVplsModeSupported == GT_TRUE)
    {
        /* don't use macro PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC before this line */
        /* in xCat C0 and xCat3 Legacy VPLS mode is supported */
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.legacyVplsMode.supported = GT_TRUE;

        /* if the device support Legacy VPLS mode and application wants to enable Legacy VPLS mode on the device
           then Legacy VPLS mode will be globaly enabled */
        if (ppPhase1ParamsPtr->enableLegacyVplsModeSupport == GT_TRUE)
        {
            /* don't use macro PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC before this line */
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.legacyVplsMode.enabled = GT_TRUE;
        }
    }

    /* set this device ALSO support the "DxCh xCat3" functions */
    devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_XCAT3_FUNCTIONS_SUPPORT_CNS;
    devPtr->appDevFamily = CPSS_XCAT3_E;

    if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) = GT_TRUE;
    }

    if(drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_DXCH_AC5_E)
    {
        devPtr->appDevFamily = CPSS_AC5_E;
    }

    if(drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        /* set this device ALSO support the "DxCh Lion" functions */
        devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_LION_FUNCTIONS_SUPPORT_CNS;
        devPtr->appDevFamily = CPSS_LION_E;

        /* L2I not support rate limiter */
        PRV_CPSS_DXCH_PP_HW_INFO_L2I_MAC(devNum).supportIngressRateLimiter = GT_FALSE;

        /* TXQ upgraded */
        PRV_CPSS_DXCH_PP_HW_INFO_TXQ_MAC(devNum).revision = 1;

        /* bit index 63 for cpu port */
        PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) = 63;

        if(CPSS_DXCH_ALL_SIP6_FAMILY_MAC(drvPpPhase1OutInfo.devFamily))
        {
            rc = setSip6FlexInfo(devNum);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            switch(drvPpPhase1OutInfo.devFamily)
            {
                case CPSS_PP_FAMILY_DXCH_LION2_E:
                    /* for Lion2 - 4 port groups - allow supportDualDeviceId as FALSE */
                    if( (HWINIT_GLOVAR(sysGenGlobalInfo.supportDualDeviceId) == GT_FALSE) &&
                        (PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.activePortGroupsBmp > 0x0F) )
                    {
                        /* this device can only work in 'dual device system' as it is 'dual deviceId device' */
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                    }

                    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).portGroupId = 3;

                    PRV_CPSS_DXCH_PP_MAC(devNum)->diagInfo.tcamParityCalcEnable = ppPhase1ParamsPtr->tcamParityCalcEnable;

                    PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) = GT_TRUE;
                    if(PRV_CPSS_PP_MAC(devNum)->isGmDevice)
                    {
                        /* the Lion2 GM device currently not supports the DFX server unit */
                        PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) = GT_FALSE;
                    }

                    break;

                case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
                case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
                case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
                case CPSS_PP_FAMILY_DXCH_AC3X_E:
                case CPSS_PP_FAMILY_DXCH_ALDRIN2_E:
                    rc = setSip5FlexInfo(devNum);
                    if(rc != GT_OK)
                    {
                        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : setSip5FlexInfo(..) : return code is %d", rc);
                        return rc;
                    }

                    break;

                    /* ADD HERE new devices that need to override parameters (like we have for Lion) */
                default:
                    break;
            }
        }/*non-sip6*/

    }

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    {
        /* CNC info */
        PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.cncUploadNextCncUnitInPortGroupToServe[portGroupId] = PRV_CPSS_DXCH_UNIT_CNC_0_E;
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts =
        PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_PHY_PORT_MAC(devNum) + 1;

    if(drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_DXCH_XCAT2_E)
    {
        /* set this device ALSO support the "DxCh xCat2" functions */
        devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_XCAT2_FUNCTIONS_SUPPORT_CNS;
        devPtr->appDevFamily = CPSS_XCAT2_E;
    }

    /* default is one TXQ unit */
    PRV_CPSS_DXCH_PP_HW_INFO_TXQ_MAC(devNum).txqUnitsNum = 1;

    if(drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        /* init the Lion2 device depending on number of activePortGroupsBmp - 8/4 port groups
           - txqUnitsNum - number of TXQ units
           - numOfPorts -  for Lion2 4 port groups is 60 and for Lion2 8 port groups it is initialized from the CPSS DB(124)*/

        if(multiPortGroupDevice == GT_TRUE)
        {
            if ( PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.activePortGroupsBmp > 0x0F )
            { /* Lion2 - 5 and more active port groups */
                  PRV_CPSS_DXCH_PP_HW_INFO_TXQ_MAC(devNum).txqUnitsNum = 2;
            }
            else
            { /* Lion2 - 4 and less active port groups */
                devPtr->numOfVirtPorts = devPtr->numOfPorts = 60;
            }
        }

        if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
        {
            /* set this device ALSO support the "DxCh Lion2" functions */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_LION2_FUNCTIONS_SUPPORT_CNS;
            devPtr->appDevFamily = CPSS_LION2_E;
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
        {
            if(devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
            {
                 /* set this device ALSO support the "DxCh Caelum" functions */
                devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_CAELUM_FUNCTIONS_SUPPORT_CNS;
                devPtr->appDevFamily = CPSS_CAELUM_E;
            }
            else
            {
                 /* set this device ALSO support the "DxCh Bobcat2" functions */
                devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_BOBCAT2_FUNCTIONS_SUPPORT_CNS;
                devPtr->appDevFamily = CPSS_BOBCAT2_E;
            }
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E)
        {
            /* use Caelum APIs so far */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_ALDRIN_FUNCTIONS_SUPPORT_CNS;
            devPtr->appDevFamily = CPSS_ALDRIN_E;
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_AC3X_E)
        {
            /* use AC3X APIs */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_AC3X_FUNCTIONS_SUPPORT_CNS;
            devPtr->appDevFamily = CPSS_AC3X_E;
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
        {
             /* set this device ALSO support the "DxCh Bobcat3" functions */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_BOBCAT3_FUNCTIONS_SUPPORT_CNS;
            devPtr->appDevFamily = CPSS_BOBCAT3_E;
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)
        {
             /* set this device ALSO support the "DxCh Aldrin2" functions */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_ALDRIN2_FUNCTIONS_SUPPORT_CNS;

            devPtr->appDevFamily = CPSS_ALDRIN2_E;
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
        {
             /* set this device ALSO support the "DxCh Falcon" functions */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_FALCON_FUNCTIONS_SUPPORT_CNS;
            devPtr->appDevFamily = CPSS_FALCON_E;
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E)
        {
             /* set this device ALSO support the "DxCh Hawk" functions */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_AC5P_FUNCTIONS_SUPPORT_CNS;
            devPtr->appDevFamily = CPSS_AC5P_E;
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E)
        {
             /* set this device ALSO support the "DxCh Phoenix" functions */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_AC5X_FUNCTIONS_SUPPORT_CNS;
            devPtr->appDevFamily = CPSS_AC5X_E;
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_HARRIER_E)
        {
             /* set this device ALSO support the "DxCh Harrier" functions */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_HARRIER_FUNCTIONS_SUPPORT_CNS;
            devPtr->appDevFamily = CPSS_HARRIER_E;
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_IRONMAN_E)
        {
            /* set this device ALSO support the "DxCh Ironman" functions */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_IRONMAN_FUNCTIONS_SUPPORT_CNS;
            devPtr->appDevFamily = CPSS_IRONMAN_E;
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);
        }
    }

    if(PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles >= 2 || /*sip6 device with tiles*/
       drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)/* in Falcon force also single tile ... to catch issues on single tile */
    {
        /**************************************/
        /* the SIP6 devices hold FDB per tile */
        /* each 2 pipes share the same FDB    */
        /**************************************/
        PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.supportSingleFdbInstance = GT_FALSE;
    }
    else
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)/*sip5 devices*/
    {
        /* multi port group device BUT with single FDB instance (not per port group) */
        PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.supportSingleFdbInstance = GT_TRUE;
    }
    else if(PRV_CPSS_IS_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))/*Lion/Lion2*/
    {
        /* multi port group device with FDB per port group */
        PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.supportSingleFdbInstance = GT_FALSE;
    }
    else
    {
        /* device without port groups --> single FDB instance */
        PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.supportSingleFdbInstance = GT_TRUE;
    }

    /* sets HW interface parameters , only after this point you can use the
        PRV_CPSS_HW_IF_PCI_COMPATIBLE_MAC , to know that the device is PCICompatible*/
    rc = prvCpssHwIfSet(devNum,ppPhase1ParamsPtr->mngInterfaceType);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssHwIfSet(..) : return code is %d", rc);
        return rc;
    }

    /* save HW devNum to the DB */
    PRV_CPSS_HW_DEV_NUM_MAC(devNum) = devNum;


    /* value taken from : prvCpssDxChPhyPortSmiRegisterWrite(...) and from
        smiStatusCheck(...) */
    devPtr->maxIterationsOfSmiWait = PRV_CPSS_SMI_RETRY_COUNTER_CNS;

    /* must be done before doing any busy wait on a device  */
    if (CPSS_CHANNEL_IS_PCI_COMPATIBLE_MAC(ppPhase1ParamsPtr->mngInterfaceType))
    {
        devPtr->maxIterationsOfBusyWait =
            66000000;/* 66 million for PCI bus with rate of 66MHz ,
                        and every read operation is about 2 clocks
                        give us about 2 second.
                        For PEX x1 it give us about 1 second */
    }
    else
    {
        switch(ppPhase1ParamsPtr->mngInterfaceType)
        {
            case CPSS_CHANNEL_SMI_E:
            case CPSS_CHANNEL_TWSI_E:
                devPtr->maxIterationsOfBusyWait =
                    78125; /* For SMI MDC 20Mhz the read/write register longs
                             then near 12.8 micro seconds.
                             78125 read registers give us about 1 second */
                break;
            default:
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : ppPhase1ParamsPtr->mngInterfaceType == %d : GT_BAD_PARAM", ppPhase1ParamsPtr->mngInterfaceType);
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }
    if(PRV_CPSS_PP_MAC(devNum)->isGmDevice)
    {
        /* the GM is heavy and query into the GM takes it's own time.
           no need more the 30 iterations , to understand 'not done' */
        devPtr->maxIterationsOfBusyWait = 30;
    }
    else
    if(PRV_CPSS_PP_MAC(devNum)->isWmDevice)
    {
        /* the simulation devices also need to do wait with sleep between iterations
            so the other task that should finish the triggered action can finish */
        devPtr->maxIterationsOfBusyWait = 500; /* with the 10 mili sleep between iterations --> 5 seconds */
    }

    /* set 'baseCoreClock' : base core clock parameter. */
    rc = baseCoreClockSet(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : baseCoreClockSet(..) : return code is %d", rc);
        return rc;
    }

    /* check if core clock needed to be read from hardware */
    rc = hwPpAutoDetectCoreClock(devNum,&(devPtr->coreClock));
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : hwPpAutoDetectCoreClock(..) : return code is %d", rc);
        return rc;
    }

    PRV_CPSS_DXCH_PP_MAC(devNum)->port.serdesRefClock = ppPhase1ParamsPtr->serdesRefClock;

    /* initialize all the WA that needed for the device */
    rc = hwPpPhase1NeededWaSettings(devNum);
    if (rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : hwPpPhase1NeededWaSettings(..) : return code is %d", rc);
        return rc;
    }


    /* initialize phyPortInfoArray[] */
    rc = initPortTypeArray(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : initPortTypeArray(..) : return code is %d", rc);
        return rc;
    }

    /* initialize Egf bitmap */
    if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        rc = initEgfForceStatusBitMap(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : initEgfForceStatusBitMap(..) : return code is %d", rc);
            return rc;
        }
    }

    /* initialize portsMibShadowArr[] */
    rc = initPortMibShadow(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : initPortMibShadow(..) : return code is %d", rc);
        return rc;
    }

    /* initialize info about those PP's family */
    if(HWINIT_GLOVAR(prvCpssFamilyInfoArray[devPtr->devFamily]) == NULL)
    {
        /* this family was not initialized yet */
        HWINIT_GLOVAR(prvCpssFamilyInfoArray[devPtr->devFamily]) =
            cpssOsMalloc(sizeof(PRV_CPSS_FAMILY_INFO_STC));

        if (HWINIT_GLOVAR(prvCpssFamilyInfoArray[devPtr->devFamily]) == NULL)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssFamilyInfoArray[devPtr->devFamily] == NULL : GT_OUT_OF_CPU_MEM");
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }

        cpssOsMemSet(HWINIT_GLOVAR(prvCpssFamilyInfoArray[devPtr->devFamily]),
                        0,sizeof(PRV_CPSS_FAMILY_INFO_STC));

        HWINIT_GLOVAR(prvCpssFamilyInfoArray[devPtr->devFamily]->numReferences) = 1;

        /* initialize specific family trunk info */
        prvCpssDxChTrunkFamilyInit(devPtr->devFamily);
    }
    else
    {
        HWINIT_GLOVAR(prvCpssFamilyInfoArray[devPtr->devFamily]->numReferences)++;
    }

    rc = setCncParameters(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : setCncParameters(..) : return code is %d", rc);
        return rc;
    }


    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* There are two non-trunk members tables in devices. First small
           one is used for cascade trunks only and second one for regular trunks. */
        PRV_CPSS_DXCH_PP_HW_INFO_TRUNK_MAC(devNum).useNonTrunkMembers2Table = GT_TRUE;
        PRV_CPSS_DXCH_PP_HW_INFO_TRUNK_MAC(devNum).useNonTrunkMembers1TableAsCascade = GT_TRUE;
        PRV_CPSS_DXCH_PP_HW_INFO_TRUNK_MAC(devNum).nonTrunkTable1NumEntries = 256;
    }

    /*initialize the DB of 'register address'*/
    rc = initRegAddrDb(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : initRegAddrDb(..) : return code is %d", rc);
        return rc;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        /* update MGCAM info by data from registers DB */
        PRV_CPSS_PP_MAC(devNum)->hwInfo.mgCam.mgcamEngineStatus  = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->MG.tableAccessControl.mgcamEngineStatus;
        PRV_CPSS_PP_MAC(devNum)->hwInfo.mgCam.mgcamEngineData    = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->MG.tableAccessControl.mgcamEngineData;
        PRV_CPSS_PP_MAC(devNum)->hwInfo.mgCam.mgcamEngineAddress = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->MG.tableAccessControl.mgcamEngineAddress;
    }

    if(drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)
    {
        /* Aldrin2 not support it since hold only 128 physical port (not 512) */
    }
    else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        /*NOTE: this parameter is relevant to bobcat3 and falcon devices ,
          because we have HW configuration for it */
        rc = internal_cpssDxChHwPpMaxNumOfPhyPortsToUseSet(devNum,ppPhase1ParamsPtr->maxNumOfPhyPortsToUse);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
    }

    if ((drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E) &&
        (devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E) &&
        (devPtr->revision == 0))
    {
        if (ppPhase1ParamsPtr->hwInfo[0].busType != CPSS_HW_INFO_BUS_TYPE_MBUS_E)
        {
            /* WA is needed only for external CPU.
               For internal CPU it will be implemented in binary header (UBOOT) */
            if (devPtr->coreClock == 25) /* PLL in BYPASS mode */
            {
                /* if application does not configured PLL core clock, WA can not be executed */
                if(ppPhase1ParamsPtr->coreClock == CPSS_DXCH_AUTO_DETECT_CORE_CLOCK_CNS)
                {
                    CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : ppPhase1ParamsPtr->coreClock == CPSS_DXCH_AUTO_DETECT_CORE_CLOCK_CNS : GT_BAD_STATE");
                    cpssOsPrintf("\n\nCore_PLL_WA: Please configure desired PLL core clock for configuration \n\n");
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                devPtr->coreClock = ppPhase1ParamsPtr->coreClock;

                /********************/
                /* Bobk Core PLL WA */
                /********************/
                if (tempSystemRecovery_Info.systemRecoveryProcess !=CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
                {
                    cpssOsPrintf("\n\nCore_PLL_WA:Manual Core CLock = %d\n\n", devPtr->coreClock);
                    if( (PRV_CPSS_SIP_5_CHECK_MAC(devNum)) &&
                        (PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE) )
                    {
                        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnits.DFXServerRegs.PLLCoreParameters;
                        rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &pllCoreParamsRegData);
                        if (rc != GT_OK)
                        {
                            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerReadReg(..) : return code is %d", rc);
                            return rc;
                        }

                        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnits.DFXServerRegs.PLLCoreConfig;
                        rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &pllCoreConfigRegData);
                        if (rc != GT_OK)
                        {
                            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerReadReg(..) : return code is %d", rc);
                            return rc;
                        }

                        switch(devPtr->coreClock)
                        {
                            case 365:
                                /*
                                    Core PLL (730 MHz)
                                    i.   bit[2:0] K div = 0x3 ( k = 4)
                                    ii.  bit [11:3]  M div = 2 ( m = 3)
                                    iii. bit [20:12] N_div = 350 ( N = 351)
                                    iv.  bit[24:21] VCO band = 0xB
                                    v.   bit [28:25]  LPF  = 1
                                    vi.  bit[31:29] Iadj = 1
                                */
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 0,  3, 3);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 3,  9, 2);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 12, 9, 350);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 21, 4, 11);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 25, 4, 1);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 29, 3, 1);

                                break;

                            case 250:

                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 0,  3, 3);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 3,  9, 0);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 12, 9, 79);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 21, 4, 6);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 25, 4, 4);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 29, 3, 1);

                                break;

                            case 200:

                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 0,  3, 3);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 3,  9, 0);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 12, 9, 63);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 21, 4, 5);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 25, 4, 4);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 29, 3, 1);

                                break;

                            case 167:

                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 0,  3, 2);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 3,  9, 1);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 12, 9, 106);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 21, 4, 3);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 25, 4, 4);
                                U32_SET_FIELD_MAC(pllCoreParamsRegData, 29, 3, 1);

                                break;

                            default:
                                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : devPtr->coreClock == %d : GT_BAD_STATE", devPtr->coreClock);
                                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                        }

                        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnits.DFXServerRegs.PLLCoreParameters;
                        rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, regAddr, pllCoreParamsRegData);
                        if (rc != GT_OK)
                        {
                            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerWriteReg(..) : return code is %d", rc);
                            return rc;
                        }

                        /*
                            i.  bit 0 core bypass   = 0
                            ii. bit 9 core Use RF Configuration  = 1
                            iii.    bit [30:11]  = 0
                        */
                        U32_SET_FIELD_MAC(pllCoreConfigRegData, 9,  1,  1);
                        U32_SET_FIELD_MAC(pllCoreConfigRegData, 11, 20, 0);

                        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnits.DFXServerRegs.PLLCoreConfig;
                        rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, regAddr, pllCoreConfigRegData);
                        if (rc != GT_OK)
                        {
                            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerWriteReg(..) : return code is %d", rc);
                            return rc;
                        }

                        U32_SET_FIELD_MAC(pllCoreConfigRegData, 0,  1,  0);
                        rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, regAddr, pllCoreConfigRegData);
                        if (rc != GT_OK)
                        {
                            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerWriteReg(..) : return code is %d", rc);
                            return rc;
                        }

                        /* Wait 1 ms for core PLL stabilization */
                        cpssOsTimerWkAfter(1);

                        /* Generate Soft reset */
                        rc = cpssDxChHwPpSoftResetSkipParamSet(devNum, CPSS_HW_PP_RESET_SKIP_TYPE_ALL_E, GT_TRUE);
                        if(GT_OK != rc)
                        {
                            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : cpssDxChHwPpSoftResetSkipParamSet(..) : return code is %d", rc);
                            return rc;
                        }

                        DXCH_HWINIT_GLOVAR(dxChHwInitSrc.isResetDbEnabled) = GT_FALSE;
                        rc = cpssDxChHwPpSoftResetTrigger(devNum);
                        if(GT_OK != rc)
                        {
                            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : cpssDxChHwPpSoftResetTrigger(..) : return code is %d", rc);
                            return rc;
                        }
                        DXCH_HWINIT_GLOVAR(dxChHwInitSrc.isResetDbEnabled) = GT_TRUE;
                    }
                }
            }
        }
        else /* ppPhase1ParamsPtr->hwInfo[0].busType == CPSS_HW_INFO_BUS_TYPE_MBUS_E */
        {
            if (devPtr->coreClock == 25) /* PLL in BYPASS mode */
            {

                if( (PRV_CPSS_SIP_5_CHECK_MAC(devNum)) &&
                    (PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE) )
                {
                    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnits.DFXServerRegs.PLLCoreParameters;
                    rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &pllCoreParamsRegData);
                    if (rc != GT_OK)
                    {
                        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerReadReg(..) : return code is %d", rc);
                        return rc;
                    }

                    switch(U32_GET_FIELD_MAC(pllCoreParamsRegData, 12, 9))
                    {
                        case 106:
                            devPtr->coreClock = 167;
                            break;

                        case 63:
                            devPtr->coreClock = 200;
                            break;

                        case 79:
                            devPtr->coreClock = 250;
                            break;

                        case 350:
                            devPtr->coreClock = 365;
                            break;

                        default:
                            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : U32_GET_FIELD_MAC(..) : GT_BAD_STATE");
                            cpssOsPrintf("Internal CPU WA error: illegal pllCoreParamsRegData configuration = %d\n", U32_GET_FIELD_MAC(pllCoreParamsRegData, 12, 9));
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                    }
                }
                else
                {
                    devPtr->coreClock = 365;
                }
            }
        }
    }

    if (tempSystemRecovery_Info.systemRecoveryProcess ==CPSS_SYSTEM_RECOVERY_PROCESS_HA_E)
    {
        GT_U32 sdma_data;
        newSystemRecoveryInfo = tempSystemRecovery_Info;
        newSystemRecoveryInfo.systemRecoveryProcess = CPSS_SYSTEM_RECOVERY_PROCESS_NOT_ACTIVE_E;
        newSystemRecoveryInfo.systemRecoveryState = CPSS_SYSTEM_RECOVERY_COMPLETION_STATE_E;
        prvCpssSystemRecoveryStateUpdate(&newSystemRecoveryInfo);
        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
        {
            /* save content of SDMA configuration register */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->sdmaRegs.sdmaCfgReg;
            rc = prvCpssHwPpReadRegister(devNum,regAddr,&sdma_data);
            if (rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc , "prvCpssHwPpReadRegister failed");
            }
            rc = prvCpssDxChManualMgSdmaReset(devNum);
            if(rc != GT_OK)
            {
                prvCpssSystemRecoveryStateUpdate(&tempSystemRecovery_Info);
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc , "prvCpssDxChManualMgSdmaReset failed");
            }
            /* return SDMA configuration register content for all mqs*/
            prvCpssDxChWriteRegisterAllMGs(devNum,regAddr,sdma_data);
        }
        prvCpssSystemRecoveryStateUpdate(&tempSystemRecovery_Info);
    }

    if(PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
    {
        rc = checkMultiPortGroupIndication(devNum,pciCompatible,&drvPpPhase1InInfo);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : checkMultiPortGroupIndication(..) : return code is %d", rc);
            return rc;
        }
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum) ||
       PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E/*ignore for now the AC3 efuse issue (if any)*/)
    {
        GT_BOOL ignoreInitDone = GT_FALSE;

        CPSS_TBD_BOOKMARK_FALCON_EMULATOR
        /* Currently receiving other value then expected from DFX indication */
        if (((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
             || (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E))
             && cpssDeviceRunCheck_onEmulator())
        {
            ignoreInitDone = GT_TRUE;
        }

        if (!((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
             (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E)    &&
             (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)) )
        {
            rc = hwPpSip5StartInitSet(devNum,ignoreInitDone);
            if(rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc , "hwPpSip5StartInitSet failed");
            }
        }
    }

    /* bind SMI related functions */
    prvCpssDxChPhySmiObjInit(devNum);
    /* init SMI/XSMI */
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    {
        rc = prvCpssSmiInit(devNum, portGroupId);
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssSmiInit(..) : return code is %d", rc);
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

    /* bind diagnostic related functions */
    prvCpssDxChDiagDataIntegrityObjInit(devNum);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* do extra SMI init before can use the SMI master(s) */
        rc = sip6SmiInitPart2(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc , "sip6SmiInitPart2 failed");
        }
    }

    /* initialize port ifMode configuration method */
    rc = prvCpssDxChPortIfCfgInit(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDxChPortIfCfgInit(..) : return code is %d", rc);
        return rc;
    }

    if(falcon_force_stop_init_after_d2d_init_get())
    {
        /* indication that the debug mode focus only on operations
           of the D2D init , and not care about later operation */
        return GT_OK;
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
    {
        /*init avs value*/
        rc = prvCpssDxChDro2AvsFalconSet(devNum);
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "hwPpPhase1Part1(): prvCpssDxChDro2AvsFalconSet() failed");
        }
        if (!((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
              (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E)) )
        {
            /* Configure MPP(GPIO) registers for connecting interrupts to Eagle */
            rc = sip6FalconInterruptsMppInit(devNum);
            if(rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc , "sip6FalconInterruptsMppInit failed");
            }
        }

        /* Mask COMPHY ECC interrupts(PIN_MEM_ECC_ERR) to Eagle */
        rc = sip6FalconComphyEccInterruptsClear(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc , "sip6FalconComphyEccInterruptsClear failed");
        }
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E ||
       PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_HARRIER_E)
    {
        /* Clean SDW PRAM ECC interrupts */
        rc = sip6HawkSdwPramEccInterruptsClear(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc , "sip6HawkSdwPramEccInterruptsClear failed");
        }
    }

    /* initialize port manager configurations */
    if (CPSS_PORT_MANAGER_CHECK_DEV_APPLICABLE_MAC(devNum))
    {
        rc = prvCpssPortManagerInit(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "hwPpPhase1Part1(..) : prvCpssDxChPortManagerInit(..) : return code is %d", rc);
        }
    }

    /*  init the common cyclic logger feature-
        The cyclic logger is needed for any state machine code.
        Currently, the cyclic logger is used by Port Manager.
    */
    rc = prvCpssCyclicLoggerInit();
    if (rc!=GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "failed init cyclic logger for common modules");
    }

    /* initialize only cpssDriver for HW access, skip the rest */
    if (DXCH_HWINIT_GLOVAR(dxChHwInitSrc.dxChInitRegDefaults) == GT_TRUE)
        return GT_OK;

#ifdef DEBUG_OPENED
    /* check that all enum value also appear in the 'strings' for debug */
    if(errataNames[PRV_CPSS_DXCH_ERRATA_MAX_NUM_E] == NULL ||
       cpssOsStrCmp(errataNames[PRV_CPSS_DXCH_ERRATA_MAX_NUM_E] , "--last one--"))
    {
        /* don't fail the initialization , only prompt about the problem */
        DUMP_PRINT_MAC(("hwPpPhase1Part1: errataNames[] not filled with all names properly \n"));
    }
#endif /*DEBUG_OPENED*/

    /* init counters modes*/
    for (i = 0; i < 2; i++)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->portGroupsExtraInfo.bridgeIngressCntrMode[i].portGroupId = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
        PRV_CPSS_DXCH_PP_MAC(devNum)->portGroupsExtraInfo.portEgressCntrModeInfo[i].portGroupId = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
    }
    PRV_CPSS_DXCH_PP_MAC(devNum)->portGroupsExtraInfo.cfgIngressDropCntrMode.portGroupId = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
    /* bind the system recovery handling functions */
    PRV_NON_SHARED_GLOBAL_VAR_SYSTEM_RECOVERY_GENERAL_VAR.prvCpssSystemRecoveryMsgDisableModeHandleFuncPtr = prvCpssDxChSystemRecoveryDisableModeHandle;
    PRV_NON_SHARED_GLOBAL_VAR_SYSTEM_RECOVERY_GENERAL_VAR.prvCpssSystemRecoveryCatchUpHandleFuncPtr = prvCpssDxChSystemRecoveryCatchUpHandle;
    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        PRV_NON_SHARED_GLOBAL_VAR_SYSTEM_RECOVERY_GENERAL_VAR.prvCpssSystemRecoveryCompletionHandleFuncPtr = prvCpssDxChSystemRecoveryCompletionHandle;
    }
    else if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        PRV_NON_SHARED_GLOBAL_VAR_SYSTEM_RECOVERY_GENERAL_VAR.prvCpssSystemRecoveryCompletionHandleFuncPtr = prvCpssDxChSystemRecoveryCompletionHandleSip5;
    }
    PRV_NON_SHARED_GLOBAL_VAR_SYSTEM_RECOVERY_GENERAL_VAR.prvCpssSystemRecoveryCompletionGenHandleFuncPtr = prvCpssDxChSystemRecoveryCompletionGenHandle;
    PRV_NON_SHARED_GLOBAL_VAR_SYSTEM_RECOVERY_GENERAL_VAR.prvCpssSystemRecoveryParallelCompletionHandleFuncPtr = prvCpssDxChSystemRecoveryParallelCompletionHandle;
    if (tempSystemRecovery_Info.systemRecoveryMode.ha2phasesInitPhase == CPSS_SYSTEM_RECOVERY_HA_2_PHASES_INIT_PHASE1_E)
    {
        PRV_NON_SHARED_GLOBAL_VAR_SYSTEM_RECOVERY_GENERAL_VAR.prvCpssSystemRecoveryHa2PhasesInitHandleFuncPtr = prvCpssSystemRecoveryHa2PhasesInitHandle;
    }
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        for (port = 0; port < devPtr->numOfPorts; port++)
        {
            /* use XSMI#0 controller to access port's PHY*/
            PRV_CPSS_PHY_XSMI_PORT_INTERFACE_MAC(devNum, port) =
                    CPSS_PHY_XSMI_INTERFACE_0_E;
        }

        /* allocate memory for the keyModePerFidBmpPtr */
        fidBitsCount = PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).fid;
        if (fidBitsCount > 32 || fidBitsCount < 5)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : fidBitsCount == %d : GT_OUT_OF_RANGE", fidBitsCount);
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        bmpBytesCount = 1 << (fidBitsCount-3); /* is always multiple to 4(GT_U32) if fidBitsCount >= 5 */
        bmpPtr = (GT_U32*) cpssOsMalloc(bmpBytesCount);
        if (NULL == bmpPtr)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : bmpPtr == NULL : GT_OUT_OF_CPU_MEM");
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }
        cpssOsMemSet(bmpPtr, 0, bmpBytesCount);
        PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.keyModePerFidBmpPtr = bmpPtr;

        hwPpPhase1DeviceSpecificIntCallbacksInit(devNum);

        if(!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            prvCpssDxChPortReservedPhysicalPortsMapSet(devNum);
        }
    }

    return GT_OK;
}



/**
* @internal hwPpPhase1Part2Config function
* @endinternal
*
* @brief   This function performs basic hardware configurations on the given PP, in
*         Hw registration phase.
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS hwPpPhase1Part2Config
(
    IN      GT_U8                                   devNum
)
{
    /* CPU enable           */
    return prvCpssHwPpSetRegField(devNum,
                                 PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.
                                 globalControl,1,1,1);
}
/*'type of resource'*/
typedef enum{
    RESOURCE_EPORTS_E,

    RESOURCE___MUST_BE_LAST_E
}RESOURCE_TYPES_ENT;
/* indication that list of devices is terminated */
#define TERMINATION_DEV_CNS   0xFFFF11AB

static const GT_U32   extraLimitationsArr[ ] = {
    /* first field is 'type of resource' (RESOURCE_TYPES_ENT) */
    RESOURCE_EPORTS_E,
        /* second field is the 'number of entries' */
        _6K,
        /* next fields are 'list of' device types */
        PRV_CPSS_AC3X_DEVICES,
        /* the termination field is last*/
        TERMINATION_DEV_CNS



    /*must be last one*/
    ,LAST_DEV_IN_LIST_CNS
};
#define NUM_EXTRA_LIMITATIONS_ARR_ENTRIES_CNS   sizeof(extraLimitationsArr)/sizeof(extraLimitationsArr[0])

/**
* @internal isDevWithLimitedResource function
* @endinternal
*
* @brief   This function check if device need to update limited resources.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] resourceType             - type of resource to check
*
* @param[out] limitedResourcePtr       - (pointer to) the limited resource value
*
* @retval GT_OK                    - there is known limitation for the resource.
* @retval GT_NOT_FOUND             - there is NO known limitation for the resource.
*                                       (value should not be changed)
* @retval GT_BAD_STATE             - the DB is corrupted (not built properly)
*                                       (ERROR that should not happen)
*/
static GT_STATUS    isDevWithLimitedResource(
    IN GT_U8   devNum,
    IN RESOURCE_TYPES_ENT  resourceType,
    OUT GT_U32      *limitedResourcePtr
)
{
    GT_U32  ii;
    GT_U32  value;
    RESOURCE_TYPES_ENT  currentResource;
    GT_U32  ownDevType = PRV_CPSS_PP_MAC(devNum)->devType;
    GT_U32  iiMax = NUM_EXTRA_LIMITATIONS_ARR_ENTRIES_CNS;

    /* check for limitations on number of resources */
    for(ii = 0 ; ((ii < iiMax) && (extraLimitationsArr[ii] !=  LAST_DEV_IN_LIST_CNS)) ; ii++)
    {
        if(ii >= (iiMax - 2))
        {
            /* sanity test to check that DB build properly */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, "array extraLimitationsArr[] not built properly");
        }

        currentResource = extraLimitationsArr[ii];
        ii++;
        value = extraLimitationsArr[ii];
        ii++;

        for( ; ((ii < iiMax) && (extraLimitationsArr[ii] != TERMINATION_DEV_CNS)) ; ii++)
        {

            if(extraLimitationsArr[ii] == ownDevType &&
               (resourceType == currentResource))
            {
                *limitedResourcePtr = value;

                /* fount match for the device type and resource type */
                return GT_OK;
            }
        }
    }

    return /* not error for log */ GT_NOT_FOUND;
}



/**
* @internal hwPpPhase1Part2Enhanced_common function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given
*         any device with features set in table format.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] tablesSize               - number of elements in the 'fine tunning' table array(parameter tablePtr)
* @param[in] tablePtr                 - (array of) the table with the 'fine tuning' parameters
* @param[in] bufferMemoryTableSize    - number of elements in the 'buffer memory' table array(parameter bufferMemoryTablePtr)
* @param[in] bufferMemoryTablePtr     - (array of) the table with the 'buffer memory' parameters
*
* @retval GT_OK                    - on success
* @retval GT_NOT_SUPPORTED         - the device not found in the DB
*/
static GT_STATUS hwPpPhase1Part2Enhanced_common
(
    IN GT_U8   devNum,
    IN GT_U32  tablesSize,
    IN const FINE_TUNING_STC *tablePtr,
    IN GT_U32  bufferMemoryTableSize,
    IN FINE_TUNING_BUFFER_MANAGEMENT_PARAMS_STC *bufferMemoryTablePtr
)
{
    GT_STATUS   rc;/* return code*/
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr = &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;
    GT_U32  ii,jj;/*iterators*/
    GT_BOOL found = GT_FALSE;
    GT_U32  totalCncCountersNeeded;
    GT_U32  tmpValue;/* temp value */

    /* first set the 'Fine tuning' parameters , from the DB */
    for(ii = 0 ; ii < tablesSize ; ii++)
    {
        for(jj = 0 ; tablePtr[ii].devTypePtr[jj] != LAST_DEV_IN_LIST_CNS ; jj++)
        {
            if(tablePtr[ii].devTypePtr[jj] == PRV_CPSS_PP_MAC(devNum)->devType)
            {
                /* found the device type */

                /* copy it's info */
                fineTuningPtr->tableSize = tablePtr[ii].config.tableSize;

                fineTuningPtr->featureInfo = tablePtr[ii].config.featureInfo;

                found = GT_TRUE;
                break;
            }
        }

        if(found == GT_TRUE)
        {
            break;
        }
    }

    if(found == GT_FALSE)
    {
        /* the device type not supported in the DB */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    found = GT_FALSE;

    /* now set the 'Buffer memory' parameters of the 'Fine tuning' parameters , from the DB */

    for(ii = 0 ; ii < bufferMemoryTableSize ; ii++)
    {
        for(jj = 0 ; bufferMemoryTablePtr[ii].devTypePtr[jj] != LAST_DEV_IN_LIST_CNS ; jj++)
        {
            if(bufferMemoryTablePtr[ii].devTypePtr[jj] == PRV_CPSS_PP_MAC(devNum)->devType)
            {
                /* found the device type */

                /* copy it's info */
                fineTuningPtr->tableSize.bufferMemory = bufferMemoryTablePtr[ii].config.bufferMemory;
                fineTuningPtr->tableSize.transmitDescr = bufferMemoryTablePtr[ii].config.transmitDescr;

                found = GT_TRUE;
                break;
            }
        }

        if(found == GT_TRUE)
        {
            break;
        }
    }

    if(fineTuningPtr->tableSize.transmitDescr == AUTO_CALC_FIELD_CNS)
    {
        fineTuningPtr->tableSize.transmitDescr =
            fineTuningPtr->tableSize.bufferMemory / _2K;/* 2K = 8bits * 256Bytes per buffer */
    }

    if(fineTuningPtr->tableSize.routerArp == AUTO_CALC_FIELD_CNS)
    {
        fineTuningPtr->tableSize.routerArp =
            fineTuningPtr->tableSize.tunnelStart * 4; /* the number of ARP entries: ARP = TS*4 */
    }

    /*  fix errata -- table sizes */

    if(fineTuningPtr->tableSize.cncBlocks == CNC_AUTO_CALC)
    {
        /* support auto calculation */
        totalCncCountersNeeded = fineTuningPtr->tableSize.cncBlockNumEntries;
    }
    else
    {
        /* support explicit value definitions */
        totalCncCountersNeeded = fineTuningPtr->tableSize.cncBlockNumEntries *
                                 fineTuningPtr->tableSize.cncBlocks;
    }

    if(totalCncCountersNeeded != 0)
    {
        /* update value - to support actual device silicon values */
        fineTuningPtr->tableSize.cncBlockNumEntries = PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries;
        /* calculate the number of CNC blocks needed to support the total number of CNC counters */
        fineTuningPtr->tableSize.cncBlocks =
            (totalCncCountersNeeded + (PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries-1)) /
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries;

        /* check that the fine tuning value not overrun the HW max support */
        if(fineTuningPtr->tableSize.cncBlocks >
           (PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks
            * PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits))
        {
            /* Error in fine tuning or in calculation */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }

    if (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX8332_Z0_CNS)
    {
        /* Set TTI,IPLR/EPLR tables size for Aldrin-Z0 */
        fineTuningPtr->tableSize.tunnelTerm = _9K;
        fineTuningPtr->tableSize.policersNum = _2K;
        fineTuningPtr->tableSize.egressPolicersNum = _2K;
    }

    /* support 'auto calc' for pcl rules to be like tti rules , as those share the same tcam */
    if(fineTuningPtr->tableSize.policyTcamRaws == PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC)
    {
        fineTuningPtr->tableSize.policyTcamRaws = fineTuningPtr->tableSize.tunnelTerm;
    }

    /* support 'auto calc' for number of trunks */
    if(fineTuningPtr->tableSize.trunksNum == TRUNK_NUM_MAX_AUTO_CALC)
    {
        CPSS_TBD_BOOKMARK
        /* limited by 8K entries in the L2ECMP table -
           since we HARD coded split it (4K entries) for trunks with 8 members */
        /* value should be PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum); */
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            tmpValue = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL2Ecmp;
                /* can not use next :
                    PRV_CPSS_DXCH_PP_MAC(devNum)->accessTableInfoPtr[
                        CPSS_DXCH_SIP5_TABLE_EQ_L2_ECMP_E].maxNumOfEntries;
                    because not initialized yet !
                */
            /* full table size */
            PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.l2EcmpNumMembers = tmpValue;

            /* 4K trunks regardless to L2 ECMP table size */
            fineTuningPtr->tableSize.trunksNum = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum);
        }
        else
        {
            fineTuningPtr->tableSize.trunksNum = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum);
        }
    }
    else if(fineTuningPtr->tableSize.trunksNum & TRUNK_L2_ECMP_NUM_MEMBERS_INDICATION_CNS)
    {
        if (fineTuningPtr->tableSize.trunksNum & TRUNK_EQUAL_L2_ECMP_NUM_MEMBERS_INDICATION_CNS)
        {
            /* indicates that 'L2Ecmp number of members == number of trunk entries' */
            tmpValue = fineTuningPtr->tableSize.trunksNum & (~TRUNK_L2_ECMP_NUM_MEMBERS_INDICATION_CNS)
                                                          & (~TRUNK_EQUAL_L2_ECMP_NUM_MEMBERS_INDICATION_CNS);

            PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.l2EcmpNumMembers = tmpValue;
            /* trunks equals L2 ECMP table size */
            fineTuningPtr->tableSize.trunksNum = PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.l2EcmpNumMembers;
        }
        else
        {
            /* indication that the value is 'L2Ecmp/trunk - number of members' and not 'trunk entries' */
            tmpValue = fineTuningPtr->tableSize.trunksNum & (~TRUNK_L2_ECMP_NUM_MEMBERS_INDICATION_CNS);
            /* full table size */
            PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.l2EcmpNumMembers = tmpValue;
            /* 4K trunks regardless to L2 ECMP table size */
            fineTuningPtr->tableSize.trunksNum = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum);
        }
    }
    else if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        tmpValue = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL2Ecmp;
            /* can not use next :
                PRV_CPSS_DXCH_PP_MAC(devNum)->accessTableInfoPtr[
                    CPSS_DXCH_SIP5_TABLE_EQ_L2_ECMP_E].maxNumOfEntries;
                because not initialized yet !
            */
        /* full table size */
        PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.l2EcmpNumMembers = tmpValue;
    }


    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE &&
       PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.l2EcmpNumMembers == 0 )
    {
        /* Error in fine tuning */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* check it anyway to see we not miscalculated */
    if(fineTuningPtr->tableSize.trunksNum >
       PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum))
    {
        /* Error in fine tuning */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    fineTuningPtr->featureInfo.TmSupported = GT_FALSE;/*support for BC3*/
    /* BC2 supported features */
    /* Enable TM for BC2, BobK-Cetus, Bobk-Caelum */
    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
    {
        switch(PRV_CPSS_PP_MAC(devNum)->devSubFamily)
        {
            case CPSS_PP_SUB_FAMILY_NONE_E:
                /*Bobcat2 devices*/
                fineTuningPtr->featureInfo.TmSupported = GT_TRUE;
                break;
            case CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E:
                /*BobK devices*/
                switch (PRV_CPSS_PP_MAC(devNum)->devType)
                {
                    /* Cetus */
                    case CPSS_98DX4235_CNS:
                        fineTuningPtr->featureInfo.TmSupported = GT_TRUE;
                        break;

                    /* Caelum */
                    case CPSS_98DX42KK_CNS:
                    case CPSS_98DX4203_CNS:
                    case CPSS_98DX4204_CNS:
                        fineTuningPtr->featureInfo.TmSupported = GT_TRUE;
                        break;
                }
                break; /* case CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E */
            default:
                break;
        }

        /* verify TM HW is Enabled */
        if (fineTuningPtr->featureInfo.TmSupported == GT_TRUE)
        {
            tmpValue = 0;
            prvCpssDxChTMFreqGet(devNum, &tmpValue);

            if (tmpValue == 0) /* tm DRAM Frequency */
            {
                fineTuningPtr->featureInfo.TmSupported = GT_FALSE;
            }
            CPSS_LOG_INFORMATION_MAC("HwInit: Tm HW is disabled\n");
        }
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        #define LIMIT_FINE_TUNING_MAC(fineTune , maxLimit) \
            if((maxLimit) && fineTune > (maxLimit))    \
            {                                              \
                fineTune = maxLimit;                       \
            }

        /* make sure that the fine tuning is not more than the actual supported entries ! */
        LIMIT_FINE_TUNING_MAC(PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.trunksNum,
            (PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).trunkId - 1));
        LIMIT_FINE_TUNING_MAC(PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.stgNum,
            (PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).stgId));
        LIMIT_FINE_TUNING_MAC(PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.vidxNum,
            (PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vidx));
    }
    else
    {
        if(PRV_CPSS_DXCH_BMP_OF_TABLES_IN_HALF_SIZE_MODE_GET_MAC(devNum,CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_NON_TRUNK_MEMBERS2_E))
        {
            fineTuningPtr->tableSize.trunksNum /= 2;
            CPSS_LOG_INFORMATION_MAC("Table [%s] new num of entries [%d] \n",
                "Trunks",
                fineTuningPtr->tableSize.trunksNum);
        }

        if(PRV_CPSS_DXCH_BMP_OF_TABLES_IN_HALF_SIZE_MODE_GET_MAC(devNum,CPSS_DXCH_LION_TABLE_STG_EGRESS_E))
        {
            fineTuningPtr->tableSize.stgNum /= 2;
            CPSS_LOG_INFORMATION_MAC("Table [%s] new num of entries [%d] \n",
                "STG",
                fineTuningPtr->tableSize.stgNum);
        }
    }

    /* check for limited eports */
    rc = isDevWithLimitedResource(devNum,RESOURCE_EPORTS_E,&tmpValue);
    if(rc == GT_OK)
    {
        PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).ePort = tmpValue;
    }
    else
    /* NOTE: GT_NOT_FOUND is NOT error */
    if (rc != GT_NOT_FOUND)
    {
        return rc;
    }




    return GT_OK;
}

/**
* @internal hwPpPhase1Part2Enhanced_xcat function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given
*         DxCh xCat device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part2Enhanced_xcat
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;       /* return code       */
    GT_U32    i;
    GT_U32    hwValue;
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr =
        &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        rc = hwPpPhase1Part2Enhanced_common(devNum,
                dxChXcatTables_size,dxChXcatTables, 0, NULL);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else   /*AC5*/
    {
        rc = hwPpPhase1Part2Enhanced_common(devNum,
                dxChAc5Tables_size,dxChAc5Tables, 0, NULL);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* PCL TCAM size in 4-STD-rule rows */
    switch (fineTuningPtr->tableSize.policyTcamRaws)
    {
        case 768: hwValue = 0; break;
        case 512: hwValue = 1; break;
        case 384: hwValue = 1; break;
        case 256: hwValue = 2; break;
        case 128: hwValue = 2; break;
        case 0: hwValue = 0xFFFFFFFF; break; /* skip configuration */
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    if (hwValue != 0xFFFFFFFF)
    {
        if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
        {
            /* POLICY TCAM  size */
            rc = prvCpssHwPpSetRegField(
                devNum,
                PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.pclRegs.pclTcamConfig0,
                1, 4, hwValue);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        else /* AC5 */
        {
            for (i = 0; (i < 2); i++)
            {
                /* POLICY TCAM  size */
                rc = prvCpssHwPpSetRegField(
                    devNum,
                    PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.pclRegs.tcamConfigRegister0Arr[i],
                    1, 4, hwValue);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }
        }
    }

    return GT_OK;
}

/**
* @internal hwPpPhase1Part2Enhanced_lion2 function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given
*         DxCh Lion2 device.
*
* @note   APPLICABLE DEVICES:      Lion2
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman
*
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part2Enhanced_lion2
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;

    rc = hwPpPhase1Part2Enhanced_common(devNum,
            lion2Tables_size,lion2Tables, 0 , NULL);
    return rc;
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet
*
* DESCRIPTION:
*       This function returns supported bandwidth by dev family/reviosion/corecolock
*
* APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;* Falcon; AC5P; AC5X; Harrier; Ironman.
*
* NOT APPLICABLE DEVICES:  None.
*
* INPUTS:
*       family       - device family
*       revision     - device revision
*       coreClockMHz - core clock in MHz
*
* OUTPUTS:
*       pipeBWCapacityInGbpsPtr - pointer to bw coreesponding to dev family/reviosion/corecolock
*
* RETURNS:
*       GT_OK            - on success
*       GT_BAD_PTR       - on error
*       GT_NOT_SUPPORTED - on device family/revison/coreclock not found
*
* COMMENTS:
*       None.
*
******************************************************************************/
typedef struct PRV_CPSS_DXCH_CORECLOCK_BW_STC
{
    GT_U32 coreClockMHz;
    GT_U32 gopBWGpbs;
}PRV_CPSS_DXCH_CORECLOCK_BW_STC;


typedef struct PRV_CPSS_DXCH_DEV_REV_x_CC_BW_STC
{
    CPSS_PP_FAMILY_TYPE_ENT         family;
    CPSS_PP_SUB_FAMILY_TYPE_ENT     subfamily;
    GT_U32                          revision;
    GT_U32                          pipeEnableBitMap;
    const PRV_CPSS_DXCH_CORECLOCK_BW_STC *coreClockBWListPtr;
}PRV_CPSS_DXCH_DEV_REV_x_CC_BW_STC;

static const PRV_CPSS_DXCH_CORECLOCK_BW_STC bobcat2_A0_coreClockBw [] =
{
   /* ccMHz,  gopBWGpbs */
      { 221,   67 }
     ,{ 250,   84 }
     ,{ 362,  120 }
   /*,{ 400,      } */ /* NOT SUPPORTED */
   /*,{ 450,      } */ /* NOT SUPPORTED */
   /*,{ 500,      } */ /* NOT SUPPORTED */
     ,{ 521,  168 }
     ,{   0,    0 }  /* last item in list  */
};

static const PRV_CPSS_DXCH_CORECLOCK_BW_STC bobcat2_B0_coreClockBw [] =
{
  /* ccMHz,  gopBWGpbs */
     { 175,   58 }
    ,{ 200,   67 }
    ,{ 221,   67 }
    ,{ 250,   84 }
    ,{ 362,  120 }
    ,{ 365,  121 }
 /* ,{ 400,    0 }  *//* NOT SUPPORTED */
 /* ,{ 450,    0 }  *//* NOT SUPPORTED */
    ,{ 521,  168 }
    ,{   0,    0 }  /* last item in list  */
};

static const PRV_CPSS_DXCH_CORECLOCK_BW_STC bobcat2_BobK_Pipe1_coreClockBw [] =
{
  /* ccMHz,  gopBWGpbs */
     { 167,   67 }
    ,{ 200,  101 }
    ,{ 250,  121 }
    ,{ 365,  185 }
    ,{   0,    0 }  /* last item in list  */
};

#define BOBCAT3_GOP_BW_GPBS_CNS 340 /* need to be 1.86T , but limited by PRV_CPSS_DXCH_BC2_PA_MAP_TOTAL_FLDS_REG_CNS */
static const PRV_CPSS_DXCH_CORECLOCK_BW_STC bobcat3_A0_coreClockBw [] =
{
  /* ccMHz,  gopBWGpbs */
     {  425 , 1140}
    ,{  525 , 1860}
    ,{  572 , 2040}
    ,{  600 , 2040}
    ,{  625 , 2040}
    ,{    0 ,    0}
};

static const PRV_CPSS_DXCH_CORECLOCK_BW_STC aldrin_coreClockBw [] =
{
  /* ccMHz,  gopBWGpbs */
     { 200,  121 }
    ,{ 250,  161 }
    ,{ 365,  321 }
    ,{ 480,  384 }
    ,{   0,    0 }  /* last item in list  */
};

static const PRV_CPSS_DXCH_CORECLOCK_BW_STC aldrin2_A0_coreClockBw [] =
{
  /* ccMHz,  gopBWGpbs */
     {  450 ,  900}
    ,{  525 , 1050}
    ,{  600 , 1090}
    ,{   0,    0 }  /* last item in list  */
};


static const PRV_CPSS_DXCH_DEV_REV_x_CC_BW_STC devRev_x_CcBwList[] =
{
      /* dev                          subfamily                                revision,           pipeBmp, core clock x BW table */
     { CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_NONE_E,        /*BC2 A0 rev */ 0,             0x1, &bobcat2_A0_coreClockBw[0]                  }
    ,{ CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_NONE_E,        /*BC2 B0 rev */ 1,             0x1, &bobcat2_B0_coreClockBw[0]                  }
    ,{ CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E,                0, /*pipe-0-1*/0x3, &bobcat2_BobK_Pipe1_coreClockBw[0]          }
    ,{ CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E,                0, /*pipe-1  */0x2, &bobcat2_BobK_Pipe1_coreClockBw[0]          }
    ,{ CPSS_PP_FAMILY_DXCH_BOBCAT3_E, CPSS_PP_SUB_FAMILY_NONE_E,/*BC3 A0 rev */         0,             0x1, &bobcat3_A0_coreClockBw[0]                  }
    ,{ CPSS_PP_FAMILY_DXCH_ALDRIN_E,  CPSS_PP_SUB_FAMILY_NONE_E,/*Aldrin A0 rev */      0,             0x7, &aldrin_coreClockBw[0]                      }
    ,{ CPSS_PP_FAMILY_DXCH_AC3X_E,    CPSS_PP_SUB_FAMILY_NONE_E,/*AC3X rev */           0,             0x7, &aldrin_coreClockBw[0]                      }
    ,{ CPSS_PP_FAMILY_DXCH_ALDRIN2_E, CPSS_PP_SUB_FAMILY_NONE_E,/*Aldrin2 A0 rev */     0,             0x1, &aldrin2_A0_coreClockBw[0]               }
    ,{ CPSS_MAX_FAMILY              , CPSS_MAX_SUB_FAMILY,                   (GT_U32)(~0),             0x0, (PRV_CPSS_DXCH_CORECLOCK_BW_STC*)NULL       }
};

static GT_U32 internal_hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet
(
    IN  GT_U8    devNum,
    OUT GT_U32  *pipeBWCapacityInGbpsPtr
)
{
    PRV_CPSS_DXCH_PP_CONFIG_STC *pDev;
    const PRV_CPSS_DXCH_DEV_REV_x_CC_BW_STC * devRevPtr;
    const PRV_CPSS_DXCH_CORECLOCK_BW_STC    * coreClockBwPtr;
    GT_U32                              min_distance;
    GT_U32                              cur_distance;
    const PRV_CPSS_DXCH_CORECLOCK_BW_STC     *suitableRevCoreClockBWListPtr;
    CPSS_PP_FAMILY_TYPE_ENT             family;
    CPSS_PP_SUB_FAMILY_TYPE_ENT         subfamily;
    GT_U32                              revision;
    GT_U32                              coreClockMHz;


    if (pipeBWCapacityInGbpsPtr == NULL)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PTR, LOG_ERROR_NO_MSG);
    }

    pDev = PRV_CPSS_DXCH_PP_MAC(devNum);
    family       = pDev->genInfo.devFamily;
    subfamily    = pDev->genInfo.devSubFamily;
    revision     = pDev->genInfo.revision;
    coreClockMHz = pDev->genInfo.coreClock;
    /*-------------------------------------------------------------*/
    /* search greatest smaller or equal to than requested revision */
    /*-------------------------------------------------------------*/
    suitableRevCoreClockBWListPtr = NULL;
    min_distance                  = (GT_U32)(~0);
    for (devRevPtr = &devRev_x_CcBwList[0]; devRevPtr->family != CPSS_MAX_FAMILY; devRevPtr++)
    {
        if (devRevPtr->family == family && devRevPtr->revision <= revision && devRevPtr->subfamily == subfamily)
        {
            cur_distance = revision - devRevPtr->revision;
            if (cur_distance < min_distance)
            {
                min_distance = cur_distance;
                suitableRevCoreClockBWListPtr = devRevPtr->coreClockBWListPtr;
            }
        }
    }

    if (suitableRevCoreClockBWListPtr != NULL) /* suitable coreclock list is found */
    {
        for (coreClockBwPtr = suitableRevCoreClockBWListPtr; coreClockBwPtr->coreClockMHz != 0; coreClockBwPtr++)
        {
            if (coreClockBwPtr->coreClockMHz == coreClockMHz)
            {
                *pipeBWCapacityInGbpsPtr = coreClockBwPtr->gopBWGpbs;
                return GT_OK;
            }
        }
    }
    *pipeBWCapacityInGbpsPtr = 0;
    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG); /* not supported */
}


GT_U32 hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet
(
    IN  GT_U8    devNum,
        OUT GT_U32  *pipeBWCapacityInGbpsPtr
)
{
    return internal_hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet(devNum,/*OUT*/pipeBWCapacityInGbpsPtr);
}

/**
* @internal hwPpPhase1Part2Enhanced_bobcat2 function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given
*         Bobcat2 device.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part2Enhanced_bobcat2
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;
    PRV_CPSS_DXCH_PP_CONFIG_STC *pDev;

    rc = hwPpPhase1Part2Enhanced_common(devNum,bobcat2Tables_size, bobcat2Tables, 0 , NULL);
    if (rc != GT_OK)
    {
        return rc;
    }

    pDev = PRV_CPSS_DXCH_PP_MAC(devNum);

    rc = internal_hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet(devNum,/*OUT*/&pDev->fineTuning.tableSize.pipeBWCapacityInGbps);
    if (rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/**
* @internal hwPpPhase1Part2Enhanced_bobcat3 function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given
*         Bobcat3 device.
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X.
*
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part2Enhanced_bobcat3
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;
    PRV_CPSS_DXCH_PP_CONFIG_STC *pDev;
    GT_BOOL isArmstrong = GT_FALSE;
    GT_BOOL isAldrin_XL = GT_FALSE;

    pDev = PRV_CPSS_DXCH_PP_MAC(devNum);

    switch(pDev->genInfo.devType)
    {
        case CPSS_ARMSTRONG_ALL_DEVICES_CASES_MAC:
            isArmstrong = GT_TRUE;
            break;
        case CPSS_98DX8572_CNS:
            isAldrin_XL = GT_TRUE;
            break;
        default:
            isArmstrong = GT_FALSE;
            break;
    }

    if(isArmstrong == GT_FALSE)
    {
        if (isAldrin_XL == GT_TRUE)
        {
            rc = hwPpPhase1Part2Enhanced_common(devNum, aldrinXlTables_size, aldrinXlTables, 0, NULL);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            rc = hwPpPhase1Part2Enhanced_common(devNum, bobcat3Tables_size, bobcat3Tables, 0, NULL);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }
    else
    {
        rc = hwPpPhase1Part2Enhanced_common(devNum, armstrongTables_size, armstrongTables, 0, NULL);
        if (rc != GT_OK)
        {
            return rc;
        }

        switch(pDev->genInfo.devType)
        {
            case CPSS_98EX5410_CNS:
                /* hold single difference from its 'group' */
                pDev->fineTuning.tableSize.transmitDescr = 48*_1K;
                break;
            default:
                break;
        }
    }

    rc = hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet(devNum, /*OUT*/&pDev->fineTuning.tableSize.pipeBWCapacityInGbps);
    if (rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/**
* @internal hwPpPhase1Part2Enhanced_aldrin2 function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given
*         Aldrin2 device.
*
* @note   APPLICABLE DEVICES:      Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part2Enhanced_aldrin2
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;
    PRV_CPSS_DXCH_PP_CONFIG_STC *pDev;

    pDev = PRV_CPSS_DXCH_PP_MAC(devNum);

    rc = hwPpPhase1Part2Enhanced_common(devNum,aldrin2Tables_size, aldrin2Tables, 0 , NULL);
    if (rc != GT_OK)
    {
        return rc;
    }

    rc = hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet(devNum, /*OUT*/&pDev->fineTuning.tableSize.pipeBWCapacityInGbps);
    if (rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/**
* @internal hwPpPhase1Part2Enhanced_falcon function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given
*         Falcon device.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part2Enhanced_falcon
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;

    /* pDev->fineTuning.tableSize.pipeBWCapacityInGbps is not used for SIP_6 devices.
       Skip pipeBWCapacityInGbps calculation logic for Falcon. */

    rc = hwPpPhase1Part2Enhanced_common(devNum,falconTables_size, falconTables, 0 , NULL);
    return rc;
}

/**
* @internal hwPpPhase1Part2Enhanced_hawk function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given
*         Hawk device.
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part2Enhanced_hawk
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;

    /* pDev->fineTuning.tableSize.pipeBWCapacityInGbps is not used for SIP_6 devices.
       Skip pipeBWCapacityInGbps calculation logic for Falcon. */

    rc = hwPpPhase1Part2Enhanced_common(devNum,hawkTables_size, hawkTables, 0 , NULL);
    return rc;
}
/**
* @internal hwPpPhase1Part2Enhanced_phoenix function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given
*         Phoenix device.
*
* @note   APPLICABLE DEVICES:      AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P.
*
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part2Enhanced_phoenix
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;
    FINE_TUNING_STC fineTuningGenericTable = phoenixTables[0];
    const FINE_TUNING_STC *fineTuningtablePtr = phoenixTables;
    GT_U32 fineTuningtable_size = phoenixTables_size;

    switch (PRV_CPSS_PP_MAC(devNum)->devType)
    {
        case PRV_CPSS_AC5X_TCAM_REDUCED_DEVICES:
            fineTuningtablePtr = &fineTuningGenericTable;
            fineTuningGenericTable.config.tableSize.tunnelTerm = _12K;
            fineTuningtable_size = 1;
            break;
        default:
            break;
    }

    switch (PRV_CPSS_PP_MAC(devNum)->devType)
    {
        case PRV_CPSS_AC5X_EM_REDUCED_DEVICES:
            fineTuningtablePtr = &fineTuningGenericTable;
            fineTuningGenericTable.config.tableSize.emNum = _16K;
            fineTuningtable_size = 1;
            break;
        default:
            break;
    }


    /* pDev->fineTuning.tableSize.pipeBWCapacityInGbps is not used for SIP_6 devices.
       Skip pipeBWCapacityInGbps calculation logic for Falcon. */

    rc = hwPpPhase1Part2Enhanced_common(devNum, fineTuningtable_size, fineTuningtablePtr, 0 , NULL);
    return rc;
}

/**
* @internal hwPpPhase1Part2Enhanced_harrier function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given
*         Harrier device.
*
* @note   APPLICABLE DEVICES:      Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part2Enhanced_harrier
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;

    /* pDev->fineTuning.tableSize.pipeBWCapacityInGbps is not used for SIP_6 devices.
       Skip pipeBWCapacityInGbps calculation logic for Falcon. */

    rc = hwPpPhase1Part2Enhanced_common(devNum,harrierTables_size, harrierTables, 0 , NULL);
    return rc;
}

/**
* @internal hwPpPhase1Part2Enhanced_sip6_generic function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given
*         Harrier device.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part2Enhanced_sip6_generic
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;

    /* pDev->fineTuning.tableSize.pipeBWCapacityInGbps is not used for SIP_6 devices.
       Skip pipeBWCapacityInGbps calculation logic for Falcon. */

    rc = hwPpPhase1Part2Enhanced_common(devNum,
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.myFamilyFineTuningSize,
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.myFamilyFineTuningPtr,
        0 , NULL);
    return rc;
}
/**
* @internal hwPpPhase1Part2Enhanced function
* @endinternal
*
* @brief   This function performs Enhanced SW configurations for the given PP.
*
* @param[in] devNum                   - The PP's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
*/
static GT_STATUS hwPpPhase1Part2Enhanced
(
    IN      GT_U8                                   devNum
)
{
    cpssOsMemSet(&PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning,0,
                sizeof(PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning));

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum) &&
       PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.myFamilyFineTuningSize)
    {
        /* CPSS_PP_FAMILY_DXCH_IRONMAN_E */
        return hwPpPhase1Part2Enhanced_sip6_generic(devNum);
    }

    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_CASES_MAC:
            return hwPpPhase1Part2Enhanced_xcat(devNum);
        case CPSS_PP_FAMILY_DXCH_LION2_E:
            return hwPpPhase1Part2Enhanced_lion2(devNum);
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
        case CPSS_PP_FAMILY_DXCH_AC3X_E:
            return hwPpPhase1Part2Enhanced_bobcat2(devNum);
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
            return hwPpPhase1Part2Enhanced_bobcat3(devNum);
        case CPSS_PP_FAMILY_DXCH_ALDRIN2_E:
            return hwPpPhase1Part2Enhanced_aldrin2(devNum);
        case CPSS_PP_FAMILY_DXCH_FALCON_E:
            return hwPpPhase1Part2Enhanced_falcon(devNum);
        case CPSS_PP_FAMILY_DXCH_AC5P_E:
            return hwPpPhase1Part2Enhanced_hawk(devNum);
        case CPSS_PP_FAMILY_DXCH_AC5X_E:
            return hwPpPhase1Part2Enhanced_phoenix(devNum);
        case CPSS_PP_FAMILY_DXCH_HARRIER_E:
            return hwPpPhase1Part2Enhanced_harrier(devNum);
        /* NOTE : CPSS_PP_FAMILY_DXCH_IRONMAN_E covered by call to
            hwPpPhase1Part2Enhanced_sip6_generic(...)
            see above */
        default:
            return GT_OK;
    }
}

/**
* @internal hwPpPhase1Part2FineTuneUpdate function
* @endinternal
*
* @brief   update 'fineTuning' according to 'hwInfo'.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The Pp's device number
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS hwPpPhase1Part2FineTuneUpdate
(
    IN  GT_U8                               devNum
)
{
    /* only now that the 'fineTuning' was set , we can modify values in it , in common logic */
    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.plrInfo.notSupportIngressPlr1 == GT_TRUE)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.featureInfo.iplrSecondStageSupported = GT_FALSE;
    }

    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.plrInfo.notSupportEgressPlr  == GT_TRUE)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.egressPolicersNum = 0;
    }

    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.ha.noTunnelStartSupport == GT_TRUE)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.tunnelStart = 0;
    }

    return GT_OK;
}
/**
* @internal hwPpPhase1Part2 function
* @endinternal
*
* @brief   Part 2 of "phase 1"
*         This routine initialize the board specific parameters and registers
*         the packet processor for pre-discovery phase access and diagnostics.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The Pp's device number
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS hwPpPhase1Part2
(
    IN  GT_U8                               devNum
)
{
    GT_STATUS           rc;

    /* Set basic device registration parameters.     */
    rc = hwPpPhase1Part2Config(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part2(..) : hwPpPhase1Part2Config(..) : return code is %d", rc);
        return rc;
    }

    /* only now the 'fineTuning' will be set */
    /* Set Enhanced device capabilities parameters.     */
    rc = hwPpPhase1Part2Enhanced(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part2(..) : hwPpPhase1Part2Enhanced(..) : return code is %d", rc);
    }

    /* now we can update 'fineTuning' according to 'hwInfo' */
    rc = hwPpPhase1Part2FineTuneUpdate(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc,LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @struct PRV_CPSS_HW_INIT_MPP_STC
 *
 * @brief This struct contains information about MPP configuration.
*/
typedef struct {
    /** MPP number */
    GT_U32 mppNum;

    /** value of MPP Select */
    GT_U32 mppSelect;
} PRV_CPSS_HW_INIT_MPP_STC;

/**
* @internal hwPpDxChMppListConfig function
* @endinternal
*
* @brief   Configure list of MPPs
*
* @note   APPLICABLE DEVICES:      AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                   - device number
* @param[in] mppListArr               - list of MPP configurations
* @param[in] mppListSize              - size of MPP list
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
static GT_STATUS hwPpDxChMppListConfig
(
    IN GT_U8 devNum,
    IN PRV_CPSS_HW_INIT_MPP_STC const mppListArr[],
    IN GT_U32 mppListSize
)
{
    GT_STATUS   rc; /* return code */
    GT_U32      ii; /* iterator */

    for (ii = 0; ii < mppListSize; ii++)
    {
        rc = cpssDxChHwMppSelectSet(devNum, mppListArr[ii].mppNum, mppListArr[ii].mppSelect);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal hwPpDxChAc5RegsDefault function
* @endinternal
*
* @brief   Set mandatory default values for AC5 registers
*
* @note   APPLICABLE DEVICES:      AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
static GT_STATUS hwPpDxChAc5RegsDefault
(
    IN GT_U8                                    devNum
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;    /* register address */
    GT_U32      i;          /* loop iterator */
    CPSS_SYSTEM_RECOVERY_INFO_STC tempSystemRecovery_Info; /* holds system recovery information */
    PRV_CPSS_HW_INIT_MPP_STC const mppList[] = {/* Set MPP 28,29 (SMI interface 0) 30,31 (SMI interface 1) */
                                              {28,2}, {29,2}, {30,2}, {31,2},
                                              /* Set MPP 38, 39 to work with SyncE */
                                              {38,1}, {39,1},
                                              /* Set MPP 36,37,40,43,44,45 to output LED signals */
                                              {36,1}, {37,1}, {40,1}, {43,1}, {44,1}, {45,1}};

    rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
    if (rc != GT_OK)
    {
        return rc;
    }
    /*in case of HA skip all HW write */
    if ((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
        (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E) )
    {
        return GT_OK;
    }

    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsDeviceSpecificRegs.deviceResetCtrl;

    /* reset device skip init controls. It can be activated after Soft Reset
       and block DFX Memories registers access. This configuration enables
       access blocked by Soft Reset. */
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 23, 1, 1);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* enable back the device skip init controls */
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 23, 1, 0);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Set Serdes REF clk:
         0 => XTAL (25MHz)
         1 => LVDS (156.25MHz/125MHz) */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl1;
    switch(PRV_CPSS_DXCH_PP_MAC(devNum)->port.serdesRefClock)
    {
        case CPSS_DXCH_PP_SERDES_REF_CLOCK_EXTERNAL_25_SINGLE_ENDED_E:
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 0, 1, 0);
            break;

        case CPSS_DXCH_PP_SERDES_REF_CLOCK_EXTERNAL_125_SINGLE_ENDED_E:
        case CPSS_DXCH_PP_SERDES_REF_CLOCK_EXTERNAL_125_DIFF_E:
        case CPSS_DXCH_PP_SERDES_REF_CLOCK_INTERNAL_125_E:
        case CPSS_DXCH_PP_SERDES_REF_CLOCK_EXTERNAL_156_25_SINGLE_ENDED_E:
        case CPSS_DXCH_PP_SERDES_REF_CLOCK_EXTERNAL_156_25_DIFF_E:
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 0, 1, 1);
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }
    if(rc != GT_OK)
    {
        return rc;
    }

    /* configure MPPs */
    rc = hwPpDxChMppListConfig(devNum, mppList, sizeof(mppList)/sizeof(mppList[0]));
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Set LED DFX related registers */

    /* Beginning of led0 chain. By default the ports don't exist */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl26;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 26, 6, 0x3F);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Beginning of led1 chain. By default the ports don't exist */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl27;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 0, 6, 0x3F);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Power-down the LDO elements */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl23;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 0x0);
    if(rc != GT_OK)
    {
        return rc;
    }
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 12, 1, 0x1);
    if(rc != GT_OK)
    {
        return rc;
    }
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 18, 3, 0x1);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* start with the same xCat3 settings */
    rc = hwPpDxChXcat3RegsDefault(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* mandatory Temperature Sensor register settings */
    rc = tseneMandatoryRegValuesSet(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                  PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_PORT_MAC_CONTROL_REG4_WA_E))
    {
        for (i = 0; i < 28; i++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, i);
            PRV_CPSS_DXCH_PORT_MAC_CTRL4_REG_MAC(devNum, i ,PRV_CPSS_PORT_GE_E, &regAddr);
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 8, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        /* configuring "hidden" MAC registers (28,29,31) */
        regAddr += 0x1000;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 8, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
        regAddr += 0x1000;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 8, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
        regAddr += 0x2000;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 8, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }/* end of PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_PORT_MAC_CONTROL_REG4_WA_E*/

    /* configure Data Integrity related interrups masks */
    rc = prvCpssDxChDiagDataIntegrityDfxServerClientsIntMaskSet(devNum,CPSS_EVENT_UNMASK_E);
    return rc;
}

/**
* @internal mandatoryRegValuesSet function
* @endinternal
*
* @brief   Set mandatory default register values
*
* @note   APPLICABLE DEVICES:       xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   None.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on other error.
*/
static GT_STATUS mandatoryRegValuesSet
(
    IN GT_U8                                    devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC       *ppPhase1ParamsPtr
)
{
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        return hwPpDxChLion2RegsDefault(devNum, ppPhase1ParamsPtr);
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
    {
        return hwPpDxChAc5RegsDefault(devNum);
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        return hwPpDxChXcat3RegsDefault(devNum);
    }

    /*Lion2*/
    return hwPpDxChLion2RegsDefault(devNum, ppPhase1ParamsPtr);
}

/**
* @internal hwPpPhase1Part3 function
* @endinternal
*
* @brief   Part 3 of "phase 1"
*         Performs configures that should be done at the end of "Phase 1" and
*         before Pp "start-init" operation.
*         Set Errata issues and registers settings.
*         function called from the "phase 1" sequence.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The Pp's device number to run the errata Wa on.
* @param[in] ppPhase1ParamsPtr        - Packet processor hardware specific parameters.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*
* @note was called "pre start init"
*
*/
static GT_STATUS hwPpPhase1Part3
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC       *ppPhase1ParamsPtr
)
{
    GT_STATUS rc; /* return code */
    CPSS_SYSTEM_RECOVERY_INFO_STC tempSystemRecovery_Info;

    /* Device number        */
    rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
    if (rc != GT_OK)
    {
        return rc;
    }
    if (tempSystemRecovery_Info.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
    {
        rc = cpssDxChCfgHwDevNumSet(devNum, devNum);
        if(GT_OK != rc)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part3(..) : cpssDxChCfgHwDevNumSet(..) : return code is %d", rc);
            return rc;
        }
    }
    else if ( (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) &&
         (PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_2_MAC(devNum) ) )
    {
             /* unmark the old HW dev number to default single mode */
            rc = cpssDxChCscdDbRemoteHwDevNumModeSet(PRV_CPSS_HW_DEV_NUM_MAC(devNum),
                                                     CPSS_GEN_CFG_HW_DEV_NUM_MODE_SINGLE_E);
            if (rc != GT_OK)
            {
                return rc;
            }

            /* mark the new HW dev as daul device in the DB */
            rc = cpssDxChCscdDbRemoteHwDevNumModeSet(devNum,
                                                     CPSS_GEN_CFG_HW_DEV_NUM_MODE_DUAL_E);
            if (rc != GT_OK)
            {
                return rc;
            }
     }
     /*Set mandatory default register values*/
     return mandatoryRegValuesSet(devNum,ppPhase1ParamsPtr);
}


/**
* @internal prvCpssDxChBobcat2PortMappingConfigSet function
* @endinternal
*
* @brief   Bobcat2 Port mapping initial configuration
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The Pp's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*/
GT_STATUS prvCpssDxChBobcat2PortMappingConfigSet
(
    IN  GT_U8  devNum
)
{
    GT_STATUS rc;       /* return code */
    GT_U32 regAddr;     /* register address */
    GT_U32 regValue;    /* register value */
    GT_U32 i;           /* loop iterator */
    CPSS_DXCH_TABLE_ENT tableType; /* table type */

    /***************************************/
    /* Bobcat2 Port Mapping Configurations */
    /***************************************/

    /* Port To DMA Map Table Configuration */
    for(i = 0; i < 72; i++)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.portToDMAMapTable[i];

        regValue = (i == CPSS_CPU_PORT_NUM_CNS) ? 72 : i;

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 8, regValue);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    /* Enable TXQ to DMA port mapping */
    regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.globalDequeueConfig;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 10, 1, 1);
    if(GT_OK != rc)
    {
        return rc;
    }

    tableType = CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_QAG_TARGET_PORT_MAPPER_E;
    /* EGF Physical port To TXQ port Table Configuration */
    for(i = 0; i < 72; i++)
    {
        /* 1:1 mapping for all TXQ ports */
        rc = prvCpssDxChWriteTableEntry(devNum, tableType, i, &i);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    return GT_OK;
}


/**
* @internal prvCpssDxChBobcat3PortMappingConfigSet function
* @endinternal
*
* @brief   Bobcat3 Port mapping initial configuration
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The Pp's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS prvCpssDxChBobcat3PortMappingConfigSet
(
    IN  GT_U8  devNum
)
{
    GT_STATUS rc;       /* return code */
    GT_U32 regAddr;     /* register address */
    GT_U32 i;     /* loop iterator */
    GT_U32 dpIndex;     /* data path index */
    GT_U32 localDmaNum; /* local DMA number 0..12 */
    GT_U32 globalDmaNum; /* local DMA number 0..72 */
    GT_U32 localDqPort; /* local DP portNumber 0..95 */
    GT_U32 globalTxqPort;/* global txq port 0..575  (575=96*6) */
    GT_U32 globalPortNum;/* global prot Num 0..255*/

    /***************************************/
    /* Bobcat3 Port Mapping Configurations */
    /***************************************/

    /* Enable TXQ to DMA port mapping */
    regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.globalDequeueConfig;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 10, 1, 1);
    if(GT_OK != rc)
    {
        return rc;
    }

    /* DQ Port To DMA Map Table Configuration */
    /* loop on all DMA numbers and do map from DQ port to those DMAs */

    for(dpIndex = 0 ;
        dpIndex < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.maxDp ;
        dpIndex++)
    {
        for(localDmaNum = 0 ;
            localDmaNum < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathNumOfPorts ;
            localDmaNum++)
        {
            if((dpIndex == 2 || dpIndex == 5)&&
               PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].cpuPortDmaNum == localDmaNum)
            {
                /* "cpu ports" on dp 2 and 5 are not real CPU ports */
                continue;
            }

            if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].cpuPortDmaNum == localDmaNum)
            {

                /* set global DMA of the CPU */
                /* BC3 dp# == dq#*/
                if (!prvCpssDxChCpuDmaNumGet(devNum,dpIndex,0,&globalDmaNum))
                {
                    CPSS_LOG_INFORMATION_MAC("prvCpssDxChBobcat3PortMappingConfigSet(..) did not find dma number for cpu port on dp %d", dpIndex);
                }
            }
            else
            {
                /* calculate the global DMA number */
                rc =  prvCpssDxChHwPpDmaLocalNumInDpToGlobalNumConvert(devNum,
                    dpIndex,
                    localDmaNum,
                    &globalDmaNum);
                if(GT_OK != rc)
                {
                    return rc;
                }

            }
            localDqPort = localDmaNum;
            /* calculate the global DQ port number */
            globalTxqPort =
                SIP_5_20_LOCAL_TXQ_DQ_PORT_TO_GLOBAL_TXQ_DQ_PORT_MAC(devNum,localDqPort,dpIndex);

            /* bind the DQ port to the DMA number */
            rc = prvCpssDxChPortMappingTxQPort2TxDMAMapSet(devNum,
                CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                globalTxqPort,
                globalDmaNum);
            if(GT_OK != rc)
            {
                return rc;
            }
        }
    }

    /* EGF Physical port To TXQ port Table Configuration */
    for(i = 0; i < PRV_CPSS_PP_MAC(devNum)->numOfPorts; i++)
    {
        globalPortNum = i;
        if( i == CPSS_CPU_PORT_NUM_CNS )
        {/**/
         /*PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.dmaNumber*/
            dpIndex = 0;
            localDmaNum = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].cpuPortDmaNum;
        }
        else
        {
            /*txq-port num --> set default to equal  'TXQ-DQ-port number' */
            /* every 12 ports move to next DQ unit */
            rc = prvCpssDxChHwPpDmaGlobalNumToLocalNumInDpConvert(
                devNum,
                i/*globalDmaNum*/,
                &dpIndex,
                &localDmaNum);
            if(GT_OK != rc)
            {
                return rc;
            }
        }

        localDqPort = localDmaNum;

        /* every 12 ports move to next DQ unit --> the globalTxqPort jump to
            next 96 ports */
        globalTxqPort =
            SIP_5_20_LOCAL_TXQ_DQ_PORT_TO_GLOBAL_TXQ_DQ_PORT_MAC(devNum,localDqPort,dpIndex);

        rc = prvCpssDxChPortMappingEGFTargetLocalPhys2TxQPortMapSet(
            devNum,
            CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
            globalPortNum, /*physical port*/
            globalTxqPort);/*txq-port num --> set default to equal  'TXQ-DQ-port number' */
        if(GT_OK != rc)
        {
            return rc;
        }
    }



    return GT_OK;
}
#if 0
/**
* @internal xcat3PllInit function
* @endinternal
*
* @brief   XCAT3 PLL init and configuration
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2.
*
* @param[in] devNum                   - The Pp's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS xcat3PllInit
(
    IN  GT_U8 devNum
)
{
    GT_STATUS   rc;         /* return code */
    GT_U32      regAddr;    /* register address */
    GT_U32      regValue;   /* register value */

    /* 1. Shut off PLL */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.pllMiscConfig;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 0, 1, 1);
    if (rc != GT_OK)
    {
        return rc;
    }


    /* 2. Disable dividers */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl10;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 8, 8, 0);
    if (rc != GT_OK)
    {
        return rc;
    }


    /* 3. Configure dividers in spare control */

    /*
        Device General Control 6:
            Misc_pll_gunit_clk_div_ratio    [12:7] -> value 0x14
        Device General Control 9:
            Misc_pll_pci_ref                [7:2]   -> value 0x19
            Misc_pll_dp_clk_div             [21:16] -> value 0x7
            Misc_pll_pci_clk_in             [27:22] -> value 0x14
    */

    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl6;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 7, 6, 0x14);
    if (rc != GT_OK)
    {
        return rc;
    }

    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl9;
    rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &regValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    U32_SET_FIELD_MAC(regValue, 2, 6, 0x19);
    U32_SET_FIELD_MAC(regValue, 16, 6, 0x7);
    U32_SET_FIELD_MAC(regValue, 22, 6, 0x14);

    rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, regAddr, regValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* 4. Configure PLL params (second is 2.5Ghz) */

    /* PLL misc Parameters register:
        Set "NDIV"      [20:12] -> value 0x63
        Set "VCO_BAND"  [24:21] -> value 0x9
    */

    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.pllMiscParameters;
    rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &regValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    U32_SET_FIELD_MAC(regValue, 12, 9, 0x63);
    U32_SET_FIELD_MAC(regValue, 21, 4, 0x9);

    rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, regAddr, regValue);
    if (rc != GT_OK)
    {
        return rc;
    }


    /* 5. Enable Use PLL RF settings */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.pllMiscConfig;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 9, 1, 1);
    if (rc != GT_OK)
    {
        return rc;
    }


    /* 6. Enable PLL */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.pllMiscConfig;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 0, 1, 0);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* 7. Wait 1ms */
    cpssOsTimerWkAfter(1);

    /* 8. Enable dividers (Spare control) */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl10;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 8, 8, 0xFF);
    return rc;
}
#endif
/**
* @internal hwPpPhase1RegisterMisconfigurationAfterTablesInit function
* @endinternal
*
* @brief   RM (Register Miss-configuration) after calling to
*         prvCpssDxChTablesAccessInit(...)
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The Pp's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS hwPpPhase1RegisterMisconfigurationAfterTablesInit
(
    IN  GT_U8               devNum
)
{
    GT_STATUS   rc;
    /* data that will be written to the table */
    GT_U32 hwDataArray[6] = {0,0,0,0,0,0};
    GT_U32    port;    /* port number */
    CPSS_PORTS_BMP_STC        portBitmap;/* bit map of ports */
    GT_U16      vidx;/* vidx */
    GT_U32      regAddr;        /* register address */
    GT_U32      data;
    GT_U32      i=0,j=0;
    GT_U32      cpuPortIndex;/* index for the SDMA cpu port */
    CPSS_DXCH_CUT_THROUGH_PACKET_HDR_INTEGRITY_CHECK_CFG_STC  ctHdrIntegrityCfg;
    CPSS_SYSTEM_RECOVERY_INFO_STC tempSystemRecovery_Info;

    if(0 == PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum))
    {
        /* not xcat and above */
        return GT_OK;
    }

    rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
    if (rc != GT_OK)
    {
        return rc;
    }
    if ((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
        (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E) )
    {
        if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)||
            (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E) ||
            (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5P_E) ||
            (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E) ||
            (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_HARRIER_E))

        {
            if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                /*init EGF qag/TC DP Mapper Table */
                rc = prvCpssDxChHwEgfQagTcDpMapperInit(devNum);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
        return GT_OK;
    }

    /* clear entry for VLAN 0 in VLAN Table */
    /* The VLAN#0 is not initialized in HW */
    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        rc = prvCpssDxChWriteTableEntry(devNum,
                                        CPSS_DXCH_TABLE_VLAN_E,
                                        0,/* vid */
                                        &hwDataArray[0]);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        /* invalidate vlan 0 */
        rc = cpssDxChBrgVlanEntryInvalidate(devNum, 0);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum))
    {
        /* set default values to L2 MLL Vidx enable table */
        for (i=0; i <= VIDX_NUM_CNS; i++)
        {
            rc = cpssDxChL2MllVidxEnableSet(devNum, (GT_U16)i, GT_FALSE);
            if(rc != GT_OK)
                return rc;
        }

        /* set default values to L2 MLL Pointer table */
        for (i=0; i <= TARGET_DEV_NUM_CNS; i++)
        {
            for(j=0; j <= TARGET_PORT_NUM_CNS; j++)
            {
                rc = cpssDxChL2MLLVirtualPortToMllMappingTableEntrySet(devNum, (GT_U8)i, (GT_U8)j, 0);
                if(rc != GT_OK)
                    return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E))
    {
        /* enable Bypass Bridge for Extended DSA tag packets */
        for( port = 0; port <= PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, port);

            rc = cpssDxChCscdPortBridgeBypassEnableSet(devNum,port,GT_TRUE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* enable on CPU port Bypass Bridge for Extended DSA tag packets */
        rc = cpssDxChCscdPortBridgeBypassEnableSet(devNum,CPSS_CPU_PORT_NUM_CNS,GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            /* set all ePort entries to support Extended DSA bypass bridge */
            for( port = 0; port < PRV_CPSS_DXCH_MAX_DEFAULT_EPORT_NUMBER_MAC(devNum); port++)
            {
                rc = cpssDxChCscdPortBridgeBypassEnableSet(devNum,port,GT_TRUE);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CONFIG_SIP_LOOKUP_E))
    {
        /* ERR-8431241 - Disable SIP lookup for packets received from the given port */
        for( port = 0; port < PRV_CPSS_DXCH_MAX_PORT_NUMBER_MAC(devNum); port++)
        {
            rc = cpssDxChLpmPortSipLookupEnableSet(devNum,port,GT_FALSE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_IPV6_TT_HBH_EXT_EXCEPTION_CMD_E))
    {
        rc = cpssDxChTtiExceptionCmdSet(devNum, CPSS_DXCH_TTI_EXCEPTION_IPV6_HBH_ERROR_E, CPSS_PACKET_CMD_FORWARD_E);
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_IPV6_TT_NON_HBH_EXT_EXCEPTION_CMD_E))
    {
        rc = cpssDxChTtiExceptionCmdSet(devNum, CPSS_DXCH_TTI_EXCEPTION_IPV6_NON_HBH_ERROR_E, CPSS_PACKET_CMD_FORWARD_E);
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
    }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CT_HEADER_INTEGRITY_EXCEPTION_CMD_E) ||
      (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CT_BC_LEN_CHECK_E)))
    {
        rc = cpssDxChCutThroughPacketHdrIntegrityCheckCfgGet(devNum, &ctHdrIntegrityCfg);
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }

        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CT_HEADER_INTEGRITY_EXCEPTION_CMD_E))
        {
            ctHdrIntegrityCfg.hdrIntergrityExceptionPktCmd = CPSS_PACKET_CMD_FORWARD_E;
        }

        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_FALCON_WRONG_DEFAULT_CT_BC_LEN_CHECK_E))
        {
            ctHdrIntegrityCfg.enableByteCountBoundariesCheck = GT_TRUE;
        }

        rc = cpssDxChCutThroughPacketHdrIntegrityCheckCfgSet(devNum, &ctHdrIntegrityCfg);
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
    }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_CPU_IN_VIDX_WA_E))
    {
        vidx = 0xFFF;
        rc = cpssDxChBrgMcEntryRead(devNum, vidx, &portBitmap);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* remove ports : 15,31,47 */
        CPSS_PORTS_BMP_PORT_CLEAR_MAC(&portBitmap,15);
        CPSS_PORTS_BMP_PORT_CLEAR_MAC(&portBitmap,31);
        CPSS_PORTS_BMP_PORT_CLEAR_MAC(&portBitmap,47);

        /* use private function to avoid flood VIDX check */
        rc = prvCpssDxChBrgMcEntryWrite(devNum, vidx, &portBitmap);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        /* next function call tables so must be called only after tables DB
           initialization */

        /* set the CPU as 2 words DSA tag */
        rc = cpssDxChCscdPortTypeSet(devNum,
            (GT_U8)CPSS_CPU_PORT_NUM_CNS,
            CPSS_PORT_DIRECTION_BOTH_E,
            CPSS_CSCD_PORT_DSA_MODE_2_WORDS_E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    /*******************************/
    /* Port Mapping Configurations */
    /*******************************/
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum))
    {
        if(!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
            if (rc != GT_OK)
            {
                return rc;
            }
            /*Virtual 2 Physical Port Remap <%n>*/
            /* set 1:1 the 'virtual port' to the physical port mapping for the
                'EGF_EFT' link up/down issues */
            if (tempSystemRecovery_Info.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
            {
                for( port = 0 ;
                     port < PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum) ;
                     port++ )
                {
                    rc = prvCpssDxChHwEgfEftFieldSet(devNum,port/*virtual port (target port)*/,
                        PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_VIRTUAL_2_PHYSICAL_PORT_REMAP_E,
                        port/*global physical port*/);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }

        /* Port To Hemisphere Mapping Reg %n */
        /* default of the device is :
            ports 0..127 --> hemisphere 0
            ports 128..255 --> hemisphere 1

            because the CPSS and simulation still uses '16 ports per port group'
            Next code will set :
            ports 64..127 --> hemisphere 1
            (not change 0..63 , 128..255)
        */
        /* there are 32 ports in each register */
        if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_MAC(devNum) == 1)
        {
            if(!PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                   /* the device has only one hemisphere. Need to reset values of
                   registers for ports 128..255 */
                GT_U32  numRegs = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts/32;
                for (i = 4; i < numRegs; i++)
                {
                    regAddr = PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).MCFIFO.MCFIFOConfigs.portToHemisphereMapReg[i];
                    rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }
        else
        {
            for(port = 64 ; port < 128 ;port++)
            {
                rc = prvCpssDxChHwEgfEftFieldSet(devNum,port,
                    PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_MC_FIFO_PORT_TO_HEMISPHERE_MAP_E,
                    1/*target hemisphere - 1*/);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }

        if(!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            /* together with the configuration from prvCpsssDxChPortMappingArgumentsBuild(...)
            it will bind 'SDMA_CPU_PORT' (63) to 'last physical port' and will set 'force link up' */
            rc = prvCpssDxChHwPpSdmaCpuPortReservedMacIdxGet(devNum,CPSS_CPU_PORT_NUM_CNS,&cpuPortIndex);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* next is ALSO to support the 'Force link UP' on 'Remote physical ports' */
            rc = prvCpssDxChHwEgfEftFieldSet(devNum,cpuPortIndex,
                PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_PHYSICAL_PORT_LINK_STATUS_MASK_E,
                1/*force link UP*/);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* next is to support the 'Force link down' on 'Remote physical ports' */
            rc = prvCpssDxChHwEgfEftFieldSet(devNum,cpuPortIndex - 1,
                PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_PHYSICAL_PORT_LINK_STATUS_MASK_E,
                2/*force link DOWN*/);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /*
               we set ALL ports to be 'force link up' , otherwise the traffic not egress event from ports with link up.
               The HW default of this 'link down' filter , is to 'filter all' ports.
               The CPSS initialization change those defaults to 'filter none'.
               The 'unaware' application will have egress traffic.(with potential unwanted replications)
               The 'aware' application will use new CPSS API to explicitly manipulate this 'link down' filter
               (without potential unwanted replications)
             */
            rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
            if (rc != GT_OK)
            {
                return rc;
            }
            if (tempSystemRecovery_Info.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_HITLESS_STARTUP_E)
            {
                for(port = 0 ; port < PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum) ; port += 32)
                {
                    rc = prvCpssHwPpWriteRegister(devNum,
                        PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.physicalPortLinkStatusMask[port/32],
                        0xFFFFFFFF);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }

        /* init EGF EFT/Global/CPU Code to Physical Port Mapping %n*/
        rc = prvCpssDxChHwEgfEftCpuCodeMapToCpuPortInit(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            /*init EGF qag/TC DP Mapper Table */
            rc = prvCpssDxChHwEgfQagTcDpMapperInit(devNum);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
        if (rc != GT_OK)
        {
            return rc;
        }
        if (tempSystemRecovery_Info.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
        {
            if(     PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E
                ||  PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E
                ||  PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC3X_E )
            {
                rc = prvCpssDxChBobcat2PortMappingConfigSet(devNum);
                if(GT_OK != rc)
                {
                    return rc;
                }
            }
            else if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E ||
                    PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)
            {
                rc = prvCpssDxChBobcat3PortMappingConfigSet(devNum);
                if(GT_OK != rc)
                {
                    return rc;
                }
            }
            else
            if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                /* do nothing , all mapping comes from the 'port mapping' API */
            }
        }
    }


    /* PLL SAR init for XCAT3:
        1. A0 device
        2. Only on A0 device that Device Sample at Reset (SAR) and Bonding Status<1>[17] is set to 0x0.

        For Core clock is lower than 360MHz:
            We must apply the WA when the GigE MACs of the 2.5Gbe ports is in reset.
            Because we cannot change the MAC Clock (DP clock) when it is out of reset.
            After applying the PLL WA, you need to take out the 2.5GbE MACs out of reset (and reset again).
    */
    if(PRV_CPSS_DXCH_XCAT3_A0_CHECK_MAC(devNum) == GT_TRUE)
    {

        rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(devNum, 0xF8204, 17, 1, &data);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }

        if(data == 0)
        {
/*            rc = xcat3PllInit(devNum);*/
            if(GT_OK != rc)
            {
                return rc;
            }

            if(PRV_CPSS_PP_MAC(devNum)->coreClock < 360)
            {
                /* After PLL manipulations - unreset and reset stack GIG ports 24..27 */
                for(i = 24; i < 28; i++)
                {
                    PRV_CPSS_DXCH_PORT_MAC_CTRL2_REG_MAC(devNum, i, PRV_CPSS_PORT_GE_E, &regAddr);
                    rc = prvCpssHwPpSetRegField(devNum, regAddr, 6, 1, 0);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }

                cpssOsTimerWkAfter(1);

                for(i = 24; i < 28; i++)
                {
                    PRV_CPSS_DXCH_PORT_MAC_CTRL2_REG_MAC(devNum, i, PRV_CPSS_PORT_GE_E, &regAddr);
                    rc = prvCpssHwPpSetRegField(devNum, regAddr, 6, 1, 1);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }
    }


    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)
    {
        /* update default values related to exact shaping/scheduling  */
        /* of packets dropped in egress pipe (typically by EPCL)      */

        /* global enable ERMRK byte count adjusting using per port values */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->ERMRK.ERMRKGlobalConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 17, 1, 1);
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }

        for (port = 0; (port < PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum)); port++)
        {
            /* update ERMRK target port entry fields */
            /* Port bc cfg value bits[326:321]       */
            rc = prvCpssDxChWriteTableEntryField(
                devNum, CPSS_DXCH_SIP5_TABLE_ERMRK_PTP_TARGET_PORT_E,
                port, PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                321/*fieldOffset*/, 6/*fieldLength*/, 0);
            if (rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
            }
        }
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_IRONMAN_E)
    {
        /* the device can't support ALL eVIDX range from 0..MAX in the MLL-LTT */
        /* as the MLL LTT is limited size */
        /* so disable the 'all' EVIDX */
        rc = cpssDxChL2MllLookupForAllEvidxEnableSet(devNum, GT_FALSE);
        if( GT_OK != rc)
        {
            return rc;
        }
        /* set 'start from eVIDX 4K' */
        rc = cpssDxChL2MllLookupMaxVidxIndexSet(devNum,_4K-1);
        if( GT_OK != rc)
        {
            return rc;
        }
    }

    if(PRV_CPSS_SIP_6_30_CHECK_MAC(devNum))
    {
        /* Disable the <sgc_global_enable> , that cause to modify 3 LSBits of the <qosProfile> */
        regAddr = PRV_DXCH_REG1_UNIT_SMU_MAC(devNum).streamGateControl.sgcGlobalConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 0);
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }

        /* the HW start with bit 0 as indication for the 'add tag1' in the srcId */
        /* change it to 15 , so it will be 'disabled' by default for those that
           uses the 802.1cb support */
        rc = cpssDxChBrgSrcIdAddTag1LocationSet(devNum,15);
        if (rc != GT_OK)
        {
            return rc;
        }
    }


    return GT_OK;
}

/**
* @internal xCat3ErrataAddrCheckWaDbInit function
* @endinternal
*
* @brief   Initialize Unit Address Ranges Data Base for Address Check WA.
*         The DB will be initialized according to the following Address ranges
*         list:
*         Where Unit Id is defined by bits 24-31.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The Pp's device number.
*                                       None.
*
* @note Note: The ranges should be in growing order.
*
*/

static GT_VOID xCat3ErrataAddrCheckWaDbInit
(
    IN  GT_U8               devNum
)
{
    GT_U32      unitId;     /* loop iterator */
    PRV_CPSS_DXCH_ERRATA_UNIT_RANGES_STC  emptyUnit = EMPTY_UNIT_MAC; /* empty unit ranges */


    /* initialize xCat3 DB */
    for (unitId = 0; unitId < UNITS_NUM_CNS; unitId++)
    {
        DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges[unitId]) = emptyUnit;
    }

    /* Unit 0, unitName: MG_IP */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[0].numOfRanges =
        (sizeof(xCat3Unit0RangesArray) / sizeof(xCat3Unit0RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[0].rangesPtr = xCat3Unit0RangesArray;

    /* Unit 2, unitName: EGR_TXQ */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[2].numOfRanges =
        (sizeof(xCat3Unit2RangesArray) / sizeof(xCat3Unit2RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[2].rangesPtr = xCat3Unit2RangesArray;

    /* Unit 4, unitName: IPvX */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[4].numOfRanges =
        (sizeof(xCat3Unit4RangesArray) / sizeof(xCat3Unit4RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[4].rangesPtr = xCat3Unit4RangesArray;

    /* Unit 6, unitName: EPLR */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[6].numOfRanges =
        (sizeof(xCat3Unit6RangesArray) / sizeof(xCat3Unit6RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[6].rangesPtr = xCat3Unit6RangesArray;

    /* Unit 14, unitName: MEM */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[14].numOfRanges =
        (sizeof(xCat3Unit14RangesArray) / sizeof(xCat3Unit14RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[14].rangesPtr = xCat3Unit14RangesArray;

    /* Unit 15, No unit exist in this range */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[15].numOfRanges =
        (sizeof(xCat3Unit15RangesArray) / sizeof(xCat3Unit15RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[15].rangesPtr = xCat3Unit15RangesArray;

    /* Unit 17, unitName: MSM  MIB*/
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[17].numOfRanges =
        (sizeof(xCat3Unit17RangesArray) / sizeof(xCat3Unit17RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[17].rangesPtr = xCat3Unit17RangesArray;

    /* Unit 18, unitName: GOP*/
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[18].numOfRanges =
        (sizeof(xCat3Unit18RangesArray) / sizeof(xCat3Unit18RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[18].rangesPtr = xCat3Unit18RangesArray;

    /* Unit 19, unitName: SD */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[19].numOfRanges =
        (sizeof(xCat3Unit19RangesArray) / sizeof(xCat3Unit19RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[19].rangesPtr = xCat3Unit19RangesArray;

    /* Unit 21, unitName: IPCL */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[21].numOfRanges =
        (sizeof(xCat3Unit21RangesArray) / sizeof(xCat3Unit21RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[21].rangesPtr = xCat3Unit21RangesArray;

    /* Unit 22, unitName: TTI */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[22].numOfRanges =
        (sizeof(xCat3Unit22RangesArray) / sizeof(xCat3Unit22RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[22].rangesPtr = xCat3Unit22RangesArray;

    /* Unit 23, unitName: IPLR 0 */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[23].numOfRanges =
        (sizeof(xCat3Unit23RangesArray) / sizeof(xCat3Unit23RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[23].rangesPtr = xCat3Unit23RangesArray;

    /* Unit 24, unitName: IPLR 1 */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[24].numOfRanges =
        (sizeof(xCat3Unit24RangesArray) / sizeof(xCat3Unit24RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[24].rangesPtr = xCat3Unit24RangesArray;

    /* Unit 26, unitName: IPCL_TCC */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[26].numOfRanges =
        (sizeof(xCat3Unit26RangesArray) / sizeof(xCat3Unit26RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[26].rangesPtr = xCat3Unit26RangesArray;

    /* Unit 27, unitName: IPvX_TCC */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[27].numOfRanges =
        (sizeof(xCat3Unit27RangesArray) / sizeof(xCat3Unit27RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[27].rangesPtr = xCat3Unit27RangesArray;

    /* Unit 28, unitName: HA */
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[28].numOfRanges =
        (sizeof(xCat3Unit28RangesArray) / sizeof(xCat3Unit28RangesArray[0]));
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges)[28].rangesPtr = xCat3Unit28RangesArray;

    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.unitRangesPtr[0]
            = DXCH_HWINIT_GLOVAR(dxChHwInitSrc.xCat3BadAddressRanges);
    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.lastValidAddress
           = 0x1D00C0FF;
}

/**
* @internal hwPpLion2StartInitSet function
* @endinternal
*
* @brief   Trigger the device to do 'start init' then wait for the device to finish
*         the operation. The function will wait up to 1 second for operation to
*         end
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The Pp's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - the device
*/
static GT_STATUS hwPpLion2StartInitSet
(
    IN  GT_U8               devNum
)
{
    PRV_CPSS_DXCH_PP_REGS_ADDR_STC  *regsAddrPtr;
    GT_U32              tmpData;
    GT_U32              timeout;        /* Timeout for waiting for the      */
                                        /* startinit operation to be done.  */
    GT_STATUS           rc;             /* Return code */
    GT_U32  timeToSleepMilisec;

#ifdef _FreeBSD
    /* under FreeBSD required longer timeout untill
     * ASIC reset finished
     */
    timeToSleepMilisec = 1000;
#else
    timeToSleepMilisec = 10;
#endif
    regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum);

    if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_FALSE)
    {
        return GT_OK;
    }


    /* Check Internal init done */
    rc = prvCpssHwPpGetRegField(devNum, regsAddrPtr->dfxUnits.server.initDoneStatus,
                                   0, 2, &tmpData);
    if(rc != GT_OK)
        return rc;

    if(tmpData == 0)
    {
        return GT_OK;
    }

    /* set 1 second timeout */
    timeout = 100;
    tmpData = 1;

    while(tmpData == 1)
    {
        if(PRV_CPSS_PP_MAC(devNum)->ppHAState == CPSS_SYS_HA_MODE_STANDBY_E)
        {
            break;
        }

        if(timeout == 0)
        {
            /* time over, the device is not finished init. This means HW problem. */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

       /* wait till : dfx_server init done */
        rc = prvCpssHwPpGetRegField(devNum, regsAddrPtr->dfxUnits.server.initDoneStatus,
                                   1, 1, &tmpData);
        if(rc != GT_OK)
            return rc;

        cpssOsTimerWkAfter(timeToSleepMilisec);
        timeout--;
    }

    /* Activating the start_tables_init */
    rc = prvCpssHwPpSetRegField(devNum, regsAddrPtr->dfxUnits.server.resetControl,
                                            2, 1, 0);
    if(rc != GT_OK)
        return rc;

    rc = prvCpssHwPpSetRegField(devNum, regsAddrPtr->dfxUnits.server.resetControl,
                                            2, 1, 1);
    if(rc != GT_OK)
        return rc;

    /* set 1 second timeout */
    timeout = 100;
    tmpData = 1;
    while(tmpData == 1)
    {
        if(PRV_CPSS_PP_MAC(devNum)->ppHAState == CPSS_SYS_HA_MODE_STANDBY_E)
        {
            break;
        }

        if(timeout == 0)
        {
            /* time over, the device is not finished init. This means HW problem. */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

        /* wait for All_INIT_DONE. */
        rc = prvCpssHwPpGetRegField(devNum,
                                   regsAddrPtr->dfxUnits.server.initDoneStatus,
                                   0, 1, &tmpData);
        if(rc != GT_OK)
            return rc;

        cpssOsTimerWkAfter(timeToSleepMilisec);
        timeout--;
    }

    return GT_OK;
}

/**
* @internal hwPpSip6StartInitSet function
* @endinternal
*
* @brief   After DEV_INIT_DONE signal is asserted, software can read fully
*         functional state from the chip.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - The Pp's device number.
* @param[in] ignoreInitDone           - Whether to return OK although init_done bit still not 'done'.
* @param[in] timeToSleepMilisec       - time to sleep between iterations
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - the device
*/
static GT_STATUS hwPpSip6StartInitSet
(
    IN  GT_U8               devNum,
    IN  GT_BOOL             ignoreInitDone,
    IN GT_U32               timeToSleepMilisec
)
{
    GT_U32              regAddr;        /* register address */
    GT_U32              tmpData = 0;
    GT_U32              mask;
    GT_U32              timeout;        /* Timeout for waiting for the      */
                                        /* startinit operation to be done.  */
    GT_U32              maxTimeout;
    GT_STATUS           rc;             /* Return code */

    if(PRV_CPSS_PP_MAC(devNum)->ppHAState == CPSS_SYS_HA_MODE_STANDBY_E)
    {
        return GT_OK;
    }

    maxTimeout = 100;
    timeout = maxTimeout;
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                      DFXServerUnitsDeviceSpecificRegs.initializationStatusDone;

    /* check single bit <all_init_done_> */
    /* this bit if value 0 - means that all units and Ravens are 'init done'*/
    /* this bit if value 1 - means that at least one unit in Eagle/Ravens is not 'init done'*/
    mask = 0x1;

    do
    {

        /* Check init stage status */
        rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &tmpData);
        if( GT_OK != rc )
        {
            return rc;
        }

        if((tmpData & mask) == 0)
        {
            /* if all needed units passed init, clear "all init done" */
            break;
        }
        cpssOsTimerWkAfter(timeToSleepMilisec);
        timeout--;
    }
    while (timeout);

    if(timeout == 0)
    {
        /* timeout, no initDone indication */
        if (ignoreInitDone)
        {
            cpssOsPrintf("WARNING : <init Done>: ignore Uncompleted HW init value: 0x%8.8x \n",
                tmpData);

            /* FORCE <init done> so the device can continue ... */
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 0,1,0 );
            if( GT_OK != rc )
            {
                return rc;
            }
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT,
                "WARNING : <init Done>: regAddr[0x%x] Uncompleted HW init value: [0x%x] \n",
                    regAddr , tmpData);
        }
    }

    timeout = maxTimeout;
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                                      DFXServerUnits.DFXServerRegs.serverStatus;
    do
    {
        /* Check init stage status */
        rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(
                                               devNum, regAddr, 4, 2, &tmpData);
        if( GT_OK != rc )
        {
            return rc;
        }

        if(tmpData == 0x3)
        {
            /* <init stage status> is ready */
            break;
        }

        cpssOsTimerWkAfter(timeToSleepMilisec);
        timeout--;
    }
    while (timeout);

    if(timeout == 0)
    {
        /* time over, the device is not finished init. This means HW problem. */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT,
            "<init stage status> is NOT ready (not value 3). This means HW problem");
    }

    return GT_OK;
}

/**
* @internal hwPpSip5StartInitSet function
* @endinternal
*
* @brief   After DEV_INIT_DONE signal is asserted, software can read fully
*         functional state from the chip.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   Lion2.
*
* @param[in] devNum                   - The Pp's device number.
* @param[in] ignoreInitDone           - Whether to return OK though initDone bits are still 'init_onGoing'.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - the device
*/
static GT_STATUS hwPpSip5StartInitSet
(
    IN  GT_U8               devNum,
    IN  GT_BOOL             ignoreInitDone
)
{
    GT_U32              regAddr;        /* register address */
    GT_U32              tmpData;
    GT_U32              tmpData1;
    GT_U32              mask;
    GT_U32              timeout;        /* Timeout for waiting for the      */
                                        /* startinit operation to be done.  */
    GT_STATUS           rc;             /* Return code */
    GT_U32              timeToSleepMilisec;
    GT_U32              tmFrequency = 0;/* tm dram frequency if != 0 tm is supported*/

#ifdef _FreeBSD
    /* under FreeBSD required longer timeout untill
     * ASIC reset finished
     */
    timeToSleepMilisec = 1000;
#else
    timeToSleepMilisec = 10;
#endif

    if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_FALSE)
    {
        return GT_OK;
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum) ||
       PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E/*ignore for now the AC3 efuse issue (if any)*/)
    {
        /* call 'clean' implementations of the 'init done' indication */
        return hwPpSip6StartInitSet(devNum,ignoreInitDone,timeToSleepMilisec);
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        timeout = 100;
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsDeviceSpecificRegs.initializationStatusDone;

        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
        {
            if (PRV_CPSS_PP_MAC(devNum)->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
            {
                /* verify whether TM is supported*/
                rc = prvCpssDxChTMFreqGet(devNum, &tmFrequency);
                if(rc != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "cpssDxChHwPpPhase1Init-initDone: Fail to get TM frequency\n");
                }
            }
        }

        do
        {
            if(PRV_CPSS_PP_MAC(devNum)->ppHAState == CPSS_SYS_HA_MODE_STANDBY_E)
            {
                break;
            }

            /* Check init stage status */
            rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &tmpData);
            if( GT_OK != rc )
            {
                return rc;
            }


            if(timeout == 0)
            {
                /* timeout, no initDone indication its System with TM or some other issue */
                if (ignoreInitDone)
                {
                    CPSS_LOG_INFORMATION_MAC("cpssDxChHwPpPhase1Init-initDone: ignore Uncompleted HW init value: %0x\n", tmpData);
                    tmpData = 0;
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
                }
            }

            if(PRV_CPSS_DXCH_BOBCAT2_A0_CHECK_MAC(devNum))
            {   /* BC2 A0*/
                rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(devNum, 0xF8520, 0, 1, &tmpData1);
                if( GT_OK != rc )
                {
                    return rc;
                }
            }
            else if (PRV_CPSS_DXCH_BOBCAT3_CHECK_MAC(devNum))
            {
                /* BC3: check metal fix register */
                rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, 0xF8248, &tmpData1);
                if( GT_OK != rc )
                {
                    return rc;
                }
                /* Bypass parity check if register data == 0xa000ffff */
                tmpData1 = (tmpData1 == 0xa000ffff) ? 0 : 1;
            }
            else if(((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E) &&
                     (PRV_CPSS_PP_MAC(devNum)->devSubFamily == CPSS_PP_SUB_FAMILY_NONE_E)) ||
                     PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
            {   /* BC2 B0 + XCAT3 */
                GT_U32  dfxBaseAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsDeviceSpecificRegs.initializationStatusDone & 0xFFF00000;

                rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(devNum, dfxBaseAddr + 0xF8F20, 0, 1, &tmpData1);
                if( GT_OK != rc )
                {
                    return rc;
                }
            }
            else
            {
                tmpData1 = 0;
            }

            /************************************************************************
                On BC2/AC3 systems there might be IDEfuse burned devices with
                security bit enabled or disabled.

                When the security bit is disabled, in case of burning some
                effuse bits, we might run into an issue of wrong the
                <dfx_server_Init_Done>[1]  status indication (MSB bit of field {2:1})

                Thus, we need to check on the <dfx_server_Init_Done>[1] only when
                ID Efuse[256] - (bit [0] of 0x000F8F20) is burned to 0x1.
                If it's not burned (0x1) SW needs to check only on <dfx_server_Init_Done>[0] .

            ************************************************************************/
            if(tmpData1 == 1)
            {
                mask = 0xFFFFFDDE;
            }
            else
            {
                mask = 0xFFFFFDDA;
            }

            if(tmpData && tmFrequency)
            {
                if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
                {
                    if (PRV_CPSS_PP_MAC(devNum)->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
                    {
                        /* system has TM, TM init status done after TM externam memory init, turn-off next bits:
                        12:  tm_Init_Done
                         8:  bc2 Init Done
                         4:  Table Init Done
                         1:  initDone-initOnGoing */
                        mask &= ~(0x1112);
                        if(GT_TRUE == PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.featureInfo.TmSupported)
                        {
                            CPSS_LOG_INFORMATION_MAC("cpssDxChHwPpPhase1Init-initDone: System has TM, ignore Uncompleted TM unit, init value: %0x, mask: %0x\n", tmpData, mask);
                        }
                    }
                }
            }


            #ifdef ASIC_SIMULATION
                /* single iteration is enough */
                tmpData = 0;
            #endif /*ASIC_SIMULATION*/

            if((tmpData & mask) == 0)
            {/* if all needed units passed init, clear "all init done" */
                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr,
                                                                     0, 1, 0);
                if( GT_OK != rc )
                {
                    return rc;
                }
                break;
            }
            cpssOsTimerWkAfter(timeToSleepMilisec);
            timeout--;
        }
        while (1);
    }

    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                                      DFXServerUnits.DFXServerRegs.serverStatus;

    timeout = 100;

    do
    {
        if(PRV_CPSS_PP_MAC(devNum)->ppHAState == CPSS_SYS_HA_MODE_STANDBY_E)
        {
            break;
        }

        if(timeout == 0)
        {
            /* time over, the device is not finished init. This means HW problem. */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

        /* Check init stage status */
        rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(
                                               devNum, regAddr, 4, 2, &tmpData);
        if( GT_OK != rc )
        {
            return rc;
        }

        cpssOsTimerWkAfter(timeToSleepMilisec);
        timeout--;
    }
    while (tmpData != 0x3);

    return GT_OK;
}

/**
* @internal prvCpssDxChErrataCallbackAddessRangeMatch function
* @endinternal
*
* @brief   Checks read/written register/memory addresses range to belong to given address bounds and
*         (optional - for write only) to contain the last word of some table entry.
*         Used for workaround related to any read, and to write of the last table entry words only.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] entryAlignment           - entry alignment in bytes - if 0 no entrySize check
*                                      pair of (entryAlignment, entrySize) used to determinate
* @param[in] address                  of the last words of table entries.
* @param[in] entrySize                - entry size in bytes
* @param[in] lowBound                 - low Bound (included to matching)
* @param[in] highBound                - high Bound (excluded from matching)
* @param[in] address                  -  of range being checked
* @param[in] sizeInWords              - size In Words of range being checked
*
* @retval GT_TRUE on matching, GT_FALSE - no matching
*/
static GT_BOOL prvCpssDxChErrataCallbackAddessRangeMatch
(
    IN  GT_U32     entryAlignment,
    IN  GT_U32     entrySize,
    IN  GT_U32     lowBound,
    IN  GT_U32     highBound,
    IN  GT_U32     address,
    IN  GT_U32     sizeInWords
)
{
    GT_U32 endAddr;  /* excluded upper bound of the range being read/written */
    GT_U32 entryEnd; /* excluded upper bound of the relevant table entry     */

    entryAlignment = (entryAlignment + 3) & 0xFFFFFFFC; /* alingn to 4 */
    entrySize      = (entrySize + 3)      & 0xFFFFFFFC; /* alingn to 4 */
    if (address >= highBound) return GT_FALSE;
    endAddr = address + (sizeInWords * 4);
    if (endAddr <= lowBound) return GT_FALSE;
    if (entryAlignment > 4)
    {
        entryEnd = address - (address % entryAlignment) + entrySize;
        if (endAddr < entryEnd) return GT_FALSE; /* not last word in entry */
    }
    return GT_TRUE;
}

/**
* @internal prvCpssDxChErrataCallbackGeneric function
* @endinternal
*
* @brief   Prepare and complete read/write access operations for special cases.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; AC3X; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The device number
* @param[in] portGroupId              - The port group Id. relevant only to 'multi-port-groups' devices,
*                                      supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS.
* @param[in,out] anchorDataPtr            - (pointer to) data used/updated by callback
*                                      passed with callback function address binding callback
* @param[in] addr                     - Start offset address to check
* @param[in] length                   - The  of the memory to check (the legth is in words).
* @param[in] param0                   - additional info - field offset in bits or bitmask
* @param[in] param0                   - additional info - field length in bits
* @param[in] inoutDataPtr             - write data pointers (for write operations)
*
* @param[out] inoutDataPtr             - read data pointers (for read operations)
* @param[out] skipHwAccessPtr          - (pointer to) GT_TRUE - skip HW access, GT_FALSE - do HW access.
*                                      Calls of this callback prevent and completes HW access in CPSS
*                                      low level driver.
*                                       none.
*/
static GT_STATUS prvCpssDxChErrataCallbackGeneric
(
    IN    GT_U8                                  devNum,
    IN    GT_U32                                 portGroupId,
    INOUT GT_VOID                                *anchorDataPtr,
    IN    PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_ENT callbackEvent,
    IN    GT_U32                                 addr,
    IN    GT_U32                                 length,
    IN    GT_U32                                 param0,
    IN    GT_U32                                 param1,
    IN    GT_VOID                                *inoutDataPtr,
    OUT   GT_BOOL                                *skipHwAccessPtr
)
{
    ERRATA_BOBK_TXQ_TAIL_DROP_DATA_STC *errataDataPtr =
        (ERRATA_BOBK_TXQ_TAIL_DROP_DATA_STC*)anchorDataPtr;
    GT_U32                             idx;
    GT_BOOL                            isWriteOnly;
    GT_BOOL                            isPrepare;
    GT_BOOL                            found;
    GT_U32                             data;
    GT_U32                             *saveDataPtr;
    GT_U32                             alignment;
    GT_U32                             entrySyze;
    GT_STATUS                          rc;

    /* prevent compiler warning */
    portGroupId = portGroupId;
    param0       = param0;
    param1       = param1;
    inoutDataPtr = inoutDataPtr;
    /* allow to caller planned HW access */
    *skipHwAccessPtr = GT_FALSE;

    /* unit address filtering */
    if ((addr < errataDataPtr->unitAddr.unitBase)
        || (addr >= errataDataPtr->unitAddr.unitUpperBound))
    {
        return GT_OK; /* HW access out of WA unit range */
    }

    if (((callbackEvent & PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_MASK_MEMORY_E)
        != PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_MEMORY_E) &&
        (length != 1))
    {
        /* invalid call - should not occur */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    isPrepare =
        ((callbackEvent & PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_MASK_STAGE_E)
         == PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_PREPARE_E) ? GT_TRUE : GT_FALSE;

    switch (callbackEvent & PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_MASK_OPERATION_E)
    {
        case PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_WRITE_E:
            isWriteOnly = GT_TRUE;
            break;
        default:
            isWriteOnly = GT_FALSE;
            break;
    }

    /* write only operations not need preparations */
    if ((isWriteOnly != GT_FALSE) && (isPrepare != GT_FALSE)) return GT_OK;

    /* exact matching - if no ranges specified - already matched */
    found = (errataDataPtr->numOfRanges == 0) ? GT_TRUE : GT_FALSE;
    for (idx = 0; (idx < errataDataPtr->numOfRanges); idx++)
    {
        if (isWriteOnly != GT_FALSE)
        {
            alignment = errataDataPtr->addrRangeArr[idx].lineSizeInBytes;
            entrySyze = errataDataPtr->addrRangeArr[idx].entrySizeInBytes;
        }
        else
        {
            alignment = 0;
            entrySyze = 0;
        }
        found = prvCpssDxChErrataCallbackAddessRangeMatch(
            alignment, entrySyze,
            (errataDataPtr->addrRangeArr[idx].lowBound),
            (errataDataPtr->addrRangeArr[idx].highBound),
            addr, length/*sizeInWords*/);
        if (found != GT_FALSE) break;
    }
    if (found == GT_FALSE) return GT_OK;

    /* WA needed and implemented here */

    /* Write completion: read other unit to delay after write */
    if (isWriteOnly != GT_FALSE)
    {
        rc = prvCpssDxChReadTableEntry(
            devNum, errataDataPtr->readAfterWrite.tableId,
            62 /*entryIndex*/, &data);
        return rc;
    }

    saveDataPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_TXQ_TAIL_DROP_TABLES_ACCESS_WA_E.saveRegDataArr[0]);

    /* used read/write functions support duplication */
    /* to all unit instances                         */
    if (isPrepare != GT_FALSE)
    {
        /* read (save) and update configured registers   */
        for (idx = 0; (idx < errataDataPtr->numOfUpdatedRegs); idx++)
        {
            rc = prvCpssHwPpReadRegister(
                devNum,
                (errataDataPtr->updatedRegArr[idx].regAddr)/*addr*/,
                &(saveDataPtr[idx]));
            if (rc != GT_OK) return rc;
            data =
                (saveDataPtr[idx] & (~ errataDataPtr->updatedRegArr[idx].updateMask))
                 | (errataDataPtr->updatedRegArr[idx].updateMask
                    & errataDataPtr->updatedRegArr[idx].updateData);
            rc = prvCpssHwPpWriteRegister(
                devNum,
                (errataDataPtr->updatedRegArr[idx].regAddr)/*addr*/,
                data);
            if (rc != GT_OK) return rc;
        }
        return GT_OK;
    }
    else /*isPrepare == GT_FALSE*/
    {
        /* restore configured registers */
        for (idx = 0; (idx < errataDataPtr->numOfUpdatedRegs); idx++)
        {
            rc = prvCpssHwPpWriteRegister(
                devNum,
                (errataDataPtr->updatedRegArr[idx].regAddr)/*addr*/,
                saveDataPtr[idx]);
            if (rc != GT_OK) return rc;
        }
        return GT_OK;
    }
}

/**
* @internal prvCpssDxChErrataCallbackDba function
* @endinternal
*
* @brief   Prepare and complete read/write access operations for special cases.
*         Used for Bobcat3 with DBA running on CM3 coprocessor.
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5;  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The device number
* @param[in] portGroupId              - The port group Id. relevant only to 'multi-port-groups' devices,
*                                      supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS.
* @param[in,out] anchorDataPtr            - (pointer to) data used/updated by callback
*                                      passed with callback function address binding callback
* @param[in] addr                     - Start offset address to check
* @param[in] length                   - The  of the memory to check (the legth is in words).
* @param[in] param0                   - additional info - field offset in bits or bitmask
* @param[in] param0                   - additional info - field length in bits
* @param[in] inoutDataPtr             - write data pointers (for write operations)
*
* @param[out] inoutDataPtr             - read data pointers (for read operations)
* @param[out] skipHwAccessPtr          - (pointer to) GT_TRUE - skip HW access, GT_FALSE - do HW access.
*                                      Calls of this callback prevent and completes HW access in CPSS
*                                      low level driver.
*                                       none.
*/
static GT_STATUS prvCpssDxChErrataCallbackDba
(
    IN    GT_U8                                  devNum,
    IN    GT_U32                                 portGroupId,
    INOUT GT_VOID                                *anchorDataPtr,
    IN    PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_ENT callbackEvent,
    IN    GT_U32                                 addr,
    IN    GT_U32                                 length,
    IN    GT_U32                                 param0,
    IN    GT_U32                                 param1,
    IN    GT_VOID                                *inoutDataPtr,
    OUT   GT_BOOL                                *skipHwAccessPtr
)
{
    ERRATA_BOBK_TXQ_TAIL_DROP_DATA_STC *errataDataPtr =
        (ERRATA_BOBK_TXQ_TAIL_DROP_DATA_STC*)anchorDataPtr;
    GT_U32                             idx;
    GT_BOOL                            isWriteOnly;
    GT_BOOL                            isReadOnly;
    GT_BOOL                            isConverted;
    GT_BOOL                            found;
    GT_U32                             data;
    GT_U32                             value;
    GT_U32                             mask;
    GT_STATUS                          rc;

    /* prevent compiler warning */
    portGroupId = portGroupId;
    /* allow to caller planned HW access */
    *skipHwAccessPtr = GT_FALSE;

    /* unit address filtering */
    if ((addr < errataDataPtr->unitAddr.unitBase)
        || (addr >= errataDataPtr->unitAddr.unitUpperBound))
    {
        return GT_OK; /* HW access out of WA unit range */
    }

    if (((callbackEvent & PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_MASK_MEMORY_E)
        != PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_MEMORY_E) &&
        (length != 1))
    {
        /* invalid call - should not occur */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if ((callbackEvent & PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_MASK_STAGE_E)
         == PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_COMPLETE_E)
    {
        /* no completion */
        return GT_OK;
    }

    switch (callbackEvent & PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_MASK_OPERATION_E)
    {
        case PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_WRITE_E:
            isWriteOnly = GT_TRUE;
            isReadOnly  = GT_FALSE;
            isConverted = GT_FALSE;
            break;
        case PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_READ_E:
            isWriteOnly = GT_FALSE;
            isReadOnly  = GT_TRUE;
            isConverted = GT_FALSE;
            break;
        case PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_WRITE_MASK_E:
            isReadOnly  = GT_FALSE;
            isWriteOnly = GT_FALSE;
            isConverted = GT_TRUE;
            if (/*mask*/param0 == 0xFFFFFFFF)
            {
                isWriteOnly = GT_TRUE;
                isConverted = GT_FALSE;
            }
            break;
        case PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_READ_MASK_E:
            isWriteOnly = GT_FALSE;
            isReadOnly  = GT_TRUE;
            isConverted = /*mask*/(param0 == 0xFFFFFFFF) ? GT_FALSE : GT_TRUE;
            break;
        case PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_GET_FIELD_E:
            if ((/*bitOffset*/param0 + /*bitLength*/param1) > 32)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            isWriteOnly = GT_FALSE;
            isReadOnly  = GT_TRUE;
            isConverted = /*bitLength*/(param1 == 32) ? GT_FALSE : GT_TRUE;
            break;
        case PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_SET_FIELD_E:
            if ((/*bitOffset*/param0 + /*bitLength*/param1) > 32)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            isReadOnly  = GT_FALSE;
            isWriteOnly = GT_FALSE;
            isConverted = GT_TRUE;
            if (/*bitLength*/param1 == 32)
            {
                isWriteOnly = GT_TRUE;
                isConverted = GT_FALSE;
            }
            break;
        default:
            isReadOnly  = GT_FALSE;
            isWriteOnly = GT_FALSE;
            isConverted = GT_TRUE;
            break;
    }

    found = GT_FALSE;
    for (idx = 0; (idx < errataDataPtr->numOfRanges); idx++)
    {
        found = prvCpssDxChErrataCallbackAddessRangeMatch(
            0/*alignment*/, 0/*entrySyze*/,
            (errataDataPtr->addrRangeArr[idx].lowBound),
            (errataDataPtr->addrRangeArr[idx].highBound),
            addr, length/*sizeInWords*/);
        if (found != GT_FALSE) break;
    }
    /* forbid to caller planned HW access */
    *skipHwAccessPtr = GT_TRUE;
    if ((found != GT_FALSE) && (isWriteOnly != GT_FALSE) && (isConverted == GT_FALSE))
    {
        /* proxy write tables */
        return prvCpssDxChPortTxDbaProxyTxqTableSet(
            devNum, addr, length, inoutDataPtr);
    }
    if ((found != GT_FALSE) && (isReadOnly != GT_FALSE) && (isConverted == GT_FALSE))
    {
        /* proxy read tables */
        return prvCpssDxChPortTxDbaProxyTxqTableGet(
            devNum, addr, length, inoutDataPtr);
    }
    if (found != GT_FALSE)
    {
        /* table space with subfields of masks not supported */
        CPSS_LOG_ERROR_AND_RETURN_MAC(
            GT_BAD_PARAM, "TailDrop table unsupported access\n");
    }
    if (length != 1)
    {
        /* register space */
        CPSS_LOG_ERROR_AND_RETURN_MAC(
            GT_BAD_PARAM, "TailDrop register opration with length > 1\n");
    }
    if ((isWriteOnly != GT_FALSE) && (isConverted == GT_FALSE))
    {
        value = *(GT_U32*)inoutDataPtr;
        return prvCpssDxChPortTxDbaProxyTxqOtherSet(
            devNum, addr, 1/*length*/, &value);
    }
    /* proxy read not tables */
    rc = prvCpssDxChPortTxDbaProxyTxqOtherGet(
        devNum, addr, 1/*length*/, &data);
    if (rc != GT_OK)
    {
        return rc;
    }
    if ((isReadOnly != GT_FALSE) && (isConverted == GT_FALSE))
    {
        *(GT_U32*)inoutDataPtr = data;
        return GT_OK;
    }
    switch (callbackEvent & PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_MASK_OPERATION_E)
    {
        case PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_READ_MASK_E:
            mask = param0 /*mask*/;
            value = data & mask;
            *(GT_U32*)inoutDataPtr = value;
            return GT_OK;
        case PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_GET_FIELD_E:
            mask = (1 << param1/*bitLength*/) - 1;
            value = (data >> param0/*bitOffset*/) & mask;
            *(GT_U32*)inoutDataPtr = value;
            return GT_OK;
        case PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_WRITE_MASK_E:
            mask = param0 /*mask*/;
            value = (*(GT_U32*)inoutDataPtr & mask) | (data & (~ mask));
            /* this callback will be called again inside, but will do nothing */
            return prvCpssDxChPortTxDbaProxyTxqOtherSet(
                devNum, addr, 1/*length*/, &value);
            break;
        case PRV_CPSS_DRV_ERRATA_CALLBACK_EVENT_SET_FIELD_E:
            mask = (((1 << param1/*bitLength*/) - 1) << param0/*bitOffset*/);
            value = (((*(GT_U32*)inoutDataPtr << param0/*bitOffset*/) & mask)) | (data & (~ mask));
            /* this callback will be called again inside, but will do nothing */
            return prvCpssDxChPortTxDbaProxyTxqOtherSet(
                devNum, addr, 1/*length*/, &value);
        default:
            break;
    }
    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
}

/**
* @internal prvCpssDxChHwPpErrataTailDropTablesAccessCallbackEnable function
* @endinternal
*
* @brief   Bind/unbind
*
* @note   APPLICABLE DEVICES:      Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The Pp's device number.
* @param[in] enable                   - GT_TRUE - bind callback, GT_FALSE - unbind callback,
*                                       None.
*/
GT_STATUS prvCpssDxChHwPpErrataTailDropTablesAccessCallbackEnable
(
    IN  GT_U8         devNum,
    IN  GT_BOOL       enable
)
{
    PRV_CPSS_DRV_ERRATA_CALLBACK_FUNC_PTR   callbackFuncPtr;
    ERRATA_BOBK_TXQ_TAIL_DROP_DATA_STC      *callbackDataPtr;
    GT_U32                                  *devUnitsBaseAddrPtr;
    const PRV_CPSS_DXCH_TABLES_INFO_STC           *tableInfoPtr;
    PRV_CPSS_DXCH_TABLES_INFO_DIRECT_STC    *tablePtr;
    GT_BOOL                                 isDbaEnable;
    GT_STATUS                               rc;

    /* Bobcat2, Caelum (BobK), Aldrin, AC3X, Bobcat3 */
    if (GT_FALSE == PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum,PRV_CPSS_DXCH_BOBCAT2_TXQ_TAIL_DROP_TABLES_R_W_PENDS_BUS_WA_E))
    {
        return GT_OK;
    }

    if (enable != GT_FALSE)
    {
        isDbaEnable = GT_FALSE;
        if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
        {
            rc = cpssDxChPortTxDbaEnableGet(devNum, &isDbaEnable);
            if (rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "cpssDxChPortTxDbaEnableGet failed\n");
            }
        }

        callbackFuncPtr = (isDbaEnable == GT_FALSE)
            ? &prvCpssDxChErrataCallbackGeneric
            : &prvCpssDxChErrataCallbackDba;

        if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            /* Bobcat3 */
            callbackDataPtr = &DXCH_HWINIT_GLOVAR(dxChHwInitSrc.bc3TxqTailDropData);
            callbackDataPtr->initialized = GT_FALSE;
        }
        else if (PRV_CPSS_SIP_5_16_CHECK_MAC(devNum))
        {
            /* Aldrin, AC3X */
            callbackDataPtr = &DXCH_HWINIT_GLOVAR(dxChHwInitSrc.aldrinTxqTailDropData);
            callbackDataPtr->initialized = GT_FALSE;
        }
        else
        {
            /* Bobcat2, BobK */
            callbackDataPtr = &DXCH_HWINIT_GLOVAR(dxChHwInitSrc.bobkTxqTailDropData);
            callbackDataPtr->initialized = GT_FALSE;
        }
        if (callbackDataPtr->initialized == GT_FALSE)
        {
            /* unit bounds */
            prvCpssDxChUnitBaseTableGet(
                devNum, &devUnitsBaseAddrPtr);
            callbackDataPtr->initialized = GT_TRUE;
            callbackDataPtr->unitAddr.unitBase =
                devUnitsBaseAddrPtr[PRV_CPSS_DXCH_UNIT_TXQ_QUEUE_E];
            callbackDataPtr->unitAddr.unitUpperBound =
                callbackDataPtr->unitAddr.unitBase + 0x01000000;
            /* registers for read WA */
            callbackDataPtr->numOfUpdatedRegs = 1;
            callbackDataPtr->updatedRegArr[0].regAddr =
                PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->
                    EGF_eft.MCFIFO.MCFIFOConfigs.MCFIFOArbiterWeights0;
            callbackDataPtr->updatedRegArr[0].updateMask = 0xFFFFFFFF;
            callbackDataPtr->updatedRegArr[0].updateData = 0x00000000;
            /* these 5 tables have one-word and two-word entries */
            /* CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP1_E and */
            /* CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP2_E are */
            /* two halfs of the same table in HW                        */
            callbackDataPtr->numOfRanges = 6;
            /*CPSS_DXCH_SIP5_TABLE_TAIL_DROP_MAX_QUEUE_LIMITS_E*/
            tableInfoPtr = PRV_TABLE_INFO_PTR_GET_MAC(
                devNum, CPSS_DXCH_SIP5_TABLE_TAIL_DROP_MAX_QUEUE_LIMITS_E);
            tablePtr = (PRV_CPSS_DXCH_TABLES_INFO_DIRECT_STC*)(tableInfoPtr->readTablePtr);
            callbackDataPtr->addrRangeArr[0].entrySizeInBytes = (tableInfoPtr->entrySize * 4);
            callbackDataPtr->addrRangeArr[0].lineSizeInBytes  = tablePtr->step;
            callbackDataPtr->addrRangeArr[0].lowBound    = tablePtr->baseAddress;
            callbackDataPtr->addrRangeArr[0].highBound   =
               tablePtr->baseAddress  + (tablePtr->step * tableInfoPtr->maxNumOfEntries);
            /*CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP0_E*/
            tableInfoPtr = PRV_TABLE_INFO_PTR_GET_MAC(
                devNum, CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP0_E);
            tablePtr = (PRV_CPSS_DXCH_TABLES_INFO_DIRECT_STC*)(tableInfoPtr->readTablePtr);
            callbackDataPtr->addrRangeArr[1].entrySizeInBytes = (tableInfoPtr->entrySize * 4);
            callbackDataPtr->addrRangeArr[1].lineSizeInBytes  = tablePtr->step;
            callbackDataPtr->addrRangeArr[1].lowBound    = tablePtr->baseAddress;
            callbackDataPtr->addrRangeArr[1].highBound   =
                tablePtr->baseAddress  + (tablePtr->step * tableInfoPtr->maxNumOfEntries);
            /*CPSS_DXCH_SIP5_TABLE_TAIL_DROP_DQ_QUEUE_BUF_LIMITS_E*/
            tableInfoPtr = PRV_TABLE_INFO_PTR_GET_MAC(
                devNum, CPSS_DXCH_SIP5_TABLE_TAIL_DROP_DQ_QUEUE_BUF_LIMITS_E);
            tablePtr = (PRV_CPSS_DXCH_TABLES_INFO_DIRECT_STC*)(tableInfoPtr->readTablePtr);
            callbackDataPtr->addrRangeArr[2].entrySizeInBytes = (tableInfoPtr->entrySize * 4);
            callbackDataPtr->addrRangeArr[2].lineSizeInBytes  = tablePtr->step;
            callbackDataPtr->addrRangeArr[2].lowBound    = tablePtr->baseAddress;
            callbackDataPtr->addrRangeArr[2].highBound   =
                tablePtr->baseAddress  + (tablePtr->step * tableInfoPtr->maxNumOfEntries);
            /*CPSS_DXCH_SIP5_TABLE_TAIL_DROP_DQ_QUEUE_DESC_LIMITS_E*/
            tableInfoPtr = PRV_TABLE_INFO_PTR_GET_MAC(
                devNum, CPSS_DXCH_SIP5_TABLE_TAIL_DROP_DQ_QUEUE_DESC_LIMITS_E);
            tablePtr = (PRV_CPSS_DXCH_TABLES_INFO_DIRECT_STC*)(tableInfoPtr->readTablePtr);
            callbackDataPtr->addrRangeArr[3].entrySizeInBytes = (tableInfoPtr->entrySize * 4);
            callbackDataPtr->addrRangeArr[3].lineSizeInBytes  = tablePtr->step;
            callbackDataPtr->addrRangeArr[3].lowBound    = tablePtr->baseAddress;
            callbackDataPtr->addrRangeArr[3].highBound   =
                tablePtr->baseAddress  + (tablePtr->step * tableInfoPtr->maxNumOfEntries);
            /*CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP1_E*/
            tableInfoPtr = PRV_TABLE_INFO_PTR_GET_MAC(
                devNum, CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP1_E);
            tablePtr = (PRV_CPSS_DXCH_TABLES_INFO_DIRECT_STC*)(tableInfoPtr->readTablePtr);
            callbackDataPtr->addrRangeArr[4].entrySizeInBytes = (tableInfoPtr->entrySize * 4);
            callbackDataPtr->addrRangeArr[4].lineSizeInBytes  = tablePtr->step;
            callbackDataPtr->addrRangeArr[4].lowBound    = tablePtr->baseAddress;
            callbackDataPtr->addrRangeArr[4].highBound   =
                tablePtr->baseAddress  + (tablePtr->step * tableInfoPtr->maxNumOfEntries);
            /*CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP2_E*/
            tableInfoPtr = PRV_TABLE_INFO_PTR_GET_MAC(
                devNum, CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP2_E);
            tablePtr = (PRV_CPSS_DXCH_TABLES_INFO_DIRECT_STC*)(tableInfoPtr->readTablePtr);
            callbackDataPtr->addrRangeArr[5].entrySizeInBytes = (tableInfoPtr->entrySize * 4);
            callbackDataPtr->addrRangeArr[5].lineSizeInBytes  = tablePtr->step;
            callbackDataPtr->addrRangeArr[5].lowBound    = tablePtr->baseAddress;
            callbackDataPtr->addrRangeArr[5].highBound   =
                tablePtr->baseAddress  + (tablePtr->step * tableInfoPtr->maxNumOfEntries);
            if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                /* Bobcat3 */
                callbackDataPtr->readAfterWrite.tableId =
                    CPSS_DXCH_SIP5_20_TABLE_EGF_QAG_PORT_TARGET_ATTRIBUTES_E;
                /* additional register for Bobcat3 */
                callbackDataPtr->numOfUpdatedRegs = 2;
                callbackDataPtr->updatedRegArr[1].regAddr =
                    PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->
                        EQ.preEgrEngineGlobalConfig.incomingWrrArbiterWeights;
                callbackDataPtr->updatedRegArr[1].updateMask = 0x00007FFF;
                callbackDataPtr->updatedRegArr[1].updateData = 0x00000421;
            }
            else
            {
                /* Bobcat2, BobK and Aldrin */
                callbackDataPtr->readAfterWrite.tableId =
                    CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_QAG_TARGET_PORT_MAPPER_E;
            }
        }
    }
    else
    {
        callbackFuncPtr = NULL;
        callbackDataPtr = NULL;
    }

    prvCpssDrvErrataCallbackBind(
        devNum, callbackFuncPtr, (GT_VOID*)callbackDataPtr);
    return GT_OK;
}
/* flag to allow the debug of fail during phase1 init , without doing cleanup of the 'device DB'
   so we can do read registers to check reason for fail */
GT_STATUS allow_phase1_fail_without_cleanup_set(GT_U32 allow)
{
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.allow_phase1_fail_without_cleanup) = allow;
    return GT_OK;
}

/* pointer to a function used for DXCH devices that will do enhanced
   initialization of SW and HW parameters --  for FUTURE compatibility */
GT_STATUS prvCpssDxChPpConfigEnhancedInitFuncPtrBind(PRV_CPSS_DXCH_PP_CONFIG_ENHANCED_INIT_FUNC funcPtr)
{
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.prvCpssDxChPpConfigEnhancedInitFuncPtr) = funcPtr;
    return GT_OK;
}

/**
* @internal internal_cpssDxChHwPpPhase1Init function
* @endinternal
*
* @brief   This function performs basic hardware configurations on the given PP, in
*         Hw registration phase.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] ppPhase1ParamsPtr        - Packet processor hardware specific parameters.
*
* @param[out] deviceTypePtr            - The Pp's device Id.
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_ALREADY_EXIST         - the devNum already in use
* @retval GT_NOT_SUPPORTED         - the device not supported by CPSS
* @retval GT_OUT_OF_CPU_MEM        - failed to allocate CPU memory,
* @retval GT_BAD_VALUE             - the driver found unknown device type
* @retval GT_NOT_IMPLEMENTED       - the CPSS was not compiled properly
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS internal_cpssDxChHwPpPhase1Init
(
    IN      CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr,
    OUT     CPSS_PP_DEVICE_TYPE                 *deviceTypePtr
)
{
    GT_STATUS rc ;
    GT_U8     devNum;
    GT_U32    portGroupId;/*iterator for port group Id*/
    PRV_CPSS_PP_PRE_PHASE1_INIT_MODE_ENT prePhase1InitMode;
    GT_BOOL   initTableDbDone = GT_FALSE , isCpssMiVarsionscompatible = GT_FALSE;
    CPSS_SYSTEM_RECOVERY_INFO_STC tempSystemRecovery_Info;


cpssOsPrintf("internal_cpssDxChHwPpPhase1Init1\n");

    CPSS_NULL_PTR_CHECK_MAC(ppPhase1ParamsPtr);
    CPSS_NULL_PTR_CHECK_MAC(deviceTypePtr);

    if(71 != PRV_CPSS_DXCH_UNIT___LAST_USED_AS_DIRECT_INDEX____E)
    {
        /*all the indexes above are used as 'index' into array like : prvDxChLion2UnitsBaseAddr[]
          meaning we must NOT add any enumeration value before this index

          so nobody should add new values that will 'move' PRV_CPSS_DXCH_UNIT___LAST_USED_AS_DIRECT_INDEX____E
        */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE,
            "PRV_CPSS_DXCH_UNIT___LAST_USED_AS_DIRECT_INDEX____E must be 71");
    }

cpssOsPrintf("internal_cpssDxChHwPpPhase1Init2\n");
    rc = prvCpssPrePhase1PpInitModeGet(&prePhase1InitMode);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("prvCpssPrePhase1PpInitModeGet(..) : return code is %d", rc);
        return rc;
    }

    devNum = ppPhase1ParamsPtr->devNum;

    /*Lock the access to per device data base in order to avoid corruption*/
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

cpssOsPrintf("internal_cpssDxChHwPpPhase1Init3\n");
    /* check input parameters */
    if(devNum >= PRV_CPSS_MAX_PP_DEVICES_CNS)
    {
        /*Unlock the access to per device data base*/
        CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

        /* bad device number -- out of range */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    else if(PRV_CPSS_PP_MAC(devNum))
    {
        /*Unlock the access to per device data base*/
        CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

        /* the device occupied by some device ... */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_ALREADY_EXIST, LOG_ERROR_NO_MSG);
    }

cpssOsPrintf("internal_cpssDxChHwPpPhase1Init4\n");
    /* initialize the cpssDriver , build the DB needed for the device */
    rc = hwPpPhase1Part1(ppPhase1ParamsPtr, deviceTypePtr);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : return code is %d", rc);
        goto exit_cleanly_lbl;
    }
cpssOsPrintf("internal_cpssDxChHwPpPhase1Init5\n");

    rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
    if (rc != GT_OK)
    {
        return rc;
    }

    /*check if system started in HS mode , if yes check validity of MI version and register state */
cpssOsPrintf("internal_cpssDxChHwPpPhase1Init6\n");
    if ((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HITLESS_STARTUP_E) &&
        (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E))
    {
        rc = prvCpssDxChHitlessStartupStateCheckAndSet(devNum,
                                                       PRV_CPSS_HITLESS_STARTUP_SOFTWARE_INIT_STATE_BOOT_INIT_STATE_DONE_E,
                                                       PRV_CPSS_HITLESS_STARTUP_SOFTWARE_INIT_STATE_HS_IN_PROGRESS_E);

        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("\n prvCpssDxChHitlessStartupStateCheckAndSet rc %d  ", rc);
            return rc;
        }

        if (PRV_NON_SHARED_GLOBAL_VAR_SYSTEM_RECOVERY_DEBUG.hsSkipVersionCheck == GT_FALSE)
        {
            rc = cpssDxChHitlessStartupMiCompatibilityCheck(devNum, NULL, &isCpssMiVarsionscompatible);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("\n cpssDxChHitlessStartupMiCompatibilityCheck rc %d  ", rc);
                return rc;
            }
            if (isCpssMiVarsionscompatible == GT_FALSE)
            {
                CPSS_LOG_INFORMATION_MAC("\n isCpssMiVarsionscompatible  == false   ");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            }
        }
        else
        {
            cpssOsPrintf("\n skip HS version check -debug mode \n");
        }
    }

cpssOsPrintf("internal_cpssDxChHwPpPhase1Init7\n");
    if(falcon_force_stop_init_after_d2d_init_get())
    {
        /* indication that the debug mode focus only on operations
           of the D2D init , and not care about later operation */
        goto exit_cleanly_lbl;
    }

    /* initialize only cpssDriver for HW access, skip the rest */
    if (DXCH_HWINIT_GLOVAR(dxChHwInitSrc.dxChInitRegDefaults) == GT_TRUE)
    {
        /*Unlock the access to per device data base*/
        CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

        return GT_OK;
    }

    /* Trigger the device for the start-init operation. */
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        /* start init sequence for Lion2 */
        rc = hwPpLion2StartInitSet(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpLion2StartInitSet(..) : return code is %d", rc);

            /*Unlock the access to per device data base*/
            CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

            return rc;
        }
    }
    else if (PRV_CPSS_SIP_5_CHECK_MAC(devNum) ||
             PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
        if (rc != GT_OK)
        {
            return rc;
        }
        if (!((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
             (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E)    &&
             (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)) )
        {
            rc = hwPpSip5StartInitSet(devNum, GT_FALSE);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpSip5StartInitSet(..) : return code is %d", rc);

                /*Unlock the access to per device data base*/
                CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

                return rc;
            }
        }
     }

cpssOsPrintf("internal_cpssDxChHwPpPhase1Init8\n");
    /* initialize the board specific parameters and registers the packet
    processor for pre-discovery phase access and diagnostics */
    rc = hwPpPhase1Part2(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part2(..) : return code is %d", rc);
        goto exit_cleanly_lbl;
    }

    if(ppPhase1ParamsPtr->numOfPortGroups == 1)
    {
        /* Initialize the interrupts mechanism for a given device. */
        rc = prvCpssDrvInterruptsInit(devNum,CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS,
                                 ppPhase1ParamsPtr->hwInfo[0].irq.switching,
                                 (GT_U32)ppPhase1ParamsPtr->hwInfo[0].intMask.switching);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_MAC("prvCpssDrvInterruptsInit(..) :devNum[%d] return code is %d", devNum,rc);
            goto exit_cleanly_lbl;
        }
    }
    else
    {
        /* the per port group information taken from ppPhase1ParamsPtr->hwInfo[portGroupId] */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
        {
            /* Initialize the interrupts mechanism for a given device. */
            rc = prvCpssDrvInterruptsInit(devNum,portGroupId,
                                     ppPhase1ParamsPtr->hwInfo[portGroupId].irq.switching,
                                     (GT_U32)ppPhase1ParamsPtr->hwInfo[portGroupId].intMask.switching);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("prvCpssDrvInterruptsInit(..) : return code is %d", rc);
                goto exit_cleanly_lbl;
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    }

cpssOsPrintf("internal_cpssDxChHwPpPhase1Init9\n");
    if (prePhase1InitMode != PRV_CPSS_PP_PRE_PHASE1_INIT_MODE_NO_PP_INIT_E)
    {
        /* do enhanced initialization of SW and HW parameters , if needed */
        if(DXCH_HWINIT_GLOVAR(dxChHwInitSrc.prvCpssDxChPpConfigEnhancedInitFuncPtr))
        {
            rc = DXCH_HWINIT_GLOVAR(dxChHwInitSrc.prvCpssDxChPpConfigEnhancedInitFuncPtr)(devNum);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("prvCpssDxChPpConfigEnhancedInitFuncPtr(..) : return code is %d", rc);
                goto exit_cleanly_lbl;
            }

            if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E) ||
                (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC3X_E))
            {
                PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.numOfLinesInBlock =
                    (((PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.lpmRam)*_2K)/_16K);
            }
        }
    }

cpssOsPrintf("internal_cpssDxChHwPpPhase1Init10\n");
    /* init Cheetah tables database .
       called after : prvCpssDxChPpConfigEnhancedInitFuncPtr
       but should be called even if prvCpssDxChPpConfigEnhancedInitFuncPtr
       is NULL
    */
    rc = prvCpssDxChTablesAccessInit(devNum, GT_TRUE);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("prvCpssDxChTablesAccessInit(..) : return code is %d", rc);
        goto exit_cleanly_lbl;
    }

    initTableDbDone = GT_TRUE;


    if (prePhase1InitMode != PRV_CPSS_PP_PRE_PHASE1_INIT_MODE_NO_PP_INIT_E)
    {
        /* Set Errata issues and registers settings.*/
        rc = hwPpPhase1Part3(devNum, ppPhase1ParamsPtr);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part3(..) : return code is %d", rc);
            goto exit_cleanly_lbl;
        }
    }

cpssOsPrintf("internal_cpssDxChHwPpPhase1Init11\n");
    /* TBD: Shadows to be enabled for SIP6 post some logical init handling */
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) || PRV_CPSS_DXCH_AC5_CHECK_MAC(devNum))
    {
        rc = prvCpssDxChHwPpPhase1ShadowInit(ppPhase1ParamsPtr);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("prvCpssDxChHwPpPhase1ShadowInit(..) : return code is %d", rc);
            goto exit_cleanly_lbl;
        }
    }

cpssOsPrintf("internal_cpssDxChHwPpPhase1Init12\n");
#ifndef ASIC_SIMULATION
    if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) &&
       (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E ||
        PRV_CPSS_SIP_6_CHECK_MAC(devNum)))
    {
        /* Enable DFX power save mode for all connected XSB units */
        rc = prvCpssDxChPacketAnalyzerDfxPowerSaveEnableSet(devNum,GT_TRUE);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
#endif

    /* wait for the device to be ready for traffic */
    rc = hwPpPhase1Part4(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part4(..) : return code is %d", rc);
        goto exit_cleanly_lbl;
    }

    /* set RM (Register Miss-configuration) after tables initialization */
    if (prePhase1InitMode != PRV_CPSS_PP_PRE_PHASE1_INIT_MODE_NO_PP_INIT_E)
    {
        rc = hwPpPhase1RegisterMisconfigurationAfterTablesInit(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1RegisterMisconfigurationAfterTablesInit(..) : return code is %d", rc);
            goto exit_cleanly_lbl;
        }
    }

    /* set final phase 1 register settings :
       called after : prvCpssDxChPpConfigEnhancedInitFuncPtr
       but should be called even if prvCpssDxChPpConfigEnhancedInitFuncPtr
       is NULL
       */
cpssOsPrintf("internal_cpssDxChHwPpPhase1Init13\n");
    if (prePhase1InitMode != PRV_CPSS_PP_PRE_PHASE1_INIT_MODE_NO_PP_INIT_E)
    {
        rc = hwPpPhase1Part5(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : return code is %d", rc);
            goto exit_cleanly_lbl;
        }

        /* set final phase 1 register settings for devices with internal CPU (xCat etc.) where this CPI is disabled    */
        rc = hwPpPhase1Part6(devNum, ppPhase1ParamsPtr);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part6(..) : return code is %d", rc);
            goto exit_cleanly_lbl;
        }

        /* needed for Bobcat2, Caelum, Aldrin, Bobcat3 */
        rc = prvCpssDxChHwPpErrataTailDropTablesAccessCallbackEnable(devNum, GT_TRUE);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC(
                "prvCpssDxChHwPpErrataTailDropTablesAccessCallbackEnable : return code is %d", rc);
            goto exit_cleanly_lbl;
        }

        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
        {
            rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
            if (rc != GT_OK)
            {
                return rc;
            }
            if (tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_NOT_ACTIVE_E)
            {
                rc = prvCpssDxChPortDynamicPATxQHighSpeedPortInit(devNum);
                if (GT_OK != rc)
                {
                    /*Unlock the access to per device data base*/
                    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

                    return rc;
                }
            }
        }
    }
cpssOsPrintf("internal_cpssDxChHwPpPhase1Init14\n");

exit_cleanly_lbl:
    if(rc == GT_HW_ERROR_NEED_RESET)
    {
        /* do not free the memory ... we need to allow the application to do soft reset */

        /*
            When 'phase 1 init' fail , the CPSS 'clean' the DB about this device , by doing so not allow to call any other API (except 'phase 1 init')

            Suggestion :
            1. add special error code 'GT_HW_ERROR_NEED_RESET'
            2. On errors of : GT_HW_ERROR_NEED_RESET the CPSS will NOT clean the DB ... and allow application to call :
                a. Set skip params
                b. 'soft-reset'
                c. Device remove (that clean the DB)
                d. Re-run 'phase 1' init
        */
        if(initTableDbDone == GT_FALSE)
        {
            /* this DB needed by the soft reset API */
            (void)prvCpssDxChTablesAccessInit(devNum, GT_FALSE);
        }
    }
    else
    if (rc != GT_OK
       && (cpssDeviceRunCheck_onEmulator()
          || DXCH_HWINIT_GLOVAR(dxChHwInitSrc.allow_phase1_fail_without_cleanup)/* allow HW debug */))
    {
        /* do not free the memory ... we may need to debug the fail with read/write
           registers */
        if(initTableDbDone == GT_FALSE)
        {
            (void)prvCpssDxChTablesAccessInit(devNum, GT_FALSE);
        }
    }
    else
    if(rc != GT_OK)
    {
        prvCpssGenericSrvCpuRemove(devNum, SRVCPU_IPC_CHANNEL_ALL);
        prvCpssDrvHwPpDevRemove(devNum);

        if(PRV_CPSS_DXCH_PP_MAC(devNum))
        {
            /* restore all the DB state to start point */
            (void)prvCpssDxChHwRegAddrDbRemove(devNum);

            /* do not modify 'rc' that hold ERROR at this point */

            /* free the memory of this device */
            cpssOsFree(PRV_CPSS_PP_MAC(devNum));

            /* set this index as "not occupied" */
            PRV_CPSS_PP_CONFIG_ARR_MAC[devNum] = NULL;
            DXCH_HWINIT_GLOVAR(dxCh_prvCpssPpConfig[devNum]) = PRV_CPSS_PP_CONFIG_ARR_MAC[devNum];
        }

        /* Cleanup all resources allocated for HW Serdes functions */
        mvHwsDeviceClose(devNum);
        /*prvCpssGenericSrvCpuRemove(devNum, SRVCPU_IPC_CHANNEL_ALL);*/
    }
    else /* rc = GT_OK */
    {
        if(falcon_force_stop_init_after_d2d_init_get() &&
            initTableDbDone == GT_FALSE)
        {
            /* we need to init the Tables DB */

            (void)prvCpssDxChTablesAccessInit(devNum, GT_FALSE);
        }
    }

    /*Unlock the access to per device data base*/
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    if(rc != GT_OK)
    {
        /* we must register the error with the ERROR LOG ! */
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }
cpssOsPrintf("internal_cpssDxChHwPpPhase1Init15\n");
    return rc;
}
/**
* @internal cpssDxChHwPpPhase1Init function
* @endinternal
*
* @brief   This function performs basic hardware configurations on the given PP, in
*         Hw registration phase.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] ppPhase1ParamsPtr        - Packet processor hardware specific parameters.
*
* @param[out] deviceTypePtr            - The Pp's device Id.
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_ALREADY_EXIST         - the devNum already in use
* @retval GT_NOT_SUPPORTED         - the device not supported by CPSS
* @retval GT_OUT_OF_CPU_MEM        - failed to allocate CPU memory,
* @retval GT_BAD_VALUE             - the driver found unknown device type
* @retval GT_NOT_IMPLEMENTED       - the CPSS was not compiled properly
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwPpPhase1Init
(
    IN      CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr,
    OUT     CPSS_PP_DEVICE_TYPE                     *deviceTypePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpPhase1Init);
  cpssOsPrintf("\n cpssDxChHwPpPhase1Init1 \n");

    CPSS_API_LOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, ppPhase1ParamsPtr, deviceTypePtr));

    rc = internal_cpssDxChHwPpPhase1Init(ppPhase1ParamsPtr, deviceTypePtr);
  cpssOsPrintf("\n cpssDxChHwPpPhase1Init2 \n");

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, ppPhase1ParamsPtr, deviceTypePtr));
    CPSS_API_UNLOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal hwPpPhase1Part4 function
* @endinternal
*
* @brief   Part 4 of "phase 1"
*         wait for the device , until it is ready for traffic,
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The Pp's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS hwPpPhase1Part4
(
    IN  GT_U8               devNum
)
{
    PRV_CPSS_DXCH_PP_REGS_ADDR_STC  *    regsAddrPtr;
    GT_U32              tmpData;
    GT_U32              timeout;        /* Timeout for waiting for the      */
                                        /* startinit operation to be done.  */
    GT_U32              portGroupId;/*port group Id*/

    /* not needed for xCat3; Lion2; Bobcat2; Caelum; Bobcat3 */
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E ||
        (PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE) ||
        PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        return GT_OK;
    }
    regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum);

    /* read Init State field */
    if(prvCpssHwPpGetRegField(devNum, regsAddrPtr->globalRegs.globalControl,
                              17, 2, &tmpData) != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part4(..) : prvCpssDrvHwPpGetRegField(..) : GT_HW_ERROR");
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    /*need to support multi port groups device,to loop on all port groups*/
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    {
        /* set 1 second timeout */
        timeout = 100;
        while(tmpData != 3)
        {
            if(timeout == 0)
            {
                /* time over, the device is not finished init.
                   This means HW problem... */
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part4(..) : timeout == 0 : GT_FAIL");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
            }

            /* wait till : Initialize is fully functional. */
            if(prvCpssDrvHwPpPortGroupGetRegField(devNum, portGroupId,regsAddrPtr->globalRegs.globalControl,
                                      17, 2, &tmpData) != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part4(..) : prvCpssDrvHwPpPortGroupGetRegField(..) : GT_HW_ERROR");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            cpssOsTimerWkAfter(10);
            timeout--;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)


    return GT_OK;
}

/**
* @internal hwPpTailDropGlobalThresholdsSet function
* @endinternal
*
* @brief   Set TXQ Tail Drop Global Thresholds
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The Pp's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS hwPpTailDropGlobalThresholdsSet
(
    IN  GT_U8               devNum
)
{
    GT_STATUS rc;
    GT_U32    regAddr;
    GT_BOOL   applicable;
    GT_U32    maxBufs;
    GT_U32    maxDescriptors = 0;
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr;

    if((! PRV_CPSS_SIP_5_CHECK_MAC(devNum)) || (PRV_CPSS_SIP_6_CHECK_MAC(devNum)))
    {
        /* relevant only for SIP5 devices */
        return GT_OK;
    }

    fineTuningPtr = &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;
    applicable = GT_FALSE;
    if (fineTuningPtr->tableSize.transmitDescr == _8K)
    {
        /* some kind of reduced BC2 */
        applicable = GT_TRUE;
        /* Limits the total number of descriptors in all egress queues */
        maxDescriptors = 0x1D98;
    }
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
    {
        /* BC3 and Armstrong */
        applicable = GT_TRUE;
        /* Limits the total number of descriptors in all egress queues */
        maxDescriptors = fineTuningPtr->tableSize.transmitDescr - 80; /* see comments in Cider */
    }

    if (applicable == GT_FALSE)
    {
        return GT_OK;
    }

    rc = cpssDxChPortTxGlobalDescLimitSet(devNum, maxDescriptors);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Limits the total number of buffers in all egress queues */
    maxBufs = fineTuningPtr->tableSize.transmitDescr;

    regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropLimits.globalBufferLimit;
    rc = prvCpssHwPpPortGroupSetRegField(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, regAddr, 0, 20, maxBufs);
    if (rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("prvCpssHwPpPortGroupSetRegField(..) : return code is %d", rc);
        return rc;
    }

    return GT_OK;
}

/**
* @internal hwPpPhase1Part5 function
* @endinternal
*
* @brief   Part 5 of "phase 1"
*         set part 5 phase 1 register settings -
*         called after : prvCpssDxChPpConfigEnhancedInitFuncPtr
*         but should be called even if prvCpssDxChPpConfigEnhancedInitFuncPtr
*         is NULL
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The Pp's device number.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS hwPpPhase1Part5
(
    IN  GT_U8               devNum
)
{
    PRV_CPSS_DXCH_PP_REGS_ADDR_STC  *    regsAddrPtr;
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr;
    GT_U32    txDescNum;    /* number of transmit descriptors */
    GT_STATUS rc; /* returned status */
    GT_U32    startBit;/*start bit of the field */
    GT_BOOL   didHwReset; /* flag indicating whether HW reset was done */
    GT_U32    regAddr;/* register address */

    fineTuningPtr = &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;

    /* Set the FDB size configuration */
    rc = prvCpssDxChBrgFdbSizeSet(devNum,fineTuningPtr->tableSize.fdb);
    if(rc != GT_OK)
    {
        return rc;
    }

    if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum))
    {
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_HA_MAC(devNum).haGlobalConfig;
            startBit = 12;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig;
            startBit = 11;
        }

        /* TR101 feature configuration */
        rc = prvCpssHwPpSetRegField(devNum,
                                       regAddr,
                                       startBit,
                                       1,
               BOOL2BIT_MAC(fineTuningPtr->featureInfo.tr101Supported));
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
            return rc;
        }

        /* Resources - buffers & descriptors - size configuration for xCat devices */
        if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
        {
            regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum);
            txDescNum = fineTuningPtr->tableSize.transmitDescr;

            /* MaxBufLimit */
            rc = prvCpssHwPpSetRegField(devNum,
                                           regsAddrPtr->bufferMng.bufMngGlobalLimit,
                                           22, 9,
                                           (txDescNum >> 5 ) - ((txDescNum == _2K) ? 1 : 2 ));
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                return rc;
            }

            /* GlobalXoff */
            rc = cpssDxChGlobalXoffLimitSet(devNum,(txDescNum - 8)/2);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("cpssDxChGlobalXoffLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* GlobalXon */
            rc = cpssDxChGlobalXonLimitSet(devNum,(txDescNum - 8)/2);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("cpssDxChGlobalXonLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* GPortsMaxBufLimit */
            rc = cpssDxChPortGroupRxBufLimitSet(devNum, CPSS_DXCH_PORT_GROUP_GIGA_E,
                                                txDescNum - 16);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("cpssDxChPortGroupRxBufLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* GPortsXoff */
            rc = cpssDxChPortGroupXoffLimitSet(devNum, CPSS_DXCH_PORT_GROUP_GIGA_E,
                                               txDescNum - 8);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("cpssDxChPortGroupXoffLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* GPortsXon */
            rc = cpssDxChPortGroupXonLimitSet(devNum, CPSS_DXCH_PORT_GROUP_GIGA_E,
                                              txDescNum - 8);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("cpssDxChPortGroupXonLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* HGSPortsMaxBufLimit */
            rc = cpssDxChPortGroupRxBufLimitSet(devNum, CPSS_DXCH_PORT_GROUP_HGS_E,
                                                txDescNum - 16);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("cpssDxChPortGroupRxBufLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* HGSPortsXoff */
            rc = cpssDxChPortGroupXoffLimitSet(devNum, CPSS_DXCH_PORT_GROUP_HGS_E,
                                               txDescNum - 8);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("cpssDxChPortGroupXoffLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* HGSPortsXon */
            rc = cpssDxChPortGroupXonLimitSet(devNum, CPSS_DXCH_PORT_GROUP_HGS_E,
                                              txDescNum - 8);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("cpssDxChPortGroupXonLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* MaxSharedBuffersLimit */
            rc = cpssDxChPortTxBuffersSharingMaxLimitSet(devNum, txDescNum - 1);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("cpssDxChPortTxBuffersSharingMaxLimitSet(..) : return code is %d", rc);
                return rc;
            }

            rc = prvCpssPpConfigDevDbHwResetGet(devNum, &didHwReset);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("prvCpssPpConfigDevDbHwResetGet(..) : return code is %d", rc);
                return rc;
            }

            if( GT_TRUE == didHwReset )
            {
                /* FllWrEn set:Write to fll memory, fll_head_ptr and fll_tail_ptr enabled */
                rc = prvCpssHwPpSetRegField(devNum,
                                               regsAddrPtr->bufferMng.bufMngMetalFix,
                                               0, 1, 1);
                if (rc != GT_OK)
                {
                    CPSS_LOG_INFORMATION_MAC("prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                    return rc;
                }

                /* LlTailPtr */
                rc = prvCpssHwPpSetRegField(devNum,
                                               regsAddrPtr->bufferMng.linkedListTailPtr,
                                               0, 14, txDescNum - 1);
                if (rc != GT_OK)
                {
                    CPSS_LOG_INFORMATION_MAC("prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                    return rc;
                }

                /* FllWrEn unset */
                rc = prvCpssHwPpSetRegField(devNum,
                                               regsAddrPtr->bufferMng.bufMngMetalFix,
                                               0, 1, 0);
                if (rc != GT_OK)
                {
                    CPSS_LOG_INFORMATION_MAC("prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                    return rc;
                }
            }

            /* TotalBuffersLimit */
            rc = prvCpssHwPpSetRegField(devNum,
                                           regsAddrPtr->egrTxQConf.totalBufferLimitConfig,
                                           0, 18, txDescNum - 1);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                return rc;
            }

            /* TotalDescLimit */
            rc = prvCpssHwPpSetRegField(devNum,
                                           regsAddrPtr->egrTxQConf.txQueueConfig,
                                           16, 16,
                                           txDescNum - PRV_DXCH_XCAT_PRE_ALLOC_DESC_CNS);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                return rc;
            }

            /* LinkListSize */
            rc = prvCpssHwPpSetRegField(devNum,
                                           regsAddrPtr->egrTxQConf.linkListControlConfig,
                                           0, 2,
                                           (txDescNum == _2K) ? 1 : ((txDescNum == _4K) ? 2 : 0) );
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                return rc;
            }

            /* SharePoolBufLimit, SharePoolDescLimit */
            rc = cpssDxChPortTxSharedGlobalResourceLimitsSet(devNum,
                                                             txDescNum - 4,
                                                             txDescNum - 4);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("cpssDxChPortTxSharedGlobalResourceLimitsSet(..) : return code is %d", rc);
                return rc;
            }
        }
    }

    /* Resources - buffers & descriptors - size configuration for Bobcat2 and Bobcat3 devices */
    rc = hwPpTailDropGlobalThresholdsSet(devNum);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        /* Configure the total TCAM active floor allocation */
        rc = cpssDxChTcamActiveFloorsSet(devNum,
                fineTuningPtr->tableSize.policyTcamRaws/CPSS_DXCH_TCAM_MAX_NUM_RULES_PER_FLOOR_CNS);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("cpssDxChTcamActiveFloorsSet(..) : return code is %d", rc);
            return rc;
        }
    }


    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum) &&
       PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.phaInfo.numOfPpg)
    {
        /* by default disable the PHA clock (to save power) */
        /* to enable it the Application need to call cpssDxChPhaInit(...) */
        rc = prvCpssDxChPhaClockEnable(devNum,GT_FALSE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal hwPpPhase1Part6 function
* @endinternal
*
* @brief   Part 6 of "phase 1"
*         Set final phase 1 register settings for devices with internal CPU (xCat etc.) where this CPU is disabled
*
* @note   APPLICABLE DEVICES:       xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The Pp's device number.
* @param[in] ppPhase1ParamsPtr        - (pointer to) phase1 parameters
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS hwPpPhase1Part6
(
    IN  GT_U8               devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr
)
{
    GT_STATUS   rc; /* returned status */

    /* default for all PPs except BOBCAT3 and ALDRIN2 */
    PRV_CPSS_DXCH_PP_MAC(devNum)->cutThroughEnable = GT_TRUE;
    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
        || (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E))
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->cutThroughEnable = ppPhase1ParamsPtr->cutThroughEnable;
        rc = prvCpssDxChCutThroughBuffresUsingModeSet(
            devNum, PRV_CPSS_DXCH_PP_MAC(devNum)->cutThroughEnable);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("prvCpssDxChCutThroughBuffresUsingModeSet(..) : return code is %d", rc);
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal hwPpPhase2 function
* @endinternal
*
* @brief   Set new devNumber to the PP in Hw and in PP,
*         update the cpssDriver
*         initialize the AU descriptors
*         initialize the FU descriptors
*         initialize the network interface
*         Assume that we are under "locked interrupts"
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] oldDevNum                - The PP's "old" device number.
* @param[in] ppPhase2ParamsPtr        - Phase2 initialization parameters..
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
*
* @note function called when PP's interrupts are disabled !
*
*/
static GT_STATUS hwPpPhase2
(
    IN  GT_U8                                oldDevNum,
    IN  CPSS_DXCH_PP_PHASE2_INIT_INFO_STC    *ppPhase2ParamsPtr
)
{
    GT_STATUS   rc;
    PRV_CPSS_DXCH_MODULE_CONFIG_STC *moduleCfgPtr;/* module config of the device */
    GT_U8   newDevNum = ppPhase2ParamsPtr->newDevNum;/* the new devNum*/
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr;/* pointer to common device info */
    GT_BOOL         enable;/* enable value returned from hw */
    CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_ENT fltTabAccessMode;
                           /* port VLAN egress filtering table access mode */
    GT_U32        fieldValue;/* field value to/from HW */
    GT_HW_DEV_NUM hwDevNum = 0;
    GT_BOOL     isDbaEnable; /* flag indicating if DBA feature is enabled */
    CPSS_SYSTEM_RECOVERY_INFO_STC tempSystemRecovery_Info; /* holds system recovery information */
    CPSS_DXCH_POLICER_MEMORY_STC memoryCfg; /* policer memory (metering and counting) configuration */

    /* update the driver about this action */
    /* let the cpss driver know that the device changed number */
    rc = prvCpssDrvHwPpPhase2Init(oldDevNum,newDevNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssDrvHwPpPhase2Init(..) : return code is %d", rc);
        return rc;
    }

    /* update the DB of the CPSS */

    if(oldDevNum != newDevNum)
    {
        /* set the DB of "old" device number to the "new" device number */
        PRV_CPSS_PP_CONFIG_ARR_MAC[newDevNum] = PRV_CPSS_PP_MAC(oldDevNum);
        /* invalidate the "old" place */
        PRV_CPSS_PP_CONFIG_ARR_MAC[oldDevNum] = NULL;

        DXCH_HWINIT_GLOVAR(dxCh_prvCpssPpConfig[newDevNum]) = PRV_CPSS_PP_CONFIG_ARR_MAC[newDevNum];
        DXCH_HWINIT_GLOVAR(dxCh_prvCpssPpConfig[oldDevNum]) = PRV_CPSS_PP_CONFIG_ARR_MAC[oldDevNum];

        /* swap the device number at the special DB */
        rc = prvCpssPpConfigDevDbRenumber(oldDevNum,newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssPpConfigDevDbRenumber(..) : return code is %d", rc);
            return rc;
        }
    }

    /*************************************************/
    /* from now on we only use the new device number */
    /*************************************************/
    devPtr = PRV_CPSS_PP_MAC(newDevNum);

    /* update the devNum of the device */
    devPtr->devNum = newDevNum;

    /* check if need to synch SDMA issues for the multiple MGs in the device */
    rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
    if (rc != GT_OK)
    {
        return rc;
    }
    if (!((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
          (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E)) )
    {
        rc = sdmaMultiMgSupport(newDevNum);
        if(rc != GT_OK)
        {
            return rc;
        }

    }

    if(PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(newDevNum))
    {
        if (ppPhase2ParamsPtr->netifSdmaPortGroupId != CPSS_PORT_GROUP_UNAWARE_MODE_CNS)
        {
            /* check requested port group is active one */
            if( (ppPhase2ParamsPtr->netifSdmaPortGroupId < PRV_CPSS_PP_MAC(newDevNum)->portGroupsInfo.firstActivePortGroup) ||
                (ppPhase2ParamsPtr->netifSdmaPortGroupId > PRV_CPSS_PP_MAC(newDevNum)->portGroupsInfo.lastActivePortGroup)  ||
                (0 == (PRV_CPSS_PP_MAC(newDevNum)->portGroupsInfo.activePortGroupsBmp &
                                         (1<<(ppPhase2ParamsPtr->netifSdmaPortGroupId)))) )
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : check requested port group is active one : GT_FAIL");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
            }
            /* check that this port group is active ... */
            if (0==(devPtr->portGroupsInfo.activePortGroupsBmp & (1 << ppPhase2ParamsPtr->netifSdmaPortGroupId)))
            {
                /* the needed port group is not active , so can't be used for RGMII */
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : the needed port group is not active , so can't be used for RGMII : GT_BAD_PARAM");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }
        /* here not important which CPU port mode actually used */
        devPtr->portGroupsInfo.cpuPortPortGroupId = devPtr->netifSdmaPortGroupId = ppPhase2ParamsPtr->netifSdmaPortGroupId;

    }
    else
    {
        /* cpuPortPortGroupId for such boards configured in hwPpPhase1Part1 */
        devPtr->portGroupsInfo.cpuPortPortGroupId = devPtr->netifSdmaPortGroupId = PRV_CPSS_FIRST_ACTIVE_PORT_GROUP_ID_MAC(newDevNum);
    }

    devPtr->noTraffic2CPU = ppPhase2ParamsPtr->noTraffic2CPU;
    /*--------------------------*/
    /* initialize pizza arbiter */
    /*--------------------------*/
    if(   devPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E )
    {
        if (tempSystemRecovery_Info.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
        {
            rc = prvCpssDxChPortPizzaArbiterIfInit(newDevNum);
            if(rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc,"hwPpPhase2(..) : prvCpssDxChPortPizzaArbiterIfInit(..) : return code is %d", rc);
            }
        }
    }

    if (PRV_CPSS_SIP_6_30_CHECK_MAC(newDevNum))
    {
        /*Ironman*/
        rc = prvCpssDxChPortDpIronmanDeviceInit(newDevNum);
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(
                rc, "hwPpPhase2(..) : prvCpssDxChPortDpIronmanDeviceInit(..) : return code is %d", rc);
        }
    }
    else
    if (PRV_CPSS_SIP_6_10_CHECK_MAC(newDevNum))
    {
        /* HAWK */
        rc = prvCpssDxChTxPortSpeedPizzaResourcesDeviceInit(newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(
                rc,
                "hwPpPhase2(..) : prvCpssDxChTxPortSpeedPizzaResourcesHawkDeviceInit(..) : return code is %d",
                 rc);
        }
    }
    else if(PRV_CPSS_SIP_6_CHECK_MAC(newDevNum))
    {
        if (tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_NOT_ACTIVE_E)
        {
            rc = prvCpssDxChFalconPortPizzaArbiterInit(newDevNum);
            if(rc != GT_OK)
            {
             CPSS_LOG_ERROR_AND_RETURN_MAC(rc,"hwPpPhase2(..) : prvCpssDxChFalconPortPizzaArbiterInit(..) : return code is %d", rc);
            }
        }
        rc = prvCpssDxChPortResourcesInit(newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc,"hwPpPhase2(..) : prvCpssDxChPortResourcesInit(..) : return code is %d", rc);
        }

        if (!((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
              (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E)) )
        {
            /* Packet Buffer Init */
            rc = prvCpssDxChPortPacketBufferAllTilesInit(newDevNum);
            if(rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(
                    rc,"hwPpPhase2(..) : prvCpssDxChPortPacketBufferAllTilesInit(..) : return code is %d", rc);
            }
        }
    }
    else
    if( PRV_CPSS_SIP_5_CHECK_MAC(newDevNum)==GT_TRUE)
    {
        rc = prvCpssDxChPortPizzaArbiterIfInit(newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc,"hwPpPhase2(..) : prvCpssDxChPortPizzaArbiterIfInit(..) : return code is %d", rc);
        }

        rc = prvCpssDxChPortPizzaArbiterAllCCFCClientsConfigure(newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc,"hwPpPhase2(..) : prvCpssDxChPortPizzaArbiterAllCCFCClientsConfigure(..) : return code is %d", rc);
        }

        rc = prvCpssDxChPortResourcesInit(newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc,"hwPpPhase2(..) : prvCpssDxChPortResourcesInit(..) : return code is %d", rc);
        }
    }

    /* update the special DB -- must be called after the device numbers swapped
       in prvCpssPpConfig and after prvCpssPpConfigDevDbRenumber was called */
    rc = prvCpssPpConfigDevDbInfoSet(newDevNum,ppPhase2ParamsPtr);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssPpConfigDevDbInfoSet(..) : return code is %d", rc);
        return rc;
    }

    /* update the HW about the new devNum */
    /* Device number  */
    if (tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
    {
        /* Read hw devNum from hw */
        rc = cpssDxChCfgHwDevNumGet(newDevNum,&hwDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChCfgHwDevNumGet(..) : return code is %d", rc);
            return rc;
        }
        if (newDevNum != hwDevNum)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChCfgHwDevNumGet(..) : hw devNum =%d currently set in pp is different from new hw devNum =%d going to be set in pp", hwDevNum,newDevNum);
            cpssOsPrintf("hwPpPhase2: cpssDxChCfgHwDevNumGet:WARNING!!! hw devNum =%d currently set in pp is different from new hw devNum =%d going to be set in pp\n",hwDevNum,newDevNum);
        }
    }
    else
    {

        rc = cpssDxChCfgHwDevNumSet(newDevNum, newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChCfgHwDevNumSet(..) : return code is %d", rc);
            return rc;
        }
    }


    if(ppPhase2ParamsPtr->useSecondaryAuq == GT_FALSE)
    {
        /* the WA not requested by the application , even if may be required */
        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(newDevNum,
            PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E);
    }

    /* Now set the rest of the parameters into the  */
    /* module configuration struct in ppConfig.     */
    moduleCfgPtr = PRV_CPSS_DXCH_DEV_MODULE_CFG_MAC(newDevNum);

    moduleCfgPtr->fuqUseSeparate = ppPhase2ParamsPtr->fuqUseSeparate;
    /* AUQ config               */
    moduleCfgPtr->auCfg.auDescBlock     = ppPhase2ParamsPtr->auqCfg.auDescBlock;
    moduleCfgPtr->auCfg.auDescBlockSize = ppPhase2ParamsPtr->auqCfg.auDescBlockSize;
    /* Use addtional primary AU queue */
    moduleCfgPtr->useDoubleAuq = ppPhase2ParamsPtr->useDoubleAuq;

    /* FUQ config               */
    moduleCfgPtr->fuCfg.fuDescBlock     = ppPhase2ParamsPtr->fuqCfg.auDescBlock;
    moduleCfgPtr->fuCfg.fuDescBlockSize = ppPhase2ParamsPtr->fuqCfg.auDescBlockSize;

    /* Network interface config */
    cpssOsMemCpy(&(moduleCfgPtr->netIfCfg.rxBufInfo),
             &(ppPhase2ParamsPtr->netIfCfg.rxBufInfo),sizeof(CPSS_RX_BUF_INFO_STC));

    moduleCfgPtr->netIfCfg.rxDescBlock     = ppPhase2ParamsPtr->netIfCfg.rxDescBlock;
    moduleCfgPtr->netIfCfg.rxDescBlockSize =
        ppPhase2ParamsPtr->netIfCfg.rxDescBlockSize;
    moduleCfgPtr->netIfCfg.txDescBlock     = ppPhase2ParamsPtr->netIfCfg.txDescBlock;
    moduleCfgPtr->netIfCfg.txDescBlockSize =
        ppPhase2ParamsPtr->netIfCfg.txDescBlockSize;

    moduleCfgPtr->useMultiNetIfSdma = ppPhase2ParamsPtr->useMultiNetIfSdma;
    moduleCfgPtr->multiNetIfCfg = ppPhase2ParamsPtr->multiNetIfCfg;
    /*Configure Policer Meterin Configuration Table flags*/
    if (PRV_CPSS_SIP_6_CHECK_MAC(newDevNum))
     {
        /* in sip6 each PLR unit has it's own instance of the Metering Configuration table
           and the entry pointer index is the same as in Metering token table. */

        /* IPLR0 */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.isMeterConfigTableShared[0] = GT_FALSE;
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.meterConfigTableAddBaseAddr[0] = GT_TRUE;
        /* IPLR1 */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.isMeterConfigTableShared[1] = GT_FALSE;
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.meterConfigTableAddBaseAddr[1] = GT_TRUE;
        /* EPLR */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.isMeterConfigTableShared[2] = GT_FALSE;
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.meterConfigTableAddBaseAddr[2] = GT_TRUE;
    }
    else if (PRV_CPSS_SIP_5_20_CHECK_MAC(newDevNum))
    {
       /* In sip20 the Metering Configuration table is shared between IPLR0/1 and EPLR.
           The access to Metering Configuration table is done by IPLR0*/

        /* IPLR0 */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.isMeterConfigTableShared[0] = GT_TRUE;
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.meterConfigTableAddBaseAddr[0] = GT_TRUE;
        /* IPLR1 */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.isMeterConfigTableShared[1] = GT_TRUE;
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.meterConfigTableAddBaseAddr[1] = GT_TRUE;
        /* EPLR */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.isMeterConfigTableShared[2] = GT_TRUE;
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.meterConfigTableAddBaseAddr[2] = GT_TRUE;
    }
    else if(PRV_CPSS_SIP_5_15_CHECK_MAC(newDevNum))
    {
       /* In sip 5_15 the Metering Configuration table is shared between IPLR0/1
           and the access to Metering Configuration table is done by IPLR0.
           EPLR have its own table and the access is without the base address.*/

        /* IPLR0 */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.isMeterConfigTableShared[0] = GT_TRUE;
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.meterConfigTableAddBaseAddr[0] = GT_TRUE;
        /* IPLR1 */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.isMeterConfigTableShared[1] = GT_TRUE;
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.meterConfigTableAddBaseAddr[1] = GT_TRUE;
        /* EPLR */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.isMeterConfigTableShared[2] = GT_FALSE;
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.meterConfigTableAddBaseAddr[2] = GT_FALSE;
     }


    /* configure Policer memories sizes */
    if (PRV_CPSS_DXCH_PP_MAC(newDevNum)->
        fineTuning.featureInfo.iplrSecondStageSupported)
    {
        /* There are two Policer Ingress stages, 256 to lower and the rest to
           upper memory */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[0] =
            (PRV_CPSS_DXCH_PP_MAC(newDevNum)->fineTuning.tableSize.policersNum - 256);
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[1] = 256;

        /* Update the ingress policer counting memory DB with the default sizes
         */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.countingMemSize[CPSS_DXCH_POLICER_STAGE_INGRESS_0_E] = PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[0];
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.countingMemSize[CPSS_DXCH_POLICER_STAGE_INGRESS_1_E] = PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[1];

        /* fix xCat2 HW default for memory configuration to be
            PLR0_28_PLR1_172_84; Policer 0 uses one memory 28
            Policer 1 uses two memories 172+84 = 256.
            Fix Lion2 HW default like xCat and Lion -
            Policer 1 256 entiries, Policer 0 rest.  */
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(newDevNum,
            PRV_CPSS_DXCH_XCAT2_RM_POLICER_MEM_CONTROL_WA_E))
        {
            rc = cpssDxChPolicerMemorySizeModeSet(newDevNum, CPSS_DXCH_POLICER_MEMORY_CTRL_MODE_0_E,0,0);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChPolicerMemorySizeModeSet(..) : return code is %d", rc);
                return rc;
            }
        }
    }
    else
    {
        /* Only one Policer Ingress stage supported.
           Configure memory to be only for IPLR0. */
        rc = cpssDxChPolicerMemorySizeModeSet(newDevNum,
            CPSS_DXCH_POLICER_MEMORY_CTRL_MODE_PLR0_UPPER_AND_LOWER_E,0,0);
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChPolicerMemorySizeModeSet(..) : return code is %d", rc);
            return rc;
        }
    }

    /* AC5P sets policer metering and counting memory differently as sizes
     * of metering table(fineTuning) is diferent than counting table(64K).
     */
    if(PRV_CPSS_SIP_6_10_CHECK_MAC(newDevNum))
    {
        cpssOsMemSet(&memoryCfg, 0, sizeof(CPSS_DXCH_POLICER_MEMORY_STC));

        if(PRV_CPSS_DXCH_PP_MAC(newDevNum)->hwInfo.parametericTables.numEntriesEplrMetering)
        {
            /* default policer memory configuration for CTRL_MODE_0 mode uses below numbers
             * numEntriesIngressStage0 = 2944,
             * mode = "CPSS_DXCH_POLICER_MEMORY_CTRL_MODE_0_E",
             * numEntriesEgressStage = 1024,
             * numEntriesIngressStage1 = 128
             * so IPLR1 uses 128 entries, EPLR uses 1K entries and IPLR0 rest. */

            memoryCfg.numMeteringEntries[CPSS_DXCH_POLICER_STAGE_INGRESS_0_E] =
                PRV_CPSS_DXCH_PP_MAC(newDevNum)->fineTuning.tableSize.policersNum - (128/*IPLR1*/ + _1K/*EPLR*/);
            memoryCfg.numMeteringEntries[CPSS_DXCH_POLICER_STAGE_INGRESS_1_E] = 128;
            memoryCfg.numMeteringEntries[CPSS_DXCH_POLICER_STAGE_EGRESS_E] = _1K;

            memoryCfg.numCountingEntries[CPSS_DXCH_POLICER_STAGE_INGRESS_0_E] =
                PRV_CPSS_DXCH_PP_MAC(newDevNum)->hwInfo.plrInfo.countingEntriesNum - (128/*IPLR1*/ + _1K/*EPLR*/);
            memoryCfg.numCountingEntries[CPSS_DXCH_POLICER_STAGE_INGRESS_1_E] = 128;
            memoryCfg.numCountingEntries[CPSS_DXCH_POLICER_STAGE_EGRESS_E] = _1K;
        }
        else  /* no EPLR in HW */
        {
            if(PRV_CPSS_DXCH_PP_MAC(newDevNum)->fineTuning.featureInfo.iplrSecondStageSupported == GT_FALSE)
            {
                /*Ironman_S*/
                /* all goes to IPLR0 (No IPLR1 and no EPLR) */
                memoryCfg.numMeteringEntries[CPSS_DXCH_POLICER_STAGE_INGRESS_0_E] =
                    PRV_CPSS_DXCH_PP_MAC(newDevNum)->fineTuning.tableSize.policersNum;

                memoryCfg.numCountingEntries[CPSS_DXCH_POLICER_STAGE_INGRESS_0_E] =
                    PRV_CPSS_DXCH_PP_MAC(newDevNum)->hwInfo.plrInfo.countingEntriesNum;
            }
            else /* no such device at the moment */
            {
                /* give 128 to PLR1 */
                memoryCfg.numMeteringEntries[CPSS_DXCH_POLICER_STAGE_INGRESS_0_E] =
                    PRV_CPSS_DXCH_PP_MAC(newDevNum)->fineTuning.tableSize.policersNum - 128/*IPLR1*/;
                memoryCfg.numMeteringEntries[CPSS_DXCH_POLICER_STAGE_INGRESS_1_E] = 128;

                memoryCfg.numCountingEntries[CPSS_DXCH_POLICER_STAGE_INGRESS_0_E] =
                    PRV_CPSS_DXCH_PP_MAC(newDevNum)->hwInfo.plrInfo.countingEntriesNum - 128/*IPLR1*/;
                memoryCfg.numCountingEntries[CPSS_DXCH_POLICER_STAGE_INGRESS_1_E] = 128;
            }
        }

        rc = cpssDxChPolicerMemorySizeSet(newDevNum, &memoryCfg);
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChPolicerMemorySizeSet(..) : return code is %d", rc);
            return rc;
        }
    }
    else if(PRV_CPSS_SIP_5_20_CHECK_MAC(newDevNum))
    {
        /* set PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[2] by
           calling cpssDxChPolicerMemorySizeModeSet(...) */
        rc = cpssDxChPolicerMemorySizeModeSet(newDevNum,
            CPSS_DXCH_POLICER_MEMORY_CTRL_MODE_0_E,0,0);
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChPolicerMemorySizeModeSet(..) : return code is %d", rc);
            return rc;
        }
    }
    else
    {
        /* Policer Egress memory size */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[2] =
            PRV_CPSS_DXCH_PP_MAC(newDevNum)->fineTuning.tableSize.egressPolicersNum;
        /* Update the egress policer counting memory DB with the default sizes
         */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.countingMemSize[CPSS_DXCH_POLICER_STAGE_EGRESS_E] = PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[2];
    }

    /* Set Policer metering calculation method to be CIR and CBS with allowed CIR/PIR deviation to be 10 and
       don't return error if CBS\PBS constraints didn't match */
    rc = cpssDxChPolicerMeteringCalcMethodSet(newDevNum, CPSS_DXCH_POLICER_METERING_CALC_METHOD_CIR_AND_CBS_E /*meteringCalcMethod*/,
                                              10 /*cirPirAllowedDeviation*/, GT_TRUE /*cbsPbsCalcOnFail*/);
    if (rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChPolicerMeteringCalcMethodSet(..) : return code is %d", rc);
        return rc;
    }

    rc = prvCpssDrvInterruptsAfterPhase2(oldDevNum,newDevNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssDrvInterruptsAfterPhase2(..) : return code is %d", rc);
        return rc;
    }

    /* we are checking if the eArch is supported and not enabled because it is
       possible to have <ePort and eVLAN Enable> = Disable and <Extended AU
       Message Enable> is a valide configuration resulting by extended AU
       message to the CPU. */
    if(PRV_CPSS_SIP_5_CHECK_MAC(newDevNum) == GT_TRUE)
    {
        /* set FDB Data base*/
        switch(ppPhase2ParamsPtr->auMessageLength)
        {
            case  CPSS_AU_MESSAGE_LENGTH_4_WORDS_E:
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : ppPhase2ParamsPtr->auMessageLength == CPSS_AU_MESSAGE_LENGTH_4_WORDS_E : GT_NOT_SUPPORTED");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            case CPSS_AU_MESSAGE_LENGTH_8_WORDS_E:
                PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.auMessageNumOfWords = 8;
                break;
            default:
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : ppPhase2ParamsPtr->auMessageLength == %d : GT_NOT_SUPPORTED", ppPhase2ParamsPtr->auMessageLength);
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        if(PRV_CPSS_SIP_6_CHECK_MAC(newDevNum))
        {
            /* get default value from hw --> save to the DB */
            rc = cpssDxChBrgFdbMacEntryMuxingModeGet(newDevNum,
                &PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.sip6FdbMacEntryMuxingMode);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChBrgFdbMacEntryMuxingModeGet(..) : return code is %d", rc);
                return rc;
            }

            /* get default value from hw --> save to the DB */
            rc = cpssDxChBrgFdbIpmcEntryMuxingModeGet(newDevNum,
                &PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.sip6FdbIpmcEntryMuxingMode);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChBrgFdbIpmcEntryMuxingModeGet(..) : return code is %d", rc);
                return rc;
            }

            rc = prvCpssHwPpGetRegField(newDevNum,
                PRV_DXCH_REG1_UNIT_FDB_MAC(newDevNum).FDBCore.FDBGlobalConfig.FDBGlobalConfig2,
                0, 2, &fieldValue);
            if(rc != GT_OK)
            {
                return rc;
            }
            PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.sip6FdbSaDropCommand =
                (fieldValue & BIT_0) ? CPSS_MAC_TABLE_DROP_E /* hard drop */ : CPSS_MAC_TABLE_SOFT_DROP_E/* soft drop */;
            PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.sip6FdbDaDropCommand =
                (fieldValue & BIT_1) ? CPSS_MAC_TABLE_DROP_E /* hard drop */ : CPSS_MAC_TABLE_SOFT_DROP_E/* soft drop */;

            /* by default the muxing mode uses 'TAG_1_VID' , but that differ from
               default of Sip5 devices. */
            /* So use mode that have SRC-ID,UDB,DA access level (without Vid1) */
            rc = cpssDxChBrgFdbMacEntryMuxingModeSet(newDevNum,
                CPSS_DXCH_FDB_MAC_ENTRY_MUXING_MODE_UDB_4_AND_4_SRC_ID_3_DA_ACCESS_LEVEL_E);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /* get default value from hw */
            rc = cpssDxChBrgFdbMaxLengthSrcIdEnableGet(newDevNum, &enable);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChBrgFdbMaxLengthSrcIdEnableGet(..) : return code is %d", rc);
                return rc;
            }

            /* set FDB data base */
            PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.maxLengthSrcIdInFdbEn = enable;

            /* get default value from hw */
            rc = cpssDxChBrgFdbVid1AssignmentEnableGet(newDevNum, &enable);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChBrgFdbVid1AssignmentEnableGet(..) : return code is %d", rc);
                return rc;
             }

            /* set FDB data base */
            PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.tag1VidFdbEn = enable;
        }

        /* In SIP_6 Obsolete Feature - ePort Egress Filtering */
        if(!PRV_CPSS_SIP_6_CHECK_MAC(newDevNum))
        {
            /* get default value from hw */
            rc = cpssDxChBrgEgrFltVlanPortAccessModeGet(newDevNum, &fltTabAccessMode);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChBrgEgrFltVlanPortAccessModeGet(..) : return code is %d", rc);
                return rc;
            }

            /* set FDB data base */
            PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.portVlanfltTabAccessMode = fltTabAccessMode;
        }

        /* get default value from hw */
        /* and save to database */
        rc = cpssDxChNstPortIsolationLookupBitsGet(newDevNum,
                    &PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupPortBits,
                    &PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupDeviceBits,
                    &PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupTrunkBits);

        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChNstPortIsolationLookupBitsGet(..) : return code is %d", rc);
            return rc;
        }

        if(PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupDeviceBits != 5)
        {
            /* restore BC3 defaults to be like in legacy devices */
            rc = cpssDxChNstPortIsolationLookupBitsSet(newDevNum,
                        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupPortBits,
                        5,/*device Bits*/
                        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupTrunkBits);

            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChNstPortIsolationLookupBitsSet(..) : return code is %d", rc);
                return rc;
            }
         }

        /* get default value from hw */
        /* and save to database */
        rc = cpssDxChNstPortIsolationLookupTrunkIndexBaseGet(newDevNum,
            &PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupTrunkIndexBase);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChNstPortIsolationLookupTrunkIndexBaseGet(..) : return code is %d", rc);
            return rc;
        }

        if(PRV_CPSS_SIP_6_10_CHECK_MAC(newDevNum) &&
           PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupTrunkIndexBase != _4K)
        {
            /* EGF-1166 : Port Isolation Lookup 0 <Trunk Index Base>. Default should be 0x1000 (instead of 0x800) */
            /* In Hawk the number of port isolation entries in the table changed from : 2K+128 to 4K+128
               But the default of : < Trunk_Index_Base > is kept 2K (0x800)
               this is wrong default , and should be 4K (0x1000) */
            rc = cpssDxChNstPortIsolationLookupTrunkIndexBaseSet(newDevNum,_4K);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChNstPortIsolationLookupTrunkIndexBaseSet(..) : return code is %d", rc);
                return rc;
            }
        }
    }
    else
    {
        /* AU message size is 4 words */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.auMessageNumOfWords = 4;

        /* set Port data base - default value is 6 bits*/
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupPortBits = 6;

        /* set Port data base - default value is 5 bits*/
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupDeviceBits = 5;

        /* set Port data base - default value is 7 bits*/
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupTrunkBits = 7;

        /* set Port data base - default value is _2K */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupTrunkIndexBase = _2K;
    }

    /* Falcon Packet Buffer - Global Amount of allocated Cells */
    PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.initialAllocatedBuffers = 0;
    if(PRV_CPSS_SIP_6_CHECK_MAC(newDevNum))
    {
        /* default value - will be recalculated below       */
        /* for fast boot - PP already under traffic         */
        /* used constant got by experiment on 4-tile Falcon */
        /* 10560 allocated cells summary on 4 tiles         */
        /* for simulation used the same value               */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.initialAllocatedBuffers =
            (PRV_CPSS_PP_MAC(newDevNum)->multiPipe.numOfTiles * 2640);
#ifndef ASIC_SIMULATION
        if (tempSystemRecovery_Info.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
        {
            rc = cpssDxChPortPacketBufferFillCounterGet(
                newDevNum, 0/*tileIndex*/,
                CPSS_DXCH_PORT_PACKET_BUFFER_COUNTER_MEMORY_SMB_CELLS_E,
                CPSS_DXCH_PORT_PACKET_BUFFER_COUNTER_SCOPE_GLOBAL_E,
                CPSS_DXCH_PORT_PACKET_BUFFER_COUNTER_VALUE_SUM_ALL_E,
                &fieldValue);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC(
                    "hwPpPhase2(..) : cpssDxChPortPacketBufferFillCounterGet(..) : return code is %d", rc);
                return rc;
            }
            PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.initialAllocatedBuffers = fieldValue;
        }
#endif
    }

    /*--------------------*/
    /* init MAC TG driver */
    /*--------------------*/
    if(PRV_CPSS_SIP_6_CHECK_MAC(newDevNum))
    {
        /* TG not implemented yet ! */
    }
    else
    if(   PRV_CPSS_SIP_5_CHECK_MAC(newDevNum)
       || PRV_CPSS_PP_MAC(newDevNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E
       || PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(newDevNum))
    {
        rc = prvCpssDxChMacTGDrvInit(newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssDxChMacTGDrvInit(..) : return code is %d", rc);
            return rc;
        }
    }

    if (PRV_CPSS_PP_MAC(newDevNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
    {
        rc = cpssDxChPortTxDbaEnableGet(newDevNum, &isDbaEnable);
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChPortTxDbaEnableGet(..) : return code is %d", rc);
            return rc;
        }

        if (GT_TRUE == isDbaEnable)
        {
            rc = cpssDxChPortTxDbaAvailBuffSet(newDevNum,
                     PRV_CPSS_DXCH_PP_MAC(newDevNum)->fineTuning.tableSize.transmitDescr);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChPortTxDbaAvailBuffSet(..) : return code is %d", rc);
                return rc;
            }
        }
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChHwPpPhase2Init function
* @endinternal
*
* @brief   This function performs basic hardware configurations on the given PP.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] ppPhase2ParamsPtr        - Phase2 initialization parameters..
*                                       GT_OK on success, or
*                                       GT_FAIL otherwise.
*
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwPpPhase2Init
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PP_PHASE2_INIT_INFO_STC       *ppPhase2ParamsPtr
)
{

    GT_STATUS  rc;
    GT_U8   oldDevNum;/* the "old" device number -- as was given in "phase 1" */

    oldDevNum =  devNum;

    CPSS_NULL_PTR_CHECK_MAC(ppPhase2ParamsPtr);
    PRV_CPSS_DXCH_DEV_CHECK_MAC(oldDevNum);

    if(ppPhase2ParamsPtr->newDevNum != oldDevNum)
    {
        /* we need to check the new device number */

        /* check input parameters */
        if(ppPhase2ParamsPtr->newDevNum >= PRV_CPSS_MAX_PP_DEVICES_CNS)
        {
            /* bad device number -- out of range */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        else if(PRV_CPSS_PP_MAC(ppPhase2ParamsPtr->newDevNum))
        {
            /* the device occupied by some device ... */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_ALREADY_EXIST, LOG_ERROR_NO_MSG);
        }
    }

    /* Lock the interrupts, this phase changes the interrupts nodes       */
    /* pool data. And relocates the port group / driverPpDevs elements.   */
    PRV_CPSS_INT_SCAN_LOCK();

    /*
    *       Set new devNumber to the PP in Hw and in PP,
    *       update the cpssDriver
    *       initialize the AU descriptors
    *       initialize the network interface
    */
    rc = hwPpPhase2(oldDevNum,ppPhase2ParamsPtr);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : return code is %d", rc);
        goto exit_cleanly_lbl;
    }

exit_cleanly_lbl:
    /* UnLock the interrupts */
    PRV_CPSS_INT_SCAN_UNLOCK();

    return rc;

}

/**
* @internal cpssDxChHwPpPhase2Init function
* @endinternal
*
* @brief   This function performs basic hardware configurations on the given PP.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] ppPhase2ParamsPtr        - Phase2 initialization parameters..
*                                       GT_OK on success, or
*                                       GT_FAIL otherwise.
*
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This API is "ISR safe".The interrupt are disabled on API entry and enabled on API exit
*
*/
GT_STATUS cpssDxChHwPpPhase2Init
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PP_PHASE2_INIT_INFO_STC       *ppPhase2ParamsPtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpPhase2Init);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    PRV_CPSS_INT_SCAN_LOCK();
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ppPhase2ParamsPtr));

    rc = internal_cpssDxChHwPpPhase2Init(devNum, ppPhase2ParamsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ppPhase2ParamsPtr));
    PRV_CPSS_INT_SCAN_UNLOCK();
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal hwPpPhyRegisterWrite function
* @endinternal
*
* @brief   Performs smi Phy write operation including poling on Buzy bit.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number.
* @param[in] addr                     - the smi phy configuration register.
* @param[in] data                     -  to write including the phy address.
* @param[in] mask                     - perform read modify write.
* @param[in/out] setPhyRegBeforeControlRegPtr - pointer to state variable
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - on timed out retries
*/
static GT_STATUS hwPpPhyRegisterWrite
(
    IN GT_U8  devNum,
    IN GT_U32 addr,
    IN GT_U32 mask,
    IN GT_U32 data,
    INOUT GT_BOOL *setPhyRegBeforeControlRegPtr
)
{
    GT_U32      smiRegConfig;     /* holds the content of the
                                  configuration register*/
    GT_U32      busyBitNumber;    /* holds the smi busy valid bit number*/
    GT_BOOL     isXgPort;         /* GT_TRUE - XG port PHY is configured
                                     GT_FALSE - GE port PHY is configured*/
    GT_U32      comp;
    GT_U32      j;                /* Time out pooling index*/

    /* Get the Xg smi control register address*/
    if ((addr == PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.smi10GeControl) ||
        (addr == PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.smi10GeAddr))
    {
        isXgPort = GT_TRUE;
    }
    else
    {
        isXgPort = GT_FALSE;
    }

    /* Zero SMi control word*/
    smiRegConfig = 0;

    /* Set the busy bit, opcode for xg phy*/
    if (isXgPort == GT_TRUE)
    {
        busyBitNumber = 30;
    }
    else
    {
        busyBitNumber = 28;
    }

    /* Perform write operation - check that SMI of XSMI Master is finished
       previous transaction by polling the busy bit */
    if (((isXgPort == GT_TRUE) && (addr == PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.smi10GeAddr))||
        (isXgPort == GT_FALSE))
    {
        j = 0;
        do
        {
            if (prvCpssHwPpReadRegister(devNum, addr, &smiRegConfig) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
            comp = (smiRegConfig >> busyBitNumber) & 0x1;

            if( (j++) == HW_INIT_SMI_POOLING_TIMEOUT_CNS )
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);

#ifdef ASIC_SIMULATION
            /* one iteration is enough */
            comp = 0;
#endif /*ASIC_SIMULATION*/
        }while (comp);
    }


    /* Set the data according to the mask*/
    mask &= 0xFFFF;                     /* Zero 16 msbis*/
    smiRegConfig &= (~mask);            /* Turn the field off.   */
    smiRegConfig |= (data & mask);

    if (isXgPort == GT_TRUE)
    {
        if (addr == PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.smi10GeAddr)
        {
            if(*setPhyRegBeforeControlRegPtr == GT_TRUE)
            {
                /*OpCode 0x5 - issue 'Address' SMI Frame the issue 'Write' SMI frame*/
                U32_SET_FIELD_MAC(smiRegConfig, 26, 3, 5);
                *setPhyRegBeforeControlRegPtr = GT_FALSE;
            }
            else
            {
                /*OpCode 0x1 - issue 'WRITE' SMI frame*/
                U32_SET_FIELD_MAC(smiRegConfig, 26, 3, 1);
            }

            /* Set the address from the input*/
            U32_SET_FIELD_MAC(smiRegConfig, 16, 10, (data >> 16));
        }
        else
        {
            *setPhyRegBeforeControlRegPtr = GT_TRUE;
        }
    }
    else
    {
        U32_SET_FIELD_MAC(smiRegConfig, 26, 1, 0);      /*OpCode 0x0 - issue 'WRITE' SMI frame*/
        /* Set the address from the input*/
        U32_SET_FIELD_MAC(smiRegConfig, 16, 10, (data >> 16));
    }

    /* Perform the phy write operation*/
    if (prvCpssHwPpWriteRegister(devNum, addr, smiRegConfig) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal hwPpStartInit function
* @endinternal
*
* @brief   This phase performs the start-init operation on a given device, and sets
*         it's registers according to the registers value list passed by user.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The device number to which the start-init operation
*                                      should be done.
* @param[in] initDataListPtr          - (pointer to) List of registers values to be set to the device.
* @param[in] initDataListLen          - Number of elements in ppRegConfigList
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
*
* @note This function should be invoked after cpssExMxHwPpPhase1Init() and
*       before cpssDxChHwPpPhase2Init().
*       1. Before the device is enabled, all ports will be set to disable state
*       to make sure that no packets are forwarded before the system is
*       fully initialized.
*
*/
static GT_STATUS hwPpStartInit
(
    IN  GT_U8                       devNum,
    IN  CPSS_REG_VALUE_INFO_STC     *initDataListPtr,
    IN  GT_U32                      initDataListLen
)
{
    GT_STATUS   rc = GT_OK;         /* Function's return value.                 */
    GT_BOOL     setMatch;       /* Indicates if the device's set matches    */
                                /* the next section.                        */
    GT_BOOL     deviceFound;    /* Indicates if the device's set was found  */
                                /* in the data-list.                        */
    GT_U32      i;              /* Loops index.                             */
    GT_U32      j;              /* Loops index.                             */
    GT_U32      cnt;            /* Repeat counter index.                    */
    CPSS_REG_VALUE_INFO_STC  *regValuePtr; /* pointer to the current reg value*/
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = PRV_CPSS_PP_MAC(devNum);/* pointer to common device info */
    CPSS_SYSTEM_RECOVERY_INFO_STC tempSystemRecovery_Info;
    GT_BOOL setPhyRegBeforeControlReg = GT_FALSE; /* Control register or Phy register - device with Single XG port*/


    deviceFound = GT_FALSE;
    rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
    if (rc != GT_OK)
    {
        return rc;
    }
    if ((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
        (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E) )
    {
        return GT_OK;
    }
    /* Search for the corresponding set to configure.   */
    /* Currently the set number is the device's         */
    /* revision number.                                 */
    /* SHOULD BE FIXED TO CONSIDER THE DEVICE'S SET #   */
    i = 0;
    while(i < initDataListLen)
    {
        /* For now, just find the device's revision number  */
        setMatch = GT_FALSE;
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            if(devPtr->revision == initDataListPtr[i].addrType)
            {
                setMatch = GT_TRUE;
                break;
            }
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        if(setMatch == GT_FALSE)
        {
            /* Go to the next section.          */
            /* Count 3 delimiters.              */
            j = 0;
            while((j < 3) && (i < initDataListLen))
            {
                if(initDataListPtr[i].addrType == CPSS_REG_LIST_DELIMITER_CNS)
                {
                    j++;
                }
                i++;
            }

            if((i == initDataListLen) && (deviceFound == GT_FALSE))
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            continue;
        }

        deviceFound = GT_TRUE;

        /* set Match == GT_TRUE         */
        /* Find the first delimiter.    */
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* Jump over the delimiter.     */
        i++;

        /* Write the pre start-init register values.        */
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            /* This is a phy read/write */
            if (initDataListPtr[i].addrType == CPSS_REG_PHY_ADDR_TYPE_CNS)
            {
                /* Search for the next delimiter*/
                j=i+1;
                while((initDataListPtr[j].addrType != CPSS_REG_PHY_ADDR_TYPE_CNS) &&
                      (j < initDataListLen))
                {
                    /* section delimiter found before phy delimiter*/
                    if (initDataListPtr[i].addrType == CPSS_REG_LIST_DELIMITER_CNS)
                    {
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                    }
                    j++;
                }

                /* If phy second delimiter was not found */
                if (j == initDataListLen)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /* Perform the write operation for all the phy whithin the
                    section*/
                while(initDataListPtr[i].addrType != CPSS_REG_PHY_ADDR_TYPE_CNS)
                {
                    regValuePtr = &initDataListPtr[i];
                    /* section delimiter found before phy delimiter*/
                    rc = hwPpPhyRegisterWrite(devNum,
                                              regValuePtr->addrType,
                                              regValuePtr->regMask,
                                              regValuePtr->regVal,
                                              &setPhyRegBeforeControlReg);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                    i++;
                }
                /* Skip the delimiter*/
                i++;
                continue;
            }

            for(cnt = 0; cnt < initDataListPtr[i].repeatCount; cnt++)
            {
                rc = prvCpssHwPpWriteRegBitMask(devNum,initDataListPtr[i].addrType,
                                             initDataListPtr[i].regMask,
                                             initDataListPtr[i].regVal);

                if(rc != GT_OK)
                {
                    return rc;
                }
            }
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* Reached the end of a section.            */
        /* Jump over the delimiter.                 */
        i++;

        /* Find the delimiter of the section end.   */
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        i++;
    }

    if((deviceFound == GT_FALSE) && (initDataListLen != 0))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_FOUND, LOG_ERROR_NO_MSG);
    }

    /* Search for the corresponding set to configure.   */
    /* Currently the set number is the device's         */
    /* revision number.                                 */
    /* SHOULD BE FIXED TO CONSIDER THE DEVICE'S SET #   */
    i = 0;
    while(i < initDataListLen)
    {
        /* For now, just find the device's revision number  */
        setMatch = GT_FALSE;
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            if(devPtr->revision == initDataListPtr[i].addrType)
            {
                setMatch = GT_TRUE;
                break;
            }
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        if(setMatch == GT_FALSE)
        {
            /* Go to the next section.          */
            /* Count 3 delimiters.              */
            j = 0;
            while((j < 3) && (i < initDataListLen))
            {
                if(initDataListPtr[i].addrType == CPSS_REG_LIST_DELIMITER_CNS)
                {
                    j++;
                }
                i++;
            }

            if((i == initDataListLen) && (deviceFound == GT_FALSE))
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            continue;
        }

        /* set Match == GT_TRUE         */
        /* Count 2 delimiters.          */
        j = 0;
        while((j < 2) && (i < initDataListLen))
        {
            if(initDataListPtr[i].addrType == CPSS_REG_LIST_DELIMITER_CNS)
            {
                j++;
            }
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* Write the post start-init register values.       */
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            /* Phy delimiter operation*/
            if (initDataListPtr[i].addrType == CPSS_REG_PHY_ADDR_TYPE_CNS)
            {
                /* Search for the next delimiter*/
                j=i+1;
                while((initDataListPtr[j].addrType != CPSS_REG_PHY_ADDR_TYPE_CNS) &&
                      (j < initDataListLen))
                {
                    /* section delimiter found before phy delimiter*/
                    if (initDataListPtr[i].addrType == CPSS_REG_LIST_DELIMITER_CNS)
                    {
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                    }
                    j++;
                }

                /* If phy second delimiter was not found */
                if (j == initDataListLen)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /* Perform the write operation for all the phy whithin the
                    section*/
                i++;
                while(initDataListPtr[i].addrType != CPSS_REG_PHY_ADDR_TYPE_CNS)
                {
                    regValuePtr = &initDataListPtr[i];
                    /* section delimiter found before phy delimiter*/
                    rc = hwPpPhyRegisterWrite(devNum,
                                                       regValuePtr->addrType,
                                                       regValuePtr->regMask,
                                                       regValuePtr->regVal,
                                                       &setPhyRegBeforeControlReg);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                    i++;
                }
                /* Skip the delimiter*/
                i++;
                continue;
            }

            for(cnt = 0; cnt < initDataListPtr[i].repeatCount; cnt++)
            {
                rc = prvCpssHwPpWriteRegBitMask(devNum,initDataListPtr[i].addrType,
                                             initDataListPtr[i].regMask,
                                             initDataListPtr[i].regVal);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }


        /* Reached the end of a section.            */
        /* Jump over the delimiter.                 */
        i++;
    }


    return GT_OK;
}

/**
* @internal hwPpUnitAddressCheck function
* @endinternal
*
* @brief   Check if single unit address range comprises restricted addresses.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The device number
* @param[in] portGroupId              - The port group Id. relevant only to 'multi-port-groups' devices,
*                                      supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS.
* @param[in] addr                     - Start offset address to check inside the unit
* @param[in] length                   - The  of the memory to check inside the unit (the legth is in words).
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on restricted address
*/
static GT_STATUS hwPpUnitAddressCheck
(
    IN GT_U8  devNum,
    IN GT_U32 portGroupId,
    IN GT_U32 addr,
    IN GT_U32 length
)
{
    PRV_CPSS_DXCH_ERRATA_UNIT_RANGES_STC    *unitRangesPtr; /* unit ranges and
                                                               their number */
    GT_U32                                  unitId;         /* unit Id */
    GT_U32                                  rangeId;        /* range Id, inside
                                                               the unit */
    GT_U32                                  portGroupsBmp;

    /* Ignore 2 LSB */
    addr &= 0xFFFFFFFC;/* ignore 2 LSB */

    if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        unitId = (addr >> 24) & 0x3F;
    }

    else
    {
        unitId = (addr >> 23) & 0x3F;
    }

    if (unitId >= UNITS_NUM_CNS)
    {
        return GT_OK;
    }

    if (!PRV_CPSS_IS_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
    {
        /* XCAT A1 */
        portGroupId = 0;
    }

    if (portGroupId == CPSS_PORT_GROUP_UNAWARE_MODE_CNS)
    {
        portGroupsBmp = PRV_CPSS_PP_MAC(devNum)->
                                    portGroupsInfo.activePortGroupsBmp;
    }
    else
    {
        portGroupsBmp = (1 << portGroupId);
    }

    /* loop on all active port groups in the bmp */
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(devNum,portGroupsBmp,portGroupId)
    {
        unitRangesPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                        info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.unitRangesPtr[portGroupId];

        if (unitRangesPtr[unitId].numOfRanges == 0)
        {
            /* no restricted ranges in this unit, move to the next portGroup */
            continue;
        }

        /* There are some restricted ranges in this unit */

        /* check if there is restricted range inside the address range given */
        for (rangeId = 0; rangeId < unitRangesPtr[unitId].numOfRanges; rangeId++)
        {
            if (addr > unitRangesPtr[unitId].rangesPtr[rangeId].addrEnd)
            {
                /* move to the next range */
                continue;
            }

            /* check if the address range ends before start of the restricted range */
            if ((addr + (length * 4) - 4) < unitRangesPtr[unitId].rangesPtr[rangeId].addrStart)
            {
                /* the address range has no restricted ranges */
                return GT_OK;
            }

            /* the restricted range is fully or partially inside the address range */
            if (unitRangesPtr[unitId].rangesPtr[rangeId].addrMask == 0x0)
            {
                /* the whole range is restricted */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "Address 0x%08X in fully resticted range[%d] of unit[%d]", addr, rangeId, unitId);
            }
            else
            {
                /* Not the whole range is restricted, there are valid and not
                   valid adrdesses inside the range */

                if ((addr & unitRangesPtr[unitId].rangesPtr[rangeId].addrMask) ==
                     unitRangesPtr[unitId].rangesPtr[rangeId].addrPattern)
                {
                    /* this specific address is not valid */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "Address 0x%08X in resticted range[%d] of unit[%d]", addr, rangeId, unitId);
                }

                /* this specific address is valid */
                return GT_OK;
            }
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(devNum,portGroupsBmp,portGroupId)


    return GT_OK;
}

/**
* @internal hwPpAddressCheck function
* @endinternal
*
* @brief   Check if address range comprises restricted addresses.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The device number
* @param[in] portGroupId              - The port group Id. relevant only to 'multi-port-groups' devices,
*                                      supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS.
* @param[in] addr                     - Start offset address to check
* @param[in] length                   - The  of the memory to check (the legth is in words).
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error.
* @retval GT_BAD_PARAM             - on bad devNum or restricted address
*/
static GT_STATUS hwPpAddressCheck
(
    IN GT_U8  devNum,
    IN GT_U32 portGroupId,
    IN GT_U32 addr,
    IN GT_U32 length
)
{
    GT_U32      unitId;         /* unit Id, loop iterator           */
    GT_U32      unitIdStart;    /* start unit Id of the range       */
    GT_U32      unitIdEnd;      /* end unit Id of the range         */
    GT_U32      startAddr;      /* start address of the range       */
    GT_U32      endAddr;        /* end address of the range         */
    GT_U32      unitLen;        /* The length inside specific unit  */
    GT_STATUS   rc;             /* return status                    */


    /* calculate end address of the range */
    endAddr = (addr + (length * 4) - 4) & 0xFFFFFFFC;

    /* Unit Id is defined by bits 24-31 */
    if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        unitIdStart = ((addr >> 24) & 0x3F);
        unitIdEnd = ((endAddr >> 24) & 0x3F);
    }

    /* Unit Id is defined by bits 23-28 */
    else
    {
        unitIdStart = ((addr >> 23) & 0x3F);
        unitIdEnd = ((endAddr >> 23) & 0x3F);
    }

    if(endAddr >
       PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
       info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.lastValidAddress)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (unitIdStart == unitIdEnd)
    {
        /* There is only one unit to check */
        rc = hwPpUnitAddressCheck(devNum,
                                  portGroupId,
                                  addr,
                                  length);
        return rc;
    }

    /* In case there are more than one unit in a range */
    for (unitId = unitIdStart; unitId <= unitIdEnd; unitId++)
    {
        if (unitId == unitIdStart)
        {
            /* The range ends in the start of the next unit */
            startAddr = addr;
            unitLen = (((unitId + 1) << 23) - (addr & 0xFFFFFFFC)) / 4 ;
        }
        else if (unitId == unitIdEnd)
        {
            /* The address starts at the start of unit */
            startAddr = (unitId << 23);
            unitLen = ((endAddr - startAddr) / 4) + 1;
        }
        else
        {
            /* all units that are inside the range */
            startAddr = (unitId << 23);
            /* The whole unit range should be checked */
            unitLen = PRV_DXCH_MAX_UNIT_ADDR_RANGE_CNS;
        }

        rc = hwPpUnitAddressCheck(devNum,
                                  portGroupId,
                                  startAddr,
                                  unitLen);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal hwPpAddressCheckAldrin function
* @endinternal
*
* @brief   Check if address range comprises restricted addresses.
*
* @note   APPLICABLE DEVICES:      Aldrin; AC3X
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The device number
* @param[in] portGroupId              - The port group Id. relevant only to 'multi-port-groups' devices,
*                                      supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS.
* @param[in] addr                     - Start offset address to check
* @param[in] length                   - The  of the memory to check (the legth is in words).
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error.
* @retval GT_BAD_PARAM             - on bad devNum or restricted address
*/
static GT_STATUS hwPpAddressCheckAldrin
(
    IN GT_U8  devNum,
    IN GT_U32 portGroupId,
    IN GT_U32 addr,
    IN GT_U32 length
)
{
    (void)devNum;
    (void)portGroupId;
    /* Protect addresses
     *   (0x10180200 .. 0x101802FF) + 0x1000* k
     * where k (0-31) represents Port
     */
    for (; length; length--, addr+=4)
    {
        if ((addr & 0xfffe0f00) == 0x10180200)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal hwPpAddressCheckAldrin2 function
* @endinternal
 *
* @brief   Check if address range comprises restricted addresses.
 *
* @note   APPLICABLE DEVICES:      Aldrin2; Bobcat3.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Falcon; AC5P; AC5X; Harrier; Ironman.
 *
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error.
* @retval GT_BAD_PARAM             - on bad devNum or restricted address
* @param[in] devNum                - The device number
* @param[in] portGroupId           - The port group Id.
*                                    relevant only
*                                    to 'multi-port-groups'
*                                    devices, supports value
*                                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS.
* @param[in] addr                  - Start offset ess to check
* @param[in] length                - The  of the memory to check
*                                    (the legth is in words).
*/
static GT_STATUS hwPpAddressCheckAldrin2
(
    IN GT_U8  devNum,
    IN GT_U32 portGroupId,
    IN GT_U32 addr,
    IN GT_U32 length
)
{
     GT_U32 entryIndex;
     GT_U32 offset;
    (void)portGroupId;

    /* Protect addresses for LPM Memory - Half Mode
     * Bobcat3
     * LPM Unit0 0x44000000, LPM Unit1 0x45000000, LPM Unit2 0x46000000, LPM Unit3 0x47000000
     * LPM MEM Entry Offset: 0x44000000+ 4*(16384*b+l): where b (0-19) represents RAM bank,
     * where l (0-16383) represents Bank line
     * LPM Memory - Half Mode only 0-8191 is a legal Bank line
     *
     * Aldrin2
     * LPM Unit0 0x44000000, LPM Unit1 0x45000000
     * LPM MEM Entry Offset: 0x44000000+ 4*(16384*b+l) : where b (0-19) represents RAM bank,
     * where l (0-8191) = Bank line
     * LPM Memory - Half Mode only 0-4095 is a legal Bank line
     *
     */
    for (; length; length--, addr+=4)
    {
        if((addr & 0xFFF00000)==PRV_CPSS_DXCH_BOBCAT3_BASE_ADDRESS_LPM_CNS ||
           (addr & 0xFFF00000)==PRV_CPSS_DXCH_BOBCAT3_BASE_ADDRESS_LPM_1_CNS ||
           (addr & 0xFFF00000)==PRV_CPSS_DXCH_BOBCAT3_BASE_ADDRESS_LPM_2_CNS ||
           (addr & 0xFFF00000)==PRV_CPSS_DXCH_BOBCAT3_BASE_ADDRESS_LPM_3_CNS)
        {
            /* each line hold 4 bytes */
            entryIndex = (addr & 0x000FFFFF)/4;
            offset = entryIndex%(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.totalNumOfLinesInBlockIncludingGap);
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.lpmMemMode==PRV_CPSS_DXCH_LPM_RAM_MEM_MODE_HALF_MEM_SIZE_E)
            {
                 if (offset >= (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.numOfLinesInBlock / 2))
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            else /* PRV_CPSS_DXCH_LPM_RAM_MEM_MODE_FULL_MEM_SIZE_E */
            {
                if (offset >= PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.numOfLinesInBlock)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

        }
    }
    return GT_OK;
}

/**
* @internal internal_cpssDxChHwPpStartInit function
* @endinternal
*
* @brief   This phase performs the start-init operation on a given device, and sets
*         it's registers according to the registers value list passed by user.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The device number to which the start-init operation
*                                      should be done.
* @param[in] initDataListPtr          - List of registers values to be set to the device.
* @param[in] initDataListLen          - Number of elements in ppRegConfigList
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - on timed out retries
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This function should be invoked after cpssDxChHwPpPhase1Init() and
*       before cpssDxChHwPpPhase2Init().
*
*/
static GT_STATUS internal_cpssDxChHwPpStartInit
(
    IN  GT_U8                       devNum,
    IN  CPSS_REG_VALUE_INFO_STC     *initDataListPtr,
    IN  GT_U32                      initDataListLen
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(initDataListPtr);

    /* set registers according to the registers value list passed by user */
    return hwPpStartInit(devNum,initDataListPtr,initDataListLen);
}

/**
* @internal cpssDxChHwPpStartInit function
* @endinternal
*
* @brief   This phase performs the start-init operation on a given device, and sets
*         it's registers according to the registers value list passed by user.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The device number to which the start-init operation
*                                      should be done.
* @param[in] initDataListPtr          - List of registers values to be set to the device.
* @param[in] initDataListLen          - Number of elements in ppRegConfigList
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - on timed out retries
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note This function should be invoked after cpssDxChHwPpPhase1Init() and
*       before cpssDxChHwPpPhase2Init().
*
*/
GT_STATUS cpssDxChHwPpStartInit
(
    IN  GT_U8                       devNum,
    IN  CPSS_REG_VALUE_INFO_STC     *initDataListPtr,
    IN  GT_U32                      initDataListLen
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpStartInit);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, initDataListPtr, initDataListLen));

    rc = internal_cpssDxChHwPpStartInit(devNum, initDataListPtr, initDataListLen);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, initDataListPtr, initDataListLen));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock function
* @endinternal
*
* @brief   Locks/unlocks the task switching and disables/enables the link status
*         change interrupt
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupId              - The port group Id. relevant only to 'multi-port-groups' devices.
*                                      supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
*                                      although in xcat/xcat2 not relevant let it be as preparation for
*                                      future
* @param[in] portNum                  - port number
* @param[in] lock                     - GT_TRUE - to  task switching and to disable interrupt
*                                      - GT_FALSE - to enable interrupt and to unlock task switching
* @param[in,out] savedStatePtr            - for "lock" - nothing, for "unlock" - saved state
* @param[in,out] savedStatePtr            - for "lock" - place to save state, for "unlock" - nothing
*
* @retval GT_OK                    - success
* @retval GT_NOT_INITIALIZED       - the internal DB for the 'WA' was not initialized
*/
static GT_STATUS prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock
(
    IN    GT_U8                             devNum,
    IN    GT_U32                            portGroupId,
    IN    GT_PHYSICAL_PORT_NUM              portNum,
    IN    GT_BOOL                           lock,
    INOUT GT_U32                            *savedStatePtr
)
{
    GT_BOOL   linkChIntEn; /* link chanhe interrupt enable       */
    GT_U32    data;        /* work data                          */
    GT_STATUS rc;          /* return code                        */

    if (lock != GT_FALSE)
    {
        /* initialize for abnormal return case */
        *savedStatePtr = 0;
    }

    if (lock == GT_FALSE)
    {
        /* UNLOCK case */

        linkChIntEn = (GT_BOOL)*savedStatePtr;
        rc = GT_OK;

        /* Link Change - interrupt enable */

        if (GT_FALSE != linkChIntEn)
        {
            PRV_CPSS_INT_SCAN_LOCK();

            /* clear Port Interrupt Cause register by read */
            rc = prvCpssHwPpPortGroupReadRegister(devNum,
                    portGroupId,
                    GE_MAC_PORT_INTERRUPT_CAUSE_MAC(portNum),
                    &data);

            /* unmask - i.e. event enable.                */
            /* prvCpssDrvEventsMask may return not GT_OK  */
            /* if interrupt was not binded by application */
            /* or interrupts are not used.                */
            /* Need to ignore this fail.                  */
            (void)prvCpssDrvEventsMask(devNum,
                GE_MAC_PORT_INTERRUPT_INDEX_MAC(devNum, portNum),
                GT_FALSE);

            PRV_CPSS_INT_SCAN_UNLOCK();
        }

        PRV_CPSS_UNLOCK_BY_MUTEX;

        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        /* LOCK case */
        PRV_CPSS_LOCK_BY_MUTEX;

        PRV_CPSS_INT_SCAN_UNLOCK();

        prvCpssDrvEventsMaskGet(devNum,
            GE_MAC_PORT_INTERRUPT_INDEX_MAC(devNum, portNum),
            &linkChIntEn);

        if (GT_FALSE != linkChIntEn)
        {
            /* Link Change - interrupt disable            */
            /* mask - i.e. event disable.                 */
            /* prvCpssDrvEventsMask may return not GT_OK  */
            /* if interrupt was not binded by application */
            /* or interrupts are not used.                */
            /* Need to ignore this fail.                  */
            (void)prvCpssDrvEventsMask(devNum,
                GE_MAC_PORT_INTERRUPT_INDEX_MAC(devNum, portNum),
                GT_TRUE);
        }

        PRV_CPSS_INT_SCAN_UNLOCK();

        *savedStatePtr = (GT_U32)linkChIntEn;
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChHwPpXcatSgmii25FLUpBadStateCheckAndFix function
* @endinternal
*
* @brief   Discover and fix bad state of flex link status change state machine
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:   None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*
* @retval GT_OK                    - success
* @retval GT_TIMEOUT               - state machine fix failed after numerous tries
*/
static GT_STATUS prvCpssDxChHwPpXcatSgmii25FLUpBadStateCheckAndFix
(
    IN GT_U8 devNum,
    IN GT_PHYSICAL_PORT_NUM portNum
)
{
    GT_STATUS   rc;     /* return code */
    GT_U32      status; /* port link state machine status */
    GT_U32      savedState; /* link change interrupt state */
    GT_U32      timeout;    /* counter of tries to fix link up
                                state machine */
    GT_U32      regAddr;    /* register address */
    GT_U32      lms0MiscCfgRegAddr = PRV_CPSS_SW_PTR_ENTRY_UNUSED;
                                    /* register address of lms0MiscConfig */
    GT_U32      debugBusRegOffset; /* offset to read in debug bus register */

    FLEX_LINK_UP_WA_DBG_PRINT_MAC(("prvCpssDxChHwPpXcatSgmii25FLUpBadStateCheckAndFix:  \
                                    devNum=%d,portNum=%d\n",
                                    devNum, portNum));

    if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) == GT_TRUE)
    {
        /* The XG port number "port_num" drives the debug bus */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->debugBusRegs.debugCtrl2;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 6, portNum);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* Control which internal XG debug register will drive the debug bus */
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 6, 6, 3);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        lms0MiscCfgRegAddr =
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms0MiscConfig;

        /*Port number to be debugged.*/
        rc = prvCpssHwPpSetRegField(devNum, lms0MiscCfgRegAddr, 6, 6, portNum);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* The Debug Group of the selected port */
        rc = prvCpssHwPpSetRegField(devNum, lms0MiscCfgRegAddr, 0, 6, 3);
        if (rc != GT_OK)
        {
           return rc;
        }

        /* Selects Ports in debug mode - must be cleared at the end. */
        rc = prvCpssHwPpSetRegField(devNum, lms0MiscCfgRegAddr, 12, 1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }

     }
    /* debug bus info read port link state machine status */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->debugBusRegs.debugBus;
    /* for ports 12-23 need to read bits 29-31 */
    debugBusRegOffset = ((portNum > 23) || (portNum < 12)) ? 13 : 29;
    rc = prvCpssHwPpGetRegField(devNum, regAddr, debugBusRegOffset, 3, &status);
    if (rc != GT_OK)
    {
        /* Must clean bit 12 in LMS0 at the end */
        if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) == GT_FALSE)
        {
            (GT_VOID)prvCpssHwPpSetRegField(devNum, lms0MiscCfgRegAddr,
                                                12, 1, 0);
        }

        return rc;
    }

    FLEX_LINK_UP_WA_DBG_PRINT_MAC(("try=0,status=%d\n", status));

    /* if no problem exit */
    if(2 != status)
    {
        if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) == GT_FALSE)
        {
            /* Must clean bit 12 in LMS0 at the end */
            rc = prvCpssHwPpSetRegField(devNum, lms0MiscCfgRegAddr,
                                            12, 1, 0);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        return GT_OK;
    }

    rc = prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock(devNum,
                                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                    portNum, GT_TRUE/* lock */,
                                    &savedState);
    if (rc != GT_OK)
    {
        goto restoreAndExit;
    }

    timeout = 0;
    while(2 == status)
    {
        if(++timeout > 100)
        {
            rc = GT_TIMEOUT;
            goto restoreAndExit;
        }

        rc = cpssDxChPortForceLinkDownEnableSet(devNum,portNum,GT_TRUE);
        if (rc != GT_OK)
        {
            goto restoreAndExit;
        }

        /* wait at least 10 usec */
        cpssOsTimerWkAfter(1);

        rc = cpssDxChPortForceLinkDownEnableSet(devNum,portNum,GT_FALSE);
        if (rc != GT_OK)
        {
            goto restoreAndExit;
        }

        rc = prvCpssHwPpGetRegField(devNum, regAddr, debugBusRegOffset, 3, &status);
        if (rc != GT_OK)
        {
            goto restoreAndExit;
        }

        FLEX_LINK_UP_WA_DBG_PRINT_MAC(("try=%d,status=%d\n",
                                        timeout, status));
    }

    if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) == GT_FALSE)
    {
        /* Must clean bit 12 in LMS0 at the end */
        rc = prvCpssHwPpSetRegField(devNum, lms0MiscCfgRegAddr,
                                        12, 1, 0);
        if (rc != GT_OK)
        {
            (GT_VOID)prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock(devNum,
                                            CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                            portNum, GT_FALSE/* unlock */,
                                            &savedState);
            return rc;
        }
    }

    return prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock(devNum,
                                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                    portNum, GT_FALSE/* unlock */,
                                    &savedState);

restoreAndExit:

    /* Must clean bit 12 in LMS0 at the end */
    if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) == GT_FALSE)
    {
        (GT_VOID)prvCpssHwPpSetRegField(devNum, lms0MiscCfgRegAddr,
                                            12, 1, 0);
    }

    (GT_VOID)prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock(devNum,
                                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                    portNum, GT_FALSE/* unlock */,
                                    &savedState);
    return rc;
}

/**
* @internal prvCpssDxChHwPpSgmii_2_5G_LinkUpWa function
* @endinternal
*
* @brief   WA for Flex link TX hangs upon link establish
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*
* @retval GT_OK                    - success
* @retval GT_TIMEOUT               - state machine fix failed after numerous tries
*/
static GT_STATUS prvCpssDxChHwPpSgmii_2_5G_LinkUpWa
(
    IN GT_U8 devNum,
    IN GT_PHYSICAL_PORT_NUM portNum
)
{
    GT_STATUS rc;   /* return code */
    GT_BOOL linkState;  /* current link state of port */
    GT_U32  fieldData; /* data to write to register */
    GT_U32  fieldOffset; /* offset in register */
    GT_U32  regAddr;    /* address of register */

    PRV_CPSS_DXCH_PHY_PORT_CHECK_MAC(devNum,portNum);

    if(PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,portNum) != PRV_CPSS_PORT_GE_E)
        return GT_OK;

    if(!PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {   /* check dp_clk on network ports */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.extendedGlobalControl;
        fieldOffset = (GT_TRUE == PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum)) ? 22 : 21;
        if((rc = prvCpssHwPpGetRegField(devNum, regAddr, fieldOffset, 1, &fieldData)) != GT_OK)
            return rc;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.metalFix;
        fieldOffset = (GT_TRUE == PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum)) ?
                        (22 + (portNum-24)) : (26 + (portNum/4));
        rc = prvCpssHwPpGetRegField(devNum, regAddr, fieldOffset, 1, &fieldData);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(fieldData != 1)
        return GT_OK;

    rc = cpssDxChPortLinkStatusGet(devNum, portNum, &linkState);
    if (GT_OK != rc)
        return rc;

    if(linkState != GT_TRUE)
        return GT_OK;

    rc = prvCpssDxChHwPpXcatSgmii25FLUpBadStateCheckAndFix(devNum,portNum);
    if (GT_OK != rc)
        return rc;

    return GT_OK;
}


/**
* @internal prvCpssDxChBobcat2FcAutoNegotiationTriSpeedPortFix function
* @endinternal
*
* @brief   Perform fix of flow control auto negotiation for tri-speed ports.
*
* @param[in] devNum                   - device number
* @param[in] portMacNum               - MAC port number
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - hw error
*/
static GT_STATUS prvCpssDxChBobcat2FcAutoNegotiationTriSpeedPortFix
(
    IN   GT_U8      devNum,
    IN   GT_U32     portMacNum
)
{
    GT_STATUS               rc;         /* return code */
    GT_BOOL                 isLinkUp;   /* link status */
    GT_PHYSICAL_PORT_NUM    portNum;    /* physical port nuymber */
    CPSS_PORT_MAC_TYPE_ENT  portMacType;/* MAC type */
    GT_U32                  regAddr;    /* register address */
    GT_U32                  anRegAddr;  /* auto negotiation register address */
    GT_U32                  regValue;   /* register value */
    GT_U32                  regValue1;  /* register value */
    GT_U32                  timeoutCntr;/* count timeout of auto negotiation */


    rc = prvCpssDxChPortPhysicalPortMapReverseMappingGet(devNum, PRV_CPSS_DXCH_PORT_TYPE_MAC_E, portMacNum, &portNum);
    if(GT_OK != rc)
    {
        return rc;
    }

    /************************************************************
    *   The workaround is relevant for tri-speed ports that are *
    *   enabled to run the Auto-Negotiation process.            *
    *************************************************************/
    rc = cpssDxChPortMacTypeGet(devNum,portNum,&portMacType);
    if(GT_OK != rc)
    {
        return rc;
    }

    PRV_CPSS_DXCH_PORT_AUTO_NEG_CTRL_REG_MAC(devNum, portMacNum,&anRegAddr);
    if(PRV_CPSS_SW_PTR_ENTRY_UNUSED == anRegAddr)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);

    rc = prvCpssHwPpGetRegField(devNum, anRegAddr, 11, 1, &regValue);
    if(GT_OK != rc)
    {
        return rc;
    }
    if((regValue == 0) /* Auto Negotiation is disabled */ ||
       ((portMacType != CPSS_PORT_MAC_TYPE_FE_E) && (portMacType != CPSS_PORT_MAC_TYPE_GE_E)))
    {
        return GT_OK;
    }

    /* Get Link Status */
    rc = cpssDxChPortLinkStatusGet(devNum,portNum,&isLinkUp);
    if (GT_OK != rc)
    {
        return rc;
    }

    /*
        - Clear the <SetFcEnTx> field in the Port MAC Control Register4 register.
        - Bind the following sequence to the LinkStatusChange interrupt of the Port Interrupt Cause Register:
        When the port link is UP:
          1. Read the <AnDone> field in the Port Status Register0 register to verify that auto-negotiation completed
          2. Read the <TxFcEn> field in the Port Status Register0 register
          3. If TxFcEn is 1: Clear the <Bypass FCA> field in the FCA Control register and the <AnFcEn> field in
             the Port Auto-Negotiation Configuration register
          4. If TxFcEn is 0: Set the <Bypass FCA> field in the FCA Control register to 1.
        When the Port link is DOWN:
          Set the <AnFcEn> field in the Port Auto-Negotiation Configuration register to 1.
    */

    if (isLinkUp == GT_FALSE)
    {
        rc = prvCpssHwPpSetRegField(devNum, anRegAddr, 11, 1, 1);
        if(GT_OK != rc)
        {
            return rc;
        }
    }
    else
    {
        timeoutCntr = 0;
        PRV_CPSS_DXCH_PORT_STATUS_CTRL_REG_MAC(devNum,portMacNum,&regAddr);
        if(PRV_CPSS_SW_PTR_ENTRY_UNUSED == regAddr)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);

        do
        {
            /* should check with delays of 30msec => 300msec overall
                length of auto-neg. process according to protocol
                here 600 msec to be sure */
            HW_WAIT_MILLISECONDS_MAC(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, 60);
            /* read AnDone bit */
            if (prvCpssHwPpReadRegister(devNum, regAddr, &regValue) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            timeoutCntr++;
        } while((U32_GET_FIELD_MAC(regValue, 11, 1) != 1) && (timeoutCntr < 10));

        if(10 == timeoutCntr)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

        /* AN done */
        if(U32_GET_FIELD_MAC(regValue, 11, 1) == 1)
        {
            if(U32_GET_FIELD_MAC(regValue, 5, 1) == 1)
            {
                regValue1 = 0;

                rc = prvCpssHwPpSetRegField(devNum, anRegAddr, 11, 1, regValue1);
                if(GT_OK != rc)
                {
                    return rc;
                }
            }
            else
            {
                regValue1 = 1;
            }

            regAddr = PRV_DXCH_REG1_UNIT_GOP_FCA_MAC(devNum, portMacNum).FCACtrl;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, regValue1);
            if(GT_OK != rc)
            {
                return rc;
            }
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

    }

    return GT_OK;
}


/**
* @internal lion2ErrataIpmBridgeCopyGetDroppedWaInit function
* @endinternal
*
* @brief   WA for IPM Bridge Copy Dropped
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - success
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS lion2ErrataIpmBridgeCopyGetDroppedWaInit
(
    IN GT_U8 devNum
)
{
    GT_STATUS rc;   /* return code */

    CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC tailDropProfileParams;
    GT_U8     trafficClass;

    GT_BOOL   tailDropIsEnabled;

    /* Tail Drop must be enabled */

    /*  if tail drop was already configured to be enable then nothing to do.
        If tail drop was configured to be disabled then need to :
        1. enable tailDrop.
        2. per TC and DP - Keep Limit values in a shadow
        3. per TC and DP - Set Limits to be MAX_LIMITS use
    */

    rc = cpssDxChPortTxTailDropUcEnableGet(devNum,&tailDropIsEnabled);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(tailDropIsEnabled==GT_FALSE)
    {
        /* when calling cpssDxChPortTxTailDropUcEnableSet form WA init
           we do not need to set limits inside cpssDxChPortTxTailDropUcEnableSet */
        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                        tailDropUcEnable = GT_TRUE;

        /* enable tailDrop */
        rc = cpssDxChPortTxTailDropUcEnableSet(devNum,GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }

        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                        tailDropUcEnable = tailDropIsEnabled;

        /* per TC and DP - Keep Limit values in a shadow and Set Limits to be MAX_LIMITS  */
        rc = prvCpssDxChPortIpmBridgeCopyGetDroppedWaTailDropMaxLimitsSet(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
        /* When the application call explicitly cpssDxChPortTxTailDropUcEnableSet(devNum, GT_TRUE),
           then  need to return all the limits kept in the shadow.*/
    }
    else
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                        tailDropUcEnable = tailDropIsEnabled;
    }

    /* Configure Port 14 to TailDropProfile 8 */
    rc = prvCpssDxChPortTxBindPortToDpSet(devNum,14,CPSS_PORT_TX_DROP_PROFILE_8_E);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Configure Port 64+14 to TailDropProfile 8 */
    if (PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_MAC(devNum) >= 2)
    {
        rc = prvCpssDxChPortTxBindPortToDpSet(devNum,78,CPSS_PORT_TX_DROP_PROFILE_8_E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    /* Set Queue limits of profile8 (last 8 lines of each table) to all_zeros */
    cpssOsMemSet(&tailDropProfileParams,0,sizeof(CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS_STC));
    for(trafficClass=0; trafficClass<CPSS_TC_RANGE_CNS;trafficClass++)
    {
        rc = cpssDxChPortTx4TcTailDropProfileSet(devNum,
                                             CPSS_PORT_TX_DROP_PROFILE_8_E,
                                             trafficClass,
                                             &tailDropProfileParams);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled = GT_TRUE;


    return GT_OK;
}

/**
* @internal prvCpssDxChHwPpInitWaCutThroughSlowToFast function
* @endinternal
*
* @brief   This function implements the Cut Through Slow to Fast Port WA.
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - The device number.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum or numOfWa = 0 or bad WA value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - on timed out retries
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Only Lion2 version B1 and above.
*
*/
static GT_STATUS prvCpssDxChHwPpInitWaCutThroughSlowToFast
(
    IN GT_U8                        devNum
)
{
    GT_STATUS           rc;              /* return code */
    GT_U32              portNum;         /* Port number */
    GT_U32              maxPortNum;      /* Maximal Port number */
    GT_U32              localPort;       /* Local Port  */
    GT_BOOL             readyToWrite;    /* ready To Write */
    GT_U32              portGroupId;     /* Port Group Id */
    CPSS_PORT_SPEED_ENT portSpeed;       /* port speed */
    GT_U32              savePortGroupId; /* Save Port Group Id */
    GT_U32              writePortGroupId;/* Write Port Group Id */
    GT_U32              hwRxData;        /* HW RX data */
    GT_U32              hwTxData;        /* HW TX data */
    GT_U32              hwRxMask;        /* HW RX mask */
    GT_U32              hwTxMask;        /* HW TX mask */
    GT_U32              hwSpeed;         /* HW port speed value */
    GT_U32              rxRegAddr;       /* RX register address */
    GT_U32              txRegAddr;       /* TX register address */
    GT_U32              rxRegOff;        /* bit offset in RX register */
    GT_U32              txRegOff;        /* bit offset in TX register */
    GT_U32              saveHwRxData;    /* save HW RX data */
    GT_U32              saveHwTxData;    /* save HW TX data */
    GT_U32              saveHwRxMask;    /* save HW RX mask */
    GT_U32              saveHwTxMask;    /* save HW TX mask */

    if (GT_FALSE == PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum, PRV_CPSS_DXCH_LION2_CUT_THROUGH_SLOW_TO_FAST_WA_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_LION2_CUT_THROUGH_SLOW_TO_FAST_WA_E.
            enabled = GT_TRUE;

    /* to prevent compiler warning */
    txRegAddr     = 0;
    rxRegAddr     = 0;
    hwRxData      = 0;
    hwTxData      = 0;
    hwRxMask      = 0;
    hwTxMask      = 0;
    portGroupId   = 0;
    saveHwRxData  = 0;
    saveHwTxData  = 0;
    saveHwRxMask  = 0;
    saveHwTxMask  = 0;

    /* stamp for first loop */
    savePortGroupId  = 0xFFFFFFFF;
    writePortGroupId = 0xFFFFFFFF;
    maxPortNum       = PRV_CPSS_PP_MAC(devNum)->numOfPorts;
    readyToWrite     = GT_FALSE;

    /* this loop has additional cycle to write accumulated results */
    /* of the last port group                                      */
    for (portNum = 0; (portNum <= maxPortNum); portNum++)
    {
        if (portNum == maxPortNum)
        {
            readyToWrite     = GT_TRUE;
            writePortGroupId = portGroupId;
            saveHwRxData     = hwRxData;
            saveHwTxData     = hwTxData;
            saveHwRxMask     = hwRxMask;
            saveHwTxMask     = hwTxMask;
        }

        if (readyToWrite != GT_FALSE)
        {
            /* write results accumulated by previous loops for previous port group */
            rc = prvCpssDrvHwPpPortGroupWriteRegBitMask(
                devNum, writePortGroupId, rxRegAddr, saveHwRxMask, saveHwRxData);
            if(rc != GT_OK)
            {
                return rc;
            }

            rc = prvCpssDrvHwPpPortGroupWriteRegBitMask(
                devNum, writePortGroupId, txRegAddr, saveHwTxMask, saveHwTxData);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        readyToWrite = GT_FALSE;

        if (portNum == maxPortNum)
        {
            break;
        }

        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);

    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

        rc = cpssDxChPortSpeedGet(devNum, portNum, &portSpeed);
        if(rc != GT_OK)
        {
            return rc;
        }

        if (portSpeed == CPSS_PORT_SPEED_NA_E)
        {
            /* if port speed yet not configured */
            /* use some valid value             */
            portSpeed = CPSS_PORT_SPEED_1000_E;
        }

        rc = prvCpssDxChPortSpeedForCutThroughWaCalc(
            devNum, localPort, portSpeed,
            &hwSpeed, &rxRegAddr, &txRegAddr, &rxRegOff, &txRegOff);
        if(rc != GT_OK)
        {
            return rc;
        }


        if ((savePortGroupId != portGroupId) && (savePortGroupId != 0xFFFFFFFF))
        {
            readyToWrite     = GT_TRUE;
            writePortGroupId = savePortGroupId;
            saveHwRxData     = hwRxData;
            saveHwTxData     = hwTxData;
            saveHwRxMask     = hwRxMask;
            saveHwTxMask     = hwTxMask;
        }

        if (savePortGroupId != portGroupId)
        {
            /* RX DMA */
            hwRxData = 2; /* enable bit */
            /* TX DMA */
            hwTxData = (1 << 24); /* enable bit */

            hwRxMask = hwRxData;
            hwTxMask = hwTxData;
        }

        savePortGroupId = portGroupId;

        hwRxData |= (hwSpeed << rxRegOff);
        hwTxData |= (hwSpeed << txRegOff);
        hwRxMask |= (3 << rxRegOff);
        hwTxMask |= (3 << txRegOff);
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChHwPpImplementWaInit function
* @endinternal
*
* @brief   This function allow application to state which WA (workarounds) the CPSS
*         should implement.
*         NOTEs:
*         1. The function may be called several times with different needed WA.
*         2. The CPSS will implement the WA for the requested WA , even when the HW
*         not require the 'WA' anymore.
*         for example:
*         assume the xcat A1 has erratum regarding "wrong trunk id
*         source port information of packet to CPU" , and in the WA the CPSS
*         will limit application to specific trunk-IDs.
*         but if no longer have this problem , but the application
*         still request for the WA , the CPSS will continue to handle the
*         WA.
*         further more - application may ask the WA for ch3...
*         3. The function can be invoked only after cpssDxChHwPpPhase1Init().
*
* @note   APPLICABLE DEVICES:      xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; AC5; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None
*
* @param[in] devNum                   - The device number.
* @param[in] numOfWa                  - number of WA needed (number of elements in
* @param[in] waArr[]                  and additionalInfoBmpArr[] arrays).
* @param[in] waArr[]                  - (array of) WA needed to implement
* @param[in] additionalInfoBmpArr[]   - (array of) bitmap for additional WA info.
*                                      The meaning of the additional info is located
*                                      in the description of the specific WA. May be NULL.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum or numOfWa = 0 or bad WA value
* @retval GT_BAD_STATE             - the WA can't be called at this stage ,
*                                       because it's relate library already initialized.
*                                       meaning it is 'too late' to request for the WA.
* @retval GT_NOT_IMPLEMENTED       - the WA can't be implemented for the current device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - on timed out retries
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChHwPpImplementWaInit
(
    IN GT_U8                        devNum,
    IN GT_U32                       numOfWa,
    IN CPSS_DXCH_IMPLEMENT_WA_ENT   waArr[],
    IN GT_U32                       additionalInfoBmpArr[]
)
{
    GT_STATUS rc;       /* return code */
    GT_U32    waIndex;/* WA index */
    GT_U32    waInfoBmp;/*bmp info. indicate if additionalInfoBmpArr is NULL*/
    GT_U32    regAddr; /* register's address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(waArr);

    if(numOfWa == 0)
    {
        /* no need to call the API , if nothing to do ...*/
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }


    /* loop on the WA needed from CPSS and set internal flags according to them */
    for(waIndex = 0 ; waIndex < numOfWa; waIndex++)
    {
        waInfoBmp = (additionalInfoBmpArr) ? additionalInfoBmpArr[waIndex] : 0;
        switch(waArr[waIndex])
        {
            case CPSS_DXCH_IMPLEMENT_WA_SDMA_PKTS_FROM_CPU_STACK_E:

                if(PRV_CPSS_DXCH_PP_MAC(devNum)->netIf.initDone == GT_TRUE)
                {
                    /* indication that cpssDxChNetIfInit(...) was already called */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_SDMA_PACKETS_FROM_CPU_CORRUPT_WA_E.
                        enabled = GT_TRUE;
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_SDMA_PACKETS_FROM_CPU_CORRUPT_WA_E.
                        devNum = (GT_U8)waInfoBmp;
                break;

            case CPSS_DXCH_IMPLEMENT_WA_FDB_AU_FIFO_E:

                 if(PRV_CPSS_PP_MAC(devNum)->
                    intCtrl.auDescCtrl[PRV_CPSS_FIRST_ACTIVE_PORT_GROUP_ID_MAC(devNum)].blockAddr != 0)
                {
                    /* indication cpssDxChCfgPpLogicalInit(...)
                       that inits AU queues was already called */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_FDB_AU_FIFO_CORRUPT_WA_E.
                        enabled = GT_TRUE;

                break;

            case CPSS_DXCH_IMPLEMENT_WA_SDMA_PKTS_FROM_CPU_STACK_PADDING_E:

                /* Enable packet from CPU padding WA */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                                             PRV_CPSS_DXCH_XCAT_TX_CPU_CORRUPT_BUFFER_WA_E);

                break;

            case CPSS_DXCH_IMPLEMENT_WA_FDB_AU_FU_FROM_NON_SOURCE_PORT_GROUP_E:
                if(PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_LION2_E)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, "relevant to Lion2 only");
                }

                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION_FDB_AU_FU_MESSAGES_FROM_NON_SOURCE_PORT_GROUP_WA_E.
                        enabled = GT_TRUE;

                break;

            case CPSS_DXCH_IMPLEMENT_WA_RESTRICTED_ADDRESS_FILTERING_E:

                if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E
                    || PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC3X_E)
                {
                    /* Bind callback to driver errata db */
                    rc = prvCpssDrvAddrCheckWaBind(devNum, &hwPpAddressCheckAldrin);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
                else if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E
                    || PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
                {
                    /* Bind callback to driver errata db */
                    rc = prvCpssDrvAddrCheckWaBind(devNum, &hwPpAddressCheckAldrin2);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
                /* Check if the device is xCat3 */
                else if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
                {
                    /* Initialize WA DB for xCat3*/
                    xCat3ErrataAddrCheckWaDbInit(devNum);

                    /* Bind callback to driver errata db */
                    rc = prvCpssDrvAddrCheckWaBind(devNum, &hwPpAddressCheck);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }

                break;

            case CPSS_DXCH_IMPLEMENT_WA_RGMII_EDGE_ALIGN_MODE_E:
                /* Check if the device is XCAT */
                if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum) &&
                    (! PRV_CPSS_DXCH_LION_FAMILY_CHECK_MAC(devNum)))
                {
                    /* Set the FTDLL register to 0x0 */
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.ftdllReg;
                    rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_GE_PORT_UNIDIRECT_E:

                if(!PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
                {
                    /* the erratum exists only in XCAT3 devices*/
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.enabled = GT_TRUE;

                /* ports PCS loopback state shadow */
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.pcsLoopbackBmpPtr =
                            (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC));
                if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.
                                pcsLoopbackBmpPtr == NULL)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
                }

                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.portEnableBmpPtr =
                            (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC));
                if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.
                                portEnableBmpPtr == NULL)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
                }
                /* assume initial state of PCS loopback - disabled */
                PRV_CPSS_PORTS_BMP_PORT_CLEAR_ALL_MAC(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                     info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.pcsLoopbackBmpPtr);
                /* assume initial state of port - enabled */
                PRV_CPSS_PORTS_BMP_PORT_SET_ALL_MAC(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                     info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.portEnableBmpPtr);

                break;

            case CPSS_DXCH_IMPLEMENT_WA_2_5G_SGMII_LINK_UP_E:

                if ((PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_XCAT_E) &&
                    (PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_XCAT2_E))
                {
                    /* the erratum exists only in XCAT/xcat2 devices*/
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }

                rc = prvCpssDxChHwPpSgmii_2_5G_LinkUpWa(devNum,
                                                        (GT_PHYSICAL_PORT_NUM)waInfoBmp);
                if (GT_OK != rc)
                {
                    return rc;
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_TRI_SPEED_PORT_AN_FC_E:

                if(!PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
                {
                    rc = prvCpssDxChBobcat2FcAutoNegotiationTriSpeedPortFix(devNum,(GT_U32)waInfoBmp);
                    if(GT_OK != rc)
                    {
                        return rc;
                    }
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }

                break;

            case CPSS_DXCH_IMPLEMENT_WA_SERDES_INTERNAL_REG_ACCESS_E:
                PRV_CPSS_DRV_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DRV_ERRATA_SERDES_INTERNAL_REGS_ACCESS_WA_E);
                break;

            case CPSS_DXCH_IMPLEMENT_WA_IPM_BRIDGE_COPY_GET_DROPPED_E:

                if(GT_FALSE == PRV_CPSS_DXCH_LION2_FAMILY_CHECK_MAC(devNum))
                {
                    /* the WA applicable only in LION2 devices*/
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }

                /* Initialize WA  */
                rc = lion2ErrataIpmBridgeCopyGetDroppedWaInit(devNum);
                if(rc != GT_OK)
                {
                    return rc;
                }

                break;

            case CPSS_DXCH_IMPLEMENT_WA_NO_ALLIGNMENT_LOCK_E:
            case CPSS_DXCH_IMPLEMENT_WA_DISMATCH_IF_LINK_E:
                rc = prvCpssDxChPortLion2LinkFixWa(devNum,
                                                 (GT_PHYSICAL_PORT_NUM)waInfoBmp);
                if(rc != GT_OK)
                {
                    return rc;
                }

                break;

            case CPSS_DXCH_IMPLEMENT_WA_MC_BANDWIDTH_RESTRICTION_E:
                if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(
                    devNum, PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E))
                {
                    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                        info_PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E.
                            enabled = GT_TRUE;
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_CUT_THROUGH_SLOW_TO_FAST_E:

                rc = prvCpssDxChHwPpInitWaCutThroughSlowToFast(devNum);
                if ((rc != GT_OK) && (rc != GT_NOT_APPLICABLE_DEVICE))
                {
                    return rc;
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_RXAUI_LINK_E:
                rc = prvCpssDxChPortLion2RxauiLinkFixWa(devNum,
                                               (GT_PHYSICAL_PORT_NUM)waInfoBmp);
                if(rc != GT_OK)
                {
                    return rc;
                }
                break;
            case CPSS_DXCH_IMPLEMENT_WA_BOBCAT2_REV_A0_40G_NOT_THROUGH_TM_IS_PA_30G_E:
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_BOBCAT2_REV_A0_40G_NOT_THROUGH_TM_IS_PA_30G_WA_E.enabled = GT_TRUE;
                break;
            case CPSS_DXCH_IMPLEMENT_WA_WRONG_MIB_COUNTERS_LINK_DOWN_E:
                if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
                {
                    if((PRV_CPSS_PORT_XLG_E == PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,waInfoBmp)) ||
                        (PRV_CPSS_PORT_XG_E == PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,waInfoBmp)))
                    {
                        GT_BOOL     linkUp;
                        GT_U32      i;
                        rc = cpssDxChPortLinkStatusGet(devNum, (GT_PHYSICAL_PORT_NUM)waInfoBmp, &linkUp);
                        if (rc != GT_OK)
                        {
                            return rc;
                        }
                        if(GT_FALSE == linkUp )
                        {
                            rc = prvCpssDxChPortMacCountersOnPortGet(devNum,(GT_PHYSICAL_PORT_NUM)waInfoBmp, GT_FALSE, NULL,
                                                                 PRV_DXCH_PORT_MAC_CNTR_READ_MODE_UPDATE_SHADOW_E);
                            if(rc != GT_OK)
                            {
                                return rc;
                            }
                            rc = prvCpssDxChPortMacCountersSpecialShadowReset(devNum,(GT_PHYSICAL_PORT_NUM)waInfoBmp);
                            if(rc != GT_OK)
                            {
                                return rc;
                            }
                            for(i = 0; i < 2; i++)
                            {
                                rc = prvCpssDxChPortMacCountersOnPortGet(devNum,(GT_PHYSICAL_PORT_NUM)waInfoBmp, GT_FALSE, NULL,
                                                                     PRV_DXCH_PORT_MAC_CNTR_READ_MODE_RESET_HW_E);
                                if(rc != GT_OK)
                                {
                                    return rc;
                                }
                            }
                        }
                    }
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_ROUTER_TCAM_RM_E:
                /* RM#30230 WA is applicable only for xCat A2 and above or xCat3 */
                if (((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E) && (PRV_CPSS_PP_MAC(devNum)->revision >= 3)) ||
                    PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
                {
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTcamControl;
                    rc = prvCpssHwPpSetRegField(devNum, regAddr, 31, 1, 1);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_XCAT_ROUTER_TCAM_RM_WA_E.enabled = GT_TRUE;
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_BOBCAT2_PTP_TIMESTAMP_E:
                rc = prvCpssDxChPortBc2PtpTimeStampFixWa(devNum);
                if(rc != GT_OK)
                {
                    return rc;
                }
                break;
            case CPSS_DXCH_IMPLEMENT_WA_100BASEX_AN_DISABLE_E:
                rc = prvCpssDxChPortAnDisableFixWa(devNum, (GT_PHYSICAL_PORT_NUM)waInfoBmp);
                if (rc != GT_OK)
                {
                    return rc;
                }
                break;
            case CPSS_DXCH_IMPLEMENT_WA_XCAT3_XLG_PORT_BUFFER_STUCK_UNIDIRECTIONAL_E:
                if (!PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }
                if (waInfoBmp >= CPSS_MAX_PORTS_NUM_CNS)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                CPSS_PORTS_BMP_PORT_SET_MAC(
                    &(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                      info_PRV_CPSS_DXCH_PORTS_XLG_UNIDIRECTIONAL_WA_E.waCapablePortsBmp),
                    (GT_PHYSICAL_PORT_NUM)waInfoBmp);
                break;
            case CPSS_DXCH_FALCON_DLB_TS_WRAP_WA_E:
                if(PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_FALCON_E)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }
                prvCpssDxChBrgL2DlbWaInit(devNum, (GT_U32)waInfoBmp);
                break;
            case CPSS_DXCH_IMPLEMENT_WA_CUT_THROUGH_NON_ETHERNET_WRONG_BYTE_COUNT_E:
                if(PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_FALCON_E)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }
                regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).ttiCutThroughConfiguration;
                rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 3, 0);
                if (rc != GT_OK)
                {
                    return rc;
                }
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_IMPLEMENT_WA_CUT_THROUGH_NON_ETHERNET_WRONG_BYTE_COUNT_E.enabled = GT_TRUE;
                break;
            default:
                /* unknown WA */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChHwPpImplementWaInit function
* @endinternal
*
* @brief   This function allow application to state which WA (workarounds) the CPSS
*         should implement.
*         NOTEs:
*         1. The function may be called several times with different needed WA.
*         2. The CPSS will implement the WA for the requested WA , even when the HW
*         not require the 'WA' anymore.
*         for example:
*         assume the xcat A1 has erratum regarding "wrong trunk id
*         source port information of packet to CPU" , and in the WA the CPSS
*         will limit application to specific trunk-IDs.
*         but if no longer have this problem , but the application
*         still request for the WA , the CPSS will continue to handle the
*         WA.
*         further more - application may ask the WA for ch3...
*         3. The function can be invoked only after cpssDxChHwPpPhase1Init().
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The device number.
* @param[in] numOfWa                  - number of WA needed (number of elements in
* @param[in] waArr[]                  and additionalInfoBmpArr[] arrays).
* @param[in] waArr[]                  - (array of) WA needed to implement
* @param[in] additionalInfoBmpArr[]   - (array of) bitmap for additional WA info.
*                                      The meaning of the additional info is located
*                                      in the description of the specific WA. May be NULL.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum or numOfWa = 0 or bad WA value
* @retval GT_BAD_STATE             - the WA can't be called at this stage ,
*                                       because it's relate library already initialized.
*                                       meaning it is 'too late' to request for the WA.
* @retval GT_NOT_IMPLEMENTED       - the WA can't be implemented for the current device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - on timed out retries
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwPpImplementWaInit
(
    IN GT_U8                        devNum,
    IN GT_U32                       numOfWa,
    IN CPSS_DXCH_IMPLEMENT_WA_ENT   waArr[],
    IN GT_U32                       additionalInfoBmpArr[]
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpImplementWaInit);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, numOfWa, waArr, additionalInfoBmpArr));

    rc = internal_cpssDxChHwPpImplementWaInit(devNum, numOfWa, waArr, additionalInfoBmpArr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, numOfWa, waArr, additionalInfoBmpArr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPpHwImplementWaGet function
* @endinternal
*
* @brief   Gets information on whether a specific workaround was implemented
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The device number.
* @param[in] wa                       - the workaround
*
* @param[out] isImplemented            - GT_TRUE: the workaround is implemented on the device
*                                      GT_FALSE: the workaround is not implemented on the device
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum or bad WA value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_IMPLEMENTED       - no information on whether the erratum was
*                                       implemented or not
*/
static GT_STATUS internal_cpssDxChPpHwImplementWaGet
(
    IN  GT_U8                       devNum,
    IN  CPSS_DXCH_IMPLEMENT_WA_ENT  wa,
    OUT GT_BOOL                     *isImplemented
)
{
    GT_U32 regAddr, value;
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    switch (wa)
    {
        case CPSS_DXCH_IMPLEMENT_WA_SDMA_PKTS_FROM_CPU_STACK_E:
            *isImplemented =
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_XCAT_SDMA_PACKETS_FROM_CPU_CORRUPT_WA_E.enabled;
            break;

        case CPSS_DXCH_IMPLEMENT_WA_FDB_AU_FIFO_E:
            *isImplemented =
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_XCAT_FDB_AU_FIFO_CORRUPT_WA_E.enabled;
            break;

        case CPSS_DXCH_IMPLEMENT_WA_FDB_AU_FU_FROM_NON_SOURCE_PORT_GROUP_E:
            *isImplemented =
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION_FDB_AU_FU_MESSAGES_FROM_NON_SOURCE_PORT_GROUP_WA_E.enabled;
            break;

        case CPSS_DXCH_IMPLEMENT_WA_SDMA_PKTS_FROM_CPU_STACK_PADDING_E:
            *isImplemented =
                PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                             PRV_CPSS_DXCH_XCAT_TX_CPU_CORRUPT_BUFFER_WA_E);
            break;

        case CPSS_DXCH_IMPLEMENT_WA_RESTRICTED_ADDRESS_FILTERING_E:
            *isImplemented =
                ((PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->errata.addrCheckFuncPtr == NULL) ? 0 : 1);
            break;

        case CPSS_DXCH_IMPLEMENT_WA_RGMII_EDGE_ALIGN_MODE_E:
            if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum) &&
                (! PRV_CPSS_DXCH_LION_FAMILY_CHECK_MAC(devNum)))
            {
                /* Get value from FTDLL register */
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.ftdllReg;
                rc = prvCpssHwPpReadRegister(devNum, regAddr, &value);
                if (rc != GT_OK)
                {
                    return rc;
                }
                *isImplemented = ((value == 0) ? 1 : 0);
            }
            else
            {
                *isImplemented = 0;
            }
            break;

        case CPSS_DXCH_IMPLEMENT_WA_GE_PORT_UNIDIRECT_E:
            *isImplemented =
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.enabled;
            break;

        case CPSS_DXCH_IMPLEMENT_WA_2_5G_SGMII_LINK_UP_E:
        case CPSS_DXCH_IMPLEMENT_WA_SGMII_2_5G_UNDER_TRAFFIC_CFG_E:
        case CPSS_DXCH_IMPLEMENT_WA_SGMII_2_5G_UNDER_TRAFFIC_NETWORKP_CFG_E:
        case CPSS_DXCH_IMPLEMENT_WA_SGMII_2_5G_UNDER_TRAFFIC_STACKP_CFG_E:
        case CPSS_DXCH_IMPLEMENT_WA_WRONG_MIB_COUNTERS_LINK_DOWN_E:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

        case CPSS_DXCH_IMPLEMENT_WA_SERDES_INTERNAL_REG_ACCESS_E:
            *isImplemented =
                PRV_CPSS_DRV_ERRATA_GET_MAC(devNum,
                                            PRV_CPSS_DRV_ERRATA_SERDES_INTERNAL_REGS_ACCESS_WA_E);
            break;

        case CPSS_DXCH_IMPLEMENT_WA_IPM_BRIDGE_COPY_GET_DROPPED_E:
            *isImplemented =
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled;
            break;

        case CPSS_DXCH_IMPLEMENT_WA_MC_BANDWIDTH_RESTRICTION_E:
            *isImplemented =
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E.enabled;
            break;

        case CPSS_DXCH_IMPLEMENT_WA_CUT_THROUGH_SLOW_TO_FAST_E:
            *isImplemented =
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_LION2_CUT_THROUGH_SLOW_TO_FAST_WA_E.enabled;
            break;

        case CPSS_DXCH_IMPLEMENT_WA_ROUTER_TCAM_RM_E:
            *isImplemented =
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_XCAT_ROUTER_TCAM_RM_WA_E.enabled;
            break;

        case CPSS_DXCH_IMPLEMENT_WA_BOBCAT2_PTP_TIMESTAMP_E:
            *isImplemented =
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_CPSS_DXCH_IMPLEMENT_WA_BOBCAT2_PTP_TIMESTAMP_E.enabled;
            break;

        case CPSS_DXCH_FALCON_DLB_TS_WRAP_WA_E:
            *isImplemented =
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_BRG_L2_DLB_TIMER_COUNTER_WA_E.dlbWaEnable;
            break;
        case CPSS_DXCH_IMPLEMENT_WA_CUT_THROUGH_NON_ETHERNET_WRONG_BYTE_COUNT_E:
            *isImplemented =
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                info_PRV_CPSS_DXCH_IMPLEMENT_WA_CUT_THROUGH_NON_ETHERNET_WRONG_BYTE_COUNT_E.enabled;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    return GT_OK;
}

/**
* @internal cpssDxChPpHwImplementWaGet function
* @endinternal
*
* @brief   Gets information on whether a specific workaround was implemented
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The device number.
* @param[in] wa                       - the workaround
*
* @param[out] isImplemented            - GT_TRUE: the workaround is implemented on the device
*                                      GT_FALSE: the workaround is not implemented on the device
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong devNum or bad WA value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_IMPLEMENTED       - no information on whether the erratum was
*                                       implemented or not
*/
GT_STATUS cpssDxChPpHwImplementWaGet
(
    IN  GT_U8                       devNum,
    IN  CPSS_DXCH_IMPLEMENT_WA_ENT  wa,
    OUT GT_BOOL                     *isImplemented
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPpHwImplementWaGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, wa, isImplemented));

    rc = internal_cpssDxChPpHwImplementWaGet(devNum, wa, isImplemented);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, wa, isImplemented));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChHwAuDescSizeGet function
* @endinternal
*
* @brief   This function returns the size in bytes of a single Address Update
*         descriptor, for a given device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devType                  - The PP's device type to return the descriptor's size for.
*
* @param[out] descSizePtr              The descrptor's size (in bytes).
*
* @retval GT_OK                    - on success,
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwAuDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    /* the devType is not used yet */
    (void)devType;

    CPSS_NULL_PTR_CHECK_MAC(descSizePtr);

    switch(devType)
    {
        case CPSS_BOBCAT2_ALL_DEVICES_CASES_MAC:
        case CPSS_BOBK_ALL_DEVICES_CASES_MAC:
        case CPSS_BOBCAT3_ALL_DEVICES_CASES_MAC:
        case CPSS_ARMSTRONG_ALL_DEVICES_CASES_MAC:
        case CPSS_ALDRIN2_ALL_DEVICES_CASES_MAC:
        case CPSS_ALDRIN_DEVICES_CASES_MAC:
        case CPSS_FALCON_ALL_DEVICES_CASES_MAC:
        case CPSS_AC5P_ALL_DEVICES_CASES_MAC:
        case CPSS_PHOENIX_ALL_DEVICES_CASES_MAC:
        case CPSS_HARRIER_ALL_DEVICES_CASES_MAC:
        case CPSS_IRONMAN_ALL_DEVICES_CASES_MAC:
            *descSizePtr = 32;
            break;
        default:
            *descSizePtr = AU_DESC_SIZE;/*16*/
            break;
    }

    return GT_OK;
}

/**
* @internal cpssDxChHwAuDescSizeGet function
* @endinternal
*
* @brief   This function returns the size in bytes of a single Address Update
*         descriptor, for a given device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devType                  - The PP's device type to return the descriptor's size for.
*
* @param[out] descSizePtr              The descrptor's size (in bytes).
*
* @retval GT_OK                    - on success,
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwAuDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwAuDescSizeGet);

    CPSS_API_LOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devType, descSizePtr));

    rc = internal_cpssDxChHwAuDescSizeGet(devType, descSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devType, descSizePtr));
    CPSS_API_UNLOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChHwRxDescSizeGet function
* @endinternal
*
* @brief   This function returns the size in bytes of a single Rx descriptor,
*         for a given device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devType                  - The PP's device type to return the descriptor's size for.
*
* @param[out] descSizePtr              The descrptor's size (in bytes).
*
* @retval GT_OK                    - on success,
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwRxDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    /* the devType is not used yet */
    (void)devType;

    CPSS_NULL_PTR_CHECK_MAC(descSizePtr);

    *descSizePtr = RX_DESC_SIZE;
    return GT_OK;
}

/**
* @internal cpssDxChHwRxDescSizeGet function
* @endinternal
*
* @brief   This function returns the size in bytes of a single Rx descriptor,
*         for a given device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devType                  - The PP's device type to return the descriptor's size for.
*
* @param[out] descSizePtr              The descrptor's size (in bytes).
*
* @retval GT_OK                    - on success,
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwRxDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwRxDescSizeGet);

    CPSS_API_LOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devType, descSizePtr));

    rc = internal_cpssDxChHwRxDescSizeGet(devType, descSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devType, descSizePtr));
    CPSS_API_UNLOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChHwTxDescSizeGet function
* @endinternal
*
* @brief   This function returns the size in bytes of a single Tx descriptor,
*         for a given device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devType                  - The PP's device type to return the descriptor's size for.
*
* @param[out] descSizePtr              The descrptor's size (in bytes).
*
* @retval GT_OK                    - on success,
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwTxDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    GT_U32    txShortBufSize;

    /* the devType is not used yet */
    (void)devType;

    CPSS_NULL_PTR_CHECK_MAC(descSizePtr);

    switch(devType)
    {
        case CPSS_BOBCAT2_ALL_DEVICES_CASES_MAC:
        case CPSS_BOBK_ALL_DEVICES_CASES_MAC:
        case CPSS_BOBCAT3_ALL_DEVICES_CASES_MAC:
        case CPSS_ARMSTRONG_ALL_DEVICES_CASES_MAC:
        case CPSS_ALDRIN2_ALL_DEVICES_CASES_MAC:
        case CPSS_ALDRIN_DEVICES_CASES_MAC:
        case CPSS_FALCON_ALL_DEVICES_CASES_MAC:
        case CPSS_AC5P_ALL_DEVICES_CASES_MAC:
        case CPSS_PHOENIX_ALL_DEVICES_CASES_MAC:
        case CPSS_HARRIER_ALL_DEVICES_CASES_MAC:
        case CPSS_IRONMAN_ALL_DEVICES_CASES_MAC:
            txShortBufSize = TX_SHORT_BUFF_SIZE_16_CNS;
            break;
        default:
            txShortBufSize = TX_SHORT_BUFF_SIZE;
            break;
    }

    *descSizePtr = TX_DESC_SIZE + txShortBufSize + (TX_HEADER_SIZE / 2);
    return GT_OK;
}

/**
* @internal cpssDxChHwTxDescSizeGet function
* @endinternal
*
* @brief   This function returns the size in bytes of a single Tx descriptor,
*         for a given device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devType                  - The PP's device type to return the descriptor's size for.
*
* @param[out] descSizePtr              The descrptor's size (in bytes).
*
* @retval GT_OK                    - on success,
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwTxDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwTxDescSizeGet);

    CPSS_API_LOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devType, descSizePtr));

    rc = internal_cpssDxChHwTxDescSizeGet(devType, descSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devType, descSizePtr));
    CPSS_API_UNLOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}



/**
* @internal internal_cpssDxChHwRxBufAlignmentGet function
* @endinternal
*
* @brief   This function returns the required alignment in bytes of a RX buffer,
*         for a given device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devType                  - The PP's device type to return the descriptor's size for.
*
* @param[out] byteAlignmentPtr         - The buffer alignment (in bytes).
*
* @retval GT_OK                    - on success,
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwRxBufAlignmentGet
(
    IN  CPSS_PP_DEVICE_TYPE devType,
    OUT GT_U32              *byteAlignmentPtr
)
{
    /* the devType is not used yet */
    (void)devType;

    CPSS_NULL_PTR_CHECK_MAC(byteAlignmentPtr);

    *byteAlignmentPtr = 128;
    return GT_OK;
}

/**
* @internal cpssDxChHwRxBufAlignmentGet function
* @endinternal
*
* @brief   This function returns the required alignment in bytes of a RX buffer,
*         for a given device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devType                  - The PP's device type to return the descriptor's size for.
*
* @param[out] byteAlignmentPtr         - The buffer alignment (in bytes).
*
* @retval GT_OK                    - on success,
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwRxBufAlignmentGet
(
    IN  CPSS_PP_DEVICE_TYPE devType,
    OUT GT_U32              *byteAlignmentPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwRxBufAlignmentGet);

    CPSS_API_LOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devType, byteAlignmentPtr));

    rc = internal_cpssDxChHwRxBufAlignmentGet(devType, byteAlignmentPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devType, byteAlignmentPtr));
    CPSS_API_UNLOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal preSoftResetRamAndDfxTreat function
* @endinternal
*
* @brief   This routine make special treatment for RAM reset and DFX registers.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5.
*
* @param[in] devNum                   - device number to reset.
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS preSoftResetRamAndDfxTreat
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     regsSkipInit,
    IN  GT_BOOL     tablesSkipInit
)
{
    GT_STATUS   rc;               /* return code         */
    GT_U32      addConfigRegAddr; /* address of register */

    if (regsSkipInit == GT_FALSE && PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) == 0)
    {
        if ((PRV_CPSS_DXCH_PP_MAC(devNum)->extMemory.externalMemoryInitFlags
             & PRV_CPSS_DXCH_TM_GLUE_DRAM_INIT_DONE_MASK_CNS) == 0)
        {
            /* skip reset of DFX registers to avoid stuck of internal CPU.
               DFX registers should be reset if TM was initialized. */
            if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                addConfigRegAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                                              DFXServerUnitsDeviceSpecificRegs.DFXSkipInitializationMatrix;
                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                                    devNum, addConfigRegAddr, 8, 1, 0);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }
            else
            {
                addConfigRegAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                                              DFXServerUnitsDeviceSpecificRegs.deviceCtrl18;
                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                    devNum, addConfigRegAddr, 26, 1, 1);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }

        }
    }

    /* WA for internal CPU and RAM init */
    if (tablesSkipInit == GT_FALSE && PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) == 0)
    {
        /* skip RAM init during soft reset to avoid CPU and MSYS RAMs corruption */
        addConfigRegAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsDeviceSpecificRegs.RAMInitSkipInitializationMatrix;

        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
            devNum, addConfigRegAddr, 8, 1, 0);
        if(GT_OK != rc)
        {
            return rc;
        }

        if ((PRV_CPSS_DXCH_PP_MAC(devNum)->extMemory.externalMemoryInitFlags
             & PRV_CPSS_DXCH_TM_GLUE_DRAM_INIT_DONE_MASK_CNS) == 0)
        {
            /* skip DDR init to avoid DRAM access failure for internal CPU.
               DDR should be reset if TM was initialized.*/
            addConfigRegAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsDeviceSpecificRegs.DDRSkipInitializationMatrix;
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                devNum, addConfigRegAddr, 8, 1, 0);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        /* reset all PP related RAMs */
        rc = prvCpssDxChDiagBistAllRamSet(devNum, 0, GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal softResetTriggerXcat3 function
* @endinternal
*
* @brief   This routine issue soft reset for a specific pp - xCat3.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number to reset.
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Soft reset is the process in which selected entities (as configured by
*       using the cpssDxChHwPpSoftResetSkipParamSet API) are reset to their
*       default values.
*
*/
static GT_STATUS softResetTriggerXcat3
(
    IN  GT_U8 devNum
)
{
    GT_STATUS rc;             /* return code */
    GT_U32    dfxDeviceResetControlRegAddr;   /* register address                */
    GT_U32    regAddr;                        /* register address                */
    GT_BOOL   tablesSkipInit;

    /* xCat3; Bobcat2; Caelum; Bobcat3 */
    if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_FALSE)
    {
        return GT_OK;
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        rc = cpssDxChHwPpSoftResetSkipParamGet(devNum, CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E, &tablesSkipInit);
        if(GT_OK != rc)
        {
            return rc;
        }

        /* WA: Skip Reset Table disable causes to CPU stuck because procedure
           resets MSYS and CPUs memories. Therefore RAM skip init should be enabled,
           and PP tables will be reseted by BIST */
        if(tablesSkipInit == GT_FALSE)
        {
            /* skip RAM init during soft reset to avoid CPU and MSYS RAMs corruption */
            regAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsDeviceSpecificRegs.RAMInitSkipInitializationMatrix;

            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                devNum, regAddr, 8, 1, 0);
            if(GT_OK != rc)
            {
                return rc;
            }

            /* reset all PP related RAMs */
            rc = prvCpssDxChDiagBistAllRamSet(devNum, 0, GT_TRUE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /***************************************************************************************************************/
    /* the following register should be configured before triggering SW reset in order to CPU will be not in reset */
    /***************************************************************************************************************/

    /* enable SKIP init for CPU */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsDeviceSpecificRegs.CPUSkipInitializationMatrix;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 8, 1, 0);
    if(GT_OK != rc)
    {
        return rc;
    }

    /* enable SKIP init for DFX */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsDeviceSpecificRegs.DFXSkipInitializationMatrix;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 8, 1, 0);
    if(GT_OK != rc)
    {
        return rc;
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        /* {cpu_core0_reset_sel} - set bit 21*/
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                              DFXServerUnitsDeviceSpecificRegs.deviceCtrl7;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 21, 1, 1);
        if(GT_OK != rc)
        {
            return rc;
        }

        /* {cpu_core1_reset_sel} - set bit 31*/
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                              DFXServerUnitsDeviceSpecificRegs.deviceCtrl9;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 31, 1, 1);
        if(GT_OK != rc)
        {
            return rc;
        }

        /* {cpu_core0_ext_reset_en + cpu_core1_ext_reset_en} - set bit 0 and 1*/
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                              DFXServerUnitsDeviceSpecificRegs.deviceCtrl0;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 0, 2, 3);
        if(GT_OK != rc)
        {
            return rc;
        }
    }
    else /* AC5 */
    {
        /* enable SKIP init for CNM */
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                              DFXServerUnitsDeviceSpecificRegs.cnmSkipInitializationMatrix;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 8, 1, 0);
        if(GT_OK != rc)
        {
            return rc;
        }

        /* Need to set skip CNM RAMs related pipe1  */
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                              DFXServerUnitsDeviceSpecificRegs.DFXPipeSkipInitializationMatrix;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 1, 1, 0);
        if(GT_OK != rc)
        {
            return rc;
        }

        /* Enable DFX Pipe skip for "MG" Reset source */
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                              DFXServerUnitsDeviceSpecificRegs.DFXPipeSkipInitializationMatrix;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 31, 1, 0);
        if(GT_OK != rc)
        {
            return rc;
        }

        /* Avoid toggle of device_enabled_and_init_done */
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                              DFXServerUnitsDeviceSpecificRegs.metalFixRegister;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 26, 1, 1);
        if(GT_OK != rc)
        {
            return rc;
        }

        /* Skip MPP reset to avoid CPU subsystem disruption */
        regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                           DFXServerUnitsDeviceSpecificRegs.mppSkipInitializationMatrix;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 8, 1, 0);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    dfxDeviceResetControlRegAddr =
        PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsDeviceSpecificRegs.deviceResetCtrl;

    /* state to the special DB that the device did HW reset */
    prvCpssPpConfigDevDbHwResetSet(devNum,GT_TRUE);

    /* set bits of : <MG Soft Reset Trigger> and <Table Start Init> */
    /* the <Table Start Init> = 0 is relevant only when <skip table> == false
        and means that 'tables' will be re-initialized */
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                  devNum, dfxDeviceResetControlRegAddr, 1, 2, 0);
    return rc;
}


/**
* @internal softResetTriggerSip5 function
* @endinternal
*
* @brief   This routine issue soft reset for a specific pp -
*         Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number to reset.
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Soft reset is the process in which selected entities (as configured by
*       using the cpssDxChHwPpSoftResetSkipParamSet API) are reset to their
*       default values.
*
*/
static GT_STATUS softResetTriggerSip5
(
    IN  GT_U8 devNum
)
{
    GT_STATUS rc;             /* return code */
    GT_U32    dfxDeviceResetControlRegAddr;   /* register address                */
    GT_U32    dfxDeviceControl15RegAddr;      /* register address                */
    GT_BOOL   regsSkipInit;
    GT_BOOL   tablesSkipInit;
    GT_BOOL   pexSkipInit;

    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    /* xCat3; Bobcat2; Caelum; Bobcat3 */
    if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_FALSE)
    {
        return GT_OK;
    }

    rc = cpssDxChHwPpSoftResetSkipParamGet(devNum, CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E, &regsSkipInit);
    if(GT_OK != rc)
    {
        return rc;
    }

    rc = cpssDxChHwPpSoftResetSkipParamGet(devNum, CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E, &tablesSkipInit);
    if(GT_OK != rc)
    {
        return rc;
    }

    rc = cpssDxChHwPpSoftResetSkipParamGet(devNum, CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E, &pexSkipInit);
    if(GT_OK != rc)
    {
        return rc;
    }

    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        /* perform special treatment for RAM reset and DFX registers */
        rc = preSoftResetRamAndDfxTreat(devNum,regsSkipInit,tablesSkipInit);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    dfxDeviceResetControlRegAddr =
        PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsDeviceSpecificRegs.deviceResetCtrl;

    /* state to the special DB that the device did HW reset */
    if (DXCH_HWINIT_GLOVAR(dxChHwInitSrc.isResetDbEnabled))
    {
        prvCpssPpConfigDevDbHwResetSet(devNum,GT_TRUE);
    }

    /*  NOTE about <Table Start Init> : if at some point in the future the CPSS
        will not force '0' , then be aware of implications of
        JIRA:  BOBCAT2-506 chip requires "manual" activation of table_start_init_ & tm_start_init_ after soft reset
    */


    /* set bits of : <MG Soft Reset Trigger> and <Table Start Init> */
    /* the <Table Start Init> = 0 is relevant only when <skip table> == false
        and means that 'tables' will be re-initialized */
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                  devNum, dfxDeviceResetControlRegAddr, 1, 2, 0);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) &&
       (GT_TRUE == PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.featureInfo.TmSupported) &&
       (GT_TRUE == regsSkipInit) &&
       (GT_TRUE == tablesSkipInit) &&
       (GT_TRUE == pexSkipInit))
    {
        /* this is fix to JIRA: CPSS-1851 : Soft reset with table skip Init */

        /* Soft reset is active for 2000 core clock cycles (6uS). Waiting 1 tick should be enough */
        cpssOsTimerWkAfter(1);

        dfxDeviceControl15RegAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsDeviceSpecificRegs.deviceCtrl15;

        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                  devNum, dfxDeviceControl15RegAddr, 0, 1, 1);
    }
    return rc;
}


/**
* @internal internal_cpssDxChHwPpSoftResetTrigger function
* @endinternal
*
* @brief   This routine issue soft reset for a specific pp.
* @brief   For Falcon resets Main Dies and Chiplets.
* @brief   Chiplets reset can be skipped enabling CPSS_HW_PP_RESET_SKIP_TYPE_CHIPLETS_E.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number to reset.
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Soft reset is the process in which selected entities (as configured by
*       using the cpssDxChHwPpSoftResetSkipParamSet API) are reset to their
*       default values.
*
*/
static GT_STATUS internal_cpssDxChHwPpSoftResetTrigger
(
    IN  GT_U8 devNum
)
{
    GT_STATUS rc;             /* return code */
    GT_U32    resetRegAddr;   /* register address                */
    GT_U32    resetBitOffset;      /* bit offset or value in register */
    GT_U32    resetTriggerVal;     /* trigger value                   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return prvCpssDxChHwInitSoftResetSip6CnmSystemResetTrigger(devNum);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        return softResetTriggerSip5(devNum);
    }

    if (PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        return softResetTriggerXcat3(devNum);
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
    {
        /* xCat2 */
        resetRegAddr =
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.resetControl;
        resetBitOffset  = 0;
        resetTriggerVal = 0;
    }
    else if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                               dfxUnits.server.resetControl;
        resetBitOffset  = 1;
        resetTriggerVal = 0;
    }
    else
    {
        /* all devices exclude xCat3; Lion2; Bobcat2; Caelum; Bobcat3 */
        resetRegAddr =
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl;
        resetBitOffset  = 16;
        resetTriggerVal = 1;
    }

    /* state to the special DB that the device did HW reset */
    prvCpssPpConfigDevDbHwResetSet(devNum,GT_TRUE);

    rc = prvCpssHwPpSetRegField(
                  devNum, resetRegAddr, resetBitOffset, 1, resetTriggerVal);

#ifdef ASIC_SIMULATION
    cpssOsTimerWkAfter(1000);
#endif /*ASIC_SIMULATION*/

    return rc;
}

/**
* @internal cpssDxChHwPpSoftResetTrigger function
* @endinternal
*
* @brief   This routine issue soft reset for a specific pp.
* @brief   For Falcon resets Main Dies and Chiplets.
* @brief   Chiplets reset can be skipped enabling CPSS_HW_PP_RESET_SKIP_TYPE_CHIPLETS_E.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number to reset.
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Soft reset is the process in which selected entities (as configured by
*       using the cpssDxChHwPpSoftResetSkipParamSet API) are reset to their
*       default values.
*
*/
GT_STATUS cpssDxChHwPpSoftResetTrigger
(
    IN  GT_U8 devNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpSoftResetTrigger);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum));

    rc = internal_cpssDxChHwPpSoftResetTrigger(devNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal softResetSkipParamSetLion2 function
* @endinternal
*
* @brief   This routine configure skip parameters related to soft reset.
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] skipType                 - the skip parameter to set
*                                      see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
* @param[in] skipEnable               - GT_FALSE: Do Not Skip
*                                      GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS softResetSkipParamSetLion2
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_U32    resetRegAddr;    /* register address */
    GT_U32    resetRegAddr1;   /* register address */
    GT_U32    bitOffset; /* bit offset or value in register */
    GT_U32    hwValue;   /* HW value            */
    GT_STATUS rc;        /* return status */

    /* only PEX use this register. mark as not used */
    resetRegAddr1 = 0;

    /* Lion2 */
    switch(skipType)
    {
        case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
            resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.regsConfSkipInitMatrix;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
            resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.genSkipInitMatrix11;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
            resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.genSkipInitMatrix2;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
            resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.genSkipInitMatrix1;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
            resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.genSkipInitMatrix8;
            resetRegAddr1 = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.genSkipInitMatrix9;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    bitOffset = 8;
    /*
        0x0 = Skip init  ON; SKIP_INIT_ON
        0x1 = Skip init OFF; SKIP_INIT_OFF
    */
    hwValue = 1 - BOOL2BIT_MAC(skipEnable);

    if (resetRegAddr1)
    {
        rc = prvCpssHwPpSetRegField(devNum, resetRegAddr1, bitOffset, 1, hwValue);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return prvCpssHwPpSetRegField(devNum, resetRegAddr, bitOffset, 1, hwValue);
}

/**
* @internal softResetSkipParamSetSip5 function
* @endinternal
*
* @brief   This routine configure skip parameters related to soft reset.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:   Lion2.
*
* @param[in] devNum                   - device number
* @param[in] skipType                 - the skip parameter to set
*                                      see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
* @param[in] skipEnable               - GT_FALSE: Do Not Skip
*                                      GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS softResetSkipParamSetSip5
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_U32    resetRegAddr;     /* register address */
    GT_U32    addConfigRegAddr; /* register address for additional configuration */
    GT_U32    bitOffset;        /* bit offset or value in register */
    GT_U32    hwValue;          /* HW value            */
    GT_STATUS rc;               /* return code */
    GT_BOOL   isPoeSkipSupported;

    /* xCat3; Bobcat2; Caelum; Bobcat3 */
    if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_FALSE)
    {
        return GT_OK;
    }

    isPoeSkipSupported = (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E ||
             PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E) ? GT_TRUE : GT_FALSE;

    bitOffset = 8;

    /*
        0x0 = Skip init  ON; SKIP_INIT_ON
        0x1 = Skip init OFF; SKIP_INIT_OFF
    */
    hwValue = 1 - BOOL2BIT_MAC(skipEnable);


    switch(skipType)
    {
        case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
            resetRegAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsDeviceSpecificRegs.configSkipInitializationMatrix;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
            resetRegAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsDeviceSpecificRegs.tableSkipInitializationMatrix;

            addConfigRegAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsDeviceSpecificRegs.RAMInitSkipInitializationMatrix;

            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                devNum, addConfigRegAddr, bitOffset, 1, hwValue);
            if(GT_OK != rc)
            {
                return rc;
            }

            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
            resetRegAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsDeviceSpecificRegs.EEPROMSkipInitializationMatrix;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
            resetRegAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsDeviceSpecificRegs.SERDESSkipInitializationMatrix;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
            /*
                Behavior is un-predictable (probably the device will hang)
                if CPU try to read/write registers/tables
                of the device during the time of soft reset
                (Soft reset is active for 2000 core clock cycles (6uS). Waiting 20uS should be enough)
                Event when '<PEX Skip Init if MG Soft Reset> = SKIP INIT ON'
                (no pex reset).

                *******************************
                meaning that even when skip pex reset there is still interval of
                time that the CPU must not approach the device.
            */
            resetRegAddr =
            PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsDeviceSpecificRegs.PCIeSkipInitializationMatrix;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_POE_E:
            if (isPoeSkipSupported)
            {
                resetRegAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                DFXServerUnitsDeviceSpecificRegs.poeSkipInitializationMatrix;
            }
            else
            {
                /* Not applicable in non AC5 devices */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
            }
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }


    return prvCpssDrvHwPpResetAndInitControllerSetRegField(
        devNum, resetRegAddr, bitOffset, 1, hwValue);

}

/**
* @internal prvCpssDxChHwInitSoftResetSip6KeepPexLinkUp function
* @endinternal
*
* @brief   This routine configure skip parameters related to soft reset.
*
* @note   APPLICABLE DEVICES:      Falcon.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] skipType                 - the skip parameter to set
*                                      see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
* @param[in] skipEnable               - GT_FALSE: Do Not Skip
*                                      GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS prvCpssDxChHwInitSoftResetSip6KeepPexLinkUp
(
    IN  GT_U8                           devNum
)
{
    GT_STATUS rc;
    GT_U32  regAddr;

    /* skip the EEPROM reset */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.EEPROMSkipInitializationMatrix;
    rc = prvCpssDrvHwPpSetRegField(devNum, regAddr , 1,1,0);
    if(rc != GT_OK)
    {
        return rc;
    }
    /* skip the device-EEPROM reset */

    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.DeviceEEPROMSkipInitializationMatrix;
    rc = prvCpssDrvHwPpSetRegField(devNum, regAddr , 1,1,0);
    if(rc != GT_OK)
    {
        return rc;
    }
    /* skip the dfx-registers reset */
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.DFXRegistersSkipInitializationMatrix;
    rc = prvCpssDrvHwPpSetRegField(devNum, regAddr , 1,1,0);
    if(rc != GT_OK)
    {
        return rc;
    }

    /*Skip      mng Skip Init Matrix*/
    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.Core_MngSkipInitializationMatrix;
    rc = prvCpssDrvHwPpSetRegField(devNum, regAddr , 1,1,0);
    if(rc != GT_OK)
    {
        return rc;
    }



    return GT_OK;
}

/**
* @internal softResetSkipParamSetAll function
* @endinternal
*
* @brief   This routine configure skip parameters related to soft reset. - ALL /ALL_EXCLUDE_PEX
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] skipType                 - the skip parameter to set , one of:
*                                      CPSS_HW_PP_RESET_SKIP_TYPE_ALL_E,
*                                      CPSS_HW_PP_RESET_SKIP_TYPE_ALL_EXCLUDE_PEX_E
* @param[in] skipEnable               - GT_FALSE: Do Not Skip
*                                      GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS softResetSkipParamSetAll
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_STATUS   rc;         /* return code */
    CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipIterator; /* loop iterator */
    GT_U32    num_GT_OK = 0;/* number of GT_OK that we got */

    for(skipIterator = CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E;
        skipIterator < CPSS_HW_PP_RESET_SKIP_TYPE_ALL_E;
        skipIterator++)
    {
        /* CPSS_HW_PP_RESET_SKIP_TYPE_CHIPLETS_E supported by SIP6 only */
        if ((skipType == CPSS_HW_PP_RESET_SKIP_TYPE_CHIPLETS_E)
            && (! PRV_CPSS_SIP_6_CHECK_MAC(devNum))) continue;

        if(skipType == CPSS_HW_PP_RESET_SKIP_TYPE_ALL_EXCLUDE_PEX_E &&
            skipIterator == CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E)
        {
            /* the pex always will set 'skip' */
            rc = cpssDxChHwPpSoftResetSkipParamSet(devNum, skipIterator, GT_TRUE);
        }
        else
        {
            rc = cpssDxChHwPpSoftResetSkipParamSet(devNum, skipIterator, skipEnable);
        }
        if(rc != GT_OK)
        {
            if(rc == GT_BAD_PARAM || rc == GT_NOT_SUPPORTED || rc == GT_NOT_APPLICABLE_DEVICE)
            {
                /* assume that this specific case is not supported */
            }
            else
            {
                return rc;
            }
        }
        else
        {
            num_GT_OK++;
        }
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E && skipEnable == GT_FALSE &&
        skipType   == CPSS_HW_PP_RESET_SKIP_TYPE_ALL_EXCLUDE_PEX_E)
    {
        /* we more parts for 'reset exclude pex'  */
        rc = prvCpssDxChHwInitSoftResetSip6KeepPexLinkUp(devNum);
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
    }

    if(num_GT_OK == 0)
    {
        /* no flag is supported so declare 'Not supported' -->
           this is Lion2 case ... until implemented */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}


/**
* @internal internal_cpssDxChHwPpSoftResetSkipParamSet function
* @endinternal
*
* @brief   This routine configure skip parameters related to soft reset.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] skipType                 - the skip parameter to set
*                                      see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
* @param[in] skipEnable               - GT_FALSE: Do Not Skip
*                                      GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwPpSoftResetSkipParamSet
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_STATUS rc; /* return code */
    GT_U32    resetRegAddr;   /* register address */
    GT_U32    bitOffset; /* bit offset or value in register */
    GT_U32    hwValue;   /* HW value            */
    PRV_CPSS_DXCH_SOFT_RESET_SKIP_INIT_MATRIX_ENT  hwSkipType;
    GT_U32    index;   /* index in HW skip type sequence */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_FALCON_SKIP_REGISTERS_SW_RESET_NOT_SUPPORTED_WA_E))
    {
        if (skipType == CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E && skipEnable == GT_TRUE)
        {
            /* Soft reset with skip registers is not supported */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
    {
        /* Falcon only - excluded configurations not supported yet */
        switch (skipType)
        {
            case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
            case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
            case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
            case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
            case CPSS_HW_PP_RESET_SKIP_TYPE_ALL_EXCLUDE_PEX_E:
            case CPSS_HW_PP_RESET_SKIP_TYPE_CHIPLETS_E:
                if (skipEnable != GT_FALSE)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
                }
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
                if (skipEnable == GT_FALSE)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
                }
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_ALL_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            /* both GT_TRUE and GT_FALSE allowed */
            default: break;
        }
    }
    else
    {
        /* there are no CPSS_HW_PP_RESET_SKIP_TYPE_CHIPLETS_E */
        if(skipType == CPSS_HW_PP_RESET_SKIP_TYPE_CHIPLETS_E)
        {
            /* no register to set it */
            return GT_OK;
        }
    }

    if(skipType == CPSS_HW_PP_RESET_SKIP_TYPE_ALL_E ||
       skipType == CPSS_HW_PP_RESET_SKIP_TYPE_ALL_EXCLUDE_PEX_E)
    {
        /* set 'ALL' or 'ALL_EXCLUDE_PEX' */
        return softResetSkipParamSetAll(devNum,skipType,skipEnable);
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        return softResetSkipParamSetLion2(devNum,skipType,skipEnable);
    }
    else
    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        for (index = 0; (1); index++)
        {
            rc = prvCpssDxChHwInitSoftResetSkipTypeSw2HwConvert(
                skipType, index, &hwSkipType);
            if (rc == GT_NO_MORE) break;
            if (rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
            }
            /* 0 - Skip is On, 1 - Skip is Off */
            hwValue = (BOOL2BIT_MAC(skipEnable) ^ 1);
            /* bit1 - MNG reset source */
            rc = prvCpssDxChHwInitSoftResetSip6AllSubunitsSkipInitMatrixWriteBitMask(
                devNum, hwSkipType,
                (1 << 1) /*mask*/, (hwValue << 1));
            if (rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
            }
        }

        return GT_OK;
    }
    else
    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE ||
        PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        return softResetSkipParamSetSip5(devNum,skipType,skipEnable);
    }

    /* all devices exclude Lion2; Bobcat2; Caelum; Bobcat3 */
    switch(skipType)
    {
        case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
            bitOffset = 21;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
            bitOffset = 22;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
            bitOffset = 23;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
            bitOffset = 24;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    resetRegAddr =
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl;
    hwValue = BOOL2BIT_MAC(skipEnable);

    return prvCpssHwPpSetRegField(
        devNum, resetRegAddr, bitOffset, 1, hwValue);
}

/**
* @internal cpssDxChHwPpSoftResetSkipParamSet function
* @endinternal
*
* @brief   This routine configure skip parameters related to soft reset.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] skipType                 - the skip parameter to set
*                                      see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
* @param[in] skipEnable               - GT_FALSE: Do Not Skip
*                                      GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwPpSoftResetSkipParamSet
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpSoftResetSkipParamSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, skipType, skipEnable));

    rc = internal_cpssDxChHwPpSoftResetSkipParamSet(devNum, skipType, skipEnable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, skipType, skipEnable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChHwPpSoftResetSkipParamGet function
* @endinternal
*
* @brief   This routine return configuration of skip parameters related to soft reset.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] skipType                 - the skip parameter to set
*                                      see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
*
* @param[out] skipEnablePtr            - GT_FALSE: Do Not Skip
*                                      GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*/
static GT_STATUS internal_cpssDxChHwPpSoftResetSkipParamGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    OUT GT_BOOL                         *skipEnablePtr
)
{
    GT_STATUS rc;        /* return code */
    GT_U32    bitOffset; /* bit offset in register */
    GT_U32    value;     /* register data */
    GT_U32    resetRegAddr;   /* register address */
    PRV_CPSS_DXCH_SOFT_RESET_DFX_TYPE_ENT dfxType;
    PRV_CPSS_DXCH_SOFT_RESET_SKIP_INIT_MATRIX_ENT  hwSkipType;
    GT_BOOL isPoeSkipSupported;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(skipEnablePtr);

    isPoeSkipSupported = (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E ||
             PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5X_E) ? GT_TRUE : GT_FALSE;

    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        if (0 == PRV_CPSS_DXCH_PP_HW_INFO_RAVENS_MAC(devNum).numOfRavens)
        {
            /* there are no CPSS_HW_PP_RESET_SKIP_TYPE_CHIPLETS_E */
            if(skipType == CPSS_HW_PP_RESET_SKIP_TYPE_CHIPLETS_E)
            {
                *skipEnablePtr = GT_TRUE;
                /* no register to set it */
                return GT_OK;
            }
        }

        rc = prvCpssDxChHwInitSoftResetSkipTypeSw2HwConvert(
            skipType, 0/*index*/, &hwSkipType);
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
        switch (hwSkipType)
        {
            case PRV_CPSS_DXCH_SOFT_RESET_SKIP_INIT_MATRIX_GOP_D2D_E:
            case PRV_CPSS_DXCH_SOFT_RESET_SKIP_INIT_MATRIX_GOP_MAIN_E:
            case PRV_CPSS_DXCH_SOFT_RESET_SKIP_INIT_MATRIX_GOP_CNM_E:
            case PRV_CPSS_DXCH_SOFT_RESET_SKIP_INIT_MATRIX_GOP_GW_E:
                dfxType = PRV_CPSS_DXCH_SOFT_RESET_DFX_GOP_E;
                break;
            default:
                dfxType = PRV_CPSS_DXCH_SOFT_RESET_DFX_CORE_E;
                break;
        }
        rc = prvCpssDxChHwInitSoftResetSip6SkipInitMatrixRead(
            devNum, dfxType,
            0 /*tileIndex*/, 0 /*gopIndex*/, hwSkipType, &value);
        if (GT_OK != rc )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }

        /* 0 - Skip is On, 1 - Skip is Off */
        /* bit1 - MNG reset source         */
        *skipEnablePtr = (value & (1 << 1)) ? GT_FALSE : GT_TRUE;
        return GT_OK;
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily
             == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        /* Lion2 */
        switch(skipType)
        {
            case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
                resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.regsConfSkipInitMatrix;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
                resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.genSkipInitMatrix11;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
                resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.genSkipInitMatrix2;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
                resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.genSkipInitMatrix1;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
                resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.genSkipInitMatrix8;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        bitOffset = 8;
    }
    else if (PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE ||
             PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        /* xCat3; AC5; Bobcat2; Caelum; Bobcat3 */
        if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_FALSE)
        {
            *skipEnablePtr = GT_TRUE;
            switch(skipType)
            {
                case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
                case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
                case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
                case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
                case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
                    return GT_OK;
                case CPSS_HW_PP_RESET_SKIP_TYPE_POE_E:
                    if (isPoeSkipSupported)
                    {
                        return GT_OK;
                    }
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }

        switch(skipType)
        {
            case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
                resetRegAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsDeviceSpecificRegs.configSkipInitializationMatrix;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
                resetRegAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsDeviceSpecificRegs.tableSkipInitializationMatrix;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
                resetRegAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsDeviceSpecificRegs.EEPROMSkipInitializationMatrix;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
                resetRegAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsDeviceSpecificRegs.SERDESSkipInitializationMatrix;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
                resetRegAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsDeviceSpecificRegs.PCIeSkipInitializationMatrix;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_POE_E:
                if (isPoeSkipSupported)
                {
                    resetRegAddr =
                    PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                        DFXServerUnitsDeviceSpecificRegs.poeSkipInitializationMatrix;
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        bitOffset = 8;
    }
    else
    {
        switch(skipType)
        {
            case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
                bitOffset = 21;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
                bitOffset = 22;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
                bitOffset = 23;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
                bitOffset = 24;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

         /* all devices exclude Lion2; Bobcat2; Caelum; Bobcat3 */
        resetRegAddr =
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl;
   }

    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE ||
        PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(
                                    devNum, resetRegAddr, bitOffset, 1, &value);
    }
    else
    {
        rc =  prvCpssHwPpGetRegField(devNum, resetRegAddr, bitOffset, 1, &value);
    }

    if (rc != GT_OK)
    {
        return rc;
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E ||
        PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE ||
        PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        /* xCat3; Bobcat2; Caelum; Bobcat3 - invert the retrieved bit */
        value = ((~ value) & 1);
    }
    *skipEnablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/**
* @internal cpssDxChHwPpSoftResetSkipParamGet function
* @endinternal
*
* @brief   This routine return configuration of skip parameters related to soft reset.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] skipType                 - the skip parameter to set
*                                      see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
*
* @param[out] skipEnablePtr            - GT_FALSE: Do Not Skip
*                                      GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*/
GT_STATUS cpssDxChHwPpSoftResetSkipParamGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    OUT GT_BOOL                         *skipEnablePtr

)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpSoftResetSkipParamGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, skipType, skipEnablePtr));

    rc = internal_cpssDxChHwPpSoftResetSkipParamGet(devNum, skipType, skipEnablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, skipType, skipEnablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChHwPpSoftResetChipletsTrigger function
* @endinternal
*
* @brief   This routine issue soft reset for a set of chiplets.
* @brief   Does not reset Main Dies.
*
* @note   APPLICABLE DEVICES:      Falcon.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] chipletsBmp              - bitmap of chiplet indexes to reset.
*                                       CPSS_CHIPLETS_UNAWARE_MODE_CNS for all chiplets of the device
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Soft reset is the process in which selected entities (as configured by
*       using the cpssDxChHwPpSoftResetChipletsSkipParamSet API) are reset to their
*       default values.
*
*/
static GT_STATUS internal_cpssDxChHwPpSoftResetChipletsTrigger
(
    IN  GT_U8                   devNum,
    IN  GT_CHIPLETS_BMP         chipletsBmp
)
{
    GT_STATUS                               rc;
    PRV_CPSS_DXCH_SOFT_RESET_DFX_TYPE_ENT   dfxType;
    GT_U32                                  tileIndex;
    GT_U32                                  gopIndex;
    GT_U32                                  gopGlobalIndex;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
          CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if (chipletsBmp == CPSS_CHIPLETS_UNAWARE_MODE_CNS)
    {
        chipletsBmp = 0xFFFFFFFF; /* rise all bits */
    }
    dfxType = PRV_CPSS_DXCH_SOFT_RESET_DFX_GOP_E;
    for (tileIndex = 0; (tileIndex < PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles); tileIndex++)
    {
        for (gopIndex = 0; (gopIndex < FALCON_RAVENS_PER_TILE); gopIndex++)
        {
            PRV_CPSS_SKIP_NOT_EXIST_RAVEN_MAC(devNum, tileIndex, gopIndex);

            gopGlobalIndex =
                ((PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles * tileIndex)
                 + gopIndex);
            if ((chipletsBmp & (1 << gopGlobalIndex)) == 0) continue;

            /* set bits of : <MG Soft Reset Trigger> and <Table Start Init> */
            /* the <Table Start Init> = 0 is relevant only when <skip table> == false
                and means that 'tables' will be re-initialized */
            rc = prvCpssDxChHwInitSoftResetSip6ResetTriggerRegWriteBitMask(
                devNum, dfxType, tileIndex, gopIndex, 6/*mask*/, 0/*data*/);
            if (rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
            }
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChHwPpSoftResetChipletsTrigger function
* @endinternal
*
* @brief   This routine issue soft reset for a set of chiplets.
* @brief   Does not reset Main Dies.
*
* @note   APPLICABLE DEVICES:      Falcon.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number.
* @param[in] chipletsBmp              - bitmap of chiplet indexes to reset.
*                                       CPSS_CHIPLETS_UNAWARE_MODE_CNS for all chiplets of the device
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Soft reset is the process in which selected entities (as configured by
*       using the cpssDxChHwPpSoftResetChipletsSkipParamSet API) are reset to their
*       default values.
*
*/
GT_STATUS cpssDxChHwPpSoftResetChipletsTrigger
(
    IN  GT_U8                   devNum,
    IN  GT_CHIPLETS_BMP         chipletsBmp
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpSoftResetChipletsTrigger);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, chipletsBmp));

    rc = internal_cpssDxChHwPpSoftResetChipletsTrigger(devNum, chipletsBmp);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, chipletsBmp));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChHwPpSoftResetChipletsSkipParamSet function
* @endinternal
*
* @brief   This routine configure skip parameters related to soft reset of set of chiplets.
*
* @note   APPLICABLE DEVICES:      Falcon.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] chipletsBmp              - bitmap of chiplet indexes to reset.
*                                       CPSS_CHIPLETS_UNAWARE_MODE_CNS for all chiplets of the device
* @param[in] skipType                 - the skip parameter to set
*                                       see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
*                                       All values except CPSS_HW_PP_RESET_SKIP_TYPE_CHIPLETS_E
*                                       are appicable. This skip type relevant to Main Die only.
*                                       The function returns GT_OK ingnoring this value.
*
* @param[in] skipEnable               - GT_FALSE: Do Not Skip
*                                       GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwPpSoftResetChipletsSkipParamSet
(
    IN  GT_U8                           devNum,
    IN  GT_CHIPLETS_BMP                 chipletsBmp,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_STATUS                                      rc;
    GT_U32                                         hwValue;
    GT_U32                                         index;
    PRV_CPSS_DXCH_SOFT_RESET_SKIP_INIT_MATRIX_ENT  hwSkipType;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
          CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    for (index = 0; (1); index++)
    {
        rc = prvCpssDxChHwInitSoftResetSkipTypeSw2HwConvert(
            skipType, index, &hwSkipType);
        if (rc == GT_NO_MORE) break;
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
        /* 0 - Skip is On, 1 - Skip is Off */
        hwValue = (BOOL2BIT_MAC(skipEnable) ^ 1);
        /* bit8 - Local DFX Server reset source */
        rc = prvCpssDxChHwInitSoftResetSip6GopSetSkipInitMatrixWriteBitMask(
            devNum, chipletsBmp, hwSkipType,
            (1 << 8) /*mask*/, (hwValue << 8));
        if (rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
    }
    return GT_OK;
}

/**
* @internal cpssDxChHwPpSoftResetChipletsSkipParamSet function
* @endinternal
*
* @brief   This routine configure skip parameters related to soft reset of set of chiplets.
*
* @note   APPLICABLE DEVICES:      Falcon.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] chipletsBmp              - bitmap of chiplet indexes to reset.
*                                       CPSS_CHIPLETS_UNAWARE_MODE_CNS for all chiplets of the device
* @param[in] skipType                 - the skip parameter to set
*                                       see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
*                                       All values except CPSS_HW_PP_RESET_SKIP_TYPE_CHIPLETS_E
*                                       are appicable. This skip type relevant to Main Die only.
*                                       The function returns GT_OK ingnoring this value.
* @param[in] skipEnable               - GT_FALSE: Do Not Skip
*                                       GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwPpSoftResetChipletsSkipParamSet
(
    IN  GT_U8                           devNum,
    IN  GT_CHIPLETS_BMP                 chipletsBmp,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpSoftResetChipletsSkipParamSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, chipletsBmp, skipType, skipEnable));

    rc = internal_cpssDxChHwPpSoftResetChipletsSkipParamSet(
        devNum, chipletsBmp, skipType, skipEnable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, chipletsBmp, skipType, skipEnable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChHwPpSoftResetChipletsSkipParamGet function
* @endinternal
*
* @brief   This routine get skip parameters related to soft reset of chiplet.
*
* @note   APPLICABLE DEVICES:      Falcon.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] chipletsBmp              - bitmap of chiplet indexes to set skip reset state,
*                                       CPSS_CHIPLETS_UNAWARE_MODE_CNS for all chiplets of the device.
* @param[in] skipType                 - the skip parameter to get.
*                                      see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
* @param[out] skipEnablePtr           - pointer to GT_FALSE: Do Not Skip
*                                                  GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChHwPpSoftResetChipletsSkipParamGet
(
    IN  GT_U8                           devNum,
    IN  GT_CHIPLETS_BMP                 chipletsBmp,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    OUT GT_BOOL                         *skipEnablePtr
)
{
    GT_STATUS                                      rc;
    GT_U32                                         hwValue;
    GT_U32                                         swValue;
    PRV_CPSS_DXCH_SOFT_RESET_DFX_TYPE_ENT          dfxType;
    GT_U32                                         tileIndex;
    GT_U32                                         gopIndex;
    PRV_CPSS_DXCH_SOFT_RESET_SKIP_INIT_MATRIX_ENT  hwSkipType;
    GT_U32                                         chipletIndex;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
          CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    CPSS_NULL_PTR_CHECK_MAC(skipEnablePtr);

    if (chipletsBmp == 0)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    chipletIndex = 0;
    if (chipletsBmp != CPSS_CHIPLETS_UNAWARE_MODE_CNS)
    {
        /* look for first nonzero bit in bitmap */
        for (;
              ((chipletIndex < 31) && ((chipletsBmp & (1 << chipletIndex)) == 0)) ;
              chipletIndex++) {};
    }

    tileIndex = (chipletIndex / FALCON_RAVENS_PER_TILE);
    if (tileIndex >= PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfTiles)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    gopIndex = (chipletIndex % FALCON_RAVENS_PER_TILE);
    rc = prvCpssDxChHwInitSoftResetSkipTypeSw2HwConvert(
        skipType, 0/*index*/, &hwSkipType);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    dfxType = PRV_CPSS_DXCH_SOFT_RESET_DFX_GOP_E;
    rc = prvCpssDxChHwInitSoftResetSip6SkipInitMatrixRead(
        devNum, dfxType, tileIndex, gopIndex, hwSkipType, &hwValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    /* 0 - Skip is On, 1 - Skip is Off */
    /* bit8 - Local DFX Server reset source */
    swValue    = (((hwValue >> 8) & 1) ^ 1);
    *skipEnablePtr = BIT2BOOL_MAC(swValue);
    return GT_OK;
}

/**
* @internal cpssDxChHwPpSoftResetChipletsSkipParamGet function
* @endinternal
*
* @brief   This routine get skip parameters related to soft reset of chiplet.
*
* @note   APPLICABLE DEVICES:      Falcon.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] chipletsBmp              - bitmap of chiplet indexes to set skip reset state,
*                                       CPSS_CHIPLETS_UNAWARE_MODE_CNS for all chiplets of the device.
* @param[in] skipType                 - the skip parameter to get.
*                                      see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
* @param[out] skipEnablePtr           - pointer to GT_FALSE: Do Not Skip
*                                                  GT_TRUE:  Skip
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, or skipType
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChHwPpSoftResetChipletsSkipParamGet
(
    IN  GT_U8                           devNum,
    IN  GT_CHIPLETS_BMP                 chipletsBmp,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    OUT GT_BOOL                         *skipEnablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpSoftResetChipletsSkipParamGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, chipletsBmp, skipType, skipEnablePtr));

    rc = internal_cpssDxChHwPpSoftResetChipletsSkipParamGet(
        devNum, chipletsBmp, skipType, skipEnablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, chipletsBmp, skipType, skipEnablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChHwPpInitStageGet function
* @endinternal
*
* @brief   Indicates the initialization stage of the device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number to reset.
*
* @param[out] initStagePtr             - pointer to the stage of the device
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*/
static GT_STATUS internal_cpssDxChHwPpInitStageGet
(
    IN  GT_U8                      devNum,
    OUT CPSS_HW_PP_INIT_STAGE_ENT  *initStagePtr
)
{
    GT_STATUS rc;
    GT_U32    value;        /* value of field */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(initStagePtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE ||
       PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {

        if(PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_FALSE)
        {
            /* we are not allowed to access the DFX registers */
            *initStagePtr =  CPSS_HW_PP_INIT_STAGE_FULLY_FUNC_E;

            return GT_OK;
        }

        rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(devNum,
                        PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                            DFXServerUnits.DFXServerRegs.serverStatus,
                        4, 2, &value);
    }
    else
    {
        rc =  prvCpssHwPpGetRegField(devNum,
                       PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl,
                       17, 2, &value) ;
    }

    if(rc != GT_OK)
        return rc;

    switch(value)
    {
        case 0:
            *initStagePtr =  CPSS_HW_PP_INIT_STAGE_INIT_DURING_RESET_E;
            break;
        case 1:
            *initStagePtr =  CPSS_HW_PP_INIT_STAGE_EEPROM_DONE_INT_MEM_DONE_E;
            break;
        case 2:
            *initStagePtr =  CPSS_HW_PP_INIT_STAGE_EEPROM_NOT_DONE_INT_MEM_DONE_E;
            break;
        case 3:
            *initStagePtr =  CPSS_HW_PP_INIT_STAGE_FULLY_FUNC_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    return rc;

}

/**
* @internal cpssDxChHwPpInitStageGet function
* @endinternal
*
* @brief   Indicates the initialization stage of the device.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number to reset.
*
* @param[out] initStagePtr             - pointer to the stage of the device
*
* @retval GT_OK                    - on success,
* @retval GT_FAIL                  - otherwise.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*/
GT_STATUS cpssDxChHwPpInitStageGet
(
    IN  GT_U8                      devNum,
    OUT CPSS_HW_PP_INIT_STAGE_ENT  *initStagePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpInitStageGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, initStagePtr));

    rc = internal_cpssDxChHwPpInitStageGet(devNum, initStagePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, initStagePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChCscdPortLocalDeviceNumberSet function
* @endinternal
*
* @brief   Set the <Local Device Number> for an egress Cascade Port.
*         this value act as <srcDev> field in the FORWARD DSA tag that egress the port.
*         NOTE: this value is used even when <Set Source to Local> is UNSET ,
*         for packets that ingresses without DSA tag to the device.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number or CPU port
* @param[in] localHwDeviceNumber      - the local HW device number.
*                                      (APPLICABLE RANGES: 0..0xFFF)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_OUT_OF_RANGE          - the value of localDeviceNumber is out of range.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS prvCpssDxChCscdPortLocalDeviceNumberSet
(
    IN  GT_U8                               devNum,
    IN  GT_PHYSICAL_PORT_NUM                portNum,
    IN  GT_HW_DEV_NUM                       localHwDeviceNumber
)
{
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

    /* <Local Device Number> */
    rc = prvCpssDxChWriteTableEntryField(devNum,
              CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_2_E,
              portNum, /*global port*/
              PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
              SIP5_HA_PHYSICAL_PORT_TABLE_2_FIELDS_LOCAL_DEVICE_NUMBER_E, /* field name */
              PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
              localHwDeviceNumber);

    return rc;
}


/**
* @internal internal_cpssDxChCfgHwDevNumSet function
* @endinternal
*
* @brief   write HW device number
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] hwDevNum                 - HW device number
*                                      (APPLICABLE RANGES: xCat3, AC5, Lion2 - 0..31)
*                                      (APPLICABLE RANGES: Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman - 0..1023)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_OUT_OF_RANGE          - on hwDevNum out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChCfgHwDevNumSet
(
    IN GT_U8    devNum,
    IN GT_HW_DEV_NUM    hwDevNum
)
{
    GT_STATUS rc;
    GT_U32    regAddr;      /* register's address */
    GT_U32    portGroupId;    /* port group id    */
    GT_PHYSICAL_PORT_NUM    portNum;
    CPSS_SYSTEM_RECOVERY_INFO_STC tempSystemRecovery_Info;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(hwDevNum > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if (HWINIT_GLOVAR(sysGenGlobalInfo.supportDualDeviceId) == GT_TRUE)
    {
        /* this is 'dual device system' all hwDevNum for all devices (not only those of Lion2)
            must be even (0,2,4,6...)*/
        if (hwDevNum & 1)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    /* The function must be called before DB update by new HW device number. */
    rc = prvCpssDxChTrunkHwDevNumSet(devNum, hwDevNum);
    if(rc != GT_OK)
    {
        return rc;
    }
    regAddr =  PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl;

    /* write to both hemisphere if exists */
    if ( (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) &&
         (PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_2_MAC(devNum) ) )
    {
        /* check that even */
        if (hwDevNum%2)
        {
            /* NOTE that we should never get here because the 'phase1Init' already
               checked that the lion2 is in system of supportDualDeviceId == GT_TRUE
               and in start of current function we already checked validity of 'must be even number'

               BUT we keep this check for the completeness of logic.
               */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* set on all port groups in hemisphere 0 the hwDevNum */
        for (portGroupId=0; portGroupId < PRV_CPSS_DXCH_PORT_GROUPS_NUM_IN_HEMISPHERE_CNS;
              portGroupId++)
        {
            /* skip non active port groups */
            if((PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.activePortGroupsBmp & (1 << portGroupId)) == 0)
            {
                continue;
            }

            rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,4,5,hwDevNum);
            if (rc != GT_OK)
            {
                return rc;
            }

        }

        /* set on all port groups in hemisphere 1 the hwDevNum+1 */
        for (portGroupId=PRV_CPSS_DXCH_PORT_GROUPS_NUM_IN_HEMISPHERE_CNS;
              portGroupId <PRV_CPSS_LION2_PORT_GROUPS_NUM_CNS; portGroupId++)
        {
            /* skip non active port groups */
            if((PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.activePortGroupsBmp & (1 << portGroupId)) == 0)
            {
                continue;
            }

            rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,4,5,hwDevNum+1);
            if (rc != GT_OK)
            {
                return rc;
            }

        }

        /* unmark the old HW dev number to default single mode */
        rc = cpssDxChCscdDbRemoteHwDevNumModeSet(PRV_CPSS_HW_DEV_NUM_MAC(devNum),
                                                 CPSS_GEN_CFG_HW_DEV_NUM_MODE_SINGLE_E);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* mark the new HW dev as daul device in the DB */
        rc = cpssDxChCscdDbRemoteHwDevNumModeSet(hwDevNum,
                                                 CPSS_GEN_CFG_HW_DEV_NUM_MODE_DUAL_E);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* save HW devNum to the DB */
        PRV_CPSS_HW_DEV_NUM_MAC(devNum) = hwDevNum;

        return GT_OK;
    }

    /* allow HW write to the device Device_ID within a Prestera chipset*/
    if (DXCH_HWINIT_GLOVAR(dxChHwInitSrc.dxChFastBootSkipOwnDeviceInit) == GT_FALSE)
    {
        /* Set all 5 or 10 bits of "ownDevNum" in Global Control register */
        rc = prvCpssHwPpSetRegField(devNum, regAddr,
                                       4,PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).hwDevNum,
                                       hwDevNum);
        if(rc != GT_OK)
        {
            return rc;
        }

        if (PRV_CPSS_SIP_6_CHECK_MAC(devNum)
            && (PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE))
        {
            if (PRV_CPSS_SIP_6_20_CHECK_MAC(devNum))
            {
                /* Harrier own_dev */
                regAddr =
                    PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                        DFXServerUnitsDeviceSpecificRegs.deviceCtrl6;

                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                     devNum, regAddr, 0, 10, hwDevNum);
            }
            else
            if (PRV_CPSS_SIP_6_15_CHECK_MAC(devNum))
            {
                /* AC5X own_dev */
                regAddr =
                    PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                        DFXServerUnitsDeviceSpecificRegs.deviceCtrl25;

                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                     devNum, regAddr, 22, 10, hwDevNum);
            }
            else
            if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
            {
                /* Hawk own_dev */
                regAddr =
                    PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                        DFXServerUnitsDeviceSpecificRegs.deviceCtrl17;

                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                     devNum, regAddr, 11, 10, hwDevNum);
            }
            else
            {
                /* Falcon own_dev */
                regAddr =
                    PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                        DFXServerUnitsDeviceSpecificRegs.deviceCtrl29;

                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                     devNum, regAddr, 12, 10, hwDevNum);
            }
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }


    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /*
            set all the egress physical ports with the 'own device'.
            This config relate to cascade ports and the <srcDev> in the FORWARD DSA tag.

        */
        rc = cpssSystemRecoveryStateGet(&tempSystemRecovery_Info);
        if (rc != GT_OK)
        {
            return rc;
        }
        if (!((tempSystemRecovery_Info.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HA_E) &&
             (tempSystemRecovery_Info.systemRecoveryState == CPSS_SYSTEM_RECOVERY_INIT_STATE_E)) )
        {
            for( portNum = 0 ;
                 portNum < PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum) ;
                 portNum ++ )
            {
                rc = prvCpssDxChCscdPortLocalDeviceNumberSet(devNum,portNum,hwDevNum);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
    }

    /* save HW devNum to the DB */
    PRV_CPSS_HW_DEV_NUM_MAC(devNum) = hwDevNum;

    if(PRV_CPSS_DXCH_PP_MAC(devNum)->port.falconPortDeleteInfoPtr &&
       PRV_CPSS_DXCH_PP_MAC(devNum)->port.falconPortDeleteInfoPtr->isWaNeeded == GT_TRUE)
    {
        /* called after update of PRV_CPSS_HW_DEV_NUM_MAC(devNum)*/
        rc = prvCpssDxChFalconPortDeleteWa_updateHwDevNum(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChCfgHwDevNumSet function
* @endinternal
*
* @brief   write HW device number
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] hwDevNum                 - HW device number
*                                      (APPLICABLE RANGES: xCat3, AC5, Lion2 - 0..31)
*                                      (APPLICABLE RANGES: Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman - 0..1023)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_OUT_OF_RANGE          - on hwDevNum out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChCfgHwDevNumSet
(
    IN GT_U8    devNum,
    IN GT_HW_DEV_NUM    hwDevNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChCfgHwDevNumSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, hwDevNum));

    rc = internal_cpssDxChCfgHwDevNumSet(devNum, hwDevNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, hwDevNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChCfgHwDevNumGet function
* @endinternal
*
* @brief   Read HW device number
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] hwDevNumPtr              - Pointer to HW device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChCfgHwDevNumGet
(
    IN GT_U8    devNum,
    OUT GT_HW_DEV_NUM   *hwDevNumPtr
)
{
    GT_U32    regVal,regVal1; /* register field value */
    GT_U32    regAddr;
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(hwDevNumPtr);

    /* Get 5 or 10 bits "ownDevNum" from Global Control register */
    rc = prvCpssHwPpGetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                   globalRegs.globalControl,
                                   4, PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).hwDevNum,
                                   &regVal);
    if(rc != GT_OK)
    {
        return rc;
    }

    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum)
        && (PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_TRUE))
    {
        /* own_dev fron DFX Server */
        if (PRV_CPSS_SIP_6_20_CHECK_MAC(devNum))
        {
            /* Harrier own_dev */
            regAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                    DFXServerUnitsDeviceSpecificRegs.deviceCtrl6;

            rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(
                 devNum, regAddr, 0, 10, &regVal1);
        }
        else
        if (PRV_CPSS_SIP_6_15_CHECK_MAC(devNum))
        {
            /* AC5X own_dev */
            regAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                    DFXServerUnitsDeviceSpecificRegs.deviceCtrl25;

            rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(
                 devNum, regAddr, 22, 10, &regVal1);
        }
        else
        if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
        {
            /* Hawk */
            regAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                    DFXServerUnitsDeviceSpecificRegs.deviceCtrl17;

            rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(
                 devNum, regAddr, 11, 10 , &regVal1);
        }
        else
        {
            /* falcon */
            regAddr =
                PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                    DFXServerUnitsDeviceSpecificRegs.deviceCtrl29;

            rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(
                 devNum, regAddr, 12, 10 , &regVal1);
        }
        if (rc != GT_OK)
        {
            return rc;
        }

        if (regVal1 != regVal)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE,
                "Mismatch: DFX-server unit <ownDev>[0x%3.3x] but MG <ownDev> [0x%3.3x]",
                regVal1,regVal);
        }
    }
    *hwDevNumPtr = regVal;

    return GT_OK;
}

/**
* @internal cpssDxChCfgHwDevNumGet function
* @endinternal
*
* @brief   Read HW device number
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] hwDevNumPtr              - Pointer to HW device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_BAD_PTR               - one of the parameters in NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChCfgHwDevNumGet
(
    IN GT_U8    devNum,
    OUT GT_HW_DEV_NUM   *hwDevNumPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChCfgHwDevNumGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, hwDevNumPtr));

    rc = internal_cpssDxChCfgHwDevNumGet(devNum, hwDevNumPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, hwDevNumPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChHwCoreClockGet function
* @endinternal
*
* @brief   This function returns the core clock value from cpss DB and from HW.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The Pp's device number.
*
* @param[out] coreClkDbPtr             - Pp's core clock from cpss DB (MHz)
* @param[out] coreClkHwPtr             - Pp's core clock read from HW (MHz) or zero
*                                      if PLL configuration as sampled at reset could
*                                      not be mapped to core clock value.
*
* @retval GT_OK                    - on success,
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwCoreClockGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *coreClkDbPtr,
    OUT GT_U32  *coreClkHwPtr
)
{
    GT_STATUS rc;
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(coreClkDbPtr);
    CPSS_NULL_PTR_CHECK_MAC(coreClkHwPtr);

    *coreClkDbPtr = PRV_CPSS_PP_MAC(devNum)->coreClock;
    rc = hwPpAutoDetectCoreClock(devNum,coreClkHwPtr);
    if (rc == GT_BAD_STATE)
    {
        *coreClkHwPtr = 0;
        rc = GT_OK;
    }
    return rc;
}

/**
* @internal cpssDxChHwCoreClockGet function
* @endinternal
*
* @brief   This function returns the core clock value from cpss DB and from HW.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The Pp's device number.
*
* @param[out] coreClkDbPtr             - Pp's core clock from cpss DB (MHz)
* @param[out] coreClkHwPtr             - Pp's core clock read from HW (MHz) or zero
*                                      if PLL configuration as sampled at reset could
*                                      not be mapped to core clock value.
*
* @retval GT_OK                    - on success,
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwCoreClockGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *coreClkDbPtr,
    OUT GT_U32  *coreClkHwPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwCoreClockGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, coreClkDbPtr, coreClkHwPtr));

    rc = internal_cpssDxChHwCoreClockGet(devNum, coreClkDbPtr, coreClkHwPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, coreClkDbPtr, coreClkHwPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChHwInterruptCoalescingSet function
* @endinternal
*
* @brief   Configures the interrupt coalescing parameters and enable\disable the
*         functionality.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - GT_TRUE: interrupt coalescing is enabled
*                                      GT_FALSE: interrupt coalescing is disabled
* @param[in] period                   - Minimal IDLE  between two consecutive interrupts.
*                                      The units of this input parameter is in nSec, the
*                                      resolution is in 320 nSec (the HW resolution for the
*                                      interrupt coalescing period is 0.32uSec). In case interrupt
*                                      coalescing is enabled (enable == GT_TRUE)
*                                      (APPLICABLE RANGES: 320..5242560).
*                                      Otherwise (enable == GT_FALSE), ignored.
* @param[in] linkChangeOverride       - GT_TRUE: A link change in one of the ports
*                                      results interrupt regardless of the (coalescing)
* @param[in] period
*                                      GT_FALSE: A link change in one of the ports
*                                      does not results interrupt immediately but
*                                      according to the (coalescing) period.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - parameter out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwInterruptCoalescingSet
(
    IN GT_U8    devNum,
    IN GT_BOOL  enable,
    IN GT_U32   period,
    IN GT_BOOL  linkChangeOverride
)
{
    GT_U32 regAddr;   /* register's address */
    GT_U32 regData;   /* register's data */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if( enable == GT_TRUE )
    {
        if( period < MIN_INTERRUPT_COALESCING_PERIOD_CNS ||
            period > MAX_INTERRUPT_COALESCING_PERIOD_CNS )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        regData = period/MIN_INTERRUPT_COALESCING_PERIOD_CNS;
    }
    else /* enable == GT_FALSE */
    {
        regData = 0;
    }

    U32_SET_FIELD_MAC(regData, 16, 1, ((linkChangeOverride == GT_TRUE) ? 0 : 1));

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.interruptCoalescing;

    return prvCpssHwPpWriteRegBitMask(devNum, regAddr, 0x13FFF, regData);
}

/**
* @internal cpssDxChHwInterruptCoalescingSet function
* @endinternal
*
* @brief   Configures the interrupt coalescing parameters and enable\disable the
*         functionality.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - GT_TRUE: interrupt coalescing is enabled
*                                      GT_FALSE: interrupt coalescing is disabled
* @param[in] period                   - Minimal IDLE  between two consecutive interrupts.
*                                      The units of this input parameter is in nSec, the
*                                      resolution is in 320 nSec (the HW resolution for the
*                                      interrupt coalescing period is 0.32uSec). In case interrupt
*                                      coalescing is enabled (enable == GT_TRUE)
*                                      (APPLICABLE RANGES: 320..5242560).
*                                      Otherwise (enable == GT_FALSE), ignored.
* @param[in] linkChangeOverride       - GT_TRUE: A link change in one of the ports
*                                      results interrupt regardless of the (coalescing)
* @param[in] period
*                                      GT_FALSE: A link change in one of the ports
*                                      does not results interrupt immediately but
*                                      according to the (coalescing) period.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - parameter out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwInterruptCoalescingSet
(
    IN GT_U8    devNum,
    IN GT_BOOL  enable,
    IN GT_U32   period,
    IN GT_BOOL  linkChangeOverride
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwInterruptCoalescingSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable, period, linkChangeOverride));

    rc = internal_cpssDxChHwInterruptCoalescingSet(devNum, enable, period, linkChangeOverride);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable, period, linkChangeOverride));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChHwInterruptCoalescingGet function
* @endinternal
*
* @brief   Gets the interrupt coalescing configuration parameters.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) GT_TRUE: interrupt coalescing is enabled
*                                      GT_FALSE: interrupt coalescing is disabled
* @param[out] periodPtr                - (pointer to) Minimal IDLE period between two consecutive
*                                      interrupts. The units are in nSec with resolution of
*                                      320nSec (due to HW resolution) and is relevant only in
*                                      case interrupt coalescing is enabled (enablePtr == GT_TRUE).
*                                      (APPLICABLE RANGES: 320..5242560).
* @param[out] linkChangeOverridePtr    - (pointer to)
*                                      GT_TRUE: A link change in one of the ports
*                                      results interrupt regardless of the (coalescing)
*                                      period.
*                                      GT_FALSE: A link change in one of the ports
*                                      does not results interrupt immediately but
*                                      according to the (coalescing) period.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The HW resolution for the interrupt coalescing period is 0.32uSec.
*
*/
static GT_STATUS internal_cpssDxChHwInterruptCoalescingGet
(
    IN GT_U8        devNum,
    OUT GT_BOOL     *enablePtr,
    OUT GT_U32      *periodPtr,
    OUT GT_BOOL     *linkChangeOverridePtr
)
{
    GT_U32 regAddr;   /* register's address */
    GT_U32 regData;   /* register's data */
    GT_STATUS rc;     /* return code */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);
    CPSS_NULL_PTR_CHECK_MAC(periodPtr);
    CPSS_NULL_PTR_CHECK_MAC(linkChangeOverridePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.interruptCoalescing;

    rc = prvCpssHwPpReadRegBitMask(devNum, regAddr, 0x13FFF, &regData);
    if( rc != GT_OK )
        return rc;

    *periodPtr = (GT_U32)(U32_GET_FIELD_MAC(regData, 0, 14) * MIN_INTERRUPT_COALESCING_PERIOD_CNS);

    *enablePtr = (*periodPtr == 0 ) ? GT_FALSE : GT_TRUE ;

    *linkChangeOverridePtr =
        (U32_GET_FIELD_MAC(regData, 16, 1) == 0) ? GT_TRUE : GT_FALSE ;

    return GT_OK;
}

/**
* @internal cpssDxChHwInterruptCoalescingGet function
* @endinternal
*
* @brief   Gets the interrupt coalescing configuration parameters.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) GT_TRUE: interrupt coalescing is enabled
*                                      GT_FALSE: interrupt coalescing is disabled
* @param[out] periodPtr                - (pointer to) Minimal IDLE period between two consecutive
*                                      interrupts. The units are in nSec with resolution of
*                                      320nSec (due to HW resolution) and is relevant only in
*                                      case interrupt coalescing is enabled (enablePtr == GT_TRUE).
*                                      (APPLICABLE RANGES: 320..5242560).
* @param[out] linkChangeOverridePtr    - (pointer to)
*                                      GT_TRUE: A link change in one of the ports
*                                      results interrupt regardless of the (coalescing)
*                                      period.
*                                      GT_FALSE: A link change in one of the ports
*                                      does not results interrupt immediately but
*                                      according to the (coalescing) period.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The HW resolution for the interrupt coalescing period is 0.32uSec.
*
*/
GT_STATUS cpssDxChHwInterruptCoalescingGet
(
    IN GT_U8        devNum,
    OUT GT_BOOL     *enablePtr,
    OUT GT_U32      *periodPtr,
    OUT GT_BOOL     *linkChangeOverridePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwInterruptCoalescingGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr, periodPtr, linkChangeOverridePtr));

    rc = internal_cpssDxChHwInterruptCoalescingGet(devNum, enablePtr, periodPtr, linkChangeOverridePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr, periodPtr, linkChangeOverridePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal prvCpssDxChHwDropModeToHwValueAndPacketCommandConvert function
* @endinternal
*
* @brief   convert from 'drop mode' to : packet command and to HW value
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] dropMode                 - drop mode
*
* @param[out] packetCommandPtr         - (pointer to) packet command (can be NULL --> ignored)
* @param[out] fieldValuePtr            - (pointer to) HW field value (can be NULL --> ignored)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChHwDropModeToHwValueAndPacketCommandConvert
(
    IN GT_U8        devNum,
    IN CPSS_DROP_MODE_TYPE_ENT dropMode,
    OUT CPSS_PACKET_CMD_ENT *packetCommandPtr,
    OUT GT_U32              *fieldValuePtr
)
{
    CPSS_PACKET_CMD_ENT packetCommand; /*packet command */
    GT_U32            fieldValue;/*field value */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    switch(dropMode)
    {
        case CPSS_DROP_MODE_HARD_E:
            packetCommand = CPSS_PACKET_CMD_DROP_HARD_E;
            break;
        case CPSS_DROP_MODE_SOFT_E:
            packetCommand = CPSS_PACKET_CMD_DROP_SOFT_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* convert packet command to HW value */
        PRV_CPSS_CONVERT_PACKET_CMD_TO_HW_VAL_MAC(fieldValue,packetCommand);
    }
    else
    {
        /* convert drop mode to HW value */
        fieldValue = (dropMode == CPSS_DROP_MODE_HARD_E) ? 1 /* hard */ : 0/* soft*/;
    }

    if(packetCommandPtr)
    {
        *packetCommandPtr = packetCommand;
    }

    if(fieldValuePtr)
    {
        *fieldValuePtr = fieldValue;
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChHwHwValueToDropModeAndPacketCommandConvert function
* @endinternal
*
* @brief   convert from HW value : to 'drop mode' and to packet command
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] fieldValue               - HW field value
*
* @param[out] packetCommandPtr         - (pointer to) packet command (can be NULL --> ignored)
* @param[out] dropModePtr              - (pointer to) drop mode (can be NULL --> ignored)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChHwHwValueToDropModeAndPacketCommandConvert
(
    IN GT_U8        devNum,
    IN GT_U32       fieldValue,
    OUT CPSS_PACKET_CMD_ENT     *packetCommandPtr,
    OUT CPSS_DROP_MODE_TYPE_ENT *dropModePtr
)
{
    CPSS_PACKET_CMD_ENT packetCommand;/* packet command */
    CPSS_DROP_MODE_TYPE_ENT dropMode; /* drop mode      */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* convert HW value to packet command */
        PRV_CPSS_CONVERT_HW_VAL_TO_PACKET_CMD_MAC(packetCommand,fieldValue);

        if(packetCommand == CPSS_PACKET_CMD_DROP_HARD_E)
        {
            dropMode = CPSS_DROP_MODE_HARD_E;
        }
        else if(packetCommand == CPSS_PACKET_CMD_DROP_SOFT_E)
        {
            dropMode = CPSS_DROP_MODE_SOFT_E;
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        /* convert HW value to drop mode */
        dropMode = (fieldValue == 1) ?
                CPSS_DROP_MODE_HARD_E :
                CPSS_DROP_MODE_SOFT_E;

        if(fieldValue == 1)
        {
            dropMode = CPSS_DROP_MODE_HARD_E;
            packetCommand = CPSS_PACKET_CMD_DROP_HARD_E;
        }
        else if(fieldValue == 0)
        {
            dropMode = CPSS_DROP_MODE_SOFT_E;
            packetCommand = CPSS_PACKET_CMD_DROP_SOFT_E;
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }

    if(packetCommandPtr)
    {
        *packetCommandPtr = packetCommand;
    }

    if(dropModePtr)
    {
        *dropModePtr = dropMode;
    }

    return GT_OK;
}


/**
* @internal prvCpssDxChHwPpPortToGopConvert function
* @endinternal
*
* @brief   Private (internal) function converts Port number to Group Of Ports number
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] phyPortNum               - physical port number
*
* @param[out] portGroupPtr             - (pointer to) Port Group Number
*                                      for not multi port group devices
*                                      CPSS_PORT_GROUP_UNAWARE_MODE_CNS
* @param[out] gopNumPtr                - (pointer to) Group of Ports Number
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong device number
*/
GT_STATUS prvCpssDxChHwPpPortToGopConvert
(
    IN  GT_U8                        devNum,
    IN  GT_PHYSICAL_PORT_NUM         phyPortNum,
    OUT GT_U32                       *portGroupPtr,
    OUT GT_U32                       *gopNumPtr
)
{
    GT_PHYSICAL_PORT_NUM   localPort; /* local port for multi port group devices */

    *portGroupPtr = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, phyPortNum);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum, phyPortNum);

    switch (PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
            /* Bobcat2 unity has 9 GOPs - 4 serdes in each.       */
            /* There are several possible HW configurations       */
            /* for different port speeds but the range of port    */
            /* numbers for each GOP is single for all of them.    */
            /* For example GOP0 can contain                       */
            /* QSGMI ports 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15  */
            /* or SGMI ports 0,4,8,12.                            */
            /* These are the port ranges in GOPs:                 */
            /* GOP0 port0  - port15                               */
            /* GOP1 port16 - port31                               */
            /* GOP2 port32 - port47                               */
            /* GOP3 port48 - port51                               */
            /* GOP4 port52 - port55                               */
            /* GOP5 port56 - port59                               */
            /* GOP6 port60 - port63                               */
            /* GOP7 port64 - port67                               */
            /* GOP8 port68 - port71                               */
            *gopNumPtr =
                ((localPort < 48)
                    ? (localPort / 16)
                    : (3 + ((localPort - 48) / 4)));
            break;
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
        case CPSS_PP_FAMILY_DXCH_AC3X_E:
            *gopNumPtr = (localPort)/4;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);
    }
    return GT_OK;
}

/**
* @internal egfShtFieldInfoGet function
* @endinternal
*
* @brief   get info about a field to the EGF_SHT table/register that represent the
*         physical port or the eport.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] fieldType                - the field type
* @param[in] accessPhysicalPort       - GT_TRUE : indication if to access to the physical ports registers
*                                      GT_FALSE : access to the ePort table
*
* @param[out] regAddrPtrPtr            - (pointer to) (pointer to) registers addresses
* @param[out] startBitPtr              - (pointer to) start bit index
* @param[out] numBitsPtr               - (pointer to) number of bits for the field
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS   egfShtFieldInfoGet
(
    IN GT_U8                    devNum,
    IN PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ENT  fieldType,
    IN GT_BOOL                  accessPhysicalPort,
    IN GT_U32                   **regAddrPtrPtr,
    IN GT_U32                   *startBitPtr,
    IN GT_U32                   *numBitsPtr
)
{
    GT_U32  *regAddrPtr;/*pointer to register address*/
    GT_U32  numBits;/*number of bits to set*/
    GT_U32  startBit;/*start bit to set */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    numBits = 1;

    if(accessPhysicalPort == GT_FALSE)
    {
        switch(fieldType)
        {
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_STP_STATE_E:
                startBit = 7;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EGRESS_VLAN_FILTER_E:
                startBit = 4;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_UC_SRC_ID_FILTER_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);/* only per physical port */
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_MC_LOCAL_ENABLE_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);/* only per physical port */
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_IGNORE_PHY_SRC_MC_FILTER_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);/* only per physical port */
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_STP_STATE_MODE_E:
                startBit = 8;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ODD_ONLY_SRC_ID_FILTER_ENABLE_E:
                startBit = 9;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ROUTED_FORWARD_RESTRICTED_E:
                startBit = 2;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_IPMC_ROUTED_FILTER_ENABLE_E:
                startBit = 3;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_FROM_CPU_FORWARD_RESTRICTED_E:
                startBit = 0;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_BRIDGED_FORWARD_RESTRICTED_E:
                startBit = 1;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_PORT_ISOLATION_MODE_E:
                /*2 bits per port*/
                numBits = 2;
                startBit = 5;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EGRESS_EPORT_EVLAN_FILTER_ENABLE_E:
                startBit = 10;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_MESH_ID_E:
                /*4 bits per port*/
                numBits = 4;
                startBit = 11;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EPORT_ASSOCIATED_VID1_E:
                /* 12 bits per port */
                numBits = 12;
                startBit = 16;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_DROP_ON_EPORT_VID1_MISMATCH_E:
                startBit = 15;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ASSIGN_EGR_ATTR_LOCAL_E:
                startBit = 28;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        regAddrPtr = NULL;/* not relevant */
    }
    else /*(accessPhysicalPort == GT_TRUE)*/
    {
        switch(fieldType)
        {
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_STP_STATE_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportStpState[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EGRESS_VLAN_FILTER_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportEvlanFilteringEnable[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_UC_SRC_ID_FILTER_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.UCSrcIDFilterEn[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_MC_LOCAL_ENABLE_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.MCLocalEn[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_IGNORE_PHY_SRC_MC_FILTER_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.ignorePhySrcMcFilterEn[0]/*Reg Offset*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_STP_STATE_MODE_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportStpStateMode[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ODD_ONLY_SRC_ID_FILTER_ENABLE_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportOddOnlySrcIdFilterEnable[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ROUTED_FORWARD_RESTRICTED_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportRoutedForwardRestricted[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_IPMC_ROUTED_FILTER_ENABLE_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportIPMCRoutedFilterEn[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_FROM_CPU_FORWARD_RESTRICTED_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportFromCPUForwardRestricted[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_BRIDGED_FORWARD_RESTRICTED_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportBridgedForwardRestricted[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_PORT_ISOLATION_MODE_E:
                /*2 bits per port*/
                numBits = 2;
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportPortIsolationMode[0]/*Port div 16*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_MESH_ID_E:
                numBits = 4;
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.ePortMeshId[0]/*Port div 8*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EGRESS_EPORT_EVLAN_FILTER_ENABLE_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);/* only per EPort */
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EPORT_ASSOCIATED_VID1_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportAssociatedVid1[0]/*Port div 2*/;
                numBits = 12;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_DROP_ON_EPORT_VID1_MISMATCH_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.dropOnEportVid1MismatchEn[0]/*Port div 32*/;
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        startBit = 0;/*will be calculated at the caller */
    }

    *regAddrPtrPtr = regAddrPtr;

    *startBitPtr = startBit;
    *numBitsPtr = numBits;

    return GT_OK;

}

/**
* @internal prvCpssEgfShtCalcStartBit function
* @endinternal
*
* @brief   Calculate an offset (in bits) of a data inside a vector of 32bit words
*         |------------32 bits-------------|--------------32 bits-----------|...
*         |<data0><data1>...<dataN><unused>|<dataN + 1><dataN + 2>..<unused>|...
* @param[in] index                    - an  of a data (is starts from 0)
* @param[in] dataLen                  - the length of the data in bits (can't exceed 32 bits!)
*                                       an offset (first bit number) of the data
*
* @note the dataLen can't be greater than 32
*
*/
static GT_U32 prvCpssEgfShtCalcStartBit
(
    IN GT_PORT_NUM index,
    IN GT_U32      dataLen
)
{
    GT_U32 gapLen;          /* unused bits count at the end of 32bit word */
    GT_U32 numGaps;         /* total number of gaps */
    GT_U32 offset;

    offset = index * dataLen;
    gapLen = 32 % dataLen;
    if (gapLen != 0)
    {
        numGaps = index / (32 / dataLen);
        offset += gapLen * numGaps;
    }
    return offset;
}

/**
* @internal prvCpssDxChHwEgfShtFieldSet function
* @endinternal
*
* @brief   Write a field to the EGF_SHT table/register that represent the
*         physical port and/or the eport.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number (physical port and/or the eport)
* @param[in] fieldType                - the field type
* @param[in] accessPhysicalPort       - indication if to access to the physical ports registers
*                                      relevant only for the portNum < 256
* @param[in] accessEPort              - indication if to access to the EPort table
* @param[in] value                    - the data write to the register and/or table
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS   prvCpssDxChHwEgfShtFieldSet
(
    IN GT_U8                    devNum,
    IN GT_PORT_NUM              portNum,
    IN PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ENT  fieldType,
    IN GT_BOOL                  accessPhysicalPort,
    IN GT_BOOL                  accessEPort,
    IN GT_U32                   value
)
{
    GT_STATUS  rc;
    GT_U32    *regAddrPtr;      /* (pointer to) register address */
    GT_U32     numBits;         /*number of bits to set*/
    GT_U32     startBit;        /*start bit to set */
    GT_BOOL    didWrite = GT_FALSE; /*indication if we did write before finish the function */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    if(accessEPort == GT_TRUE)
    {
        PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

        rc = egfShtFieldInfoGet(devNum,fieldType,
            GT_FALSE,/*accessPhysicalPort*/
            &regAddrPtr,/* not used */
            &startBit,
            &numBits);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(value > BIT_MASK_MAC(numBits))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        rc = prvCpssDxChWriteTableEntryField(devNum,
                   CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_EGRESS_EPORT_E,
                   portNum,
                   PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                   startBit, /* start bit */
                   numBits,  /* num of bits */
                   value);
        if(rc != GT_OK)
        {
            return rc;
        }

        didWrite = GT_TRUE;
    }

    if( (accessPhysicalPort == GT_TRUE) &&
        (portNum < PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum)) )
    {
        rc = egfShtFieldInfoGet(devNum,fieldType,
            GT_TRUE,/*accessPhysicalPort*/
            &regAddrPtr,
            &startBit,
            &numBits);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(regAddrPtr == NULL)
        {
            /*should not happen*/
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }

        if(value > BIT_MASK_MAC(numBits))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        startBit = prvCpssEgfShtCalcStartBit(portNum, numBits);

        rc = prvCpssHwPpSetRegField(devNum,
                 regAddrPtr[OFFSET_TO_WORD_MAC(startBit)],
                 OFFSET_TO_BIT_MAC(startBit) ,
                 numBits,
                 value);
        if(rc != GT_OK)
        {
            return rc;
        }

        didWrite = GT_TRUE;
    }

    if(didWrite == GT_FALSE)
    {
        /* no write access to table / register was done ! */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChHwEgfShtFieldGet function
* @endinternal
*
* @brief   Read a field to the EGF_SHT table/register that represent the
*         physical port or the eport.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number (physical port or the eport)
* @param[in] fieldType                - the field type
* @param[in] accessPhysicalPort       - GT_TRUE : indication if to access to the physical ports registers
*                                      relevant only for the portNum < 256
*                                      GT_FALSE : access to the ePort table
*
* @param[out] valuePtr                 - (pointer to)the data read from the register or table
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS   prvCpssDxChHwEgfShtFieldGet
(
    IN GT_U8                    devNum,
    IN GT_PORT_NUM              portNum,
    IN PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ENT  fieldType,
    IN GT_BOOL                  accessPhysicalPort,
    OUT GT_U32                   *valuePtr
)
{
    GT_STATUS  rc;
    GT_U32    *regAddrPtr;      /* (pointer to) register address */
    GT_U32     numBits;         /*number of bits to set*/
    GT_U32     startBit;        /*start bit to set */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(valuePtr);

    if( (accessPhysicalPort == GT_FALSE) ||
        (portNum >= PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum)) )
    {
        PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

        rc = egfShtFieldInfoGet(devNum,fieldType,
            GT_FALSE,/*accessPhysicalPort*/
            &regAddrPtr,/* not used */
            &startBit,
            &numBits);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssDxChReadTableEntryField(devNum,
                   CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_EGRESS_EPORT_E,
                   portNum,
                   PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                   startBit, /* start bit */
                   numBits,  /* num of bits */
                   valuePtr);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else /*(accessPhysicalPort == GT_TRUE && (portNum < 256))*/
    {
        PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

        rc = egfShtFieldInfoGet(devNum,fieldType,
            GT_TRUE,/*accessPhysicalPort*/
            &regAddrPtr,
            &startBit,
            &numBits);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(regAddrPtr == NULL)
        {
            /*should not happen*/
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }

        startBit = prvCpssEgfShtCalcStartBit(portNum, numBits);

        rc = prvCpssHwPpGetRegField(devNum,
                 regAddrPtr[OFFSET_TO_WORD_MAC(startBit)],
                 OFFSET_TO_BIT_MAC(startBit) ,
                 numBits,
                 valuePtr);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal egfEftFieldInfoGet function
* @endinternal
*
* @brief   get info about a field to the EGF_EFT register that represent the
*         physical port .
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] fieldType                - the field type
*
* @param[out] regAddrPtrPtr            - (pointer to) (pointer to) registers addresses
* @param[out] numBitsPtr               - (pointer to) number of bits for the field
* @param[out] numBitsOffsetBetweenPortsPtr - (pointer to) number of bits between 2 consecutive ports
* @param[out] numPortsInRegisterPtr    - (pointer to) number of ports in register
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS   egfEftFieldInfoGet
(
    IN GT_U8                    devNum,
    IN PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_ENT  fieldType,
    IN GT_U32                   **regAddrPtrPtr,
    IN GT_U32                   *numBitsPtr,
    IN GT_U32                   *numBitsOffsetBetweenPortsPtr,
    IN GT_U32                   *numPortsInRegisterPtr
)
{
    GT_U32  *regAddrPtr;/*pointer to register address*/
    GT_U32  numBits;/*number of bits to set*/
    GT_U32  numBitsOffsetBetweenPorts;/*number of bits between 2 consecutive ports */
    GT_U32  numPortsInRegister;/*number of ports in register*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    numBits = 1;
    numBitsOffsetBetweenPorts = 0xFFFFFFFF;/*indication that was not set yet */
    numPortsInRegister = AUTO_CALC_FIELD_CNS;/*indication that need auto calculation */

    switch(fieldType)
    {
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_MC_FIFO_PORT_TO_MC_FIFO_ATTRIBUTION_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).MCFIFO.MCFIFOConfigs.portToMcFIFOAttributionReg[0]/*reg_offset*/;
            if(!PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                numBits = 2;
            }
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_MC_FIFO_PORT_TO_HEMISPHERE_MAP_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).MCFIFO.MCFIFOConfigs.portToHemisphereMapReg[0]/*reg offset*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_FC_TRIGGER_BY_CN_FRAME_ON_PORT_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.enFCTriggerByCNFrameOnPort[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_CN_FRAME_TX_ON_PORT_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.enCNFrameTxOnPort[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_UNREGED_BC_FILTER_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.unregedBCFilterEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_UNKNOWN_UC_FILTER_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.unknownUCFilterEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_UNREGED_MC_FILTER_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.unregedMCFilterEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_OAM_LOOPBACK_FILTER_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.OAMLoopbackFilterEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_VIRTUAL_2_PHYSICAL_PORT_REMAP_E:
            if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.virtual2PhysicalPortRemap[0]/*offset*/;
            numBits = PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort;
            numBitsOffsetBetweenPorts =  MAX(numBits,8);
            numPortsInRegister = numPortsInRegister;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_PHYSICAL_PORT_LINK_STATUS_MASK_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.physicalPortLinkStatusMask[0]/*reg offset*/;
            numBits = PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? 1 : 2;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_DEV_MAP_TABLE_ADDR_CONSTRUCT_PROFILE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).deviceMapConfigs.devMapTableAddrConstructProfile[0]/*profile_num*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_DEV_MAP_TABLE_LOCAL_SRC_PORT_MAP_OWN_DEV_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).deviceMapConfigs.localSrcPortMapOwnDevEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_DEV_MAP_TABLE_LOCAL_TRG_PORT_MAP_OWN_DEV_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).deviceMapConfigs.localTrgPortMapOwnDevEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_DEV_MAP_TABLE_PORT_ADDR_CONSTRUCT_MODE_ADDRESS_PROFILE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).deviceMapConfigs.portAddrConstructMode[0]/*local physical source port*/;
            numBits = 3;
            numPortsInRegister =  PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? 8 : 1;

            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    *regAddrPtrPtr = regAddrPtr;
    *numBitsPtr = numBits;
    if(numBitsOffsetBetweenPorts != 0xFFFFFFFF)
    {
        *numBitsOffsetBetweenPortsPtr = numBitsOffsetBetweenPorts;
    }
    else
    {
        /*by default this equal the numBits */
        *numBitsOffsetBetweenPortsPtr = numBits;
    }

    if(numPortsInRegister == AUTO_CALC_FIELD_CNS)
    {
        /* auto calc */
        numPortsInRegister = 32 / numBits;
    }

    *numPortsInRegisterPtr = numPortsInRegister;


    return GT_OK;

}

/* flag to allow to see printings of 'EGR_FILTER_PHYSICAL_PORT_LINK_STATUS' manipulations */

GT_STATUS EGR_FILTER_PHYSICAL_PORT_LINK_STATUS_MASK_debug_print_set(IN GT_U32 allowPrint)
{
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.EGR_FILTER_PHYSICAL_PORT_LINK_STATUS_MASK_debug_print) = allowPrint;
    return GT_OK;
}

/**
* @internal prvCpssDxChHwEgfEftFieldSet function
* @endinternal
*
* @brief   Write a field to the EGF_EFT register that represent the
*         physical port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number (physical port)
* @param[in] fieldType                - the field type
* @param[in] value                    - the data write to the register
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS   prvCpssDxChHwEgfEftFieldSet
(
    IN GT_U8                    devNum,
    IN GT_PHYSICAL_PORT_NUM     portNum,
    IN PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_ENT  fieldType,
    IN GT_U32                   value
)
{
    GT_STATUS   rc;
    GT_U32  *regAddrPtr;/* (pointer to) register address */
    GT_U32  numBits;/*number of bits to set*/
    GT_U32  numBitsOffsetBetweenPorts;/*number of bits between 2 consecutive ports */
    GT_U32  numPortsInRegister;/*number of ports in register*/
    GT_U32  wordIndex;/*index in registers array*/
    GT_U32  bitIndex;/*index in the register*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

    if ( DXCH_HWINIT_GLOVAR(dxChHwInitSrc.EGR_FILTER_PHYSICAL_PORT_LINK_STATUS_MASK_debug_print) /*flag to allow debug print*/
       && fieldType == PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_PHYSICAL_PORT_LINK_STATUS_MASK_E)
    {
        /* this filter is crucial for SIP5.20 and above , and we need many times
           to debug it's value and sequence of operations
        */
        cpssOsPrintf("portNum [%d] set EGF link filter value [%d]\n",
            portNum,value);
    }

    rc = egfEftFieldInfoGet(devNum,fieldType,
        &regAddrPtr,
        &numBits,
        &numBitsOffsetBetweenPorts,
        &numPortsInRegister);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(regAddrPtr == NULL)
    {
        /*should not happen*/
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    if(value > BIT_MASK_MAC(numBits))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    wordIndex = (portNum / numPortsInRegister);
    bitIndex  = (portNum % numPortsInRegister) * numBitsOffsetBetweenPorts;

    rc = prvCpssHwPpSetRegField(devNum,
             regAddrPtr[wordIndex],
             bitIndex ,
             numBits,
             value);

    return rc;
}

/**
* @internal prvCpssDxChHwEgfEftFieldGet function
* @endinternal
*
* @brief   Read a field from the EGF_EFT register that represent the
*         physical port.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portNum                  - the port number (physical port)
* @param[in] fieldType                - the field type
*
* @param[out] valuePtr                 - (pointer to)the data read from the register
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS   prvCpssDxChHwEgfEftFieldGet
(
    IN GT_U8                    devNum,
    IN GT_PHYSICAL_PORT_NUM     portNum,
    IN PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_ENT  fieldType,
    OUT GT_U32                   *valuePtr
)
{
    GT_STATUS   rc;
    GT_U32  *regAddrPtr;/* (pointer to) register address */
    GT_U32  numBits;/*number of bits to set*/
    GT_U32  numBitsOffsetBetweenPorts;/*number of bits between 2 consecutive ports */
    GT_U32  numPortsInRegister;/*number of ports in register*/
    GT_U32  wordIndex;/*index in registers array*/
    GT_U32  bitIndex;/*index in the register*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(valuePtr);

    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

    rc = egfEftFieldInfoGet(devNum,fieldType,
        &regAddrPtr,
        &numBits,
        &numBitsOffsetBetweenPorts,
        &numPortsInRegister);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(regAddrPtr == NULL)
    {
        /*should not happen*/
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    wordIndex = (portNum / numPortsInRegister);
    bitIndex  = (portNum % numPortsInRegister) * numBitsOffsetBetweenPorts;

    rc = prvCpssHwPpGetRegField(devNum,
             regAddrPtr[wordIndex],
             bitIndex ,
             numBits,
             valuePtr);

    return rc;
}

/* function to check EGF_SHT 'bmp of ports' support
    and get special behavior for each one
*/
static GT_STATUS egfShtPortsBmpTableSupportGet
(
    IN GT_U8               devNum,
    IN CPSS_DXCH_TABLE_ENT tableType,
    OUT GT_U32 *prvMcRelayPortsBmp_neededPtr,
    OUT GT_BOOL *checkPhysicalPortPtr
)
{
    GT_U32 prvMcRelayPortsBmp_needed = 0;
    GT_BOOL checkPhysicalPort   = GT_FALSE;

    switch(tableType)
    {
        case CPSS_DXCH_LION_TABLE_PORT_ISOLATION_L2_E:
        case CPSS_DXCH_LION_TABLE_PORT_ISOLATION_L3_E:
            prvMcRelayPortsBmp_needed = 1;
            break;
        case CPSS_DXCH_LION_TABLE_TXQ_SOURCE_ID_MEMBERS_E:
            checkPhysicalPort = GT_TRUE;
            break;
        case CPSS_DXCH_LION_TABLE_TXQ_NON_TRUNK_MEMBERS_E:
        case CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_NON_TRUNK_MEMBERS2_E:
        case CPSS_DXCH_LION_TABLE_TXQ_DESIGNATED_PORT_E  :
            break;
        case CPSS_DXCH_TABLE_MULTICAST_E                 :
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
            {
                /* complex CPU port issues that not changed from original code */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            }
            break;
        case CPSS_DXCH_LION_TABLE_STG_EGRESS_E           :
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
            {
                /* the egress STP is 2 bits per port (not 1) */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            }
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(prvMcRelayPortsBmp_neededPtr)
    {
        *prvMcRelayPortsBmp_neededPtr = prvMcRelayPortsBmp_needed;
    }

    if(checkPhysicalPortPtr)
    {
        *checkPhysicalPortPtr = checkPhysicalPort;
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChHwEgfShtPortsBmpTableEntryWrite function
* @endinternal
*
* @brief   Write a whole entry to the table. - for 'bmp of ports' - EGF_SHT tables
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] tableType                - the specific table name
*                                      entryIndex   - index in the table
* @param[in] portsMembersPtr          - (pointer to) the bmp of ports that will be written to
*                                      the table.
* @param[in] isCpuMember              - indication if to use 'isCpuMember'
* @param[in] isCpuMember              - indication to add the CPU port to the BMP of ports
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChHwEgfShtPortsBmpTableEntryWrite
(
    IN GT_U8               devNum,
    IN CPSS_DXCH_TABLE_ENT tableType,
    IN GT_U32               tableIndex,
    IN CPSS_PORTS_BMP_STC  *portsMembersPtr,
    IN GT_BOOL              isCpuMember_supported,
    IN GT_BOOL              isCpuMember
)
{
    GT_U32      hwValueArr[EGF_SHT_MAX_PORTS_BMP_NUM_CNS];/* 16 words to support 512 ports */
    GT_STATUS   rc;         /* return value*/
    GT_U32      ii;          /* iterator */
    GT_U32      iiMax;       /* max iterator value */
    GT_U32      prvMcRelayPortsBmp_needed;/*do we need to add the relay ports */
    GT_U32      prvMcRelayPortsBmp; /* special port <12+16*n> bitmap */
    GT_U32      portGroupId;/* port group Id */
    GT_U32      wordIndexInBmp;/* word index in hwValueArr[]*/

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    rc = egfShtPortsBmpTableSupportGet(devNum,tableType,&prvMcRelayPortsBmp_needed,NULL);
    if(rc != GT_OK)
    {
        return rc;
    }


    iiMax = 4;/*support 128 ports */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* no relay port issues */
        prvMcRelayPortsBmp = 0;
        iiMax = MAX(8,(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts/32));
    }
    else
    if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_2_MAC(devNum))
    {
        /* port <12 + 16*n> is used for MC relay to adjacent hemisphere */
        prvMcRelayPortsBmp = PRV_MC_RELAY_PORTS_BMP_CNS;
    }
    else
    {
        prvMcRelayPortsBmp = 0;
    }

    if(prvMcRelayPortsBmp_needed == 0)
    {
        /* THE RELAY PORTS BMP NOT NEEDED*/
        prvMcRelayPortsBmp = 0;
    }

    for(ii = 0 ; ii < iiMax ; ii++)
    {
        hwValueArr[ii] =  portsMembersPtr->ports[ii] | prvMcRelayPortsBmp;
    }

    if(isCpuMember_supported == GT_TRUE)
    {
        if(BOOL2BIT_MAC(isCpuMember))
        {
            /*emulate CPU port as bit 63 */
            U32_SET_FIELD_IN_ENTRY_MAC(hwValueArr,63,1,1);
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* no hemispheres issues , all port groups get the same value */
        rc = prvCpssDxChWriteTableEntry(devNum,
                                    tableType,
                                    tableIndex,
                                    &hwValueArr[0]);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        iiMax = PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_MAC(devNum);

        /* loop on all TXQ units */
        for (ii = 0; ii < iiMax; ii++)
        {
            /* each hemisphere get it's relevant section of the ports */
            portGroupId    = ii*PRV_CPSS_DXCH_PORT_GROUPS_NUM_IN_HEMISPHERE_CNS;
            wordIndexInBmp = 2 * ii;/* 64 ports are in 2 words */

            rc = prvCpssDxChPortGroupWriteTableEntry(devNum,portGroupId,
                                        tableType,
                                        tableIndex,
                                        &hwValueArr[wordIndexInBmp]);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChHwEgfShtPortsBmpTableEntryRead function
* @endinternal
*
* @brief   Read a whole entry of the table. - for 'bmp of ports' - EGF_SHT tables
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] tableType                - the specific table name
*                                      entryIndex   - index in the table
* @param[in] isCpuMember_supported    - indication if to use 'isCpuMemberPtr'
*
* @param[out] portsMembersPtr          - (pointer to) the bmp of ports that will be written to
*                                      the table.
* @param[out] isCpuMemberPtr           - (pointer to) indication to add the CPU port to the BMP of ports
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChHwEgfShtPortsBmpTableEntryRead
(
    IN GT_U8               devNum,
    IN CPSS_DXCH_TABLE_ENT tableType,
    IN GT_U32               tableIndex,
    OUT CPSS_PORTS_BMP_STC  *portsMembersPtr,
    IN GT_BOOL              isCpuMember_supported,
    OUT GT_BOOL              *isCpuMemberPtr
)
{
    GT_U32      hwValueArr[EGF_SHT_MAX_PORTS_BMP_NUM_CNS];/* 16 words to support 512 ports */
    GT_STATUS   rc;         /* return value*/
    GT_U32      ii;          /* iterator */
    GT_U32      iiMax;       /* max iterator value */
    GT_U32      prvMcRelayPortsBmp_needed;/*do we need to add the relay ports */
    GT_U32      prvMcRelayPortsBmp; /* special port <12+16*n> bitmap */
    GT_U32      portGroupId;/* port group Id */
    GT_U32      wordIndexInBmp;/* word index in hwValueArr[]*/
    GT_U32      tmpValue;

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    rc = egfShtPortsBmpTableSupportGet(devNum,tableType,&prvMcRelayPortsBmp_needed,NULL);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* no hemispheres issues , all port groups get the same value */
        rc = prvCpssDxChReadTableEntry(devNum,
                        tableType,
                        tableIndex,
                        &hwValueArr[0]);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        iiMax = PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_MAC(devNum);

        if (iiMax == 0)
        {
            /* something is wrong */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }

        /* loop on all TXQ units */
        for (ii = 0; ii < iiMax; ii++)
        {
            /* each hemisphere get it's relevant section of the ports */
            portGroupId = ii*PRV_CPSS_DXCH_PORT_GROUPS_NUM_IN_HEMISPHERE_CNS;
            wordIndexInBmp = 2 * ii;/* 64 ports are in steps of 2 words */

            rc = prvCpssDxChPortGroupReadTableEntry(devNum,portGroupId,
                            tableType,
                            tableIndex,
                            &hwValueArr[wordIndexInBmp]);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* no relay port issues */
        prvMcRelayPortsBmp = 0;
        /* support minimum 256 ports */
        iiMax = MAX(8,(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts/32));
    }
    else
    if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_2_MAC(devNum))
    {
        /* port <12 + 16*n> is used for MC relay to adjacent hemisphere */
        prvMcRelayPortsBmp = PRV_MC_RELAY_PORTS_BMP_CNS;
        iiMax = 4;/*support 128 ports */
    }
    else /* single hemisphere */
    {
        prvMcRelayPortsBmp = 0;
        iiMax = 2;/* have only 64 ports to use --
                    also remove the issue of 'parity bit' in word 2 !!! */
    }

    if(prvMcRelayPortsBmp_needed == 0)
    {
        /* THE RELAY PORTS BMP NOT NEEDED*/
        prvMcRelayPortsBmp = 0;
    }

    for(ii = 0 ; ii < iiMax ; ii++)
    {
        portsMembersPtr->ports[ii] = hwValueArr[ii]  & (~prvMcRelayPortsBmp);
    }

    for(/*continue*/ ; ii < CPSS_MAX_PORTS_BMP_NUM_CNS ; ii++)
    {
        /* reset the other words */
        portsMembersPtr->ports[ii] = 0;
    }

    if(isCpuMember_supported)
    {
        /* get the CPU port as bit in BMP */
        U32_GET_FIELD_IN_ENTRY_MAC(portsMembersPtr->ports,63,1,tmpValue);
        *isCpuMemberPtr = BIT2BOOL_MAC(tmpValue);

        /* reset the CPU port as bit in BMP */
        U32_SET_FIELD_IN_ENTRY_MAC(portsMembersPtr->ports,63,1,0);
    }

    return GT_OK;
}


/**
* @internal prvCpssDxChHwEgfShtPortsBmpTableEntrySetPort function
* @endinternal
*
* @brief   set (enable/disable) single port (bit index) in entry to the table. - for 'bmp of ports' - EGF_SHT tables
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] tableType                - the specific table name
*                                      entryIndex   - index in the table
* @param[in] portNum                  - the port number
* @param[in] enable                   - enable/disable the port in the entry
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChHwEgfShtPortsBmpTableEntrySetPort
(
    IN GT_U8               devNum,
    IN CPSS_DXCH_TABLE_ENT tableType,
    IN GT_U32               tableIndex,
    IN GT_U32               portNum,
    IN GT_BOOL              enable
)
{
    GT_STATUS   rc;         /* return value*/
    GT_U32      portGroupId;/* port group Id */
    GT_U32      data;
    GT_BOOL     checkPhysicalPort;/*indication to check physical port / cpu port */

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    data = BOOL2BIT_MAC(enable);

    rc = egfShtPortsBmpTableSupportGet(devNum,tableType,NULL,&checkPhysicalPort);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

        /* all port groups get the same value */
        portGroupId = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
    }
    else
    {
        if(checkPhysicalPort == GT_TRUE)
        {
            PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum,portNum);
        }

        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum,portNum);
        portNum = PRV_CPSS_DXCH_GLOBAL_TO_HEM_LOCAL_PORT(devNum,portNum);

        /* check port */
        if(portNum > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_PHY_PORT_MAC(devNum))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    rc = prvCpssDxChPortGroupWriteTableEntryField(devNum, portGroupId,
                                    tableType,
                                    tableIndex,
                                    PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                    portNum,
                                    1,
                                    data);

    return rc;
}


/**
* @internal prvCpssDxChHwHaTunnelStartArpNatTableEntryWrite function
* @endinternal
*
* @brief   Write a whole entry to the table. HA memory of 'TunnelStart/ARP/NAT(for NAT capable devices)'
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupId              - the port group Id , to support multi-port-group devices that need to access
*                                      specific port group
* @param[in] entryType                - entry type (arp/TS/TS_double)
* @param[in] tableIndex               - index in the table.
*                                      the ratio is 4 ARP per 1 TS ('regular')
*                                      so for 1K TS the indexes are:
*                                      for ARP : (APPLICABLE RANGES: 0,1,2,3,4..(4K-1))
*                                      for TS  : (APPLICABLE RANGES: 0,1,2,3,4..(1K-1))
*                                      for TS_double : (APPLICABLE RANGES: 0,2,4,6,8..(1K-2))
*                                      for NAT: (APPLICABLE RANGES: 0,1,2,3,4..(1K-1))
*                                      NOTE: the 'double' TS must use only 'even' indexes (0,2,4,6,...)
* @param[in] entryValuePtr            - (pointer to) the data that will be written to the table
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChHwHaTunnelStartArpNatTableEntryWrite
(
    IN GT_U8                                        devNum,
    IN GT_U32                                       portGroupId,
    IN PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_ENT   entryType,
    IN GT_U32                                       tableIndex,
    IN GT_U32                                       *entryValuePtr
)
{
    GT_STATUS   rc;
    GT_U32      entryBuf[12];/* 12 words supports the 384 bits for 'double' TS */
    GT_U32      maskBuf[12]; /* 12 words supports the 384 bits for 'double' TS */
    CPSS_DXCH_TABLE_ENT  tableType = CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E;
    GT_U32      entryIsPartOfLine;/* indication occupies only part of full HW line in the table */
    GT_U32      memoryLineIndex;/* index into the actual memory*/
    GT_U32      actualStartBitInMemoryLine;/* the bit index of the data in the memory line */
    GT_U32      numberOfBitsInEntry;/*number of bits in the entry*/
    GT_U32      currentNumBitsToUpdate;/*current number of bits to update */
    GT_U32      currentStartBitToUpdate;/*current start bit to update */
    GT_U32      wordIndex;/*index in entryValuePtr*/

    switch(entryType)
    {
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_ARP_E:
            entryIsPartOfLine = 1;/* not full memory line*/
            numberOfBitsInEntry = 48;

            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                memoryLineIndex = tableIndex >> 3;/* /8 */
                actualStartBitInMemoryLine = (tableIndex & 7) * numberOfBitsInEntry;
            }
            else
            {
                memoryLineIndex = tableIndex >> 2;/* /4 */
                actualStartBitInMemoryLine = (tableIndex & 3) * numberOfBitsInEntry;
            }
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_TUNNEL_START_REGULAR_E:
            numberOfBitsInEntry = 192;

            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                memoryLineIndex = tableIndex >> 1;/* /2 */
                entryIsPartOfLine = 1;/* not full memory line*/
                actualStartBitInMemoryLine = (tableIndex & 1) * numberOfBitsInEntry;/*start at bit 0 or 192 */
            }
            else
            {
                memoryLineIndex = tableIndex;
                entryIsPartOfLine = 0;/* full memory line */
                actualStartBitInMemoryLine = 0;/*start at bit 0*/
            }
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_TUNNEL_START_DOUBLE_E:
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, "The TS 'double' entries (IPv6) not supported by the device" );
            }

            if(tableIndex & 1)
            {
                /* the 'double TS' must start only at 'even' entries */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "The TS 'double' entries (IPv6) must start at even index , but got odd Index[%d] " ,
                    tableIndex);
            }

            numberOfBitsInEntry = 384;

            /* the 'double' TS index was given by the application with the same
               indexing method as 'regular' TS*/

            memoryLineIndex = tableIndex >> 1;/* /2 */
            entryIsPartOfLine = 0;/* full memory line */
            actualStartBitInMemoryLine = 0;/*start at bit 0*/
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_NAT_E:
            numberOfBitsInEntry = 192;
            memoryLineIndex = tableIndex >> 1;/* /2 */
            entryIsPartOfLine = 1;/* not full memory line*/
            actualStartBitInMemoryLine = (tableIndex & 1) * numberOfBitsInEntry;/*start at bit 0 or 192 */
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(entryIsPartOfLine)
    {
        currentNumBitsToUpdate = numberOfBitsInEntry;
        currentStartBitToUpdate = actualStartBitInMemoryLine;

        for(currentNumBitsToUpdate = numberOfBitsInEntry ,
            currentStartBitToUpdate = actualStartBitInMemoryLine,
            wordIndex = 0;

            currentNumBitsToUpdate > 32 ;

            currentNumBitsToUpdate -= 32,
            currentStartBitToUpdate += 32,
            wordIndex++)
        {
            /* update the next word from the entry */
            U32_SET_FIELD_IN_ENTRY_MAC(entryBuf,
                currentStartBitToUpdate,
                32,
                entryValuePtr[wordIndex]);
        }

        /* update the last word from the entry */
        U32_SET_FIELD_IN_ENTRY_MAC(entryBuf,
                currentStartBitToUpdate,
                currentNumBitsToUpdate,
                entryValuePtr[wordIndex]);

        cpssOsMemSet(maskBuf, 0, sizeof(maskBuf));
        raiseBitsInMemory(maskBuf, actualStartBitInMemoryLine, numberOfBitsInEntry);

        /* write the entry */
        rc = prvCpssDxChPortGroupWriteTableEntryMasked(devNum,portGroupId,tableType,memoryLineIndex,entryBuf, maskBuf);
    }
    else
    {
        /* write the entry */
        rc = prvCpssDxChPortGroupWriteTableEntry(devNum,portGroupId,tableType,memoryLineIndex,entryValuePtr);
    }


    return rc;
}


/**
* @internal prvCpssDxChHwHaTunnelStartArpNatTableEntryRead function
* @endinternal
*
* @brief   Read a whole entry from the table. HA memory of 'TunnelStart/ARP/NAT(for NAT capable devices)'
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupId              - the port group Id , to support multi-port-group devices that need to access
*                                      specific port group
* @param[in] entryType                - entry type (arp/TS/TS_double)
* @param[in] tableIndex               - index in the table.
*                                      the ratio is 4 ARP per 1 TS ('regular')
*                                      so for 1K TS the indexes are:
*                                      for ARP : (APPLICABLE RANGES: 0,1,2,3,4..(4K-1))
*                                      for TS  : (APPLICABLE RANGES: 0,1,2,3,4..(1K-1))
*                                      for TS_double : (APPLICABLE RANGES: 0,2,4,6,8..(1K-2))
*                                      for NAT: (APPLICABLE RANGES: 0,1,2,3,4..(1K-1))
*                                      NOTE: the 'double' TS must use only 'even' indexes (0,2,4,6,...)
*
* @param[out] entryValuePtr            - (pointer to) the data that will be read from the table
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChHwHaTunnelStartArpNatTableEntryRead
(
    IN GT_U8                                        devNum,
    IN GT_U32                                       portGroupId,
    IN PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_ENT   entryType,
    IN GT_U32                                       tableIndex,
    OUT GT_U32                                      *entryValuePtr
)
{
    GT_STATUS   rc;
    GT_U32      readMemoryArr[12];/* 12 words supports the 384 bits for 'double' TS */
    CPSS_DXCH_TABLE_ENT  tableType = CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E;
    GT_U32      memoryLineIndex;/* index into the actual memory*/
    GT_U32      actualStartBitInMemoryLine;/* the bit index of the data in the memory line */
    GT_U32      numberOfBitsInEntry;/*number of bits in the entry*/
    GT_U32      currentNumBitsToUpdate;/*current number of bits to update */
    GT_U32      currentStartBitToUpdate;/*current start bit to update */
    GT_U32      wordIndex;/*index in entryValuePtr*/

    switch(entryType)
    {
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_ARP_E:
            numberOfBitsInEntry = 48;

            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                memoryLineIndex = tableIndex >> 3;/* /8 */
                actualStartBitInMemoryLine = (tableIndex & 7) * numberOfBitsInEntry;
            }
            else
            {
                memoryLineIndex = tableIndex >> 2;/* /4 */
                actualStartBitInMemoryLine = (tableIndex & 3) * numberOfBitsInEntry;
            }
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_TUNNEL_START_REGULAR_E:
            numberOfBitsInEntry = 192;

            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                memoryLineIndex = tableIndex >> 1;/* /2 */
                actualStartBitInMemoryLine = (tableIndex & 1) * numberOfBitsInEntry;/*start at bit 0 or 192 */
            }
            else
            {
                memoryLineIndex = tableIndex;
                actualStartBitInMemoryLine = 0;/*start at bit 0*/
            }
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_TUNNEL_START_DOUBLE_E:
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, "The TS 'double' entries (IPv6) not supported by the device" );
            }

            if(tableIndex & 1)
            {
                /* the 'double TS' must start only at 'even' entries */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "The TS 'double' entries (IPv6) must start at even index , but got odd Index[%d] " ,
                    tableIndex);
            }

            numberOfBitsInEntry = 384;

            /* the 'double' TS index was given by the application with the same
               indexing method as 'regular' TS*/

            memoryLineIndex = tableIndex >> 1;/* /2 */
            actualStartBitInMemoryLine = 0;/*start at bit 0*/
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_NAT_E:
            numberOfBitsInEntry = 192;
            memoryLineIndex = tableIndex >> 1;/* /2 */
            actualStartBitInMemoryLine = (tableIndex & 1) * numberOfBitsInEntry;/*start at bit 0 or 192 */
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* read the entry */
    rc = prvCpssDxChPortGroupReadTableEntry(devNum,portGroupId,tableType,memoryLineIndex,readMemoryArr);
    if(rc != GT_OK)
    {
        return rc;
    }

    currentNumBitsToUpdate = numberOfBitsInEntry;
    currentStartBitToUpdate = actualStartBitInMemoryLine;

    for(    currentNumBitsToUpdate = numberOfBitsInEntry ,
            currentStartBitToUpdate = actualStartBitInMemoryLine,
            wordIndex = 0;

        currentNumBitsToUpdate > 32 ;

            currentNumBitsToUpdate -= 32,
            currentStartBitToUpdate += 32,
            wordIndex++)
    {
        /* get the next word for the entry */
        U32_GET_FIELD_IN_ENTRY_MAC(readMemoryArr,
            currentStartBitToUpdate,
            32,
            entryValuePtr[wordIndex]);
    }

    /* get the last word for the entry */
    U32_GET_FIELD_IN_ENTRY_MAC(readMemoryArr,
            currentStartBitToUpdate,
            currentNumBitsToUpdate,
            entryValuePtr[wordIndex]);


    return GT_OK;
}

/**
* @internal internal_cpssDxChHwInitLion2GeBackwardCompatibility function
* @endinternal
*
* @brief   Init parameters of serdes initialization for 1.25G frequncy accordingly to
*         HWS version 43. Proposed for Lion2 B0 only.
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Must be call before cpssDxChHwPpPhase1Init.
*
*/
static GT_VOID internal_cpssDxChHwInitLion2GeBackwardCompatibility
(
    GT_VOID
)
{
    /* this function supposed to run too early to check device validity */
    hwsChange1GSpeedCfgV43();

    return;
}

/**
* @internal cpssDxChHwInitLion2GeBackwardCompatibility function
* @endinternal
*
* @brief   Init parameters of serdes initialization for 1.25G frequncy accordingly to
*         HWS version 43. Proposed for Lion2 B0 only.
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Must be call before cpssDxChHwPpPhase1Init.
*
*/
GT_VOID cpssDxChHwInitLion2GeBackwardCompatibility
(
    GT_VOID
)
{
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwInitLion2GeBackwardCompatibility);

    CPSS_API_LOCK_DEVICELESS_NO_RETURN_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId));

    internal_cpssDxChHwInitLion2GeBackwardCompatibility();

    CPSS_API_UNLOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
}

/**
* @internal internal_cpssDxChHwPpAddressDecodeWindowConfigSet function
* @endinternal
*
* @brief   This function perfroms the address decoding window configuration.
*         If a window is enabled and an address driven by one the PP's units hit the window,
*         the window's configuration applied on this address access.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] windowNumber             - window number (APPLICABLE RANGES: 0..5).
* @param[in] windowConfigPtr          - window's configuration.
*                                       GT_OK on success, or
*                                       GT_FAIL otherwise.
*
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, window size or window base address
* @retval GT_NOT_SUPPORTED         - if this feature not supported by the device.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwPpAddressDecodeWindowConfigSet
(
    IN  GT_U8                                     devNum,
    IN  GT_U32                                    windowNumber,
    IN  CPSS_DXCH_ADDR_DECODE_WINDOW_CONFIG_STC  *windowConfigPtr
)
{
   GT_STATUS rc;        /* return code */
   GT_U32    regAddr;   /* register address */
   GT_U32    regData;   /* register data */
   GT_U32    offset;    /* data offset within register */

   PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
   PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E
                                         | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
   CPSS_NULL_PTR_CHECK_MAC(windowConfigPtr);

   if(windowNumber>5)
   {
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
   }

   if(windowConfigPtr->enableWindow == GT_TRUE)
   {
     /* Validate window size is a power of 2 */
     if((windowConfigPtr->windowSize ==0) || (windowConfigPtr->windowSize > _64K) || /* can't be 0 or above 64K */
        (((windowConfigPtr->windowSize-1) & (windowConfigPtr->windowSize)) !=0 )) /* Power of 2 - only one bit set */
     {
       CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
     }

     /* Validate window base address is in resolution of window size.  */
     if(windowConfigPtr->baseAddress % windowConfigPtr->windowSize)
     {
       CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
     }

     /* Disable window before changing settings. */
     if( PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
     {
         regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[windowNumber];
         offset = 0;
     }
     else /* xCat2 */
     {
         regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[0];
         offset = windowNumber;
     }

     rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, 1, 1);
     if (rc != GT_OK)
     {
         return rc;
     }

     /* Target Unit PCI, Memory access */
     regData = 0x804;
     if( !PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
     {
         regData |= 0xE000;
     }

     regData |= windowConfigPtr->baseAddress&0xFFFF0000; /* Bits 0-15 are 0 */

     /* Set window attribute */
     regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddress[windowNumber];
     rc = prvCpssHwPpWriteRegister(devNum, regAddr, regData);
     if (rc != GT_OK)
     {
       return rc;
     }

     /* Set window size */
     /* This field must be programmed from LSB to MSB as sequence of 1s followed by sequence of 0s.
             The size of the window is (windowConfigPtr->windowSiz + 1) * 64K.
             e.g. configure value of 0x003F specifies 64x64k = 4 MB*/
     regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.windowSize[windowNumber];
     rc = prvCpssHwPpWriteRegister(devNum, regAddr, (windowConfigPtr->windowSize-1)<<16);
     if (rc != GT_OK)
     {
       return rc;
     }

     /* Set high address remap value. */
     if(windowNumber < 4)
     {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.highAddressRemap[windowNumber];
       rc = prvCpssHwPpWriteRegister(devNum, regAddr, windowConfigPtr->remapAddress);
       if (rc != GT_OK)
       {
         return rc;
       }
     }

     /* Set window Access Protect mode - full access read and write */
     if( PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
     {
         regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[windowNumber];
         offset = 1;
     }
     else /* xCat2 */
     {
         regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.accessProtect;
         offset = 2*windowNumber;
     }

     rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, 2, 0x3);
     if (rc != GT_OK)
     {
       return rc;
     }
   }

   /* Window enable only after validating and setting all other configuration. */
   regData = (windowConfigPtr->enableWindow)? 0:1;
   if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[windowNumber];
       offset = 0;
   }
   else /* xCat2 */
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[0];
       offset = windowNumber;
   }

   rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, 1, regData);
   if (rc != GT_OK)
   {
       return rc;
   }

   return GT_OK;
}

/**
* @internal cpssDxChHwPpAddressDecodeWindowConfigSet function
* @endinternal
*
* @brief   This function perfroms the address decoding window configuration.
*         If a window is enabled and an address driven by one the PP's units hit the window,
*         the window's configuration applied on this address access.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] windowNumber             - window number (APPLICABLE RANGES: 0..5).
* @param[in] windowConfigPtr          - window's configuration.
*                                       GT_OK on success, or
*                                       GT_FAIL otherwise.
*
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, window size or window base address
* @retval GT_NOT_SUPPORTED         - if this feature not supported by the device.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwPpAddressDecodeWindowConfigSet
(
    IN  GT_U8                                     devNum,
    IN  GT_U32                                    windowNumber,
    IN  CPSS_DXCH_ADDR_DECODE_WINDOW_CONFIG_STC  *windowConfigPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpAddressDecodeWindowConfigSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, windowNumber, windowConfigPtr));

    rc = internal_cpssDxChHwPpAddressDecodeWindowConfigSet(devNum, windowNumber, windowConfigPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, windowNumber, windowConfigPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChHwPpAddressDecodeWindowConfigGet function
* @endinternal
*
* @brief   This function returns the address decoding window configuration.
*         If a window is enabled and an address driven by one the PP's units hit the window,
*         the window's configuration applied on this address access.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] windowNumber             - window number (APPLICABLE RANGES: 0..5).
*
* @param[out] windowConfigPtr          - window's configuration.
*                                       GT_OK on success, or
*                                       GT_FAIL otherwise.
*
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, window size or window base address
* @retval GT_BAD_STATE             - get illegal value from HW.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwPpAddressDecodeWindowConfigGet
(
    IN  GT_U8                                     devNum,
    IN  GT_U32                                    windowNumber,
    OUT CPSS_DXCH_ADDR_DECODE_WINDOW_CONFIG_STC  *windowConfigPtr
)
{
   GT_STATUS rc;            /* return code */
   GT_U32    regAddr;       /* register address */
   GT_U32    regData;       /* register data */
   GT_U32    offset;        /* data offset within register */
   GT_U32    attributes;    /* unit attributes*/

   PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
   PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E
                                         | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
   CPSS_NULL_PTR_CHECK_MAC(windowConfigPtr);

   if(windowNumber>5)
   {
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
   }

   /* Window enable */
   if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[windowNumber];
       offset = 0;
   }
   else /* xCat2 */
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[0];
       offset = windowNumber;
   }

   rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 1, &regData);
   if (rc != GT_OK)
   {
       return rc;
   }

   windowConfigPtr->enableWindow = (regData == 0) ? GT_TRUE : GT_FALSE;


   /* Get window attributes, base address and target id */
   regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddress[windowNumber];
   rc = prvCpssHwPpReadRegister(devNum, regAddr, &regData);
   if (rc != GT_OK)
   {
       return rc;
   }

   attributes = regData & 0xFFFF;
   if((windowConfigPtr->enableWindow == GT_TRUE) &&
      ((PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum)  && attributes != 0x804) ||
       (!PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum) && attributes != 0xE804)))
   {
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
   }

   windowConfigPtr->baseAddress = regData & 0xFFFF0000; /* get bits 16-31. */


   /* Get window size */
   /* This field must be programmed from LSB to MSB as sequence of 1s followed by sequence of 0s.
           The size of the window is (windowConfigPtr->windowSiz + 1) * 64K.
           e.g. configure value of 0x003F specifies 64x64k = 4 MB*/
   regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.windowSize[windowNumber];
   rc = prvCpssHwPpReadRegister(devNum, regAddr, &regData);
   if (rc != GT_OK)
   {
       return rc;
   }
   windowConfigPtr->windowSize = (regData >> 16) + 1;


   /* Get high address remap value. */
   if(windowNumber < 4)
   {
     regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.highAddressRemap[windowNumber];
     rc = prvCpssHwPpReadRegister(devNum, regAddr, &(windowConfigPtr->remapAddress));
     if (rc != GT_OK)
     {
       return rc;
     }
   }

   /* Get window Access Protect mode */
   if( PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[windowNumber];
       offset = 1;
   }
   else /* xCat2 */
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.accessProtect;
       offset = 2*windowNumber;
   }

   rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 2, &regData);
   if (rc != GT_OK)
   {
       return rc;
   }

   if((windowConfigPtr->enableWindow == GT_TRUE) && (regData != 3))
   {
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
   }

   return GT_OK;
}

/**
* @internal cpssDxChHwPpAddressDecodeWindowConfigGet function
* @endinternal
*
* @brief   This function returns the address decoding window configuration.
*         If a window is enabled and an address driven by one the PP's units hit the window,
*         the window's configuration applied on this address access.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] windowNumber             - window number (APPLICABLE RANGES: 0..5).
*
* @param[out] windowConfigPtr          - window's configuration.
*                                       GT_OK on success, or
*                                       GT_FAIL otherwise.
*
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong devNum, window size or window base address
* @retval GT_BAD_STATE             - get illegal value from HW.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChHwPpAddressDecodeWindowConfigGet
(
    IN  GT_U8                                     devNum,
    IN  GT_U32                                    windowNumber,
    OUT CPSS_DXCH_ADDR_DECODE_WINDOW_CONFIG_STC  *windowConfigPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpAddressDecodeWindowConfigGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, windowNumber, windowConfigPtr));

    rc = internal_cpssDxChHwPpAddressDecodeWindowConfigGet(devNum, windowNumber, windowConfigPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, windowNumber, windowConfigPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


#ifdef DEBUG_OPENED
/**
* @internal prvCpssDxChPrintFineTuningDebugInfo function
* @endinternal
*
* @brief   DxCh prints information about Packet processor , fine tuning values
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - PP's device number .
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - invalid devNum
*/
GT_STATUS prvCpssDxChPrintFineTuningDebugInfo
(
    IN GT_U8                    devNum
)
{
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr;
    PRV_CPSS_DXCH_PP_HW_INFO_STC            *ppHwInfoPtr;
    PRV_CPSS_GEN_PP_CONFIG_STC *devInfoPtr = PRV_CPSS_PP_MAC(devNum);
    PRV_CPSS_DXCH_PP_CONFIG_STC *dxChDevInfoPtr = PRV_CPSS_DXCH_PP_MAC(devNum);

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    fineTuningPtr = &dxChDevInfoPtr->fineTuning;
    ppHwInfoPtr = &dxChDevInfoPtr->hwInfo;

    DUMP_PRINT_MAC((" devNum = [%d] \n",devInfoPtr->devNum));
    DUMP_PRINT_MAC((" devType = [0x%8.8x] \n",devInfoPtr->devType));
    DUMP_PRINT_MAC((" revision = [%d] \n",devInfoPtr->revision));
#define STR_FOR_FAMILY(family) devInfoPtr->devFamily == family  ? #family :
    DUMP_PRINT_MAC((" devFamily = [%s] \n",
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_XCAT3_E        )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_AC5_E          )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_LION2_E        )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_BOBCAT2_E      )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_BOBCAT3_E      )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_ALDRIN_E       )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_AC3X_E         )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_ALDRIN2_E      )
        STR_FOR_FAMILY(CPSS_PX_FAMILY_PIPE_E              )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_FALCON_E       )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_AC5P_E         )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_AC5X_E      )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_HARRIER_E      )
        STR_FOR_FAMILY(CPSS_PP_FAMILY_DXCH_IRONMAN_E      )
        " unknown "
    ));

    /************************/
    /* fine tuning - tables */
    /************************/

        /* bridge section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.fdb                     )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.vidxNum                 )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.stgNum                  )
        ));
        /* router and TTI TCAM section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.router )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.tunnelTerm )
        ));
        /* tunnel section*/
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.tunnelStart )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.routerArp )
        ));
        /* ip section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.routerNextHop           )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.ecmpQos                 )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.mllPairs                )
        ));
        /* PCL section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.policyTcamRaws          )
        ));
        /* CNC section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.cncBlocks               )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.cncBlockNumEntries      )
        ));
        /* Policer Section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.policersNum             )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.egressPolicersNum       )
        ));
        /* trunk Section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.trunksNum               )
        ));
        /* Transmit Descriptors */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.transmitDescr           )
        ));
        /* Buffer Memory */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.bufferMemory            )
        ));
        /*  Transmit Queues */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.txQueuesNum             )
        ));
        /*  LPM RAM */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.lpmRam                  )
        ));

    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.bpePointToPointEChannels)
        ));

    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.emNum)
        ));

    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.vrfIdNum)
        ));

    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.oamEntriesNum)
        ));

    /*********************************/
    /* fine tuning - feature support */
    /*********************************/

        /* TR101 Feature support */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->featureInfo.tr101Supported)
        ));
        /* VLAN translation support */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->featureInfo.vlanTranslationSupported)
        ));
        /* Policer Ingress second stage support flag */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->featureInfo.iplrSecondStageSupported)
        ));
        /* trunk CRC hash support flag */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->featureInfo.trunkCrcHashSupported)
        ));

        /* TM support flag */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->featureInfo.TmSupported)
        ));


    /***************/
    /* other info  */
    /***************/

        /*policer 0 - Memory size per stage*/
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(dxChDevInfoPtr->policer.memSize[0])
        ));
        /*policer 1 - Memory size per stage*/
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(dxChDevInfoPtr->policer.memSize[1])
        ));
        /*policer 2 - Memory size per stage*/
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(dxChDevInfoPtr->policer.memSize[2])
        ));


    /************/
    /* HW info  */
    /************/
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(ppHwInfoPtr->l2i.supportIngressRateLimiter)
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(ppHwInfoPtr->cnc.cncBlocks)
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(ppHwInfoPtr->cnc.cncBlockNumEntries)
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(ppHwInfoPtr->txq.revision)
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(ppHwInfoPtr->ha.cpuPortBitIndex)
        ));
    return GT_OK;
}

/**
* @internal prvCpssDxChPrintBridgeDebugInfo function
* @endinternal
*
* @brief   DxCh prints information about Packet processor bridge values
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - PP's device number .
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - invalid devNum
*/
GT_STATUS prvCpssDxChPrintBridgeDebugInfo
(
    IN GT_U8                    devNum
)
{
    PRV_CPSS_DXCH_BRIDGE_INFO_STC *biPtr;
    char                          *s1;
    char                          *s2;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    biPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->bridge);

    DUMP_PRINT_MAC((" devTable = [0x%X] \n", biPtr->devTable));
    switch (biPtr->fdbHashParams.vlanMode)
    {
        case CPSS_IVL_E: s1 = "CPSS_IVL_E"; break;
        case CPSS_SVL_E: s1 = "CPSS_SVL_E"; break;
        default: s1 = "UNKNOWN"; break;
    }
    switch (biPtr->fdbHashParams.hashMode)
    {
        case CPSS_MAC_HASH_FUNC_CRC_E: s2 = "CPSS_MAC_HASH_FUNC_CRC_E"; break;
        case CPSS_MAC_HASH_FUNC_XOR_E: s2 = "CPSS_MAC_HASH_FUNC_XOR_E"; break;
        case CPSS_MAC_HASH_FUNC_CRC_MULTI_HASH_E: s2 = "CPSS_MAC_HASH_FUNC_CRC_MULTI_HASH_E"; break;
        default: s2 = "UNKNOWN"; break;
    }
    DUMP_PRINT_MAC((" HASH  vlanMode = [%s] hashMode = [%s]\n", s1, s2));
    DUMP_PRINT_MAC
        ((" HASH  size = [%d] numOfBanks = [%d] fid16BitHashEn = [%d]\n",
          biPtr->fdbHashParams.size, biPtr->fdbHashParams.numOfBanks,
          biPtr->fdbHashParams.fid16BitHashEn));
    switch (biPtr->fdbHashParams.crcHashUpperBitsMode)
    {
        case CPSS_DXCH_BRG_FDB_CRC_HASH_UPPER_BITS_MODE_ALL_ZERO_E:
            s1 = "CPSS_DXCH_BRG_FDB_CRC_HASH_UPPER_BITS_MODE_ALL_ZERO_E";
            break;
        case CPSS_DXCH_BRG_FDB_CRC_HASH_UPPER_BITS_MODE_USE_FID_E:
            s1 = "CPSS_DXCH_BRG_FDB_CRC_HASH_UPPER_BITS_MODE_USE_FID_E";
            break;
        case CPSS_DXCH_BRG_FDB_CRC_HASH_UPPER_BITS_MODE_USE_MAC_E:
            s1 = "CPSS_DXCH_BRG_FDB_CRC_HASH_UPPER_BITS_MODE_USE_MAC_E";
            break;
        default: s1 = "UNKNOWN"; break;
    }
    DUMP_PRINT_MAC((" HASH  crcHashUpperBitsMode = [%s]\n", s1));
    DUMP_PRINT_MAC
        ((" maxLengthSrcIdInFdbEn = [%d] tag1VidFdbEn = [%d] \n",
          biPtr->maxLengthSrcIdInFdbEn, biPtr->tag1VidFdbEn));
    switch (biPtr->sip6FdbMacEntryMuxingMode)
    {
        case CPSS_DXCH_FDB_MAC_ENTRY_MUXING_MODE_TAG_1_VID_E:
            s1 = "CPSS_DXCH_FDB_MAC_ENTRY_MUXING_MODE_TAG_1_VID_E";
            break;
        case CPSS_DXCH_FDB_MAC_ENTRY_MUXING_MODE_SRC_ID_E:
            s1 = "CPSS_DXCH_FDB_MAC_ENTRY_MUXING_MODE_SRC_ID_E";
            break;
        case CPSS_DXCH_FDB_MAC_ENTRY_MUXING_MODE_UDB_10_SRC_ID_1_DA_ACCESS_LEVEL_E:
            s1 = "CPSS_DXCH_FDB_MAC_ENTRY_MUXING_MODE_UDB_10_SRC_ID_1_DA_ACCESS_LEVEL_E";
            break;
        case CPSS_DXCH_FDB_MAC_ENTRY_MUXING_MODE_UDB_4_AND_4_SRC_ID_3_DA_ACCESS_LEVEL_E:
            s1 = "CPSS_DXCH_FDB_MAC_ENTRY_MUXING_MODE_UDB_4_AND_4_SRC_ID_3_DA_ACCESS_LEVEL_E";
            break;
        default: s1 = "UNKNOWN"; break;
    }
    DUMP_PRINT_MAC((" sip6FdbMacEntryMuxingMode = [%s]\n", s1));
    switch (biPtr->sip6FdbIpmcEntryMuxingMode)
    {
        case CPSS_DXCH_FDB_IPMC_ENTRY_MUXING_MODE_SRC_ID_7_E:
            s1 = "CPSS_DXCH_FDB_IPMC_ENTRY_MUXING_MODE_SRC_ID_7_E";
            break;
        case CPSS_DXCH_FDB_IPMC_ENTRY_MUXING_MODE_UDB_4_SRC_ID_3_E:
            s1 = "CPSS_DXCH_FDB_IPMC_ENTRY_MUXING_MODE_UDB_4_SRC_ID_3_E";
            break;
        case CPSS_DXCH_FDB_IPMC_ENTRY_MUXING_MODE_UDB_7_E:
            s1 = "CPSS_DXCH_FDB_IPMC_ENTRY_MUXING_MODE_UDB_7_E";
            break;
        default: s1 = "UNKNOWN"; break;
    }
    DUMP_PRINT_MAC((" sip6FdbIpmcEntryMuxingMode = [%s]\n", s1));
    switch (biPtr->sip6FdbSaDropCommand)
    {
        case CPSS_MAC_TABLE_FRWRD_E:         s1 = "CPSS_MAC_TABLE_FRWRD_E"; break;
        case CPSS_MAC_TABLE_DROP_E:          s1 = "CPSS_MAC_TABLE_DROP_E"; break;
        case CPSS_MAC_TABLE_INTERV_E:        s1 = "CPSS_MAC_TABLE_INTERV_E"; break;
        case CPSS_MAC_TABLE_CNTL_E:          s1 = "CPSS_MAC_TABLE_CNTL_E"; break;
        case CPSS_MAC_TABLE_MIRROR_TO_CPU_E: s1 = "CPSS_MAC_TABLE_MIRROR_TO_CPU_E"; break;
        case CPSS_MAC_TABLE_SOFT_DROP_E:     s1 = "CPSS_MAC_TABLE_SOFT_DROP_E"; break;
        default:                             s1 = "UNKNOWN"; break;
    }
    switch (biPtr->sip6FdbDaDropCommand)
    {
        case CPSS_MAC_TABLE_FRWRD_E:         s2 = "CPSS_MAC_TABLE_FRWRD_E"; break;
        case CPSS_MAC_TABLE_DROP_E:          s2 = "CPSS_MAC_TABLE_DROP_E"; break;
        case CPSS_MAC_TABLE_INTERV_E:        s2 = "CPSS_MAC_TABLE_INTERV_E"; break;
        case CPSS_MAC_TABLE_CNTL_E:          s2 = "CPSS_MAC_TABLE_CNTL_E"; break;
        case CPSS_MAC_TABLE_MIRROR_TO_CPU_E: s2 = "CPSS_MAC_TABLE_MIRROR_TO_CPU_E"; break;
        case CPSS_MAC_TABLE_SOFT_DROP_E:     s2 = "CPSS_MAC_TABLE_SOFT_DROP_E"; break;
        default:                             s2 = "UNKNOWN"; break;
    }
    DUMP_PRINT_MAC((" sip6FdbSaDropCommand = [%s] sip6FdbDaDropCommand = [%s]\n", s1, s2));
    DUMP_PRINT_MAC
        ((" auMessageNumOfWords = [%d] actionHwDevNum = [%d]\n",
          biPtr->auMessageNumOfWords, biPtr->actionHwDevNum));
    DUMP_PRINT_MAC
        ((" actionHwDevNumMask = [%d] supportSingleFdbInstance = [%d]\n",
          biPtr->actionHwDevNumMask, biPtr->supportSingleFdbInstance));
    switch (biPtr->portVlanfltTabAccessMode)
    {
        case CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_256_E:
            s1 = "CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_256_E";
            break;
        case CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_512_E:
            s1 = "CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_512_E";
            break;
        case CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_1K_E:
            s1 = "CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_1K_E";
            break;
        case CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_2K_E:
            s1 = "CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_2K_E";
            break;
        case CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_4K_E:
            s1 = "CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_4K_E";
            break;
        case CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_8K_E:
            s1 = "CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_8K_E";
            break;
        case CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_16K_E:
            s1 = "CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_16K_E";
            break;
        case CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_32K_E:
            s1 = "CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_32K_E";
            break;
        default: s1 = "UNKNOWN"; break;
    }
    DUMP_PRINT_MAC((" portVlanfltTabAccessMode = [%s]\n", s1));
    DUMP_PRINT_MAC
        ((" fdbAging_oneSecGranularity = [%d] fdbAging_maxSec = [%d]\n",
          biPtr->fdbAging_oneSecGranularity, biPtr->fdbAging_maxSec));
    DUMP_PRINT_MAC
        ((" l2EcmpNumMembers = [%d] l2EcmpNumMembers_usedByTrunk = [%d] l2EcmpIndex_NULL_port = [%d]\n",
          biPtr->l2EcmpNumMembers, biPtr->l2EcmpNumMembers_usedByTrunk, biPtr->l2EcmpIndex_NULL_port));
    return GT_OK;
}

/**
* @internal prvCpssDxChPrintErrataNamesDebugInfo function
* @endinternal
*
* @brief   DxCh prints information about which errata WA implemented for the device
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - PP's device number .
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - invalid devNum
*/
GT_STATUS prvCpssDxChPrintErrataNamesDebugInfo
(
    IN GT_U8                    devNum
)
{
    GT_U32  ii;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    DUMP_PRINT_MAC(("cpssDxChPrintErrataNamesInfo : the errata,RM WA for the device \n"));

    for(ii = 0 ; ii < PRV_CPSS_DXCH_ERRATA_MAX_NUM_E; ii++)
    {
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,ii))
        {
            if(errataNames[ii] == NULL)
            {
                DUMP_PRINT_MAC((" index %d is unknown \n" ,ii));
            }
            else
            {
                DUMP_PRINT_MAC((" %s \n" , errataNames[ii]));
            }
        }
    }

    return GT_OK;
}

#endif /*DEBUG_OPENED*/


/**
* @internal prvCpssDxChHwPpSdmaCpuPortReservedDmaIdxGet function
* @endinternal
*
* @brief   get the DMA index that is reserved for the CPU port
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] txqPortNumber            - sip5 : The global txq port number of the cpu port
*                                       sip6 : The global DMA port number of the cpu port
*
* @param[out] indexPtr                 - pointer to the index
*                                       GT_OK on success
*/
GT_STATUS prvCpssDxChHwPpSdmaCpuPortReservedDmaIdxGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  txqPortNumber,
    OUT GT_U32  *indexPtr
)
{
    GT_STATUS   rc;

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        GT_U32 globalDmaNum = txqPortNumber;/* use this parameter as 'global DMA' */
        GT_U32 dpIndex;
        GT_U32 globalDmaNum_actual;
        GT_U32 localDmaNum;

        /* get the DMA unit that need to be used */
        rc = prvCpssDxChHwPpDmaGlobalNumToLocalNumInDpConvert(devNum,globalDmaNum,&dpIndex,&localDmaNum);
        if (rc != GT_OK)
        {
            return rc;
        }

        if(dpIndex >= PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.maxDp)
        {
            /* this SDMA is not supported */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "the CPU SDMA can not be in DMA port num[%d] - it is not supported",
                globalDmaNum);
        }


        /* get what is the actual DMA port num for the CPU SDMA in the DMA unit */
        *indexPtr = CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS;
        if (!prvCpssDxChCpuDmaNumGet(devNum,dpIndex,localDmaNum,/*OUT*/&globalDmaNum_actual))
        {
            CPSS_LOG_INFORMATION_MAC("did not find cpu DMA matching DMA Port number[%d] ,dqIndex[%d] ",
                globalDmaNum,dpIndex);

            return GT_OK; /* return without error for 'query' of ports that are not CPU SDMA */
        }

        if(globalDmaNum_actual != globalDmaNum)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "the CPU SDMA can not be in DMA port num[%d] in DP[%d] only in DMA port num[%d]",
                globalDmaNum,dpIndex,globalDmaNum_actual);
        }

        *indexPtr = globalDmaNum_actual;
    }
    else
    if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        if (!prvCpssDxChCpuDmaNumGet(devNum,SIP_5_20_GLOBAL_TXQ_DQ_PORT_TO_DQ_UNIT_INDEX_MAC(devNum,txqPortNumber),0,/*OUT*/indexPtr))
        {
            *indexPtr = CPSS_DXCH_PORT_MAPPING_INVALID_PORT_CNS;
            CPSS_LOG_INFORMATION_MAC("did not find cpu DMA matching txq Port number[%d] ",txqPortNumber);
        }

    }
    else
    {
        *indexPtr = PRV_CPSS_DXCH_BC2_PORT_NUM_CPU_DMA_CNS;
    }

    return GT_OK;
}


/**
* @internal prvCpssDxChHwPpSdmaCpuPortReservedMacIdxGet function
* @endinternal
*
* @brief   get the index that is reserved for the CPU port for 'link status' filtering.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] portNum                  - The Physical port number of the cpu port
*
* @param[out] indexPtr                 - pointer to the index
*                                       GT_OK on success
*/
GT_STATUS prvCpssDxChHwPpSdmaCpuPortReservedMacIdxGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_U32                  *indexPtr
)
{
    if(!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        /* use the 'reserved' physical port as the SDMA CPU port */
        *indexPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->port.reservedPortsPtr[0];
    }
    else
    {
        /* there is no mapping in the EGF from 'virtual port' to 'physical port' */
        *indexPtr = portNum;/*63 or other*/
    }

    return GT_OK;
}

/* number of entries in bc3SpecialDma_from72 array */
#define bc3SpecialDma_from72_numEntries_CNS 6

static const struct{
    GT_U32    dpIndex;
}bc3SpecialDma_from72[bc3SpecialDma_from72_numEntries_CNS]= {
   /*72*/{2},
   /*73*/{5},
   /*74*/{0},
   /*75*/{1},
   /*76*/{3},
   /*77*/{4}
   };
#define BC3_SPECIAL_GLOBAL_PORT_CNS 72

/* number of entries in aldrin2specialDma_ports array */
#define aldrin2specialDma_ports_numEntries_CNS 5

static const struct{
    GT_U32    globalDmaNum;
    GT_U32    dpIndex;
    GT_U32    localDmaNum;
}aldrin2specialDma_ports[aldrin2specialDma_ports_numEntries_CNS]=
{
    /*globalPortNum*/ /*dpIndex*/ /*localPortNum*/
     {72             ,   0           ,        24}
    /*73 not valid*/
    ,{74             ,   3           ,        24}
    ,{75             ,   1           ,        24}
    ,{76             ,   2           ,        24}
    ,{77             ,   0           ,        23}
};

/**
* @internal prvCpssDxChHwPpGopGlobalMacPortNumToLocalMacPortInPipeConvert function
* @endinternal
*
* @brief   convert the global GOP MAC port number in device to local GOP MAC port
*         in the pipe , and the pipeId.
*
* @note   APPLICABLE DEVICES:      Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] globalMacPortNum         - the MAC global port number.
*
* @param[out] pipeIndexPtr             - (pointer to) the pipe Index of the MAC port
* @param[out] localMacPortNumPtr       - (pointer to) the MAC local port number
*                                       GT_OK on success
*/
GT_STATUS prvCpssDxChHwPpGopGlobalMacPortNumToLocalMacPortInPipeConvert
(
    IN  GT_U8   devNum,
    IN  GT_U32  globalMacPortNum,
    OUT GT_U32  *pipeIndexPtr,
    OUT GT_U32  *localMacPortNumPtr
)
{

    if(!PRV_CPSS_IS_MULTI_PIPES_DEVICE_MAC(devNum))
    {
        /* no convert needed */
        if(pipeIndexPtr)
        {
            *pipeIndexPtr = 0;
        }
        if(localMacPortNumPtr)
        {
            *localMacPortNumPtr = globalMacPortNum;
        }
        return GT_OK;
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
    {
        /*
            NOTE: for bobcat3 :
            global MAC ports 0..35  are 'pipe 0' local ports 0..35
            global MAC ports 36..71 are 'pipe 1' local ports 0..35

            global MAC 72 : 'pipe 0' local port 36
            global MAC 73 : 'pipe 1' local port 36
        */
        if(pipeIndexPtr)
        {
            *pipeIndexPtr       = globalMacPortNum >= BC3_SPECIAL_GLOBAL_PORT_CNS ?
                                  (globalMacPortNum & 1) :
                                  (globalMacPortNum / 36);
        }
        if(localMacPortNumPtr)
        {
            *localMacPortNumPtr = globalMacPortNum >= BC3_SPECIAL_GLOBAL_PORT_CNS ?
                                  36 :
                                  (globalMacPortNum % 36);
        }
        return GT_OK;
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_FALCON_E)
    {
        return
            prvCpssFalconGopGlobalMacPortNumToLocalMacPortInPipeConvert(devNum,
                globalMacPortNum,pipeIndexPtr,localMacPortNumPtr);
    }

    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);
}

/**
* @internal prvCpssDxChHwPpDmaGlobalNumToLocalNumInDpConvert function
* @endinternal
*
* @brief   convert the global DMA number in device to local DMA number
*         in the DataPath (DP), and the Data Path Id.
*
* @note   APPLICABLE DEVICES:      Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] globalDmaNum             - the DMA global number.
*
* @param[out] dpIndexPtr               - (pointer to) the Data Path (DP) Index
* @param[out] localDmaNumPtr           - (pointer to) the DMA local number
*                                       GT_OK on success
*/
GT_STATUS prvCpssDxChHwPpDmaGlobalNumToLocalNumInDpConvert
(
    IN  GT_U8   devNum,
    IN  GT_U32  globalDmaNum,
    OUT GT_U32  *dpIndexPtr,
    OUT GT_U32  *localDmaNumPtr
)
{
    GT_U32 dpIndex;   /* Data Path index */
    GT_U32 firstDma;  /* first global DMA in specific DP */
    GT_U32 numOfDmas; /* number of global DMA in specific DP */
    GT_U32 ii;        /*Iterator*/
    const GT_U32 *localDmaMapArr; /* local DMAs in specific DP, NULL in cases 1:1 mapping */

    if(! PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.supportRelativePortNum)
    {
        /* no convert needed */
        if(dpIndexPtr)
        {
            if (globalDmaNum >= 56 && /*56..71 at DP[1]*/
                (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E) &&
                (PRV_CPSS_PP_MAC(devNum)->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E))
            {
                *dpIndexPtr = 1;
            }
            else
            {
                *dpIndexPtr = 0;
            }
        }
        if(localDmaNumPtr)
        {
            *localDmaNumPtr = globalDmaNum;
        }
        return GT_OK;
    }



    /*
        NOTE: for bobcat3 :
        global DMA IDs 0..11   are 'DP 0' local dma 0..11
        global DMA IDs 12..23  are 'DP 1' local dma 0..11
        global DMA IDs 24..35  are 'DP 2' local dma 0..11
        global DMA IDs 36..47  are 'DP 3' local dma 0..11
        global DMA IDs 48..59  are 'DP 4' local dma 0..11
        global DMA IDs 60..71  are 'DP 5' local dma 0..11

        global DMA ID  72      is  'DP 2' local dma 12
        global DMA ID  73      is  'DP 5' local dma 12
        global DMA ID  74      is  'DP 0' local dma 12 -- CPU
        global DMA ID  75      is  'DP 1' local dma 12 -- CPU
        global DMA ID  76      is  'DP 3' local dma 12 -- CPU
        global DMA ID  77      is  'DP 4' local dma 12 -- CPU

        Aldrin has 3 DPs with local DMAs:
        DP0 - 56..59, 64..71  -> mapped to global ports 0..11
        DP1 - 56..59, 64..71  -> mapped to global ports 12..23
        DP2 - 56..59, 64..67, 62, 72 -> mapped to global ports 24..32, 72 (CPU)


        NOTE: for Aldrin2 :
        global DMA IDs 0..11   are 'DP 0' local dma 0..11
        global DMA IDs 12..23  are 'DP 1' local dma 0..11
        global DMA IDs 24..47  are 'DP 2' local dma 0..23
        global DMA IDs 48..71  are 'DP 3' local dma 0..23

        global DMA ID  72      is  'DP 0' local dma 24
        global DMA ID  73      --------
        global DMA ID  74      is  'DP 3' local dma 24 -- CPU
        global DMA ID  75      is  'DP 1' local dma 24 -- CPU
        global DMA ID  76      is  'DP 3' local dma 24 -- CPU
        global DMA ID  77      is  'DP 0' local dma 23 -- CPU (23--> not 24)
    */

    for (ii=0; ii<CPSS_MAX_SDMA_CPU_PORTS_CNS; ii++ )
    {
        PRV_CPSS_DXCH_NETIF_SKIP_NON_EXISTS_NETIF_NUM_MAC(devNum,ii);

        if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.info[ii].dmaNum == globalDmaNum)
        {
            /* CPU SDMA port is DP 2 in Aldrin */
            dpIndex = ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E) ||
                    (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC3X_E)) ? 2 : PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.info[ii].dqNum;

            /* portIndex is local port number in the pipe */
            if(localDmaNumPtr)
            {
                if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.info[ii].use_cpuPortDmaNum1 == GT_TRUE)
                {
                    /* support AC5X that hold 2 SDMAs in single DP[] */
                    *localDmaNumPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].cpuPortDmaNum1;
                }
                else
                {
                    *localDmaNumPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].cpuPortDmaNum;
                }
            }

            if(dpIndexPtr)
            {
                *dpIndexPtr = dpIndex;
            }
            return GT_OK;
        }

    }

    if(DMA_GLOBALNUM_TO_LOCAL_NUM_IN_DP_CONVERT_FUNC(devNum))
    {
        /* sip 6 devices */
        return DMA_GLOBALNUM_TO_LOCAL_NUM_IN_DP_CONVERT_FUNC(devNum)(devNum,
                globalDmaNum,dpIndexPtr,localDmaNumPtr);
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
    {
        if(globalDmaNum >= /*78*/(BC3_SPECIAL_GLOBAL_PORT_CNS+bc3SpecialDma_from72_numEntries_CNS))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        if(localDmaNumPtr)
        {
            *localDmaNumPtr = globalDmaNum >= BC3_SPECIAL_GLOBAL_PORT_CNS ?
                              12:
                              (globalDmaNum % 12);
        }
        if(dpIndexPtr)
        {
            *dpIndexPtr = globalDmaNum >= BC3_SPECIAL_GLOBAL_PORT_CNS ?
                          bc3SpecialDma_from72[globalDmaNum-BC3_SPECIAL_GLOBAL_PORT_CNS].dpIndex :
                          (globalDmaNum / 12);
        }
        return GT_OK;
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E)
    {
        /* first look at the 'special ports' */
        for(ii = 0 ; ii < aldrin2specialDma_ports_numEntries_CNS ; ii++)
        {
            if(aldrin2specialDma_ports[ii].globalDmaNum == globalDmaNum)
            {
                if (dpIndexPtr)
                {
                    *dpIndexPtr = aldrin2specialDma_ports[ii].dpIndex;
                }

                if(localDmaNumPtr)
                {
                    *localDmaNumPtr = aldrin2specialDma_ports[ii].localDmaNum;
                }

                return GT_OK;
            }
        }

        /* if not found ... check the global port at the ranges */
    }



    dpIndex = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.maxDp - 1;

    do
    {
        firstDma = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathFirstPort;
        numOfDmas = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathNumOfPorts;
        /* calculate pipe index */
        if((globalDmaNum >= firstDma) &&
           ((globalDmaNum - firstDma) < numOfDmas))
        {
            /* the port is in this pipe */
            break;
        }

        if(dpIndex == 0)
        {
            /* ERROR in the logic (or missing logic) */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }

    }while(--dpIndex);

    firstDma = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathFirstPort;
    numOfDmas = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathNumOfPorts;
    localDmaMapArr = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].localDmaMapArr;

    if(dpIndex == 0 &&
        ((globalDmaNum < firstDma) ||
         ((globalDmaNum - firstDma) >= numOfDmas)))
    {
        /* ERROR in the logic (or missing logic) */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* portIndex is local port number in the pipe */
    if(localDmaNumPtr)
    {
        if (localDmaMapArr)
        {
            *localDmaNumPtr = localDmaMapArr[globalDmaNum - firstDma];
        }
        else
        {
            *localDmaNumPtr = globalDmaNum - firstDma;
        }
    }

    if(dpIndexPtr)
    {
        *dpIndexPtr = dpIndex;
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChHwPpDmaLocalNumInDpToGlobalNumConvert function
* @endinternal
*
* @brief   convert the local DMA number in the DataPath (DP), to global DMA number
*         in the device.
*
* @note   APPLICABLE DEVICES:      Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] dpIndex                  - the Data Path (DP) Index
* @param[in] localDmaNum              - the DMA local number
*
* @param[out] globalDmaNumPtr          - (pointer to) the DMA global number.
*                                       GT_OK on success
*/
GT_STATUS prvCpssDxChHwPpDmaLocalNumInDpToGlobalNumConvert
(
    IN  GT_U8   devNum,
    IN  GT_U32  dpIndex,
    IN  GT_U32  localDmaNum,
    OUT GT_U32  *globalDmaNumPtr
)
{
    GT_U32 firstDma;  /* first global DMA in specific DP */
    GT_U32 numOfDmas; /* number of global DMA in specific DP */
    GT_U32 ii;

    if(! PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.supportRelativePortNum)
    {
        /* no convert needed */
        *globalDmaNumPtr = localDmaNum;
        return GT_OK;
    }

    if(dpIndex >= PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.maxDp)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "dpIndex[%d] not supported by the device",
            dpIndex);
    }

    if(DMA_LOCALNUM_TO_GLOBAL_NUM_IN_DP_CONVERT_FUNC(devNum))
    {
        /* sip 6 devices */
        return DMA_LOCALNUM_TO_GLOBAL_NUM_IN_DP_CONVERT_FUNC(devNum)(devNum,
                    dpIndex,localDmaNum,globalDmaNumPtr);
    }

    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
        if(localDmaNum > 12)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        if(localDmaNum == 12)
        {
            for(ii = 0 ; ii < bc3SpecialDma_from72_numEntries_CNS; ii++)
            {
                if(bc3SpecialDma_from72[ii].dpIndex == dpIndex)
                {
                    *globalDmaNumPtr = BC3_SPECIAL_GLOBAL_PORT_CNS + ii;
                    return GT_OK;
                }
            }
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_FOUND, LOG_ERROR_NO_MSG);
        }
        else
        {
            *globalDmaNumPtr = (12*dpIndex) + localDmaNum;
        }

        return GT_OK;

        case CPSS_PP_FAMILY_DXCH_ALDRIN2_E:
        /* first look at the 'special ports' */
        for(ii = 0 ; ii < aldrin2specialDma_ports_numEntries_CNS ; ii++)
        {
            if(aldrin2specialDma_ports[ii].dpIndex     == dpIndex &&
               aldrin2specialDma_ports[ii].localDmaNum == localDmaNum)
            {
                *globalDmaNumPtr = aldrin2specialDma_ports[ii].globalDmaNum;
                return GT_OK;
            }
        }

        /* if not found check the specific dpIndex */

        firstDma  = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathFirstPort;
        numOfDmas = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathNumOfPorts;

        if(localDmaNum >= numOfDmas)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "localDmaNum[%d] not supported at dpIndex[%d]",
                localDmaNum,dpIndex);
        }

        *globalDmaNumPtr = firstDma + localDmaNum;

        return GT_OK;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);
    }
}

/**
* @internal prvCpssDxChHwPpDmaLocalNumInDpToGlobalNumConvert_getNext function
* @endinternal
*
* @brief   the pair of {dpIndex,localDmaNum} may support 'mux' of :
*                   SDMA CPU port or network CPU port
*          each of them hold different 'global DMA number'
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] dpIndex                  - the Data Path (DP) Index
* @param[in] localDmaNum              - the DMA local number
* @param[out] globalDmaNumPtr          - (pointer to) the 'current' DMA global number.
*                                       if 'current' is GT_NA (0xFFFFFFFF) --> meaning need to 'get first'
*
* @param[out] globalDmaNumPtr          - (pointer to) the 'next' DMA global number.
*  GT_OK      on success
*  GT_NO_MORE on success but no more such global DMA port
*  GT_BAD_PARAM on bad param
*  GT_NOT_FOUND on non exists global DMA port
*/
GT_STATUS prvCpssDxChHwPpDmaLocalNumInDpToGlobalNumConvert_getNext
(
    IN  GT_U8   devNum,
    IN  GT_U32  dpIndex,
    IN  GT_U32  localDmaNum,
    INOUT GT_U32  *globalDmaNumPtr
)
{
    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.prvCpssDmaLocalNumInDpToGlobalNumConvertGetNextFunc)
    {
        /* sip 6 devices */
        return PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.prvCpssDmaLocalNumInDpToGlobalNumConvertGetNextFunc(devNum,
                dpIndex,localDmaNum,globalDmaNumPtr);
    }

    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE,LOG_ERROR_NO_MSG);
}


/**
* @internal prvCpssDxChHwPpPhysicalPortNumToPortGroupIdConvert function
* @endinternal
*
* @brief   convert the physical port number in device to port group index.
*
* @note   APPLICABLE DEVICES:      Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] physicalPortNum          - the physical port number.
*
* @param[out] portGroupIdPtr           - (pointer to) the port group of the port
*                                       GT_OK on success
*/
GT_STATUS prvCpssDxChHwPpPhysicalPortNumToPortGroupIdConvert
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    physicalPortNum,
    OUT GT_U32                 *portGroupIdPtr
)
{
    GT_STATUS   rc;
    GT_U32      portRxDmaNum;
    GT_U32      dpIndex;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(portGroupIdPtr);

    if(!PRV_CPSS_IS_MULTI_PIPES_DEVICE_MAC(devNum))
    {
        /* no conversion needed */
        *portGroupIdPtr = 0;
        return GT_OK;
    }

    /* Get port's DMA number */
    PRV_CPSS_DXCH_PORT_NUM_OR_CPU_PORT_CHECK_AND_RXDMA_NUM_GET_MAC(devNum,physicalPortNum,portRxDmaNum);

    /* Get DP index of port's DMA */
    rc = prvCpssDxChHwPpDmaGlobalNumToLocalNumInDpConvert(devNum,
                                                            portRxDmaNum,
                                                            &dpIndex,
                                                            NULL);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Convert DP index to pipe number, assuming equal number of DP's per pipe */
    *portGroupIdPtr =
        (dpIndex * PRV_CPSS_PP_MAC(devNum)->multiPipe.numOfPipes) /
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.maxDp;

    return GT_OK;
}

/**
* @internal prvCpssDxChHwEgfEftCpuCodeMapToCpuPortInit function
* @endinternal
*
* @brief   init the CPU code table mapping to CPU physical port that represent the CPU code.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5.
*
* @param[in] devNum                   - The PP's device number.
*                                      dpIndex             - the Data Path (DP) Index
*                                      localDmaNum         - the DMA local number
*                                       GT_OK on success
*/
static GT_STATUS prvCpssDxChHwEgfEftCpuCodeMapToCpuPortInit
(
    IN  GT_U8   devNum
)
{
    GT_STATUS rc;
    GT_U32  ii;
    GT_U32  numPortsInRegister = PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? 2 : 4;
    GT_U32  numBitsPerPort;
    GT_U32  numOfRegisters = 256 / numPortsInRegister;/*256 CPU codes*/
    GT_U32  value = CPSS_CPU_PORT_NUM_CNS;

    numBitsPerPort = PRV_CPSS_SIP_6_30_CHECK_MAC(devNum) ?  6 :
                     PRV_CPSS_SIP_6_10_CHECK_MAC(devNum) ?  7 :
                     PRV_CPSS_SIP_6_CHECK_MAC(devNum)    ? 10 :
                     PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? 9  :
                     8;

    /* build value of the registers */
    for(ii  = 1 ; ii < numPortsInRegister ; ii++)
    {
        value |= CPSS_CPU_PORT_NUM_CNS/*0x3f*/ << (ii*numBitsPerPort);
    }

    /* Set CPU Port Mapping Of Register default value  */
    for(ii = 0; ii < numOfRegisters; ii++)
    {
        rc = prvCpssHwPpWriteRegister(devNum,
              PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).global.cpuPortMapOfReg[ii],
              value);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}


/**
* @internal prvCpssDxChHwEgfQagTcDpMapperByIndexSet function
* @endinternal
*
* @brief   (sip5_20) set the EGF QAG 'TC,DP' mapping table , in specific index.
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] index                    -  into the table
*                                      (APPLICABLE RANGES: 0..(4K-1))
*                                      {NW-TC (3 bits)
*                                      NW-DP (2 bits)
*                                      Command (2 bits)
*                                      Multi or single destimnation (1 bit)
*                                      Target Port TC Profile (2 bits),
*                                      Source Port TC Profile (2 bits)}
* @param[in] newTxqDp                 - the DP to assign in the TXQ
* @param[in] newTxqTc                 - the TC to assign in the TXQ
*                                      (APPLICABLE RANGES: 0..7)
* @param[in] newTxqPfcTc              - the PFC TC to assign in the TXQ
*                                      (APPLICABLE RANGES: 0..7)
*                                       GT_OK on success
* @param[in]  mcastPriority            -defines whether a Multicast packet has guarantee delivery (e.g. IPTv,
*                                                             ARP-BC) or best effort delivery (e.g. flood).This indication has meaning only if the
*                                                             packet is Multicast.(APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman).
*
* @param[in]  dpForRx                 - defines whether on congestion packets will be dropped from RX context queue or
*                                       queue will back pressure the control pipe.(APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman)
* @param[in]  preemptiveTc            -defines whether a new TC will be preemptive or express.
*                                                              Valid only if targetPortTcProfile is  CPSS_DXCH_PORT_PROFILE_NETWORK_PREEMPTIVE_E
*                                                               (APPLICABLE DEVICES:  AC5P; AC5X; Harrier; Ironman).
*
*/
static GT_STATUS prvCpssDxChHwEgfQagTcDpMapperByIndexSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  index,
    IN  CPSS_DP_LEVEL_ENT  newTxqDp,
    IN  GT_U32  newTxqTc,
    IN  GT_U32  newTxqPfcTc,
    IN  CPSS_PORT_TX_DROP_MCAST_PRIORITY_ENT     mcastPriority,
    IN  CPSS_DP_FOR_RX_ENT                       dpForRx,
    IN  GT_BOOL                                  preemptiveTc
)
{
    GT_STATUS   rc; /* return code */
    GT_U32  value;/* hw value for the entry */
    GT_U32  hw_newTxqDp;/* hw value for <newTxqDp> */
    GT_U32  poolId,oldTc4Pfc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_XCAT3_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E);

    PRV_CPSS_DXCH3_COS_DP_CONVERT_MAC(newTxqDp,hw_newTxqDp);
    PRV_CPSS_DXCH_COS_CHECK_4BIT_TC_MAC(devNum,newTxqTc);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(newTxqPfcTc);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        if((index>>5)>=PRV_CPSS_DXCH_TC4PFC_TO_EGF_INDEX_ARR_SIZE_CNS)
        {
             CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        rc = cpssDxChPortTxTcMapToSharedPoolGet(devNum,(GT_U8)newTxqPfcTc,&poolId);
        if(rc!=GT_OK)
        {
            return rc;
        }

        if(poolId == SIP6_SHARED_TOTAL_POOLS_NUM_CNS)
        {
            /*this tc is unmapped ,so map it to default*/
            poolId = PRV_SIP6_DEFAULT_POOL_CNS;
            rc = prvCpssFalconTxqPfccMapTcToPoolSet(devNum,(GT_U8)newTxqPfcTc,poolId,
                GT_FALSE/*do not update 'ppolId' in all the entries that already relate to this newTxqPfcTc */);
            if(rc!=GT_OK)
            {
                return rc;
            }
        }

        /*Get old tc4Pfc*/
        rc = prvCpssDxChReadTableEntryField(devNum,
                                                CPSS_DXCH_SIP5_20_TABLE_EGF_QAG_TC_DP_MAPPER_E,
                                                index,
                                                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                                6,
                                                3,
                                                &oldTc4Pfc);


       if(oldTc4Pfc>=CPSS_TC_RANGE_CNS)
       {
         CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "read TC4PFC is out of range %d\n",oldTc4Pfc);
       }

       if(newTxqPfcTc>=CPSS_TC_RANGE_CNS)
       {
         CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "write TC4PFC is out of range %d\n",newTxqPfcTc);
       }


       PRV_CPSS_DXCH_PP_MAC(devNum)->tc4PfcToEgfIndex[oldTc4Pfc][index>>5]&=(~(1<<(index&0x1F)));
       PRV_CPSS_DXCH_PP_MAC(devNum)->tc4PfcToEgfIndex[newTxqPfcTc][index>>5]|=(1<<(index&0x1F));

       /*assume that validity is already checked*/
       if(GT_TRUE == preemptiveTc)
       {
            newTxqTc = (1<<3)|newTxqTc;
       }

        value = hw_newTxqDp |
                newTxqTc << 2 |
                newTxqPfcTc << 6|
                poolId<<9|((mcastPriority==CPSS_PORT_TX_DROP_MCAST_PRIORITY_HI_E)?1:0)<<10|
                ((dpForRx == CPSS_DP_FOR_RX_HIGH_E)?1:0)<<11;
    }
    else
    {
        value = hw_newTxqDp |
                newTxqTc << 2 |
                newTxqPfcTc << 5;
    }

    rc = prvCpssDxChWriteTableEntry(devNum,
        CPSS_DXCH_SIP5_20_TABLE_EGF_QAG_TC_DP_MAPPER_E,
        index, &value);

    return rc;
}

/**
* @internal prvCpssDxChHwEgfQagTcDpMapperByIndexGet function
* @endinternal
*
* @brief   (sip5_20) Get the EGF QAG 'TC,DP' mapping table entry, by specific index.
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] index                    -  into the table
*                                      (APPLICABLE RANGES: 0..(4K-1))
*                                      {NW-TC (3 bits)
*                                      NW-DP (2 bits)
*                                      Command (2 bits)
*                                      Multi or single destimnation (1 bit)
*                                      Target Port TC Profile (2 bits),
*                                      Source Port TC Profile (2 bits)}
*
* @param[out] txqDpPtr                 - (pointer to) the DP assigned to the TXQ
* @param[out] txqTcPtr                 - (pointer to) the TC assigned to the TXQ
*                                      (APPLICABLE RANGES: 0..7)
* @param[out] txqPfcTcPtr              - (pointer to) the PFC TC assigned in the TXQ
*                                      (APPLICABLE RANGES: 0..7)
*                                       GT_OK on success
* @param[out]  mcastPriorityPtr            -(pointer to)defines whether a Multicast packet has guarantee delivery (e.g. IPTv,
*                                                             ARP-BC) or best effort delivery (e.g. flood).This indication has meaning only if the
*                                                             packet is Multicast.(APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman).
*
* @param[out] dpForRxPtr                - (pointer to) drop precedence to RX context queue
*/
static GT_STATUS prvCpssDxChHwEgfQagTcDpMapperByIndexGet
(
    IN  GT_U8                                       devNum,
    IN  GT_U32                                      index,
    OUT  CPSS_DP_LEVEL_ENT                          *txqDpPtr,
    OUT  GT_U32                                     *txqTcPtr,
    OUT  GT_U32                                     *txqPfcTcPtr,
    OUT  CPSS_PORT_TX_DROP_MCAST_PRIORITY_ENT       *mcastPriorityPtr,
    OUT  CPSS_DP_FOR_RX_ENT                         *dpForRxPtr
)
{
    GT_STATUS   rc; /* return code */
    GT_U32  value;/* hw value for the entry */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_XCAT3_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E);

    CPSS_NULL_PTR_CHECK_MAC(txqDpPtr);
    CPSS_NULL_PTR_CHECK_MAC(txqTcPtr);
    CPSS_NULL_PTR_CHECK_MAC(txqPfcTcPtr);

    *mcastPriorityPtr = CPSS_PORT_TX_DROP_MCAST_PRIORITY_LOW_E;

    rc = prvCpssDxChReadTableEntry(devNum,
        CPSS_DXCH_SIP5_20_TABLE_EGF_QAG_TC_DP_MAPPER_E,
        index, &value);

    switch (value & 0x3)
    {
        case 0:
            *txqDpPtr = CPSS_DP_GREEN_E;
            break;
        case 1:
            *txqDpPtr = CPSS_DP_YELLOW_E;
            break;
        default:
            *txqDpPtr = CPSS_DP_RED_E;
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        *txqTcPtr = (value >> 2) & 0xF;
        *txqPfcTcPtr = (value >> 6) & 0x7;
        if((value >> 10) & 0x1)
        {
            *mcastPriorityPtr = CPSS_PORT_TX_DROP_MCAST_PRIORITY_HI_E;
        }
        if((value >> 11) & 0x1)
        {
            *dpForRxPtr = CPSS_DP_FOR_RX_HIGH_E;
        }
        else
        {
            *dpForRxPtr = CPSS_DP_FOR_RX_LOW_E;
        }
    }
    else
    {
        *txqTcPtr = (value >> 2) & 0x7;
        *txqPfcTcPtr = (value >> 5) & 0x7;
    }

    return rc;
}

/**
* @internal prvCpssDxChHwEgfQagTcDpMapperParamsCheck function
* @endinternal
*
* @brief   (sip5_20) check the EGF QAG 'TC,DP' mapping table input parameters and calculate 'index' to the table.
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X.
*
*
* @param[out] indexPtr                 - pointer to calculated table 'index'
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on bad parameteres
*/
static GT_STATUS prvCpssDxChHwEgfQagTcDpMapperParamsCheck
(
    IN  GT_U8   devNum,
    /* key */
    IN  GT_U32  origTc,
    IN  CPSS_DP_LEVEL_ENT   origDp,
    IN  CPSS_DXCH_NET_DSA_CMD_ENT  packetCommand,
    IN  GT_BOOL   isMultiDestination,
    IN  GT_U32  targetPortTcProfile,
    IN  GT_U32  sourcePortTcProfile,
    OUT GT_U32  *indexPtr
)
{
    GT_STATUS   rc;
    CPSS_DXCH_CSCD_QOS_PRIO_TABLE_ACCESS_MODE_ENT  prioTableAccessMode;
    GT_U32  hw_origDp;/* hw value for <origDp> */
    GT_U32  hw_packetCommand;/* hw value for <packetCommand> */
    GT_U32  hw_isMultiDestination = BOOL2BIT_MAC(isMultiDestination);/* hw value for <isMultiDestination> */

    /* check 'key' parameters */
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(origTc);
    PRV_CPSS_DXCH3_COS_DP_CONVERT_MAC(origDp,hw_origDp);

    switch (packetCommand)
    {
        case CPSS_DXCH_NET_DSA_CMD_TO_CPU_E:
            hw_packetCommand = 0;
            break;
        case CPSS_DXCH_NET_DSA_CMD_FROM_CPU_E:
            hw_packetCommand = 1;
            break;
        case CPSS_DXCH_NET_DSA_CMD_TO_ANALYZER_E:
            hw_packetCommand = 2;
            break;
        case CPSS_DXCH_NET_DSA_CMD_FORWARD_E:
            hw_packetCommand = 3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {

        rc = cpssDxChCscdQosTcDpRemapTableAccessModeGet(devNum, &prioTableAccessMode);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }

        switch (prioTableAccessMode)
        {
        case CPSS_DXCH_CSCD_QOS_2B_SRC_2B_TRG_E:
            if(targetPortTcProfile >= BIT_2)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            if(sourcePortTcProfile >= BIT_2)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            /* build the index
            *            {NW-TC (3 bits)
            *            NW-DP (2 bits)
            *            Command (2 bits)
            *            Multi or single destination (1 bit)
             *            Target Port TC Profile (2 bits),
            *            Source Port TC Profile (2 bits)}
            */

            *indexPtr = origTc << 9 |
                hw_origDp << 7 |
                hw_packetCommand << 5 |
                hw_isMultiDestination << 4 |
                targetPortTcProfile << 2 |
                sourcePortTcProfile ;
            break;

        case CPSS_DXCH_CSCD_QOS_4B_TRG_E:
            if(targetPortTcProfile >= BIT_4)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            /* build the index
            *            {NW-TC (3 bits)
            *            NW-DP (2 bits)
            *            Command (2 bits)
            *            Multi or single destimnation (1 bit)
            *            Target Port TC Profile (4 bits)
            */

            *indexPtr = origTc << 9 |
                hw_origDp << 7 |
                hw_packetCommand << 5 |
                hw_isMultiDestination << 4 |
                targetPortTcProfile;
            break;

        case CPSS_DXCH_CSCD_QOS_1B_SRC_3B_TRG_E:
            if(targetPortTcProfile >= BIT_3)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            if(sourcePortTcProfile >= BIT_1)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            /* build the index
            *            {NW-TC (3 bits)
            *            NW-DP (2 bits)
            *            Command (2 bits)
            *            Multi or single destimnation (1 bit)
            *            Target Port TC Profile (3 bits),
            *            Source Port TC Profile (1 bits)}
            */

            *indexPtr = origTc << 9 |
                hw_origDp << 7 |
                hw_packetCommand << 5 |
                hw_isMultiDestination << 4 |
                targetPortTcProfile << 1 |
                sourcePortTcProfile ;
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        if(targetPortTcProfile >= BIT_2)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        if(sourcePortTcProfile >= BIT_2)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* build the index
        *            {NW-TC (3 bits)
        *            NW-DP (2 bits)
        *            Command (2 bits)
        *            Multi or single destimnation (1 bit)
        *            Target Port TC Profile (2 bits),
        *            Source Port TC Profile (2 bits)}
        */

        *indexPtr = origTc << 9 |
        hw_origDp << 7 |
        hw_packetCommand << 5 |
        hw_isMultiDestination << 4 |
        targetPortTcProfile << 2 |
        sourcePortTcProfile ;

    }
    return GT_OK;
}

/**
* @internal prvCpssDxChHwEgfQagTcDpMapperByParamsSet function
* @endinternal
*
* @brief   (sip5_20) set the EGF QAG 'TC,DP' mapping table , according to parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X.
*
* @param[in] devNum                   - The PP's device number.
*                                      next parameters are part of the key , which define the 'index' to the table
* @param[in] origTc                   - orig TC (traffic class).
*                                      (APPLICABLE RANGES: 0..7)
* @param[in] origDp                   - orig DP (Drop precedence).
* @param[in] packetCommand            - packet command (on of CPSS_DXCH_NET_DSA_CMD_ENT)
* @param[in] isMultiDestination       - GT_TRUE - multi-destination
*                                      GT_FALSE - single destination
* @param[in] targetPortTcProfile      - Target Port TC Profile
*                                      (APPLICABLE RANGES: 0..3)
* @param[in] sourcePortTcProfile      - Source Port TC Profile
*                                      (APPLICABLE RANGES: 0..3)
*                                      next parameters are part of the 'data' to set according to the key
* @param[in] newTxqDp                 - the DP to assign in the TXQ
* @param[in] newTxqTc                 - the TC to assign in the TXQ
*                                      (APPLICABLE RANGES: 0..7)
* @param[in] newTxqPfcTc              - the PFC TC to assign in the TXQ
*                                      (APPLICABLE RANGES: 0..7)
* @param[in]  mcastPriority            -defines whether a Multicast packet has guarantee delivery (e.g. IPTv,
*                                                             ARP-BC) or best effort delivery (e.g. flood).This indication has meaning only if the
*                                                             packet is Multicast.(APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman).
* @param[in]  dpForRx                 - defines whether on congestion packets will be dropped from RX context queue or
*                                       queue will back pressure the control pipe.(APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman)
* @param[in]  preemptiveTc            -defines whether a new TC will be preemptive or express.
*                                                              Valid only if targetPortTcProfile is  CPSS_DXCH_PORT_PROFILE_NETWORK_PREEMPTIVE_E
*                                                               (APPLICABLE DEVICES:  AC5P; AC5X; Harrier; Ironman).
*                                       GT_OK on success
*/
GT_STATUS prvCpssDxChHwEgfQagTcDpMapperByParamsSet
(
    IN  GT_U8   devNum,
    /* key */
    IN  GT_U32  origTc,
    IN  CPSS_DP_LEVEL_ENT   origDp,
    IN  CPSS_DXCH_NET_DSA_CMD_ENT  packetCommand,
    IN  GT_BOOL   isMultiDestination,
    IN  GT_U32  targetPortTcProfile,
    IN  GT_U32  sourcePortTcProfile,
    /* data */
    IN  GT_U32  newTxqDp,
    IN  GT_U32  newTxqTc,
    IN  GT_U32  newTxqPfcTc,
    IN  CPSS_PORT_TX_DROP_MCAST_PRIORITY_ENT     mcastPriority,
    IN  CPSS_DP_FOR_RX_ENT                       dpForRx,
    IN  GT_BOOL                                  preemptiveTc
)
{
    GT_STATUS   rc; /* return code */
    GT_U32  index;
    GT_U32  pProfileHwValue;/* preemptive profile hw value */

    rc = prvCpssDxChHwEgfQagTcDpMapperParamsCheck(devNum,origTc, origDp, packetCommand,
                                                  isMultiDestination,
                                                  targetPortTcProfile,
                                                  sourcePortTcProfile,
                                                  &index);
    if (rc != GT_OK)
    {
        return rc;
    }

    PRV_CPSS_DXCH_PORT_TC_PROFILE_CONVERT_MAC(CPSS_DXCH_PORT_PROFILE_NETWORK_PREEMPTIVE_E,pProfileHwValue)

    if(PRV_CPSS_PP_MAC(devNum)->preemptionSupported)
    {
        if(targetPortTcProfile != pProfileHwValue&& GT_TRUE==preemptiveTc)
        {
           CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "Preemption is not supported on target profile %d\n",targetPortTcProfile);
        }

        /*We have only 4 bits ,bit 3 needed in order to mark preemptive tc*/
        if(GT_TRUE==preemptiveTc && newTxqTc >=BIT_3)
        {
           CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "Preemption is not supported for TC %d\n",newTxqTc);
        }
    }
    else
    {
        if(GT_TRUE == preemptiveTc)
        {
           CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "Preemption is not supported on device %d\n",devNum);
        }

        if(targetPortTcProfile == pProfileHwValue)
        {
           CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "Preemption is not supported on device %d\n",devNum);
        }
    }

    if(sourcePortTcProfile == pProfileHwValue)
    {
       CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "Preemption is not supported for source port profile \n");
    }

    return prvCpssDxChHwEgfQagTcDpMapperByIndexSet(devNum, index,newTxqDp,newTxqTc,newTxqPfcTc,mcastPriority, dpForRx,preemptiveTc);
}

/**
* @internal prvCpssDxChHwEgfQagTcDpMapperByParamsGet function
* @endinternal
*
* @brief   (sip5_20) Get the EGF QAG 'TC,DP' mapping table entry, according to parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X.
*
* @param[in] devNum                   - The PP's device number.
*                                      next parameters are part of the key , which define the 'index' to the table
* @param[in] origTc                   - orig TC (traffic class).
*                                      (APPLICABLE RANGES: 0..7)
* @param[in] origDp                   - orig DP (Drop precedence).
* @param[in] packetCommand            - packet command (on of CPSS_DXCH_NET_DSA_CMD_ENT)
* @param[in] isMultiDestination       - GT_TRUE - multi-destination
*                                      GT_FALSE - single destination
* @param[in] targetPortTcProfile      - Target Port TC Profile
*                                      (APPLICABLE RANGES: 0..3)
* @param[in] sourcePortTcProfile      - Source Port TC Profile
*                                      (APPLICABLE RANGES: 0..3)
*                                      next parameters are 'output' to get according to the key
* @param[in] txqDpPtr                 - (pointer to) the DP assigned to the TXQ
* @param[in] txqTcPtr                 - (pointer to) the TC to assigned to the TXQ
*                                      (APPLICABLE RANGES: 0..7)
* @param[in] txqPfcTcPtr              - (pointer to) the PFC TC assigned to the TXQ
*                                      (APPLICABLE RANGES: 0..7)
*                                       GT_OK on success
* @param[out]  mcastPriorityPtr            -(pointer to)defines whether a Multicast packet has guarantee delivery (e.g. IPTv,
*                                                             ARP-BC) or best effort delivery (e.g. flood).This indication has meaning only if the
*                                                             packet is Multicast.(APPLICABLE DEVICES: Falcon; AC5P; AC5X; Harrier; Ironman).
* @param[out]  dpForRx                 -(pointer to) Drop precedence for Rx context queue.
* @param[out]  preemptiveTcPtr         -(pointer to)defines whether a new TC will be preemptive or express.
*                                                              Valid only if targetPortTcProfile is  CPSS_DXCH_PORT_PROFILE_NETWORK_PREEMPTIVE_E
*                                                               (APPLICABLE DEVICES:  AC5P; AC5X; Harrier; Ironman).

*/
GT_STATUS prvCpssDxChHwEgfQagTcDpMapperByParamsGet
(
    IN  GT_U8   devNum,
    /* key */
    IN  GT_U32  origTc,
    IN  CPSS_DP_LEVEL_ENT   origDp,
    IN  CPSS_DXCH_NET_DSA_CMD_ENT  packetCommand,
    IN  GT_BOOL   isMultiDestination,
    IN  GT_U32  targetPortTcProfile,
    IN  GT_U32  sourcePortTcProfile,
    /* output parameters */
    OUT  CPSS_DP_LEVEL_ENT  * txqDpPtr,
    OUT  GT_U32  * txqTcPtr,
    OUT  GT_U32  * txqPfcTcPtr,
    OUT  CPSS_PORT_TX_DROP_MCAST_PRIORITY_ENT       *mcastPriorityPtr,
    OUT  CPSS_DP_FOR_RX_ENT                         *dpForRxPtr,
    OUT  GT_BOOL                                    *preemptiveTcPtr
)
{
    GT_STATUS   rc; /* return code */
    GT_U32  index;
    GT_U32  pProfileHwValue;/* preemptive profile hw value */

    PRV_CPSS_DXCH_PORT_TC_PROFILE_CONVERT_MAC(CPSS_DXCH_PORT_PROFILE_NETWORK_PREEMPTIVE_E,pProfileHwValue)

    rc = prvCpssDxChHwEgfQagTcDpMapperParamsCheck(devNum, origTc, origDp, packetCommand,
                                                  isMultiDestination,
                                                  targetPortTcProfile,
                                                  sourcePortTcProfile,
                                                  &index);
    if (rc != GT_OK)
    {
        return rc;
    }

    rc = prvCpssDxChHwEgfQagTcDpMapperByIndexGet(devNum,
            index,txqDpPtr,txqTcPtr,txqPfcTcPtr,mcastPriorityPtr,dpForRxPtr);

    if(targetPortTcProfile==pProfileHwValue)
    {
       *preemptiveTcPtr = ((*txqTcPtr&0xF)>>3)==1?GT_TRUE:GT_FALSE;
       *txqTcPtr = (*txqTcPtr)&0x7;
    }
    else
    {
        *preemptiveTcPtr = GT_FALSE;
    }

    return rc;
}

/**
* @internal prvCpssDxChHwEgfQagTcDpMapper1To1Set function
* @endinternal
*
* @brief   (sip5_20) set the EGF QAG 'TC,DP' mapping table as '1:1' for specific TC,DP.
*         in terms of (orgTc,orifDp) to (newTc,newDp).
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] tc                       - orig TC (traffic class).
*                                      (APPLICABLE RANGES: 0..7)
* @param[in] dp                       - orig DP (Drop precedence).
*                                       GT_OK on success
*/
static GT_STATUS prvCpssDxChHwEgfQagTcDpMapper1To1Set
(
    IN  GT_U8   devNum,
    IN  GT_U32  tc,
    IN  CPSS_DP_LEVEL_ENT   dp
)
{
    GT_STATUS   rc; /* return code */
    CPSS_DXCH_NET_DSA_CMD_ENT  packetCommand;
    GT_BOOL   isMultiDestination;
    CPSS_DP_FOR_RX_ENT   dpForRx = CPSS_DP_FOR_RX_LOW_E;         /* Drop precedence for RX */
    GT_U32  targetPortTcProfile;
    GT_U32  sourcePortTcProfile;
    GT_U32  numberOfTargetProfiles = 4;
    GT_U32  numberOfSourceProfiles = 4;

    /*AC5P*/
    if(PRV_CPSS_PP_MAC(devNum)->preemptionSupported)
    {
        /*include also preemptive profile*/
        numberOfTargetProfiles = 5;
        numberOfSourceProfiles = 1;

        rc = cpssDxChCscdQosTcDpRemapTableAccessModeSet(devNum,CPSS_DXCH_CSCD_QOS_1B_SRC_3B_TRG_E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    for(packetCommand = CPSS_DXCH_NET_DSA_CMD_TO_CPU_E ;
        packetCommand <= CPSS_DXCH_NET_DSA_CMD_FORWARD_E ;
        packetCommand++)
    {
        for(isMultiDestination = GT_FALSE ;
            isMultiDestination <= GT_TRUE ;
            isMultiDestination++)
        {
            for(targetPortTcProfile = 0 ;
                targetPortTcProfile <numberOfTargetProfiles;
                targetPortTcProfile++)
            {
                for(sourcePortTcProfile = 0 ;
                    sourcePortTcProfile < numberOfSourceProfiles;
                    sourcePortTcProfile++)
                {
                    if((PRV_CPSS_SIP_6_CHECK_MAC(devNum)) && (isMultiDestination == GT_TRUE))
                    {
                        /* On congestion, MC traffic will be dropped by RX */
                        dpForRx = CPSS_DP_FOR_RX_HIGH_E;
                    }

                    rc = prvCpssDxChHwEgfQagTcDpMapperByParamsSet(devNum,
                        tc ,/*origTc*/
                        dp ,/*origDp*/
                        packetCommand,
                        isMultiDestination,
                        targetPortTcProfile,
                        sourcePortTcProfile,

                        dp,/*newTxqDp*/
                        tc,/*newTxqTc*/
                        tc /*newTxqPfcTc*/,CPSS_PORT_TX_DROP_MCAST_PRIORITY_LOW_E,
                        dpForRx,
                        GT_FALSE
                        );
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }/*loop on sourcePortTcProfile*/
            }/*loop on targetPortTcProfile*/
        }/*loop on isMultiDestination*/
    }/*loop on packetCommand*/

    return GT_OK;
}

/**
* @internal prvCpssDxChHwEgfQagTcDpMapperInit function
* @endinternal
*
* @brief   (sip5_20) set the EGF QAG 'TC,DP' mapping table as '1:1' for all the (tc,dp).
*
* @note   APPLICABLE DEVICES:      Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X.
*
* @param[in] devNum                   - The PP's device number.
*                                       GT_OK on success
*/
static GT_STATUS prvCpssDxChHwEgfQagTcDpMapperInit
(
    IN  GT_U8   devNum
)
{
    GT_STATUS   rc; /* return code */
    GT_U32  tc;
    CPSS_DP_LEVEL_ENT   dp;
    GT_U32              i;

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        for(i=0;i<128;i++)
        {
            /*By default all belong to TC0*/
            PRV_CPSS_DXCH_PP_MAC(devNum)->tc4PfcToEgfIndex[0][i] = 0xFFFFFFFF;
        }
    }

    for(tc = 0 ;tc < CPSS_TC_RANGE_CNS ; tc++)
    {
        for(dp = CPSS_DP_GREEN_E ; dp <= CPSS_DP_RED_E ; dp++)
        {
            rc = prvCpssDxChHwEgfQagTcDpMapper1To1Set(devNum,tc,dp);
            if(rc != GT_OK)
            {
                return rc;
            }
        }/*loop on dp*/
    }/*loop on tc*/

    return GT_OK;

}


/**
* @internal internal_cpssDxChHwPpMaxNumOfPhyPortsToUseSet function
* @endinternal
*
* @brief   Set the number of physical ports that the device should support.
*         In Bobcat3 there is tradeoff between number of physical ports and some tables
*         that hold all physical ports 'per entry'
*         So Bobcat3 can support 256 physical ports like Bobcat2 :
*         8K vlans , 4K STG , 4K trunks , 4K SST-ID
*         Or Bobcat3 can support 512 physical ports :
*         4K vlans, 2K STG , 2K trunks , 2K SST-ID , single device (8bit port-id in eDSA)
*         NOTE: Next tables keep 256 ports only !!!  :
*         L2 Port Isolation , L3 Port Isolation
*
*         In Falcon we support up to 1K Remote Physical Ports.
*         correlated scales :
*         Remote Phy Ports    64    128   256   512    1024
*         ----------------   ----   ----  ---   ---    ----
*         eVlan              8K     8k    4K    2K     1K
*         Trunks             4K     2K    1K    512    256
*         Vidx(MC Groups)    4K     2K    1K    512    256
*         Span State Groups  4K     2K    1K    512    256
*         Source ID          4K     2K    1K    512    256
*
*         In AC5P we support only 128 port modes.
*
*         In AC5X we support only 128 port modes.
*
*
* @note   APPLICABLE DEVICES:      Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2;
*                                   Caelum; Aldrin; Aldrin2; AC3X.
*
* @param[in] devNum                   - The PP's device number.
* @param[in] maxPhysicalPorts         - the max number of 'physical ports' that the device need to support.
*                                      value 0 means 'default'
*                                      (APPLICABLE VALUES: Bobcat3;  Falcon; AC5P; AC5X; Harrier; Ironman: 0,256,512)
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChHwPpMaxNumOfPhyPortsToUseSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  maxPhysicalPorts
)
{
    GT_STATUS rc;
    GT_U32  value_distributorGeneralConfigs;/* value to register distributorGeneralConfigs */
    GT_U32  value_SHTGlobalConfigs;         /* value to register SHTGlobalConfigs */
    GT_U32  value_bridgeGlobalConfig0;      /* value to register bridgeGlobalConfig0 */
    GT_U32  regAddr,regOffset,regValue;
    GT_U32  isHalfTable;
    GT_U32  multipleValue=1,dividerValue=1;
    GT_U32  vlan_multipleValue=1,vlan_dividerValue=1;
    GT_U32  ii;
    static const CPSS_DXCH_TABLE_ENT affectedTables[] = {
        /*L2i*/
        CPSS_DXCH_LION_TABLE_STG_INGRESS_E,
        CPSS_DXCH_SIP5_TABLE_INGRESS_BRIDGE_PORT_MEMBERS_E,
        /*QAG*/
        CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_QAG_EGRESS_VLAN_E,
        /*SHT*/
        CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_NON_TRUNK_MEMBERS2_E,
        CPSS_DXCH_LION_TABLE_STG_EGRESS_E,
        CPSS_DXCH_LION_TABLE_VLAN_EGRESS_E,
        CPSS_DXCH_LION_TABLE_TXQ_SOURCE_ID_MEMBERS_E,

        /* must be last */
        CPSS_DXCH_TABLE_LAST_E
    };

    static const CPSS_DXCH_TABLE_ENT sip6_extra_affectedTables[] = {
        /*SHT*/
        CPSS_DXCH_TABLE_MULTICAST_E,
        /* must be last */
        CPSS_DXCH_TABLE_LAST_E
    };

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E |
          CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_ALDRIN2_E);

    if(PRV_CPSS_SIP_6_30_CHECK_MAC(devNum))
    {
        /* nothing to set , as there are not 'modes' that the device supports.
           all relevant tables are '64 ports bmp'  */

        if(maxPhysicalPorts != 0 && maxPhysicalPorts != 64) /* support single 64 ports mode */
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,
                "value[%d] not supported by the device (supports only '64' or '0')",
                maxPhysicalPorts);
        }

        return GT_OK;
    }

    if(maxPhysicalPorts == 0)
    {
        if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
        {
            /* AC5P,AC5X,Harrier -- support for JIRA : CPSS-12624 :
                Aldrin3: Need for maxPhysicalPorts on phase1 parameters */
            /* support single 128 ports mode */
            /* default : the single mode     */
            maxPhysicalPorts = 128;
        }
        else
        {
            /* default : half table */
            maxPhysicalPorts = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts / 2;
        }
    }


    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        switch(maxPhysicalPorts)
        {
            case 64:
                value_distributorGeneralConfigs = 0;
                break;
            case 128:
                value_distributorGeneralConfigs = 1;
                break;
            case 256:
                value_distributorGeneralConfigs = 2;
                break;
            case 512:
                value_distributorGeneralConfigs = 3;
                break;
            case 1024:
                value_distributorGeneralConfigs = 4;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,
                    "value[%d] not supported for this device",
                    maxPhysicalPorts);
        }

        if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
        {
            if(maxPhysicalPorts != 128) /* support single 128 ports mode */
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,
                    "value[%d] not supported by the device (supports only '128' or '0')",
                    maxPhysicalPorts);
            }

            dividerValue      = 1;
            vlan_dividerValue = 1;
            value_distributorGeneralConfigs = 1;
        }
        else
        {
            dividerValue  = maxPhysicalPorts >> 6; /* 64: 1, 128: 2, 256: 4, 512 : 8, 1024: 16*/
            vlan_dividerValue =
                                maxPhysicalPorts == 64   ? 1 :
                                maxPhysicalPorts == 512  ? 4 :
                                maxPhysicalPorts == 1024 ? 8 :
                                value_distributorGeneralConfigs;/*64 : 1, 128: 1, 256: 2, 512 : 4, 1024: 8*/
        }

        /* in falcon the regular port mode is 256 physical ports
           isHalfTable indicate if the mode is regular or not*/
        isHalfTable =  value_distributorGeneralConfigs == 1 ? 0 : 1;

        value_SHTGlobalConfigs = value_distributorGeneralConfigs;
        value_bridgeGlobalConfig0 = value_distributorGeneralConfigs;

        PRV_CPSS_DXCH_TABLES_SIZE_MODE_SET_MAC(devNum,value_distributorGeneralConfigs);

           /*
        NOTE: the init of devPtr->multiPipe.numOfTiles comes from the 'driver'
        and set during hwPpPhase1Part1(...)
        (see use of MACRO NUM_OF_TILES_AND_PORTS(...))
        */

        if( PRV_CPSS_PP_MAC(devNum)->numOfPorts > maxPhysicalPorts)
        {
            PRV_CPSS_PP_MAC(devNum)->numOfVirtPorts  = maxPhysicalPorts;
            /* without this 'limitation' the 6.4 Tera device  initialization FAILs on
              'trunkInit' because try to call cpssDxChTrunkPortTrunkIdSet with portNum = 128,129

              (and will fail for 12.8 T)
              */
        }
    }
    else /* sip 5.20 */
    {
        switch(maxPhysicalPorts)
        {
            case 256:
                /* full table */
                value_distributorGeneralConfigs = 0;
                value_SHTGlobalConfigs = 0;
                value_bridgeGlobalConfig0 = 1;
                isHalfTable = 0;  /* full table */
                break;
            case 512:
                /* half table */
                value_distributorGeneralConfigs = 1;
                value_SHTGlobalConfigs = 1;
                value_bridgeGlobalConfig0 = 0;
                isHalfTable = 1;  /* half table */
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,
                    "value[%d] not supported for this device",
                    maxPhysicalPorts);
        }

        if(isHalfTable)
        {
            /* half table */
            if(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).phyPort != maxPhysicalPorts)
            {
                /* we change mode from 'full' to 'half' */
                dividerValue = 2;
                CPSS_LOG_INFORMATION_MAC("we change mode from 'full' to 'half' table mode \n");
            }
            else
            {
                CPSS_LOG_INFORMATION_MAC("we keep 'half' table mode \n");
            }
        }
        else
        {
            /* full table */
            if(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).phyPort != 0 &&
               PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).phyPort != maxPhysicalPorts)
            {
                /* we change mode from 'half' to 'full' */
                multipleValue = 2;
                CPSS_LOG_INFORMATION_MAC("we change mode from 'half' to 'full' table mode \n");
            }
            else
            {
                CPSS_LOG_INFORMATION_MAC("we keep 'full' table mode \n");
            }
        }

        vlan_multipleValue = multipleValue;
        vlan_dividerValue  = dividerValue;

        PRV_CPSS_DXCH_TABLES_SIZE_MODE_SET_MAC(devNum,dividerValue);

    }


    if(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid == 0)
    {
        /* init values */
        PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid = 1 + PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_VID_MAC(devNum);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).sstId == 0)
    {
        /* init values */
        PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).sstId = 1 + PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_SRC_ID_MAC(devNum);
    }

#define UPDATE_VALUE_MAC(value,multiple,divide) \
    value = ((value) * (multiple)) / (divide)

    /* set new values to table sizes */
    PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).phyPort  = maxPhysicalPorts;
    UPDATE_VALUE_MAC(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid       ,vlan_multipleValue,vlan_dividerValue);
    UPDATE_VALUE_MAC(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).sstId     ,multipleValue,dividerValue);

    CPSS_LOG_INFORMATION_MAC("Table [%s] new num of entries [%d] \n",
        "Vlans",
        PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid);

    CPSS_LOG_INFORMATION_MAC("Table [%s] new num of entries [%d] \n",
        "Src-id",
        PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).sstId);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).stgId == 0)
        {
            /* init values */
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).stgId = 1 + PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_STG_ID_MAC(devNum);
        }

        if(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).trunkId == 0)
        {
            /* init values */
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).trunkId = 1 + PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum);
        }

        if(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vidx == 0)
        {
            /* init values */
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vidx = 1 + PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_VIDX_MAC(devNum);
        }

        /* set new values to table sizes */
        UPDATE_VALUE_MAC(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).stgId     ,multipleValue,dividerValue);
        UPDATE_VALUE_MAC(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).trunkId   ,multipleValue,dividerValue);
        UPDATE_VALUE_MAC(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vidx      ,multipleValue,dividerValue);


        CPSS_LOG_INFORMATION_MAC("Table [%s] new num of entries [%d] \n",
            "stgId",
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).stgId);

        CPSS_LOG_INFORMATION_MAC("Table [%s] new num of entries [%d] \n",
            "trunkId",
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).trunkId);

        CPSS_LOG_INFORMATION_MAC("Table [%s] new num of entries [%d] \n",
            "vidx",
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vidx);
    }

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        /* 1. not supports the <Remote Physical Ports scales> in QAG,SHT */
        /* 2. no need to modify <Flood eVIDX> because the table hold entry index 0xfff
            NOTE: in sip6_10 the field is 14 bits and starts at bit 13 ! (not 15 like in sip6)
        */

        /* set the L2i default value from mode of 256 to 128 */
        regAddr = PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeGlobalConfig0;
        regOffset = 28;
        regValue = value_bridgeGlobalConfig0;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, regOffset, 3, regValue);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        /*<Table Access Mode>*/
        regAddr = PRV_DXCH_REG1_UNIT_EGF_QAG_MAC(devNum).distributor.distributorGeneralConfigs;
        regOffset = 15;
        regValue = value_distributorGeneralConfigs;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, regOffset, PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? 3 : 1, regValue);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }

        /*<Table Access Mode>*/
        regAddr = PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.SHTGlobalConfigs;
        regOffset = 8;
        regValue = value_SHTGlobalConfigs;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, regOffset, PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? 3 : 1, regValue);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }

        /* <HalfPhyPortTables> */
        regAddr = PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeGlobalConfig0;
        regOffset = PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? 28 : 26;
        regValue = value_bridgeGlobalConfig0;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, regOffset, PRV_CPSS_SIP_6_CHECK_MAC(devNum) ? 3 : 1, regValue);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum) &&
           (((value_SHTGlobalConfigs == 0) && (PRV_CPSS_DXCH_PP_HW_INFO_LAST_INDEX_IN_TABLE_VIDX_MAC(devNum) == FLOOD_VIDX_CNS))||(PRV_CPSS_DXCH_PP_HW_INFO_LAST_INDEX_IN_TABLE_VIDX_MAC(devNum) < FLOOD_VIDX_CNS)))
        {
            /* need to set <Flood eVIDX> with 'max value' to replace the 'vidx 0xFFF' */
            regAddr  = PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.SHTGlobalConfigs;
            regValue = PRV_CPSS_DXCH_PP_HW_INFO_LAST_INDEX_IN_TABLE_VIDX_MAC(devNum);

            rc = prvCpssHwPpSetRegField(devNum, regAddr, 15, 12, regValue);
            if(rc != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
            }
        }
    }

    ii = 0;
    while(affectedTables[ii] < CPSS_DXCH_TABLE_LAST_E)
    {
        if(isHalfTable)
        {
            PRV_CPSS_DXCH_BMP_OF_TABLES_IN_HALF_SIZE_MODE_SET_MAC(devNum,affectedTables[ii]);
        }
        else
        {
            PRV_CPSS_DXCH_BMP_OF_TABLES_IN_HALF_SIZE_MODE_CLEAR_MAC(devNum,affectedTables[ii]);
        }
        ii++;
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        ii = 0;
        while(sip6_extra_affectedTables[ii] < CPSS_DXCH_TABLE_LAST_E)
        {
            if(isHalfTable)
            {
                PRV_CPSS_DXCH_BMP_OF_TABLES_IN_HALF_SIZE_MODE_SET_MAC(devNum,sip6_extra_affectedTables[ii]);
            }
            else
            {
                PRV_CPSS_DXCH_BMP_OF_TABLES_IN_HALF_SIZE_MODE_CLEAR_MAC(devNum,sip6_extra_affectedTables[ii]);
            }
            ii++;
        }

    }


    return GT_OK;
}

/**
* @internal prvCpssDxChHwInitNumOfSerdesGet function
* @endinternal
*
* @brief   Get number of SERDES lanes in device.
*         Function returns number of SERDES in port group for Lion and Lion2
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
*
* @retval 0                        - for not applicable device
*                                       Number of number of SERDES lanes in device or port group
*/
GT_U32 prvCpssDxChHwInitNumOfSerdesGet
(
    IN GT_U8 devNum
)
{
    GT_U32      lanesNumInDev; /* number of SERDES lanes */

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        return PRV_CPSS_DXCH_PP_HW_INFO_SERDES_MAC(devNum).sip6LanesNumInDev;
    }

    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_CASES_MAC:
            lanesNumInDev = PRV_CPSS_XCAT3_SERDES_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_LION2_E:
            lanesNumInDev = PRV_CPSS_LION2_SERDES_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
            lanesNumInDev = PRV_CPSS_BOBCAT2_SERDES_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
        case CPSS_PP_FAMILY_DXCH_AC3X_E:
            lanesNumInDev = PRV_CPSS_ALDRIN_SERDES_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
            lanesNumInDev = PRV_CPSS_BOBCAT3_SERDES_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_ALDRIN2_E:
            lanesNumInDev = PRV_CPSS_ALDRIN2_SERDES_NUM_CNS;
            break;
        default:
            lanesNumInDev = 0;
            break;
    }

    return lanesNumInDev;
}

/**
* @internal prvCpssDxChHwPortGroupBetweenUnitsConvert function
* @endinternal
*
* @brief   Convert port group of 'unit A' to port group in 'unit B'
*         NOTE:
*         1. some units hold 'relations' between themselves , like:
*         a. MT to MG on FDB upload or on NA to CPU.
*         b. CNC to MG on CNC upload
*         2. such function needed for Bobcat3 where single MG unit serves the CNC
*         units of both 2 port groups. (MT is also single anyway)
*
* @note   APPLICABLE DEVICES:      Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] unitA                    - the type of unit A
* @param[in] portGroupInUnitA         - the port group in unit A that needs conversion.
* @param[in] unitB                    - the type of unit B
*
* @param[out] portGroupInUnitBPtr      - (pointer to) the port group of unit B that
*                                      relates to port group in unit A.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS  prvCpssDxChHwPortGroupBetweenUnitsConvert
(
    IN GT_U8 devNum,
    IN PRV_CPSS_DXCH_UNIT_ENT   unitA,
    IN GT_U32       portGroupInUnitA,
    IN PRV_CPSS_DXCH_UNIT_ENT   unitB,
    OUT GT_U32      *portGroupInUnitBPtr
)
{
    /* default : 'No conversion' */
    *portGroupInUnitBPtr = portGroupInUnitA;

    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
            if(unitA == PRV_CPSS_DXCH_UNIT_CNC_0_E &&
               unitB == PRV_CPSS_DXCH_UNIT_MG_E)
            {
                if(portGroupInUnitA < 2)/* 0 or 1 */
                {
                    /* the (single MG) MG of port group 0 , serves both port groups of CNC */
                    *portGroupInUnitBPtr = 0;
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
            }
            break;
        case CPSS_PP_FAMILY_DXCH_FALCON_E:
            if(unitA == PRV_CPSS_DXCH_UNIT_CNC_0_E &&
               unitB == PRV_CPSS_DXCH_UNIT_MG_E)
            {
                static const GT_U32 mgPortGroupForCncArr[8] = {0,1,3,2,4,5,7,6};

                /* in Falcon each pipe hold it's own FUQ for CNC upload    */
                /* there are 8 pipes in Falcon , but there are 16 MG units */
                /* but only 2 of every 4 MGs hold FUQ                      */
                *portGroupInUnitBPtr = mgPortGroupForCncArr[portGroupInUnitA];
            }
            break;
        case CPSS_PP_FAMILY_DXCH_AC5P_E:
            if(unitA == PRV_CPSS_DXCH_UNIT_CNC_2_E &&
               unitB == PRV_CPSS_DXCH_UNIT_MG_E)
            {
                *portGroupInUnitBPtr = 0;/* even though MG[1] supports CNC2,3 upload ,
                                            this function returns 'port groups' */
            }
            break;
        default:
            break;
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChHwPortGroupToMgUnitConvert function
* @endinternal
*
* @brief   Convert port group of client in port group to MG unit index.
*
* @note   APPLICABLE DEVICES:      Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - physical device number
* @param[in] portGroup                - the port group in unit A that needs conversion.
* @param[in] mgClient                 - the type of client
*
* @param[out] mgUnitPtr      - (pointer to) the MG unit.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS  prvCpssDxChHwPortGroupToMgUnitConvert
(
    IN GT_U8                        devNum,
    IN GT_U32                       portGroup,
    IN PRV_CPSS_DXCH_MG_CLIENT_ENT  mgClient,
    OUT GT_U32                      *mgUnitPtr
)
{
    switch(mgClient)
    {
        case PRV_CPSS_DXCH_MG_CLIENT_FDB_ONLY_E             : /* The MG that serves FDB unit for AU and FU operations */
        case PRV_CPSS_DXCH_MG_CLIENT_FUQ_FOR_CNC01_E        : /* The MG that serves FUQ for CNC0,1 uploads */
        case PRV_CPSS_DXCH_MG_CLIENT_FUQ_FOR_CNC23_E        : /* The MG that serves FUQ for CNC2,3 uploads */
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum)) /*Hawk*/
    {
        if(mgClient == PRV_CPSS_DXCH_MG_CLIENT_FUQ_FOR_CNC23_E)
        {
            *mgUnitPtr = 1;
        }
        else
        {
            *mgUnitPtr = 0;
        }
        return GT_OK;
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum)) /*Falcon*/
    {
        if(mgClient == PRV_CPSS_DXCH_MG_CLIENT_FDB_ONLY_E)
        {
            /* for AUQ : only even portGroup are expected */
            /* for FUQ : only even portGroup are expected */
            /* but if called as 'loop on all port groups' for FUQ for CNC0,1 upload
               also the even port groups are called ... give those the MGs */

            static const GT_U32 mgUnitAuqFuqArr[8] = {0,1,4,5,8,9,12,13};/* MG units --NO NO -- NO SWAP !!! */
            *mgUnitPtr = mgUnitAuqFuqArr[portGroup];
        }
        else
        if(mgClient == PRV_CPSS_DXCH_MG_CLIENT_FUQ_FOR_CNC01_E)
        {
            /* needed for CNC upload operations */
            /* the portGroup in application terms are swapped to the actual pipes and MGs that serves them */
            static const GT_U32 mgUnitFuqArr[8] = {0,1,5,4,8,9,13,12};/* MG units SWAP !!! */
            *mgUnitPtr = mgUnitFuqArr[portGroup];
        }
        else
        {
            *mgUnitPtr = 0;/* unknown unit */
        }
        return GT_OK;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        /* single MG[0] supports : AUQ,FUQ,CNC-upload */
        *mgUnitPtr = 0;
        return GT_OK;
    }

    if(PRV_CPSS_IS_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
    {
        /* MG[x] supports : AUQ,FUQ,CNC-upload in that port group */
        *mgUnitPtr =  portGroup;
    }
    else
    {
        /* single MG[0] supports : AUQ,FUQ,CNC-upload */
        *mgUnitPtr = 0;
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChHwDevNumChange function
* @endinternal
*
* @brief   This function performs own HW device number update
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] hwDevNum                 - HW device number
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on error
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - on bad device
* @retval GT_OUT_OF_RANGE          - on hwDevNum > 31
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChHwDevNumChange
(
    IN  GT_U8                       devNum,
    IN  GT_HW_DEV_NUM               hwDevNum
)
{
    GT_STATUS rc;
    GT_PORT_NUM                         portNum;
    CPSS_INTERFACE_INFO_STC             physicalInfo;
    GT_U32                              numOfPhysicalPorts;
    CPSS_SYSTEM_RECOVERY_INFO_STC system_recovery; /* holds system recovery information */

    rc = cpssSystemRecoveryStateGet(&system_recovery);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* the fast boot not change the HW devNum during operations.*/
    if (system_recovery.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_HSU_E ||
        system_recovery.systemRecoveryProcess == CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E )
    {
        return GT_OK;
    }

    rc = cpssDxChCfgHwDevNumSet(devNum, hwDevNum);
    if (GT_OK != rc)
    {
        return rc;
    }

    /* system_recovery not change the HW devNum during operations. */
    if (system_recovery.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_NOT_ACTIVE_E)
    {
        return GT_OK;
    }

    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.eArch.supported == GT_FALSE)
    {
        /* no more for those devices */
        return GT_OK;
    }


    /* set all hwDevNum in E2Phy mapping table for all ePorts */
    /* Enable configuration of drop for ARP MAC SA mismatch due to check per port */
        /* Loop on the first 256 (num of physical ports , and CPU port (63)) entries
           of the table */
    numOfPhysicalPorts =
        PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum);

    for(portNum=0; portNum < numOfPhysicalPorts; portNum++)
    {
        rc = cpssDxChBrgEportToPhysicalPortTargetMappingTableGet(devNum,
                                                                 portNum,
                                                                 &physicalInfo);
        if(rc != GT_OK)
        {
            return rc;
        }
        /* If <Target Is Trunk> == 0 && <Use VIDX> == 0 */
        if(physicalInfo.type == CPSS_INTERFACE_PORT_E)
        {
            physicalInfo.devPort.hwDevNum = hwDevNum;
            rc = cpssDxChBrgEportToPhysicalPortTargetMappingTableSet(devNum,
                                                                     portNum,
                                                                     &physicalInfo);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChMicroInitBasicCodeGenerate function
* @endinternal
*
* @brief   This function performs basic and per feature code generation.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Caelum; Aldrin; AC3X.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] ppPhase1ParamsPtr        - Packet processor hardware specific  parameters.
* @param[in] featuresBitmap           - bitmap of cpss features participated in code generation.
* @param[in] hwdevNum                 - HW device number
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_ALREADY_EXIST         - the devNum already in use
* @retval GT_NOT_SUPPORTED         - the device not supported by CPSS
* @retval GT_OUT_OF_CPU_MEM        - failed to allocate CPU memory,
* @retval GT_BAD_VALUE             - the driver found unknown device type
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChMicroInitBasicCodeGenerate
(
    IN CPSS_DXCH_PP_PHASE1_INIT_INFO_STC *ppPhase1ParamsPtr,
    IN GT_U32 featuresBitmap,
    IN GT_U32 hwDevNum
)
{
    GT_STATUS              rc ;
    GT_U8                  devNum;
    CPSS_PP_DEVICE_TYPE    deviceType;
    CPSS_DXCH_PP_PHASE2_INIT_INFO_STC   cpssPpPhase2Info;
    GT_U32      unitIdx, port,i;
    PRV_CPSS_DXCH_PA_WORKSPACE_STC *paWsPtr;
    GT_U32  mg0base;
    CPSS_NULL_PTR_CHECK_MAC(ppPhase1ParamsPtr);
    cpssOsMemSet(&cpssPpPhase2Info,0,sizeof(CPSS_DXCH_PP_PHASE2_INIT_INFO_STC));

    if(ppPhase1ParamsPtr->numOfPortGroups == 0 ||
       ppPhase1ParamsPtr->numOfPortGroups > CPSS_MAX_PORT_GROUPS_CNS)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    devNum = ppPhase1ParamsPtr->devNum;
    /* initialize the cpssDriver , build the DB needed for the device */

    if (DXCH_HWINIT_GLOVAR(dxChHwInitSrc.microInitCpllFirstTime) == GT_TRUE)
    {
        /* close hw write prints */
        rc = cpssDrvPpHwTraceEnable(devNum, CPSS_DRV_HW_TRACE_TYPE_WRITE_DELAY_E, GT_FALSE);
        if(rc != GT_OK)
        {
            return rc;
        }
        rc = hwPpPhase1Part1(ppPhase1ParamsPtr, &deviceType);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = cpssDrvPpHwTraceEnable(devNum, CPSS_DRV_HW_TRACE_TYPE_WRITE_DELAY_E, GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }

        if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            mg0base = prvCpssDxChHwUnitBaseAddrGet(devNum, PRV_CPSS_DXCH_UNIT_MG_E, NULL);
        }
        else
        {
            mg0base = 0;
        }

        if (!PRV_CPSS_SIP_6_CHECK_MAC(devNum))/* no address completion in sip6 devices */
        {
            rc = prvCpssHwPpSetRegField(devNum,0x140,16,1,0);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        rc = prvCpssHwPpSetRegField(devNum,mg0base+0x2800,6,2,3);
        if(rc != GT_OK)
        {
            return rc;
        }
        rc = prvCpssHwPpSetRegField(devNum,mg0base+0x2800,23,2,0);
        if(rc != GT_OK)
        {
            return rc;
        }
        if (PRV_CPSS_PP_MAC(devNum)->devFamily >= CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
        {
            rc = hwPpPhase1Part1_existingUnitsListAtMGInit(devNum);
            if(rc != GT_OK)
            {
                return rc;
            }

            if ( !((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E) &&
                 (PRV_CPSS_PP_MAC(devNum)->devSubFamily == CPSS_PP_SUB_FAMILY_NONE_E)))
            {

                for(i = 0; i < MV_HWS_MAX_CPLL_NUMBER; i++)
                {
                    hwsDeviceSpecInfo[devNum].avagoSerdesInfo.cpllInitDoneStatusArr[i] = GT_FALSE;
                    hwsDeviceSpecInfo[devNum].avagoSerdesInfo.cpllCurrentOutFreqArr[i] = MV_HWS_MAX_OUTPUT_FREQUENCY;
                }
                rc = prvCpssDxChPortCpllConfig(devNum);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
    }
    if ( (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E ||
          PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E ||
          PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN2_E) &&
         (DXCH_HWINIT_GLOVAR(dxChHwInitSrc.microInitCpllFirstTime) == GT_TRUE) )
    {
        DXCH_HWINIT_GLOVAR(dxChHwInitSrc.microInitCpllFirstTime) = GT_FALSE;
        return GT_OK;
    }
    DXCH_HWINIT_GLOVAR(dxChHwInitSrc.microInitCpllFirstTime) = GT_FALSE;
    rc = hwPpSip5StartInitSet(devNum, GT_FALSE);
    if(rc != GT_OK)
    {
        return rc;
    }
    rc = hwPpPhase1Part2(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }
    /* close hw write prints */
    rc = cpssDrvPpHwTraceEnable(devNum, CPSS_DRV_HW_TRACE_TYPE_WRITE_DELAY_E, GT_FALSE);
    if(rc != GT_OK)
    {
        return rc;
    }
    rc = prvCpssDxChTablesAccessInit(devNum, GT_TRUE);
    if(rc != GT_OK)
    {
        return rc;
    }
    /* open hw write prints */

    rc = cpssDrvPpHwTraceEnable(devNum, CPSS_DRV_HW_TRACE_TYPE_WRITE_DELAY_E, GT_TRUE);
    if(rc != GT_OK)
    {
        return rc;
    }
    /* check if EPLR WA is needed */
    if ((featuresBitmap & 0x1) == GT_FALSE)
    {
        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_CAELUM_EGRESS_MEMORIES_NOT_RESET_WA_E);
    }

    /*Set mandatory default register values*/
    rc = mandatoryRegValuesSet(devNum,ppPhase1ParamsPtr);
    if(rc != GT_OK)
    {
        return rc;
    }

    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E) &&
        ((PRV_CPSS_PP_MAC(devNum)->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)) )
    {
     /* Fix default value of BIST register */
        rc = prvCpssDxChDiagBistCaelumFixBist(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* check if Bypass Bridge for Extended DSA tag packets is needed */
    if ((featuresBitmap & 0x2) == GT_FALSE)
    {
        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E);
    }
    rc = hwPpPhase1RegisterMisconfigurationAfterTablesInit(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }
    rc = hwPpPhase1Part5(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }
    /* it is needed for XCAT or XCAT2 */
    rc = hwPpPhase1Part6(devNum, ppPhase1ParamsPtr);
    if(rc != GT_OK)
    {
        return rc;
    }

    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum) && /*bc2,bobk,aldrin,ac3x*/
       !PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        rc = prvCpssDxChPortDynamicPATxQHighSpeedPortInit(devNum);
        if (GT_OK != rc)
        {
            return rc;
        }
    }

     /* close hw write prints */
    rc = cpssDrvPpHwTraceEnable(devNum, CPSS_DRV_HW_TRACE_TYPE_WRITE_DELAY_E, GT_FALSE);
    if(rc != GT_OK)
    {
        return rc;
    }

    cpssPpPhase2Info.auMessageLength = CPSS_AU_MESSAGE_LENGTH_8_WORDS_E;
    cpssPpPhase2Info.newDevNum = 0;
    cpssPpPhase2Info.auqCfg.auDescBlockSize = 0;
    cpssPpPhase2Info.fuqCfg.auDescBlockSize = 0;
    cpssPpPhase2Info.netIfCfg.txDescBlockSize = 0;
    cpssPpPhase2Info.netIfCfg.rxDescBlockSize = 0;
    rc = hwPpPhase2(devNum,&cpssPpPhase2Info);
    if(rc != GT_OK)
    {
        return rc;
    }
    rc = cpssDrvPpHwTraceEnable(devNum, CPSS_DRV_HW_TRACE_TYPE_WRITE_DELAY_E, GT_TRUE);
    if(rc != GT_OK)
    {
        return rc;
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E)
    {
        rc = prvCpssHwPpSetRegField(devNum,0x40000000,1,7,0x3F);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    if (!PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))
    {
        /* handle conserving mode */
        rc = prvCpssDxChPortDynamicPizzaArbiterWSGet(devNum,/*OUT*/&paWsPtr);
        if (rc != GT_OK)
        {
            return rc;
        }
        if (paWsPtr->workConservingModeOnUnitListPtr != NULL)
        {
            for ( unitIdx = 0 ; paWsPtr->workConservingModeOnUnitListPtr[unitIdx] !=  CPSS_DXCH_PA_UNIT_UNDEFINED_E ; unitIdx++)
            {
                rc = cpssDxChPortDynamicPizzaArbiterIfWorkConservingModeSet(devNum,paWsPtr->workConservingModeOnUnitListPtr[unitIdx],GT_TRUE);
                if (GT_OK != rc)
                {
                    return rc;
                }
            }
        }
        for(port = 0; port < CPSS_MAX_PORTS_NUM_CNS; port++)
        {
            if( !(CPSS_PORTS_BMP_IS_PORT_SET_MAC(&PRV_CPSS_PP_MAC(devNum)->existingPorts, port)))
            {
                continue;
            }

            /* split ports between MC FIFOs for Multicast arbiter */
            rc = cpssDxChPortTxMcFifoSet(devNum, port, port%2);
            if( GT_OK != rc )
            {
                return rc;
            }
        }
    }

    /* update E2PHY table with Own Device Num and add it to "device1" file */
    rc = prvCpssDxChHwDevNumChange(devNum,hwDevNum);

    return rc;
}


/**
* @internal cpssDxChMicroInitBasicCodeGenerate function
* @endinternal
*
* @brief   This function performs basic and per feature code generation.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Caelum; Aldrin; AC3X.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] ppPhase1ParamsPtr        - Packet processor hardware specific  parameters.
* @param[in] featuresBitmap           - bitmap of cpss features participated in code generation.
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_ALREADY_EXIST         - the devNum already in use
* @retval GT_NOT_SUPPORTED         - the device not supported by CPSS
* @retval GT_OUT_OF_CPU_MEM        - failed to allocate CPU memory,
* @retval GT_BAD_VALUE             - the driver found unknown device type
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChMicroInitBasicCodeGenerate
(
    IN CPSS_DXCH_PP_PHASE1_INIT_INFO_STC *ppPhase1ParamsPtr,
    IN GT_U32 featuresBitmap,
    IN GT_U32 hwDevNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChMicroInitBasicCodeGenerate);

    CPSS_API_LOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, ppPhase1ParamsPtr, featuresBitmap, hwDevNum));

    rc = internal_cpssDxChMicroInitBasicCodeGenerate(ppPhase1ParamsPtr, featuresBitmap, hwDevNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, ppPhase1ParamsPtr, featuresBitmap, hwDevNum));
    CPSS_API_UNLOCK_DEVICELESS_MAC(PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChUnitInterruptGenerationCheck function
* @endinternal
*
* @brief   This function checks if unit generates interrupt.
*
* @note   APPLICABLE DEVICES:      Bobcat2, Caelum, Aldrin, AC3X, Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - Device number.
* @param[in] causeReg                 - Address of the interrupt cause register.
*
* @retval GT_OK                    - interrupt cause register is in supported unit
* @retval GT_NOT_SUPPORTED         - interrupt cause register is in unsupported unit
*/
static GT_STATUS prvCpssDxChUnitInterruptGenerationCheck
(
    IN GT_SW_DEV_NUM devNum,
    IN GT_U32        causeReg
)
{
    PRV_CPSS_DXCH_UNIT_ENT unit;
    GT_U32                 unitItr; /* unit iterator */
    GT_U32                 unsupportedUnitsArraySize; /* size of prvCpssDxChNoInterruptsGenerationUnits array */

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    unsupportedUnitsArraySize=sizeof(prvCpssDxChNoInterruptsGenerationUnits)/
                              sizeof(prvCpssDxChNoInterruptsGenerationUnits[0]);

    unit =  prvCpssDxChHwRegAddrToUnitIdConvert (devNum, causeReg);

    /* PTP SubUnit of GOP supports interrupt generation starting from Bobk */
    if(PRV_CPSS_SIP_5_15_CHECK_MAC(devNum) && !PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        if((unit == PRV_CPSS_DXCH_UNIT_GOP_E) &&
                ((causeReg & 0x1C0E00) == 0x180800))
        {
            return GT_OK;
        }
    }

    for (unitItr = 0; unitItr < unsupportedUnitsArraySize; unitItr++)
    {
        if (unit == prvCpssDxChNoInterruptsGenerationUnits[unitItr])
        {
            /* Return GT_NOT_SUPPORTED if unit is in list of unsupported units */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }
    }

    if (PRV_CPSS_DXCH_UNIT_MG_E == unit)
    {
        /* MG unit has XSMI sub-units without interrupt generation support */
        if ((causeReg == PRV_DXCH_REG1_UNIT_MG_MAC(devNum).XSMI[0].XSMIInterruptCause) ||
            (causeReg == PRV_DXCH_REG1_UNIT_MG_MAC(devNum).XSMI[1].XSMIInterruptCause))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }

        if ((causeReg == PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->interrupts.rxDmaIntCause) ||
            (causeReg == PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->interrupts.txDmaIntCause))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChGpioPhyConfigSet function
* @endinternal
*
* @brief   Set per-PHY GPIO configuration.
*
* @note   APPLICABLE DEVICES:      AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - connecting physical port number connected to remote ports.
* @param[in] directionBitmap          - For bits 0..15:
*                                      bit#i set means GPIO#i is input,
*                                      bit#i not set means GPIO#i is output
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_FAIL                  - otherwise
*
* @note Applicable only to remote ports on AC3X.
*
*/
static GT_STATUS internal_cpssDxChGpioPhyConfigSet
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    IN  GT_U32                          directionBitmap
)
{
    GT_STATUS rc;
    GT_U32 portMacNum; /* MAC number */
    CPSS_MACDRV_OBJ_STC * portMacObjPtr;/* Get PHY MAC object pointer */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E);
    PRV_CPSS_DXCH_PORT_NUM_CHECK_AND_MAC_NUM_GET_MAC(devNum,portNum,portMacNum);

    portMacObjPtr = PRV_CPSS_PHY_MAC_OBJ(devNum,portMacNum);

    /* run MACPHY callback */
    if (portMacObjPtr != NULL && portMacObjPtr->macDrvMacGpioConfigSetFunc)
    {
        GT_BOOL doPpMacConfig = GT_TRUE;

        rc = portMacObjPtr->macDrvMacGpioConfigSetFunc(devNum,portNum,
                                  directionBitmap,CPSS_MACDRV_STAGE_PRE_E,
                                  &doPpMacConfig);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(doPpMacConfig == GT_FALSE)
        {
            return GT_OK;
        }
    }

    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
}

/**
* @internal cpssDxChGpioPhyConfigSet function
* @endinternal
*
* @brief   Set per-PHY GPIO configuration.
*
* @note   APPLICABLE DEVICES:      AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - connecting physical port number connected to remote ports.
* @param[in] directionBitmap          - For bits 0..15:
*                                      bit#i set means GPIO#i is input,
*                                      bit#i not set means GPIO#i is output
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_FAIL                  - otherwise
*
* @note Applicable only to remote ports on AC3X.
*
*/
GT_STATUS cpssDxChGpioPhyConfigSet
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    IN  GT_U32                          directionBitmap
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChGpioPhyConfigSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, directionBitmap));

    rc = internal_cpssDxChGpioPhyConfigSet(devNum, portNum, directionBitmap);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, directionBitmap));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChGpioPhyConfigGet function
* @endinternal
*
* @brief   Get per-PHY GPIO configuration.
*
* @note   APPLICABLE DEVICES:      AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - connecting physical port number connected to remote ports.
*
* @param[out] modeBitmapPtr            - (Pointer to) For bits 0..15:
*                                      bit#i set means GPIO#i pin can be used as GPIO,
*                                      bit#i not set means GPIO#i pin cannot be used as GPIO
* @param[out] directionBitmapPtr       - (Pointer to) For bits 0..15:
*                                      bit#i set means GPIO#i is input,
*                                      bit#i not set means GPIO#i is output
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_FAIL                  - otherwise
*
* @note Applicable only to remote ports on AC3X.
*
*/
static GT_STATUS internal_cpssDxChGpioPhyConfigGet
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    OUT GT_U32                         *modeBitmapPtr,
    OUT GT_U32                         *directionBitmapPtr
)
{
    GT_STATUS rc;
    GT_U32 portMacNum; /* MAC number */
    CPSS_MACDRV_OBJ_STC * portMacObjPtr;/* Get PHY MAC object pointer */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E);
    PRV_CPSS_DXCH_PORT_NUM_CHECK_AND_MAC_NUM_GET_MAC(devNum,portNum,portMacNum);

    portMacObjPtr = PRV_CPSS_PHY_MAC_OBJ(devNum,portMacNum);

    /* run MACPHY callback */
    if (portMacObjPtr != NULL && portMacObjPtr->macDrvMacGpioConfigGetFunc)
    {
        GT_BOOL doPpMacConfig = GT_TRUE;

        rc = portMacObjPtr->macDrvMacGpioConfigGetFunc(devNum,portNum,
                                  modeBitmapPtr,
                                  directionBitmapPtr,
                                  CPSS_MACDRV_STAGE_PRE_E,
                                  &doPpMacConfig);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(doPpMacConfig == GT_FALSE)
        {
            return GT_OK;
        }
    }

    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
}

/**
* @internal cpssDxChGpioPhyConfigGet function
* @endinternal
*
* @brief   Get per-PHY GPIO configuration.
*
* @note   APPLICABLE DEVICES:      AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - connecting physical port number connected to remote ports.
*
* @param[out] modeBitmapPtr            - (Pointer to) For bits 0..15:
*                                      bit#i set means GPIO#i pin can be used as GPIO,
*                                      bit#i not set means GPIO#i pin cannot be used as GPIO
* @param[out] directionBitmapPtr       - (Pointer to) For bits 0..15:
*                                      bit#i set means GPIO#i is input,
*                                      bit#i not set means GPIO#i is output
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_FAIL                  - otherwise
*
* @note Applicable only to remote ports on AC3X.
*
*/
GT_STATUS cpssDxChGpioPhyConfigGet
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    OUT GT_U32                         *modeBitmapPtr,
    OUT GT_U32                         *directionBitmapPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChGpioPhyConfigGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, modeBitmapPtr, directionBitmapPtr));

    rc = internal_cpssDxChGpioPhyConfigGet(devNum, portNum, modeBitmapPtr, directionBitmapPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, modeBitmapPtr, directionBitmapPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChGpioPhyDataRead function
* @endinternal
*
* @brief   Read per-PHY input GPIO data.
*
* @note   APPLICABLE DEVICES:      AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - connecting physical port number connected to remote ports.
*
* @param[out] dataBitmapPtr            - (Pointer to) Bits 0..15 reflect the input value on
*                                      GPIO pins enabled and configured for input.
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_FAIL                  - otherwise
*
* @note Applicable only to remote ports on AC3X.
*
*/
static GT_STATUS internal_cpssDxChGpioPhyDataRead
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    OUT GT_U32                         *dataBitmapPtr
)
{
    GT_STATUS rc;
    GT_U32 portMacNum; /* MAC number */
    CPSS_MACDRV_OBJ_STC * portMacObjPtr;/* Get PHY MAC object pointer */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E);
    PRV_CPSS_DXCH_PORT_NUM_CHECK_AND_MAC_NUM_GET_MAC(devNum,portNum,portMacNum);

    portMacObjPtr = PRV_CPSS_PHY_MAC_OBJ(devNum,portMacNum);

    /* run MACPHY callback */
    if (portMacObjPtr != NULL && portMacObjPtr->macDrvMacGpioDataReadFunc)
    {
        GT_BOOL doPpMacConfig = GT_TRUE;

        rc = portMacObjPtr->macDrvMacGpioDataReadFunc(devNum,portNum,
                                  dataBitmapPtr,CPSS_MACDRV_STAGE_PRE_E,
                                  &doPpMacConfig);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(doPpMacConfig == GT_FALSE)
        {
            return GT_OK;
        }
    }

    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
}

/**
* @internal cpssDxChGpioPhyDataRead function
* @endinternal
*
* @brief   Read per-PHY input GPIO data.
*
* @note   APPLICABLE DEVICES:      AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - connecting physical port number connected to remote ports.
*
* @param[out] dataBitmapPtr            - (Pointer to) Bits 0..15 reflect the input value on
*                                      GPIO pins enabled and configured for input.
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_FAIL                  - otherwise
*
* @note Applicable only to remote ports on AC3X.
*
*/
GT_STATUS cpssDxChGpioPhyDataRead
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    OUT GT_U32                         *dataBitmapPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChGpioPhyDataRead);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, dataBitmapPtr));

    rc = internal_cpssDxChGpioPhyDataRead(devNum, portNum, dataBitmapPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, dataBitmapPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChGpioPhyDataWrite function
* @endinternal
*
* @brief   Write per-PHY output GPIO data.
*
* @note   APPLICABLE DEVICES:      AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - connecting physical port number connected to remote ports.
* @param[in] dataBitmap               - Bits 0..15 (when not masked) will be the output value on
*                                      GPIO pins enabled and configured for output.
* @param[in] dataBitmapMask           - For bits 0..15:
*                                      bit#i set means corresponding bit at dataBitmap will be used,
*                                      bit#i not set means corresponding bit at dataBitmap will be discarded.
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_FAIL                  - otherwise
*
* @note Applicable only to remote ports on AC3X.
*
*/
static GT_STATUS internal_cpssDxChGpioPhyDataWrite
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    IN  GT_U32                          dataBitmap,
    IN  GT_U32                          dataBitmapMask
)
{
    GT_STATUS rc;
    GT_U32 portMacNum; /* MAC number */
    CPSS_MACDRV_OBJ_STC * portMacObjPtr;/* Get PHY MAC object pointer */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_BOBCAT3_E);
    PRV_CPSS_DXCH_PORT_NUM_CHECK_AND_MAC_NUM_GET_MAC(devNum,portNum,portMacNum);

    portMacObjPtr = PRV_CPSS_PHY_MAC_OBJ(devNum,portMacNum);

    /* run MACPHY callback */
    if (portMacObjPtr != NULL && portMacObjPtr->macDrvMacGpioDataWriteFunc)
    {
        GT_BOOL doPpMacConfig = GT_TRUE;

        rc = portMacObjPtr->macDrvMacGpioDataWriteFunc(devNum,portNum,
                                  dataBitmap,
                                  dataBitmapMask,
                                  CPSS_MACDRV_STAGE_PRE_E,
                                  &doPpMacConfig);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(doPpMacConfig == GT_FALSE)
        {
            return GT_OK;
        }
    }

    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
}

/**
* @internal cpssDxChGpioPhyDataWrite function
* @endinternal
*
* @brief   Write per-PHY output GPIO data.
*
* @note   APPLICABLE DEVICES:      AC3X.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - physical device number
* @param[in] portNum                  - connecting physical port number connected to remote ports.
* @param[in] dataBitmap               - Bits 0..15 (when not masked) will be the output value on
*                                      GPIO pins enabled and configured for output.
* @param[in] dataBitmapMask           - For bits 0..15:
*                                      bit#i set means corresponding bit at dataBitmap will be used,
*                                      bit#i not set means corresponding bit at dataBitmap will be discarded.
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_FAIL                  - otherwise
*
* @note Applicable only to remote ports on AC3X.
*
*/
GT_STATUS cpssDxChGpioPhyDataWrite
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    IN  GT_U32                          dataBitmap,
    IN  GT_U32                          dataBitmapMask
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChGpioPhyDataWrite);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, dataBitmap, dataBitmapMask));

    rc = internal_cpssDxChGpioPhyDataWrite(devNum, portNum, dataBitmap, dataBitmapMask);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, dataBitmap, dataBitmapMask));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/*******************************************************************************
* prvCpssDxChEventGenericConvert
*
* DESCRIPTION:
*       Function convert (if needed) 'IN_evExtData' to 'OUT_evExtData' according
*       to : {uniEvent,evConvertType}
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* NOT APPLICABLE DEVICES:
*         xCat3; AC5; Lion2.
*
* INPUTS:
* @param[in]  devNum            - device number
* @param[in]  uniEvent          - the unified event.
* @param[in]  IN_evExtData      - additional data (port num / lane number / other)
* @param[in]  evConvertType     - convert type for specific event.
* @param[out] OUT_evExtDataPtr  - (pointer to) converted additional data (port num / lane number / other)
*                                      the event was received upon.
*
* RETURNS:
*       GT_OK           - on success
*       GT_BAD_PARAM    - wrong devNum, IN_evExtData
*       GT_BAD_PTR      - on bad pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS prvCpssDxChEventGenericConvert
(
    IN  GT_SW_DEV_NUM                   devNum,
    IN  CPSS_UNI_EV_CAUSE_ENT           uniEvent,
    IN  GT_U32                          IN_evExtData,
    IN  PRV_CPSS_EV_CONVERT_DIRECTION_ENT    evConvertType,
    OUT GT_U32                          *OUT_evExtDataPtr
)
{
    GT_STATUS   rc;
    GT_U32  portBit,portMask;
    GT_U32  portNumFrom,portNumTo;

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(OUT_evExtDataPtr);

    /**********************************/
    /* by default : no convert needed */
    /**********************************/
    *OUT_evExtDataPtr = IN_evExtData;

    if(GT_TRUE == prvCpssDrvEventIsCpuSdmaPortPerQueue((GT_U8)devNum,uniEvent))
    {
        return prvCpssDxChNetifEventSdmaCpuPortConvert(devNum,
            evConvertType,
            IN_evExtData,/*in_queue*/
            OUT_evExtDataPtr);/*out_queue*/
    }

    if(GT_TRUE == prvCpssDrvPpUniEvPerPortHit(uniEvent,&portBit,&portMask))
    {
        /* extract port that will be converted from extended data */
        portNumFrom = IN_evExtData >> portBit;

        if((portNumFrom & MARK_REMOTE_PHYSICAL_PORT_INT_CNS) == MARK_REMOTE_PHYSICAL_PORT_INT_CNS)
        {
            /* remote physical port . need to remove the 'indication' */
            (*OUT_evExtDataPtr) = CLEAR_3_MSBits_MARK_INT_MAC(IN_evExtData);
            return GT_OK;
        }

        rc = prvCpssDxChPortEventPortMapConvert(devNum,
            evConvertType,
            portNumFrom,/*portNumFrom*/
            &portNumTo);/*portNumToPtr*/

        /* set converted port to extended data */
        *OUT_evExtDataPtr  = portNumFrom & ~portMask;
        *OUT_evExtDataPtr |= (portNumTo << portBit);

        return rc;
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChHwPpImplementWaInit_FalconPortDelete function
* @endinternal
*
* @brief   state the dedicated resources needed by the 'PORT DELETE' workaround (WA)
*           in Falcon.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; xCat3; AC5x; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - physical device number
* @param[in] infoPtr                  - (pointer to) the needed info
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_FAIL                  - otherwise
*
* @note None
*
*/
static GT_STATUS internal_cpssDxChHwPpImplementWaInit_FalconPortDelete(
    IN GT_U8                        devNum,
    IN CPSS_DXCH_HW_PP_IMPLEMENT_WA_INIT_FALCON_PORT_DELETE_STC *infoPtr
)
{
    return prvCpssDxChFalconPortDeleteWa_initParams(devNum,infoPtr);
}

/**
* @internal cpssDxChHwPpImplementWaInit_FalconPortDelete function
* @endinternal
*
* @brief   state the dedicated resources needed by the 'PORT DELETE' workaround (WA)
*           in Falcon.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - physical device number
* @param[in] infoPtr                  - (pointer to) the needed info
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_FAIL                  - otherwise
*
* @note None
*
*/
GT_STATUS cpssDxChHwPpImplementWaInit_FalconPortDelete(
    IN GT_U8                        devNum,
    IN CPSS_DXCH_HW_PP_IMPLEMENT_WA_INIT_FALCON_PORT_DELETE_STC *infoPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId,cpssDxChHwPpImplementWaInit_FalconPortDelete);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, infoPtr));

    rc = internal_cpssDxChHwPpImplementWaInit_FalconPortDelete(devNum, infoPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, infoPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}





/**
* @internal prvCpssDxChFalconRavenBitmapSet function
* @endinternal
*
* @brief   Set bitmap of active Ravens in Falcon devices.
*
* @note   APPLICABLE DEVICES:      Falcon.
* @note   NOT APPLICABLE DEVICES:  Lion2; xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum      - the device number
*
*/
static GT_VOID prvCpssDxChFalconRavenBitmapSet
(
    IN GT_U8   devNum
)
{
    GT_U32  numOfTiles = PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->numOfTiles;

    /* Falcon info */
    switch(numOfTiles)
    {
        case 1:
            PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->activeRavensBitmap = 0xF;
            break;
        case 2:
            PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->activeRavensBitmap = 0xFF;
            break;
        default:
            PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->activeRavensBitmap = 0xFFFF;
            break;
    }

    switch (PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->devType)
    {
        case CPSS_98CX8535_CNS:
        case CPSS_98CX8535_H_CNS:
        case CPSS_98CX8514_CNS:
        case CPSS_98EX5614_CNS:
            /* Ravens 0,2,4,5,7 */
            PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->activeRavensBitmap = 0xB5;
            break;
        case CPSS_98CX8530_CNS: /* 6.4T reduced to 4T, 5 ravens out of 8 are in use */
        case CPSS_98CX8512_CNS: /* 6.4T reduced to 2T, 5 ravens out of 8 are in use (SerDes with falcon 4T half speed) */
        case CPSS_98EX5610_CNS:
            /* Ravens 0,2,5,6,7 */
            PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->activeRavensBitmap = 0xE5;
            break;
        case CPSS_98CX8520_CNS: /* 6.4T reduced to 3.2T, 4 ravens out of 8 are in use*/
        case CPSS_98CX8525_CNS:
            /* Ravens 0,2,5,7 */
            PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->activeRavensBitmap = 0xA5;
            break;
        case CPSS_98CX8550_CNS:
            /* Ravens 0,1,2,5,7,8,10,13,14,15 */
            PRV_SHARED_GLOBAL_VAR_CPSS_DRIVER_PP_CONFIG[devNum]->activeRavensBitmap = 0xE5A7;
            break;
        default:
            break;
    }
}

/**
* @internal internal_cpssDxChHwMppSelectSet function
* @endinternal
*
* @brief   Sets value for MPP control register.
*
* @note   APPLICABLE DEVICES:      AC5, AC5X, AC5P, Harrier.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC3X; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; Ironman.
*
* @param[in] devNum                - physical device number
* @param[in] mppNum                - MPP number
* @param[in] mppSelect             - HW value for MPP select.
*                                    See the MPP Function Summary table in the Hardware Specifications for this device
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - device number or MPP select number is wrong
* @retval GT_OUT_OF_RANGE          - MPP select value is out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChHwMppSelectSet
(
    IN  GT_U8                           devNum,
    IN  GT_U32                          mppNum,
    IN  GT_U32                          mppSelect
)
{
    GT_U32    regAddr;                  /* register address */
    GT_U32    fieldOffset;              /* register field offset */
    GT_U32    *regAddrPtr;              /* (pointer to) register address data base structure */
    GT_U32    regsAddrIndex;            /* register index in register address data base */
    GT_U32    maxMppSelectors;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
                                          CPSS_XCAT3_E | CPSS_AC3X_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
                                          CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_IRONMAN_E);

    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_HARRIER_E:
            maxMppSelectors = PRV_CPSS_HARRIER_MAX_MPP_SELECTORS_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_AC5P_E:
            maxMppSelectors = PRV_CPSS_AC5P_MAX_MPP_SELECTORS_NUM_CNS;
            break;
        default:
            maxMppSelectors = PRV_CPSS_MAX_MPP_SELECTORS_NUM_CNS;
    }

    if (mppNum >= maxMppSelectors)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (mppSelect >= BIT_4)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* Pointer to MPP registers database */
        regAddrPtr = &PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->CNM.MPP_RFU.MPPControl0_7;
    }
    else
    {
        /* Pointer to MPP registers database */
        regAddrPtr = &PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->MPP_RFU.MPPControl0_7;
    }

    /* MPP register index */
    regsAddrIndex = mppNum / 8;
    /* MPP select field offset */
    fieldOffset = (mppNum % 8) * 4;
    /* Register address by MPP index */
    regAddr = regAddrPtr[regsAddrIndex];

    /* Set register field */
    return prvCpssHwPpSetRegField(devNum, regAddr, fieldOffset, 4, mppSelect);
}

/**
* @internal cpssDxChHwMppSelectSet function
* @endinternal
*
* @brief   Sets value for MPP control register.
*
* @note   APPLICABLE DEVICES:      AC5, AC5X, AC5P, Harrier.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC3X; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; Ironman.
*
* @param[in] devNum                - physical device number
* @param[in] mppNum                - MPP number
* @param[in] mppSelect             - HW value for MPP select.
*                                    See the MPP Function Summary table in the Hardware Specifications for this device
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - device number or MPP select number is wrong
* @retval GT_OUT_OF_RANGE          - MPP select value is out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChHwMppSelectSet
(
    IN  GT_U8                           devNum,
    IN  GT_U32                          mppNum,
    IN  GT_U32                          mppSelect
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwMppSelectSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mppNum, mppSelect));

    rc = internal_cpssDxChHwMppSelectSet(devNum, mppNum, mppSelect);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mppNum, mppSelect));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChHwMppSelectGet function
* @endinternal
*
* @brief   Gets value for MPP control register.
*
* @note   APPLICABLE DEVICES:      AC5, AC5X, AC5P, Harrier.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC3X; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; Ironman.
*
* @param[in]  devNum               - physical device number
* @param[in]  mppNum               - MPP number
* @param[out] mppSelectPtr         - (pointer to) HW value for MPP select
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - device number or MPP select number is wrong
* @retval GT_BAD_PTR               - pointer to MPP select value is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChHwMppSelectGet
(
    IN  GT_U8                           devNum,
    IN  GT_U32                          mppNum,
    OUT GT_U32                         *mppSelectPtr
)
{
    GT_U32    regAddr;                  /* register address */
    GT_U32    fieldOffset;              /* register field offset */
    GT_U32    *regAddrPtr;              /* (pointer to) register address data base structure */
    GT_U32    regsAddrIndex;            /* register index in register address data base */
    GT_U32    maxMppSelectors;          /* MPP selectors maximal numbers */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
                                          CPSS_XCAT3_E | CPSS_AC3X_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
                                          CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_IRONMAN_E);

    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_HARRIER_E:
            maxMppSelectors = PRV_CPSS_HARRIER_MAX_MPP_SELECTORS_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_AC5P_E:
            maxMppSelectors = PRV_CPSS_AC5P_MAX_MPP_SELECTORS_NUM_CNS;
            break;
        default:
            maxMppSelectors = PRV_CPSS_MAX_MPP_SELECTORS_NUM_CNS;
    }

    if (mppNum >= maxMppSelectors)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    CPSS_NULL_PTR_CHECK_MAC(mppSelectPtr);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* Pointer to MPP registers database */
        regAddrPtr = &PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->CNM.MPP_RFU.MPPControl0_7;
    }
    else
    {
        /* Pointer to MPP registers database */
        regAddrPtr = &PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->MPP_RFU.MPPControl0_7;
    }

    /* MPP register index */
    regsAddrIndex = mppNum / 8;
    /* MPP select field offset */
    fieldOffset = (mppNum % 8) * 4;
    /* Register address by MPP index */
    regAddr = regAddrPtr[regsAddrIndex];

    /* Get register field */
    return prvCpssHwPpGetRegField(devNum, regAddr, fieldOffset, 4, mppSelectPtr);
}

/**
* @internal cpssDxChHwMppSelectGet function
* @endinternal
*
* @brief   Gets value for MPP control register.
*
* @note   APPLICABLE DEVICES:      AC5, AC5X, AC5P, Harrier.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC3X; Lion2; Bobcat2; Caelum; Aldrin; Bobcat3; Aldrin2; Falcon; Ironman.
*
* @param[in]  devNum               - physical device number
* @param[in]  mppNum               - MPP number
* @param[out] mppSelectPtr         - (pointer to) HW value for MPP select
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - device number or MPP select number is wrong
* @retval GT_BAD_PTR               - pointer to MPP select value is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChHwMppSelectGet
(
    IN  GT_U8                           devNum,
    IN  GT_U32                          mppNum,
    OUT GT_U32                         *mppSelectPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwMppSelectGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mppNum, mppSelectPtr));

    rc = internal_cpssDxChHwMppSelectGet(devNum, mppNum, mppSelectPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mppNum, mppSelectPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


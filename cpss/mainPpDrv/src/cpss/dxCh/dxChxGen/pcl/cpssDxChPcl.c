/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
*
*/
/**
********************************************************************************
* @file cpssDxChPcl.c
*
* @brief CPSS CH general PCL API implementation
*
* @version   123
********************************************************************************
*/
#define CPSS_LOG_IN_MODULE_ENABLE
#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChInfo.h>
#include <cpss/dxCh/dxChxGen/pcl/cpssDxChPcl.h>
#include <cpss/dxCh/dxChxGen/pcl/private/prvCpssDxChPcl.h>
#include <cpssDriver/pp/prvCpssDrvPpDefs.h>
#include <cpss/dxCh/dxChxGen/tcam/private/prvCpssDxChTcam.h>
#include <cpss/dxCh/dxChxGen/private/routerTunnelTermTcam/prvCpssDxChRouterTunnelTermTcam.h>
#include <cpss/dxCh/dxChxGen/pcl/private/prvCpssDxChPclLog.h>
#include <cpss/generic/log/prvCpssLog.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDb.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDbInterface.h>
#include <cpss/generic/private/prvCpssCommonDefs.h>



/* used in structures at the places of not relevant values */
/* as offset of not used register address                  */
#define DUMMY8_CNS  0xFF
#define DUMMY32_CNS 0xFFFFFFFF

/* different devices have the same structure of register addresses */
/* but register addresses                                          */
/* the macros below helps to keep in DB not the register address   */
/* but the offset of register address in the structure of register */
/* addresses                                                       */

/* offset from the beginning of structure */
#define MEMBER_OFFSET_MAC(_type, _member)        (GT_UINTPTR)&(((_type*)0)->_member)

/* extract member address by pointer      */
#define MEMBER_POINTER_MAC(_ptr, _offset, _type) \
    (_type*)(((char*)(_ptr)) + (_offset))

/* offset of PCL register */
#define PCL_REG_OFFSET_MAC(_reg) \
    MEMBER_OFFSET_MAC(PRV_CPSS_DXCH_PP_REGS_ADDR_STC, pclRegs._reg)

/* address of PCL register */
#define PCL_REG_ADDRESS_MAC(_devNum, _offset) \
    *(MEMBER_POINTER_MAC(PRV_CPSS_DXCH_DEV_REGS_MAC(_devNum), _offset, GT_U32))

/* UDB pool size for devices under SIP 5.20 */
#define PRV_CPSS_DXCH_PCL_SIP_5_UDB_POOL_SIZE_CNS 50

/* HW values for Cheetah offset types in UDBs */
#define UDB_HW_L2_CNS      0
#define UDB_HW_L3_CNS      1
#define UDB_HW_L4_CNS      2
#define UDB_HW_IPV6EH_CNS  3
/* HW values for XCAT offset types in UDBs */
#define UDB_XCAT_HW_L2_CNS              0
#define UDB_XCAT_HW_MPLS_CNS            1
#define UDB_XCAT_HW_L3_CNS              2
#define UDB_XCAT_HW_L4_CNS              3

#define UDB_DB_L2_CNS      (1 << UDB_HW_L2_CNS)
#define UDB_DB_L3_CNS      (1 << UDB_HW_L3_CNS)
#define UDB_DB_L4_CNS      (1 << UDB_HW_L4_CNS)
#define UDB_DB_IPV6EH_CNS (1 << UDB_HW_IPV6EH_CNS)

#define UDB_DB_L2_L3_CNS   (UDB_DB_L2_CNS | UDB_DB_L3_CNS)
#define UDB_DB_L3_L4_CNS   (UDB_DB_L3_CNS | UDB_DB_L4_CNS)
#define UDB_DB_L2_L3_L4_CNS  \
    (UDB_DB_L2_CNS | UDB_DB_L3_CNS | UDB_DB_L4_CNS)
#define UDB_DB_L2_L3_L4_IPV6EH_CNS \
    (UDB_DB_L2_CNS | UDB_DB_L3_CNS | UDB_DB_L4_CNS | UDB_DB_IPV6EH_CNS)
#define UDB_DB_L3_L4_IPV6EH_CNS \
    (UDB_DB_L3_CNS | UDB_DB_L4_CNS | UDB_DB_IPV6EH_CNS)

/* 10 words in sip5    ipcl 316 bits (for 50 UDBs)
   10 words in sip5    epcl 306 bits (for 50 UDBs)
   16 words in sip5.20 epcl 506 bits (for 70 UDBs) + 12 key bytes replacements
   17 words in sip6.10 epcl 513 bits (for 50 UDBs) + 19 key bytes replacements
*/
#define UDB_SELECTION_WORDS     ((513 + 31)/32)

/* Maximal EPCL UDB index */
/* (APPLICABLE DEVICES: Falcon) */
#define PRV_CPSS_DXCH_EPCL_SIP_6_UDB_MAX_NUMBER_CNS 50

/* Maximal EPCL UDB index */
/* (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman) */
#define PRV_CPSS_DXCH_EPCL_SIP_6_10_UDB_MAX_NUMBER_CNS 60

/* Amount of replaceable UDBs in Ingress UDB only keys */
/* (APPLICABLE DEVICES: Bobcat2, Caelum, Bobcat3; Aldrin2; Falcon; Aldrin, AC3X) */
#define PRV_CPSS_DXCH_PCL_INGRESS_UDB_REPLACE_MAX_SIP_5_CNS  12

/* static variables */

/* HW <==> SW conversion tables for PCL CFG tables key formats */
/* Index is the HW value                                       */

/* xCat IPCL xCat LOOKUP NOT IP */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChXCatSwKeyType_IPCL_NOT_IP[
    PRV_CPSS_DXCH_PCL_CFG_MAX_HW_KEY_TYPES_CNS] =
{
    /* 0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
    /* 1 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E,
    /* 3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /* 4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /* 5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
    /* 6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
    /* 7 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* xCat IPCL xCat LOOKUP IPV4 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChXCatSwKeyType_IPCL_IPV4[
    PRV_CPSS_DXCH_PCL_CFG_MAX_HW_KEY_TYPES_CNS] =
{
    /* 0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
    /* 1 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
    /* 2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E,
    /* 3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /* 4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /* 5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
    /* 6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E,
    /* 7 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};


/* xCat IPCL LOOKUP IPV6 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChXCatSwKeyType_IPCL_IPV6[
    PRV_CPSS_DXCH_PCL_CFG_MAX_HW_KEY_TYPES_CNS] =
{
    /* 0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
    /* 1 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E,
    /* 2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E,
    /* 3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /* 4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /* 5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
    /* 6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E,
    /* 7 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E
};

/* xCat3 EPCL LOOKUP NOT IP */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSwKeyType_EPCL_NOT_IP[
    PRV_CPSS_DXCH_PCL_CFG_MAX_HW_KEY_TYPES_CNS] =
{
    /* 0 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E,
    /* 1 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E,
    /* 2 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E,
    /* 3 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 4 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 5 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 6 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 7 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* xCat3 EPCL LOOKUP IPV4 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSwKeyType_EPCL_IPV4[
    PRV_CPSS_DXCH_PCL_CFG_MAX_HW_KEY_TYPES_CNS] =
{
    /* 0 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E,
    /* 1 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E,
    /* 2 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E,
    /* 3 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E,
    /* 4 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 5 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 6 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 7 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* xCat3 EPCL LOOKUP IPV6 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSwKeyType_EPCL_IPV6[
    PRV_CPSS_DXCH_PCL_CFG_MAX_HW_KEY_TYPES_CNS] =
{
    /* 0 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E,
    /* 1 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E,
    /* 2 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E,
    /* 3 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E,
    /* 4 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 5 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 6 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 7 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* Bobcat2, Caelum IPCL LOOKUP NOT IP */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip5SwKeyType_IPCL_NOT_IP[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
    /*  1 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
    /*  7 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E,
    /* 11 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E,
    /* 12 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E,
    /* 13 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E,
    /* 14 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* Bobcat2, Caelum IPCL LOOKUP IPV4 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip5SwKeyType_IPCL_IPV4[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
    /*  1 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E,
    /*  7 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E,
    /* 11 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E,
    /* 12 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E,
    /* 13 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E,
    /* 14 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* Bobcat2, Caelum IPCL LOOKUP IPV6 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip5SwKeyType_IPCL_IPV6[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
    /*  1 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E,
    /*  7 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E,
    /* 11 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E,
    /* 12 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E,
    /* 13 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E,
    /* 14 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* Bobcat3 IPCL LOOKUP NOT IP */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip520SwKeyType_IPCL_NOT_IP[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
    /*  1 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
    /*  7 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E,
    /* 11 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E,
    /* 12 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E,
    /* 13 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E,
    /* 14 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* SIP6_10 devices */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip6_10SwKeyType_IPCL_NOT_IP[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
    /*  1 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
    /*  7 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E,
    /* 11 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E,
    /* 12 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E,
    /* 13 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E,
    /* 14 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E,
    /* 15 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E /* APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman */
};

/* Bobcat3 IPCL LOOKUP IPV4 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip520SwKeyType_IPCL_IPV4[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
    /*  1 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E,
    /*  7 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E,
    /* 11 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E,
    /* 12 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E,
    /* 13 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E,
    /* 14 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* SIP6_10 IPCL LOOKUP IPV4 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip6_10SwKeyType_IPCL_IPV4[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
    /*  1 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E,
    /*  7 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E,
    /* 11 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E,
    /* 12 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E,
    /* 13 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E,
    /* 14 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E,
    /* 15 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E /* APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman */
};

/* Bobcat3 IPCL LOOKUP IPV6 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip520SwKeyType_IPCL_IPV6[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
    /*  1 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E,
    /*  7 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E,
    /* 11 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E,
    /* 12 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E,
    /* 13 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E,
    /* 14 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* Bobcat3 IPCL LOOKUP IPV6 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip6_10SwKeyType_IPCL_IPV6[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
    /*  1 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E,
    /*  7 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E,
    /* 11 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E,
    /* 12 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E,
    /* 13 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E,
    /* 14 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E,
    /* 15 */ CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E /* APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman */
};

/* Bobcat2, Caelum, Bobcat3 EPCL LOOKUP NOT IP */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip5SwKeyType_EPCL_NOT_IP[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E,
    /*  1 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E,
    /*  3 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E,
    /*  7 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E,
    /* 10 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 11 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 12 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 13 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 14 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* SIP6_10 EPCL LOOKUP NOT IP */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip6_10SwKeyType_EPCL_NOT_IP[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E,
    /*  1 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E,
    /*  3 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E,
    /*  7 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E,
    /* 11 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 12 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 13 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 14 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* Bobcat2, Caelum, Bobcat3 EPCL LOOKUP IPV4 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip5SwKeyType_EPCL_IPV4[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E,
    /*  1 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E,
    /*  7 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E,
    /* 10 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 11 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 12 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 13 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 14 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* SIP6_10 EPCL LOOKUP IPV4 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip6_10SwKeyType_EPCL_IPV4[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E,
    /*  1 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E,
    /*  7 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E,
    /* 11 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 12 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 13 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 14 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* Bobcat2, Caelum, Bobcat3 EPCL LOOKUP IPV6 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip5SwKeyType_EPCL_IPV6[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E,
    /*  1 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E,
    /*  7 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E,
    /* 10 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 11 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 12 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 13 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 14 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/* Bobcat2, Caelum, Bobcat3 EPCL LOOKUP IPV6 */
static const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT prvCpssDxChSip6_10SwKeyType_EPCL_IPV6[] =
{
    /*  0 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E,
    /*  1 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS/*CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E*/,
    /*  2 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E,
    /*  3 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E,
    /*  4 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E,
    /*  5 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E,
    /*  6 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E,
    /*  7 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E,
    /*  8 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E,
    /*  9 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E,
    /* 10 */ CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E,
    /* 11 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 12 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 13 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 14 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS,
    /* 15 */ PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS
};

/**
* @enum SIP5_HW_PACKET_TYPE_ENT
 *
 * @brief IPCL,EPCL supports the SIP5 enumeration
*/
typedef enum{

    /** IPV4 TCP */
    SIP5_HW_PACKET_TYPE_IPV4_TCP_E                ,

    /** IPV4 UDP */
    SIP5_HW_PACKET_TYPE_IPV4_UDP_E                ,

    /** MPLS */
    SIP5_HW_PACKET_TYPE_MPLS_E                    ,

    /** IPV4 Fragment */
    SIP5_HW_PACKET_TYPE_IPV4_FRAGMENT_E           ,

    /** IPV4 Other */
    SIP5_HW_PACKET_TYPE_IPV4_OTHER_E              ,

    /** Ethernet Other */
    SIP5_HW_PACKET_TYPE_ETHERNET_OTHER_E          ,

    /** IPV6 */
    SIP5_HW_PACKET_TYPE_IPV6_E                    ,

    /** IPV6 TCP */
    SIP5_HW_PACKET_TYPE_IPV6_TCP_E                ,

    /** IPV6 UDP */
    SIP5_HW_PACKET_TYPE_IPV6_UDP_E                ,

    /** User Defined Ethertype 0 */
    SIP5_HW_PACKET_TYPE_UDE0_E                    ,

    /** User Defined Ethertype 1 */
    SIP5_HW_PACKET_TYPE_UDE1_E                    ,

    /** User Defined Ethertype 2 */
    SIP5_HW_PACKET_TYPE_UDE2_E                    ,

    /** User Defined Ethertype 3 */
    SIP5_HW_PACKET_TYPE_UDE3_E                    ,

    /** User Defined Ethertype 4 */
    SIP5_HW_PACKET_TYPE_UDE4_E                    ,

    /** User Defined Ethertype 5 */
    SIP5_HW_PACKET_TYPE_UDE5_E                    ,

    /** User Defined Ethertype 6 */
    SIP5_HW_PACKET_TYPE_UDE6_E                    ,

    /** not suppotred packet type */
    SIP5_HW_PACKET_TYPE_INVALID_E = 0xFF

} SIP5_HW_PACKET_TYPE_ENT;
/* convert from CPSS_DXCH_PCL_PACKET_TYPE_ENT to SIP5_HW_PACKET_TYPE_ENT */
static const SIP5_HW_PACKET_TYPE_ENT  sip5ConvertSwPacketTypeToHwValueArr[CPSS_DXCH_PCL_PACKET_TYPE_LAST_E] =
{
/*CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E        */  SIP5_HW_PACKET_TYPE_IPV4_TCP_E          ,
/*CPSS_DXCH_PCL_PACKET_TYPE_IPV4_UDP_E        */  SIP5_HW_PACKET_TYPE_IPV4_UDP_E          ,
/*CPSS_DXCH_PCL_PACKET_TYPE_MPLS_E            */  SIP5_HW_PACKET_TYPE_MPLS_E              ,
/*CPSS_DXCH_PCL_PACKET_TYPE_IPV4_FRAGMENT_E   */  SIP5_HW_PACKET_TYPE_IPV4_FRAGMENT_E     ,
/*CPSS_DXCH_PCL_PACKET_TYPE_IPV4_OTHER_E      */  SIP5_HW_PACKET_TYPE_IPV4_OTHER_E        ,
/*CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E  */  SIP5_HW_PACKET_TYPE_ETHERNET_OTHER_E    ,
/*CPSS_DXCH_PCL_PACKET_TYPE_UDE_E             */  SIP5_HW_PACKET_TYPE_UDE0_E              ,
/*CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E            */  SIP5_HW_PACKET_TYPE_INVALID_E           ,
/*CPSS_DXCH_PCL_PACKET_TYPE_UDE1_E            */  SIP5_HW_PACKET_TYPE_UDE1_E              ,
/*CPSS_DXCH_PCL_PACKET_TYPE_UDE2_E            */  SIP5_HW_PACKET_TYPE_UDE2_E              ,
/*CPSS_DXCH_PCL_PACKET_TYPE_UDE3_E            */  SIP5_HW_PACKET_TYPE_UDE3_E              ,
/*CPSS_DXCH_PCL_PACKET_TYPE_UDE4_E            */  SIP5_HW_PACKET_TYPE_UDE4_E              ,
/*CPSS_DXCH_PCL_PACKET_TYPE_IPV6_TCP_E        */  SIP5_HW_PACKET_TYPE_IPV6_TCP_E          ,
/*CPSS_DXCH_PCL_PACKET_TYPE_IPV6_UDP_E        */  SIP5_HW_PACKET_TYPE_IPV6_UDP_E          ,
/*CPSS_DXCH_PCL_PACKET_TYPE_IPV6_OTHER_E      */  SIP5_HW_PACKET_TYPE_IPV6_E              ,
/*CPSS_DXCH_PCL_PACKET_TYPE_UDE5_E            */  SIP5_HW_PACKET_TYPE_UDE5_E              ,
/*CPSS_DXCH_PCL_PACKET_TYPE_UDE6_E            */  SIP5_HW_PACKET_TYPE_UDE6_E
};


/**
* @enum SIP5_HW_PCL_UDB_ANCHOR_ENT
 *
 * @brief UDB Anchors.
 * IPCL,EPCL supports the SIP5 enumeration.
*/
typedef enum{

    /** L2 */
    SIP5_HW_PCL_UDB_ANCHOR_L2_E            =  0,

    /** MPLS header origin minus 2 bytes */
    SIP5_HW_PCL_UDB_ANCHOR_MPLS_MINUS_2_E  =  1,

    /** L3 header origin minus 2 bytes */
    SIP5_HW_PCL_UDB_ANCHOR_L3_MINUS_2_E    =  2,

    /** L4 */
    SIP5_HW_PCL_UDB_ANCHOR_L4_E            =  3,

    /** @brief TUNNEL L2
     *  SIP5_HW_PCL_UDB_ANCHOR_TUNNEL_L3_E_E  TUNNEL L3
     */
    SIP5_HW_PCL_UDB_ANCHOR_TUNNEL_L2_E     =  4,

    SIP5_HW_PCL_UDB_ANCHOR_TUNNEL_L3_E     =  5,

    /** METADATA */
    SIP5_HW_PCL_UDB_ANCHOR_METADATA_E      =  6,

    /** TUNNEL L4 */
    /* APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman */
    SIP6_10_HW_PCL_UDB_ANCHOR_TUNNEL_L4_E  =  7,

    /** Not supported - conversion table placeholder */
    SIP5_HW_PCL_UDB_ANCHOR_NOT_SUPPORTED_E =  0xFF

} SIP5_HW_PCL_UDB_ANCHOR_ENT;

/* convert from CPSS_DXCH_PCL_OFFSET_TYPE_ENT to  SIP5_HW_PCL_UDB_ANCHOR_ENT*/
static const SIP5_HW_PCL_UDB_ANCHOR_ENT sip5ConvertSwUdbAnchorToHwValueArr[] =
{
    /*CPSS_DXCH_PCL_OFFSET_L2_E,                 */ SIP5_HW_PCL_UDB_ANCHOR_L2_E,
    /*CPSS_DXCH_PCL_OFFSET_L3_E,                 */ SIP5_HW_PCL_UDB_ANCHOR_NOT_SUPPORTED_E,
    /*CPSS_DXCH_PCL_OFFSET_L4_E,                 */ SIP5_HW_PCL_UDB_ANCHOR_L4_E,
    /*CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E,       */ SIP5_HW_PCL_UDB_ANCHOR_NOT_SUPPORTED_E,
    /*CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E, */ SIP5_HW_PCL_UDB_ANCHOR_NOT_SUPPORTED_E,
    /*CPSS_DXCH_PCL_OFFSET_L3_MINUS_2_E,         */ SIP5_HW_PCL_UDB_ANCHOR_L3_MINUS_2_E,
    /*CPSS_DXCH_PCL_OFFSET_MPLS_MINUS_2_E,       */ SIP5_HW_PCL_UDB_ANCHOR_MPLS_MINUS_2_E,
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E,          */ SIP5_HW_PCL_UDB_ANCHOR_TUNNEL_L2_E,
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E,  */ SIP5_HW_PCL_UDB_ANCHOR_TUNNEL_L3_E,
    /*CPSS_DXCH_PCL_OFFSET_METADATA_E,           */ SIP5_HW_PCL_UDB_ANCHOR_METADATA_E,
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L4_E,          */ SIP6_10_HW_PCL_UDB_ANCHOR_TUNNEL_L4_E, /* APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman */
    /*CPSS_DXCH_PCL_OFFSET_INVALID_E             */ SIP5_HW_PCL_UDB_ANCHOR_L2_E
};

/**
* @struct UDB_RANGE_PER_ANCHORS_STC
 *
 * @brief This structure describes Ranges of UDB number and offset
 * per offset type.
 * (APPLICABLE DEVICES: Bobcat2, Caelum, Aldrin, AC3X, Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*/
typedef struct{

    /** The UDB number low (included) bound */
    GT_U32 lowUdb;

    /** The UDB number high (excluded) bound */
    GT_U32 maxUdb;

    /** The Ingress PCL packet offset high (included) bound */
    GT_U32 ingrMaxOffset;

    /** @brief The Egress PCL packet offset high (included) bound
     *  Comments:
     */
    GT_U32 egrMaxOffset;

} UDB_RANGE_PER_ANCHORS_STC;

static const UDB_RANGE_PER_ANCHORS_STC sip5UdbRangePerAnchorArr[] =
{
    /*CPSS_DXCH_PCL_OFFSET_L2_E,                 */ {0,  PRV_CPSS_DXCH_PCL_SIP_5_UDB_POOL_SIZE_CNS, 127, 255},
    /*CPSS_DXCH_PCL_OFFSET_L3_E,                 */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_L4_E,                 */ {0,  PRV_CPSS_DXCH_PCL_SIP_5_UDB_POOL_SIZE_CNS, 127, 255},
    /*CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E,       */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E, */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_L3_MINUS_2_E,         */ {0,  PRV_CPSS_DXCH_PCL_SIP_5_UDB_POOL_SIZE_CNS, 127, 255},
    /*CPSS_DXCH_PCL_OFFSET_MPLS_MINUS_2_E,       */ {0,  PRV_CPSS_DXCH_PCL_SIP_5_UDB_POOL_SIZE_CNS, 127, 20},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E,          */ {0,  PRV_CPSS_DXCH_PCL_SIP_5_UDB_POOL_SIZE_CNS, 62,  18},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E,  */ {0,  PRV_CPSS_DXCH_PCL_SIP_5_UDB_POOL_SIZE_CNS, 56,  64},
    /*CPSS_DXCH_PCL_OFFSET_METADATA_E,           */ {30, PRV_CPSS_DXCH_PCL_SIP_5_UDB_POOL_SIZE_CNS, 127, 255},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L4_E,          */ {0,  0, 0, 0},  /* not applicable */
    /*CPSS_DXCH_PCL_OFFSET_INVALID_E             */ {0,  PRV_CPSS_DXCH_PCL_SIP_5_UDB_POOL_SIZE_CNS, 127, 255}
};

static const UDB_RANGE_PER_ANCHORS_STC sip5_20_UdbRangePerAnchorArr[] =
{
    /*CPSS_DXCH_PCL_OFFSET_L2_E,                 */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 127, 255},
    /*CPSS_DXCH_PCL_OFFSET_L3_E,                 */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_L4_E,                 */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 127, 255},
    /*CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E,       */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E, */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_L3_MINUS_2_E,         */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 127, 255},
    /*CPSS_DXCH_PCL_OFFSET_MPLS_MINUS_2_E,       */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 127, 20},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E,          */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 62, 18},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E,  */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 56, 64},
    /*CPSS_DXCH_PCL_OFFSET_METADATA_E,           */ {30, 50,                               127, 255},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L4_E,          */ {0,  0, 0, 0},  /* not applicable */
    /*CPSS_DXCH_PCL_OFFSET_INVALID_E             */ {0, CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 127, 255}
};

static const UDB_RANGE_PER_ANCHORS_STC sip6_ipcl_UdbRangePerAnchorArr[] =
{
    /*CPSS_DXCH_PCL_OFFSET_L2_E,                 */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_L3_E,                 */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_L4_E,                 */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E,       */ {0,  0, 0, 0}, /* not applicable */
    /*CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E, */ {0,  0, 0, 0}, /* not applicable */
    /*CPSS_DXCH_PCL_OFFSET_L3_MINUS_2_E,         */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_MPLS_MINUS_2_E,       */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 159, 20},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E,          */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 62, 18},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E,  */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 56, 64},
    /*CPSS_DXCH_PCL_OFFSET_METADATA_E,           */ {30, 66,                              159, 101},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L4_E,          */ {0,  0, 0, 0},  /* not applicable */
    /*CPSS_DXCH_PCL_OFFSET_INVALID_E             */ {0, CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 159, 127}
};

static const UDB_RANGE_PER_ANCHORS_STC sip6_epcl_UdbRangePerAnchorArr[] =
{
    /*CPSS_DXCH_PCL_OFFSET_L2_E,                 */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_L3_E,                 */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_L4_E,                 */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E,       */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E, */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_L3_MINUS_2_E,         */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_MPLS_MINUS_2_E,       */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_UDB_MAX_NUMBER_CNS, 159, 20},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E,          */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_UDB_MAX_NUMBER_CNS, 62, 18},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E,  */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_UDB_MAX_NUMBER_CNS, 56, 64},
    /*CPSS_DXCH_PCL_OFFSET_METADATA_E,           */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_UDB_MAX_NUMBER_CNS, 159, 101},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L4_E,          */ {0,  0, 0, 0},  /* not applicable */
    /*CPSS_DXCH_PCL_OFFSET_INVALID_E             */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_UDB_MAX_NUMBER_CNS, 159, 127}
};

static const UDB_RANGE_PER_ANCHORS_STC sip6_10_epcl_UdbRangePerAnchorArr[] =
{
    /*CPSS_DXCH_PCL_OFFSET_L2_E,                 */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_10_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_L3_E,                 */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_L4_E,                 */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_10_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E,       */ {0,  0, 0, 0},  /* not applicable */
    /*CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E, */ {0,  0, 0, 0},  /* not applicable */
    /*CPSS_DXCH_PCL_OFFSET_L3_MINUS_2_E,         */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_10_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_MPLS_MINUS_2_E,       */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_10_UDB_MAX_NUMBER_CNS, 159, 20},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E,          */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_10_UDB_MAX_NUMBER_CNS, 62, 18},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E,  */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_10_UDB_MAX_NUMBER_CNS, 56, 64},
    /*CPSS_DXCH_PCL_OFFSET_METADATA_E,           */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_10_UDB_MAX_NUMBER_CNS, 178, 116},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L4_E,          */ {0,  0, 0, 0},  /* not applicable */
    /*CPSS_DXCH_PCL_OFFSET_INVALID_E             */ {0,  PRV_CPSS_DXCH_EPCL_SIP_6_10_UDB_MAX_NUMBER_CNS, 159, 127}
};

static const UDB_RANGE_PER_ANCHORS_STC sip6_10_ipcl_UdbRangePerAnchorArr[] =
{
    /*CPSS_DXCH_PCL_OFFSET_L2_E,                 */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_L3_E,                 */ {0,  0, 0, 0},
    /*CPSS_DXCH_PCL_OFFSET_L4_E,                 */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E,       */ {0,  0, 0, 0},  /* not applicable */
    /*CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E, */ {0,  0, 0, 0},  /* not applicable */
    /*CPSS_DXCH_PCL_OFFSET_L3_MINUS_2_E,         */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 159, 127},
    /*CPSS_DXCH_PCL_OFFSET_MPLS_MINUS_2_E,       */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 159, 20},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E,          */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 62, 18},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E,  */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 56, 64},
    /*CPSS_DXCH_PCL_OFFSET_METADATA_E,           */ {30, 66,                              178, 116},
    /*CPSS_DXCH_PCL_OFFSET_TUNNEL_L4_E,          */ {0,  CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 24, 8},
    /*CPSS_DXCH_PCL_OFFSET_INVALID_E             */ {0, CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS, 159, 127}
};

/*******************************************************************************
* sip5UdbSelectionEntryFormatInfoGet
*
* DESCRIPTION:
*   info about field format in the IPCL/EPCL UDB Select Entry
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* NOT APPLICABLE DEVICES:
*        xCat3; AC5; Lion2.
*
* INPUTS:
*       devNum       - device number
*       isEgress     - indication if EPCL or IPCL
* OUTPUTS:
*       numMaxUdbsPtr         - (pointer to) max number of UDBs
*       numBitsPerUdbPtr      - (pointer to) number of bits for field of :
*                               The decimal UDB number in the global UDB pool
*                               that is selected as UDB #n in this UDB key.
*       startBitsAfterUdbsPtr - (pointer to) bit index after the UDBs.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on wrong parameter
*
* COMMENTS:
*
*******************************************************************************/
static void sip5UdbSelectionEntryFormatInfoGet(
    IN   GT_U8    devNum,
    IN   GT_BOOL  isEgress,
    OUT  GT_U32   *numMaxUdbsPtr,
    OUT  GT_U32   *numBitsPerUdbPtr,
    OUT  GT_U32   *startBitsAfterUdbsPtr
);

/**
* @internal prvCpssDxChPclHwToSwCnvArrGet function
* @endinternal
*
* @brief   The function calculates address of 8-elements array of SW values
*         for 3-bit key type HW fields in PCL Configuration tables
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] direction                - ingress or egress PCL key
* @param[in] pktType                  - NOT-IP, IPV4 or IPV6 packet
*
* @param[out] hwToSwCnvPtrPtr          - pointer to array of SW values
* @param[out] hwToSwCnvArraySizePtr    - (pointer to) size of array of SW values
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
*
* @note NONE
*
*/
static GT_STATUS prvCpssDxChPclHwToSwCnvArrGet
(
    IN  GT_U8                              devNum,
    IN  CPSS_PCL_DIRECTION_ENT             direction,
    IN  GT_U32                             pktType,
    OUT const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT **hwToSwCnvPtrPtr,
    OUT GT_U32                             *hwToSwCnvArraySizePtr
)
{
    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* Bobcat2, Caelum, Bobcat3 */

        *hwToSwCnvArraySizePtr = 16;

        switch (direction)
        {
            case CPSS_PCL_DIRECTION_INGRESS_E:
                if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    switch (pktType)
                    {
                        case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_NOT_IP_CNS:
                            if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
                            {
                                *hwToSwCnvPtrPtr = prvCpssDxChSip6_10SwKeyType_IPCL_NOT_IP;
                            }
                            else
                            {
                                *hwToSwCnvPtrPtr = prvCpssDxChSip520SwKeyType_IPCL_NOT_IP;
                            }
                            break;
                        case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV4_CNS:
                            if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
                            {
                                *hwToSwCnvPtrPtr = prvCpssDxChSip6_10SwKeyType_IPCL_IPV4;
                            }
                            else
                            {
                                *hwToSwCnvPtrPtr = prvCpssDxChSip520SwKeyType_IPCL_IPV4;
                            }
                            break;
                        case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV6_CNS:
                            if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
                            {
                                *hwToSwCnvPtrPtr = prvCpssDxChSip6_10SwKeyType_IPCL_IPV6;
                            }
                            else
                            {
                                *hwToSwCnvPtrPtr = prvCpssDxChSip520SwKeyType_IPCL_IPV6;
                            }
                            break;
                        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                    }
                }
                else
                {
                    switch (pktType)
                    {
                        case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_NOT_IP_CNS:
                            *hwToSwCnvPtrPtr = prvCpssDxChSip5SwKeyType_IPCL_NOT_IP;
                            break;
                        case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV4_CNS:
                            *hwToSwCnvPtrPtr = prvCpssDxChSip5SwKeyType_IPCL_IPV4;
                            break;
                        case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV6_CNS:
                            *hwToSwCnvPtrPtr = prvCpssDxChSip5SwKeyType_IPCL_IPV6;
                            break;
                        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                    }
                }
                break;
            case CPSS_PCL_DIRECTION_EGRESS_E:
                switch (pktType)
                {
                    case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_NOT_IP_CNS:
                        if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
                        {
                            *hwToSwCnvPtrPtr = prvCpssDxChSip6_10SwKeyType_EPCL_NOT_IP;
                        }
                        else
                        {
                            *hwToSwCnvPtrPtr = prvCpssDxChSip5SwKeyType_EPCL_NOT_IP;
                        }
                        break;
                    case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV4_CNS:
                        if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
                        {
                            *hwToSwCnvPtrPtr = prvCpssDxChSip6_10SwKeyType_EPCL_IPV4;
                        }
                        else
                        {
                            *hwToSwCnvPtrPtr = prvCpssDxChSip5SwKeyType_EPCL_IPV4;
                        }
                        break;
                    case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV6_CNS:
                        if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
                        {
                            *hwToSwCnvPtrPtr = prvCpssDxChSip6_10SwKeyType_EPCL_IPV6;
                        }
                        else
                        {
                            *hwToSwCnvPtrPtr = prvCpssDxChSip5SwKeyType_EPCL_IPV6;
                        }

                        break;
                    default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                break;
            default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        return GT_OK;
    }

    /* for not EARCH devices - 8 values in table */
    *hwToSwCnvArraySizePtr = PRV_CPSS_DXCH_PCL_CFG_MAX_HW_KEY_TYPES_CNS;

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            /* xCat3, Lion2 */
            switch (pktType)
            {
                case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_NOT_IP_CNS:
                    *hwToSwCnvPtrPtr = prvCpssDxChXCatSwKeyType_IPCL_NOT_IP;
                    break;
                case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV4_CNS:
                    *hwToSwCnvPtrPtr = prvCpssDxChXCatSwKeyType_IPCL_IPV4;
                    break;
                case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV6_CNS:
                    *hwToSwCnvPtrPtr = prvCpssDxChXCatSwKeyType_IPCL_IPV6;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;
        case CPSS_PCL_DIRECTION_EGRESS_E:
            switch (pktType)
            {
                case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_NOT_IP_CNS:
                    *hwToSwCnvPtrPtr = prvCpssDxChSwKeyType_EPCL_NOT_IP;
                    break;
                case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV4_CNS:
                    *hwToSwCnvPtrPtr = prvCpssDxChSwKeyType_EPCL_IPV4;
                    break;
                case PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV6_CNS:
                    *hwToSwCnvPtrPtr = prvCpssDxChSwKeyType_EPCL_IPV6;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    return GT_OK;
}

/**
* @internal prvCpssDxChPclKeyTypeHwToSw function
* @endinternal
*
* @brief   The function converts HW CFG table key type value to SW value.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] direction                - ingress or egress PCL key
* @param[in] pktType                  - NOT-IP, IPV4 or IPV6 packet
* @param[in] hwKeyType                - HW CFG table key type value
*
* @param[out] swKeyTypePtr             - pointer to SW CFG table key type value
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_STATE             - unsupported HW value
*
* @note NONE
*
*/
static GT_STATUS prvCpssDxChPclKeyTypeHwToSw
(
    IN  GT_U8                              devNum,
    IN  CPSS_PCL_DIRECTION_ENT             direction,
    IN  GT_U32                             pktType,
    IN  GT_U32                             hwKeyType,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT *swKeyTypePtr
)
{
    const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT *hwToSwCnvArrPtr; /* CNV table    */
    GT_STATUS                           rc;              /* return code  */
    GT_U32                              hwKeyRange;      /* HW Key Range */

    /* select HW <==> SW convertion table */
    rc = prvCpssDxChPclHwToSwCnvArrGet(
        devNum, direction, pktType, &hwToSwCnvArrPtr, &hwKeyRange);
    if (rc != GT_OK)
    {
        return rc;
    }

    if (hwKeyType >= hwKeyRange)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* convert using HW value as index */
    *swKeyTypePtr = hwToSwCnvArrPtr[hwKeyType];

    return (*swKeyTypePtr == PRV_CPSS_DXCH_PCL_CFG_DUMMY_SW_KEY_TYPE_CNS)
            ? GT_BAD_STATE : GT_OK;
}

/**
* @internal prvCpssDxChPclKeyTypeSwToHw function
* @endinternal
*
* @brief   The function converts SW CFG table key type value to HW value.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] direction                - ingress or egress PCL key
* @param[in] pktType                  - NOT-IP, IPV4 or IPV6 packet
* @param[in] swKeyType                - SW CFG table key type value
*
* @param[out] hwKeyTypePtr             - pointer to HW CFG table key type value
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
*
* @note NONE
*
*/
static GT_STATUS prvCpssDxChPclKeyTypeSwToHw
(
    IN  GT_U8                              devNum,
    IN  CPSS_PCL_DIRECTION_ENT             direction,
    IN  GT_U32                             pktType,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT swKeyType,
    OUT GT_U32                             *hwKeyTypePtr
)
{
    const CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT *hwToSwCnvArrPtr; /* CNV table    */
    GT_STATUS                           rc;              /* return code  */
    GT_U32                              i;               /* loop counter */
    GT_U32                              hwKeyRange;      /* HW Key Range */


    /* select HW <==> SW convertion table */
    rc = prvCpssDxChPclHwToSwCnvArrGet(
        devNum, direction, pktType, &hwToSwCnvArrPtr, &hwKeyRange);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* search SW value in the table - the index is HW value */
    for (i = 0; (i < hwKeyRange); i++)
    {
        if (hwToSwCnvArrPtr[i] == swKeyType)
        {
            *hwKeyTypePtr = i;
            return GT_OK;
        }
    }

    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
}

/**
* @internal internal_cpssDxChPclInit function
* @endinternal
*
* @brief   The function initializes the device for following configuration
*         and using Policy engine
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
*
* @note NONE
*
*/
static GT_STATUS internal_cpssDxChPclInit
(
    IN GT_U8                           devNum
)
{
    /* this function is reserved */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    return GT_OK;
}

/**
* @internal cpssDxChPclInit function
* @endinternal
*
* @brief   The function initializes the device for following configuration
*         and using Policy engine
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
*
* @note NONE
*
*/
GT_STATUS cpssDxChPclInit
(
    IN GT_U8                           devNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclInit);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum));

    rc = internal_cpssDxChPclInit(devNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChXCatPclUDBEntryIndexGet function
* @endinternal
*
* @brief   The function gets the User Defined Byte Entry index
*         Relevant for Ingress PCL only.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number
* @param[in] packetType               - packet Type
* @param[in] udbIndex                 - index of UDB specified by application
*
* @param[out] entryIndexPtr            - (pointer to) User Defined Byte Entry index
* @param[out] internalIndexPtr         - (pointer to) internal index of UDB in the entry
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS prvCpssDxChXCatPclUDBEntryIndexGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  GT_U32                               udbIndex,
    OUT GT_U32                               *entryIndexPtr,
    OUT GT_U32                               *internalIndexPtr
)
{
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if (packetType > CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E)
    {
        /* assumed that the device is Lion2 and above (but not sip5) */
        /* the UDE1-4 packet types supported by Lion2 and above only */
        if (PRV_CPSS_DXCH_LION_FAMILY_CHECK_MAC(devNum) == 0)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    switch (packetType)
    {
        case CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E:
            *entryIndexPtr = 0;
            break;
        case CPSS_DXCH_PCL_PACKET_TYPE_IPV4_UDP_E:
            *entryIndexPtr = 1;
            break;
        case CPSS_DXCH_PCL_PACKET_TYPE_MPLS_E:
            *entryIndexPtr = 2;
            break;
        case CPSS_DXCH_PCL_PACKET_TYPE_IPV4_FRAGMENT_E:
            *entryIndexPtr = 3;
            break;
        case CPSS_DXCH_PCL_PACKET_TYPE_IPV4_OTHER_E:
            *entryIndexPtr = 4;
            break;
        case CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E:
            *entryIndexPtr = 5;
            break;
        case CPSS_DXCH_PCL_PACKET_TYPE_UDE_E:
            *entryIndexPtr = 6;
            break;
        case CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E:
            *entryIndexPtr = 7;
            break;
        case CPSS_DXCH_PCL_PACKET_TYPE_UDE1_E:
            *entryIndexPtr = 8;
            break;
        case CPSS_DXCH_PCL_PACKET_TYPE_UDE2_E:
            *entryIndexPtr = 9;
            break;
        case CPSS_DXCH_PCL_PACKET_TYPE_UDE3_E:
            *entryIndexPtr = 10;
            break;
        case CPSS_DXCH_PCL_PACKET_TYPE_UDE4_E:
            *entryIndexPtr = 11;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* default assignment */
    *internalIndexPtr = udbIndex;

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) != GT_FALSE)
    {
        if (udbIndex > 42)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        if (udbIndex > 22)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;
}

/**
* @internal sip5PclUDBEntryIndexGet function
* @endinternal
*
* @brief   The function gets the User Defined Byte Entry index.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] packetType               - packet Type
*
* @param[out] entryIndexPtr            - (pointer to) User Defined Byte Entry index
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
*/
GT_STATUS sip5PclUDBEntryIndexGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    OUT GT_U32                               *entryIndexPtr
)
{
    devNum = devNum;

    if(packetType >= CPSS_DXCH_PCL_PACKET_TYPE_LAST_E)
    {
        /* check for access violation into the array of
            sip5ConvertSwPacketTypeToHwValueArr[] */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    *entryIndexPtr = (GT_U32)(sip5ConvertSwPacketTypeToHwValueArr[packetType]);

    if (*entryIndexPtr == SIP5_HW_PACKET_TYPE_INVALID_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "packetType[%d] is not valid for the device",
            packetType);
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChPclUserDefinedByteSet function
* @endinternal
*
* @brief   The function configures the User Defined Byte (UDB)
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
*                                      Relevant for DxCh3 devices
* @param[in] packetType               - packet Type
*                                      Used for Ingress Only
*                                      (APPLICABLE DEVICES xCat3; AC5; Lion2.)
*                                      Used for Ingress and Egress
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.)
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress.(APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      Ignored, configure ingress.
*                                      (APPLICABLE DEVICES xCat3; AC5)
* @param[in] udbIndex                 - index of User Defined Byte to configure.
*                                      See format of rules to known indexes of UDBs
* @param[in] offset                   - the type of offset (see CPSS_DXCH_PCL_OFFSET_TYPE_ENT)
* @param[in] offset                   - The  of the user-defined byte, in bytes,from the
*                                      place in the packet indicated by the offset type
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_OUT_OF_RANGE          - parameter value more than HW bit field
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note See comments to CPSS_DXCH_PCL_OFFSET_TYPE_ENT
*
*/
static GT_STATUS internal_cpssDxChPclUserDefinedByteSet
(
    IN GT_U8                                devNum,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN CPSS_PCL_DIRECTION_ENT               direction,
    IN GT_U32                               udbIndex,
    IN CPSS_DXCH_PCL_OFFSET_TYPE_ENT        offsetType,
    IN GT_U8                                offset
)
{
    return cpssDxChPclPortGroupUserDefinedByteSet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        ruleFormat, packetType, direction, udbIndex,
        offsetType, offset);

}

/**
* @internal cpssDxChPclUserDefinedByteSet function
* @endinternal
*
* @brief   The function configures the User Defined Byte (UDB)
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
*                                      Relevant for DxCh3 devices
* @param[in] packetType               - packet Type
*                                      Used for Ingress Only
*                                      (APPLICABLE DEVICES xCat3; AC5; Lion2.)
*                                      Used for Ingress and Egress
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.)
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress.(APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      Ignored, configure ingress.
*                                      (APPLICABLE DEVICES xCat3; AC5)
* @param[in] udbIndex                 - index of User Defined Byte to configure.
*                                      See format of rules to known indexes of UDBs
* @param[in] offset                   - the type of offset (see CPSS_DXCH_PCL_OFFSET_TYPE_ENT)
* @param[in] offset                   - The  of the user-defined byte, in bytes,from the
*                                      place in the packet indicated by the offset type
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_OUT_OF_RANGE          - parameter value more than HW bit field
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note See comments to CPSS_DXCH_PCL_OFFSET_TYPE_ENT
*
*/
GT_STATUS cpssDxChPclUserDefinedByteSet
(
    IN GT_U8                                devNum,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN CPSS_PCL_DIRECTION_ENT               direction,
    IN GT_U32                               udbIndex,
    IN CPSS_DXCH_PCL_OFFSET_TYPE_ENT        offsetType,
    IN GT_U8                                offset
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclUserDefinedByteSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ruleFormat, packetType, direction, udbIndex, offsetType, offset));

    rc = internal_cpssDxChPclUserDefinedByteSet(devNum, ruleFormat, packetType, direction, udbIndex, offsetType, offset);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ruleFormat, packetType, direction, udbIndex, offsetType, offset));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclUserDefinedByteGet function
* @endinternal
*
* @brief   The function gets the User Defined Byte (UDB) configuration
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
*                                      Relevant for DxCh3 devices
* @param[in] packetType               - packet Type
*                                      Used for Ingress Only
*                                      (APPLICABLE DEVICES xCat3; AC5; Lion2.)
*                                      Used for Ingress and Egress
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.)
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress.(APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      Ignored, configure ingress.
*                                      (APPLICABLE DEVICES xCat3; AC5)
* @param[in] udbIndex                 - index of User Defined Byte to configure.
*                                      See format of rules to known indexes of UDBs
*
* @param[out] offsetTypePtr            - (pointer to) The type of offset
*                                      (see CPSS_DXCH_PCL_OFFSET_TYPE_ENT)
* @param[out] offsetPtr                - (pointer to) The offset of the user-defined byte,
*                                      in bytes,from the place in the packet
*                                      indicated by the offset type.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note See comments to CPSS_DXCH_PCL_OFFSET_TYPE_ENT
*
*/
static GT_STATUS internal_cpssDxChPclUserDefinedByteGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_DIRECTION_ENT               direction,
    IN  GT_U32                               udbIndex,
    OUT CPSS_DXCH_PCL_OFFSET_TYPE_ENT        *offsetTypePtr,
    OUT GT_U8                                *offsetPtr
)
{
    return cpssDxChPclPortGroupUserDefinedByteGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        ruleFormat, packetType, direction, udbIndex,
        offsetTypePtr, offsetPtr);
}

/**
* @internal cpssDxChPclUserDefinedByteGet function
* @endinternal
*
* @brief   The function gets the User Defined Byte (UDB) configuration
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
*                                      Relevant for DxCh3 devices
* @param[in] packetType               - packet Type
*                                      Used for Ingress Only
*                                      (APPLICABLE DEVICES xCat3; AC5; Lion2.)
*                                      Used for Ingress and Egress
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.)
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress.(APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      Ignored, configure ingress.
*                                      (APPLICABLE DEVICES xCat3; AC5)
* @param[in] udbIndex                 - index of User Defined Byte to configure.
*                                      See format of rules to known indexes of UDBs
*
* @param[out] offsetTypePtr            - (pointer to) The type of offset
*                                      (see CPSS_DXCH_PCL_OFFSET_TYPE_ENT)
* @param[out] offsetPtr                - (pointer to) The offset of the user-defined byte,
*                                      in bytes,from the place in the packet
*                                      indicated by the offset type.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note See comments to CPSS_DXCH_PCL_OFFSET_TYPE_ENT
*
*/
GT_STATUS cpssDxChPclUserDefinedByteGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_DIRECTION_ENT               direction,
    IN  GT_U32                               udbIndex,
    OUT CPSS_DXCH_PCL_OFFSET_TYPE_ENT        *offsetTypePtr,
    OUT GT_U8                                *offsetPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclUserDefinedByteGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ruleFormat, packetType, direction, udbIndex, offsetTypePtr, offsetPtr));

    rc = internal_cpssDxChPclUserDefinedByteGet(devNum, ruleFormat, packetType, direction, udbIndex, offsetTypePtr, offsetPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ruleFormat, packetType, direction, udbIndex, offsetTypePtr, offsetPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclRuleSet function
* @endinternal
*
* @brief   The function sets the Policy Rule Mask, Pattern and Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleFormat               - format of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM. The rule index defines
*                                      order of action resolution in the cases of multiple
*                                      rules match with packet's search key. Action of the
*                                      matched rule with lowest index is taken in this case
*                                      With reference to Standard and Extended rules
*                                      indexes, the partitioning is as follows:
*                                      For xCat3 and above devices:
*                                      See datasheet of particular device for TCAM size.
*                                      For example describe the TCAM that has 1/4K (256) rows.
*                                      Each row can be used as:
*                                      - 4 standard rules
*                                      - 2 extended rules
*                                      - 1 extended and 2 standard rules
*                                      - 2 standard and 1 extended rules
*                                      The TCAM partitioning is as follows:
*                                      - Standard rules.
*                                      Rule index may be in the range from 0 up to 1K (1024).
*                                      - Extended rules.
*                                      Rule index may be in the range from 0 up to 0.5K (512).
*                                      Extended rule consumes the space of two standard
*                                      rules:
*                                      - Extended rule with index 2n (even index)
*                                      is placed in the space of two standard rules with
*                                      indexes 4n and 4n + 1.
*                                      - Extended rule with index 2n+1 (odd index)
*                                      is placed in the space of two standard rules with
*                                      indexes 4n+2 and 4n + 3.
* @param[in] ruleOptionsBmp           - Bitmap of rule's options.
*                                      The CPSS_DXCH_PCL_RULE_OPTION_ENT defines meaning of each bit.
*                                      Samples:
* @param[in] ruleOptionsBmp           = 0 - no options are defined.
*                                      Rule state is valid.
* @param[in] ruleOptionsBmp           = CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E -
*                                      write all fields of rule to TCAM but rule's
*                                      state is invalid (no match during lookups).
* @param[in] maskPtr                  - rule mask. The rule mask is AND styled one. Mask
*                                      bit's 0 means don't care bit (corresponding bit in
*                                      the pattern is not using in the TCAM lookup).
*                                      Mask bit's 1 means that corresponding bit in the
*                                      pattern is using in the TCAM lookup.
*                                      The format of mask is defined by ruleFormat
* @param[in] patternPtr               - rule pattern.
*                                      The format of pattern is defined by ruleFormat
* @param[in] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The pattern and mask input structures should be set to zero
*       by an application before assignment of fields.
*       The function places all muxed fields to rule patern and mask
*       by using bitwise OR operation.
*       The function does not check validity of muxed (overlapped) fields.
*
*/
static GT_STATUS internal_cpssDxChPclRuleSet
(
    IN GT_U8                                            devNum,
    IN GT_U32                                           tcamIndex,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               ruleFormat,
    IN GT_U32                                           ruleIndex,
    IN CPSS_DXCH_PCL_RULE_OPTION_ENT                    ruleOptionsBmp,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *maskPtr,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *patternPtr,
    IN CPSS_DXCH_PCL_ACTION_STC                         *actionPtr
)
{
    return cpssDxChPclPortGroupRuleSet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, tcamIndex,
        ruleFormat, ruleIndex, ruleOptionsBmp,
        maskPtr, patternPtr, actionPtr);
}

/**
* @internal cpssDxChPclRuleSet function
* @endinternal
*
* @brief   The function sets the Policy Rule Mask, Pattern and Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleFormat               - format of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM. The rule index defines
*                                      order of action resolution in the cases of multiple
*                                      rules match with packet's search key. Action of the
*                                      matched rule with lowest index is taken in this case
*                                      With reference to Standard and Extended rules
*                                      indexes, the partitioning is as follows:
*                                      For DxCh and DxCh2 devices:
*                                      - Standard rules.
*                                      Rule index may be in the range from 0 up to 1023.
*                                      - Extended rules.
*                                      Rule index may be in the range from 0 up to 511.
*                                      Extended rule consumes the space of two standard
*                                      rules:
*                                      - Extended rule with index  0 <= n <= 511
*                                      is placed in the space of two standard rules with
*                                      indexes n and n + 512.
*                                      For DxCh3 device:
*                                      The TCAM has up to 3.5K (3584) rows.
*                                      See datasheet of particular device for TCAM size.
*                                      Each row can be used as:
*                                      - 4 standard rules
*                                      - 2 extended rules
*                                      - 1 extended and 2 standard rules
*                                      - 2 standard and 1 extended rules
*                                      The TCAM partitioning is as follows:
*                                      - Standard rules.
*                                      Rule index may be in the range from 0 up to 14335.
*                                      - Extended rules.
*                                      Rule index may be in the range from 0 up to 7167.
*                                      Extended rule consumes the space of two standard
*                                      rules:
*                                      - Extended rule with index  0 <= n < 3584
*                                      is placed in the space of two standard rules with
*                                      indexes n and n + 3584.
*                                      - Extended rule with index  3584 <= n < 7168
*                                      is placed in the space of two standard rules with
*                                      indexes n + 3584, n + 7168.
*                                      For xCat3 and above devices:
*                                      See datasheet of particular device for TCAM size.
*                                      For example describe the TCAM that has 1/4K (256) rows.
*                                      Each row can be used as:
*                                      - 4 standard rules
*                                      - 2 extended rules
*                                      - 1 extended and 2 standard rules
*                                      - 2 standard and 1 extended rules
*                                      The TCAM partitioning is as follows:
*                                      - Standard rules.
*                                      Rule index may be in the range from 0 up to 1K (1024).
*                                      - Extended rules.
*                                      Rule index may be in the range from 0 up to 0.5K (512).
*                                      Extended rule consumes the space of two standard
*                                      rules:
*                                      - Extended rule with index 2n (even index)
*                                      is placed in the space of two standard rules with
*                                      indexes 4n and 4n + 1.
*                                      - Extended rule with index 2n+1 (odd index)
*                                      is placed in the space of two standard rules with
*                                      indexes 4n+2 and 4n + 3.
* @param[in] ruleOptionsBmp           - Bitmap of rule's options.
*                                      The CPSS_DXCH_PCL_RULE_OPTION_ENT defines meaning of each bit.
*                                      Samples:
* @param[in] ruleOptionsBmp           = 0 - no options are defined.
*                                      Rule state is valid.
* @param[in] ruleOptionsBmp           = CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E -
*                                      write all fields of rule to TCAM but rule's
*                                      state is invalid (no match during lookups).
* @param[in] maskPtr                  - rule mask. The rule mask is AND styled one. Mask
*                                      bit's 0 means don't care bit (corresponding bit in
*                                      the pattern is not using in the TCAM lookup).
*                                      Mask bit's 1 means that corresponding bit in the
*                                      pattern is using in the TCAM lookup.
*                                      The format of mask is defined by ruleFormat
* @param[in] patternPtr               - rule pattern.
*                                      The format of pattern is defined by ruleFormat
* @param[in] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The pattern and mask input structures should be set to zero
*       by an application before assignment of fields.
*       The function places all muxed fields to rule patern and mask
*       by using bitwise OR operation.
*       The function does not check validity of muxed (overlapped) fields.
*
*/
GT_STATUS cpssDxChPclRuleSet
(
    IN GT_U8                              devNum,
    IN GT_U32                             tcamIndex,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat,
    IN GT_U32                             ruleIndex,
    IN CPSS_DXCH_PCL_RULE_OPTION_ENT      ruleOptionsBmp,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT      *maskPtr,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT      *patternPtr,
    IN CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclRuleSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    CPSS_LOG_API_ENTER_MAC(
        (funcId, devNum, tcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, maskPtr, patternPtr, actionPtr));

    rc = internal_cpssDxChPclRuleSet(
        devNum, tcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, maskPtr, patternPtr, actionPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);

    CPSS_APP_SPECIFIC_CB_MAC(
        (funcId, rc, devNum, tcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, maskPtr, patternPtr, actionPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclRuleParsedGet function
* @endinternal
*
* @brief   The function gets the Policy Rule valid status, Mask, Pattern and Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleFormat               - format of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM.
* @param[in] ruleOptionsBmp           - Bitmap of rule's options.
*                                      The CPSS_DXCH_PCL_RULE_OPTION_ENT defines meaning of each bit.
*                                      Samples:
* @param[in] ruleOptionsBmp           = 0 - no options are defined.
*
* @param[out] isRuleValidPtr           - GT_TRUE - rule is valid, GT_FALSE - rule is invalid
* @param[out] maskPtr                  - rule mask. The rule mask is AND styled one. Mask
*                                      bit's 0 means don't care bit (corresponding bit in
*                                      the pattern is not using in the TCAM lookup).
*                                      Mask bit's 1 means that corresponding bit in the
*                                      pattern is using in the TCAM lookup.
*                                      The format of mask is defined by ruleFormat
* @param[out] patternPtr               - rule pattern.
*                                      The format of pattern is defined by ruleFormat
* @param[out] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - null pointer
* @retval GT_BAD_STATE             - when size is trash or not related to ruleFormat.
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclRuleParsedGet
(
    IN  GT_U8                                            devNum,
    IN  GT_U32                                           tcamIndex,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               ruleFormat,
    IN  GT_U32                                           ruleIndex,
    IN  CPSS_DXCH_PCL_RULE_OPTION_ENT                    ruleOptionsBmp,
    OUT GT_BOOL                                          *isRuleValidPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *maskPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *patternPtr,
    OUT CPSS_DXCH_PCL_ACTION_STC                         *actionPtr
)
{
    return cpssDxChPclPortGroupRuleParsedGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, tcamIndex,
        ruleFormat, ruleIndex, ruleOptionsBmp,
        isRuleValidPtr, maskPtr, patternPtr, actionPtr);
}

/**
* @internal cpssDxChPclRuleParsedGet function
* @endinternal
*
* @brief   The function gets the Policy Rule valid status, Mask, Pattern and Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleFormat               - format of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM.
* @param[in] ruleOptionsBmp           - Bitmap of rule's options.
*                                      The CPSS_DXCH_PCL_RULE_OPTION_ENT defines meaning of each bit.
*                                      Samples:
* @param[in] ruleOptionsBmp           = 0 - no options are defined.
*
* @param[out] isRuleValidPtr           - GT_TRUE - rule is valid, GT_FALSE - rule is invalid
* @param[out] maskPtr                  - rule mask. The rule mask is AND styled one. Mask
*                                      bit's 0 means don't care bit (corresponding bit in
*                                      the pattern is not using in the TCAM lookup).
*                                      Mask bit's 1 means that corresponding bit in the
*                                      pattern is using in the TCAM lookup.
*                                      The format of mask is defined by ruleFormat
* @param[out] patternPtr               - rule pattern.
*                                      The format of pattern is defined by ruleFormat
* @param[out] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - null pointer
* @retval GT_BAD_STATE             - when size is trash or not related to ruleFormat.
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclRuleParsedGet
(
    IN  GT_U8                                            devNum,
    IN  GT_U32                                           tcamIndex,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               ruleFormat,
    IN  GT_U32                                           ruleIndex,
    IN  CPSS_DXCH_PCL_RULE_OPTION_ENT                    ruleOptionsBmp,
    OUT GT_BOOL                                          *isRuleValidPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *maskPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *patternPtr,
    OUT CPSS_DXCH_PCL_ACTION_STC                         *actionPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclRuleParsedGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC(
        (funcId, devNum, tcamIndex, ruleFormat, ruleIndex,
         ruleOptionsBmp, isRuleValidPtr, maskPtr, patternPtr, actionPtr));

    rc = internal_cpssDxChPclRuleParsedGet(
        devNum, tcamIndex, ruleFormat, ruleIndex,
        ruleOptionsBmp, isRuleValidPtr, maskPtr, patternPtr, actionPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC(
        (funcId, rc, devNum, tcamIndex, ruleFormat, ruleIndex,
         ruleOptionsBmp, isRuleValidPtr, maskPtr, patternPtr, actionPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclRuleActionUpdate function
* @endinternal
*
* @brief   The function updates the Rule Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule. (APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclRuleSet.
* @param[in] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note NONE
*
*/
static GT_STATUS internal_cpssDxChPclRuleActionUpdate
(
    IN GT_U8                              devNum,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
{
    return cpssDxChPclPortGroupRuleActionUpdate(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, tcamIndex,
        ruleSize, ruleIndex, actionPtr);
}

/**
* @internal cpssDxChPclRuleActionUpdate function
* @endinternal
*
* @brief   The function updates the Rule Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule. (APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclRuleSet.
* @param[in] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note NONE
*
*/
GT_STATUS cpssDxChPclRuleActionUpdate
(
    IN GT_U8                              devNum,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclRuleActionUpdate);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcamIndex, ruleSize, ruleIndex, actionPtr));

    rc = internal_cpssDxChPclRuleActionUpdate(devNum, tcamIndex, ruleSize, ruleIndex, actionPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcamIndex, ruleSize, ruleIndex, actionPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclRuleActionGet function
* @endinternal
*
* @brief   The function gets the Rule Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule. (APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclRuleSet.
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
*                                      Needed for parsing
*
* @param[out] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note NONE
*
*/
static GT_STATUS internal_cpssDxChPclRuleActionGet
(
    IN  GT_U8                              devNum,
    IN  GT_U32                             tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN  GT_U32                             ruleIndex,
    IN  CPSS_PCL_DIRECTION_ENT             direction,
    OUT CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
{
    return cpssDxChPclPortGroupRuleActionGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, tcamIndex,
        ruleSize, ruleIndex, direction, actionPtr);
}

/**
* @internal cpssDxChPclRuleActionGet function
* @endinternal
*
* @brief   The function gets the Rule Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule. (APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclRuleSet.
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
*                                      Needed for parsing
*
* @param[out] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note NONE
*
*/
GT_STATUS cpssDxChPclRuleActionGet
(
    IN  GT_U8                              devNum,
    IN  GT_U32                             tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN  GT_U32                             ruleIndex,
    IN  CPSS_PCL_DIRECTION_ENT             direction,
    OUT CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclRuleActionGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, tcamIndex, devNum, ruleSize, ruleIndex, direction, actionPtr));

    rc = internal_cpssDxChPclRuleActionGet(devNum, tcamIndex, ruleSize, ruleIndex, direction, actionPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcamIndex, ruleSize, ruleIndex, direction, actionPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclRuleInvalidate function
* @endinternal
*
* @brief   The function invalidates the Policy Rule.
*         For DxCh and DxCh2 devices start indirect rule write operation
*         with "garbage" pattern and mask content and "valid-flag" == 0
*         For DxCh3 devices calculates the TCAM position by ruleSize and ruleIndex
*         parameters and updates the first "valid" bit matching X/Y pair to (1,1)
*         i.e. don't match any value. If origin of valid or invalid rule found at the
*         specified TCAM position it will be invalid and available to back validation.
*         If the specified TCAM position contains the not first 24 byte segment of
*         extended rule, the rule also will be invalidated,
*         but unavailable to back validation.
*         If the garbage found in TCAM the X/Y bits will be updated to be as
*         in invalid rule.
*         The function does not check the TCAM contents.
*         GT_OK will be returned in each of described cases.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.(APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclRuleSet.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Backward compatible styled API.
*       The cpssDxChPclRuleValidStatusSet recommended for using instead.
*
*/
static GT_STATUS internal_cpssDxChPclRuleInvalidate
(
    IN GT_U8                              devNum,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex
)
{
    return cpssDxChPclPortGroupRuleInvalidate(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, tcamIndex,
        ruleSize, ruleIndex);
}

/**
* @internal cpssDxChPclRuleInvalidate function
* @endinternal
*
* @brief   The function invalidates the Policy Rule.
*         For DxCh and DxCh2 devices start indirect rule write operation
*         with "garbage" pattern and mask content and "valid-flag" == 0
*         For DxCh3 devices calculates the TCAM position by ruleSize and ruleIndex
*         parameters and updates the first "valid" bit matching X/Y pair to (1,1)
*         i.e. don't match any value. If origin of valid or invalid rule found at the
*         specified TCAM position it will be invalid and available to back validation.
*         If the specified TCAM position contains the not first 24 byte segment of
*         extended rule, the rule also will be invalidated,
*         but unavailable to back validation.
*         If the garbage found in TCAM the X/Y bits will be updated to be as
*         in invalid rule.
*         The function does not check the TCAM contents.
*         GT_OK will be returned in each of described cases.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.(APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclRuleSet.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Backward compatible styled API.
*       The cpssDxChPclRuleValidStatusSet recommended for using instead.
*
*/
GT_STATUS cpssDxChPclRuleInvalidate
(
    IN GT_U8                              devNum,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclRuleInvalidate);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, tcamIndex, devNum, ruleSize, ruleIndex));

    rc = internal_cpssDxChPclRuleInvalidate(devNum, tcamIndex, ruleSize, ruleIndex);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcamIndex, ruleSize, ruleIndex));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclRuleValidStatusSet function
* @endinternal
*
* @brief   Validates/Invalidates the Policy rule.
*         The validation of the rule is performed by next steps:
*         1. Retrieve the content of the rule from PP TCAM
*         2. Write content back to TCAM with Valid indication set.
*         The function does not check content of the rule before
*         write it back to TCAM
*         The invalidation of the rule is performed by next steps:
*         1. Retrieve the content of the rule from PP TCAM
*         2. Write content back to TCAM with Invalid indication set.
*         If the given the rule found already in needed valid state
*         no write done. If the given the rule found with size
*         different from the given rule-size an error code returned.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.(APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM.
* @param[in] valid                    - new rule status: GT_TRUE - valid, GT_FALSE - invalid
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_STATE             - if in TCAM found rule of size different
*                                       from the specified
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclRuleValidStatusSet
(
    IN GT_U8                              devNum,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN GT_BOOL                            valid
)
{
    return cpssDxChPclPortGroupRuleValidStatusSet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, tcamIndex,
        ruleSize, ruleIndex, valid);
}

/**
* @internal cpssDxChPclRuleValidStatusSet function
* @endinternal
*
* @brief   Validates/Invalidates the Policy rule.
*         The validation of the rule is performed by next steps:
*         1. Retrieve the content of the rule from PP TCAM
*         2. Write content back to TCAM with Valid indication set.
*         The function does not check content of the rule before
*         write it back to TCAM
*         The invalidation of the rule is performed by next steps:
*         1. Retrieve the content of the rule from PP TCAM
*         2. Write content back to TCAM with Invalid indication set.
*         If the given the rule found already in needed valid state
*         no write done. If the given the rule found with size
*         different from the given rule-size an error code returned.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.(APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM.
* @param[in] valid                    - new rule status: GT_TRUE - valid, GT_FALSE - invalid
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_STATE             - if in TCAM found rule of size different
*                                       from the specified
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclRuleValidStatusSet
(
    IN GT_U8                              devNum,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN GT_BOOL                            valid
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclRuleValidStatusSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcamIndex, ruleSize, ruleIndex, valid));

    rc = internal_cpssDxChPclRuleValidStatusSet(devNum, tcamIndex, ruleSize, ruleIndex, valid);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcamIndex, ruleSize, ruleIndex, valid));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclRuleCopy function
* @endinternal
*
* @brief   The function copies the Rule's mask, pattern and action to new TCAM position.
*         The source Rule is not invalidated by the function. To implement move Policy
*         Rule from old position to new one at first cpssDxChPclRuleCopy should be
*         called. And after this cpssDxChPclRuleInvalidate or
*         cpssDxChPclRuleValidStatusSet should be used
*         to invalidate Rule in old position.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.
* @param[in] ruleSrcIndex             - index of the rule in the TCAM from which pattern,
*                                      mask and action are taken.
* @param[in] ruleDstIndex             - index of the rule in the TCAM to which pattern,
*                                      mask and action are placed
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclRuleCopy
(
    IN GT_U8                              devNum,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleSrcIndex,
    IN GT_U32                             ruleDstIndex
)
{
    return cpssDxChPclPortGroupRuleCopy(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, tcamIndex,
        ruleSize, ruleSrcIndex, ruleDstIndex);
}

/**
* @internal cpssDxChPclRuleCopy function
* @endinternal
*
* @brief   The function copies the Rule's mask, pattern and action to new TCAM position.
*         The source Rule is not invalidated by the function. To implement move Policy
*         Rule from old position to new one at first cpssDxChPclRuleCopy should be
*         called. And after this cpssDxChPclRuleInvalidate or
*         cpssDxChPclRuleValidStatusSet should be used
*         to invalidate Rule in old position.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.
* @param[in] ruleSrcIndex             - index of the rule in the TCAM from which pattern,
*                                      mask and action are taken.
* @param[in] ruleDstIndex             - index of the rule in the TCAM to which pattern,
*                                      mask and action are placed
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclRuleCopy
(
    IN GT_U8                              devNum,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleSrcIndex,
    IN GT_U32                             ruleDstIndex
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclRuleCopy);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex));

    rc = internal_cpssDxChPclRuleCopy(devNum, tcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortIngressPolicyEnable function
* @endinternal
*
* @brief   Enables/disables ingress policy per port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] enable                   - GT_TRUE - Ingress Policy enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortIngressPolicyEnable
(
    IN GT_U8    devNum,
    IN GT_PORT_NUM  portNum,
    IN GT_BOOL  enable
)
{
    GT_STATUS rc = GT_OK;
    GT_U32 bitNum; /* number of "PCL enable" bit in VLAN QoS entry */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);
        /* write value to post-tti-lookup-ingress-eport table */
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                             CPSS_DXCH_SIP5_TABLE_POST_TTI_LOOKUP_INGRESS_EPORT_E,
                                             portNum,
                                             PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                             SIP5_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_ING_POLICY_EN_E, /* field name */
                                             PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                             ((enable == GT_FALSE) ? 0 : 1));
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        bitNum = 10;

        rc = prvCpssDxChWriteTableEntryField(devNum,
                                           CPSS_DXCH_TABLE_PORT_VLAN_QOS_E,
                                           portNum,
                                           0 /*fieldWordNum*/,
                                           bitNum /*fieldOffset*/,
                                           1 /*fieldLength*/,
                                           ((enable == GT_FALSE) ? 0 : 1) /*fieldValue*/);
    }

    return rc;
}

/**
* @internal cpssDxChPclPortIngressPolicyEnable function
* @endinternal
*
* @brief   Enables/disables ingress policy per port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] enable                   - GT_TRUE - Ingress Policy enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortIngressPolicyEnable
(
    IN GT_U8    devNum,
    IN GT_PORT_NUM  portNum,
    IN GT_BOOL  enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortIngressPolicyEnable);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enable));

    rc = internal_cpssDxChPclPortIngressPolicyEnable(devNum, portNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortIngressPolicyEnableGet function
* @endinternal
*
* @brief   Get the Enable/Disable ingress policy status per port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*
* @param[out] enablePtr                - Pointer to ingress policy status.
*                                      GT_TRUE - Ingress Policy is enabled.
*                                      GT_FALSE - Ingress Policy is disabled.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortIngressPolicyEnableGet
(
    IN  GT_U8    devNum,
    IN  GT_PORT_NUM     portNum,
    OUT GT_BOOL  *enablePtr
)
{
    GT_U32 bitNum; /* number of "PCL enable" bit in VLAN QoS entry */
    GT_U32 value;  /* register field value */
    GT_STATUS rc;         /* return code                                  */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);
        /* read value from post-tti-lookup-ingress-eport table */
        rc = prvCpssDxChReadTableEntryField(devNum,
                                            CPSS_DXCH_SIP5_TABLE_POST_TTI_LOOKUP_INGRESS_EPORT_E,
                                            portNum,
                                            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                            SIP5_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_ING_POLICY_EN_E, /* field name */
                                            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                            &value);
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        bitNum = 10;

        rc = prvCpssDxChReadTableEntryField(devNum,
                                            CPSS_DXCH_TABLE_PORT_VLAN_QOS_E,
                                            portNum,
        0 /*fieldWordNum*/,
        bitNum /*fieldOffset*/,
        1 /*fieldLength*/,
        &value /*fieldValue*/);
    }
    if(rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = (value == 1) ? GT_TRUE : GT_FALSE;

    return GT_OK;
}

/**
* @internal cpssDxChPclPortIngressPolicyEnableGet function
* @endinternal
*
* @brief   Get the Enable/Disable ingress policy status per port.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*
* @param[out] enablePtr                - Pointer to ingress policy status.
*                                      GT_TRUE - Ingress Policy is enabled.
*                                      GT_FALSE - Ingress Policy is disabled.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortIngressPolicyEnableGet
(
    IN  GT_U8    devNum,
    IN  GT_PORT_NUM     portNum,
    OUT GT_BOOL  *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortIngressPolicyEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enablePtr));

    rc = internal_cpssDxChPclPortIngressPolicyEnableGet(devNum, portNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortLookupCfgTabAccessModeSet function
* @endinternal
*
* @brief   Configures VLAN/PORT/ePort access mode to Ingress or Egress PCL
*         configuration table per lookup.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number.
*                                      In eArch devices
*                                      - for each ingress lookup portNum is default ePort.
*                                      - for egress lookup portNum is physical port.
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      lookup0 or lookup1
* @param[in] subLookupNum             - sub lookup number for lookup.
*                                      Supported only for  xCat3 and above devices.
*                                      Ignored for other devices.
*                                      xCat3 and above devices supports two sub lookups only for
*                                      ingress lookup CPSS_PCL_LOOKUP_0_E , (APPLICABLE RANGES: 0..1).
*                                      All other lookups have not sub lookups,
*                                      acceptable value is 0.
* @param[in] mode                     - PCL Configuration Table access mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - on bad entryIndex
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note - since dxCh1 supports Ingress direction only, this API set the same access
*       type for both lookups regardless <lookupNum> parameter value for dxCh1.
*
*/
static GT_STATUS internal_cpssDxChPclPortLookupCfgTabAccessModeSet
(
    IN GT_U8                                          devNum,
    IN GT_PORT_NUM                                    portNum,
    IN CPSS_PCL_DIRECTION_ENT                         direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT                     lookupNum,
    IN GT_U32                                         subLookupNum,
    IN CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT mode
)
{
    GT_U32    rc;
    GT_U32    regAddr;       /* register address                    */
    GT_U32    bitPos;        /* bit position                        */
    GT_U32    portGroupId;        /* port group Id - support multi-port-groups device    */
    GT_U32     localPort;     /* local port - support multi-port-groups device */
    GT_U32    lookupMode;    /* Determines the index to the third lookup in the PCL Configuration table.
                                The index may be source port, VLAN ID or lower bits of ePort based on this field.*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    switch (mode)
    {
        case CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E:
            lookupMode = 0;
            break;
        case CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E:
            lookupMode = 1;
            break;
        case CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E:
            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == 0)
            {
                /* only for Bobcat2; Caelum; Bobcat3 and above devices        */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            lookupMode = 2;
            break;
        case CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_SRC_TRG_E:
            if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum) == 0)
            {
                /* only for SIP_6_10 and above devices */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            lookupMode = 3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        switch (direction)
        {
            case CPSS_PCL_DIRECTION_INGRESS_E:

                switch (lookupNum)
                {
                    case CPSS_PCL_LOOKUP_0_E:
                        if (subLookupNum > 1)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        if (subLookupNum == 0)
                        {
                            bitPos = SIP5_TTI_DEFAULT_EPORT_TABLE_FIELDS_LOOKUP0_PCL_CFG_MODE_E;
                        }
                        else
                        {
                            bitPos = SIP5_TTI_DEFAULT_EPORT_TABLE_FIELDS_LOOKUP1_PCL_CFG_MODE_E;
                        }
                        break;
                    case CPSS_PCL_LOOKUP_1_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = SIP5_TTI_DEFAULT_EPORT_TABLE_FIELDS_LOOKUP2_PCL_CFG_MODE_E;
                        break;
                    case CPSS_PCL_LOOKUP_0_0_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = SIP5_TTI_DEFAULT_EPORT_TABLE_FIELDS_LOOKUP0_PCL_CFG_MODE_E;
                        break;
                    case CPSS_PCL_LOOKUP_0_1_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = SIP5_TTI_DEFAULT_EPORT_TABLE_FIELDS_LOOKUP1_PCL_CFG_MODE_E;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                {
                    bitPos++;
                }

                PRV_CPSS_DXCH_DEFAULT_EPORT_CHECK_MAC(devNum,portNum);

                /* write value to pre-tti-lookup-ingress-eport table */
                rc = prvCpssDxChWriteTableEntryField(devNum,
                                            CPSS_DXCH_SIP5_TABLE_PRE_TTI_LOOKUP_INGRESS_EPORT_E,
                                            portNum,
                                            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                            bitPos, /* field name */
                                            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                            lookupMode);

                break;

            case CPSS_PCL_DIRECTION_EGRESS_E:
                PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

                /* write value to table */
                rc = prvCpssDxChWriteTableEntryField(devNum,
                    CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
                    portNum,
                    PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                    SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_EPCL_LOOKUP_CONFIGURATION_MODE_E, /* field name */
                    PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                    lookupMode);
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        if (portNum == CPSS_CPU_PORT_NUM_CNS)
        {
            portNum = 63;
        }

        switch (direction)
        {
            case CPSS_PCL_DIRECTION_INGRESS_E:
                /* xCat3, Lion2 devices*/
                switch (lookupNum)
                {
                    case CPSS_PCL_LOOKUP_0_E:
                        if (subLookupNum > 1)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = (subLookupNum == 0) ? 11 : 12;
                        break;
                    case CPSS_PCL_LOOKUP_1_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = 13;
                        break;
                    case CPSS_PCL_LOOKUP_0_0_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = 11;
                        break;
                    case CPSS_PCL_LOOKUP_0_1_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = 12;
                        break;
                    default:
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                rc = prvCpssDxChWriteTableEntryField(devNum,
                                                       CPSS_DXCH_TABLE_PORT_VLAN_QOS_E,
                                                       portNum,
                                                       0 /*fieldWordNum*/,
                                                       bitPos,
                                                       1 /*fieldLength*/,
                                                       lookupMode);

                break;
            case CPSS_PCL_DIRECTION_EGRESS_E:
                if (subLookupNum > 0)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
                portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
                localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

                /* get the start bit 0..63 (in the bmp of registers) */
                bitPos = (localPort == CPSS_CPU_PORT_NUM_CNS) ?
                         PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) :
                         localPort;

                regAddr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                        epclCfgTblAccess[OFFSET_TO_WORD_MAC(bitPos)];

                    rc = prvCpssDrvHwPpPortGroupSetRegField(devNum,
                                                              portGroupId,
                                                              regAddr,
                                                              OFFSET_TO_BIT_MAC(bitPos),
                                                              1,
                                                          lookupMode);
                    break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }
    return rc;
}

/**
* @internal cpssDxChPclPortLookupCfgTabAccessModeSet function
* @endinternal
*
* @brief   Configures VLAN/PORT/ePort access mode to Ingress or Egress PCL
*         configuration table per lookup.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number.
*                                      In eArch devices
*                                      - for each ingress lookup portNum is default ePort.
*                                      - for egress lookup portNum is physical port.
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      lookup0 or lookup1
* @param[in] subLookupNum             - sub lookup number for lookup.
*                                      Supported only for  xCat3 and above devices.
*                                      Ignored for other devices.
*                                      xCat3 and above devices supports two sub lookups only for
*                                      ingress lookup CPSS_PCL_LOOKUP_0_E , (APPLICABLE RANGES: 0..1).
*                                      All other lookups have not sub lookups,
*                                      acceptable value is 0.
* @param[in] mode                     - PCL Configuration Table access mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - on bad entryIndex
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note - since dxCh1 supports Ingress direction only, this API set the same access
*       type for both lookups regardless <lookupNum> parameter value for dxCh1.
*
*/
GT_STATUS cpssDxChPclPortLookupCfgTabAccessModeSet
(
    IN GT_U8                                          devNum,
    IN GT_PORT_NUM                                    portNum,
    IN CPSS_PCL_DIRECTION_ENT                         direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT                     lookupNum,
    IN GT_U32                                         subLookupNum,
    IN CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT mode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortLookupCfgTabAccessModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, direction, lookupNum, subLookupNum, mode));

    rc = internal_cpssDxChPclPortLookupCfgTabAccessModeSet(devNum, portNum, direction, lookupNum, subLookupNum, mode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, direction, lookupNum, subLookupNum, mode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortLookupCfgTabAccessModeGet function
* @endinternal
*
* @brief   Gets VLAN/PORT/ePort access mode to Ingress or Egress PCL
*         configuration table per lookup.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*                                      In eArch devices
*                                      - for each ingress lookup portNum is default ePort.
*                                      - for egress lookup portNum is physical port.
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      lookup0 or lookup1
* @param[in] subLookupNum             - sub lookup number for lookup.
*                                      Supported only for  xCat3 and above devices.
*                                      Ignored for other devices.
*                                      xCat3 and above devices supports two sub lookups only for
*                                      ingress lookup CPSS_PCL_LOOKUP_0_E , (APPLICABLE RANGES: 0..1).
*                                      All other lookups have not sub lookups,
*                                      acceptable value is 0.
*
* @param[out] modePtr                  - (pointer to)PCL Configuration Table access mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclPortLookupCfgTabAccessModeGet
(
    IN  GT_U8                                          devNum,
    IN  GT_PORT_NUM                                    portNum,
    IN  CPSS_PCL_DIRECTION_ENT                         direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT                     lookupNum,
    IN  GT_U32                                         subLookupNum,
    OUT CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT *modePtr
)
{
    GT_U32    rc;
    GT_U32    regAddr;       /* register address                    */
    GT_U32    bitPos;        /* bit position                        */
    GT_U32    portGroupId;   /* port group Id - support multi-port-groups device    */
    GT_U32     localPort;     /* local port - support multi-port-groups device */
    GT_U32    lookupMode;    /* Determines the index to the third lookup in the PCL Configuration table.
                                The index may be source port, VLAN ID or lower bits of ePort based on this field.*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(modePtr);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        switch (direction)
        {
            case CPSS_PCL_DIRECTION_INGRESS_E:

                switch (lookupNum)
                {
                    case CPSS_PCL_LOOKUP_0_E:
                        if (subLookupNum > 1)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        if (subLookupNum == 0)
                        {
                            bitPos = SIP5_TTI_DEFAULT_EPORT_TABLE_FIELDS_LOOKUP0_PCL_CFG_MODE_E;
                        }
                        else
                        {
                            bitPos = SIP5_TTI_DEFAULT_EPORT_TABLE_FIELDS_LOOKUP1_PCL_CFG_MODE_E;
                        }
                        break;
                    case CPSS_PCL_LOOKUP_1_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = SIP5_TTI_DEFAULT_EPORT_TABLE_FIELDS_LOOKUP2_PCL_CFG_MODE_E;
                        break;
                    case CPSS_PCL_LOOKUP_0_0_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = SIP5_TTI_DEFAULT_EPORT_TABLE_FIELDS_LOOKUP0_PCL_CFG_MODE_E;
                        break;
                    case CPSS_PCL_LOOKUP_0_1_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = SIP5_TTI_DEFAULT_EPORT_TABLE_FIELDS_LOOKUP1_PCL_CFG_MODE_E;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                {
                    bitPos++;
                }

                PRV_CPSS_DXCH_DEFAULT_EPORT_CHECK_MAC(devNum,portNum);

                /* write value to pre-tti-lookup-ingress-eport table */
                rc = prvCpssDxChReadTableEntryField(devNum,
                                            CPSS_DXCH_SIP5_TABLE_PRE_TTI_LOOKUP_INGRESS_EPORT_E,
                                            portNum,
                                            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                            bitPos, /* field name */
                                            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                            &lookupMode);
                break;

            case CPSS_PCL_DIRECTION_EGRESS_E:
                PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

                /* read value from table */
                rc = prvCpssDxChReadTableEntryField(devNum,
                    CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
                    portNum,
                    PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                    SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_EPCL_LOOKUP_CONFIGURATION_MODE_E, /* field name */
                    PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                    &lookupMode);
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        /*  E_ARCH Disabled */
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        if (portNum == CPSS_CPU_PORT_NUM_CNS)
        {
            portNum = 63;
        }

        switch (direction)
        {
            case CPSS_PCL_DIRECTION_INGRESS_E:
                /* Lion2 & xCat3 devices*/
                switch (lookupNum)
                {
                    case CPSS_PCL_LOOKUP_0_E:
                        if (subLookupNum > 1)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = (subLookupNum == 0) ? 11 : 12;
                        break;
                    case CPSS_PCL_LOOKUP_1_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = 13;
                        break;
                    case CPSS_PCL_LOOKUP_0_0_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = 11;
                        break;
                    case CPSS_PCL_LOOKUP_0_1_E:
                        if (subLookupNum > 0)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        bitPos = 12;
                        break;
                        default:
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                rc = prvCpssDxChReadTableEntryField(
                    devNum,
                    CPSS_DXCH_TABLE_PORT_VLAN_QOS_E,
                    portNum,
                    0 /*fieldWordNum*/,
                    bitPos,
                    1 /*fieldLength*/,
                    &lookupMode);
                break;

            case CPSS_PCL_DIRECTION_EGRESS_E:
                if (subLookupNum > 0)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
                portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
                localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

                /* get the start bit 0..63 (in the bmp of registers) */
                bitPos = (localPort == CPSS_CPU_PORT_NUM_CNS) ?
                         PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) :
                         localPort;

                regAddr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                        epclCfgTblAccess[OFFSET_TO_WORD_MAC(bitPos)];

                rc = prvCpssDrvHwPpPortGroupGetRegField(
                    devNum,
                    portGroupId,
                    regAddr,
                    OFFSET_TO_BIT_MAC(bitPos),
                    1,
                    &lookupMode);
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    if (rc != 0)
    {
        return rc;
    }

    if(lookupMode <= 3)
    {
        *modePtr = (lookupMode == 0) ? CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E :
                   (lookupMode == 1) ? CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E :
                   (lookupMode == 2) ? CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E :
                 /*(lookupMode == 3)*/ CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_SRC_TRG_E;
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPclPortLookupCfgTabAccessModeGet function
* @endinternal
*
* @brief   Gets VLAN/PORT/ePort access mode to Ingress or Egress PCL
*         configuration table per lookup.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*                                      In eArch devices
*                                      - for each ingress lookup portNum is default ePort.
*                                      - for egress lookup portNum is physical port.
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      lookup0 or lookup1
* @param[in] subLookupNum             - sub lookup number for lookup.
*                                      Supported only for  xCat3 and above devices.
*                                      Ignored for other devices.
*                                      xCat3 and above devices supports two sub lookups only for
*                                      ingress lookup CPSS_PCL_LOOKUP_0_E , (APPLICABLE RANGES: 0..1).
*                                      All other lookups have not sub lookups,
*                                      acceptable value is 0.
*
* @param[out] modePtr                  - (pointer to)PCL Configuration Table access mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclPortLookupCfgTabAccessModeGet
(
    IN  GT_U8                                          devNum,
    IN  GT_PORT_NUM                                    portNum,
    IN  CPSS_PCL_DIRECTION_ENT                         direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT                     lookupNum,
    IN  GT_U32                                         subLookupNum,
    OUT CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT *modePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortLookupCfgTabAccessModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, direction, lookupNum, subLookupNum, modePtr));

    rc = internal_cpssDxChPclPortLookupCfgTabAccessModeGet(devNum, portNum, direction, lookupNum, subLookupNum, modePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, direction, lookupNum, subLookupNum, modePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclCfgTblAccessModeSet function
* @endinternal
*
* @brief   Configures global access mode to Ingress or Egress PCL configuration tables.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] accModePtr               - global configuration of access mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
*/
static GT_STATUS internal_cpssDxChPclCfgTblAccessModeSet
(
    IN GT_U8                                    devNum,
    IN CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   *accModePtr
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    hwMask;        /* HW mask                             */
    GT_STATUS res;           /* return code                         */
    GT_U32    swData;        /* work                                */
    GT_U32    nonLocalBitPos;/* positon of nonLocal bit             */
    GT_U32    EPCLPortInterfacePCLBlockBit;/* EPCL : bit index of field <EPCL Port Interface PCL Block>*/
    GT_U32    EPCLMaxPortPerDevBit;/* EPCL : bit index of field <EPCL Max Port Per Dev>*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    CPSS_NULL_PTR_CHECK_MAC(accModePtr);

    /* ingress PCL */

    hwValue = hwMask = 0;

    /* LOCAL / NON_LOCAL ACCESS */
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).ingrPolicyGlobalConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.control;
    }

    nonLocalBitPos = 2;

    hwMask |= (1 << nonLocalBitPos);

    switch (accModePtr->ipclAccMode)
    {
        case CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E:
            /* hwValue already 0 */
            break;
        case CPSS_DXCH_PCL_CFG_TBL_ACCESS_NON_LOCAL_PORT_E:
            hwValue |= (1 << nonLocalBitPos);
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* max ports per device for non-local access */
    /* base of segment entries for non-local access */

    swData = 0;

    switch (accModePtr->ipclMaxDevPorts)
    {
        case CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E:
            /* swData already 0 */
            break;
        case CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E:
            swData |= (1 << 2);
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch (accModePtr->ipclDevPortBase)
    {
        case CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E:
            /* swData already 0 */
            break;
        case CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE1024_E:
            swData |= 1;
            break;
        case CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E:
            swData |= 2;
            break;
        case CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE3072_E:
            swData |= 3;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* xCat3 and above */
    hwMask |= (1 << 7) | (3 << 3);
    switch (swData)
    {
        case 0:    /* 32 ports base 0 */
            /* hwValue bits 7, 4, 3 already 0 */
            break;
        case 1:    /* 32 ports base 1024 */
            hwValue |= (1 << 3);
            break;
        case 2:    /* 32 ports base 2048 */
            hwValue |= (2 << 3);
            break;
        case 3:    /* 32 ports base 3072 */
            hwValue |= (3 << 3);
            break;
        case 4:    /* 64 ports base 0 */
            hwValue |= (1 << 7);
            break;
        case 6:    /* 64 ports base 2048 */
            hwValue |= (1 << 7) | (1 << 3);
            break;
        /* all other parameter values are invalid */
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    res = prvCpssHwPpWriteRegBitMask(
        devNum, regAddr, hwMask, hwValue);
    if (res != GT_OK)
    {
        return res;
    }

    /* egress PCL */

    hwValue = hwMask = 0;

    /* LOCAL / NON_LOCAL ACCESS */

    hwMask |= (1 << 1);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egrPolicyGlobalConfig;

        EPCLPortInterfacePCLBlockBit = 6;
        EPCLMaxPortPerDevBit = 8;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.epclGlobalConfig;

        EPCLPortInterfacePCLBlockBit = 16;
        EPCLMaxPortPerDevBit = 18;
    }

    switch (accModePtr->epclAccMode)
    {
        case CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E:
            /* hwValue already 0 */
            break;
        case CPSS_DXCH_PCL_CFG_TBL_ACCESS_NON_LOCAL_PORT_E:
            hwValue |= (1 << 1);
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* max ports per device for non-local access */
    /* base of segment entries for non-local access */

    hwMask |= (1 << EPCLMaxPortPerDevBit) | (3 << EPCLPortInterfacePCLBlockBit);
    swData = 0;

    switch (accModePtr->epclMaxDevPorts)
    {
        case CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E:
            /* swData already 0 */
            break;
        case CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E:
            swData |= (1 << 2);
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch (accModePtr->epclDevPortBase)
    {
        case CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E:
            /* swData already 0 */
            break;
        case CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE1024_E:
            swData |= 1;
            break;
        case CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E:
            swData |= 2;
            break;
        case CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE3072_E:
            swData |= 3;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* xCat3 and above */
    switch (swData)
    {
        case 0:    /* 32 ports base 0 */
            /* hwValue bits 18, 17, 16 already 0 */
            break;
        case 2:    /* 32 ports base 2048 */
            hwValue |= (1 << EPCLPortInterfacePCLBlockBit);
            break;
        case 4:    /* 64 ports base 0 */
            hwValue |= (1 << EPCLMaxPortPerDevBit);
            break;
        case 6:    /* 64 ports base 2048 */
            hwValue |= (1 << EPCLMaxPortPerDevBit) | (1 << EPCLPortInterfacePCLBlockBit);
            break;
        /* Not supported */
        case 1:    /* 32 ports base 1024 */
        case 3:    /* 32 ports base 3072 */
        /* all other parameter values are invalid */
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    res = prvCpssHwPpWriteRegBitMask(
        devNum, regAddr, hwMask, hwValue);
    if (res != GT_OK)
    {
        return res;
    }

    return GT_OK;
}

/**
* @internal cpssDxChPclCfgTblAccessModeSet function
* @endinternal
*
* @brief   Configures global access mode to Ingress or Egress PCL configuration tables.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] accModePtr               - global configuration of access mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
*/
GT_STATUS cpssDxChPclCfgTblAccessModeSet
(
    IN GT_U8                                    devNum,
    IN CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   *accModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclCfgTblAccessModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, accModePtr));

    rc = internal_cpssDxChPclCfgTblAccessModeSet(devNum, accModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, accModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclCfgTblAccessModeGet function
* @endinternal
*
* @brief   Get global access mode to Ingress or Egress PCL configuration tables.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] accModePtr               - global configuration of access mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note see cpssDxChPclCfgTblAccessModeSet
*
*/
static GT_STATUS internal_cpssDxChPclCfgTblAccessModeGet
(
    IN  GT_U8                                   devNum,
    OUT CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   *accModePtr
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    hwData;        /* HW Data                             */
    GT_STATUS res;           /* return code                         */
    GT_U32    nonLocalBitPos;/* positon of nonLocal bit             */
    GT_U32    EPCLPortInterfacePCLBlockBit;/* EPCL : bit index of field <EPCL Port Interface PCL Block>*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    CPSS_NULL_PTR_CHECK_MAC(accModePtr);

    /* ingress PCL */

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).ingrPolicyGlobalConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.control;
    }

    res = prvCpssHwPpReadRegister(devNum, regAddr, &hwValue);
    if (res != GT_OK)
    {
        return res;
    }

    /* LOCAL / NON_LOCAL ACCESS */
    nonLocalBitPos = 2;

    accModePtr->ipclAccMode =
        ((hwValue & (1 << nonLocalBitPos)) == 0)
        ? CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E
        : CPSS_DXCH_PCL_CFG_TBL_ACCESS_NON_LOCAL_PORT_E;

    /* max ports per device for non-local access */
    /* base of segment entries for non-local access */
    /* xCat3 and above */
    /* bits 7 and 4:3 */
    hwData = (((hwValue >> 3) & 3) | ((hwValue >> 5) & 4));

    switch (hwData)
    {
        case 0:
            accModePtr->ipclMaxDevPorts =
                CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
            accModePtr->ipclDevPortBase =
                CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
            break;
        case 1:
            accModePtr->ipclMaxDevPorts =
                CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
            accModePtr->ipclDevPortBase =
                CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE1024_E;
            break;
        case 2:
            accModePtr->ipclMaxDevPorts =
                CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
            accModePtr->ipclDevPortBase =
                CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E;
            break;
        case 3:
            accModePtr->ipclMaxDevPorts =
                CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
            accModePtr->ipclDevPortBase =
                CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE3072_E;
            break;
        case 4:
            accModePtr->ipclMaxDevPorts =
                CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E;
            accModePtr->ipclDevPortBase =
                CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
            break;
        case 5:
        case 6:
        case 7:
            /* CASES 6 AND 7 NEVER CONFIGURED BY CPSS AND UNDEFINED */
            accModePtr->ipclMaxDevPorts =
                CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E;
            accModePtr->ipclDevPortBase =
                CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E;
            break;
        /* must never occure */
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }


    /* egress PCL */

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egrPolicyGlobalConfig;

        EPCLPortInterfacePCLBlockBit = 6;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.epclGlobalConfig;

        EPCLPortInterfacePCLBlockBit = 16;
    }

    res = prvCpssHwPpReadRegister(devNum, regAddr, &hwValue);
    if (res != GT_OK)
    {
        return res;
    }

    /* LOCAL / NON_LOCAL ACCESS */

    accModePtr->epclAccMode =
        ((hwValue & (1 << 1)) == 0)
        ? CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E
        : CPSS_DXCH_PCL_CFG_TBL_ACCESS_NON_LOCAL_PORT_E;

    /* max ports per device for non-local access */
    /* base of segment entries for non-local access */
    /* xCat3 and above */
    switch ((hwValue >> EPCLPortInterfacePCLBlockBit) & 7)
    {
        case 0:
            accModePtr->epclMaxDevPorts =
                CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
            accModePtr->epclDevPortBase =
                CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
            break;
        case 1:
            accModePtr->epclMaxDevPorts =
                CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
            accModePtr->epclDevPortBase =
                CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E;
            break;
        case 4:
            accModePtr->epclMaxDevPorts =
                CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E;
            accModePtr->epclDevPortBase =
                CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
            break;
        case 5:
            accModePtr->epclMaxDevPorts =
                CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E;
            accModePtr->epclDevPortBase =
                CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPclCfgTblAccessModeGet function
* @endinternal
*
* @brief   Get global access mode to Ingress or Egress PCL configuration tables.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] accModePtr               - global configuration of access mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note see cpssDxChPclCfgTblAccessModeSet
*
*/
GT_STATUS cpssDxChPclCfgTblAccessModeGet
(
    IN  GT_U8                                   devNum,
    OUT CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   *accModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclCfgTblAccessModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, accModePtr));

    rc = internal_cpssDxChPclCfgTblAccessModeGet(devNum, accModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, accModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclCfgTblSet function
* @endinternal
*
* @brief   PCL Configuration table entry's lookup configuration for interface.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] interfaceInfoPtr         - interface data: port, VLAN, or index for setting a
*                                      specific PCL Configuration Table entry
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      For Ingress PCL: lookup0 or lookup1
*                                      For Egress PCL ignored
* @param[in] lookupCfgPtr             - lookup configuration
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note For Bobcat2, Caelum, Bobcat3, Aldrin, AC3X that use INDEX interface type
*       to configure entry for ePort, index = ePort
*
*/
static GT_STATUS internal_cpssDxChPclCfgTblSet
(
    IN GT_U8                           devNum,
    IN CPSS_INTERFACE_INFO_STC        *interfaceInfoPtr,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
{
    return cpssDxChPclPortGroupCfgTblSet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        interfaceInfoPtr, direction, lookupNum, lookupCfgPtr);
}

/**
* @internal cpssDxChPclCfgTblSet function
* @endinternal
*
* @brief   PCL Configuration table entry's lookup configuration for interface.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] interfaceInfoPtr         - interface data: port, VLAN, or index for setting a
*                                      specific PCL Configuration Table entry
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      For Ingress PCL: lookup0 or lookup1
*                                      For Egress PCL ignored
* @param[in] lookupCfgPtr             - lookup configuration
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note For Bobcat2, Caelum, Bobcat3, Aldrin, AC3X that use INDEX interface type
*       to configure entry for ePort, index = ePort
*
*/
GT_STATUS cpssDxChPclCfgTblSet
(
    IN GT_U8                           devNum,
    IN CPSS_INTERFACE_INFO_STC        *interfaceInfoPtr,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclCfgTblSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr));

    rc = internal_cpssDxChPclCfgTblSet(devNum, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclCfgTblGet function
* @endinternal
*
* @brief   PCL Configuration table entry's lookup configuration for interface.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] interfaceInfoPtr         - interface data: port, VLAN, or index for getting a
*                                      specific PCL Configuration Table entry
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      For Ingress PCL: lookup0 or lookup1
*                                      For Egress PCL ignored
*
* @param[out] lookupCfgPtr             - (pointer to) lookup configuration
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note For Bobcat2, Caelum, Bobcat3, Aldrin, AC3X that use INDEX interface type
*       to configure entry for ePort, index = ePort
*
*/
static GT_STATUS internal_cpssDxChPclCfgTblGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_INTERFACE_INFO_STC        *interfaceInfoPtr,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    OUT CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
{
    return cpssDxChPclPortGroupCfgTblGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        interfaceInfoPtr, direction, lookupNum, lookupCfgPtr);
}

/**
* @internal cpssDxChPclCfgTblGet function
* @endinternal
*
* @brief   PCL Configuration table entry's lookup configuration for interface.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] interfaceInfoPtr         - interface data: port, VLAN, or index for getting a
*                                      specific PCL Configuration Table entry
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      For Ingress PCL: lookup0 or lookup1
*                                      For Egress PCL ignored
*
* @param[out] lookupCfgPtr             - (pointer to) lookup configuration
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note For Bobcat2, Caelum, Bobcat3, Aldrin, AC3X that use INDEX interface type
*       to configure entry for ePort, index = ePort
*
*/
GT_STATUS cpssDxChPclCfgTblGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_INTERFACE_INFO_STC        *interfaceInfoPtr,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    OUT CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclCfgTblGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr));

    rc = internal_cpssDxChPclCfgTblGet(devNum, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclIngressPolicyEnable function
* @endinternal
*
* @brief   Enables Ingress Policy.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] enable                   -  ingress policy
*                                      GT_TRUE  - enable,
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclIngressPolicyEnable
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitPos;        /* the position of bit                 */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).ingrPolicyGlobalConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.control;
    }

    bitPos = 1;

    /* 1 - enable, 0 - disable */
    hwValue = (enable == GT_FALSE) ? 0 : 1;

    return prvCpssHwPpSetRegField(devNum, regAddr, bitPos, 1, hwValue);
}

/**
* @internal cpssDxChPclIngressPolicyEnable function
* @endinternal
*
* @brief   Enables Ingress Policy.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] enable                   -  ingress policy
*                                      GT_TRUE  - enable,
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclIngressPolicyEnable
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclIngressPolicyEnable);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPclIngressPolicyEnable(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclIngressPolicyEnableGet function
* @endinternal
*
* @brief   Get status (Enable or Disable) of Ingress Policy.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enable Policy
*                                      GT_TRUE  - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclIngressPolicyEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_STATUS rc;            /* return code                         */
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitPos;        /* the position of bit                 */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).ingrPolicyGlobalConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.control;
    }

    bitPos = 1;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, bitPos, 1, &hwValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* 1 - enable, 0 - disable */
    *enablePtr = ((hwValue == 0) ? GT_FALSE : GT_TRUE);

    return GT_OK;
}

/**
* @internal cpssDxChPclIngressPolicyEnableGet function
* @endinternal
*
* @brief   Get status (Enable or Disable) of Ingress Policy.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enable Policy
*                                      GT_TRUE  - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclIngressPolicyEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclIngressPolicyEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPclIngressPolicyEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChPclUdeEtherTypeRegAddeGet function
* @endinternal
*
* @brief   This function gets UDE Ethertype register address
*         and bit offset of this subfield in register.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in] index                    - UDE Ethertype index
*                                      The valid range documented in Functional Specification.
*                                      (APPLICABLE RANGES: Lion2 0..4; Bobcat2, Caelum, Bobcat3; Aldrin2, Aldrin, AC3X 0..6)
*
* @param[out] regAddrPtr               - (pointer to) address of register.
* @param[out] bitOffsetPtr             - (pointer to) bit offset in register.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS prvCpssDxChPclUdeEtherTypeRegAddeGet
(
    IN   GT_U8           devNum,
    IN   GT_U32          index,
    OUT  GT_U32          *regAddrPtr,
    OUT  GT_U32          *bitOffsetPtr
)
{

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if (index >= 8)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        *regAddrPtr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).PCLUserDefinedEtherTypes[index / 2];

        *bitOffsetPtr = (index & 1) ? 16 : 0;

        return GT_OK;
    }

    if (index == 0)
    {
        /* UDE for index == 0 */
        *regAddrPtr =
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                ttiRegs.specialEthertypes;

        *bitOffsetPtr = 0;

        return GT_OK;
    }

    if (index < 5)
    {
        /* UDE for index == 1..4                      */
        /* the case of 0 already treated upper        */

        /* for index 1,2 - word0, for index 3,4 - word1 */
        *regAddrPtr =
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                ttiRegs.udeEthertypesBase
            + (4 * ((index - 1) / 2));

        /* for index 1,3 - 0, for index 2,4 - 16 */
        *bitOffsetPtr = ((index - 1) & 1) ? 16 : 0;

        return GT_OK;
    }

    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
}

/**
* @internal internal_cpssDxChPclUdeEtherTypeSet function
* @endinternal
*
* @brief   This function sets UDE Ethertype.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in] index                    - UDE Ethertype index,
*                                      (APPLICABLE RANGES: Lion2 0..4; Bobcat2, Caelum, Bobcat3; Aldrin2, Aldrin, AC3X 0..6)
* @param[in] ethType                  - Ethertype value (APPLICABLE RANGES:  0..0xFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_OUT_OF_RANGE          - on out of range parameter value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclUdeEtherTypeSet
(
    IN  GT_U8           devNum,
    IN  GT_U32          index,
    IN  GT_U32          ethType
)
{
    GT_STATUS   rc;           /* return code      */
    GT_U32      regAddr;      /* register address */
    GT_U32      bitOffset;    /* bit offset       */

    /* check parameters */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E);


    if (ethType >= BIT_16)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

    /* check devNum and index validity */
    /* calculate regAddr and bitOffset */
    rc = prvCpssDxChPclUdeEtherTypeRegAddeGet(
        devNum, index, &regAddr, &bitOffset);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* write value */
    return prvCpssHwPpSetRegField(
        devNum, regAddr, bitOffset, 16, ethType);
}

/**
* @internal cpssDxChPclUdeEtherTypeSet function
* @endinternal
*
* @brief   This function sets UDE Ethertype.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in] index                    - UDE Ethertype index,
*                                      (APPLICABLE RANGES: Lion2 0..4; Bobcat2, Caelum, Bobcat3; Aldrin2, Aldrin, AC3X 0..6)
* @param[in] ethType                  - Ethertype value (APPLICABLE RANGES:  0..0xFFFF)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_OUT_OF_RANGE          - on out of range parameter value
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclUdeEtherTypeSet
(
    IN  GT_U8           devNum,
    IN  GT_U32          index,
    IN  GT_U32          ethType
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclUdeEtherTypeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, index, ethType));

    rc = internal_cpssDxChPclUdeEtherTypeSet(devNum, index, ethType);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, index, ethType));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclUdeEtherTypeGet function
* @endinternal
*
* @brief   This function gets the UDE Ethertype.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in] index                    - UDE Ethertype index,
*                                      (APPLICABLE RANGES: Lion2 0..4; Bobcat2, Caelum, Bobcat3; Aldrin2, Aldrin, AC3X 0..6)
*
* @param[out] ethTypePtr               - points to Ethertype value
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclUdeEtherTypeGet
(
    IN  GT_U8           devNum,
    IN  GT_U32          index,
    OUT GT_U32          *ethTypePtr
)
{
    GT_STATUS   rc;           /* return code      */
    GT_U32      regAddr;      /* register address */
    GT_U32      bitOffset;    /* bit offset       */

    /* check parameters */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E);

    CPSS_NULL_PTR_CHECK_MAC(ethTypePtr);

    /* check devNum and index validity */
    /* calculate regAddr and bitOffset */
    rc = prvCpssDxChPclUdeEtherTypeRegAddeGet(
        devNum, index, &regAddr, &bitOffset);
    if (rc != GT_OK)
    {
        return rc;
    }

    return prvCpssHwPpGetRegField(
        devNum, regAddr, bitOffset, 16, ethTypePtr);
}

/**
* @internal cpssDxChPclUdeEtherTypeGet function
* @endinternal
*
* @brief   This function gets the UDE Ethertype.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5.
*
* @param[in] devNum                   - device number
* @param[in] index                    - UDE Ethertype index,
*                                      (APPLICABLE RANGES: Lion2 0..4; Bobcat2, Caelum, Bobcat3; Aldrin2, Aldrin, AC3X 0..6)
*
* @param[out] ethTypePtr               - points to Ethertype value
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclUdeEtherTypeGet
(
    IN  GT_U8           devNum,
    IN  GT_U32          index,
    OUT GT_U32          *ethTypePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclUdeEtherTypeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, index, ethTypePtr));

    rc = internal_cpssDxChPclUdeEtherTypeGet(devNum, index, ethTypePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, index, ethTypePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclTwoLookupsCpuCodeResolution function
* @endinternal
*
* @brief   Resolve the result CPU Code if both lookups has action commands
*         are either both TRAP or both MIRROR To CPU
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] lookupNum                - lookup number from which the CPU Code is selected
*                                      when action commands are either both TRAP or
*                                      both MIRROR To CPU
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclTwoLookupsCpuCodeResolution
(
    IN GT_U8                       devNum,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitNum;        /* bit number                          */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).TTIUnitGlobalConfigs.TTIUnitGlobalConfig;
        bitNum = 6;
    }
    else
    {
        /* xCat3 and Lion2 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiUnitConfig;
        bitNum = 6;
    }

    switch (lookupNum)
    {
        case CPSS_PCL_LOOKUP_0_E: hwValue = 0; break;
        case CPSS_PCL_LOOKUP_1_E: hwValue = 1; break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, bitNum, 1, hwValue);
}

/**
* @internal cpssDxChPclTwoLookupsCpuCodeResolution function
* @endinternal
*
* @brief   Resolve the result CPU Code if both lookups has action commands
*         are either both TRAP or both MIRROR To CPU
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] lookupNum                - lookup number from which the CPU Code is selected
*                                      when action commands are either both TRAP or
*                                      both MIRROR To CPU
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclTwoLookupsCpuCodeResolution
(
    IN GT_U8                       devNum,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclTwoLookupsCpuCodeResolution);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, lookupNum));

    rc = internal_cpssDxChPclTwoLookupsCpuCodeResolution(devNum, lookupNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, lookupNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclInvalidUdbCmdSet function
* @endinternal
*
* @brief   Set the command that is applied when the policy key <User-Defined>
*         field cannot be extracted from the packet due to lack of header
*         depth (i.e, the field resides deeper than 128 bytes into the packet.
*         In Falcon and above ingress packet depth increased to 160 bytes.).
*         This command is NOT applied when the policy key <User-Defined>
*         field cannot be extracted due to the offset being relative to a layer
*         start point that does not exist in the packet. (e.g. the offset is relative
*         to the IP header but the packet is a non-IP).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] udbErrorCmd              - command applied to a packet:
*                                      continue lookup, trap to CPU, hard drop or soft drop
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclInvalidUdbCmdSet
(
    IN GT_U8                        devNum,
    IN CPSS_DXCH_UDB_ERROR_CMD_ENT  udbErrorCmd
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitNum;        /* Bit number                          */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).ingrPolicyGlobalConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.control;
    }

    bitNum = 8;

    switch (udbErrorCmd)
    {
        case CPSS_DXCH_UDB_ERROR_CMD_LOOKUP_E:      hwValue = 0; break;
        case CPSS_DXCH_UDB_ERROR_CMD_TRAP_TO_CPU_E: hwValue = 1; break;
        case CPSS_DXCH_UDB_ERROR_CMD_DROP_HARD_E:   hwValue = 3; break;
        case CPSS_DXCH_UDB_ERROR_CMD_DROP_SOFT_E:   hwValue = 2; break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, bitNum, 2, hwValue);
}

/**
* @internal cpssDxChPclInvalidUdbCmdSet function
* @endinternal
*
* @brief   Set the command that is applied when the policy key <User-Defined>
*         field cannot be extracted from the packet due to lack of header
*         depth (i.e, the field resides deeper than 128 bytes into the packet.
*         In Falcon and above ingress packet depth increased to 160 bytes.).
*         This command is NOT applied when the policy key <User-Defined>
*         field cannot be extracted due to the offset being relative to a layer
*         start point that does not exist in the packet. (e.g. the offset is relative
*         to the IP header but the packet is a non-IP).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] udbErrorCmd              - command applied to a packet:
*                                      continue lookup, trap to CPU, hard drop or soft drop
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclInvalidUdbCmdSet
(
    IN GT_U8                        devNum,
    IN CPSS_DXCH_UDB_ERROR_CMD_ENT  udbErrorCmd
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclInvalidUdbCmdSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, udbErrorCmd));

    rc = internal_cpssDxChPclInvalidUdbCmdSet(devNum, udbErrorCmd);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, udbErrorCmd));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclInvalidUdbCmdGet function
* @endinternal
*
* @brief   Get the command that is applied when the policy key <User-Defined>
*         field cannot be extracted from the packet due to lack of header
*         depth (i.e, the field resides deeper than 128 bytes into the packet.
*         In Falcon and above ingress packet depth increased to 160 bytes.).
*         This command is NOT applied when the policy key <User-Defined>
*         field cannot be extracted due to the offset being relative to a layer
*         start point that does not exist in the packet. (e.g. the offset is relative
*         to the IP header but the packet is a non-IP).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] udbErrorCmdPtr           - command applied to a packet:
*                                      continue lookup, trap to CPU, hard drop or soft drop
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_BAD_PTR               - on NULL pointer
*/
static GT_STATUS internal_cpssDxChPclInvalidUdbCmdGet
(
    IN  GT_U8                        devNum,
    OUT CPSS_DXCH_UDB_ERROR_CMD_ENT  *udbErrorCmdPtr
)
{
    GT_STATUS rc;
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitNum;        /* Bit number                          */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(udbErrorCmdPtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).ingrPolicyGlobalConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.control;
    }

    bitNum = 8;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, bitNum, 2, &hwValue);
    if(GT_OK != rc)
    {
        return rc;
    }

    switch (hwValue)
    {
        case 0:
            *udbErrorCmdPtr = CPSS_DXCH_UDB_ERROR_CMD_LOOKUP_E;
            break;
        case 1:
            *udbErrorCmdPtr = CPSS_DXCH_UDB_ERROR_CMD_TRAP_TO_CPU_E;
            break;
        case 3:
            *udbErrorCmdPtr = CPSS_DXCH_UDB_ERROR_CMD_DROP_HARD_E;
            break;
        case 2:
            *udbErrorCmdPtr = CPSS_DXCH_UDB_ERROR_CMD_DROP_SOFT_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @internal cpssDxChPclInvalidUdbCmdGet function
* @endinternal
*
* @brief   Get the command that is applied when the policy key <User-Defined>
*         field cannot be extracted from the packet due to lack of header
*         depth (i.e, the field resides deeper than 128 bytes into the packet.
*         In Falcon and above ingress packet depth increased to 160 bytes.).
*         This command is NOT applied when the policy key <User-Defined>
*         field cannot be extracted due to the offset being relative to a layer
*         start point that does not exist in the packet. (e.g. the offset is relative
*         to the IP header but the packet is a non-IP).
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] udbErrorCmdPtr           - command applied to a packet:
*                                      continue lookup, trap to CPU, hard drop or soft drop
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_BAD_PTR               - on NULL pointer
*/
GT_STATUS cpssDxChPclInvalidUdbCmdGet
(
    IN  GT_U8                        devNum,
    OUT CPSS_DXCH_UDB_ERROR_CMD_ENT  *udbErrorCmdPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclInvalidUdbCmdGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, udbErrorCmdPtr));

    rc = internal_cpssDxChPclInvalidUdbCmdGet(devNum, udbErrorCmdPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, udbErrorCmdPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclIpLengthCheckModeSet function
* @endinternal
*
* @brief   Set the mode of checking IP packet length.
*         To determine if an IP packet is a valid IP packet, one of the checks is a
*         length check to find out if the total IP length field reported in the
*         IP header is less or equal to the packet's length.
*         This function determines the check mode.
*         The results of this check sets the policy key <IP Header OK>.
*         The result is also used by the router engine to determine whether
*         to forward or trap/drop the packet.
*         There are two check modes:
*         1. For IPv4: ip_total_length <= packet's byte count
*         For IPv6: ip_total_length + 40 <= packet's byte count
*         2. For IPv4: ip_total_length + L3 Offset + 4 (CRC) <= packet's byte count,
*         For IPv6: ip_total_length + 40 +L3 Offset + 4 (CRC) <= packet's
*         byte count
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number
* @param[in] mode                     - IP packet length checking mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclIpLengthCheckModeSet
(
    IN GT_U8                                   devNum,
    IN CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_ENT  mode
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitNum;        /* bit number                          */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    if (PRV_CPSS_DXCH_LION_FAMILY_CHECK_MAC(devNum))
    {
        /* Lion2 and above */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiUnitConfig;
        bitNum = 10;
    }
    else
    {
        /* xCat3 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiUnitConfig;
        bitNum = 9;
    }

    switch (mode)
    {
        case CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L3_E:
            hwValue = 1;
            break;
        case CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L2_E:
            hwValue = 0;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, bitNum, 1, hwValue);
}

/**
* @internal cpssDxChPclIpLengthCheckModeSet function
* @endinternal
*
* @brief   Set the mode of checking IP packet length.
*         To determine if an IP packet is a valid IP packet, one of the checks is a
*         length check to find out if the total IP length field reported in the
*         IP header is less or equal to the packet's length.
*         This function determines the check mode.
*         The results of this check sets the policy key <IP Header OK>.
*         The result is also used by the router engine to determine whether
*         to forward or trap/drop the packet.
*         There are two check modes:
*         1. For IPv4: ip_total_length <= packet's byte count
*         For IPv6: ip_total_length + 40 <= packet's byte count
*         2. For IPv4: ip_total_length + L3 Offset + 4 (CRC) <= packet's byte count,
*         For IPv6: ip_total_length + 40 +L3 Offset + 4 (CRC) <= packet's
*         byte count
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number
* @param[in] mode                     - IP packet length checking mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclIpLengthCheckModeSet
(
    IN GT_U8                                   devNum,
    IN CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_ENT  mode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclIpLengthCheckModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mode));

    rc = internal_cpssDxChPclIpLengthCheckModeSet(devNum, mode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclIpLengthCheckModeGet function
* @endinternal
*
* @brief   Get the mode of checking IP packet length.
*         To determine if an IP packet is a valid IP packet, one of the checks is a
*         length check to find out if the total IP length field reported in the
*         IP header is less or equal to the packet's length.
*         This function determines the check mode.
*         The results of this check sets the policy key <IP Header OK>.
*         The result is also used by the router engine to determine whether
*         to forward or trap/drop the packet.
*         There are two check modes:
*         1. For IPv4: ip_total_length <= packet's byte count
*         For IPv6: ip_total_length + 40 <= packet's byte count
*         2. For IPv4: ip_total_length + L3 Offset + 4 (CRC) <= packet's byte count,
*         For IPv6: ip_total_length + 40 +L3 Offset + 4 (CRC) <= packet's
*         byte count
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number
*
* @param[out] modePtr                  - IP packet length checking mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_BAD_PTR               - on NULL pointer
*/
static GT_STATUS internal_cpssDxChPclIpLengthCheckModeGet
(
    IN  GT_U8                                   devNum,
    OUT CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_ENT  *modePtr
)
{
    GT_STATUS rc;
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitNum;        /* bit number                          */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    CPSS_NULL_PTR_CHECK_MAC(modePtr);

    if (PRV_CPSS_DXCH_LION_FAMILY_CHECK_MAC(devNum))
    {
        /* Lion2 and above */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiUnitConfig;
        bitNum = 10;
    }
    else
    {
        /* xCat3 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiUnitConfig;
        bitNum = 9;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, bitNum, 1, &hwValue);
    if(GT_OK != rc)
    {
        return rc;
    }

    *modePtr = (0 == hwValue) ? CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L2_E :
                                CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L3_E;

    return rc;
}

/**
* @internal cpssDxChPclIpLengthCheckModeGet function
* @endinternal
*
* @brief   Get the mode of checking IP packet length.
*         To determine if an IP packet is a valid IP packet, one of the checks is a
*         length check to find out if the total IP length field reported in the
*         IP header is less or equal to the packet's length.
*         This function determines the check mode.
*         The results of this check sets the policy key <IP Header OK>.
*         The result is also used by the router engine to determine whether
*         to forward or trap/drop the packet.
*         There are two check modes:
*         1. For IPv4: ip_total_length <= packet's byte count
*         For IPv6: ip_total_length + 40 <= packet's byte count
*         2. For IPv4: ip_total_length + L3 Offset + 4 (CRC) <= packet's byte count,
*         For IPv6: ip_total_length + 40 +L3 Offset + 4 (CRC) <= packet's
*         byte count
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2.
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number
*
* @param[out] modePtr                  - IP packet length checking mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_BAD_PTR               - on NULL pointer
*/
GT_STATUS cpssDxChPclIpLengthCheckModeGet
(
    IN  GT_U8                                   devNum,
    OUT CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_ENT  *modePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclIpLengthCheckModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, modePtr));

    rc = internal_cpssDxChPclIpLengthCheckModeGet(devNum, modePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, modePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxCh2PclEgressPolicyEnable function
* @endinternal
*
* @brief   Enables Egress Policy.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] enable                   -  Egress Policy
*                                      GT_TRUE  - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_SUPPORTED         - on not supported enable parameter value
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxCh2PclEgressPolicyEnable
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitIndex;/*start bit*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egrPolicyGlobalConfig;
        bitIndex = 0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.epclGlobalConfig;
        bitIndex = 7;
    }

    /* 1 - enable, 0 - disable */
    hwValue = (enable == GT_FALSE) ? 0 : 1;

    return prvCpssHwPpSetRegField(devNum, regAddr, bitIndex, 1, hwValue);
}

/**
* @internal cpssDxCh2PclEgressPolicyEnable function
* @endinternal
*
* @brief   Enables Egress Policy.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] enable                   -  Egress Policy
*                                      GT_TRUE  - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_SUPPORTED         - on not supported enable parameter value
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxCh2PclEgressPolicyEnable
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxCh2PclEgressPolicyEnable);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxCh2PclEgressPolicyEnable(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxCh2PclEgressPolicyEnableGet function
* @endinternal
*
* @brief   Get status of Egress Policy.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - status of Egress Policy
*                                      GT_TRUE  - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_BAD_PTR               - on NULL poinet
*/
static GT_STATUS internal_cpssDxCh2PclEgressPolicyEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_STATUS rc;
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitIndex;      /*start bit                            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egrPolicyGlobalConfig;
        bitIndex = 0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.epclGlobalConfig;
        bitIndex = 7;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, bitIndex, 1, &hwValue);
    if(GT_OK != rc)
    {
        return rc;
    }

    *enablePtr = (hwValue == 0) ? GT_FALSE : GT_TRUE;

    return rc;
}

/**
* @internal cpssDxCh2PclEgressPolicyEnableGet function
* @endinternal
*
* @brief   Get status of Egress Policy.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - status of Egress Policy
*                                      GT_TRUE  - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_BAD_PTR               - on NULL poinet
*/
GT_STATUS cpssDxCh2PclEgressPolicyEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxCh2PclEgressPolicyEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxCh2PclEgressPolicyEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressForRemoteTunnelStartEnableSet function
* @endinternal
*
* @brief   Enable/Disable the Egress PCL processing for the packets,
*         which Tunnel Start already done on remote ingress device.
*         These packets are ingessed with DSA Tag contains source port 60.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] enable                   -  Remote Tunnel Start Packets Egress Pcl
*                                      GT_TRUE  - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclEgressForRemoteTunnelStartEnableSet
(
    IN  GT_U8                         devNum,
    IN  GT_BOOL                       enable
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitIndex;/*start bit*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);


    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egrPolicyGlobalConfig;
        bitIndex = 9;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.epclGlobalConfig;
        bitIndex = 19;
    }

    /* 1 - enable, 0 - disable */
    hwValue = (enable == GT_FALSE) ? 0 : 1;

    return prvCpssHwPpSetRegField(devNum, regAddr, bitIndex, 1, hwValue);
}

/**
* @internal cpssDxChPclEgressForRemoteTunnelStartEnableSet function
* @endinternal
*
* @brief   Enable/Disable the Egress PCL processing for the packets,
*         which Tunnel Start already done on remote ingress device.
*         These packets are ingessed with DSA Tag contains source port 60.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] enable                   -  Remote Tunnel Start Packets Egress Pcl
*                                      GT_TRUE  - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclEgressForRemoteTunnelStartEnableSet
(
    IN  GT_U8                         devNum,
    IN  GT_BOOL                       enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressForRemoteTunnelStartEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPclEgressForRemoteTunnelStartEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressForRemoteTunnelStartEnableGet function
* @endinternal
*
* @brief   Gets Enable/Disable of the Egress PCL processing for the packets,
*         which Tunnel Start already done on remote ingress device.
*         These packets are ingessed with DSA Tag contains source port 60.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enable Remote Tunnel Start Packets Egress Pcl
*                                      GT_TRUE  - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclEgressForRemoteTunnelStartEnableGet
(
    IN  GT_U8                         devNum,
    OUT GT_BOOL                       *enablePtr
)
{
    GT_STATUS rc;            /* return code                         */
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitIndex;/*start bit*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egrPolicyGlobalConfig;
        bitIndex = 9;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.epclGlobalConfig;
        bitIndex = 19;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, bitIndex, 1, &hwValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* 1 - enable, 0 - disable */
    *enablePtr = (hwValue == 0) ? GT_FALSE : GT_TRUE;

    return GT_OK;
}

/**
* @internal cpssDxChPclEgressForRemoteTunnelStartEnableGet function
* @endinternal
*
* @brief   Gets Enable/Disable of the Egress PCL processing for the packets,
*         which Tunnel Start already done on remote ingress device.
*         These packets are ingessed with DSA Tag contains source port 60.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) enable Remote Tunnel Start Packets Egress Pcl
*                                      GT_TRUE  - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclEgressForRemoteTunnelStartEnableGet
(
    IN  GT_U8                         devNum,
    OUT GT_BOOL                       *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressForRemoteTunnelStartEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPclEgressForRemoteTunnelStartEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet function
* @endinternal
*
* @brief   Sets Egress Policy Configuration Table Access Mode for
*         Tunnel Start packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] cfgTabAccMode            - PCL Configuration Table access mode
*                                      CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E - VLAN ID
*                                      CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E - Normal
*                                      Normal means that access to PCL configuration table is done
*                                      according to settings done by cpssDxChPclCfgTblAccessModeSet
*                                      and cpssDxChPclPortLookupCfgTabAccessModeSet
*                                      as non tunnel start packets.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet
(
    IN  GT_U8                                            devNum,
    IN  CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT   cfgTabAccMode
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitIndex;/*start bit*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egrPolicyGlobalConfig;
        bitIndex = 11;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.epclGlobalConfig;
        bitIndex = 26;
    }

    switch (cfgTabAccMode)
    {
        case CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E:
            hwValue = 0;
            break;
        case CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E:
            hwValue = 1;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }


    return prvCpssHwPpSetRegField(devNum, regAddr, bitIndex, 1, hwValue);
}

/**
* @internal cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet function
* @endinternal
*
* @brief   Sets Egress Policy Configuration Table Access Mode for
*         Tunnel Start packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] cfgTabAccMode            - PCL Configuration Table access mode
*                                      CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E - VLAN ID
*                                      CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E - Normal
*                                      Normal means that access to PCL configuration table is done
*                                      according to settings done by cpssDxChPclCfgTblAccessModeSet
*                                      and cpssDxChPclPortLookupCfgTabAccessModeSet
*                                      as non tunnel start packets.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet
(
    IN  GT_U8                                            devNum,
    IN  CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT   cfgTabAccMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cfgTabAccMode));

    rc = internal_cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet(devNum, cfgTabAccMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cfgTabAccMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet function
* @endinternal
*
* @brief   Gets Egress Policy Configuration Table Access Mode for
*         Tunnel Start packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] cfgTabAccModePtr         - (pointer to) PCL Configuration Table access mode
*                                      CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E - VLAN ID
*                                      CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E - Normal
*                                      Normal means that access to PCL configuration table is done
*                                      according to settings done by cpssDxChPclCfgTblAccessModeSet
*                                      and cpssDxChPclPortLookupCfgTabAccessModeSet
*                                      as non tunnel start packets.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet
(
    IN  GT_U8                                            devNum,
    OUT CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT   *cfgTabAccModePtr
)
{
    GT_STATUS rc;            /* return code                         */
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitIndex;/*start bit*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(cfgTabAccModePtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egrPolicyGlobalConfig;
        bitIndex = 11;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.epclGlobalConfig;
        bitIndex = 26;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, bitIndex, 1, &hwValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    *cfgTabAccModePtr = (hwValue == 0) ?
                        CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E :
                        CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E;

    return GT_OK;
}

/**
* @internal cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet function
* @endinternal
*
* @brief   Gets Egress Policy Configuration Table Access Mode for
*         Tunnel Start packets
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] cfgTabAccModePtr         - (pointer to) PCL Configuration Table access mode
*                                      CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E - VLAN ID
*                                      CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E - Normal
*                                      Normal means that access to PCL configuration table is done
*                                      according to settings done by cpssDxChPclCfgTblAccessModeSet
*                                      and cpssDxChPclPortLookupCfgTabAccessModeSet
*                                      as non tunnel start packets.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet
(
    IN  GT_U8                                            devNum,
    OUT CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT   *cfgTabAccModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cfgTabAccModePtr));

    rc = internal_cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet(devNum, cfgTabAccModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cfgTabAccModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressKeyFieldsVidUpModeSet function
* @endinternal
*
* @brief   Sets Egress Policy VID and UP key fields content mode
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] vidUpMode                - VID and UP key fields content mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclEgressKeyFieldsVidUpModeSet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   vidUpMode
)
{
    return cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, vidUpMode);
}

/**
* @internal cpssDxChPclEgressKeyFieldsVidUpModeSet function
* @endinternal
*
* @brief   Sets Egress Policy VID and UP key fields content mode
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] vidUpMode                - VID and UP key fields content mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclEgressKeyFieldsVidUpModeSet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   vidUpMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressKeyFieldsVidUpModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vidUpMode));

    rc = internal_cpssDxChPclEgressKeyFieldsVidUpModeSet(devNum, vidUpMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vidUpMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressKeyFieldsVidUpModeGet function
* @endinternal
*
* @brief   Gets Egress Policy VID and UP key fields content mode
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] vidUpModePtr             - (pointer to) VID and UP key fields
*                                      calculation mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclEgressKeyFieldsVidUpModeGet
(
    IN   GT_U8                                      devNum,
    OUT  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   *vidUpModePtr
)
{
    return cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, vidUpModePtr);
}

/**
* @internal cpssDxChPclEgressKeyFieldsVidUpModeGet function
* @endinternal
*
* @brief   Gets Egress Policy VID and UP key fields content mode
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] vidUpModePtr             - (pointer to) VID and UP key fields
*                                      calculation mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclEgressKeyFieldsVidUpModeGet
(
    IN   GT_U8                                      devNum,
    OUT  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   *vidUpModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressKeyFieldsVidUpModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vidUpModePtr));

    rc = internal_cpssDxChPclEgressKeyFieldsVidUpModeGet(devNum, vidUpModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vidUpModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxCh2EgressPclPacketTypesSet function
* @endinternal
*
* @brief   Enables/disables Egress PCL (EPCL) for set of packet types on port
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] port                     - port number
* @param[in] pktType                  - packet type to enable/disable EPCL for it
* @param[in] enable                   -  EPCL for specific packet type
*                                      GT_TRUE - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note - after reset EPCL disabled for all packet types on all ports
*
*/
static GT_STATUS internal_cpssDxCh2EgressPclPacketTypesSet
(
    IN GT_U8                             devNum,
    IN GT_PHYSICAL_PORT_NUM              port,
    IN CPSS_DXCH_PCL_EGRESS_PKT_TYPE_ENT pktType,
    IN GT_BOOL                           enable
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */
    GT_U32  bitPos;   /* position of a bit */
    CPSS_DXCH_TABLE_ENT tableType; /* table's type */
    GT_U32  fieldName; /* name of the field */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /* 1 - enable, 0 - disable */
    hwValue = (enable == GT_TRUE) ? 1 : 0;

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum, port);

        /* Bobcat2; Caelum; Bobcat3 */
        switch (pktType)
        {
            case CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_EPCL_FROM_CPU_CONTROL_PACKETS_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_DATA_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_EPCL_FROM_CPU_DATA_PACKETS_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_TO_CPU_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_2_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_2_FIELDS_EPCL_TO_CPU_PACKETS_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_2_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_2_FIELDS_EPCL_TO_ANALYZER_PACKETS_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_TS_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_EPCL_TS_DATA_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_EPCL_NON_TS_DATA_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_DROP_E:
                if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
                {

                    return prvCpssDxChWriteTableEntryField(devNum,
                                                           CPSS_DXCH_SIP6_TABLE_EGRESS_PCL_TARGET_PHYSICAL_PORT_MAPPING_E,
                                                           port,
                                                           PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                                           17, 1, hwValue);
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                break;
            default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        return prvCpssDxChWriteTableEntryField(
            devNum,
            tableType,
            port,
            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
            fieldName, /* field name */
            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
            hwValue);
    }

    /* xCat3; AC5; Lion2 */
    PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, port);

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, port);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,port);

    /* get the start bit 0..63 (in the bmp of registers) */
    bitPos = (localPort == CPSS_CPU_PORT_NUM_CNS) ?
             PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) :
             localPort;

    switch (pktType)
    {
        case CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktFromCpuControl[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        case CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_DATA_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktFromCpuData[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        case CPSS_DXCH_PCL_EGRESS_PKT_TO_CPU_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktToCpu[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        case CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktToAnalyzer[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        case CPSS_DXCH_PCL_EGRESS_PKT_TS_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktTs[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        case CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktNonTs[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return prvCpssDrvHwPpPortGroupSetRegField(
            devNum, portGroupId, regAddr,
            OFFSET_TO_BIT_MAC(bitPos), 1, hwValue);
}

/**
* @internal cpssDxCh2EgressPclPacketTypesSet function
* @endinternal
*
* @brief   Enables/disables Egress PCL (EPCL) for set of packet types on port
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] port                     -  number
* @param[in] pktType                  - packet type to enable/disable EPCL for it
* @param[in] enable                   -  EPCL for specific packet type
*                                      GT_TRUE - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note - after reset EPCL disabled for all packet types on all ports
*
*/
GT_STATUS cpssDxCh2EgressPclPacketTypesSet
(
    IN GT_U8                             devNum,
    IN GT_PHYSICAL_PORT_NUM              port,
    IN CPSS_DXCH_PCL_EGRESS_PKT_TYPE_ENT pktType,
    IN GT_BOOL                           enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxCh2EgressPclPacketTypesSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, port, pktType, enable));

    rc = internal_cpssDxCh2EgressPclPacketTypesSet(devNum, port, pktType, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, port, pktType, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxCh2EgressPclPacketTypesGet function
* @endinternal
*
* @brief   Get status of Egress PCL (EPCL) for set of packet types on port
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] port                     -  number
* @param[in] pktType                  - packet type to enable/disable EPCL for it
*
* @param[out] enablePtr                - enable EPCL for specific packet type
*                                      GT_TRUE - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_BAD_PTR               - on NULL pointer
*/
static GT_STATUS internal_cpssDxCh2EgressPclPacketTypesGet
(
    IN  GT_U8                             devNum,
    IN  GT_PHYSICAL_PORT_NUM              port,
    IN  CPSS_DXCH_PCL_EGRESS_PKT_TYPE_ENT pktType,
    OUT GT_BOOL                           *enablePtr
)
{
    GT_STATUS rc;
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */
    GT_U32  fieldName;  /* name of the field */
    GT_U32  bitPos;     /* position of a bit */
    CPSS_DXCH_TABLE_ENT tableType; /* table's type */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum, port);
        /* Bobcat2; Caelum; Bobcat3 */
        switch (pktType)
        {
            case CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_EPCL_FROM_CPU_CONTROL_PACKETS_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_DATA_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_EPCL_FROM_CPU_DATA_PACKETS_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_TO_CPU_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_2_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_2_FIELDS_EPCL_TO_CPU_PACKETS_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_2_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_2_FIELDS_EPCL_TO_ANALYZER_PACKETS_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_TS_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_EPCL_TS_DATA_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E:
                tableType = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E;
                fieldName = SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_EPCL_NON_TS_DATA_PORT_ENABLE_E;
                break;
            case CPSS_DXCH_PCL_EGRESS_PKT_DROP_E:
                if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
                {
                    rc = prvCpssDxChReadTableEntryField(devNum,
                                                        CPSS_DXCH_SIP6_TABLE_EGRESS_PCL_TARGET_PHYSICAL_PORT_MAPPING_E,
                                                        port,
                                                        PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                                        17, 1, &hwValue);
                    if(GT_OK != rc)
                    {
                        return rc;
                    }
                    *enablePtr = (hwValue == 0) ? GT_FALSE : GT_TRUE;
                    return rc;
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                break;

            default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        rc = prvCpssDxChReadTableEntryField(
              devNum,
              tableType,
              port,
              PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
              fieldName, /* field name */
              PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
              &hwValue);
        if(GT_OK != rc)
        {
            return rc;
        }

        *enablePtr = (hwValue == 0) ? GT_FALSE : GT_TRUE;
        return rc;
    }

    /* xCat3; AC5; Lion2 */
    PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, port);

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, port);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,port);

    /* get the start bit 0..63 (in the bmp of registers) */
    bitPos = (localPort == CPSS_CPU_PORT_NUM_CNS) ?
             PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) :
             localPort;

    switch (pktType)
    {
        case CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktFromCpuControl[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        case CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_DATA_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktFromCpuData[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        case CPSS_DXCH_PCL_EGRESS_PKT_TO_CPU_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktToCpu[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        case CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktToAnalyzer[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        case CPSS_DXCH_PCL_EGRESS_PKT_TS_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktTs[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        case CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E:
            regAddr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclEnPktNonTs[OFFSET_TO_WORD_MAC(bitPos)];
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssDrvHwPpPortGroupGetRegField(
            devNum, portGroupId, regAddr,
            OFFSET_TO_BIT_MAC(bitPos), 1, &hwValue);
    if(GT_OK != rc)
    {
        return rc;
    }

    *enablePtr = (hwValue == 0) ? GT_FALSE : GT_TRUE;

    return rc;
}

/**
* @internal cpssDxCh2EgressPclPacketTypesGet function
* @endinternal
*
* @brief   Get status of Egress PCL (EPCL) for set of packet types on port
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] port                     -  number
* @param[in] pktType                  - packet type to enable/disable EPCL for it
*
* @param[out] enablePtr                - enable EPCL for specific packet type
*                                      GT_TRUE - enable
*                                      GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_BAD_PTR               - on NULL pointer
*/
GT_STATUS cpssDxCh2EgressPclPacketTypesGet
(
    IN  GT_U8                             devNum,
    IN  GT_PHYSICAL_PORT_NUM              port,
    IN  CPSS_DXCH_PCL_EGRESS_PKT_TYPE_ENT pktType,
    OUT GT_BOOL                           *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxCh2EgressPclPacketTypesGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, port, pktType, enablePtr));

    rc = internal_cpssDxCh2EgressPclPacketTypesGet(devNum, port, pktType, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, port, pktType, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxCh3PclTunnelTermForceVlanModeEnableSet function
* @endinternal
*
* @brief   The function enables/disables forcing of the PCL ID configuration
*         for all TT packets according to the VLAN assignment.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - force TT packets assigned to PCL
*                                      configuration table entry
*                                      GT_TRUE  - By VLAN
*                                      GT_FALSE - according to ingress port
*                                      per lookup settings
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxCh3PclTunnelTermForceVlanModeEnableSet
(
    IN  GT_U8                         devNum,
    IN  GT_BOOL                       enable
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitNum;        /* bit number                          */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).TTIEngine.TTIEngineConfig;
        bitNum = 5;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiEngineConfig;
        bitNum = 10;
    }

    /* 1 - enable, 0 - disable */
    hwValue = (enable == GT_FALSE) ? 0 : 1;

    return prvCpssHwPpSetRegField(devNum, regAddr, bitNum, 1, hwValue);
}

/**
* @internal cpssDxCh3PclTunnelTermForceVlanModeEnableSet function
* @endinternal
*
* @brief   The function enables/disables forcing of the PCL ID configuration
*         for all TT packets according to the VLAN assignment.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - force TT packets assigned to PCL
*                                      configuration table entry
*                                      GT_TRUE  - By VLAN
*                                      GT_FALSE - according to ingress port
*                                      per lookup settings
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxCh3PclTunnelTermForceVlanModeEnableSet
(
    IN  GT_U8                         devNum,
    IN  GT_BOOL                       enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxCh3PclTunnelTermForceVlanModeEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxCh3PclTunnelTermForceVlanModeEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxCh3PclTunnelTermForceVlanModeEnableGet function
* @endinternal
*
* @brief   The function gets enable/disable of the forcing of the PCL ID configuration
*         for all TT packets according to the VLAN assignment.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) force TT packets assigned to PCL
*                                      configuration table entry
*                                      GT_TRUE  - By VLAN
*                                      GT_FALSE - according to ingress port
*                                      per lookup settings
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxCh3PclTunnelTermForceVlanModeEnableGet
(
    IN  GT_U8                         devNum,
    OUT GT_BOOL                       *enablePtr
)
{
    GT_STATUS rc;            /* return code                         */
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    bitNum;        /* bit number                          */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).TTIEngine.TTIEngineConfig;
        bitNum = 5;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiEngineConfig;
        bitNum = 10;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, bitNum, 1, &hwValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* 1 - enable, 0 - disable */
    *enablePtr = (hwValue == 0) ? GT_FALSE : GT_TRUE;

    return GT_OK;
}

/**
* @internal cpssDxCh3PclTunnelTermForceVlanModeEnableGet function
* @endinternal
*
* @brief   The function gets enable/disable of the forcing of the PCL ID configuration
*         for all TT packets according to the VLAN assignment.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to) force TT packets assigned to PCL
*                                      configuration table entry
*                                      GT_TRUE  - By VLAN
*                                      GT_FALSE - according to ingress port
*                                      per lookup settings
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxCh3PclTunnelTermForceVlanModeEnableGet
(
    IN  GT_U8                         devNum,
    OUT GT_BOOL                       *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxCh3PclTunnelTermForceVlanModeEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxCh3PclTunnelTermForceVlanModeEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxCh2PclTcpUdpPortComparatorSet function
* @endinternal
*
* @brief   Configure TCP or UDP Port Comparator entry
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] l4Protocol               - protocol, TCP or UDP
* @param[in] entryIndex               - entry index
*                                       (APPLICABLE RANGES: xCat3, AC5, Lion2, Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman 0..7;
*                                                           AC5P 0..63)
* @param[in] l4PortType               - TCP/UDP port type, source or destination port
* @param[in] compareOperator          - compare operator FALSE, LTE, GTE, NEQ
* @param[in] value                    - 16 bit  to compare with
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxCh2PclTcpUdpPortComparatorSet
(
    IN GT_U8                             devNum,
    IN CPSS_PCL_DIRECTION_ENT            direction,
    IN CPSS_L4_PROTOCOL_ENT              l4Protocol,
    IN GT_U8                             entryIndex,
    IN CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortType,
    IN CPSS_COMPARE_OPERATOR_ENT         compareOperator,
    IN GT_U16                            value
)
{
    return cpssDxChPclPortGroupTcpUdpPortComparatorSet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        direction, l4Protocol, entryIndex,
        l4PortType, compareOperator, value);
}

/**
* @internal cpssDxCh2PclTcpUdpPortComparatorSet function
* @endinternal
*
* @brief   Configure TCP or UDP Port Comparator entry
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] l4Protocol               - protocol, TCP or UDP
* @param[in] entryIndex               - entry index
*                                       (APPLICABLE RANGES: xCat3, AC5, Lion2, Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman 0..7;
*                                                           AC5P 0..63)
* @param[in] l4PortType               - TCP/UDP port type, source or destination port
* @param[in] compareOperator          - compare operator FALSE, LTE, GTE, NEQ
* @param[in] value                    - 16 bit  to compare with
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxCh2PclTcpUdpPortComparatorSet
(
    IN GT_U8                             devNum,
    IN CPSS_PCL_DIRECTION_ENT            direction,
    IN CPSS_L4_PROTOCOL_ENT              l4Protocol,
    IN GT_U8                             entryIndex,
    IN CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortType,
    IN CPSS_COMPARE_OPERATOR_ENT         compareOperator,
    IN GT_U16                            value
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxCh2PclTcpUdpPortComparatorSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, l4Protocol, entryIndex, l4PortType, compareOperator, value));

    rc = internal_cpssDxCh2PclTcpUdpPortComparatorSet(devNum, direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, l4Protocol, entryIndex, l4PortType, compareOperator, value));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxCh2PclTcpUdpPortComparatorGet function
* @endinternal
*
* @brief   Get TCP or UDP Port Comparator entry
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] l4Protocol               - protocol, TCP or UDP
* @param[in] entryIndex               - entry index
*                                       (APPLICABLE RANGES: xCat3, AC5, Lion2, Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman 0..7;
*                                                           AC5P 0..63)
*
* @param[out] l4PortTypePtr            - TCP/UDP port type, source or destination port
* @param[out] compareOperatorPtr       - compare operator FALSE, LTE, GTE, NEQ
* @param[out] valuePtr                 - 16 bit value to compare with
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_BAD_PTR               - on NULL pointer
*/
static GT_STATUS internal_cpssDxCh2PclTcpUdpPortComparatorGet
(
    IN  GT_U8                             devNum,
    IN  CPSS_PCL_DIRECTION_ENT            direction,
    IN  CPSS_L4_PROTOCOL_ENT              l4Protocol,
    IN  GT_U8                             entryIndex,
    OUT CPSS_L4_PROTOCOL_PORT_TYPE_ENT    *l4PortTypePtr,
    OUT CPSS_COMPARE_OPERATOR_ENT         *compareOperatorPtr,
    OUT GT_U16                            *valuePtr
)
{
    return cpssDxChPclPortGroupTcpUdpPortComparatorGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        direction, l4Protocol, entryIndex,
        l4PortTypePtr, compareOperatorPtr, valuePtr);
}

/**
* @internal cpssDxCh2PclTcpUdpPortComparatorGet function
* @endinternal
*
* @brief   Get TCP or UDP Port Comparator entry
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] l4Protocol               - protocol, TCP or UDP
* @param[in] entryIndex               - entry index
*                                       (APPLICABLE RANGES: xCat3, AC5, Lion2, Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman 0..7;
*                                                           AC5P 0..63)
*
* @param[out] l4PortTypePtr            - TCP/UDP port type, source or destination port
* @param[out] compareOperatorPtr       - compare operator FALSE, LTE, GTE, NEQ
* @param[out] valuePtr                 - 16 bit value to compare with
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_BAD_PTR               - on NULL pointer
*/
GT_STATUS cpssDxCh2PclTcpUdpPortComparatorGet
(
    IN  GT_U8                             devNum,
    IN  CPSS_PCL_DIRECTION_ENT            direction,
    IN  CPSS_L4_PROTOCOL_ENT              l4Protocol,
    IN  GT_U8                             entryIndex,
    OUT CPSS_L4_PROTOCOL_PORT_TYPE_ENT    *l4PortTypePtr,
    OUT CPSS_COMPARE_OPERATOR_ENT         *compareOperatorPtr,
    OUT GT_U16                            *valuePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxCh2PclTcpUdpPortComparatorGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, l4Protocol, entryIndex, l4PortTypePtr, compareOperatorPtr, valuePtr));

    rc = internal_cpssDxCh2PclTcpUdpPortComparatorGet(devNum, direction, l4Protocol, entryIndex, l4PortTypePtr, compareOperatorPtr, valuePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, l4Protocol, entryIndex, l4PortTypePtr, compareOperatorPtr, valuePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclRuleStateGet function
* @endinternal
*
* @brief   Get state (valid or not) of the rule and it's size
*         Old function for DxCh1 and DxCh2 devices and for
*         standard rules on DxCh3 devices.
*         The general function is cpssDxChPclRuleAnyStateGet
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleIndex                - index of rule
*
* @param[out] validPtr                 -  rule's validity
*                                      GT_TRUE  - rule valid
*                                      GT_FALSE - rule invalid
* @param[out] ruleSizePtr              -  rule's size
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclRuleStateGet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        tcamIndex,
    IN  GT_U32                        ruleIndex,
    OUT GT_BOOL                       *validPtr,
    OUT CPSS_PCL_RULE_SIZE_ENT        *ruleSizePtr
)
{
    return cpssDxChPclRuleAnyStateGet(
        devNum, tcamIndex, CPSS_PCL_RULE_SIZE_STD_E,
        ruleIndex, validPtr, ruleSizePtr);
}

/**
* @internal cpssDxChPclRuleStateGet function
* @endinternal
*
* @brief  Get state (valid or not) of the rule and it's size
*         Old function for DxCh1 and DxCh2 devices and for
*         standard rules on DxCh3 devices.
*         The general function is cpssDxChPclRuleAnyStateGet
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleIndex                - index of rule
*
* @param[out] validPtr                 -  rule's validity
*                                      GT_TRUE  - rule valid
*                                      GT_FALSE - rule invalid
* @param[out] ruleSizePtr              -  rule's size
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclRuleStateGet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        tcamIndex,
    IN  GT_U32                        ruleIndex,
    OUT GT_BOOL                       *validPtr,
    OUT CPSS_PCL_RULE_SIZE_ENT        *ruleSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclRuleStateGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcamIndex, ruleIndex, validPtr, ruleSizePtr));

    rc = internal_cpssDxChPclRuleStateGet(devNum, tcamIndex, ruleIndex, validPtr, ruleSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcamIndex, ruleIndex, validPtr, ruleSizePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclRuleAnyStateGet function
* @endinternal
*
* @brief   Get state (valid or not) of the rule and it's size
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of rule
* @param[in] ruleIndex                - index of rule
*
* @param[out] validPtr                 -  rule's validity
*                                      GT_TRUE  - rule valid
*                                      GT_FALSE - rule invalid
* @param[out] ruleSizePtr              -  rule's size
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclRuleAnyStateGet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT        ruleSize,
    IN  GT_U32                        ruleIndex,
    OUT GT_BOOL                       *validPtr,
    OUT CPSS_PCL_RULE_SIZE_ENT        *ruleSizePtr
)
{
    return cpssDxChPclPortGroupRuleAnyStateGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, tcamIndex,
        ruleSize, ruleIndex,
        validPtr, ruleSizePtr);
}

/**
* @internal cpssDxChPclRuleAnyStateGet function
* @endinternal
*
* @brief   Get state (valid or not) of the rule and it's size
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of rule
* @param[in] ruleIndex                - index of rule
*
* @param[out] validPtr                 -  rule's validity
*                                      GT_TRUE  - rule valid
*                                      GT_FALSE - rule invalid
* @param[out] ruleSizePtr              -  rule's size
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclRuleAnyStateGet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT        ruleSize,
    IN  GT_U32                        ruleIndex,
    OUT GT_BOOL                       *validPtr,
    OUT CPSS_PCL_RULE_SIZE_ENT        *ruleSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclRuleAnyStateGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcamIndex, ruleSize, ruleIndex, validPtr, ruleSizePtr));

    rc = internal_cpssDxChPclRuleAnyStateGet(devNum, tcamIndex, ruleSize, ruleIndex, validPtr, ruleSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcamIndex, ruleSize, ruleIndex, validPtr, ruleSizePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclRuleGet function
* @endinternal
*
* @brief   The function gets the Policy Rule Mask, Pattern and Action in Hw format
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM.
*
* @param[out] maskArr[]                - rule mask          - 21  words.
* @param[out] patternArr[]             - rule pattern       - 21  words.
* @param[out] actionArr[]              - Policy rule action - 8 words.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclRuleGet
(
    IN  GT_U8                  devNum,
    IN  GT_U32                 tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT ruleSize,
    IN  GT_U32                 ruleIndex,
    OUT GT_U32                 maskArr[],
    OUT GT_U32                 patternArr[],
    OUT GT_U32                 actionArr[]
)
{
    return cpssDxChPclPortGroupRuleGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, tcamIndex,
        ruleSize, ruleIndex,
        maskArr, patternArr, actionArr);
}

/**
* @internal cpssDxChPclRuleGet function
* @endinternal
*
* @brief   The function gets the Policy Rule Mask, Pattern and Action in Hw format
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM.
*
* @param[out] maskArr[]                - rule mask          - 21  words.
* @param[out] patternArr[]             - rule pattern       - 21  words.
* @param[out] actionArr[]              - Policy rule action - 8 words.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclRuleGet
(
    IN  GT_U8                  devNum,
    IN  GT_U32                 tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT ruleSize,
    IN  GT_U32                 ruleIndex,
    OUT GT_U32                 maskArr[], /*maxArraySize=21*/
    OUT GT_U32                 patternArr[], /*maxArraySize=21*/
    OUT GT_U32                 actionArr[] /*maxArraySize=8*/
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclRuleGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tcamIndex, ruleSize, ruleIndex, maskArr, patternArr, actionArr));

    rc = internal_cpssDxChPclRuleGet(devNum, tcamIndex, ruleSize, ruleIndex, maskArr, patternArr, actionArr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tcamIndex, ruleSize, ruleIndex, maskArr, patternArr, actionArr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclCfgTblEntryGet function
* @endinternal
*
* @brief   Gets the PCL configuration table entry in Hw format.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Ingress Policy or Egress Policy
*                                      (CPSS_PCL_DIRECTION_ENT member),
* @param[in] lookupNum                - Lookup number: lookup0 or lookup1
*                                      xCat3 and above supports the parameter
*                                      xCat3 and above devices has separate HW entries
*                                      for both ingress lookups.
*                                      Only lookup 0 is supported for egress.
* @param[in] entryIndex               - PCL configuration table entry Index
*
* @param[out] pclCfgTblEntryPtr        - pcl Cfg Tbl Entry
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_BAD_STATE             - in case of already bound pclHwId with same
*                                       combination of slot/direction
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note DxCh devices support ingress direction only
*
*/
static GT_STATUS internal_cpssDxChPclCfgTblEntryGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN  GT_U32                          entryIndex,
    OUT GT_U32                          *pclCfgTblEntryPtr
)
{
    return cpssDxChPclPortGroupCfgTblEntryGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        direction, lookupNum, entryIndex, pclCfgTblEntryPtr);
}

/**
* @internal cpssDxChPclCfgTblEntryGet function
* @endinternal
*
* @brief   Gets the PCL configuration table entry in Hw format.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Ingress Policy or Egress Policy
*                                      (CPSS_PCL_DIRECTION_ENT member),
* @param[in] lookupNum                - Lookup number: lookup0 or lookup1
*                                      xCat3 and above supports the parameter
*                                      xCat3 and above devices has separate HW entries
*                                      for both ingress lookups.
*                                      Only lookup 0 is supported for egress.
* @param[in] entryIndex               - PCL configuration table entry Index
*
* @param[out] pclCfgTblEntryPtr        - pcl Cfg Tbl Entry
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_BAD_STATE             - in case of already bound pclHwId with same
*                                       combination of slot/direction
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note DxCh devices support ingress direction only
*
*/
GT_STATUS cpssDxChPclCfgTblEntryGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN  GT_U32                          entryIndex,
    OUT GT_U32                          *pclCfgTblEntryPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclCfgTblEntryGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, lookupNum, entryIndex, pclCfgTblEntryPtr));

    rc = internal_cpssDxChPclCfgTblEntryGet(devNum, direction, lookupNum, entryIndex, pclCfgTblEntryPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, lookupNum, entryIndex, pclCfgTblEntryPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclLookupCfgPortListEnableSet function
* @endinternal
*
* @brief   The function enables/disables using port-list in search keys.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] lookupNum                - lookup number: 0,1
* @param[in] subLookupNum             - Sub lookup Number - for ingress CPSS_PCL_LOOKUP_0_E
*                                      means 0: lookup0_0, 1: lookup0_1,
*                                      for other cases not relevant.
* @param[in] enable                   - GT_TRUE  -  port-list in search key
*                                      GT_FALSE - disable port-list in search key
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclLookupCfgPortListEnableSet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    IN  GT_BOOL                       enable
)
{
    return cpssDxChPclPortGroupLookupCfgPortListEnableSet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        direction, lookupNum, subLookupNum, enable);
}

/**
* @internal cpssDxChPclLookupCfgPortListEnableSet function
* @endinternal
*
* @brief   The function enables/disables using port-list in search keys.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] lookupNum                - lookup number: 0,1
* @param[in] subLookupNum             - Sub lookup Number - for ingress CPSS_PCL_LOOKUP_0_E
*                                      means 0: lookup0_0, 1: lookup0_1,
*                                      for other cases not relevant.
* @param[in] enable                   - GT_TRUE  -  port-list in search key
*                                      GT_FALSE - disable port-list in search key
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclLookupCfgPortListEnableSet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    IN  GT_BOOL                       enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclLookupCfgPortListEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, lookupNum, subLookupNum, enable));

    rc = internal_cpssDxChPclLookupCfgPortListEnableSet(devNum, direction, lookupNum, subLookupNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, lookupNum, subLookupNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclLookupCfgPortListEnableGet function
* @endinternal
*
* @brief   The function gets enable/disable state of
*         using port-list in search keys.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] lookupNum                - lookup number: 0,1
* @param[in] subLookupNum             - Sub lookup Number - for ingress CPSS_PCL_LOOKUP_0_E
*                                      means 0: lookup0_0, 1: lookup0_1,
*                                      for other cases not relevant.
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE  - enable port-list in search key
*                                      GT_FALSE - disable port-list in search key
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclLookupCfgPortListEnableGet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    OUT GT_BOOL                       *enablePtr
)
{
    return cpssDxChPclPortGroupLookupCfgPortListEnableGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        direction, lookupNum, subLookupNum, enablePtr);
}

/**
* @internal cpssDxChPclLookupCfgPortListEnableGet function
* @endinternal
*
* @brief   The function gets enable/disable state of
*         using port-list in search keys.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] lookupNum                - lookup number: 0,1
* @param[in] subLookupNum             - Sub lookup Number - for ingress CPSS_PCL_LOOKUP_0_E
*                                      means 0: lookup0_0, 1: lookup0_1,
*                                      for other cases not relevant.
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE  - enable port-list in search key
*                                      GT_FALSE - disable port-list in search key
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclLookupCfgPortListEnableGet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    OUT GT_BOOL                       *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclLookupCfgPortListEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, lookupNum, subLookupNum, enablePtr));

    rc = internal_cpssDxChPclLookupCfgPortListEnableGet(devNum, direction, lookupNum, subLookupNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, lookupNum, subLookupNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupRuleSet function
* @endinternal
*
* @brief   The function sets the Policy Rule Mask, Pattern and Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleFormat               - format of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM. The rule index defines
*                                      order of action resolution in the cases of multiple
*                                      rules match with packet's search key. Action of the
*                                      matched rule with lowest index is taken in this case
*                                      With reference to Standard and Extended rules
*                                      indexes, the partitioning is as follows:
*                                      For xCat3 and above devices:
*                                      See datasheet of particular device for TCAM size.
*                                      For example describe the TCAM that has 1/4K (256) rows.
*                                      Each row can be used as:
*                                      - 4 standard rules
*                                      - 2 extended rules
*                                      - 1 extended and 2 standard rules
*                                      - 2 standard and 1 extended rules
*                                      The TCAM partitioning is as follows:
*                                      - Standard rules.
*                                      Rule index may be in the range from 0 up to 1K (1024).
*                                      - Extended rules.
*                                      Rule index may be in the range from 0 up to 0.5K (512).
*                                      Extended rule consumes the space of two standard
*                                      rules:
*                                      - Extended rule with index 2n (even index)
*                                      is placed in the space of two standard rules with
*                                      indexes 4n and 4n + 1.
*                                      - Extended rule with index 2n+1 (odd index)
*                                      is placed in the space of two standard rules with
*                                      indexes 4n+2 and 4n + 3.
* @param[in] ruleOptionsBmp           - Bitmap of rule's options.
*                                      The CPSS_DXCH_PCL_RULE_OPTION_ENT defines meaning of each bit.
*                                      Samples:
* @param[in] ruleOptionsBmp           = 0 - no options are defined.
*                                      Write rule to TCAM not using port-list format.
*                                      Rule state is valid.
* @param[in] ruleOptionsBmp           = CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E -
*                                      write all fields of rule to TCAM but rule's
*                                      state is invalid (no match during lookups).
* @param[in] maskPtr                  - rule mask. The rule mask is AND styled one. Mask
*                                      bit's 0 means don't care bit (corresponding bit in
*                                      the pattern is not using in the TCAM lookup).
*                                      Mask bit's 1 means that corresponding bit in the
*                                      pattern is using in the TCAM lookup.
*                                      The format of mask is defined by ruleFormat
* @param[in] patternPtr               - rule pattern.
*                                      The format of pattern is defined by ruleFormat
* @param[in] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - null pointer
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The pattern and mask input structures should be set to zero
*       by an application before assignment of fields.
*       The function places all muxed fields to rule patern and mask
*       by using bitwise OR operation.
*       The function does not check validity of muxed (overlapped) fields.
*
*/
static GT_STATUS internal_cpssDxChPclPortGroupRuleSet
(
    IN GT_U8                                            devNum,
    IN GT_PORT_GROUPS_BMP                               portGroupsBmp,
    IN GT_U32                                           tcamIndex,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               ruleFormat,
    IN GT_U32                                           ruleIndex,
    IN CPSS_DXCH_PCL_RULE_OPTION_ENT                    ruleOptionsBmp,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *maskPtr,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *patternPtr,
    IN CPSS_DXCH_PCL_ACTION_STC                         *actionPtr
)
{
    GT_STATUS    rc;            /* return code                          */
    GT_U32       ruleSize;      /* ruleSize (in STD rules)              */
                    /* for E_ARCH - CPSS_DXCH_TCAM_RULE_SIZE_ENT member */
    GT_U32       hwAction[CPSS_DXCH_PCL_ACTION_SIZE_IN_WORDS_CNS];
                                /* action in HW format                  */
    GT_U32       hwMask[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS];
                                /* mask in HW format                    */
    GT_U32       hwPattern[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS];
                                /* pattern in HW format                 */
    GT_BOOL      egressRule;    /* egress Rule                          */
    GT_BOOL      validRule;     /* write valid rule                     */
    GT_U32       portGroupId;   /* port group Id                        */
    PRV_CPSS_DXCH_PCL_RULE_SOURCE_PORT_GROUP_MODIFIED_FLD_STC fldSrc;
    PRV_CPSS_DXCH_PCL_RULE_STORE_PORT_GROUP_MODIFIED_FLD_STC  storeFld;
    GT_U32      entryNumber = 0;/* Rule's index in TCAM    */
    GT_U32      dummy;
    CPSS_DXCH_TCAM_RULE_SIZE_ENT tcamRuleSize = CPSS_DXCH_TCAM_RULE_SIZE_10_B_E; /* default */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(maskPtr);
    CPSS_NULL_PTR_CHECK_MAC(patternPtr);
    CPSS_NULL_PTR_CHECK_MAC(actionPtr);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_UNIT_MAC(devNum,portGroupsBmp,PRV_CPSS_DXCH_UNIT_TCAM_E);
    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        && (tcamIndex > 1))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,"PCL tcamIndex out of range.");
    }

    if((CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E == ruleFormat && !PRV_CPSS_SIP_6_10_CHECK_MAC(devNum)) ||
       (CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E == ruleFormat && !PRV_CPSS_SIP_6_10_CHECK_MAC(devNum)))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* check rule format and get egressRule value */
    /* defaults to aviod compiler warnings        */
    ruleSize   = 1;
    egressRule = GT_FALSE;

    rc = prvCpssDxChPclRuleGetDirAndSize(
        ruleFormat, &egressRule, &ruleSize);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* convert rule's format to rule's size */
        PRV_CPSS_DXCH_PCL_CONVERT_RULE_FORMAT_TO_TCAM_RULE_SIZE_VAL_MAC(tcamRuleSize,ruleFormat);

        /* convert rule global index to TCAM entry number */
        rc = prvCpssDxChTcamRuleIndexToEntryNumber(devNum,ruleIndex,&entryNumber,&dummy);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        PRV_CPSS_DXCH_PCL_RULE_SIZE_INDEX_CHECK_MAC(devNum, ruleSize, ruleIndex);
    }

    if (egressRule != actionPtr->egressPolicy)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,"PCL action field egressPolicy must set to match the rule type direction.");
    }

    rc = prvCpssDxChPclRuleDataSw2HwConvert(
        devNum, ruleFormat,
        maskPtr, patternPtr, actionPtr,
        hwMask, hwPattern, hwAction);
    if (rc != GT_OK)
    {
        return rc;
    }

    validRule =
        (ruleOptionsBmp & CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E)
        ? GT_FALSE : GT_TRUE;

    if (PRV_CPSS_DXCH_LION_FAMILY_CHECK_MAC(devNum) == 0)
    {
        /* xCat3 and AC5 devices */
        /* write rule             */
        return prvCpssDxChPclTcamRuleWrite(
            devNum, 0 /*portGroupId*/, tcamIndex,
            ruleSize, ruleIndex, validRule,
            hwAction, hwMask, hwPattern);
    }

    /* retrieve modified fields sources */
    rc = prvCpssDxChPclRuleGetModifiedFieldsSources(
        ruleFormat, maskPtr, patternPtr, &fldSrc);
    if (rc != GT_OK)
    {
        return rc;
    }


    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        /* convert values according to current port group */
        rc = prvCpssDxChPclRuleDataConvertForPortGroup(
            devNum, portGroupId, &fldSrc, &storeFld);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* store converted values of fields to HW formated */
        /* of pattern and mask                             */
        rc = prvCpssDxChPclRuleDataStorePortGroupModifiedFields(
            devNum, &storeFld, hwMask, hwPattern);
        if (rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
             /* invalidate rule in TCAM */
            rc = cpssDxChTcamPortGroupRuleValidStatusSet(
                devNum, (1<<portGroupId), ruleIndex,GT_FALSE);
            if (rc != GT_OK)
            {
                return rc;
            }

            /* write action */
            rc = prvCpssDxChPortGroupWriteTableEntry(
                devNum, portGroupId,
                CPSS_DXCH_SIP5_TABLE_TCAM_PCL_TTI_ACTION_E,
                (entryNumber/2), hwAction);
            if (rc != GT_OK)
            {
                return rc;
            }

            /* write rule to the TCAM */
            rc = cpssDxChTcamPortGroupRuleWrite(
                devNum, (1<<portGroupId), ruleIndex,validRule,tcamRuleSize,hwPattern,hwMask);

            if (rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /* Lion2 devices - write rule */
            rc = prvCpssDxChPclTcamRuleWrite(
                devNum, portGroupId, tcamIndex,
                ruleSize, ruleIndex, validRule,
                hwAction, hwMask, hwPattern);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;

}

/**
* @internal cpssDxChPclPortGroupRuleSet function
* @endinternal
*
* @brief   The function sets the Policy Rule Mask, Pattern and Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleFormat               - format of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM. The rule index defines
*                                      order of action resolution in the cases of multiple
*                                      rules match with packet's search key. Action of the
*                                      matched rule with lowest index is taken in this case
*                                      With reference to Standard and Extended rules
*                                      indexes, the partitioning is as follows:
*                                      For xCat3 and above devices:
*                                      See datasheet of particular device for TCAM size.
*                                      For example describe the TCAM that has 1/4K (256) rows.
*                                      Each row can be used as:
*                                      - 4 standard rules
*                                      - 2 extended rules
*                                      - 1 extended and 2 standard rules
*                                      - 2 standard and 1 extended rules
*                                      The TCAM partitioning is as follows:
*                                      - Standard rules.
*                                      Rule index may be in the range from 0 up to 1K (1024).
*                                      - Extended rules.
*                                      Rule index may be in the range from 0 up to 0.5K (512).
*                                      Extended rule consumes the space of two standard
*                                      rules:
*                                      - Extended rule with index 2n (even index)
*                                      is placed in the space of two standard rules with
*                                      indexes 4n and 4n + 1.
*                                      - Extended rule with index 2n+1 (odd index)
*                                      is placed in the space of two standard rules with
*                                      indexes 4n+2 and 4n + 3.
* @param[in] ruleOptionsBmp           - Bitmap of rule's options.
*                                      The CPSS_DXCH_PCL_RULE_OPTION_ENT defines meaning of each bit.
*                                      Samples:
* @param[in] ruleOptionsBmp           = 0 - no options are defined.
*                                      Write rule to TCAM not using port-list format.
*                                      Rule state is valid.
* @param[in] ruleOptionsBmp           = CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E -
*                                      write all fields of rule to TCAM but rule's
*                                      state is invalid (no match during lookups).
* @param[in] maskPtr                  - rule mask. The rule mask is AND styled one. Mask
*                                      bit's 0 means don't care bit (corresponding bit in
*                                      the pattern is not using in the TCAM lookup).
*                                      Mask bit's 1 means that corresponding bit in the
*                                      pattern is using in the TCAM lookup.
*                                      The format of mask is defined by ruleFormat
* @param[in] patternPtr               - rule pattern.
*                                      The format of pattern is defined by ruleFormat
* @param[in] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - null pointer
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The pattern and mask input structures should be set to zero
*       by an application before assignment of fields.
*       The function places all muxed fields to rule patern and mask
*       by using bitwise OR operation.
*       The function does not check validity of muxed (overlapped) fields.
*
*/
GT_STATUS cpssDxChPclPortGroupRuleSet
(
    IN GT_U8                                            devNum,
    IN GT_PORT_GROUPS_BMP                               portGroupsBmp,
    IN GT_U32                                           tcamIndex,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               ruleFormat,
    IN GT_U32                                           ruleIndex,
    IN CPSS_DXCH_PCL_RULE_OPTION_ENT                    ruleOptionsBmp,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *maskPtr,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *patternPtr,
    IN CPSS_DXCH_PCL_ACTION_STC                         *actionPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupRuleSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC(
        (funcId, devNum, portGroupsBmp, tcamIndex, ruleFormat, ruleIndex,
         ruleOptionsBmp, maskPtr, patternPtr, actionPtr));

    rc = internal_cpssDxChPclPortGroupRuleSet(
        devNum, portGroupsBmp, tcamIndex, ruleFormat, ruleIndex,
        ruleOptionsBmp, maskPtr, patternPtr, actionPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC(
        (funcId, rc, devNum, portGroupsBmp, tcamIndex, ruleFormat, ruleIndex,
         ruleOptionsBmp, maskPtr, patternPtr, actionPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChPclBits191_1Drag function
* @endinternal
*
* @brief   The function drags bits [191:1] to [190:0] and bit [0] to 191
*         supported for devices up to Lion (inclusive) , but upper function not supports
*         ch3 and below
*
* @note   APPLICABLE DEVICES:      xCat3; AC5.
* @note   NOT APPLICABLE DEVICES:  Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in,out] ruleDataPtr              - (pointer to) 192-bit rule data buffer
* @param[in,out] ruleDataPtr              - (pointer to) 192-bit rule data buffer
*                                       None.
*/
static GT_VOID prvCpssDxChPclBits191_1Drag
(
    INOUT GT_U32                                         *ruleDataPtr
)
{
    GT_U32       workBit0;       /* bit value for drag         */
    GT_U32       workBit1;       /* bit value for drag         */
    GT_U32       i,j;            /* loop index                 */

    /* drag bit0 - to 191-th position   */
    /* drag bits [191:1] to [190:0]     */
    workBit0 = ruleDataPtr[0] & 1;
    for (i = 6; (i > 0); i--)
    {
        j = i - 1;
        workBit1 = ruleDataPtr[j] & 1;
        ruleDataPtr[j] =
            (((ruleDataPtr[j] >> 1) & 0x7FFFFFFF)
            | (workBit0 << 31));
        workBit0 = workBit1;
    }
}

/**
* @internal internal_cpssDxChPclPortGroupRuleParsedGet function
* @endinternal
*
* @brief   The function gets the Policy Rule valid state, Mask, Pattern and Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleFormat               - format of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM.
* @param[in] ruleOptionsBmp           - Bitmap of rule's options.
*                                      The CPSS_DXCH_PCL_RULE_OPTION_ENT defines meaning of each bit.
*                                      Samples:
* @param[in] ruleOptionsBmp           = 0 - no options are defined.
*
* @param[out] isRuleValidPtr           - GT_TRUE - rule is valid, GT_FALSE - rule is invalid
* @param[out] maskPtr                  - rule mask. The rule mask is AND styled one. Mask
*                                      bit's 0 means don't care bit (corresponding bit in
*                                      the pattern is not using in the TCAM lookup).
*                                      Mask bit's 1 means that corresponding bit in the
*                                      pattern is using in the TCAM lookup.
*                                      The format of mask is defined by ruleFormat
* @param[out] patternPtr               - rule pattern.
*                                      The format of pattern is defined by ruleFormat
* @param[out] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - null pointer
* @retval GT_BAD_STATE             - when size is trash or not related to ruleFormat.
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortGroupRuleParsedGet
(
    IN GT_U8                                            devNum,
    IN GT_PORT_GROUPS_BMP                               portGroupsBmp,
    IN GT_U32                                           tcamIndex,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               ruleFormat,
    IN GT_U32                                           ruleIndex,
    IN CPSS_DXCH_PCL_RULE_OPTION_ENT                    ruleOptionsBmp,
    OUT GT_BOOL                                         *isRuleValidPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                   *maskPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                   *patternPtr,
    OUT CPSS_DXCH_PCL_ACTION_STC                        *actionPtr
)
{
    GT_STATUS    rc;            /* return code                 */
    GT_U32       portGroupId;   /*the port group Id            */
    GT_U32       ruleSizeFound; /* rule size (in STD rules)    */
    GT_U32       ruleSizeVal;   /* rule  size (in STD rules)   */
    GT_BOOL      egressRule;    /* egress Rule                 */
    GT_U32       mask[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS] = {0};
                                /* mask in HW format           */
    GT_U32       pattern[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS];
                                /* pattern in HW format        */
    GT_U32       action[CPSS_DXCH_PCL_ACTION_SIZE_IN_WORDS_CNS];
                                /* action in HW format         */
    PRV_CPSS_DXCH_PCL_RULE_STORE_PORT_GROUP_MODIFIED_FLD_STC   storeFld;
                                /* srcPort and portListBmp retrieved from HW     */
    PRV_CPSS_DXCH_PCL_RULE_STC_PORT_GROUP_MODIFIED_PTRS_STC    maskSrcPointers;
                                /* pointers to srcPort and portListBmp in mask   */
    PRV_CPSS_DXCH_PCL_RULE_STC_PORT_GROUP_MODIFIED_PTRS_STC    patternSrcPointers;
                                /*pointers to srcPort and portListBmp in pattern */
    CPSS_DXCH_TCAM_RULE_SIZE_ENT tcamRuleSize;
    CPSS_DXCH_TCAM_RULE_SIZE_ENT tcamRuleSizeFound;
    GT_BOOL     validFound; /* is rule found valid     */
    GT_U32      entryNumber = 0;/* Rule's index in TCAM    */
    GT_U32      dummy;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(isRuleValidPtr);
    CPSS_NULL_PTR_CHECK_MAC(maskPtr);
    CPSS_NULL_PTR_CHECK_MAC(patternPtr);
    CPSS_NULL_PTR_CHECK_MAC(actionPtr);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_UNIT_MAC(devNum,portGroupsBmp,PRV_CPSS_DXCH_UNIT_TCAM_E);
    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        && (tcamIndex > 1))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,"PCL tcamIndex out of range.");
    }

    ruleOptionsBmp = ruleOptionsBmp;/*unused parameter*/

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
        devNum, portGroupsBmp, portGroupId);

    /* for not E_ARCH devices get ruleSizeVal */
    /* any case get egressRule                */
    rc = prvCpssDxChPclRuleGetDirAndSize(
        ruleFormat, &egressRule, &ruleSizeVal);
    if (rc != GT_OK)
    {
        return rc;
    }

    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* convert rule's format to rule's size */
        PRV_CPSS_DXCH_PCL_CONVERT_RULE_FORMAT_TO_TCAM_RULE_SIZE_VAL_MAC(tcamRuleSize,ruleFormat);

        rc = cpssDxChTcamPortGroupRuleValidStatusGet(
            devNum,portGroupsBmp,ruleIndex,isRuleValidPtr, &tcamRuleSizeFound);
        if (rc != GT_OK)
        {
            return rc;
        }

        if (tcamRuleSizeFound != tcamRuleSize)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }

        /* read rule from the TCAM */
        rc = cpssDxChTcamPortGroupRuleRead(
            devNum,portGroupsBmp,ruleIndex,&validFound,&tcamRuleSize,pattern,mask);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        PRV_CPSS_DXCH_PCL_RULE_SIZE_INDEX_CHECK_MAC(
            devNum, ruleSizeVal, ruleIndex);

        rc = prvCpssDxChPclTcamRuleStateGet(
            devNum, portGroupId, tcamIndex,
            ruleSizeVal, ruleIndex, isRuleValidPtr, &ruleSizeFound);
        if (rc != GT_OK)
        {
            return rc;
        }

        if (ruleSizeVal != ruleSizeFound)
        {
            /* source rule is valid, but has another size */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
        rc = prvCpssDxChPclTcamRuleDataGet(
            devNum, portGroupId, tcamIndex,
            ruleSizeVal, ruleIndex, mask, pattern);
        if (rc != GT_OK)
        {
            return rc;
        }

        if ((egressRule != GT_FALSE)
            && (PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum) == 0)
            /* next 2 keys not need the 'shift' (not hold 'valid bit' at bit 0)*/
            && (ruleFormat != CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E)
            && (ruleFormat != CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E)
            )
        {
            /* egress rules xCat and Lion             */
            /* drag bit0 - valid to 191-th position   */
            /* drag bits [191:1] to [190:0]           */
            /* to be at the same places as on devices */
            /* xCat2 and above                        */
            prvCpssDxChPclBits191_1Drag(mask);
            prvCpssDxChPclBits191_1Drag(pattern);
        }
    }

    rc = prvCpssDxChPclTcamRuleDataHw2SwConvert(
        devNum, ruleFormat, mask, maskPtr);
    if (rc != GT_OK)
    {
        return rc;
    }

    rc = prvCpssDxChPclTcamRuleDataHw2SwConvert(
        devNum, ruleFormat, pattern, patternPtr);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* convert rule global index to TCAM entry number */
        rc = prvCpssDxChTcamRuleIndexToEntryNumber(devNum,ruleIndex,&entryNumber,&dummy);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* read action */
        rc = prvCpssDxChPortGroupReadTableEntry(devNum,
                                                portGroupId,
                                                CPSS_DXCH_SIP5_TABLE_TCAM_PCL_TTI_ACTION_E,
                                                (entryNumber/2),
                                                action);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        rc = prvCpssDxChPclTcamActionGet(
            devNum, portGroupId, tcamIndex,
            ruleSizeVal, ruleIndex, action);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    rc = prvCpssDxChPclTcamRuleActionHw2SwConvert(
        devNum,
        ((egressRule == GT_FALSE)
            ? CPSS_PCL_DIRECTION_INGRESS_E
            : CPSS_PCL_DIRECTION_EGRESS_E),
        action, actionPtr);
    if (rc != GT_OK)
    {
        return rc;
    }

    if (! PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
    {
        return GT_OK;
    }

    /* the sip5 device does not need any conversions on the src port field */
    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
       return GT_OK;
    }

    rc = prvCpssDxChPclRuleGetModifiedFieldsSourcesPointers(
        ruleFormat, maskPtr, &maskSrcPointers);
    if (rc != GT_OK)
    {
        return rc;
    }

    rc = prvCpssDxChPclRuleGetModifiedFieldsSourcesPointers(
        ruleFormat, patternPtr, &patternSrcPointers);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Clear srcPort and port list after first retrieve */

    if (maskSrcPointers.srcPortPtr != NULL)
    {
        *(maskSrcPointers.srcPortPtr)    = 0;
    }

    if (patternSrcPointers.srcPortPtr != NULL)
    {
        *(patternSrcPointers.srcPortPtr)    = 0;
    }

    if(maskSrcPointers.portListBmpPtr &&
       patternSrcPointers.portListBmpPtr)
    {
        maskSrcPointers.portListBmpPtr->ports[0]    = 0;
        patternSrcPointers.portListBmpPtr->ports[0] = 0;
    }


    /* rescan the fields modified by RuleSet function */
    /* according to port group                        */
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        rc = prvCpssDxChPclTcamRuleDataGet(
                    devNum, portGroupId, tcamIndex,
                    ruleSizeVal, ruleIndex, mask, pattern);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* the xCat and Lion egress rules bits drag  */
        /* done before raw to structure conversion   */
        /* (see in this function upper)              */
        /* not relevant for rule formats treted here */
        storeFld.isEgress = egressRule;
        storeFld.ruleSize = ruleSizeVal;
        rc = prvCpssDxChPclRuleDataLoadPortGroupModifiedFields(
            devNum, mask, pattern, &storeFld);
        if (rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssDxChPclRuleDataAccumulateFromPortGroup(
            devNum, portGroupId, &storeFld,
            &maskSrcPointers, &patternSrcPointers);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupRuleParsedGet function
* @endinternal
*
* @brief   The function gets the Policy Rule valid state, Mask, Pattern and Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleFormat               - format of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM.
* @param[in] ruleOptionsBmp           - Bitmap of rule's options.
*                                      The CPSS_DXCH_PCL_RULE_OPTION_ENT defines meaning of each bit.
*                                      Samples:
* @param[in] ruleOptionsBmp           = 0 - no options are defined.
*
* @param[out] isRuleValidPtr           - GT_TRUE - rule is valid, GT_FALSE - rule is invalid
* @param[out] maskPtr                  - rule mask. The rule mask is AND styled one. Mask
*                                      bit's 0 means don't care bit (corresponding bit in
*                                      the pattern is not using in the TCAM lookup).
*                                      Mask bit's 1 means that corresponding bit in the
*                                      pattern is using in the TCAM lookup.
*                                      The format of mask is defined by ruleFormat
* @param[out] patternPtr               - rule pattern.
*                                      The format of pattern is defined by ruleFormat
* @param[out] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - null pointer
* @retval GT_BAD_STATE             - when size is trash or not related to ruleFormat.
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortGroupRuleParsedGet
(
    IN GT_U8                                            devNum,
    IN GT_PORT_GROUPS_BMP                               portGroupsBmp,
    IN GT_U32                                           tcamIndex,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               ruleFormat,
    IN GT_U32                                           ruleIndex,
    IN CPSS_DXCH_PCL_RULE_OPTION_ENT                    ruleOptionsBmp,
    OUT GT_BOOL                                         *isRuleValidPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                   *maskPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                   *patternPtr,
    OUT CPSS_DXCH_PCL_ACTION_STC                        *actionPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupRuleParsedGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC(
        (funcId, devNum, portGroupsBmp, tcamIndex, ruleFormat, ruleIndex,
         ruleOptionsBmp, isRuleValidPtr, maskPtr, patternPtr, actionPtr));

    rc = internal_cpssDxChPclPortGroupRuleParsedGet(
        devNum, portGroupsBmp, tcamIndex, ruleFormat, ruleIndex,
        ruleOptionsBmp, isRuleValidPtr, maskPtr, patternPtr, actionPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC(
        (funcId, rc, devNum, portGroupsBmp, tcamIndex, ruleFormat, ruleIndex,
         ruleOptionsBmp, isRuleValidPtr, maskPtr, patternPtr, actionPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupRuleActionUpdate function
* @endinternal
*
* @brief   The function updates the Rule Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule. (APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclPortGroupRuleSet.
* @param[in] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - null pointer
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note NONE
*
*/
static GT_STATUS internal_cpssDxChPclPortGroupRuleActionUpdate
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
{
    GT_STATUS    rc;          /* return code                 */
    GT_U32       portGroupId; /*the port group Id            */
    GT_U32       hwAction[CPSS_DXCH_PCL_ACTION_SIZE_IN_WORDS_CNS];
                              /* action in HW format       */
    GT_U32       ruleSizeVal=0; /* ruleSize (in STD rules)   */
    GT_U32       entryNumber = 0;/* Rule's index in TCAM    */
    GT_U32       dummy;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(actionPtr);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_UNIT_MAC(devNum,portGroupsBmp,PRV_CPSS_DXCH_UNIT_TCAM_E);
    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        && (tcamIndex > 1))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,"PCL tcamIndex out of range.");
    }

    /* convert action to HW format */
    rc = prvCpssDxChPclTcamRuleActionSw2HwConvert(
        devNum, actionPtr, hwAction);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* convert rule global index to TCAM entry number */
        rc = prvCpssDxChTcamRuleIndexToEntryNumber(devNum,ruleIndex,&entryNumber,&dummy);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        PRV_CPSS_DXCH_PCL_GET_RULE_SIZE_VALUE_MAC(ruleSize, ruleSizeVal);
        PRV_CPSS_DXCH_PCL_RULE_SIZE_INDEX_CHECK_MAC(devNum, ruleSizeVal, ruleIndex);
    }

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            /* write action */
            rc = prvCpssDxChPortGroupWriteTableEntry(devNum,
                                                     portGroupId,
                                                     CPSS_DXCH_SIP5_TABLE_TCAM_PCL_TTI_ACTION_E,
                                                     (entryNumber/2),
                                                     hwAction);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /* write action */
            rc = prvCpssDxChPclTcamRuleActionUpdate(
                devNum, portGroupId, tcamIndex,
                ruleSizeVal, ruleIndex, hwAction);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupRuleActionUpdate function
* @endinternal
*
* @brief   The function updates the Rule Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule. (APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclPortGroupRuleSet.
* @param[in] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - null pointer
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note NONE
*
*/
GT_STATUS cpssDxChPclPortGroupRuleActionUpdate
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupRuleActionUpdate);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, actionPtr));

    rc = internal_cpssDxChPclPortGroupRuleActionUpdate(
        devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, actionPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, actionPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupRuleActionGet function
* @endinternal
*
* @brief   The function gets the Rule Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule. (APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclPortGroupRuleSet.
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
*                                      Needed for parsing
*
* @param[out] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note NONE
*
*/
static GT_STATUS internal_cpssDxChPclPortGroupRuleActionGet
(
    IN  GT_U8                              devNum,
    IN  GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN  GT_U32                             tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN  GT_U32                             ruleIndex,
    IN  CPSS_PCL_DIRECTION_ENT             direction,
    OUT CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
{
    GT_STATUS    rc;          /* return code                 */
    GT_U32       portGroupId; /*the port group Id            */
    GT_U32       ruleSizeVal=0; /* rule  size (in STD rules)   */
    GT_U32       action[CPSS_DXCH_PCL_ACTION_SIZE_IN_WORDS_CNS];
                               /* action in HW format       */
    GT_U32       entryNumber = 0;/* Rule's index in TCAM    */
    GT_U32       dummy;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(actionPtr);
    PRV_CPSS_DXCH_PCL_DIRECTION_CHECK_MAC(direction);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_UNIT_MAC(devNum,portGroupsBmp,PRV_CPSS_DXCH_UNIT_TCAM_E);
    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        && (tcamIndex > 1))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,"PCL tcamIndex out of range.");
    }

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
        devNum, portGroupsBmp, portGroupId);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* convert rule global index to TCAM entry number */
        rc = prvCpssDxChTcamRuleIndexToEntryNumber(devNum,ruleIndex,&entryNumber,&dummy);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* read action */
        rc = prvCpssDxChPortGroupReadTableEntry(devNum,
                                                portGroupId,
                                                CPSS_DXCH_SIP5_TABLE_TCAM_PCL_TTI_ACTION_E,
                                                (entryNumber/2),
                                                action);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        PRV_CPSS_DXCH_PCL_GET_RULE_SIZE_VALUE_MAC(ruleSize, ruleSizeVal);
        PRV_CPSS_DXCH_PCL_RULE_SIZE_INDEX_CHECK_MAC(devNum, ruleSizeVal, ruleIndex);

        rc = prvCpssDxChPclTcamActionGet(
            devNum, portGroupId, tcamIndex,
            ruleSizeVal, ruleIndex, action);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return prvCpssDxChPclTcamRuleActionHw2SwConvert(
        devNum, direction, action, actionPtr);
}

/**
* @internal cpssDxChPclPortGroupRuleActionGet function
* @endinternal
*
* @brief   The function gets the Rule Action
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule. (APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclPortGroupRuleSet.
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
*                                      Needed for parsing
*
* @param[out] actionPtr                - Policy rule action that applied on packet if packet's
*                                      search key matched with masked pattern.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note NONE
*
*/
GT_STATUS cpssDxChPclPortGroupRuleActionGet
(
    IN  GT_U8                              devNum,
    IN  GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN  GT_U32                             tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN  GT_U32                             ruleIndex,
    IN  CPSS_PCL_DIRECTION_ENT             direction,
    OUT CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupRuleActionGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC(
        (funcId, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, direction, actionPtr));

    rc = internal_cpssDxChPclPortGroupRuleActionGet(
        devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, direction, actionPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC(
        (funcId, rc, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, direction, actionPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupRuleInvalidate function
* @endinternal
*
* @brief   The function invalidates the Policy Rule.
*         For DxCh and DxCh2 devices start indirect rule write operation
*         with "garbage" pattern and mask content and "valid-flag" == 0
*         For DxCh3 devices calculates the TCAM position by ruleSize and ruleIndex
*         parameters and updates the first "valid" bit matching X/Y pair to (1,1)
*         i.e. don't match any value. If origin of valid or invalid rule found at the
*         specified TCAM position it will be invalid and available to back validation.
*         If the specified TCAM position contains the not first 24 byte segment of
*         extended rule, the rule also will be invalidated,
*         but unavailable to back validation.
*         If the garbage found in TCAM the X/Y bits will be updated to be as
*         in invalid rule.
*         The function does not check the TCAM contents.
*         GT_OK will be returned in each of described cases.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.(APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclPortGroupRuleSet.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Backward compatible styled API.
*       The cpssDxChPclRuleValidStatusSet recommended for using instead.
*
*/
static GT_STATUS internal_cpssDxChPclPortGroupRuleInvalidate
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex
)
{
    GT_STATUS    rc;            /* return code                             */
    GT_U32       portGroupId;   /*the port group Id                        */
    GT_U32       ruleSizeVal;   /* rule size (in std rules)                */
    GT_U32       absIndex;      /* absolute rule index (in STD rules)      */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_UNIT_MAC(devNum,portGroupsBmp,PRV_CPSS_DXCH_UNIT_TCAM_E);
    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        && (tcamIndex > 1))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,"PCL tcamIndex out of range.");
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* invalidate rule in TCAM */
        rc = cpssDxChTcamPortGroupRuleValidStatusSet(devNum,portGroupsBmp,ruleIndex,GT_FALSE);

        return rc;
    }

    PRV_CPSS_DXCH_PCL_GET_RULE_SIZE_VALUE_MAC(ruleSize, ruleSizeVal);
    PRV_CPSS_DXCH_PCL_RULE_SIZE_INDEX_CHECK_MAC(devNum, ruleSizeVal, ruleIndex);


    /* get index of first Standard part of rule */
    rc = prvCpssDxChPclTcamRuleAbsoluteIndexGet(
        devNum, ruleSizeVal, ruleIndex, 0/*ruleSegment*/, &absIndex);
    if (rc != GT_OK)
    {
        return rc;
    }

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        /* invalidate first standard part of rule */
        rc = prvCpssDxChPclTcamStdRuleValidStateSet(
            devNum, portGroupId, tcamIndex, absIndex, GT_FALSE);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupRuleInvalidate function
* @endinternal
*
* @brief   The function invalidates the Policy Rule.
*         For DxCh and DxCh2 devices start indirect rule write operation
*         with "garbage" pattern and mask content and "valid-flag" == 0
*         For DxCh3 devices calculates the TCAM position by ruleSize and ruleIndex
*         parameters and updates the first "valid" bit matching X/Y pair to (1,1)
*         i.e. don't match any value. If origin of valid or invalid rule found at the
*         specified TCAM position it will be invalid and available to back validation.
*         If the specified TCAM position contains the not first 24 byte segment of
*         extended rule, the rule also will be invalidated,
*         but unavailable to back validation.
*         If the garbage found in TCAM the X/Y bits will be updated to be as
*         in invalid rule.
*         The function does not check the TCAM contents.
*         GT_OK will be returned in each of described cases.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.(APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM. See cpssDxChPclPortGroupRuleSet.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note Backward compatible styled API.
*       The cpssDxChPclRuleValidStatusSet recommended for using instead.
*
*/
GT_STATUS cpssDxChPclPortGroupRuleInvalidate
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupRuleInvalidate);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex));

    rc = internal_cpssDxChPclPortGroupRuleInvalidate(devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupRuleValidStatusSet function
* @endinternal
*
* @brief   Validates/Invalidates the Policy rule.
*         The validation of the rule is performed by next steps:
*         1. Retrieve the content of the rule from PP TCAM
*         2. Write content back to TCAM with Valid indication set.
*         The function does not check content of the rule before
*         write it back to TCAM
*         The invalidation of the rule is performed by next steps:
*         1. Retrieve the content of the rule from PP TCAM
*         2. Write content back to TCAM with Invalid indication set.
*         If the given the rule found already in needed valid state
*         no write done. If the given the rule found with size
*         different from the given rule-size an error code returned.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      port group(s). If a bit of non  port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.(APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM.
* @param[in] valid                    - new rule status: GT_TRUE - valid, GT_FALSE - invalid
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_STATE             - if in TCAM found rule of size different
*                                       from the specified
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortGroupRuleValidStatusSet
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN GT_BOOL                            valid
)
{
    GT_STATUS    rc;                           /* return code              */
    GT_U32       portGroupId;                  /* the port group Id        */
    GT_U32       ruleSizeVal;                  /* rule size (in std rules) */
    GT_U32       ruleSizeFound;                /* rule size found          */
    GT_BOOL      validFound;                   /* is rule found valid      */
    GT_U32       absIndex;      /* absolute rule inex (in STD rules)       */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_UNIT_MAC(devNum,portGroupsBmp,PRV_CPSS_DXCH_UNIT_TCAM_E);
    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        && (tcamIndex > 1))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,"PCL tcamIndex out of range.");
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* set valid status for rule in TCAM */
        rc = cpssDxChTcamPortGroupRuleValidStatusSet(devNum,portGroupsBmp,ruleIndex,valid);

        return rc;
    }

    PRV_CPSS_DXCH_PCL_GET_RULE_SIZE_VALUE_MAC(ruleSize, ruleSizeVal);
    PRV_CPSS_DXCH_PCL_RULE_SIZE_INDEX_CHECK_MAC(devNum, ruleSizeVal, ruleIndex);

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        rc = prvCpssDxChPclTcamRuleStateGet(
            devNum, portGroupId, tcamIndex,
            ruleSizeVal, ruleIndex, &validFound, &ruleSizeFound);
        if (rc != GT_OK)
        {
            return rc;
        }

        if (ruleSizeVal != ruleSizeFound)
        {
            /* source rule has another size */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }

        if (valid == validFound)
        {
            /* the rule is aready in requred valid state */
            return GT_OK;
        }

        rc = prvCpssDxChPclTcamRuleAbsoluteIndexGet(
            devNum, ruleSizeVal, ruleIndex, 0/*ruleSegment*/, &absIndex);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* modify validity of first standard part of rule*/
        rc = prvCpssDxChPclTcamStdRuleValidStateSet(
            devNum, portGroupId, tcamIndex, absIndex, valid);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupRuleValidStatusSet function
* @endinternal
*
* @brief   Validates/Invalidates the Policy rule.
*         The validation of the rule is performed by next steps:
*         1. Retrieve the content of the rule from PP TCAM
*         2. Write content back to TCAM with Valid indication set.
*         The function does not check content of the rule before
*         write it back to TCAM
*         The invalidation of the rule is performed by next steps:
*         1. Retrieve the content of the rule from PP TCAM
*         2. Write content back to TCAM with Invalid indication set.
*         If the given the rule found already in needed valid state
*         no write done. If the given the rule found with size
*         different from the given rule-size an error code returned.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      port group(s). If a bit of non  port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.(APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of the rule in the TCAM.
* @param[in] valid                    - new rule status: GT_TRUE - valid, GT_FALSE - invalid
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_STATE             - if in TCAM found rule of size different
*                                       from the specified
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortGroupRuleValidStatusSet
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN GT_BOOL                            valid
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupRuleValidStatusSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, valid));

    rc = internal_cpssDxChPclPortGroupRuleValidStatusSet(
        devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, valid);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, valid));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupRuleAnyStateGet function
* @endinternal
*
* @brief   Get state (valid or not) of the rule and it's size
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of rule. (APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of rule
*
* @param[out] validPtr                 -  rule's validity
*                                      GT_TRUE  - rule valid
*                                      GT_FALSE - rule invalid
* @param[out] ruleSizePtr              -  rule's size
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - null pointer
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS internal_cpssDxChPclPortGroupRuleAnyStateGet
(
    IN  GT_U8                         devNum,
    IN  GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN  GT_U32                        tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT        ruleSize,
    IN  GT_U32                        ruleIndex,
    OUT GT_BOOL                       *validPtr,
    OUT CPSS_PCL_RULE_SIZE_ENT        *ruleSizePtr
)
{
    GT_U32    ruleSizeVal=0; /* rule size (in STD rules)              */
    GT_U32    ruleSizeFound; /* rule size (in STD rules)              */
    GT_STATUS rc;            /* return code                           */
    GT_U32    portGroupId;   /* the port group Id                     */
    CPSS_DXCH_TCAM_RULE_SIZE_ENT tcamRuleSize; /* TCAM rule size      */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(validPtr);
    CPSS_NULL_PTR_CHECK_MAC(ruleSizePtr);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_UNIT_MAC(devNum,portGroupsBmp,PRV_CPSS_DXCH_UNIT_TCAM_E);
    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        && (tcamIndex > 1))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,"PCL tcamIndex out of range.");
    }

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
        devNum, portGroupsBmp, portGroupId);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* get valid status for rule in TCAM */
        rc = cpssDxChTcamPortGroupRuleValidStatusGet(
            devNum, portGroupsBmp, ruleIndex, validPtr, &tcamRuleSize);
        if (rc != GT_OK)
        {
            return rc;
        }

        switch (tcamRuleSize)
        {
            case CPSS_DXCH_TCAM_RULE_SIZE_30_B_E:
                *ruleSizePtr = CPSS_PCL_RULE_SIZE_STD_E;
                break;
            case CPSS_DXCH_TCAM_RULE_SIZE_60_B_E:
                *ruleSizePtr = CPSS_PCL_RULE_SIZE_EXT_E;
                break;
            case CPSS_DXCH_TCAM_RULE_SIZE_80_B_E:
                *ruleSizePtr = CPSS_PCL_RULE_SIZE_ULTRA_E;
                break;
            case CPSS_DXCH_TCAM_RULE_SIZE_10_B_E:
                *ruleSizePtr = CPSS_PCL_RULE_SIZE_10_BYTES_E;
                break;
            case CPSS_DXCH_TCAM_RULE_SIZE_20_B_E:
                *ruleSizePtr = CPSS_PCL_RULE_SIZE_20_BYTES_E;
                break;
            case CPSS_DXCH_TCAM_RULE_SIZE_40_B_E:
                *ruleSizePtr = CPSS_PCL_RULE_SIZE_40_BYTES_E;
                break;
            case CPSS_DXCH_TCAM_RULE_SIZE_50_B_E:
                *ruleSizePtr = CPSS_PCL_RULE_SIZE_50_BYTES_E;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        return GT_OK;
    }
    else
    {
        PRV_CPSS_DXCH_PCL_GET_RULE_SIZE_VALUE_MAC(ruleSize, ruleSizeVal);
        PRV_CPSS_DXCH_PCL_RULE_SIZE_INDEX_CHECK_MAC(devNum, ruleSizeVal, ruleIndex);

        rc = prvCpssDxChPclTcamRuleStateGet(
            devNum, portGroupId, tcamIndex,
            ruleSizeVal, ruleIndex, validPtr, &ruleSizeFound);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    *ruleSizePtr = (ruleSizeFound == 1) ?  CPSS_PCL_RULE_SIZE_STD_E :
                   (ruleSizeFound == 2) ?  CPSS_PCL_RULE_SIZE_EXT_E :
                                           CPSS_PCL_RULE_SIZE_ULTRA_E;

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupRuleAnyStateGet function
* @endinternal
*
* @brief   Get state (valid or not) of the rule and it's size
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of rule. (APPLICABLE DEVICES xCat3; AC5; Lion2)
* @param[in] ruleIndex                - index of rule
*
* @param[out] validPtr                 -  rule's validity
*                                      GT_TRUE  - rule valid
*                                      GT_FALSE - rule invalid
* @param[out] ruleSizePtr              -  rule's size
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - null pointer
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_HW_ERROR              - on hardware error
*/
GT_STATUS cpssDxChPclPortGroupRuleAnyStateGet
(
    IN  GT_U8                         devNum,
    IN  GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN  GT_U32                        tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT        ruleSize,
    IN  GT_U32                        ruleIndex,
    OUT GT_BOOL                       *validPtr,
    OUT CPSS_PCL_RULE_SIZE_ENT        *ruleSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupRuleAnyStateGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC(
        (funcId, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, validPtr, ruleSizePtr));

    rc = internal_cpssDxChPclPortGroupRuleAnyStateGet(
        devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, validPtr, ruleSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC(
        (funcId, rc, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, validPtr, ruleSizePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupRuleCopy function
* @endinternal
*
* @brief   The function copies the Rule's mask, pattern and action to new TCAM position.
*         The source Rule is not invalidated by the function. To implement move Policy
*         Rule from old position to new one at first cpssDxChPclPortGroupRuleCopy should be
*         called. And after this cpssDxChPclPortGroupRuleInvalidate or
*         cpssDxChPclPortGroupRuleValidStatusSet should
*         be used to invalidate Rule in old position.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.
* @param[in] ruleSrcIndex             - index of the rule in the TCAM from which pattern,
*                                      mask and action are taken.
* @param[in] ruleDstIndex             - index of the rule in the TCAM to which pattern,
*                                      mask and action are placed
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortGroupRuleCopy
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleSrcIndex,
    IN GT_U32                             ruleDstIndex
)
{
    GT_STATUS    rc;          /* return code                 */
    GT_U32       portGroupId; /* port group Id for multi-port-group devices */
    GT_U32       ruleSizeVal=0; /* rule size (in std rules)      */
    CPSS_DXCH_TCAM_RULE_SIZE_ENT tcamRuleSize = CPSS_DXCH_TCAM_RULE_SIZE_10_B_E; /* default */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_UNIT_MAC(devNum,portGroupsBmp,PRV_CPSS_DXCH_UNIT_TCAM_E);
    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        && (tcamIndex > 1))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,"PCL tcamIndex out of range.");
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* convert pcl rule's size to tcam rule's size */
        PRV_CPSS_DXCH_PCL_CONVERT_RULE_SIZE_TO_TCAM_RULE_SIZE_VAL_MAC(tcamRuleSize, ruleSize);
    }
    else
    {
        PRV_CPSS_DXCH_PCL_GET_RULE_SIZE_VALUE_MAC(ruleSize, ruleSizeVal);
        PRV_CPSS_DXCH_PCL_RULE_SIZE_INDEX_CHECK_MAC(
            devNum, ruleSizeVal, ruleSrcIndex);
        PRV_CPSS_DXCH_PCL_RULE_SIZE_INDEX_CHECK_MAC(
            devNum, ruleSizeVal, ruleDstIndex);
    }

    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChPclSip5RuleCopy(devNum, portGroupsBmp, tcamRuleSize, ruleSrcIndex, ruleDstIndex);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)
            {
                rc = prvCpssDxChPclRuleCopy(
                    devNum, portGroupId, tcamIndex,
                    ruleSizeVal, ruleSrcIndex, ruleDstIndex);
            }
            if (rc != GT_OK)
            {
                return rc;
            }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)
    }

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupRuleCopy function
* @endinternal
*
* @brief   The function copies the Rule's mask, pattern and action to new TCAM position.
*         The source Rule is not invalidated by the function. To implement move Policy
*         Rule from old position to new one at first cpssDxChPclPortGroupRuleCopy should be
*         called. And after this cpssDxChPclPortGroupRuleInvalidate or
*         cpssDxChPclPortGroupRuleValidStatusSet should
*         be used to invalidate Rule in old position.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of Rule.
* @param[in] ruleSrcIndex             - index of the rule in the TCAM from which pattern,
*                                      mask and action are taken.
* @param[in] ruleDstIndex             - index of the rule in the TCAM to which pattern,
*                                      mask and action are placed
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortGroupRuleCopy
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleSrcIndex,
    IN GT_U32                             ruleDstIndex
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupRuleCopy);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex));

    rc = internal_cpssDxChPclPortGroupRuleCopy(devNum, portGroupsBmp, tcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupRuleGet function
* @endinternal
*
* @brief   The function gets the Policy Rule Mask, Pattern and Action in Hw format
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM.
*
* @param[out] maskArr[]                - rule mask          - 21  words.
* @param[out] patternArr[]             - rule pattern       - 21  words.
* @param[out] actionArr[]              - Policy rule action - 4 words.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - null pointer
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclPortGroupRuleGet
(
    IN  GT_U8                  devNum,
    IN  GT_PORT_GROUPS_BMP     portGroupsBmp,
    IN  GT_U32                 tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT ruleSize,
    IN  GT_U32                 ruleIndex,
    OUT GT_U32                 maskArr[],
    OUT GT_U32                 patternArr[],
    OUT GT_U32                 actionArr[]
)
{
    GT_STATUS  rc;            /* return code                 */
    GT_U32     portGroupId;   /* port group Id               */
    GT_BOOL    valid;         /* valid source rule           */
    GT_U32     ruleSizeVal=0; /* rule size (in STD rules)    */
    GT_U32     ruleSizeFound; /* rule size (in STD rules)    */
    CPSS_DXCH_TCAM_RULE_SIZE_ENT tcamRuleSize; /* TCAM rule size */
    CPSS_DXCH_TCAM_RULE_SIZE_ENT tcamRuleSizeFound; /* TCAM rule size Found */
    GT_U32      entryNumber = 0;/* Rule's index in TCAM    */
    GT_U32      dummy;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(maskArr);
    CPSS_NULL_PTR_CHECK_MAC(patternArr);
    CPSS_NULL_PTR_CHECK_MAC(actionArr);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_UNIT_MAC(devNum,portGroupsBmp,PRV_CPSS_DXCH_UNIT_TCAM_E);
    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        && (tcamIndex > 1))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,"PCL tcamIndex out of range.");
    }

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
        devNum, portGroupsBmp, portGroupId);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PCL_CONVERT_RULE_SIZE_TO_TCAM_RULE_SIZE_VAL_MAC(
            tcamRuleSize, ruleSize);

        rc = cpssDxChTcamPortGroupRuleValidStatusGet(
            devNum, portGroupsBmp, ruleIndex, &valid, &tcamRuleSizeFound);
        if (rc != GT_OK)
        {
            return rc;
        }
        if ((tcamRuleSize != tcamRuleSizeFound) && (valid != GT_FALSE))
        {
            /* source rule is valid, but has another size */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        PRV_CPSS_DXCH_PCL_GET_RULE_SIZE_VALUE_MAC(ruleSize, ruleSizeVal);
        PRV_CPSS_DXCH_PCL_RULE_SIZE_INDEX_CHECK_MAC(
            devNum, ruleSizeVal, ruleIndex);

        rc = prvCpssDxChPclTcamRuleStateGet(
            devNum, portGroupId, tcamIndex,
            ruleSizeVal, ruleIndex, &valid, &ruleSizeFound);
        if (rc != GT_OK)
        {
            return rc;
        }

        if ((ruleSizeVal != ruleSizeFound) && (valid != GT_FALSE))
        {
            /* source rule is valid, but has another size */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }

    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* convert rule global index to TCAM entry number */
        rc = prvCpssDxChTcamRuleIndexToEntryNumber(devNum,ruleIndex,&entryNumber,&dummy);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* read action */
        rc = prvCpssDxChPortGroupReadTableEntry(devNum,
                                                portGroupId,
                                                CPSS_DXCH_SIP5_TABLE_TCAM_PCL_TTI_ACTION_E,
                                                (entryNumber/2),
                                                actionArr);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* read rule from the TCAM */
        rc = cpssDxChTcamPortGroupRuleRead(devNum,portGroupsBmp,ruleIndex,&valid,&tcamRuleSize,patternArr,maskArr);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        rc = prvCpssDxChPclTcamActionGet(
            devNum, portGroupId, tcamIndex,
            ruleSizeVal, ruleIndex, actionArr);
        if (rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssDxChPclTcamRuleDataGet(
            devNum, portGroupId, tcamIndex,
            ruleSizeVal, ruleIndex, maskArr, patternArr);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupRuleGet function
* @endinternal
*
* @brief   The function gets the Policy Rule Mask, Pattern and Action in Hw format
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
*                                      3. see general note about portGroupsBmp in TCAM APIs for Falcon
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of the Rule.
* @param[in] ruleIndex                - index of the rule in the TCAM.
*
* @param[out] maskArr[]                - rule mask          - 21  words.
* @param[out] patternArr[]             - rule pattern       - 21  words.
* @param[out] actionArr[]              - Policy rule action - 4 words.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - null pointer
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclPortGroupRuleGet
(
    IN  GT_U8                  devNum,
    IN  GT_PORT_GROUPS_BMP     portGroupsBmp,
    IN  GT_U32                 tcamIndex,
    IN  CPSS_PCL_RULE_SIZE_ENT ruleSize,
    IN  GT_U32                 ruleIndex,
    OUT GT_U32                 maskArr[], /*maxArraySize=21*/
    OUT GT_U32                 patternArr[], /*maxArraySize=21*/
    OUT GT_U32                 actionArr[] /*maxArraySize=8*/
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupRuleGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC(
        (funcId, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, maskArr, patternArr, actionArr));

    rc = internal_cpssDxChPclPortGroupRuleGet(
        devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, maskArr, patternArr, actionArr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC(
        (funcId, rc, devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex, maskArr, patternArr, actionArr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclMapLookupsToTcamIndexesSet function
* @endinternal
*
* @brief   Maps 4 PCL lookups each to one of TCAM units of the device.
*
* @note   APPLICABLE DEVICES:      AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                         - device number
* @param[in] pclLookupsTcamIndexesPtr       - (pointer to)TCAM indexes mapped to PCL lookups.
*
* @retval GT_OK                             - on success
* @retval GT_BAD_PARAM                      - on wrong parameter value
* @retval GT_BAD_PTR                        - on NULL pointer parameter
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclMapLookupsToTcamIndexesSet
(
    IN   GT_U8                                  devNum,
    IN   CPSS_DXCH_PCL_LOOKUP_TCAM_INDEXES_STC  *pclLookupsTcamIndexesPtr
)
{
    GT_STATUS  rc;            /* return code                 */
    GT_U32     data;          /* register data               */
    GT_U32     regAddr;       /* register address            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E |
        CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    CPSS_NULL_PTR_CHECK_MAC(pclLookupsTcamIndexesPtr);

    if (PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_FALSE)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }
    if (pclLookupsTcamIndexesPtr->ipcl0TcamIndex > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    if (pclLookupsTcamIndexesPtr->ipcl1TcamIndex > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    if (pclLookupsTcamIndexesPtr->ipcl2TcamIndex > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    if (pclLookupsTcamIndexesPtr->epclTcamIndex > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    data = (GT_U32)
        (pclLookupsTcamIndexesPtr->ipcl0TcamIndex
        | (pclLookupsTcamIndexesPtr->ipcl1TcamIndex << 1)
        | (pclLookupsTcamIndexesPtr->ipcl2TcamIndex << 2)
        | (pclLookupsTcamIndexesPtr->epclTcamIndex << 3));

    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl24;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 10, 4, data);

    return rc;
}


/**
* @internal cpssDxChPclMapLookupsToTcamIndexesSet function
* @endinternal
*
* @brief   Maps 4 PCL lookups each to one of TCAM units of the device.
*
* @note   APPLICABLE DEVICES:      AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                         - device number
* @param[in] pclLookupsTcamIndexesPtr       - (pointer to)TCAM indexes mapped to PCL lookups.
*
* @retval GT_OK                             - on success
* @retval GT_OUT_OF_RANGE                   - on out of range value for mask
* @retval GT_BAD_PARAM                      - on wrong parameter value
* @retval GT_BAD_PTR                        - on NULL pointer parameter
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
GT_STATUS cpssDxChPclMapLookupsToTcamIndexesSet
(
    IN   GT_U8                                  devNum,
    IN   CPSS_DXCH_PCL_LOOKUP_TCAM_INDEXES_STC  *pclLookupsTcamIndexesPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclMapLookupsToTcamIndexesSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, pclLookupsTcamIndexesPtr));

    rc = internal_cpssDxChPclMapLookupsToTcamIndexesSet(
        devNum, pclLookupsTcamIndexesPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, pclLookupsTcamIndexesPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclMapLookupsToTcamIndexesGet function
* @endinternal
*
* @brief   Gets map of 4 PCL lookups each to one of TCAM units of the device.
*
* @note   APPLICABLE DEVICES:      AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in]  devNum                        - device number
* @param[out] pclLookupsTcamIndexesPtr      - (pointer to)TCAM indexes mapped to PCL lookups.
*
* @retval GT_OK                             - on success
* @retval GT_BAD_PARAM                      - on wrong parameter value
* @retval GT_BAD_PTR                        - on NULL pointer parameter
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclMapLookupsToTcamIndexesGet
(
    IN   GT_U8           devNum,
    OUT  CPSS_DXCH_PCL_LOOKUP_TCAM_INDEXES_STC  *pclLookupsTcamIndexesPtr
)
{
    GT_STATUS  rc;            /* return code                 */
    GT_U32     data;          /* register data               */
    GT_U32     regAddr;       /* register address            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E |
        CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);
    CPSS_NULL_PTR_CHECK_MAC(pclLookupsTcamIndexesPtr);
    if (PRV_CPSS_DEV_DFX_SERVER_SUPPORTED_MAC(devNum) == GT_FALSE)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_CPSS_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsDeviceSpecificRegs.deviceCtrl24;
    rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(devNum, regAddr, 10, 4, &data);
    if (rc != GT_OK)
    {
        return rc;
    }
    pclLookupsTcamIndexesPtr->ipcl0TcamIndex =  data & 1;
    pclLookupsTcamIndexesPtr->ipcl1TcamIndex = (data >> 1) & 1;
    pclLookupsTcamIndexesPtr->ipcl2TcamIndex = (data >> 2) & 1;
    pclLookupsTcamIndexesPtr->epclTcamIndex  = (data >> 3) & 1;

    return GT_OK;
}

/**
* @internal cpssDxChPclMapLookupsToTcamIndexesGet function
* @endinternal
*
* @brief   Gets map of 4 PCL lookups each to one of TCAM units of the device.
*
* @note   APPLICABLE DEVICES:      AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in]  devNum                        - device number
* @param[out] pclLookupsTcamIndexesPtr      - (pointer to)TCAM indexes mapped to PCL lookups.
*
* @retval GT_OK                             - on success
* @retval GT_BAD_PARAM                      - on wrong parameter value
* @retval GT_BAD_PTR                        - on NULL pointer parameter
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
GT_STATUS cpssDxChPclMapLookupsToTcamIndexesGet
(
    IN   GT_U8           devNum,
    OUT  CPSS_DXCH_PCL_LOOKUP_TCAM_INDEXES_STC  *pclLookupsTcamIndexesPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclMapLookupsToTcamIndexesGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, pclLookupsTcamIndexesPtr));

    rc = internal_cpssDxChPclMapLookupsToTcamIndexesGet(
        devNum, pclLookupsTcamIndexesPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, pclLookupsTcamIndexesPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupCfgTblSet function
* @endinternal
*
* @brief   PCL Configuration table entry's lookup configuration for interface.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] interfaceInfoPtr         - interface data: port, VLAN, or index for setting a
*                                      specific PCL Configuration Table entry
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      For Ingress PCL: lookup0 or lookup1
*                                      For Egress PCL ignored
* @param[in] lookupCfgPtr             - lookup configuration
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note For Bobcat2, Caelum, Bobcat3; Aldrin2, Aldrin, AC3X that use INDEX interface type
*       to configure entry for ePort, index = ePort
*
*/
static GT_STATUS internal_cpssDxChPclPortGroupCfgTblSet
(
    IN GT_U8                           devNum,
    IN GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN CPSS_INTERFACE_INFO_STC         *interfaceInfoPtr,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
{
    PRV_CPSS_DXCH_PCL_LOOKUP_CFG_HW_STC    lookupHwCfg;
    GT_STATUS res;           /* return code                                       */
    GT_U32    entryIndex;    /* pcl configuration table entry Index               */
    GT_U32    hwValue;       /* pcl configuration table HW value                  */
    GT_U32    portGroupId;        /*the port group Id - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    CPSS_NULL_PTR_CHECK_MAC(interfaceInfoPtr);
    CPSS_NULL_PTR_CHECK_MAC(lookupCfgPtr);
    PRV_CPSS_DXCH_PCL_LOOKUP_NUM_CHECK_MAC(lookupNum);

    res = prvCpssDxChPclCfgTblEntryIndexGet(
        devNum, interfaceInfoPtr, direction, &entryIndex , &portGroupId);
    if (res != GT_OK)
    {
        return res;
    }

    if (portGroupId != CPSS_PORT_GROUP_UNAWARE_MODE_CNS)
    {
        if ((portGroupsBmp  != CPSS_PORT_GROUP_UNAWARE_MODE_CNS)
            && (portGroupsBmp != (GT_U32)(1 << portGroupId)))
        {
            /* valid only "All port groups" or the correct port group */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        /* update bitmap to correct port group */
        portGroupsBmp = (1 << portGroupId);
    }

    /* common for all cases */
    cpssOsMemSet(&lookupHwCfg, 0, sizeof(lookupHwCfg));
    lookupHwCfg.enableLookup = (GT_U8)BOOL2BIT_MAC(lookupCfgPtr->enableLookup);
    lookupHwCfg.pclId        = lookupCfgPtr->pclId;

    if (PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum))
    {
        /* xCat2, Lion2 and above - 3 configuration tables */
        lookupHwCfg.dualLookup   = 0;
        lookupHwCfg.pclIdL01     = 0;
    }
    else
    {
        /* xCat3 */
        lookupHwCfg.dualLookup   =
            (GT_U8)BOOL2BIT_MAC(lookupCfgPtr->dualLookup);
        lookupHwCfg.pclIdL01     = lookupCfgPtr->pclIdL01;
    }

    /* non IP key style */
    res = prvCpssDxChPclKeyTypeSwToHw(
        devNum, direction, PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_NOT_IP_CNS,
        lookupCfgPtr->groupKeyTypes.nonIpKey,
        &hwValue);
    if (res != GT_OK)
    {
        return res;
    }
    lookupHwCfg.nonIpKeyType = (GT_U8)hwValue;

    /* IPv4 key style */
    res = prvCpssDxChPclKeyTypeSwToHw(
        devNum, direction, PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV4_CNS,
        lookupCfgPtr->groupKeyTypes.ipv4Key,
        &hwValue);
    if (res != GT_OK)
    {
        return res;
    }
    lookupHwCfg.ipv4KeyType = (GT_U8)hwValue;

    /* IPv6 key style */
    res = prvCpssDxChPclKeyTypeSwToHw(
        devNum, direction, PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV6_CNS,
        lookupCfgPtr->groupKeyTypes.ipv6Key,
        &hwValue);
    if (res != GT_OK)
    {
        return res;
    }
    lookupHwCfg.ipv6KeyType = (GT_U8)hwValue;

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        lookupHwCfg.udbKeyBitmapEnable = BOOL2BIT_MAC(lookupCfgPtr->udbKeyBitmapEnable);

        if(PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_BOBCAT3_RM_TCAM_SEGMENT_MODE_OBSOLETE_WA_E))
        {
            /* ignore lookupCfgPtr->tcamSegmentMode value from the caller */
            lookupHwCfg.tcamSegmentMode = 4;
        }
        else
        {
            switch (lookupCfgPtr->tcamSegmentMode)
            {
                case CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_1_TCAM_E:
                    lookupHwCfg.tcamSegmentMode = 0;
                    break;
                case CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_2_AND_2_E:
                    lookupHwCfg.tcamSegmentMode = 1;
                    break;
                case CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_1_AND_3_E:
                    lookupHwCfg.tcamSegmentMode = 2;
                    break;
                case CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_3_AND_1_E:
                    lookupHwCfg.tcamSegmentMode = 3;
                    break;
                case CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_4_TCAMS_E:
                    lookupHwCfg.tcamSegmentMode = 4;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }
    }
    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        GT_U32 maxValue;
        if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
        {
            maxValue = 15;
        }
        else
        {
            maxValue = 7;
        }
        if(lookupCfgPtr->exactMatchLookupSubProfileId > maxValue)
        {
           CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "exactMatchLookupSubProfileId[%d] > max[%d]",
               lookupCfgPtr->exactMatchLookupSubProfileId , maxValue);
        }
        lookupHwCfg.exactMatchLookupSubProfileId = lookupCfgPtr->exactMatchLookupSubProfileId;
    }
    if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        lookupHwCfg.pclId          = lookupCfgPtr->pclId & 0x3FF;
        lookupHwCfg.pclIdExtension = lookupCfgPtr->pclId >> PRV_CPSS_DXCH_PCL_ID_LENGTH_CNS;
    }
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        res = prvCpssDxChPclCfgTblHwWrite(
            devNum, portGroupId , direction, entryIndex,
            lookupNum, 0 /*subLookupNum*/, &lookupHwCfg);
        if (res != GT_OK)
        {
            return res;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    if ((0 == PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum))
        || (direction != CPSS_PCL_DIRECTION_INGRESS_E)
        || (lookupNum != CPSS_PCL_LOOKUP_0_E))
    {
        /* only one configuration table needed update */
        return GT_OK;
    }

    /* xCat2 ingress lookup01 table update              */
    /* Ingress PCL CPSS_PCL_LOOKUP_0_E - configure      */
    /* lookup_0_1 with the same key types as lookup_0_0 */
    lookupHwCfg.enableLookup = (GT_U8)BOOL2BIT_MAC(lookupCfgPtr->dualLookup);
    lookupHwCfg.pclId        = lookupCfgPtr->pclIdL01;
    /* key types alredy converted for lookup_0_0 */
    /* lookupHwCfg.nonIpKeyType;                 */
    /* lookupHwCfg.ipv4KeyType;                  */
    /* lookupHwCfg.ipv6KeyType;                  */

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        res = prvCpssDxChPclCfgTblHwWrite(
            devNum, portGroupId , direction, entryIndex,
            lookupNum, 1 /*subLookupNum*/, &lookupHwCfg);
        if (res != GT_OK)
        {
            return res;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupCfgTblSet function
* @endinternal
*
* @brief   PCL Configuration table entry's lookup configuration for interface.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] interfaceInfoPtr         - interface data: port, VLAN, or index for setting a
*                                      specific PCL Configuration Table entry
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      For Ingress PCL: lookup0 or lookup1
*                                      For Egress PCL ignored
* @param[in] lookupCfgPtr             - lookup configuration
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_BAD_PTR               - null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note For Bobcat2, Caelum, Bobcat3; Aldrin2, Aldrin, AC3X that use INDEX interface type
*       to configure entry for ePort, index = ePort
*
*/
GT_STATUS cpssDxChPclPortGroupCfgTblSet
(
    IN GT_U8                           devNum,
    IN GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN CPSS_INTERFACE_INFO_STC         *interfaceInfoPtr,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupCfgTblSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr));

    rc = internal_cpssDxChPclPortGroupCfgTblSet(devNum, portGroupsBmp, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupCfgTblGet function
* @endinternal
*
* @brief   PCL Configuration table entry's lookup configuration for interface.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] interfaceInfoPtr         - interface data: port, VLAN, or index for getting a
*                                      specific PCL Configuration Table entry
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      For Ingress PCL: lookup0 or lookup1
*                                      For Egress PCL ignored
*
* @param[out] lookupCfgPtr             - (pointer to) lookup configuration
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_BAD_PTR               - null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note For Bobcat2, Caelum, Bobcat3; Aldrin2, Aldrin, AC3X that use INDEX interface type
*       to configure entry for ePort, index = ePort
*
*/
static GT_STATUS internal_cpssDxChPclPortGroupCfgTblGet
(
    IN  GT_U8                           devNum,
    IN  GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN  CPSS_INTERFACE_INFO_STC        *interfaceInfoPtr,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    OUT CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
{
    PRV_CPSS_DXCH_PCL_LOOKUP_CFG_HW_STC    lookupHwCfg;
    GT_STATUS res;           /* return code                            */
    GT_U32    entryIndex;    /* index of PCL configuration table entry */
    GT_U32  portGroupId;     /* the port group Id                      */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    CPSS_NULL_PTR_CHECK_MAC(interfaceInfoPtr);
    CPSS_NULL_PTR_CHECK_MAC(lookupCfgPtr);
    PRV_CPSS_DXCH_PCL_LOOKUP_NUM_CHECK_MAC(lookupNum);

    /* clear output data */
    cpssOsMemSet(lookupCfgPtr, 0, sizeof(CPSS_DXCH_PCL_LOOKUP_CFG_STC));

    res = prvCpssDxChPclCfgTblEntryIndexGet(
        devNum, interfaceInfoPtr, direction, &entryIndex , &portGroupId);
    if (res != GT_OK)
    {
        return res;
    }

    if (portGroupId != CPSS_PORT_GROUP_UNAWARE_MODE_CNS)
    {
        if ((portGroupsBmp  != CPSS_PORT_GROUP_UNAWARE_MODE_CNS)
            && (portGroupsBmp != (GT_U32)(1 << portGroupId)))
        {
            /* valid only "All port groups" or the correct port group */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        /* update bitmap to correct port group */
        portGroupsBmp = (1 << portGroupId);
    }
    else
    {
        PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
            devNum, portGroupsBmp, portGroupId);
    }

    res = prvCpssDxChPclCfgTblHwRead(
        devNum, portGroupId , direction, entryIndex,
        lookupNum, 0 /*subLookupNum*/, &lookupHwCfg);
    if (res != GT_OK)
    {
        return res;
    }

    /* common for all devices */
    cpssOsMemSet(lookupCfgPtr, 0, sizeof(CPSS_DXCH_PCL_LOOKUP_CFG_STC));
    lookupCfgPtr->enableLookup        = BIT2BOOL_MAC(lookupHwCfg.enableLookup);
    lookupCfgPtr->pclId               = lookupHwCfg.pclId;
    lookupCfgPtr->dualLookup          = BIT2BOOL_MAC(lookupHwCfg.dualLookup);
    lookupCfgPtr->pclIdL01            = lookupHwCfg.pclIdL01;

    /* non IP key style */
    res = prvCpssDxChPclKeyTypeHwToSw(
        devNum, direction, PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_NOT_IP_CNS,
        lookupHwCfg.nonIpKeyType,
        &lookupCfgPtr->groupKeyTypes.nonIpKey);
    if (res != GT_OK)
    {
        return res;
    }

    /* IPv4 key style */
    res = prvCpssDxChPclKeyTypeHwToSw(
        devNum, direction, PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV4_CNS,
        lookupHwCfg.ipv4KeyType,
        &lookupCfgPtr->groupKeyTypes.ipv4Key);
    if (res != GT_OK)
    {
        return res;
    }

    /* IPv6 key style */
    res = prvCpssDxChPclKeyTypeHwToSw(
        devNum, direction, PRV_CPSS_DXCH_PCL_CFG_PKT_TYPE_IPV6_CNS,
        lookupHwCfg.ipv6KeyType,
        &lookupCfgPtr->groupKeyTypes.ipv6Key);
    if (res != GT_OK)
    {
        return res;
    }

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        lookupCfgPtr->udbKeyBitmapEnable = BIT2BOOL_MAC(lookupHwCfg.udbKeyBitmapEnable);

        switch (lookupHwCfg.tcamSegmentMode)
        {
            case 0:
                lookupCfgPtr->tcamSegmentMode = CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_1_TCAM_E;
                break;
            case 1:
                lookupCfgPtr->tcamSegmentMode = CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_2_AND_2_E;
                break;
            case 2:
                lookupCfgPtr->tcamSegmentMode = CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_1_AND_3_E;
                break;
            case 3:
                lookupCfgPtr->tcamSegmentMode = CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_3_AND_1_E;
                break;
            case 4:
                lookupCfgPtr->tcamSegmentMode = CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_4_TCAMS_E;
                break;
            default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }
    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        lookupCfgPtr->exactMatchLookupSubProfileId = lookupHwCfg.exactMatchLookupSubProfileId;
    }

    if ((0 == PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum))
        || (direction != CPSS_PCL_DIRECTION_INGRESS_E)
        || (lookupNum != CPSS_PCL_LOOKUP_0_E))
    {
        /* only one configuration table needed retrieve */
        return GT_OK;
    }

    /* xCat2 ingress lookup01 table read                       */
    /* Ingress PCL CPSS_PCL_LOOKUP_0_E - means both sublookups */

    res = prvCpssDxChPclCfgTblHwRead(
        devNum, portGroupId , direction, entryIndex,
        lookupNum, 1 /*subLookupNum*/, &lookupHwCfg);
    if (res != GT_OK)
    {
        return res;
    }

    /* lookup_0_1 related data                    */
    /* lookup_0_1 key types assumed as lookup_0_0 */
    lookupCfgPtr->dualLookup = BIT2BOOL_MAC(lookupHwCfg.enableLookup);
    lookupCfgPtr->pclIdL01   = lookupHwCfg.pclId;

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupCfgTblGet function
* @endinternal
*
* @brief   PCL Configuration table entry's lookup configuration for interface.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] interfaceInfoPtr         - interface data: port, VLAN, or index for getting a
*                                      specific PCL Configuration Table entry
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress
* @param[in] lookupNum                - Lookup number:
*                                      For Ingress PCL: lookup0 or lookup1
*                                      For Egress PCL ignored
*
* @param[out] lookupCfgPtr             - (pointer to) lookup configuration
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_BAD_PTR               - null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note For Bobcat2, Caelum, Bobcat3; Aldrin2, Aldrin, AC3X that use INDEX interface type
*       to configure entry for ePort, index = ePort
*
*/
GT_STATUS cpssDxChPclPortGroupCfgTblGet
(
    IN  GT_U8                           devNum,
    IN  GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN  CPSS_INTERFACE_INFO_STC        *interfaceInfoPtr,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    OUT CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupCfgTblGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr));

    rc = internal_cpssDxChPclPortGroupCfgTblGet(devNum, portGroupsBmp, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, interfaceInfoPtr, direction, lookupNum, lookupCfgPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupCfgTblEntryGet function
* @endinternal
*
* @brief   Gets the PCL configuration table entry in Hw format.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] direction                - Ingress Policy or Egress Policy
*                                      (CPSS_PCL_DIRECTION_ENT member),
* @param[in] lookupNum                - Lookup number: lookup0 or lookup1
*                                      xCat3 and above supports the parameter
*                                      xCat3 and above devices has separate HW entries
*                                      for both ingress lookups.
*                                      Only lookup 0 is supported for egress.
* @param[in] entryIndex               - PCL configuration table entry Index
*
* @param[out] pclCfgTblEntryPtr        - pcl Cfg Tbl Entry
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_BAD_STATE             - in case of already bound pclHwId with same
*                                       combination of slot/direction
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note DxCh devices support ingress direction only
*
*/
static GT_STATUS internal_cpssDxChPclPortGroupCfgTblEntryGet
(
    IN  GT_U8                           devNum,
    IN  GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN  GT_U32                          entryIndex,
    OUT GT_U32                          *pclCfgTblEntryPtr
)
{
    GT_STATUS rc;              /* return code                              */
    GT_U32    portGroupId;     /* the port group Id                        */
    CPSS_DXCH_TABLE_ENT tableId; /* id of ingress of egress Policy Cfg */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(pclCfgTblEntryPtr);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
        devNum, portGroupsBmp, portGroupId);

    if ((PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum))
        && (direction == CPSS_PCL_DIRECTION_INGRESS_E)
        && (lookupNum == CPSS_PCL_LOOKUP_0_E))
    {
        /* xCat2 read entries from both lookup0 and lookup01 tables */

        /* lookup0 */
        tableId = CPSS_DXCH_TABLE_PCL_CONFIG_E;
        rc = prvCpssDxChPortGroupReadTableEntry(
            devNum, portGroupId, tableId, entryIndex, pclCfgTblEntryPtr);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* lookup01 - next two words */
        tableId = CPSS_DXCH_XCAT2_TABLE_INGRESS_PCL_LOOKUP01_CONFIG_E;
        rc = prvCpssDxChPortGroupReadTableEntry(
            devNum, portGroupId, tableId, entryIndex, &(pclCfgTblEntryPtr[2]));

        return rc;
    }

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            if (PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum))
            {
                /* xCat2 and above */
                switch (lookupNum)
                {
                    /* case CPSS_PCL_LOOKUP_0_E treated above */
                    case CPSS_PCL_LOOKUP_0_0_E:
                        tableId = CPSS_DXCH_TABLE_PCL_CONFIG_E;
                        break;
                    case CPSS_PCL_LOOKUP_0_1_E:
                        tableId =
                            CPSS_DXCH_XCAT2_TABLE_INGRESS_PCL_LOOKUP01_CONFIG_E;
                        break;
                    case CPSS_PCL_LOOKUP_1_E:
                        if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        tableId =
                            CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_LOOKUP1_CONFIG_E;
                        break;
                    default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                /* xCat3 and above */
                switch (lookupNum)
                {
                    case CPSS_PCL_LOOKUP_0_E:
                        tableId = CPSS_DXCH_TABLE_PCL_CONFIG_E;
                        break;
                    case CPSS_PCL_LOOKUP_1_E:
                        tableId =
                            CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_LOOKUP1_CONFIG_E;
                        break;
                    default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
            }
            break;
        case CPSS_PCL_DIRECTION_EGRESS_E:
            if (lookupNum != CPSS_PCL_LOOKUP_0_E)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            tableId = CPSS_DXCH2_TABLE_EGRESS_PCL_CONFIG_E;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return prvCpssDxChPortGroupReadTableEntry(
        devNum, portGroupId, tableId, entryIndex, pclCfgTblEntryPtr);
}

/**
* @internal cpssDxChPclPortGroupCfgTblEntryGet function
* @endinternal
*
* @brief   Gets the PCL configuration table entry in Hw format.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] direction                - Ingress Policy or Egress Policy
*                                      (CPSS_PCL_DIRECTION_ENT member),
* @param[in] lookupNum                - Lookup number: lookup0 or lookup1
*                                      xCat3 and above supports the parameter
*                                      xCat3 and above devices has separate HW entries
*                                      for both ingress lookups.
*                                      Only lookup 0 is supported for egress.
* @param[in] entryIndex               - PCL configuration table entry Index
*
* @param[out] pclCfgTblEntryPtr        - pcl Cfg Tbl Entry
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_BAD_STATE             - in case of already bound pclHwId with same
*                                       combination of slot/direction
* @retval GT_TIMEOUT               - after max number of retries checking if PP ready
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note DxCh devices support ingress direction only
*
*/
GT_STATUS cpssDxChPclPortGroupCfgTblEntryGet
(
    IN  GT_U8                           devNum,
    IN  GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN  GT_U32                          entryIndex,
    OUT GT_U32                          *pclCfgTblEntryPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupCfgTblEntryGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, direction, lookupNum, entryIndex, pclCfgTblEntryPtr));

    rc = internal_cpssDxChPclPortGroupCfgTblEntryGet(devNum, portGroupsBmp, direction, lookupNum, entryIndex, pclCfgTblEntryPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, direction, lookupNum, entryIndex, pclCfgTblEntryPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupTcpUdpPortComparatorSet function
* @endinternal
*
* @brief   Configure TCP or UDP Port Comparator entry
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
* @param[in] value                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] l4Protocol               - protocol, TCP or UDP
* @param[in] entryIndex               - entry index
*                                       (APPLICABLE RANGES: xCat3, AC5, Lion2, Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman 0..7;
*                                                           AC5P 0..63)
* @param[in] l4PortType               - TCP/UDP port type, source or destination port
* @param[in] compareOperator          - compare operator FALSE, LTE, GTE, NEQ
* @param[in] value                    - 16 bit  to compare with
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS internal_cpssDxChPclPortGroupTcpUdpPortComparatorSet
(
    IN GT_U8                             devNum,
    IN GT_PORT_GROUPS_BMP                portGroupsBmp,
    IN CPSS_PCL_DIRECTION_ENT            direction,
    IN CPSS_L4_PROTOCOL_ENT              l4Protocol,
    IN GT_U8                             entryIndex,
    IN CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortType,
    IN CPSS_COMPARE_OPERATOR_ENT         compareOperator,
    IN GT_U16                            value
)
{
    GT_STATUS rc;            /* return code                         */
    GT_U32    regAddr;       /* register address                    */
    GT_U32    directonNum;   /* direction => 0 or 1                 */
    GT_U32    protocolNum ;  /* protocol => 0 or 1                  */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    portGroupId;   /* the port group Id                   */
    GT_U32    maxValidEntryIndex=0;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        maxValidEntryIndex = 63;
    }
    else
    {
        maxValidEntryIndex = 7;
    }
    if (entryIndex > maxValidEntryIndex)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "entrIndex invalid - out of range \n");
    }

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E: directonNum = 0; break;
        case CPSS_PCL_DIRECTION_EGRESS_E:  directonNum = 1; break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch (l4Protocol)
    {
        case CPSS_L4_PROTOCOL_TCP_E: protocolNum = 0; break;
        case CPSS_L4_PROTOCOL_UDP_E: protocolNum = 1; break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch ((directonNum << 1) | protocolNum)
    {
        case 0: /* ingress TCP */
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
            {
                regAddr =
                    PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).userDefinedBytes.IPCLTCPPortRangeComparatorConfig[entryIndex];
            }
            else
            {
                regAddr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    ipclTcpPortComparator0 + (entryIndex * 4);
            }
            break;
        case 1: /* ingress UDP */
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
            {
                regAddr =
                    PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).userDefinedBytes.IPCLUDPPortRangeComparatorConfig[entryIndex];
            }
            else
            {
                regAddr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    ipclUdpPortComparator0 + (entryIndex * 4);
            }
            break;
        case 2: /* egress TCP */
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
            {
                regAddr =
                    PRV_DXCH_REG1_UNIT_HA_MAC(devNum).egrTCPPortRangeComparatorConfig[entryIndex];
            }
            else
            {
                regAddr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclTcpPortComparator0 + (entryIndex * 4);
            }
            break;
        case 3: /* egress UDP */
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
            {
                regAddr =
                    PRV_DXCH_REG1_UNIT_HA_MAC(devNum).egrUDPPortRangeComparatorConfig[entryIndex];
            }
            else
            {
                regAddr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclUdpPortComparator0 + (entryIndex * 4);
            }
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    hwValue = (value & 0xFFFF);

    switch (l4PortType)
    {
        case CPSS_L4_PROTOCOL_PORT_SRC_E: /* bit18 aleady 0 */  break;
        case CPSS_L4_PROTOCOL_PORT_DST_E: hwValue |= (1 << 18); break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch (compareOperator)
    {
        case CPSS_COMPARE_OPERATOR_INVALID_E: /*bit16-17 aleady 0*/ break;
        case CPSS_COMPARE_OPERATOR_LTE:       hwValue |= (2 << 16); break;
        case CPSS_COMPARE_OPERATOR_GTE:       hwValue |= (1 << 16); break;
        case CPSS_COMPARE_OPERATOR_NEQ:       hwValue |= (3 << 16); break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        rc = prvCpssHwPpPortGroupSetRegField(
            devNum, portGroupId, regAddr, 0, 19, hwValue);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupTcpUdpPortComparatorSet function
* @endinternal
*
* @brief   Configure TCP or UDP Port Comparator entry
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
* @param[in] value                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] l4Protocol               - protocol, TCP or UDP
* @param[in] entryIndex               - entry index
*                                       (APPLICABLE RANGES: xCat3, AC5, Lion2, Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman 0..7;
*                                                           AC5P 0..63)
* @param[in] l4PortType               - TCP/UDP port type, source or destination port
* @param[in] compareOperator          - compare operator FALSE, LTE, GTE, NEQ
* @param[in] value                    - 16 bit  to compare with
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
*/
GT_STATUS cpssDxChPclPortGroupTcpUdpPortComparatorSet
(
    IN GT_U8                             devNum,
    IN GT_PORT_GROUPS_BMP                portGroupsBmp,
    IN CPSS_PCL_DIRECTION_ENT            direction,
    IN CPSS_L4_PROTOCOL_ENT              l4Protocol,
    IN GT_U8                             entryIndex,
    IN CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortType,
    IN CPSS_COMPARE_OPERATOR_ENT         compareOperator,
    IN GT_U16                            value
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupTcpUdpPortComparatorSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, direction, l4Protocol, entryIndex, l4PortType, compareOperator, value));

    rc = internal_cpssDxChPclPortGroupTcpUdpPortComparatorSet(devNum, portGroupsBmp, direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, direction, l4Protocol, entryIndex, l4PortType, compareOperator, value));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupTcpUdpPortComparatorGet function
* @endinternal
*
* @brief   Get TCP or UDP Port Comparator entry
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] l4Protocol               - protocol, TCP or UDP
* @param[in] entryIndex               - entry index
*                                       (APPLICABLE RANGES: xCat3, AC5, Lion2, Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman 0..7;
*                                                           AC5P 0..63)
*
* @param[out] l4PortTypePtr            - TCP/UDP port type, source or destination port
* @param[out] compareOperatorPtr       - compare operator FALSE, LTE, GTE, NEQ
* @param[out] valuePtr                 - 16 bit value to compare with
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on NULL pointer
*/
static GT_STATUS internal_cpssDxChPclPortGroupTcpUdpPortComparatorGet
(
    IN  GT_U8                             devNum,
    IN  GT_PORT_GROUPS_BMP                portGroupsBmp,
    IN  CPSS_PCL_DIRECTION_ENT            direction,
    IN  CPSS_L4_PROTOCOL_ENT              l4Protocol,
    IN  GT_U8                             entryIndex,
    OUT CPSS_L4_PROTOCOL_PORT_TYPE_ENT    *l4PortTypePtr,
    OUT CPSS_COMPARE_OPERATOR_ENT         *compareOperatorPtr,
    OUT GT_U16                            *valuePtr
)
{
    GT_STATUS rc;            /* return code                         */
    GT_U32    regAddr;       /* register address                    */
    GT_U32    directonNum;   /* direction => 0 or 1                 */
    GT_U32    protocolNum ;  /* protocol => 0 or 1                  */
    GT_U32    hwValue;       /* HW Value                            */
    GT_U32    value;         /* tmp value                           */
    GT_U32    portGroupId;   /* the port group Id                   */
    GT_U32    maxValidEntryIndex=0;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    CPSS_NULL_PTR_CHECK_MAC(l4PortTypePtr);
    CPSS_NULL_PTR_CHECK_MAC(compareOperatorPtr);
    CPSS_NULL_PTR_CHECK_MAC(valuePtr);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
        devNum, portGroupsBmp, portGroupId);

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        maxValidEntryIndex = 63;
    }
    else
    {
        maxValidEntryIndex = 7;
    }

    if (entryIndex > maxValidEntryIndex)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E: directonNum = 0; break;
        case CPSS_PCL_DIRECTION_EGRESS_E:  directonNum = 1; break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch (l4Protocol)
    {
        case CPSS_L4_PROTOCOL_TCP_E: protocolNum = 0; break;
        case CPSS_L4_PROTOCOL_UDP_E: protocolNum = 1; break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch ((directonNum << 1) | protocolNum)
    {
        case 0: /* ingress TCP */
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
            {
                regAddr =
                    PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).userDefinedBytes.IPCLTCPPortRangeComparatorConfig[entryIndex];
            }
            else
            {
                regAddr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    ipclTcpPortComparator0 + (entryIndex * 4);
            }
            break;
        case 1: /* ingress UDP */
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
            {
                regAddr =
                    PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).userDefinedBytes.IPCLUDPPortRangeComparatorConfig[entryIndex];
            }
            else
            {
                regAddr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    ipclUdpPortComparator0 + (entryIndex * 4);
            }
            break;
        case 2: /* egress TCP */
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
            {
                regAddr =
                    PRV_DXCH_REG1_UNIT_HA_MAC(devNum).egrTCPPortRangeComparatorConfig[entryIndex];
            }
            else
            {
                regAddr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclTcpPortComparator0 + (entryIndex * 4);
            }
            break;
        case 3: /* egress UDP */
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
            {
                regAddr =
                    PRV_DXCH_REG1_UNIT_HA_MAC(devNum).egrUDPPortRangeComparatorConfig[entryIndex];
            }
            else
            {
                regAddr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.
                    epclUdpPortComparator0 + (entryIndex * 4);
            }
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpPortGroupGetRegField(
        devNum, portGroupId, regAddr, 0, 19, &hwValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    *valuePtr = (GT_U16)(hwValue & 0xFFFF);

    /* get value from hwValue */
    value = (hwValue >> 18) & 0x1;

    *l4PortTypePtr = (0 == value) ? CPSS_L4_PROTOCOL_PORT_SRC_E :
                                    CPSS_L4_PROTOCOL_PORT_DST_E;

    /* get compareOperator from hwValue */
    value = (hwValue >> 16) & 0x3;

    switch (value)
    {
        case 0:
          *compareOperatorPtr = CPSS_COMPARE_OPERATOR_INVALID_E;
          break;
        case 2:
          *compareOperatorPtr = CPSS_COMPARE_OPERATOR_LTE;
          break;
        case 1:
          *compareOperatorPtr = CPSS_COMPARE_OPERATOR_GTE;
          break;
        case 3:
          *compareOperatorPtr = CPSS_COMPARE_OPERATOR_NEQ;
          break;
        default:
          CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupTcpUdpPortComparatorGet function
* @endinternal
*
* @brief   Get TCP or UDP Port Comparator entry
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] l4Protocol               - protocol, TCP or UDP
* @param[in] entryIndex               - entry index
*                                       (APPLICABLE RANGES: xCat3, AC5, Lion2, Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon, AC5P, AC5X, Harrier, Ironman 0..7;
*                                                           AC5P 0..63)
*
* @param[out] l4PortTypePtr            - TCP/UDP port type, source or destination port
* @param[out] compareOperatorPtr       - compare operator FALSE, LTE, GTE, NEQ
* @param[out] valuePtr                 - 16 bit value to compare with
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on NULL pointer
*/
GT_STATUS cpssDxChPclPortGroupTcpUdpPortComparatorGet
(
    IN  GT_U8                             devNum,
    IN  GT_PORT_GROUPS_BMP                portGroupsBmp,
    IN  CPSS_PCL_DIRECTION_ENT            direction,
    IN  CPSS_L4_PROTOCOL_ENT              l4Protocol,
    IN  GT_U8                             entryIndex,
    OUT CPSS_L4_PROTOCOL_PORT_TYPE_ENT    *l4PortTypePtr,
    OUT CPSS_COMPARE_OPERATOR_ENT         *compareOperatorPtr,
    OUT GT_U16                            *valuePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupTcpUdpPortComparatorGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, direction, l4Protocol, entryIndex, l4PortTypePtr, compareOperatorPtr, valuePtr));

    rc = internal_cpssDxChPclPortGroupTcpUdpPortComparatorGet(devNum, portGroupsBmp, direction, l4Protocol, entryIndex, l4PortTypePtr, compareOperatorPtr, valuePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, direction, l4Protocol, entryIndex, l4PortTypePtr, compareOperatorPtr, valuePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal sip5PclUdbOffsetTypeSw2Hw function
* @endinternal
*
* @brief   The function converts UDB OffsetType SW to HW.
*
* @note   APPLICABLE DEVICES:      Bobcat2, Caelum, Aldrin, AC3X, Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] swOffsetType             - packet Type
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
*/
static GT_STATUS sip5PclUdbOffsetTypeSw2Hw
(
    IN  CPSS_DXCH_PCL_OFFSET_TYPE_ENT        swOffsetType,
    OUT GT_U32                               *hwOffsetTypePtr
)
{
    if (swOffsetType >=
        (sizeof(sip5ConvertSwUdbAnchorToHwValueArr) / sizeof(sip5ConvertSwUdbAnchorToHwValueArr[0])))
    {
        /* check for access violation into the array of
            sip5ConvertSwUdbAnchorToHwValueArr[] */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    *hwOffsetTypePtr = (GT_U32)(sip5ConvertSwUdbAnchorToHwValueArr[swOffsetType]);

    if (*hwOffsetTypePtr == SIP5_HW_PCL_UDB_ANCHOR_NOT_SUPPORTED_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal sip5PclPortGroupUserDefinedByteSet function
* @endinternal
*
* @brief   The function configures the User Defined Byte (UDB).
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] packetType               - packet Type
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress.
* @param[in] udbIndex                 - index of User Defined Byte to configure.
*                                      See format of rules to known indexes of UDBs
* @param[in] offset                   - the type of offset (see CPSS_DXCH_PCL_OFFSET_TYPE_ENT)
* @param[in] offset                   - The  of the user-defined byte, in bytes,from the
*                                      place in the packet indicated by the offset type
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong parameter
* @retval GT_OUT_OF_RANGE          - parameter value more than HW bit field
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS sip5PclPortGroupUserDefinedByteSet
(
    IN GT_U8                                devNum,
    IN GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN CPSS_PCL_DIRECTION_ENT               direction,
    IN GT_U32                               udbIndex,
    IN CPSS_DXCH_PCL_OFFSET_TYPE_ENT        offsetType,
    IN GT_U8                                offset
)
{
    GT_STATUS rc;              /* return code              */
    GT_U32    regValue;        /* register  value*/
    GT_U32    hwAnchor;        /* HW offset Type           */
    GT_U32    startBit;        /* start Bit                */
    GT_U32    udbEntryIndex;   /* XCat HW UDB entry index  */
    GT_U32    portGroupId;     /*the port group Id         */
    GT_U32    numBitsInfo;/* number of bits of info per UDB*/
    CPSS_DXCH_TABLE_ENT tableType;
    const UDB_RANGE_PER_ANCHORS_STC *udbRangePerAnchorPtr;

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        if (direction == CPSS_PCL_DIRECTION_INGRESS_E)
        {
            udbRangePerAnchorPtr = sip6_10_ipcl_UdbRangePerAnchorArr;
        }
        else
        {
            udbRangePerAnchorPtr = sip6_10_epcl_UdbRangePerAnchorArr;
        }
    }
    else if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        if (direction == CPSS_PCL_DIRECTION_INGRESS_E)
        {
            udbRangePerAnchorPtr = sip6_ipcl_UdbRangePerAnchorArr;
        }
        else
        {
            udbRangePerAnchorPtr = sip6_epcl_UdbRangePerAnchorArr;
        }
    }
    else if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        udbRangePerAnchorPtr = sip5_20_UdbRangePerAnchorArr;
    }
    else
    {
        udbRangePerAnchorPtr = sip5UdbRangePerAnchorArr;
    }


    if(direction != CPSS_PCL_DIRECTION_INGRESS_E &&
       direction != CPSS_PCL_DIRECTION_EGRESS_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* Calculate entry index by packet type */
    rc = sip5PclUDBEntryIndexGet(devNum, packetType, &udbEntryIndex);
    if (rc != GT_OK)
    {
        return rc;
    }

    rc = sip5PclUdbOffsetTypeSw2Hw(offsetType, &hwAnchor);
    if (rc != GT_OK)
    {
        return rc;
    }

    if ((udbIndex >= udbRangePerAnchorPtr[offsetType].maxUdb)
        || (udbIndex < udbRangePerAnchorPtr[offsetType].lowUdb))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "offsetType [%d] : udbIndex[%d] < min [%d] or >= max[%d]",
            offsetType,
            udbIndex,
            udbRangePerAnchorPtr[offsetType].lowUdb,
            udbRangePerAnchorPtr[offsetType].maxUdb);
    }

    if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
    {

        /*
            bit 0 - valid
            bits 1..3 - Anchor
            bits 4..10 - offset (7 bits)
        */
        tableType = CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_UDB_CONFIG_E;
        numBitsInfo = 11;/* 11 bits per UDB */
        if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            numBitsInfo = 12;/* 12 bits per UDB */
        }
        if (offset > udbRangePerAnchorPtr[offsetType].ingrMaxOffset)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        /*
            bit 0 - valid
            bits 1..3 - Anchor
            bits 4..11 - offset (8 bits)
        */
        tableType = CPSS_DXCH_SIP5_TABLE_HA_EPCL_UDB_CONFIG_E;
        numBitsInfo = 12;/* 12 bits per UDB */
        if (offset > udbRangePerAnchorPtr[offsetType].egrMaxOffset)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
    }

    regValue = (offset << 4);

    /*
         type of the offset for UDB:
         0x0 =  L2; Offset is defined from the beginning of the outgoing passenger MAC header (if no tunnel start, then it refers to the full outgoing packet header);
         0x1 =  MPLS; Offset is defined from start of MPLS header - 2.;
         0x2 =  L3; Offset is defined from the beginning of the outgoing passenger L3 header (according to L3 offset. if no tunnel start, then it refers to the L3 of the full outgoing packet header);
         0x3 =  L4; Offset is defined from the beginning of the outgoing passenger L4 header (if no tunnel start, then it refers to the L4 of the full outgoing packet header);
         0x4 = Tunnel L2; Tunnel_L2; Refers to the beginning of the outgoing packets MAC header (after tunnel-start).
                If packet was not tunnel-start this anchor is invalid;
         0x5 = Tunnel L3; Tunnel_L3; Same as L3 anchor but for the outgoing packets header (after to tunnel-start).
                If packet was not tunnel-start this anchor is invalid;
         0x6 = Metadata; Calculated fields;
         0x7 = Tunnel L4; this is the start of the original packets tunnel L4 header, If packet was not tunnel-start this anchor is invalid
               not supported in EPCL (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
    */

    regValue |= (hwAnchor << 1);
    if (offsetType != CPSS_DXCH_PCL_OFFSET_INVALID_E)
    {
        regValue |= 1; /* bit 0 means "valid" */
    }

    startBit = numBitsInfo * udbIndex;

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        rc =  prvCpssDxChPortGroupWriteTableEntryField(
            devNum, portGroupId,
            tableType,
            udbEntryIndex,
            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
            startBit,
            numBitsInfo,
            regValue);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)


    return GT_OK;
}

/**
* @internal internal_cpssDxChPclPortGroupUserDefinedByteSet function
* @endinternal
*
* @brief   The function configures the User Defined Byte (UDB)
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] ruleFormat               - rule format
*                                      Relevant for DxCh3 devices
* @param[in] packetType               - packet Type
*                                      Used for Ingress Only
*                                      (APPLICABLE DEVICES xCat3; AC5; Lion2.)
*                                      Used for Ingress and Egress
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.)
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress.(APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      Ignored, configure ingress.
*                                      (APPLICABLE DEVICES xCat3; AC5)
* @param[in] udbIndex                 - index of User Defined Byte to configure.
*                                      See format of rules to known indexes of UDBs
* @param[in] offset                   - the type of offset (see CPSS_DXCH_PCL_OFFSET_TYPE_ENT)
* @param[in] offset                   - The  of the user-defined byte, in bytes,from the
*                                      place in the packet indicated by the offset type
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong parameter
* @retval GT_OUT_OF_RANGE          - parameter value more than HW bit field
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note See comments to CPSS_DXCH_PCL_OFFSET_TYPE_ENT
*
*/
static GT_STATUS internal_cpssDxChPclPortGroupUserDefinedByteSet
(
    IN GT_U8                                devNum,
    IN GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN CPSS_PCL_DIRECTION_ENT               direction,
    IN GT_U32                               udbIndex,
    IN CPSS_DXCH_PCL_OFFSET_TYPE_ENT        offsetType,
    IN GT_U8                                offset
)
{
    GT_STATUS rc;              /* return code              */
    GT_U32    regValue;        /* value to update register */
    GT_U32    startBit;        /* start Bit                */
    GT_U32    udbEntryIndex;   /* XCat HW UDB entry index  */
    GT_U32    portGroupId;     /*the port group Id         */
    GT_U32    udbIntIndex;     /*index of UDB in the entry */
    GT_U32    numBitsInfo;/* number of bits of info per UDB*/

    (GT_VOID)ruleFormat; /* not used */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    /* TUNNEL_L4 anchorType supported only in sip6_10 devices */
    if((!PRV_CPSS_SIP_6_10_CHECK_MAC(devNum) || direction != CPSS_PCL_DIRECTION_INGRESS_E)  && offsetType == CPSS_DXCH_PCL_OFFSET_TUNNEL_L4_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        return sip5PclPortGroupUserDefinedByteSet(devNum,portGroupsBmp,packetType,direction,
                udbIndex,offsetType,offset);
    }

    /* xCat3 and Lion2 */

    if (offset >= BIT_7)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    regValue = (offset << 3);

    /* bit 0 means "valid", bit 10 - "comparator" */
    switch (offsetType)
    {
        case CPSS_DXCH_PCL_OFFSET_L2_E:
            regValue |= (UDB_XCAT_HW_L2_CNS << 1) | 1;
            break;
        case CPSS_DXCH_PCL_OFFSET_L3_MINUS_2_E:
            regValue |= (UDB_XCAT_HW_L3_CNS << 1) | 1;
            break;
        case CPSS_DXCH_PCL_OFFSET_L4_E:
            regValue |= (UDB_XCAT_HW_L4_CNS << 1) | 1;
            break;
        case CPSS_DXCH_PCL_OFFSET_MPLS_MINUS_2_E:
            regValue |= (UDB_XCAT_HW_MPLS_CNS << 1) | 1;
            break;
        case CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E:
            regValue |= (UDB_XCAT_HW_L2_CNS << 1) | 1 | (1 << 10);
            break;
        case CPSS_DXCH_PCL_OFFSET_INVALID_E:
            /* L2 without valid bit*/
            regValue |= (UDB_XCAT_HW_L2_CNS << 1);
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }


    /* xCat3 and above up to Lion2 UDBs - direction ignored */
    /* Bobcat2; Caelum; Bobcat3 ingress PCL UDBs                               */

    /* Calculate entry index by packet type */
    rc = prvCpssDxChXCatPclUDBEntryIndexGet(
        devNum, packetType, udbIndex, &udbEntryIndex, &udbIntIndex);
    if (rc != GT_OK)
    {
        return rc;
    }

    numBitsInfo = 11;/* 11 bits per UDB */
    startBit = numBitsInfo * udbIntIndex;

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        /* set the UDB info */
        rc =  prvCpssDxChPortGroupWriteTableEntryField(
            devNum, portGroupId,
            CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_UDB_CONFIG_E,
            udbEntryIndex,
            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
            startBit,
            numBitsInfo,
            regValue);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupUserDefinedByteSet function
* @endinternal
*
* @brief   The function configures the User Defined Byte (UDB)
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] ruleFormat               - rule format
*                                      Relevant for DxCh3 devices
* @param[in] packetType               - packet Type
*                                      Used for Ingress Only
*                                      (APPLICABLE DEVICES xCat3; AC5; Lion2.)
*                                      Used for Ingress and Egress
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.)
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress.(APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      Ignored, configure ingress.
*                                      (APPLICABLE DEVICES xCat3; AC5)
* @param[in] udbIndex                 - index of User Defined Byte to configure.
*                                      See format of rules to known indexes of UDBs
* @param[in] offset                   - the type of offset (see CPSS_DXCH_PCL_OFFSET_TYPE_ENT)
* @param[in] offset                   - The  of the user-defined byte, in bytes,from the
*                                      place in the packet indicated by the offset type
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong parameter
* @retval GT_OUT_OF_RANGE          - parameter value more than HW bit field
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note See comments to CPSS_DXCH_PCL_OFFSET_TYPE_ENT
*
*/
GT_STATUS cpssDxChPclPortGroupUserDefinedByteSet
(
    IN GT_U8                                devNum,
    IN GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN CPSS_PCL_DIRECTION_ENT               direction,
    IN GT_U32                               udbIndex,
    IN CPSS_DXCH_PCL_OFFSET_TYPE_ENT        offsetType,
    IN GT_U8                                offset
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupUserDefinedByteSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, ruleFormat, packetType, direction, udbIndex, offsetType, offset));

    rc = internal_cpssDxChPclPortGroupUserDefinedByteSet(devNum, portGroupsBmp, ruleFormat, packetType, direction, udbIndex, offsetType, offset);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, ruleFormat, packetType, direction, udbIndex, offsetType, offset));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal sip5PclPortGroupUserDefinedByteGet function
* @endinternal
*
* @brief   The function gets the User Defined Byte (UDB) configuration
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] portGroupId              - bitmap of Port Groups or CPSS_PORT_GROUP_UNAWARE_MODE_CNS.
* @param[in] packetType               - packet Type
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress.
* @param[in] udbIndex                 - index of User Defined Byte to configure.
*                                      See format of rules to known indexes of UDBs
*
* @param[out] offsetTypePtr            - (pointer to) The type of offset
*                                      (see CPSS_DXCH_PCL_OFFSET_TYPE_ENT)
* @param[out] offsetPtr                - (pointer to) The offset of the user-defined byte,
*                                      in bytes,from the place in the packet
*                                      indicated by the offset type.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong parameter
* @retval GT_BAD_PTR               - null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS sip5PclPortGroupUserDefinedByteGet
(
    IN  GT_U8                                devNum,
    IN  GT_U32                               portGroupId,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_DIRECTION_ENT               direction,
    IN  GT_U32                               udbIndex,
    OUT CPSS_DXCH_PCL_OFFSET_TYPE_ENT        *offsetTypePtr,
    OUT GT_U8                                *offsetPtr
)
{
    GT_STATUS rc;              /* return code              */
    GT_U32    regValue;        /* register  value*/
    GT_U32    startBit;        /* start Bit                */
    GT_U32    udbEntryIndex;   /* XCat HW UDB entry index  */
    GT_U32    numBitsInfo;/* number of bits of info per UDB*/
    GT_U32    i;               /* loop index               */
    GT_U32    numOfTypes;      /* num Of Offset Types      */
    GT_U32    hwAnchor;        /* HW OffsetType            */
    CPSS_DXCH_TABLE_ENT tableType;
    GT_U32    numMaxUdbs;
    GT_U32    numBitsPerUdb;
    GT_U32    startBitsAfterUdbs;

    if(direction != CPSS_PCL_DIRECTION_INGRESS_E &&
       direction != CPSS_PCL_DIRECTION_EGRESS_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    sip5UdbSelectionEntryFormatInfoGet(devNum,
        direction == CPSS_PCL_DIRECTION_EGRESS_E, &numMaxUdbs, &numBitsPerUdb,
        &startBitsAfterUdbs);

    if (udbIndex >= numMaxUdbs)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* Calculate entry index by packet type */
    rc = sip5PclUDBEntryIndexGet(devNum, packetType, &udbEntryIndex);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
    {
        /*
            bit 0 - valid
            bits 1..3 - Anchor
            bits 4..10 - offset (7 bits)
        */
        tableType = CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_UDB_CONFIG_E;
        numBitsInfo = 11;/* 11 bits per UDB */
        if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            numBitsInfo = 12;/* 12 bits per UDB */
        }
    }
    else
    {
        /*
            bit 0 - valid
            bits 1..3 - Anchor
            bits 4..11 - offset (8 bits)
        */
        tableType = CPSS_DXCH_SIP5_TABLE_HA_EPCL_UDB_CONFIG_E;
        numBitsInfo = 12;/* 12 bits per UDB */
    }

    startBit = numBitsInfo * udbIndex;

    rc =  prvCpssDxChPortGroupReadTableEntryField(
        devNum, portGroupId,
        tableType,
        udbEntryIndex,
        PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
        startBit,
        numBitsInfo,
        &regValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    *offsetPtr = (GT_U8) U32_GET_FIELD_MAC(regValue,4,8);

    if (U32_GET_FIELD_MAC(regValue,0,1) == 0)
    {
        /* invalid UDB */
        *offsetTypePtr = CPSS_DXCH_PCL_OFFSET_INVALID_E;
        return GT_OK;
    }

    /*
         type of the offset for UDB:
         0x0 =  L2; Offset is defined from the beginning of the outgoing passenger MAC header (if no tunnel start, then it refers to the full outgoing packet header);
         0x1 =  MPLS; Offset is defined from start of MPLS header - 2.;
         0x2 =  L3; Offset is defined from the beginning of the outgoing passenger L3 header (according to L3 offset. if no tunnel start, then it refers to the L3 of the full outgoing packet header);
         0x3 =  L4; Offset is defined from the beginning of the outgoing passenger L4 header (if no tunnel start, then it refers to the L4 of the full outgoing packet header);
         0x4 = Tunnel L2; Tunnel_L2; Refers to the beginning of the outgoing packets MAC header (after tunnel-start).
                If packet was not tunnel-start this anchor is invalid;
         0x5 = Tunnel L3; Tunnel_L3; Same as L3 anchor but for the outgoing packets header (after to tunnel-start).
                If packet was not tunnel-start this anchor is invalid;
         0x6 = Metadata; Calculated fields;
         0x7 = Tunnel L4; this is the start of the original packets tunnel L4 header, If packet was not tunnel-start this anchor is invalid
               not supported in EPCL (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
    */

    hwAnchor = U32_GET_FIELD_MAC(regValue,1,3);
    numOfTypes =
        (sizeof(sip5ConvertSwUdbAnchorToHwValueArr) /
         sizeof(sip5ConvertSwUdbAnchorToHwValueArr[0]));

    for (i = 0; (i < numOfTypes); i++)
    {
        if (hwAnchor == (GT_U32)sip5ConvertSwUdbAnchorToHwValueArr[i])
        {
            *offsetTypePtr = (CPSS_DXCH_PCL_OFFSET_TYPE_ENT)i;
            break;
        }
    }

    if (i >= numOfTypes)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChPclPortGroupUserDefinedByteGet function
* @endinternal
*
* @brief   The function gets the User Defined Byte (UDB) configuration
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] ruleFormat               - rule format
*                                      Relevant for DxCh3 devices
* @param[in] packetType               - packet Type
*                                      Used for Ingress Only
*                                      (APPLICABLE DEVICES xCat3; AC5; Lion2.)
*                                      Used for Ingress and Egress
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.)
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress.(APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      Ignored, configure ingress.
*                                      (APPLICABLE DEVICES xCat3; AC5)
* @param[in] udbIndex                 - index of User Defined Byte to configure.
*                                      See format of rules to known indexes of UDBs
*
* @param[out] offsetTypePtr            - (pointer to) The type of offset
*                                      (see CPSS_DXCH_PCL_OFFSET_TYPE_ENT)
* @param[out] offsetPtr                - (pointer to) The offset of the user-defined byte,
*                                      in bytes,from the place in the packet
*                                      indicated by the offset type.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong parameter
* @retval GT_BAD_PTR               - null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note See comments to CPSS_DXCH_PCL_OFFSET_TYPE_ENT
*
*/
static GT_STATUS internal_cpssDxChPclPortGroupUserDefinedByteGet
(
    IN  GT_U8                                devNum,
    IN  GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_DIRECTION_ENT               direction,
    IN  GT_U32                               udbIndex,
    OUT CPSS_DXCH_PCL_OFFSET_TYPE_ENT        *offsetTypePtr,
    OUT GT_U8                                *offsetPtr
)
{
    GT_STATUS rc;               /* return code              */
    GT_U32    regValue;         /* value to update register */
    GT_U32    startBit;         /* start Bit                */
    GT_U32    udbEntryIndex;    /* XCat HW UDB entry index  */
    GT_U32    portGroupId;      /*the port group Id         */
    GT_U32    udbIntIndex;      /*index of UDB in the entry */
    GT_U32    numBitsInfo;/* number of bits of info per UDB*/

    /* temporary unused parametres */
    (GT_VOID)direction;
    (GT_VOID)ruleFormat;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(offsetTypePtr);
    CPSS_NULL_PTR_CHECK_MAC(offsetPtr);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
        devNum, portGroupsBmp, portGroupId);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        return sip5PclPortGroupUserDefinedByteGet(devNum,portGroupId,packetType,direction,
                udbIndex,offsetTypePtr,offsetPtr);
    }

    /* Lion2 & xCat3 devices */
    /* Direction ignored     */

    /* Calculate entry index by packet type */
    rc = prvCpssDxChXCatPclUDBEntryIndexGet(
        devNum, packetType, udbIndex, &udbEntryIndex, &udbIntIndex);
    if (rc != GT_OK)
    {
        return rc;
    }

    numBitsInfo = 11;/* 11 bits per UDB */
    startBit = numBitsInfo * udbIntIndex;

    /* get the UDB info */
    rc =  prvCpssDxChPortGroupReadTableEntryField(
        devNum, portGroupId,
        CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_UDB_CONFIG_E,
        udbEntryIndex,
        PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
        startBit,
        numBitsInfo,
        &regValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    *offsetPtr = (GT_U8)((regValue >> 3) & 0x7F);

    if ((regValue & 1) == 0)
    {
        /* invalid UDB */
        *offsetTypePtr = CPSS_DXCH_PCL_OFFSET_INVALID_E;
            return GT_OK;
        }

    if ((regValue & (1 << 10)) != 0)
    {
        /* TCP/UDB comparator */
        *offsetTypePtr = CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E;
        return GT_OK;
    }

    switch ((regValue >> 1) & 3)
    {
         case UDB_XCAT_HW_L2_CNS:
             *offsetTypePtr = CPSS_DXCH_PCL_OFFSET_L2_E;
             break;
         case UDB_XCAT_HW_L3_CNS:
             *offsetTypePtr = CPSS_DXCH_PCL_OFFSET_L3_MINUS_2_E;
             break;
         case UDB_XCAT_HW_L4_CNS:
             *offsetTypePtr = CPSS_DXCH_PCL_OFFSET_L4_E;
             break;
         case UDB_XCAT_HW_MPLS_CNS:
             *offsetTypePtr = CPSS_DXCH_PCL_OFFSET_MPLS_MINUS_2_E;
             break;
         /* cannot occur */
         default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
     }

     return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupUserDefinedByteGet function
* @endinternal
*
* @brief   The function gets the User Defined Byte (UDB) configuration
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] ruleFormat               - rule format
*                                      Relevant for DxCh3 devices
* @param[in] packetType               - packet Type
*                                      Used for Ingress Only
*                                      (APPLICABLE DEVICES xCat3; AC5; Lion2.)
*                                      Used for Ingress and Egress
*                                      (APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3.)
* @param[in] direction                - Policy direction:
*                                      Ingress or Egress.(APPLICABLE DEVICES Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      Ignored, configure ingress.
*                                      (APPLICABLE DEVICES xCat3; AC5)
* @param[in] udbIndex                 - index of User Defined Byte to configure.
*                                      See format of rules to known indexes of UDBs
*
* @param[out] offsetTypePtr            - (pointer to) The type of offset
*                                      (see CPSS_DXCH_PCL_OFFSET_TYPE_ENT)
* @param[out] offsetPtr                - (pointer to) The offset of the user-defined byte,
*                                      in bytes,from the place in the packet
*                                      indicated by the offset type.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong parameter
* @retval GT_BAD_PTR               - null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*
* @note See comments to CPSS_DXCH_PCL_OFFSET_TYPE_ENT
*
*/
GT_STATUS cpssDxChPclPortGroupUserDefinedByteGet
(
    IN  GT_U8                                devNum,
    IN  GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_DIRECTION_ENT               direction,
    IN  GT_U32                               udbIndex,
    OUT CPSS_DXCH_PCL_OFFSET_TYPE_ENT        *offsetTypePtr,
    OUT GT_U8                                *offsetPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupUserDefinedByteGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, ruleFormat, packetType, direction, udbIndex, offsetTypePtr, offsetPtr));

    rc = internal_cpssDxChPclPortGroupUserDefinedByteGet(devNum, portGroupsBmp, ruleFormat, packetType, direction, udbIndex, offsetTypePtr, offsetPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, ruleFormat, packetType, direction, udbIndex, offsetTypePtr, offsetPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal sip5PclUDBSelectEntryIndexGet function
* @endinternal
*
* @brief   Get the User Defined Byte (UDB) Selection Configuration entry index.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
*                                      Valid only UDB only key formats.
*                                      The parameter used also to determinate Ingress or Egress.
* @param[in] packetType               - packet Type
* @param[in] lookupNum                - Lookup number. Ignored for egress.
*
* @param[out] indexPtr                 - (pointer to) entry index.
* @param[out] egressPtr                - (pointer to) GT_TRUE - Egress PCL, GT_FALSE - Ingress PCL.
* @param[out] tableTypePtr             - (pointer to) table Id.
* @param[out] replacement_tableTypePtr - (pointer to) replacement_tableTypePtr
*                                         this table relevant only from sip_6_30 devices
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
*/
static GT_STATUS sip5PclUDBSelectEntryIndexGet
(
    IN GT_U8                                 devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum,
    OUT GT_U32                               *indexPtr,
    OUT GT_BOOL                              *egressPtr,
    OUT CPSS_DXCH_TABLE_ENT              *tableTypePtr,
    OUT CPSS_DXCH_TABLE_ENT              *replacement_tableTypePtr
)
{
    GT_STATUS rc;              /* return code      */
    GT_U32    packetTypeIndex; /* packet Type Index */
    GT_U32    keyTypeIndex;    /* key Type Index    */

    if(((CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E == ruleFormat) && !PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* Calculate entry index by packet type */
    rc = sip5PclUDBEntryIndexGet(devNum, packetType, &packetTypeIndex);
    if (rc != GT_OK)
    {
        return rc;
    }

    switch (ruleFormat)
    {
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E:
            *egressPtr = GT_FALSE;
            keyTypeIndex = 0;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E:
            *egressPtr = GT_FALSE;
            keyTypeIndex = 1;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E:
            *egressPtr = GT_FALSE;
            keyTypeIndex = 2;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E:
            *egressPtr = GT_FALSE;
            keyTypeIndex = 3;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E:
            *egressPtr = GT_FALSE;
            keyTypeIndex = 4;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E:
            *egressPtr = GT_FALSE;
            keyTypeIndex = 5;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E:
            *egressPtr = GT_FALSE;
            keyTypeIndex = 6;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E:
            *egressPtr = GT_TRUE;
            keyTypeIndex = 0;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E:
            *egressPtr = GT_TRUE;
            keyTypeIndex = 1;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E:
            *egressPtr = GT_TRUE;
            keyTypeIndex = 2;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E:
            *egressPtr = GT_TRUE;
            keyTypeIndex = 3;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E:
            *egressPtr = GT_TRUE;
            keyTypeIndex = 4;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E:
            *egressPtr = GT_TRUE;
            keyTypeIndex = 5;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    *indexPtr = (16 * keyTypeIndex) + packetTypeIndex;
    if (*egressPtr == GT_FALSE)
    {
        /* ingress */
        switch (lookupNum)
        {
            case CPSS_PCL_LOOKUP_0_E:
            case CPSS_PCL_LOOKUP_0_0_E:
                *tableTypePtr = CPSS_DXCH_SIP5_TABLE_IPCL0_UDB_SELECT_E;
                *replacement_tableTypePtr = CPSS_DXCH_SIP6_30_TABLE_IPCL0_UDB_REPLACEMENT_E;
                break;
            case CPSS_PCL_LOOKUP_0_1_E:
                *tableTypePtr = CPSS_DXCH_SIP5_TABLE_IPCL1_UDB_SELECT_E;
                *replacement_tableTypePtr = CPSS_DXCH_SIP6_30_TABLE_IPCL1_UDB_REPLACEMENT_E;
                break;
            case CPSS_PCL_LOOKUP_1_E:
                if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                *tableTypePtr = CPSS_DXCH_SIP5_TABLE_IPCL2_UDB_SELECT_E;
                *replacement_tableTypePtr = CPSS_DXCH_SIP6_30_TABLE_IPCL2_UDB_REPLACEMENT_E;
                break;
            default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        /* egress */
        *tableTypePtr = CPSS_DXCH_SIP5_TABLE_EPCL_UDB_SELECT_E;
    }

    return GT_OK;
}

/**
* @internal sip5UdbSelectionEntryFormatInfoGet function
* @endinternal
*
* @brief   info about field format in the IPCL/EPCL UDB Select Entry
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] isEgress                 - indication if EPCL or IPCL
*
* @param[out] numMaxUdbsPtr            - (pointer to) max number of UDBs
* @param[out] numBitsPerUdbPtr         - (pointer to) number of bits for field of :
*                                      The decimal UDB number in the global UDB pool
*                                      that is selected as UDB #n in this UDB key.
* @param[out] startBitsAfterUdbsPtr    - (pointer to) bit index after the UDBs.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
*/
static void sip5UdbSelectionEntryFormatInfoGet(
    IN   GT_U8    devNum,
    IN   GT_BOOL  isEgress,
    OUT  GT_U32   *numMaxUdbsPtr,
    OUT  GT_U32   *numBitsPerUdbPtr,
    OUT  GT_U32   *startBitsAfterUdbsPtr
)
{
    GT_U32  numMaxUdbs    ;    /*max number of UDBs*/
    GT_U32  numBitsPerUdb ;    /*number of bits for field of :
                               The decimal UDB number in the global UDB pool
                               that is selected as UDB #n in this UDB key.*/
    GT_U32  startBitsAfterUdbs; /*bit index after the UDBs.*/

    if(isEgress == GT_TRUE)
    {
        numMaxUdbs    = PRV_CPSS_SIP_6_10_CHECK_MAC(devNum) ? 60 : 50;
        numBitsPerUdb = 6;
    }
    else
    {
        numMaxUdbs    = PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? 70 : 50;
        numBitsPerUdb = PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ?  7 : 6;
    }

    startBitsAfterUdbs = (numMaxUdbs * numBitsPerUdb);


    *numMaxUdbsPtr          = numMaxUdbs;
    *numBitsPerUdbPtr       = numBitsPerUdb;
    *startBitsAfterUdbsPtr  = startBitsAfterUdbs;

    return ;
}

/**
* @internal prvCpssDxChPclPortGroupUserDefinedBytesSelectSet function
* @endinternal
*
* @brief   Set the User Defined Byte (UDB) Selection Configuration.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] ruleFormat               - rule format
*                                      Valid only UDB only key formats.
*                                      The parameter used also to determinate Ingress or Egress.
*                                      Relevant values are:
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
* @param[in] packetType               - packet Type
* @param[in] lookupNum                - Lookup number. Ignored for egress.
* @param[in] udbSelectPtr             - (pointer to) structure with UDB Selection configuration.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_OUT_OF_RANGE          - on out-of-range parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS prvCpssDxChPclPortGroupUserDefinedBytesSelectSet
(
    IN  GT_U8                                devNum,
    IN  GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum,
    IN  CPSS_DXCH_PCL_UDB_SELECT_STC         *udbSelectPtr
)
{
    GT_STATUS                rc;          /* return code                          */
    GT_U32                   index;       /* table entry index                    */
    GT_BOOL                  egress;      /* GT_TRUE - egress, GT_FALSE - ingress */
    CPSS_DXCH_TABLE_ENT  tableType;       /* table Id                             */
    CPSS_DXCH_TABLE_ENT  replacement_tableType;/* table Id for sip_6_30 UDB replacement */
    GT_U32                   hwData[UDB_SELECTION_WORDS];  /* data in HW format   */
    GT_U32                   i;           /* loop iterator                        */
    GT_U32                   offset;      /* offset in HW                         */
    GT_U32                   portGroupId; /* the port group Id                    */
    GT_U32  numMaxUdbs    ;    /*max number of UDBs*/
    GT_U32  udbsInKey     ;    /* number of UDBs in the key*/
    GT_U32  numBitsPerUdb ;    /*number of bits for field of :
                               The decimal UDB number in the global UDB pool
                               that is selected as UDB #n in this UDB key.*/
    GT_U32  startBitsAfterUdbs; /*bit index after the UDBs.*/
    GT_U32  numEntries;/* num entries in UDB select table */
    GT_U32  tmpHwData[1];  /* data in HW format   */
    GT_U32  maxUdbReplace;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    CPSS_NULL_PTR_CHECK_MAC(udbSelectPtr);

    if((CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E == ruleFormat && !PRV_CPSS_SIP_6_10_CHECK_MAC(devNum)) ||
        (CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E == ruleFormat && !PRV_CPSS_SIP_6_10_CHECK_MAC(devNum)))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    maxUdbReplace = PRV_CPSS_SIP_6_10_CHECK_MAC(devNum)
        ? CPSS_DXCH_PCL_INGRESS_UDB_REPLACE_MAX_CNS
        : PRV_CPSS_DXCH_PCL_INGRESS_UDB_REPLACE_MAX_SIP_5_CNS;

    rc = sip5PclUDBSelectEntryIndexGet(
        devNum, ruleFormat, packetType, lookupNum,
        &index, &egress, &tableType , &replacement_tableType);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* get info about the format of the entry */
    sip5UdbSelectionEntryFormatInfoGet(devNum,egress,
            &numMaxUdbs,&numBitsPerUdb,
            &startBitsAfterUdbs);

    /* the table hold 16 entries per 'udb size' so we divide the index by 16 */
    /* then we multiple it by 10 , to know the 'udb size' */
    udbsInKey = ((index / 16)+1) * 10;/*10/20/...70*/

    if(udbsInKey > numMaxUdbs)
    {
        /* non-sip5_20 than not supports only 50 UDBs on '60 bytes' key */
        udbsInKey = numMaxUdbs;
    }

    for (i = 0; (i < udbsInKey); i++)
    {
        if (udbSelectPtr->udbSelectArr[i] >= numMaxUdbs)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
    }

    rc = prvCpssDxChTableNumEntriesGet(devNum,tableType,&numEntries);
    if (rc != GT_OK)
    {
        return rc;
    }
    if(numEntries == 0)
    {
        /* the UDB select table not exists in this IPCL/EPCL lookup */
        /* the HW will do implicit 1:1 UDB selection                */
        /* make sure that the application kn'ows about this mapping  */
        for (i = 0; (i < udbsInKey); i++)
        {
            if((egress == GT_FALSE) && (i < maxUdbReplace)
               && (udbSelectPtr->ingrUdbReplaceArr[i] == GT_TRUE))
            {
                /* the UDB is overwritten , so not need to check it ! */
                continue;
            }
            else
            if(egress == GT_TRUE && udbSelectPtr->egrUdb01Replace == GT_TRUE && i <= 1)
            {
                /* the UDB is overwritten , so not need to check it ! */
                continue;
            }
            else
            if(egress == GT_TRUE && udbSelectPtr->egrUdbBit15Replace == GT_TRUE && i == 15)
            {
                /* the UDB is overwritten , so not need to check it ! */
                continue;
            }

            if(udbSelectPtr->udbSelectArr[i] != i)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,
                "All UDB select must have 1:1 mapping , but index[%d] hold value[%d] instead of [%d]" ,
                i,udbSelectPtr->udbSelectArr[i],i);
            }
        }
    }

    cpssOsMemSet(hwData, 0, sizeof(hwData));

    for (i = 0; (i < udbsInKey); i++)
    {
        offset = (numBitsPerUdb * i);
        U32_SET_FIELD_IN_ENTRY_MAC(
            hwData, offset, numBitsPerUdb/*length*/, udbSelectPtr->udbSelectArr[i]);
    }

    if (egress == GT_FALSE)
    {
        if(PRV_CPSS_SIP_6_30_CHECK_MAC(devNum))
        {
            cpssOsMemSet(tmpHwData, 0, sizeof(tmpHwData));

            for (i = 0; (i < maxUdbReplace); i++)
            {
                offset = i;
                U32_SET_FIELD_IN_ENTRY_MAC(
                    tmpHwData, offset, 1/*length*/,
                    BOOL2BIT_MAC(udbSelectPtr->ingrUdbReplaceArr[i]));
            }

            /* Set Key Byte Replacement mode */
            switch(udbSelectPtr->keyByteReplacementMode)
            {
                case CPSS_DXCH_PCL_KEY_BYTE_REPLACEMENT_MODE_HASH_AND_QOS_E:
                    i = 0;
                    break;
                case CPSS_DXCH_PCL_KEY_BYTE_REPLACEMENT_MODE_SRC_DST_EPG_E:
                    i = 1;
                    break;
                case CPSS_DXCH_PCL_KEY_BYTE_REPLACEMENT_MODE_SRC_ID_11_0_COPY_RES_12_1_E:
                    i = 2;
                    break;
                case CPSS_DXCH_PCL_KEY_BYTE_REPLACEMENT_MODE_SRC_ID_3_0_COPY_RES_19_0_E:
                    i = 3;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            U32_SET_FIELD_IN_ENTRY_MAC(tmpHwData, 19, 2, i);

            PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
                devNum, portGroupsBmp, portGroupId)
            {
                rc = prvCpssDxChPortGroupWriteTableEntry(
                    devNum, portGroupId, replacement_tableType,
                    index, tmpHwData);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }
            PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
                devNum, portGroupsBmp, portGroupId)
        }
        else
        {
            /* ingress */
            for (i = 0; (i < maxUdbReplace); i++)
            {
                offset = (startBitsAfterUdbs + i);
                U32_SET_FIELD_IN_ENTRY_MAC(
                    hwData, offset, 1/*length*/,
                    BOOL2BIT_MAC(udbSelectPtr->ingrUdbReplaceArr[i]));
            }
        }
    }
    else
    {
        /* egress */

        if(PRV_CPSS_SIP_6_30_CHECK_MAC(devNum))
        {
            tmpHwData[0] = BOOL2BIT_MAC(udbSelectPtr->egrUdb01Replace) |
                     BOOL2BIT_MAC(udbSelectPtr->egrUdbBit15Replace) << 1;

            rc = prvCpssHwPpSetRegField(devNum,
                PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCL_UDB_replacement[index/16],
                (index%16)*2/*offset*/, 2/*Length*/, tmpHwData[0]);
            if (rc != GT_OK)
            {
                return rc;
            }
            startBitsAfterUdbs = 0;
        }
        else
        {
            offset = startBitsAfterUdbs;
            U32_SET_FIELD_IN_ENTRY_MAC(
                hwData, offset, 1/*length*/,
                BOOL2BIT_MAC(udbSelectPtr->egrUdb01Replace));
            offset = startBitsAfterUdbs + 1;
            U32_SET_FIELD_IN_ENTRY_MAC(
                hwData, offset, 1/*length*/,
                BOOL2BIT_MAC(udbSelectPtr->egrUdbBit15Replace));
        }
    }

    if(numEntries == 0)
    {
        /* the UDB select table not exists in this IPCL/EPCL lookup */
        /* the HW will do implicit 1:1 UDB selection                */
        return GT_OK;
    }

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        rc = prvCpssDxChPortGroupWriteTableEntry(
            devNum, portGroupId, tableType,
            index, hwData);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}

/**
* @internal internal_cpssDxChPclUserDefinedBytesSelectSet function
* @endinternal
*
* @brief   Set the User Defined Byte (UDB) Selection Configuration.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
*                                      Valid only UDB only key formats.
*                                      The parameter used also to determinate Ingress or Egress.
*                                      Relevant values are:
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
* @param[in] packetType               - packet Type
* @param[in] lookupNum                - Lookup number. Ignored for egress.
* @param[in] udbSelectPtr             - (pointer to) structure with UDB Selection configuration.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_OUT_OF_RANGE          - on out-of-range parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclUserDefinedBytesSelectSet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum,
    IN  CPSS_DXCH_PCL_UDB_SELECT_STC         *udbSelectPtr
)
{
    return prvCpssDxChPclPortGroupUserDefinedBytesSelectSet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        ruleFormat, packetType, lookupNum, udbSelectPtr);
}

/**
* @internal cpssDxChPclUserDefinedBytesSelectSet function
* @endinternal
*
* @brief   Set the User Defined Byte (UDB) Selection Configuration.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
*                                      Valid only UDB only key formats.
*                                      The parameter used also to determinate Ingress or Egress.
*                                      Relevant values are:
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
* @param[in] packetType               - packet Type
* @param[in] lookupNum                - Lookup number. Ignored for egress.
* @param[in] udbSelectPtr             - (pointer to) structure with UDB Selection configuration.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_OUT_OF_RANGE          - on out-of-range parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclUserDefinedBytesSelectSet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum,
    IN  CPSS_DXCH_PCL_UDB_SELECT_STC         *udbSelectPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclUserDefinedBytesSelectSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ruleFormat, packetType, lookupNum, udbSelectPtr));

    rc = internal_cpssDxChPclUserDefinedBytesSelectSet(devNum, ruleFormat, packetType, lookupNum, udbSelectPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ruleFormat, packetType, lookupNum, udbSelectPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChPclPortGroupUserDefinedBytesSelectGet function
* @endinternal
*
* @brief   Get the User Defined Byte (UDB) Selection Configuration.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Falcon)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] ruleFormat               - rule format
*                                      Valid only UDB only key formats.
*                                      The parameter used also to determinate Ingress or Egress.
*                                      Relevant values are:
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
* @param[in] packetType               - packet Type
* @param[in] lookupNum                - Lookup number. Ignored for egress.
*
* @param[out] udbSelectPtr             - (pointer to) structure with UDB Selection configuration.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_STATE             - on unsupported HW state
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS prvCpssDxChPclPortGroupUserDefinedBytesSelectGet
(
    IN  GT_U8                                devNum,
    IN  GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum,
    OUT CPSS_DXCH_PCL_UDB_SELECT_STC         *udbSelectPtr
)
{
    GT_STATUS                rc;          /* return code                          */
    GT_U32                   index;       /* table entry index                    */
    GT_BOOL                  egress;      /* GT_TRUE - egress, GT_FALSE - ingress */
    CPSS_DXCH_TABLE_ENT  tableType;       /* table Id                             */
    CPSS_DXCH_TABLE_ENT  replacement_tableType;/* table Id for sip_6_30 UDB replacement */
    GT_U32                   entryBuf[UDB_SELECTION_WORDS];  /* data in HW format   */
    GT_U32                   i;           /* loop iterator                        */
    GT_U32                   offset;      /* offset in HW                         */
    GT_U32                   portGroupId; /* the port group Id                    */
    GT_U32                   data;        /* HW field value                       */
    GT_U32  numMaxUdbs    ;    /*max number of UDBs*/
    GT_U32  udbsInKey     ;    /* number of UDBs in the key*/
    GT_U32  numBitsPerUdb ;    /*number of bits for field of :
                               The decimal UDB number in the global UDB pool
                               that is selected as UDB #n in this UDB key.*/
    GT_U32  startBitsAfterUdbs; /*bit index after the UDBs.*/
    GT_U32  numEntries;/* num entries in UDB select table */
    GT_U32  maxUdbReplace;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    CPSS_NULL_PTR_CHECK_MAC(udbSelectPtr);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
        devNum, portGroupsBmp, portGroupId);

    cpssOsMemSet(udbSelectPtr, 0, sizeof(*udbSelectPtr));

    maxUdbReplace = PRV_CPSS_SIP_6_10_CHECK_MAC(devNum) ? CPSS_DXCH_PCL_INGRESS_UDB_REPLACE_MAX_CNS : PRV_CPSS_DXCH_PCL_INGRESS_UDB_REPLACE_MAX_SIP_5_CNS;

    rc = sip5PclUDBSelectEntryIndexGet(
        devNum, ruleFormat, packetType, lookupNum,
        &index, &egress, &tableType , &replacement_tableType);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* get info about the format of the entry */
    sip5UdbSelectionEntryFormatInfoGet(devNum,egress,
            &numMaxUdbs,&numBitsPerUdb,
            &startBitsAfterUdbs);

    /* the table hold 16 entries per 'udb size' so we divide the index by 16 */
    /* then we multiple it by 10 , to know the 'udb size' */
    udbsInKey = ((index / 16)+1) * 10;/*10/20/...60*/

    if(udbsInKey > numMaxUdbs)
    {
        /* non-sip5_20 than not supports 50 UDBs on '60 bytes' key */
        udbsInKey = numMaxUdbs;
    }

    rc = prvCpssDxChTableNumEntriesGet(devNum,tableType,&numEntries);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(numEntries)
    {
        rc = prvCpssDxChPortGroupReadTableEntry(
            devNum, portGroupId, tableType,
            index, entryBuf);
        if (rc != GT_OK)
        {
            return rc;
        }

        for (i = 0; (i < udbsInKey); i++)
        {
            offset = (numBitsPerUdb * i);
            U32_GET_FIELD_IN_ENTRY_MAC(
                entryBuf, offset, numBitsPerUdb/*length*/, udbSelectPtr->udbSelectArr[i]);
        }
    }
    else /* the UDB select not supported : the HW is doing 1:1 mapping */
    {
        for (i = 0; (i < udbsInKey); i++)
        {
            udbSelectPtr->udbSelectArr[i] = i;
        }
    }

    if (egress == GT_FALSE)
    {
        /* ingress */
        if(PRV_CPSS_SIP_6_30_CHECK_MAC(devNum))
        {
            rc = prvCpssDxChPortGroupReadTableEntry(
                devNum, portGroupId, replacement_tableType,
                index, entryBuf);
            if (rc != GT_OK)
            {
                return rc;
            }
            startBitsAfterUdbs = 0;

            /* Set Key Byte Replacement mode */
            U32_GET_FIELD_IN_ENTRY_MAC(entryBuf, 19, 2, data)
            switch(data)
            {
                case 0:
                    udbSelectPtr->keyByteReplacementMode = CPSS_DXCH_PCL_KEY_BYTE_REPLACEMENT_MODE_HASH_AND_QOS_E;
                    break;
                case 1:
                    udbSelectPtr->keyByteReplacementMode = CPSS_DXCH_PCL_KEY_BYTE_REPLACEMENT_MODE_SRC_DST_EPG_E;
                    break;
                case 2:
                    udbSelectPtr->keyByteReplacementMode = CPSS_DXCH_PCL_KEY_BYTE_REPLACEMENT_MODE_SRC_ID_11_0_COPY_RES_12_1_E;
                    break;
                case 3:
                    udbSelectPtr->keyByteReplacementMode = CPSS_DXCH_PCL_KEY_BYTE_REPLACEMENT_MODE_SRC_ID_3_0_COPY_RES_19_0_E;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }

        for (i = 0; (i < maxUdbReplace); i++)
        {
            offset = (startBitsAfterUdbs + i);
            U32_GET_FIELD_IN_ENTRY_MAC(
                entryBuf, offset, 1/*length*/, data);
            udbSelectPtr->ingrUdbReplaceArr[i] = BIT2BOOL_MAC(data);
        }
    }
    else
    {
        /* egress */
        if(PRV_CPSS_SIP_6_30_CHECK_MAC(devNum))
        {
            rc = prvCpssHwPpGetRegField(devNum,
                PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCL_UDB_replacement[index/16],
                (index%16)*2/*offset*/, 2/*Length*/, entryBuf);
            if (rc != GT_OK)
            {
                return rc;
            }
            startBitsAfterUdbs = 0;
        }

        offset = startBitsAfterUdbs;
        U32_GET_FIELD_IN_ENTRY_MAC(
            entryBuf, offset, 1/*length*/, data);
        udbSelectPtr->egrUdb01Replace = BIT2BOOL_MAC(data);

        offset = startBitsAfterUdbs + 1;
        U32_GET_FIELD_IN_ENTRY_MAC(
            entryBuf, offset, 1/*length*/, data);
        udbSelectPtr->egrUdbBit15Replace = BIT2BOOL_MAC(data);
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChPclUserDefinedBytesSelectGet function
* @endinternal
*
* @brief   Get the User Defined Byte (UDB) Selection Configuration.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
*                                      Valid only UDB only key formats.
*                                      The parameter used also to determinate Ingress or Egress.
*                                      Relevant values are:
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
* @param[in] packetType               - packet Type
* @param[in] lookupNum                - Lookup number. Ignored for egress.
*
* @param[out] udbSelectPtr             - (pointer to) structure with UDB Selection configuration.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_STATE             - on unsupported HW state
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclUserDefinedBytesSelectGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum,
    OUT CPSS_DXCH_PCL_UDB_SELECT_STC         *udbSelectPtr
)
{
    return prvCpssDxChPclPortGroupUserDefinedBytesSelectGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        ruleFormat, packetType, lookupNum, udbSelectPtr);
}

/**
* @internal cpssDxChPclUserDefinedBytesSelectGet function
* @endinternal
*
* @brief   Get the User Defined Byte (UDB) Selection Configuration.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
*                                      Valid only UDB only key formats.
*                                      The parameter used also to determinate Ingress or Egress.
*                                      Relevant values are:
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E
*                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E
*                                      (APPLICABLE DEVICES: AC5P; AC5X; Harrier; Ironman)
* @param[in] packetType               - packet Type
* @param[in] lookupNum                - Lookup number. Ignored for egress.
*
* @param[out] udbSelectPtr             - (pointer to) structure with UDB Selection configuration.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_STATE             - on unsupported HW state
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclUserDefinedBytesSelectGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum,
    OUT CPSS_DXCH_PCL_UDB_SELECT_STC         *udbSelectPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclUserDefinedBytesSelectGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ruleFormat, packetType, lookupNum, udbSelectPtr));

    rc = internal_cpssDxChPclUserDefinedBytesSelectGet(devNum, ruleFormat, packetType, lookupNum, udbSelectPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ruleFormat, packetType, lookupNum, udbSelectPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet function
* @endinternal
*
* @brief   Set the User Defined Byte (UDB) Values bitmap expansion mode.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] udbValuesBmpMode         - UDB Values bitmap mode (see enum description)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_ENT   udbValuesBmpMode
)
{
    GT_STATUS   rc;          /* return code       */
    GT_U32      regAddr;     /* register address  */
    GT_U32      hwValue;     /* data in HW format */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_BOBCAT3_E |
          CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_ALDRIN2_E);

    switch (udbValuesBmpMode)
    {
        case CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_8_BYTES_E:
            hwValue = 2;
            break;
        case CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_16_BYTES_E:
            hwValue = 1;
            break;
        case CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_32_BYTES_E:
            hwValue = 0;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).ingrPolicyGlobalConfig;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 18, 2, hwValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }
    return rc;
}

/**
* @internal cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet function
* @endinternal
*
* @brief   Set the User Defined Byte (UDB) Values bitmap expansion mode.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in] devNum                   - device number
* @param[in] udbValuesBmpMode         - UDB Values bitmap mode (see enum description)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_ENT   udbValuesBmpMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, udbValuesBmpMode));

    rc = internal_cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet(devNum, udbValuesBmpMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, udbValuesBmpMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet function
* @endinternal
*
* @brief   Get the User Defined Byte (UDB) Values bitmap expansion mode.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in]  devNum                   - device number
* @param[out] udbValuesBmpModePtr      - (pointer to)UDB Values bitmap mode (see enum description)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_STATE             - on wrong HW value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet
(
    IN  GT_U8                                      devNum,
    OUT CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_ENT   *udbValuesBmpModePtr
)
{
    GT_STATUS   rc;          /* return code       */
    GT_U32      regAddr;     /* register address  */
    GT_U32      hwValue;     /* data in HW format */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_BOBCAT3_E |
          CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_ALDRIN2_E);
    CPSS_NULL_PTR_CHECK_MAC(udbValuesBmpModePtr);

    regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).ingrPolicyGlobalConfig;
    rc = prvCpssHwPpGetRegField(devNum, regAddr, 18, 2, &hwValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }
    switch (hwValue)
    {
        case 2:
            *udbValuesBmpModePtr = CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_8_BYTES_E;
            break;
        case 1:
            *udbValuesBmpModePtr = CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_16_BYTES_E;
            break;
        case 0:
            *udbValuesBmpModePtr = CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_32_BYTES_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }
    return GT_OK;
}

/**
* @internal cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet function
* @endinternal
*
* @brief   Get the User Defined Byte (UDB) Values bitmap expansion mode.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
*
* @param[in]  devNum                   - device number
* @param[out] udbValuesBmpModePtr      - (pointer to)UDB Values bitmap mode (see enum description)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameter
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_BAD_STATE             - on wrong HW value
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet
(
    IN  GT_U8                                      devNum,
    OUT CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_ENT   *udbValuesBmpModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, udbValuesBmpModePtr));

    rc = internal_cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet(devNum, udbValuesBmpModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, udbValuesBmpModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet function
* @endinternal
*
* @brief   Sets Egress Policy VID and UP key fields content mode
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] vidUpMode                - VID and UP key fields content mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet
(
    IN  GT_U8                                      devNum,
    IN  GT_PORT_GROUPS_BMP                         portGroupsBmp,
    IN  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   vidUpMode
)
{
    GT_STATUS rc;            /* return code                         */
    GT_U32    portGroupId;   /*the port group Id                    */
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig;

    switch (vidUpMode)
    {
        case CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E:
            hwValue = 0;
            break;
        case CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG1_E:
            hwValue = 1;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        rc = prvCpssHwPpPortGroupSetRegField(
            devNum, portGroupId, regAddr, 21, 1, hwValue);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet function
* @endinternal
*
* @brief   Sets Egress Policy VID and UP key fields content mode
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] vidUpMode                - VID and UP key fields content mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet
(
    IN  GT_U8                                      devNum,
    IN  GT_PORT_GROUPS_BMP                         portGroupsBmp,
    IN  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   vidUpMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, vidUpMode));

    rc = internal_cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet(devNum, portGroupsBmp, vidUpMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, vidUpMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet function
* @endinternal
*
* @brief   Gets Egress Policy VID and UP key fields content mode
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
*
* @param[out] vidUpModePtr             - (pointer to) VID and UP key fields
*                                      calculation mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet
(
    IN   GT_U8                                      devNum,
    IN   GT_PORT_GROUPS_BMP                         portGroupsBmp,
    OUT  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   *vidUpModePtr
)
{
    GT_STATUS rc;            /* return code                         */
    GT_U32    portGroupId;   /*the port group Id                    */
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(vidUpModePtr);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
        devNum, portGroupsBmp, portGroupId);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig;

    rc = prvCpssHwPpPortGroupGetRegField(
        devNum, portGroupId, regAddr, 21, 1, &hwValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    *vidUpModePtr =
        (hwValue == 0)
           ? CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E
           : CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG1_E;

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet function
* @endinternal
*
* @brief   Gets Egress Policy VID and UP key fields content mode
*
* @note   APPLICABLE DEVICES:      Lion2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Bobcat2; Caelum; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; Aldrin; AC3X.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
*
* @param[out] vidUpModePtr             - (pointer to) VID and UP key fields
*                                      calculation mode
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet
(
    IN   GT_U8                                      devNum,
    IN   GT_PORT_GROUPS_BMP                         portGroupsBmp,
    OUT  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   *vidUpModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, vidUpModePtr));

    rc = internal_cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet(devNum, portGroupsBmp, vidUpModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, vidUpModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChPclLookupCfgPortListEnableRegAddrAndPosGet function
* @endinternal
*
* @brief   The function gets register address and bit position
*         for enable bit of using port-list in search keys.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] lookupNum                - lookup number: 0,1
* @param[in] subLookupNum             - Sub lookup Number - for ingress CPSS_PCL_LOOKUP_0_E
*                                      means 0: lookup0_0, 1: lookup0_1,
*                                      for other cases not relevant.
*
* @param[out] regAddrPtr               - (pointer to) register address.
* @param[out] bitPosPtr                - (pointer to) bit position.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS prvCpssDxChPclLookupCfgPortListEnableRegAddrAndPosGet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    OUT GT_U32                        *regAddrPtr,
    OUT GT_U32                        *bitPosPtr
)
{
    GT_STATUS rc; /* return code */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E);

    rc = prvCpssDxChPclLookupParamCheck(
        devNum, direction, lookupNum, subLookupNum);
    if (rc != GT_OK)
    {
        return rc;
    }

    if (direction == CPSS_PCL_DIRECTION_INGRESS_E)
    {
        /* ingress PCL */
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            *regAddrPtr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineConfig;
        }
        else
        if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        {
            *regAddrPtr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ipclMetalFix;
            switch (lookupNum)
            {
                case CPSS_PCL_LOOKUP_0_E:
                    *bitPosPtr = ((subLookupNum == 0) ? 28 : 27);
                    break;
                case CPSS_PCL_LOOKUP_1_E:
                    *bitPosPtr = 26;
                    break;
                case CPSS_PCL_LOOKUP_0_0_E:
                    *bitPosPtr = 28;
                    break;
                case CPSS_PCL_LOOKUP_0_1_E:
                    *bitPosPtr = 27;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            return GT_OK;
        }
        else
        {
            *regAddrPtr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclEngineConfig;
        }

        switch (lookupNum)
        {
            case CPSS_PCL_LOOKUP_0_E:
                *bitPosPtr = ((subLookupNum == 0) ? 14 : 15);
                break;
            case CPSS_PCL_LOOKUP_1_E:
                if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                *bitPosPtr = 16;
                break;
            case CPSS_PCL_LOOKUP_0_0_E:
                *bitPosPtr = 14;
                break;
            case CPSS_PCL_LOOKUP_0_1_E:
                *bitPosPtr = 15;
                break;
            default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
        {
            (*bitPosPtr)++;
        }
    }
    else
    {
        /* egress PCL */
        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
        {
            *regAddrPtr =
                PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egrPolicyGlobalConfig;
            *bitPosPtr = 5;
        }
        else
        if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
        }
        else
        {
            *regAddrPtr =
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.epclGlobalConfig;
            *bitPosPtr = 27;
        }
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChPclPortGroupLookupCfgPortListEnableSet function
* @endinternal
*
* @brief   The function enables/disables using port-list in search keys.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] lookupNum                - lookup number: 0,1
* @param[in] subLookupNum             - Sub lookup Number - for ingress CPSS_PCL_LOOKUP_0_E
*                                      means 0: lookup0_0, 1: lookup0_1,
*                                      for other cases not relevant.
* @param[in] enable                   - GT_TRUE  -  port-list in search key
*                                      GT_FALSE - disable port-list in search key
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclPortGroupLookupCfgPortListEnableSet
(
    IN  GT_U8                         devNum,
    IN  GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    IN  GT_BOOL                       enable
)
{
    GT_STATUS    rc;            /* returned code               */
    GT_U32       data;          /* register data               */
    GT_U32       regAddr;       /* register address            */
    GT_U32       bitPos;        /* bit position                */
    GT_U32       portGroupId;   /*the port group Id            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E);

    rc = prvCpssDxChPclLookupCfgPortListEnableRegAddrAndPosGet(
        devNum, direction, lookupNum, subLookupNum,
        &regAddr, &bitPos);
    if (rc != GT_OK)
    {
        return rc;
    }

    data = (enable == GT_FALSE) ? 0 : 1;

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        rc = prvCpssHwPpPortGroupSetRegField(
            devNum, portGroupId, regAddr, bitPos, 1, data);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupLookupCfgPortListEnableSet function
* @endinternal
*
* @brief   The function enables/disables using port-list in search keys.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] lookupNum                - lookup number: 0,1
* @param[in] subLookupNum             - Sub lookup Number - for ingress CPSS_PCL_LOOKUP_0_E
*                                      means 0: lookup0_0, 1: lookup0_1,
*                                      for other cases not relevant.
* @param[in] enable                   - GT_TRUE  -  port-list in search key
*                                      GT_FALSE - disable port-list in search key
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclPortGroupLookupCfgPortListEnableSet
(
    IN  GT_U8                         devNum,
    IN  GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    IN  GT_BOOL                       enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupLookupCfgPortListEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, direction, lookupNum, subLookupNum, enable));

    rc = internal_cpssDxChPclPortGroupLookupCfgPortListEnableSet(devNum, portGroupsBmp, direction, lookupNum, subLookupNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, direction, lookupNum, subLookupNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupLookupCfgPortListEnableGet function
* @endinternal
*
* @brief   The function gets enable/disable state of
*         using port-list in search keys.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] lookupNum                - lookup number: 0,1
* @param[in] subLookupNum             - Sub lookup Number - for ingress CPSS_PCL_LOOKUP_0_E
*                                      means 0: lookup0_0, 1: lookup0_1,
*                                      for other cases not relevant.
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE  - enable port-list in search key
*                                      GT_FALSE - disable port-list in search key
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclPortGroupLookupCfgPortListEnableGet
(
    IN  GT_U8                         devNum,
    IN  GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    OUT GT_BOOL                       *enablePtr
)
{
    GT_STATUS    rc;            /* returned code               */
    GT_U32       data;          /* register data               */
    GT_U32       regAddr;       /* register address            */
    GT_U32       bitPos;        /* bit position                */
    GT_U32       portGroupId;   /*the port group Id            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
        devNum, portGroupsBmp, portGroupId);

    rc = prvCpssDxChPclLookupCfgPortListEnableRegAddrAndPosGet(
        devNum, direction, lookupNum, subLookupNum,
        &regAddr, &bitPos);
    if (rc != GT_OK)
    {
        return rc;
    }

    rc = prvCpssHwPpPortGroupGetRegField(
        devNum, portGroupId, regAddr, bitPos, 1, &data);
    if (rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = ((data != 0) ? GT_TRUE : GT_FALSE);

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupLookupCfgPortListEnableGet function
* @endinternal
*
* @brief   The function gets enable/disable state of
*         using port-list in search keys.
*
* @note   APPLICABLE DEVICES:      Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] direction                - Policy Engine direction, Ingress or Egress
* @param[in] lookupNum                - lookup number: 0,1
* @param[in] subLookupNum             - Sub lookup Number - for ingress CPSS_PCL_LOOKUP_0_E
*                                      means 0: lookup0_0, 1: lookup0_1,
*                                      for other cases not relevant.
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE  - enable port-list in search key
*                                      GT_FALSE - disable port-list in search key
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclPortGroupLookupCfgPortListEnableGet
(
    IN  GT_U8                         devNum,
    IN  GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    OUT GT_BOOL                       *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupLookupCfgPortListEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, direction, lookupNum, subLookupNum, enablePtr));

    rc = internal_cpssDxChPclPortGroupLookupCfgPortListEnableGet(devNum, portGroupsBmp, direction, lookupNum, subLookupNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, direction, lookupNum, subLookupNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclL3L4ParsingOverMplsEnableSet function
* @endinternal
*
* @brief   If enabled, non-Tunnel-Terminated IPvx over MPLS packets are treated
*         by Ingress PCL as IP packets for key selection and UDB usage.
*         If disabled, non-Tunnel-Terminated IPvx over MPLS packets are treated
*         by Ingress PCL as MPLS packets for key selection and UDB usage.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclL3L4ParsingOverMplsEnableSet
(
    IN  GT_U8                              devNum,
    IN  GT_BOOL                            enable
)
{
    GT_U32       data;      /* register data               */
    GT_U32       regAddr;   /* register address            */
    GT_U32       bitNum;    /* bit number                  */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    data = (enable == GT_FALSE) ? 0 : 1;

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        if(PRV_CPSS_PP_MAC(devNum)->isGmDevice)
        {
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
            {
                /* the GM not implemented the functionality behind this field , so we not allow to set it */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);
            }
        }

        regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).TTIUnitGlobalConfigs.TTIUnitGlobalConfigExt;
        bitNum = 27;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiUnitConfig;
        bitNum = 23;
    }

    return prvCpssHwPpSetRegField(devNum, regAddr, bitNum, 1, data);
}

/**
* @internal cpssDxChPclL3L4ParsingOverMplsEnableSet function
* @endinternal
*
* @brief   If enabled, non-Tunnel-Terminated IPvx over MPLS packets are treated
*         by Ingress PCL as IP packets for key selection and UDB usage.
*         If disabled, non-Tunnel-Terminated IPvx over MPLS packets are treated
*         by Ingress PCL as MPLS packets for key selection and UDB usage.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclL3L4ParsingOverMplsEnableSet
(
    IN  GT_U8                              devNum,
    IN  GT_BOOL                            enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclL3L4ParsingOverMplsEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPclL3L4ParsingOverMplsEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPclL3L4ParsingOverMplsEnableGet function
* @endinternal
*
* @brief   If enabled, non-Tunnel-Terminated IPvx over MPLS packets are treated
*         by Ingress PCL as IP packets for key selection and UDB usage.
*         If disabled, non-Tunnel-Terminated IPvx over MPLS packets are treated
*         by Ingress PCL as MPLS packets for key selection and UDB usage.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to)GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclL3L4ParsingOverMplsEnableGet
(
    IN  GT_U8                              devNum,
    OUT GT_BOOL                            *enablePtr
)
{
    GT_U32       data;      /* register data               */
    GT_STATUS    rc;        /* return code                 */
    GT_U32       regAddr;   /* register address            */
    GT_U32       bitNum;    /* bit number                  */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).TTIUnitGlobalConfigs.TTIUnitGlobalConfigExt;
        bitNum = 27;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiUnitConfig;
        bitNum = 23;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, bitNum, 1, &data);
    if (rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = (data == 0) ? GT_FALSE : GT_TRUE;

    return GT_OK;
}

/**
* @internal cpssDxChPclL3L4ParsingOverMplsEnableGet function
* @endinternal
*
* @brief   If enabled, non-Tunnel-Terminated IPvx over MPLS packets are treated
*         by Ingress PCL as IP packets for key selection and UDB usage.
*         If disabled, non-Tunnel-Terminated IPvx over MPLS packets are treated
*         by Ingress PCL as MPLS packets for key selection and UDB usage.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to)GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclL3L4ParsingOverMplsEnableGet
(
    IN  GT_U8                              devNum,
    OUT GT_BOOL                            *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclL3L4ParsingOverMplsEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPclL3L4ParsingOverMplsEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal prvCpssDxChPclOverrideUDBCfgGet function
* @endinternal
*
* @brief   The function gets the configuration elements
*         of enable status of overriding the
*         UDB configuration for specific UDB in specific key format
*         where it supported by HW.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
* @param[in] udbOverrideType          - The type of the UDB configuration overriding.
* @param[in] enable                   - GT_TRUE - enable, GT_FALSE - disable
*
* @param[out] regAddrPtr               - (pointer to) register address
* @param[out] maskPtr                  - (pointer to) mask of configuration
* @param[out] valuePtr                 - (pointer to) value of configuration
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS prvCpssDxChPclOverrideUDBCfgGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType,
    IN  GT_BOOL                              enable,
    OUT GT_U32                               *regAddrPtr,
    OUT GT_U32                               *maskPtr,
    OUT GT_U32                               *valuePtr
)
{
    GT_BOOL valueWasSet = GT_FALSE;/*indication that (*valuePtr) was set */

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        if(ruleFormat == CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,
                "CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E not supported by the device \n");
        }
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
    {
        /* this device not supports those 6 keys */
        switch (ruleFormat)
        {
            case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E:
            case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E:
            case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E:
            case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E:
            case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E:
            case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            default:
                break;
        }
    }

    switch (udbOverrideType)
    {
        case CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E:
            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                *regAddrPtr =
                    PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineUserDefinedBytesConfig;
            }
            else
            {
                *regAddrPtr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclUDBConfig;
            }

            switch (ruleFormat)
            {
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E:
                    *maskPtr = 1;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E:
                    *maskPtr = (1 << 2);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E:
                    *maskPtr = (1 << 4);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E:
                    *maskPtr = (1 << 8);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E:
                    *maskPtr = (1 << 10);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E:
                    *maskPtr = (1 << 12);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E:
                    *maskPtr = (1 << 6);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E:
                    *maskPtr = (1 << 14);
                    break;

                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E :
                    *maskPtr = (1 << 20);
                    break;
                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E :
                    *maskPtr = (1 << 16);
                    break;
                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E :
                    *maskPtr = (1 << 18);
                    break;
                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E :
                    *maskPtr = (1 << 22);
                    break;


                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;
        case CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E:
            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                *regAddrPtr =
                    PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineUserDefinedBytesConfig;
            }
            else
            {
                *regAddrPtr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclUDBConfig;
            }
            switch (ruleFormat)
            {
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E:
                    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum)
                        == GT_FALSE)
                    {
                        *maskPtr = (1 << 1);
                    }
                    else
                    {
                        /* eArch device */
                        *maskPtr = (3 << 27);/* 2 bits */
                        *valuePtr = 1 << 27; /* value 1 */
                        valueWasSet = GT_TRUE;
                    }
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E:
                    *maskPtr = (1 << 3);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E:
                    *maskPtr = (1 << 5);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E:
                    *maskPtr = (1 << 9);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E:
                    *maskPtr = (1 << 11);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E:
                    *maskPtr = (1 << 13);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E:
                    *maskPtr = (1 << 7);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E:
                    *maskPtr = (1 << 15);
                    break;

                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E :
                    *maskPtr = (1 << 21);
                    break;
                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E :
                    *maskPtr = (1 << 17);
                    break;
                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E :
                    *maskPtr = (1 << 19);
                    break;
                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E :
                    *maskPtr = (1 << 23);
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;
        case CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_QOS_PROFILE_E:
            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                *regAddrPtr =
                    PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineUserDefinedBytesConfig;
            }
            else
            {
                *regAddrPtr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclUDBConfig;
            }
            switch (ruleFormat)
            {
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E:
                    *maskPtr = (1 << 24);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E:
                    *maskPtr = (1 << 25);
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;
        case CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TRUNK_HASH_E:
            if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
            {
                *regAddrPtr =
                    PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineUserDefinedBytesExtConfig;
            }
            else
            {
                *regAddrPtr =
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclEngineExtUdbConfig;
            }

            switch (ruleFormat)
            {
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E:
                    *maskPtr = 1;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E:
                    *maskPtr = (1 << 2);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E:
                    *maskPtr = (1 << 4);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E:
                    *maskPtr = (1 << 5);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E:
                    *maskPtr = (1 << 6);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E:
                    *maskPtr = (1 << 3);
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E:
                    *maskPtr = (1 << 7);
                    break;

                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E :
                    *maskPtr = (1 << 10);
                    break;
                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E  :
                    *maskPtr = (1 << 8);
                    break;
                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E :
                    *maskPtr = (1 << 9);
                    break;
                case     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E :
                    *maskPtr = (1 << 11);
                    break;

                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;
        case CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TAG1_INFO_E:
            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum)
                == GT_FALSE)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            *regAddrPtr =
                PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineUserDefinedBytesConfig;
            switch (ruleFormat)
            {
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E:
                    *maskPtr = 3 << 27;    /* 2 bits */
                    *valuePtr = 2 << 27;   /* value 2 */
                    valueWasSet = GT_TRUE;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;
        case CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MODE_E:
             if (PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC(devNum)
                  == GT_FALSE)
             {
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
             }
            *regAddrPtr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.control;
            /* ruleFormat parameter ignored */
            *maskPtr = (1 << 16);
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(enable == GT_FALSE)
    {
        *valuePtr = 0;
    }
    else
    if(enable == GT_TRUE && valueWasSet == GT_FALSE)
    {
        *valuePtr = *maskPtr;
    }

    if((*regAddrPtr) == PRV_CPSS_SW_PTR_ENTRY_UNUSED)
    {
        /* the chosen register is not supported by this device.
            meaning that the required type is not supported by this device .
        */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal internal_cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet function
* @endinternal
*
* @brief   The function enables or disables overriding of the
*         UDB content for specific UDB in specific key format
*         where it supported by HW.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] ruleFormat               - rule format
* @param[in] udbOverrideType          - The type of the UDB configuration overriding.
* @param[in] enable                   - GT_TRUE -  overriding of UDB content
*                                      by udbOverrideType.
*                                      GT_FALSE - disable overriding of UDB content
*                                      by udbOverrideType, UDB configuration is used.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet
(
    IN  GT_U8                                devNum,
    IN  GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType,
    IN  GT_BOOL                              enable
)
{
    GT_STATUS    rc;          /* return code                 */
    GT_U32       regAddr;     /* register address            */
    GT_U32       mask;        /* register mask               */
    GT_U32       value;       /* register value              */
    GT_U32       portGroupId; /* port Group Id               */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if((CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E == ruleFormat && !PRV_CPSS_SIP_6_10_CHECK_MAC(devNum)) ||
       (CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E == ruleFormat && !PRV_CPSS_SIP_6_10_CHECK_MAC(devNum)))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssDxChPclOverrideUDBCfgGet(
        devNum, ruleFormat, udbOverrideType, enable,
        &regAddr, &mask, &value);
    if (rc != GT_OK)
    {
        return rc;
    }

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        rc = prvCpssHwPpPortGroupWriteRegBitMask(
            devNum, portGroupId, regAddr, mask, value);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet function
* @endinternal
*
* @brief   The function enables or disables overriding of the
*         UDB content for specific UDB in specific key format
*         where it supported by HW.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] ruleFormat               - rule format
* @param[in] udbOverrideType          - The type of the UDB configuration overriding.
* @param[in] enable                   - GT_TRUE -  overriding of UDB content
*                                      by udbOverrideType.
*                                      GT_FALSE - disable overriding of UDB content
*                                      by udbOverrideType, UDB configuration is used.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet
(
    IN  GT_U8                                devNum,
    IN  GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType,
    IN  GT_BOOL                              enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, ruleFormat, udbOverrideType, enable));

    rc = internal_cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet(devNum, portGroupsBmp, ruleFormat, udbOverrideType, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, ruleFormat, udbOverrideType, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet function
* @endinternal
*
* @brief   The function get status (enabled or disabled) of the
*         overriding of the UDB content for specific UDB
*         in specific key format where it supported by HW.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] ruleFormat               - rule format
* @param[in] udbOverrideType          - The type of the UDB configuration overriding.
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE - enable overriding of UDB content
*                                      by udbOverrideType.
*                                      GT_FALSE - disable overriding of UDB content
*                                      by udbOverrideType, UDB content may be overriden
*                                      by content of another udbOverrideType.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet
(
    IN  GT_U8                                devNum,
    IN  GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType,
    OUT GT_BOOL                              *enablePtr
)
{
    GT_STATUS    rc;          /* return code                 */
    GT_U32       regAddr;     /* register address            */
    GT_U32       mask;        /* register mask               */
    GT_U32       pattern;     /* register value pattern      */
    GT_U32       value;       /* register value              */
    GT_U32       portGroupId; /* port Group Id               */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(
        devNum, portGroupsBmp, portGroupId);

    rc = prvCpssDxChPclOverrideUDBCfgGet(
        devNum, ruleFormat, udbOverrideType, GT_TRUE /*enable*/,
        &regAddr, &mask, &pattern);
    if (rc != GT_OK)
    {
        return rc;
    }

    rc = prvCpssHwPpPortGroupReadRegBitMask(
        devNum, portGroupId, regAddr, mask, &value);
    if (rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = (value == pattern) ? GT_TRUE : GT_FALSE;

    return GT_OK;
}

/**
* @internal cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet function
* @endinternal
*
* @brief   The function get status (enabled or disabled) of the
*         overriding of the UDB content for specific UDB
*         in specific key format where it supported by HW.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*                                      - read only from first active port group of the bitmap.
* @param[in] ruleFormat               - rule format
* @param[in] udbOverrideType          - The type of the UDB configuration overriding.
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE - enable overriding of UDB content
*                                      by udbOverrideType.
*                                      GT_FALSE - disable overriding of UDB content
*                                      by udbOverrideType, UDB content may be overriden
*                                      by content of another udbOverrideType.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet
(
    IN  GT_U8                                devNum,
    IN  GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType,
    OUT GT_BOOL                              *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, ruleFormat, udbOverrideType, enablePtr));

    rc = internal_cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet(devNum, portGroupsBmp, ruleFormat, udbOverrideType, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, ruleFormat, udbOverrideType, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOverrideUserDefinedBytesEnableSet function
* @endinternal
*
* @brief   The function enables or disables overriding of the
*         UDB content for specific UDB in specific key format
*         where it supported by HW.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
* @param[in] udbOverrideType          - The type of the UDB configuration overriding.
* @param[in] enable                   - GT_TRUE -  overriding of UDB content
*                                      by udbOverrideType.
*                                      GT_FALSE - disable overriding of UDB content
*                                      by udbOverrideType, UDB configuration is used.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclOverrideUserDefinedBytesEnableSet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType,
    IN  GT_BOOL                              enable
)
{
    return cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        ruleFormat, udbOverrideType, enable);
}

/**
* @internal cpssDxChPclOverrideUserDefinedBytesEnableSet function
* @endinternal
*
* @brief   The function enables or disables overriding of the
*         UDB content for specific UDB in specific key format
*         where it supported by HW.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
* @param[in] udbOverrideType          - The type of the UDB configuration overriding.
* @param[in] enable                   - GT_TRUE -  overriding of UDB content
*                                      by udbOverrideType.
*                                      GT_FALSE - disable overriding of UDB content
*                                      by udbOverrideType, UDB configuration is used.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclOverrideUserDefinedBytesEnableSet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType,
    IN  GT_BOOL                              enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOverrideUserDefinedBytesEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ruleFormat, udbOverrideType, enable));

    rc = internal_cpssDxChPclOverrideUserDefinedBytesEnableSet(devNum, ruleFormat, udbOverrideType, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ruleFormat, udbOverrideType, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOverrideUserDefinedBytesEnableGet function
* @endinternal
*
* @brief   The function get status (enabled or disabled) of the
*         overriding of the UDB content for specific UDB
*         in specific key format where it supported by HW.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
* @param[in] udbOverrideType          - The type of the UDB configuration overriding.
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE - enable overriding of UDB content
*                                      by udbOverrideType.
*                                      GT_FALSE - disable overriding of UDB content
*                                      by udbOverrideType, UDB content may be overriden
*                                      by content of another udbOverrideType.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclOverrideUserDefinedBytesEnableGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType,
    OUT GT_BOOL                              *enablePtr
)
{
    return cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet(
        devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
        ruleFormat, udbOverrideType, enablePtr);
}

/**
* @internal cpssDxChPclOverrideUserDefinedBytesEnableGet function
* @endinternal
*
* @brief   The function get status (enabled or disabled) of the
*         overriding of the UDB content for specific UDB
*         in specific key format where it supported by HW.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] ruleFormat               - rule format
* @param[in] udbOverrideType          - The type of the UDB configuration overriding.
*
* @param[out] enablePtr                - (pointer to)
*                                      GT_TRUE - enable overriding of UDB content
*                                      by udbOverrideType.
*                                      GT_FALSE - disable overriding of UDB content
*                                      by udbOverrideType, UDB content may be overriden
*                                      by content of another udbOverrideType.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclOverrideUserDefinedBytesEnableGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType,
    OUT GT_BOOL                              *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOverrideUserDefinedBytesEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ruleFormat, udbOverrideType, enablePtr));

    rc = internal_cpssDxChPclOverrideUserDefinedBytesEnableGet(devNum, ruleFormat, udbOverrideType, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ruleFormat, udbOverrideType, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclLookup0ForRoutedPacketsEnableSet function
* @endinternal
*
* @brief   Enables/disables PCL lookup0 for routed packets.
*         For not routed packets lookup0 always enable.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] enable                   - GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS internal_cpssDxChPclLookup0ForRoutedPacketsEnableSet
(
    IN  GT_U8                              devNum,
    IN  GT_PORT_NUM                        portNum,
    IN  GT_BOOL                            enable
)
{
    GT_STATUS   rc = GT_OK;
    GT_U32      hwData;    /* data to write to HW                     */
    GT_U32      wordNum;   /* number of word in the entry             */
    GT_U32      bitNum;    /* number of bit in the entry              */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    /* Convert boolean value to the HW format */
    hwData = (enable == GT_TRUE) ? 0 : 1;

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);
        /* write value to post-tti-lookup-ingress-eport table */
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                            CPSS_DXCH_SIP5_TABLE_POST_TTI_LOOKUP_INGRESS_EPORT_E,
                                            portNum,
                                            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                            SIP5_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_DIS_IPCL0_FOR_ROUTED_E, /* field name */
                                            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                            hwData);
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        /* bit 14 in word 0 (abs 14) */
         wordNum = 0;
         bitNum  = 14;

        /* Update port mode in the VLAN and QoS Configuration Entry */
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                             CPSS_DXCH_TABLE_PORT_VLAN_QOS_E,
                                             portNum,
                                             wordNum,
                                             bitNum,
                                             1, /* 1 bit */
                                             hwData);
    }
    return rc;
}

/**
* @internal cpssDxChPclLookup0ForRoutedPacketsEnableSet function
* @endinternal
*
* @brief   Enables/disables PCL lookup0 for routed packets.
*         For not routed packets lookup0 always enable.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
* @param[in] enable                   - GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
*/
GT_STATUS cpssDxChPclLookup0ForRoutedPacketsEnableSet
(
    IN  GT_U8                              devNum,
    IN  GT_PORT_NUM                        portNum,
    IN  GT_BOOL                            enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclLookup0ForRoutedPacketsEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enable));

    rc = internal_cpssDxChPclLookup0ForRoutedPacketsEnableSet(devNum, portNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclLookup0ForRoutedPacketsEnableGet function
* @endinternal
*
* @brief   Gets Enable/disable status of PCL lookup0 for routed packets.
*         For not routed packets lookup0 always enable.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*
* @param[out] enablePtr                - (pointer to)GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on null pointer
*/
static GT_STATUS internal_cpssDxChPclLookup0ForRoutedPacketsEnableGet
(
    IN  GT_U8                              devNum,
    IN  GT_PORT_NUM                        portNum,
    OUT GT_BOOL                            *enablePtr
)
{
    GT_U32      hwData;   /* data to write to HW                     */
    GT_STATUS   rc;       /* generic return status code              */
    GT_U32      wordNum;  /* number of word in the entry             */
    GT_U32      bitNum;   /* number of bit in the entry              */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);
        /* read from post-tti-lookup-ingress-eport table */
        rc = prvCpssDxChReadTableEntryField(devNum,
                                            CPSS_DXCH_SIP5_TABLE_POST_TTI_LOOKUP_INGRESS_EPORT_E,
                                            portNum,
                                            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                            SIP5_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_DIS_IPCL0_FOR_ROUTED_E, /* field name */
                                            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                            &hwData);
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        /* bit 14 in word 0 (abs 14) */
         wordNum = 0;
         bitNum  = 14;

        /* Read port mode from VLAN and QoS Configuration Entry */
        rc = prvCpssDxChReadTableEntryField(devNum,
                                            CPSS_DXCH_TABLE_PORT_VLAN_QOS_E,
                                            portNum,
                                            wordNum,
                                            bitNum,
                                            1,/* 1 bit */
                                            &hwData);
    }
    if (rc == GT_OK)
    {
        /* Convert gathered HW value to the SW format */
        *enablePtr = (hwData == 1) ? GT_FALSE : GT_TRUE;
    }

    return rc;
}

/**
* @internal cpssDxChPclLookup0ForRoutedPacketsEnableGet function
* @endinternal
*
* @brief   Gets Enable/disable status of PCL lookup0 for routed packets.
*         For not routed packets lookup0 always enable.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] portNum                  - port number
*
* @param[out] enablePtr                - (pointer to)GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on null pointer
*/
GT_STATUS cpssDxChPclLookup0ForRoutedPacketsEnableGet
(
    IN  GT_U8                              devNum,
    IN  GT_PORT_NUM                        portNum,
    OUT GT_BOOL                            *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclLookup0ForRoutedPacketsEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enablePtr));

    rc = internal_cpssDxChPclLookup0ForRoutedPacketsEnableGet(devNum, portNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclLookup1ForNotRoutedPacketsEnableSet function
* @endinternal
*
* @brief   Enables/disables PCL lookup1 for not routed packets.
*         For routed packets lookup1 always enable.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
*/
static GT_STATUS internal_cpssDxChPclLookup1ForNotRoutedPacketsEnableSet
(
    IN  GT_U8                              devNum,
    IN  GT_BOOL                            enable
)
{
    GT_U32       data;      /* register data               */
    GT_STATUS    rc;        /* return code                 */
    GT_U32       regAddr;   /* register address            */
    GT_U32       bitNum;    /* bit bumber                  */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);


    data = (enable == GT_TRUE) ? 0 : 1;

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineConfig;
        bitNum  = 8;
    }
    else
    {
        /* xCat3, Lion2 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclEngineConfig;
        bitNum  = 8;
    }

    rc = prvCpssHwPpSetRegField(
        devNum, regAddr, bitNum, 1, data);

    return rc;
}

/**
* @internal cpssDxChPclLookup1ForNotRoutedPacketsEnableSet function
* @endinternal
*
* @brief   Enables/disables PCL lookup1 for not routed packets.
*         For routed packets lookup1 always enable.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
*/
GT_STATUS cpssDxChPclLookup1ForNotRoutedPacketsEnableSet
(
    IN  GT_U8                              devNum,
    IN  GT_BOOL                            enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclLookup1ForNotRoutedPacketsEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPclLookup1ForNotRoutedPacketsEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclLookup1ForNotRoutedPacketsEnableGet function
* @endinternal
*
* @brief   Gets Enable/disable status of PCL lookup1 for not routed packets.
*         For routed packets lookup1 always enable.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to)GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on null pointer
*/
static GT_STATUS internal_cpssDxChPclLookup1ForNotRoutedPacketsEnableGet
(
    IN  GT_U8                              devNum,
    OUT GT_BOOL                            *enablePtr
)
{
    GT_U32       data;      /* register data               */
    GT_STATUS    rc;        /* return code                 */
    GT_U32       regAddr;   /* register address            */
    GT_U32       bitNum;    /* bit bumber                  */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineConfig;
        bitNum  = 8;
    }
    else
    {
        /* xCat3, Lion2 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclEngineConfig;
        bitNum  = 8;
    }

    rc = prvCpssHwPpGetRegField(
        devNum, regAddr, bitNum, 1, &data);
    if (rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = (data != 0) ? GT_FALSE : GT_TRUE;

    return GT_OK;
}

/**
* @internal cpssDxChPclLookup1ForNotRoutedPacketsEnableGet function
* @endinternal
*
* @brief   Gets Enable/disable status of PCL lookup1 for not routed packets.
*         For routed packets lookup1 always enable.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to)GT_TRUE - enable, GT_FALSE - disable
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PTR               - on null pointer
*/
GT_STATUS cpssDxChPclLookup1ForNotRoutedPacketsEnableGet
(
    IN  GT_U8                              devNum,
    OUT GT_BOOL                            *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclLookup1ForNotRoutedPacketsEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPclLookup1ForNotRoutedPacketsEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclIpMinOffsetSet function
* @endinternal
*
* @brief   Set the IP Minimum Offset parameter.
*         If packet is IPV4 fragment and has non zero offset
*         and it's offset less than IP Minimum Offset
*         the packet is counted as small offset.
*         The ipHeaderInfo field in PCL search key is set to be 3 i.e. "Ip Small Offset".
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] ipMinOffset              - IP Minimum Offset  parameter (APPLICABLE RANGES: 0..0x1FFF)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on out of range minIpOffset
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclIpMinOffsetSet
(
    IN  GT_U8                              devNum,
    IN  GT_U32                             ipMinOffset
)
{

    GT_U32    regAddr;     /* register address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if (ipMinOffset >= BIT_13)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    /*IP Minimum Offset*/
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).IPMinimumOffset;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ttiRegs.ipMinimumOffset;
    }

    return prvCpssHwPpSetRegField(
        devNum,
        regAddr,
        0, 13, ipMinOffset);
}

/**
* @internal cpssDxChPclIpMinOffsetSet function
* @endinternal
*
* @brief   Set the IP Minimum Offset parameter.
*         If packet is IPV4 fragment and has non zero offset
*         and it's offset less than IP Minimum Offset
*         the packet is counted as small offset.
*         The ipHeaderInfo field in PCL search key is set to be 3 i.e. "Ip Small Offset".
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] ipMinOffset              - IP Minimum Offset  parameter (APPLICABLE RANGES: 0..0x1FFF)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on out of range minIpOffset
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclIpMinOffsetSet
(
    IN  GT_U8                              devNum,
    IN  GT_U32                             ipMinOffset
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclIpMinOffsetSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ipMinOffset));

    rc = internal_cpssDxChPclIpMinOffsetSet(devNum, ipMinOffset);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ipMinOffset));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPclIpMinOffsetGet function
* @endinternal
*
* @brief   Get the IP Minimum Offset parameter.
*         If packet is IPV4 fragment and has non zero offset
*         and it's offset less than IP Minimum Offset
*         the packet is counted as small offset.
*         The ipHeaderInfo field in PCL search key is set to be 3 i.e. "Ip Small Offset".
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] ipMinOffsetPtr           - (pointer to)IP Minimum Offset  parameter
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on out of range minIpOffset
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclIpMinOffsetGet
(
    IN  GT_U8                              devNum,
    OUT GT_U32                             *ipMinOffsetPtr
)
{
    GT_U32    regAddr;     /* register address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(ipMinOffsetPtr);
    /*IP Minimum Offset*/
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).IPMinimumOffset;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ttiRegs.ipMinimumOffset;
    }

    return prvCpssHwPpGetRegField(
        devNum,
        regAddr,
        0, 13, ipMinOffsetPtr);
}

/**
* @internal cpssDxChPclIpMinOffsetGet function
* @endinternal
*
* @brief   Get the IP Minimum Offset parameter.
*         If packet is IPV4 fragment and has non zero offset
*         and it's offset less than IP Minimum Offset
*         the packet is counted as small offset.
*         The ipHeaderInfo field in PCL search key is set to be 3 i.e. "Ip Small Offset".
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] ipMinOffsetPtr           - (pointer to)IP Minimum Offset  parameter
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - on out of range minIpOffset
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclIpMinOffsetGet
(
    IN  GT_U8                              devNum,
    OUT GT_U32                             *ipMinOffsetPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclIpMinOffsetGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ipMinOffsetPtr));

    rc = internal_cpssDxChPclIpMinOffsetGet(devNum, ipMinOffsetPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ipMinOffsetPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortIngressLookup0Sublookup1TypeSet function
* @endinternal
*
* @brief   Configures Ingress PCL Lookup0 sublookup1 type.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] lookupType               - partial or full IPCL lookup0 sublookup1 type
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortIngressLookup0Sublookup1TypeSet
(
    IN GT_U8                                     devNum,
    IN CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_ENT lookupType
)
{
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclEngineConfig;
    }

    switch (lookupType)
    {
        case CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_PARTIAL_E:
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            hwValue = 0;
            break;
        case CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_FULL_E:
            hwValue = 1;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return prvCpssHwPpSetRegField(
        devNum, regAddr, 12, 1, hwValue);
}

/**
* @internal cpssDxChPclPortIngressLookup0Sublookup1TypeSet function
* @endinternal
*
* @brief   Configures Ingress PCL Lookup0 sublookup1 type.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
* @param[in] lookupType               - partial or full IPCL lookup0 sublookup1 type
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortIngressLookup0Sublookup1TypeSet
(
    IN GT_U8                                     devNum,
    IN CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_ENT lookupType
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortIngressLookup0Sublookup1TypeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, lookupType));

    rc = internal_cpssDxChPclPortIngressLookup0Sublookup1TypeSet(devNum, lookupType);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, lookupType));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPclPortIngressLookup0Sublookup1TypeGet function
* @endinternal
*
* @brief   Configures Ingress PCL Lookup0 sublookup1 type.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] lookupTypePtr            - (pointer to)partial or full IPCL lookup0 sublookup1 type
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortIngressLookup0Sublookup1TypeGet
(
    IN  GT_U8                                     devNum,
    OUT CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_ENT *lookupTypePtr
)
{
    GT_STATUS rc;            /* return code                         */
    GT_U32    regAddr;       /* register address                    */
    GT_U32    hwValue;       /* HW Value                            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(lookupTypePtr);

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclEngineConfig;
    }

    rc = prvCpssHwPpGetRegField(
        devNum, regAddr, 12, 1, &hwValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    *lookupTypePtr =
        (hwValue == 0)
            ? CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_PARTIAL_E
            : CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_FULL_E;

    return GT_OK;
}

/**
* @internal cpssDxChPclPortIngressLookup0Sublookup1TypeGet function
* @endinternal
*
* @brief   Configures Ingress PCL Lookup0 sublookup1 type.
*
* @note   APPLICABLE DEVICES:      xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  None.
*
* @param[in] devNum                   - device number
*
* @param[out] lookupTypePtr            - (pointer to)partial or full IPCL lookup0 sublookup1 type
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortIngressLookup0Sublookup1TypeGet
(
    IN  GT_U8                                     devNum,
    OUT CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_ENT *lookupTypePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortIngressLookup0Sublookup1TypeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, lookupTypePtr));

    rc = internal_cpssDxChPclPortIngressLookup0Sublookup1TypeGet(devNum, lookupTypePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, lookupTypePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortListGroupingEnableSet function
* @endinternal
*
* @brief   Enable/disable port grouping mode per direction. When enabled, the 4 MSB
*         bits of the <Port List> field in the PCL keys are replaced by a 4-bit
*         <Port Group>.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction
* @param[in] enable                   - enable/disable port grouping mode
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortListGroupingEnableSet
(
    IN GT_U8                    devNum,
    IN CPSS_PCL_DIRECTION_ENT   direction,
    IN GT_BOOL                  enable
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_U32      bitOffset;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).
                            TTIUnitGlobalConfigs.TTIUnitGlobalConfigExt;
            bitOffset = 28;
            break;
        case CPSS_PCL_DIRECTION_EGRESS_E:
            regAddr = PRV_DXCH_REG1_UNIT_HA_MAC(devNum).haGlobalConfig;
            bitOffset = 19;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    hwData = BOOL2BIT_MAC(enable);

    return prvCpssHwPpSetRegField(devNum, regAddr, bitOffset, 1, hwData);
}

/**
* @internal cpssDxChPclPortListGroupingEnableSet function
* @endinternal
*
* @brief   Enable/disable port grouping mode per direction. When enabled, the 4 MSB
*         bits of the <Port List> field in the PCL keys are replaced by a 4-bit
*         <Port Group>.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction
* @param[in] enable                   - enable/disable port grouping mode
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortListGroupingEnableSet
(
    IN GT_U8                    devNum,
    IN CPSS_PCL_DIRECTION_ENT   direction,
    IN GT_BOOL                  enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortListGroupingEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, enable));

    rc = internal_cpssDxChPclPortListGroupingEnableSet(devNum, direction, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortListGroupingEnableGet function
* @endinternal
*
* @brief   Get the port grouping mode enabling status per direction. When enabled,
*         the 4 MSB bits of the <Port List> field in the PCL keys are replaced by a
*         4-bit <Port Group>.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction
*
* @param[out] enablePtr                - (pointer to) the port grouping mode enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortListGroupingEnableGet
(
    IN  GT_U8                   devNum,
    IN  CPSS_PCL_DIRECTION_ENT  direction,
    OUT GT_BOOL                 *enablePtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_U32      bitOffset;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).
                            TTIUnitGlobalConfigs.TTIUnitGlobalConfigExt;
            bitOffset = 28;
            break;
        case CPSS_PCL_DIRECTION_EGRESS_E:
            regAddr = PRV_DXCH_REG1_UNIT_HA_MAC(devNum).haGlobalConfig;
            bitOffset = 19;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, bitOffset, 1, &hwData);
    if (rc == GT_OK)
    {
        *enablePtr = BIT2BOOL_MAC(hwData);
    }
    return rc;
}

/**
* @internal cpssDxChPclPortListGroupingEnableGet function
* @endinternal
*
* @brief   Get the port grouping mode enabling status per direction. When enabled,
*         the 4 MSB bits of the <Port List> field in the PCL keys are replaced by a
*         4-bit <Port Group>.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction
*
* @param[out] enablePtr                - (pointer to) the port grouping mode enabling status
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortListGroupingEnableGet
(
    IN  GT_U8                   devNum,
    IN  CPSS_PCL_DIRECTION_ENT  direction,
    OUT GT_BOOL                 *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortListGroupingEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, enablePtr));

    rc = internal_cpssDxChPclPortListGroupingEnableGet(devNum, direction, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortListPortMappingSet function
* @endinternal
*
* @brief   Set port group mapping and offset in port list for PCL working in Physical
*         Port List.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction
* @param[in] portNum                  - port number
* @param[in] enable                   - port participate in the port list vector.
* @param[in] group                    - PCL port group
*                                      Relevant only if <enable> == GT_TRUE.
*                                      (APPLICABLE RANGES: 0..15)
* @param[in] offset                   -  in the port list bit vector.
*                                      Relevant only if <enable> == GT_TRUE.
*                                      (APPLICABLE RANGES: 0..27)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note When working in PCL Port List mode with port grouping enabled, <offset>
*       value in the range 23..27 has no influence.
*
*/
static GT_STATUS internal_cpssDxChPclPortListPortMappingSet
(
    IN  GT_U8                   devNum,
    IN  CPSS_PCL_DIRECTION_ENT  direction,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_BOOL                 enable,
    IN  GT_U32                  group,
    IN  GT_U32                  offset
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;
    GT_U32      groupNum;
    GT_U32      portOffset;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

    if( GT_TRUE == enable )
    {
        /* check PCL port group and offset in bit vector validity */
        if( (group >= BIT_4) || (offset >= 28) )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        groupNum    = group;
        portOffset  = offset;
    }
    else /* GT_FALSE */
    {
        /* offset value (0x1F) for indication that port doesn't participate */
        /* in port list */
        groupNum    = 0;
        portOffset  = 0x1F;
    }

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                if( GT_TRUE == enable )
                {
                    rc = prvCpssDxChWriteTableEntryField(
                            devNum,
                            CPSS_DXCH_SIP5_20_TABLE_TTI_PHYSICAL_PORT_ATTRIBUTE_2_E,
                            portNum,
                            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                            246,
                            4,
                            groupNum);
                    if( GT_OK != rc )
                    {
                        return rc;
                    }
                }
                rc = prvCpssDxChWriteTableEntryField(
                        devNum,
                        CPSS_DXCH_SIP5_20_TABLE_TTI_PHYSICAL_PORT_ATTRIBUTE_2_E,
                        portNum,
                        PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                        241,
                        5,
                        portOffset);
            }
            else
            {
                if (portNum >= 256)
                {
                    /* redundant ckeck - the portNum check upper must catch it, but Klocwork - not */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                if (GT_TRUE == enable)
                {
                    regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).
                                                portMap.portGroupMap[portNum/8];
                    rc = prvCpssHwPpSetRegField(devNum, regAddr,
                                               (portNum%8)*4,
                                               4,
                                               groupNum);
                    if( GT_OK != rc )
                    {
                        return rc;
                    }
                }

                regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).
                                                portMap.portListMap[portNum/6];
                rc = prvCpssHwPpSetRegField(devNum, regAddr,
                                               (portNum%6)*5,
                                               5,
                                               portOffset);
            }
            break;
        case CPSS_PCL_DIRECTION_EGRESS_E:
            if( GT_TRUE == enable )
            {
                rc = prvCpssDxChWriteTableEntryField(
                        devNum,
                        CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
                        portNum,
                        PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                        SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_PORT_GROUP_E, /* field name */
                        PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                        groupNum);

                if( GT_OK != rc )
                {
                    return rc;
                }
            }

            rc = prvCpssDxChWriteTableEntryField(
                    devNum,
                    CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
                    portNum,
                    PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                    SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_PORT_LIST_BIT_VECTOR_OFFSET_E, /* field name */
                    PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                    portOffset);
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/**
* @internal cpssDxChPclPortListPortMappingSet function
* @endinternal
*
* @brief   Set port group mapping and offset in port list for PCL working in Physical
*         Port List.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction
* @param[in] portNum                  - port number
* @param[in] enable                   - port participate in the port list vector.
* @param[in] group                    - PCL port group
*                                      Relevant only if <enable> == GT_TRUE.
*                                      (APPLICABLE RANGES: 0..15)
* @param[in] offset                   -  in the port list bit vector.
*                                      Relevant only if <enable> == GT_TRUE.
*                                      (APPLICABLE RANGES: 0..27)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note When working in PCL Port List mode with port grouping enabled, <offset>
*       value in the range 23..27 has no influence.
*
*/
GT_STATUS cpssDxChPclPortListPortMappingSet
(
    IN  GT_U8                   devNum,
    IN  CPSS_PCL_DIRECTION_ENT  direction,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_BOOL                 enable,
    IN  GT_U32                  group,
    IN  GT_U32                  offset
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortListPortMappingSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, portNum, enable, group, offset));

    rc = internal_cpssDxChPclPortListPortMappingSet(devNum, direction, portNum, enable, group, offset);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, portNum, enable, group, offset));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortListPortMappingGet function
* @endinternal
*
* @brief   Get port group mapping and offset in port list for PCL working in Physical
*         Port List.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction
* @param[in] portNum                  - port number
*
* @param[out] enablePtr                - (pointer to) port participate in the port list vector.
* @param[out] groupPtr                 - (pointer to) PCL port group
* @param[out] offsetPtr                - (pointer to) offset in the port list bit vector.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortListPortMappingGet
(
    IN  GT_U8                   devNum,
    IN  CPSS_PCL_DIRECTION_ENT  direction,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_BOOL                 *enablePtr,
    OUT GT_U32                  *groupPtr,
    OUT GT_U32                  *offsetPtr
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);
    CPSS_NULL_PTR_CHECK_MAC(groupPtr);
    CPSS_NULL_PTR_CHECK_MAC(offsetPtr);

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                rc = prvCpssDxChReadTableEntryField(
                        devNum,
                        CPSS_DXCH_SIP5_20_TABLE_TTI_PHYSICAL_PORT_ATTRIBUTE_2_E,
                        portNum,
                        PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                        246,
                        4,
                        groupPtr);
                if( GT_OK != rc )
                {
                    return rc;
                }
                rc = prvCpssDxChReadTableEntryField(
                        devNum,
                        CPSS_DXCH_SIP5_20_TABLE_TTI_PHYSICAL_PORT_ATTRIBUTE_2_E,
                        portNum,
                        PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                        241,
                        5,
                        offsetPtr);
            }
            else
            {
                if (portNum >= 256)
                {
                    /* redundant ckeck - the portNum check upper must catch it, but Klocwork - not */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).
                                                portMap.portGroupMap[portNum/8];
                rc = prvCpssHwPpGetRegField(devNum, regAddr,
                                               (portNum%8)*4,
                                               4,
                                               groupPtr);
                if( GT_OK != rc )
                {
                    return rc;
                }

                regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).
                                                portMap.portListMap[portNum/6];
                rc = prvCpssHwPpGetRegField(devNum, regAddr,
                                               (portNum%6)*5,
                                               5,
                                               offsetPtr);
            }
            break;
        case CPSS_PCL_DIRECTION_EGRESS_E:
            rc = prvCpssDxChReadTableEntryField(devNum,
                                                CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
                                                portNum,
                                                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_PORT_GROUP_E, /* field name */
                                                PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                                groupPtr);
            if( GT_OK != rc )
            {
                return rc;
            }

            rc = prvCpssDxChReadTableEntryField(devNum,
                                                CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
                                                portNum,
                                                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                SIP5_HA_PHYSICAL_PORT_TABLE_1_FIELDS_PORT_LIST_BIT_VECTOR_OFFSET_E, /* field name */
                                                PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                                offsetPtr);
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (rc == GT_OK)
    {
        if( 0x1F == *offsetPtr )
        {
            /* offset value (0x1F) for indication that port doesn't participate */
            /* in port list */
            *enablePtr = GT_FALSE;
        }
        else
        {
            *enablePtr = GT_TRUE;
        }
    }

    return rc;
}

/**
* @internal cpssDxChPclPortListPortMappingGet function
* @endinternal
*
* @brief   Get port group mapping and offset in port list for PCL working in Physical
*         Port List.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction
* @param[in] portNum                  - port number
*
* @param[out] enablePtr                - (pointer to) port participate in the port list vector.
* @param[out] groupPtr                 - (pointer to) PCL port group
* @param[out] offsetPtr                - (pointer to) offset in the port list bit vector.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortListPortMappingGet
(
    IN  GT_U8                   devNum,
    IN  CPSS_PCL_DIRECTION_ENT  direction,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_BOOL                 *enablePtr,
    OUT GT_U32                  *groupPtr,
    OUT GT_U32                  *offsetPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortListPortMappingGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, portNum, enablePtr, groupPtr, offsetPtr));

    rc = internal_cpssDxChPclPortListPortMappingGet(devNum, direction, portNum, enablePtr, groupPtr, offsetPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, portNum, enablePtr, groupPtr, offsetPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet function
* @endinternal
*
* @brief   Set Mapping of MPLS Channel Type Profile to OAM opcode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] channelTypeProfile       - MPLS G-ACh Channel Type Profile
*                                      (APPLICABLE RANGES: 1..15)
* @param[in] opcode                   - OAM  (APPLICABLE RANGES: 0..255)
* @param[in] RBitAssignmentEnable     - replace Bit0 of opcode by packet R-flag
*                                      GT_TRUE  - Bit0 of result opcode is packet R-flag
*                                      GT_FALSE - Bit0 of result opcode
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - for out-of-range parameter values.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet
(
    IN  GT_U8                     devNum,
    IN  GT_U32                    channelTypeProfile,
    IN  GT_U32                    opcode,
    IN  GT_BOOL                   RBitAssignmentEnable
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */
    GT_U32      offset;  /* field offset in bits */
    GT_STATUS   rc;      /* return code          */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    if ((channelTypeProfile > 15) || (channelTypeProfile == 0))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (opcode > 0xFF)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    /* Ingress PCL */

    /* channelType => OAMOpcode table */
    regAddr =
        PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).OAMConfigs.channelTypeOAMOpcode[channelTypeProfile - 1];

    hwData = opcode;

    rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 8, hwData);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* RBitAssignmentEnable */

    regAddr =
        PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).OAMConfigs.RBitAssignmentEnable;

    hwData = BOOL2BIT_MAC(RBitAssignmentEnable);

    rc = prvCpssHwPpSetRegField(devNum, regAddr, channelTypeProfile, 1, hwData);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Egress PCL */

    /* channelType => OAMOpcode table */
    regAddr =
        PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCLChannelTypeToOAMOpcodeMap[(channelTypeProfile - 1) / 3];

    offset = (((channelTypeProfile - 1) % 3) * 9);
    hwData = (opcode | (BOOL2BIT_MAC(RBitAssignmentEnable) << 8));

    rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, 9, hwData);

    return rc;
}

/**
* @internal cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet function
* @endinternal
*
* @brief   Set Mapping of MPLS Channel Type Profile to OAM opcode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] channelTypeProfile       - MPLS G-ACh Channel Type Profile
*                                      (APPLICABLE RANGES: 1..15)
* @param[in] opcode                   - OAM  (APPLICABLE RANGES: 0..255)
* @param[in] RBitAssignmentEnable     - replace Bit0 of opcode by packet R-flag
*                                      GT_TRUE  - Bit0 of result opcode is packet R-flag
*                                      GT_FALSE - Bit0 of result opcode
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - for out-of-range parameter values.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet
(
    IN  GT_U8                     devNum,
    IN  GT_U32                    channelTypeProfile,
    IN  GT_U32                    opcode,
    IN  GT_BOOL                   RBitAssignmentEnable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, channelTypeProfile, opcode, RBitAssignmentEnable));

    rc = internal_cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet(devNum, channelTypeProfile, opcode, RBitAssignmentEnable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, channelTypeProfile, opcode, RBitAssignmentEnable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet function
* @endinternal
*
* @brief   Get Mapping of MPLS Channel Type Profile to OAM opcode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] channelTypeProfile       - MPLS G-ACh Channel Type Profile
*                                      (APPLICABLE RANGES: 1..15)
*
* @param[out] opcodePtr                - (pointer to)OAM opcode
* @param[out] RBitAssignmentEnablePtr  - (pointer to)replace Bit0 of opcode by packet R-flag
*                                      GT_TRUE  - Bit0 of result opcode is packet R-flag
*                                      GT_FALSE - Bit0 of result opcode
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet
(
    IN  GT_U8                     devNum,
    IN  GT_U32                    channelTypeProfile,
    OUT GT_U32                    *opcodePtr,
    OUT GT_BOOL                   *RBitAssignmentEnablePtr
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */
    GT_U32      offset;  /* field offset in bits */
    GT_STATUS   rc;      /* return code          */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    if ((channelTypeProfile > 15) || (channelTypeProfile == 0))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    CPSS_NULL_PTR_CHECK_MAC(opcodePtr);
    CPSS_NULL_PTR_CHECK_MAC(RBitAssignmentEnablePtr);

    /* Egress PCL */

    /* channelType => OAMOpcode table */
    regAddr =
        PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCLChannelTypeToOAMOpcodeMap[(channelTypeProfile - 1) / 3];

    offset = (((channelTypeProfile - 1) % 3) * 9);

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 9, &hwData);
    if (rc != GT_OK)
    {
        return rc;
    }

    *opcodePtr               = (hwData & 0xFF);
    *RBitAssignmentEnablePtr = BIT2BOOL_MAC(((hwData >> 8) & 1));

    return GT_OK;
}

/**
* @internal cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet function
* @endinternal
*
* @brief   Get Mapping of MPLS Channel Type Profile to OAM opcode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] channelTypeProfile       - MPLS G-ACh Channel Type Profile
*                                      (APPLICABLE RANGES: 1..15)
*
* @param[out] opcodePtr                - (pointer to)OAM opcode
* @param[out] RBitAssignmentEnablePtr  - (pointer to)replace Bit0 of opcode by packet R-flag
*                                      GT_TRUE  - Bit0 of result opcode is packet R-flag
*                                      GT_FALSE - Bit0 of result opcode
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet
(
    IN  GT_U8                     devNum,
    IN  GT_U32                    channelTypeProfile,
    OUT GT_U32                    *opcodePtr,
    OUT GT_BOOL                   *RBitAssignmentEnablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, channelTypeProfile, opcodePtr, RBitAssignmentEnablePtr));

    rc = internal_cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(devNum, channelTypeProfile, opcodePtr, RBitAssignmentEnablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, channelTypeProfile, opcodePtr, RBitAssignmentEnablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOamMegLevelModeSet function
* @endinternal
*
* @brief   Set OAM MEG Level Mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction.
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
* @param[in] megLevelMode             - OAM MEG Level Mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - for out-of-range parameter values.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclOamMegLevelModeSet
(
    IN  GT_U8                                     devNum,
    IN  CPSS_PCL_DIRECTION_ENT                    direction,
    IN  GT_U32                                    oamProfile,
    IN  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_ENT  megLevelMode
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */
    GT_U32      offset;  /* field offset in bits */
    GT_STATUS   rc;      /* return code          */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    if (oamProfile > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    offset = (2 * oamProfile);

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            switch (megLevelMode)
            {
                case CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E:
                    hwData = 0;
                    break;
                case CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_MAC_DA_E:
                    hwData = 1;
                    break;
                case CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_QOS_E:
                    hwData = 2;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            regAddr =
                PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).OAMConfigs.OAMMEGLevelModeConfigs;
            break;

        case CPSS_PCL_DIRECTION_EGRESS_E:
            switch (megLevelMode)
            {
                case CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E:
                    hwData = 0;
                    break;
                case CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_MAC_DA_E:
                    hwData = 1;
                    break;
                case CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_EXP_E:
                    hwData = 2;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            regAddr =
                PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCLOAMMEGLevelMode;
            break;

        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, 2, hwData);

    return rc;
}

/**
* @internal cpssDxChPclOamMegLevelModeSet function
* @endinternal
*
* @brief   Set OAM MEG Level Mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction.
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
* @param[in] megLevelMode             - OAM MEG Level Mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - for out-of-range parameter values.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclOamMegLevelModeSet
(
    IN  GT_U8                                     devNum,
    IN  CPSS_PCL_DIRECTION_ENT                    direction,
    IN  GT_U32                                    oamProfile,
    IN  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_ENT  megLevelMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOamMegLevelModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, oamProfile, megLevelMode));

    rc = internal_cpssDxChPclOamMegLevelModeSet(devNum, direction, oamProfile, megLevelMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, oamProfile, megLevelMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOamMegLevelModeGet function
* @endinternal
*
* @brief   Get OAM MEG Level Mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction.
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
*
* @param[out] megLevelModePtr          - (pointer to) OAM MEG Level Mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_STATE             - on unexpected value in HW
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclOamMegLevelModeGet
(
    IN  GT_U8                                     devNum,
    IN  CPSS_PCL_DIRECTION_ENT                    direction,
    IN  GT_U32                                    oamProfile,
    OUT CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_ENT  *megLevelModePtr
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */
    GT_U32      offset;  /* field offset in bits */
    GT_STATUS   rc;      /* return code          */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(megLevelModePtr);

    if (oamProfile > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    offset = (2 * oamProfile);

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            regAddr =
                PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).OAMConfigs.OAMMEGLevelModeConfigs;
            break;

        case CPSS_PCL_DIRECTION_EGRESS_E:
            regAddr =
                PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCLOAMMEGLevelMode;
            break;

        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 2, &hwData);
    if (rc != GT_OK)
    {
        return rc;
    }

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            switch (hwData)
            {
                case 0:
                    *megLevelModePtr = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E;
                    break;
                case 1:
                    *megLevelModePtr = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_MAC_DA_E;
                    break;
                case 2:
                    *megLevelModePtr = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_QOS_E;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            break;

        case CPSS_PCL_DIRECTION_EGRESS_E:
            switch (hwData)
            {
                case 0:
                    *megLevelModePtr = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E;
                    break;
                case 1:
                    *megLevelModePtr = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_MAC_DA_E;
                    break;
                case 2:
                    *megLevelModePtr = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_EXP_E;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            break;

        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPclOamMegLevelModeGet function
* @endinternal
*
* @brief   Get OAM MEG Level Mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction.
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
*
* @param[out] megLevelModePtr          - (pointer to) OAM MEG Level Mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_STATE             - on unexpected value in HW
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclOamMegLevelModeGet
(
    IN  GT_U8                                     devNum,
    IN  CPSS_PCL_DIRECTION_ENT                    direction,
    IN  GT_U32                                    oamProfile,
    OUT CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_ENT  *megLevelModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOamMegLevelModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, oamProfile, megLevelModePtr));

    rc = internal_cpssDxChPclOamMegLevelModeGet(devNum, direction, oamProfile, megLevelModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, oamProfile, megLevelModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOamRdiMatchingSet function
* @endinternal
*
* @brief   Set OAM RDI(Remote Direct Indicator) Matching parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction.
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
* @param[in] rdiMask                  - Mask for RDI bit.(APPLICABLE RANGES: 0..255)
* @param[in] rdiPattern               - Pattern for RDI bit.(APPLICABLE RANGES: 0..255)
*                                      Extracted packet byte pointed by UDB4 (profile0) or UDB5 (profile1)
*                                      Result = ((packetByte & rdiMask) == rdiPattern) ? 0 : 1.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - for out-of-range parameter values.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclOamRdiMatchingSet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  GT_U32                        oamProfile,
    IN  GT_U32                        rdiMask,
    IN  GT_U32                        rdiPattern
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */
    GT_U32      offset;  /* field offset in bits */
    GT_STATUS   rc;      /* return code          */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    if (oamProfile > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (rdiMask > 0xFF)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if (rdiPattern > 0xFF)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    offset = (16 * oamProfile);

    hwData = ((rdiPattern << 8) | rdiMask);

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            regAddr =
                PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).OAMConfigs.OAMRDIConfigs;
            break;

        case CPSS_PCL_DIRECTION_EGRESS_E:
            regAddr =
                PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCLOAMRDI;
            break;

        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, 16, hwData);

    return rc;
}

/**
* @internal cpssDxChPclOamRdiMatchingSet function
* @endinternal
*
* @brief   Set OAM RDI(Remote Direct Indicator) Matching parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction.
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
* @param[in] rdiMask                  - Mask for RDI bit.(APPLICABLE RANGES: 0..255)
* @param[in] rdiPattern               - Pattern for RDI bit.(APPLICABLE RANGES: 0..255)
*                                      Extracted packet byte pointed by UDB4 (profile0) or UDB5 (profile1)
*                                      Result = ((packetByte & rdiMask) == rdiPattern) ? 0 : 1.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - for out-of-range parameter values.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclOamRdiMatchingSet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  GT_U32                        oamProfile,
    IN  GT_U32                        rdiMask,
    IN  GT_U32                        rdiPattern
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOamRdiMatchingSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, oamProfile, rdiMask, rdiPattern));

    rc = internal_cpssDxChPclOamRdiMatchingSet(devNum, direction, oamProfile, rdiMask, rdiPattern);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, oamProfile, rdiMask, rdiPattern));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOamRdiMatchingGet function
* @endinternal
*
* @brief   Get OAM RDI(Remote Direct Indicator) Matching parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction.
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
*
* @param[out] rdiMaskPtr               - (pointer to)Mask for RDI bit.(APPLICABLE RANGES: 0..255)
* @param[out] rdiPatternPtr            - (pointer to)Pattern for RDI bit.(APPLICABLE RANGES: 0..255)
*                                      Extracted packet byte pointed by UDB4 (profile0) or UDB5 (profile1)
*                                      Result = ((packetByte & rdiMask) == rdiPattern) ? 0 : 1.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclOamRdiMatchingGet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  GT_U32                        oamProfile,
    OUT GT_U32                        *rdiMaskPtr,
    OUT GT_U32                        *rdiPatternPtr
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */
    GT_U32      offset;  /* field offset in bits */
    GT_STATUS   rc;      /* return code          */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(rdiMaskPtr);
    CPSS_NULL_PTR_CHECK_MAC(rdiPatternPtr);

    if (oamProfile > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    offset = (16 * oamProfile);

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            regAddr =
                PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).OAMConfigs.OAMRDIConfigs;
            break;

        case CPSS_PCL_DIRECTION_EGRESS_E:
            regAddr =
                PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCLOAMRDI;
            break;

        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 16, &hwData);
    if (rc != GT_OK)
    {
        return rc;
    }

    *rdiMaskPtr     = (hwData & 0xFF);
    *rdiPatternPtr  = ((hwData >> 8) & 0xFF);

    return GT_OK;
}

/**
* @internal cpssDxChPclOamRdiMatchingGet function
* @endinternal
*
* @brief   Get OAM RDI(Remote Direct Indicator) Matching parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] direction                - Policy direction.
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
*
* @param[out] rdiMaskPtr               - (pointer to)Mask for RDI bit.(APPLICABLE RANGES: 0..255)
* @param[out] rdiPatternPtr            - (pointer to)Pattern for RDI bit.(APPLICABLE RANGES: 0..255)
*                                      Extracted packet byte pointed by UDB4 (profile0) or UDB5 (profile1)
*                                      Result = ((packetByte & rdiMask) == rdiPattern) ? 0 : 1.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclOamRdiMatchingGet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  GT_U32                        oamProfile,
    OUT GT_U32                        *rdiMaskPtr,
    OUT GT_U32                        *rdiPatternPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOamRdiMatchingGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, oamProfile, rdiMaskPtr, rdiPatternPtr));

    rc = internal_cpssDxChPclOamRdiMatchingGet(devNum, direction, oamProfile, rdiMaskPtr, rdiPatternPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, oamProfile, rdiMaskPtr, rdiPatternPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOamEgressPacketDetectionSet function
* @endinternal
*
* @brief   Set OAM Egress Packet Detection parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] mode                     - Egress Packet Detection mode.
* @param[in] sourceId                 - packet Source Id. When mode ==
*                                      CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E
*                                      and packet source ID equal to sourceId value
*                                      the packet treated as OAM packet
*                                      regardless to PCL action results.
*                                      (APPLICABLE RANGES: 0..0xFFF)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - for out-of-range parameter values.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclOamEgressPacketDetectionSet
(
    IN  GT_U8                                     devNum,
    IN  CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_ENT  mode,
    IN  GT_U32                                    sourceId
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */
    GT_STATUS   rc;      /* return code          */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    switch (mode)
    {
        case CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_STANDARD_E:
            hwData = 0;
            break;
        case CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E:
            hwData = 1;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (sourceId > 0xFFF)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    hwData = ((sourceId << 1) | hwData);

    regAddr =
        PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCLOAMPktDetection;

    rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 13, hwData);

    return rc;
}

/**
* @internal cpssDxChPclOamEgressPacketDetectionSet function
* @endinternal
*
* @brief   Set OAM Egress Packet Detection parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] mode                     - Egress Packet Detection mode.
* @param[in] sourceId                 - packet Source Id. When mode ==
*                                      CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E
*                                      and packet source ID equal to sourceId value
*                                      the packet treated as OAM packet
*                                      regardless to PCL action results.
*                                      (APPLICABLE RANGES: 0..0xFFF)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - for out-of-range parameter values.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclOamEgressPacketDetectionSet
(
    IN  GT_U8                                     devNum,
    IN  CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_ENT  mode,
    IN  GT_U32                                    sourceId
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOamEgressPacketDetectionSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mode, sourceId));

    rc = internal_cpssDxChPclOamEgressPacketDetectionSet(devNum, mode, sourceId);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mode, sourceId));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOamEgressPacketDetectionGet function
* @endinternal
*
* @brief   Get OAM Egress Packet Detection parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] modePtr                  - (pointer to)Egress Packet Detection mode.
* @param[out] sourceIdPtr              - (pointer to)packet Source Id. When mode ==
*                                      CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E
*                                      and packet source ID equal to sourceId value
*                                      the packet treated as OAM packet
*                                      regardless to PCL action results.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclOamEgressPacketDetectionGet
(
    IN  GT_U8                                     devNum,
    OUT CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_ENT  *modePtr,
    OUT GT_U32                                    *sourceIdPtr
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */
    GT_STATUS   rc;      /* return code          */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(modePtr);
    CPSS_NULL_PTR_CHECK_MAC(sourceIdPtr);

    regAddr =
        PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCLOAMPktDetection;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 13, &hwData);
    if (rc != GT_OK)
    {
        return rc;
    }

    *modePtr = ((hwData & 1) == 0)
        ? CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_STANDARD_E
        : CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E;

    *sourceIdPtr = ((hwData >> 1) & 0xFFF);

    return GT_OK;
}

/**
* @internal cpssDxChPclOamEgressPacketDetectionGet function
* @endinternal
*
* @brief   Get OAM Egress Packet Detection parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] modePtr                  - (pointer to)Egress Packet Detection mode.
* @param[out] sourceIdPtr              - (pointer to)packet Source Id. When mode ==
*                                      CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E
*                                      and packet source ID equal to sourceId value
*                                      the packet treated as OAM packet
*                                      regardless to PCL action results.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclOamEgressPacketDetectionGet
(
    IN  GT_U8                                     devNum,
    OUT CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_ENT  *modePtr,
    OUT GT_U32                                    *sourceIdPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOamEgressPacketDetectionGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, modePtr, sourceIdPtr));

    rc = internal_cpssDxChPclOamEgressPacketDetectionGet(devNum, modePtr, sourceIdPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, modePtr, sourceIdPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOamRFlagMatchingSet function
* @endinternal
*
* @brief   Set OAM R-Flag Matching parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
* @param[in] rFlagMask                - Mask for R-Flag.(APPLICABLE RANGES: 0..255)
* @param[in] rFlagPattern             - Pattern for R-Flag.(APPLICABLE RANGES: 0..255)
*                                      Extracted packet byte pointed by UDB8 (profile0) or UDB9 (profile1)
*                                      Result = ((packetByte & rFlagMask) == rFlagPattern) ? 0 : 1.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - for out-of-range parameter values.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclOamRFlagMatchingSet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        oamProfile,
    IN  GT_U32                        rFlagMask,
    IN  GT_U32                        rFlagPattern
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */
    GT_U32      offset;  /* field offset in bits */
    GT_STATUS   rc;      /* return code          */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    if (oamProfile > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (rFlagMask > 0xFF)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if (rFlagPattern > 0xFF)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    offset = (16 * oamProfile);

    hwData = ((rFlagPattern << 8) | rFlagMask);

    regAddr =
        PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).OAMConfigs.OAMRFlagConfigs;

    rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, 16, hwData);

    return rc;
}

/**
* @internal cpssDxChPclOamRFlagMatchingSet function
* @endinternal
*
* @brief   Set OAM R-Flag Matching parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
* @param[in] rFlagMask                - Mask for R-Flag.(APPLICABLE RANGES: 0..255)
* @param[in] rFlagPattern             - Pattern for R-Flag.(APPLICABLE RANGES: 0..255)
*                                      Extracted packet byte pointed by UDB8 (profile0) or UDB9 (profile1)
*                                      Result = ((packetByte & rFlagMask) == rFlagPattern) ? 0 : 1.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_OUT_OF_RANGE          - for out-of-range parameter values.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclOamRFlagMatchingSet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        oamProfile,
    IN  GT_U32                        rFlagMask,
    IN  GT_U32                        rFlagPattern
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOamRFlagMatchingSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, oamProfile, rFlagMask, rFlagPattern));

    rc = internal_cpssDxChPclOamRFlagMatchingSet(devNum, oamProfile, rFlagMask, rFlagPattern);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, oamProfile, rFlagMask, rFlagPattern));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclOamRFlagMatchingGet function
* @endinternal
*
* @brief   Get OAM R-Flag Matching parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
*
* @param[out] rFlagMaskPtr             - (pointer to)Mask for R-Flag.(APPLICABLE RANGES: 0..255)
* @param[out] rFlagPatternPtr          - (pointer to)Pattern for R-Flag.(APPLICABLE RANGES: 0..255)
*                                      Extracted packet byte pointed by UDB8 (profile0) or UDB9 (profile1)
*                                      Result = ((packetByte & rFlagMask) == rFlagPattern) ? 0 : 1.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclOamRFlagMatchingGet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        oamProfile,
    OUT GT_U32                        *rFlagMaskPtr,
    OUT GT_U32                        *rFlagPatternPtr
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */
    GT_U32      offset;  /* field offset in bits */
    GT_STATUS   rc;      /* return code          */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(rFlagMaskPtr);
    CPSS_NULL_PTR_CHECK_MAC(rFlagPatternPtr);

    if (oamProfile > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    offset = (16 * oamProfile);

    regAddr =
        PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).OAMConfigs.OAMRFlagConfigs;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 16, &hwData);
    if (rc != GT_OK)
    {
        return rc;
    }

    *rFlagMaskPtr     = (hwData & 0xFF);
    *rFlagPatternPtr  = ((hwData >> 8) & 0xFF);

    return GT_OK;
}

/**
* @internal cpssDxChPclOamRFlagMatchingGet function
* @endinternal
*
* @brief   Get OAM R-Flag Matching parameters.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] oamProfile               - OAM profile (APPLICABLE RANGES: 0..1)
*
* @param[out] rFlagMaskPtr             - (pointer to)Mask for R-Flag.(APPLICABLE RANGES: 0..255)
* @param[out] rFlagPatternPtr          - (pointer to)Pattern for R-Flag.(APPLICABLE RANGES: 0..255)
*                                      Extracted packet byte pointed by UDB8 (profile0) or UDB9 (profile1)
*                                      Result = ((packetByte & rFlagMask) == rFlagPattern) ? 0 : 1.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclOamRFlagMatchingGet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        oamProfile,
    OUT GT_U32                        *rFlagMaskPtr,
    OUT GT_U32                        *rFlagPatternPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclOamRFlagMatchingGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, oamProfile, rFlagMaskPtr, rFlagPatternPtr));

    rc = internal_cpssDxChPclOamRFlagMatchingGet(devNum, oamProfile, rFlagMaskPtr, rFlagPatternPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, oamProfile, rFlagMaskPtr, rFlagPatternPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressSourcePortSelectionModeSet function
* @endinternal
*
* @brief   Set EPCL source port field selection mode for DSA tagged packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portSelectionMode        - Source port selection mode for DSA packets
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note EPCL key <SrcPort> always reflects the local device source physical
*       ingress port, even for DSA-tagged packets. To maintain backward
*       compatibility for DSA-tagged packets, a global mode allows working in
*       the backward compatible mode where <SrcPort> is taken from the DSA tag
*       if packet was received DSA tagged.
*
*/
static GT_STATUS internal_cpssDxChPclEgressSourcePortSelectionModeSet
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ENT portSelectionMode
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    switch (portSelectionMode)
    {
        case CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ORIGINAL_E:
            hwData = 0;
            break;
        case CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_LOCAL_E:
            hwData = 1;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_DXCH_REG1_UNIT_HA_MAC(devNum).haGlobalConfig;

    return prvCpssHwPpSetRegField(devNum, regAddr, 20, 1, hwData);
}

/**
* @internal cpssDxChPclEgressSourcePortSelectionModeSet function
* @endinternal
*
* @brief   Set EPCL source port field selection mode for DSA tagged packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portSelectionMode        - Source port selection mode for DSA packets
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note EPCL key <SrcPort> always reflects the local device source physical
*       ingress port, even for DSA-tagged packets. To maintain backward
*       compatibility for DSA-tagged packets, a global mode allows working in
*       the backward compatible mode where <SrcPort> is taken from the DSA tag
*       if packet was received DSA tagged.
*
*/
GT_STATUS cpssDxChPclEgressSourcePortSelectionModeSet
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ENT portSelectionMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressSourcePortSelectionModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portSelectionMode));

    rc = internal_cpssDxChPclEgressSourcePortSelectionModeSet(devNum, portSelectionMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portSelectionMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressSourcePortSelectionModeGet function
* @endinternal
*
* @brief   Get EPCL source port field selection mode for DSA tagged packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] portSelectionModePtr     - (pointer to) Source port selection mode for
*                                      DSA packets
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note EPCL key <SrcPort> always reflects the local device source physical
*       ingress port, even for DSA-tagged packets. To maintain backward
*       compatibility for DSA-tagged packets, a global mode allows working in
*       the backward compatible mode where <SrcPort> is taken from the DSA tag
*       if packet was received DSA tagged.
*
*/
static GT_STATUS internal_cpssDxChPclEgressSourcePortSelectionModeGet
(
    IN  GT_U8                                               devNum,
    OUT CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ENT *portSelectionModePtr
)
{
    GT_STATUS   rc;      /* return code          */
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(portSelectionModePtr);

    regAddr = PRV_DXCH_REG1_UNIT_HA_MAC(devNum).haGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 20, 1, &hwData);
    if (rc != GT_OK)
    {
        return rc;
    }

    *portSelectionModePtr = (hwData == 0) ?
            CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ORIGINAL_E :
            CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_LOCAL_E;

    return GT_OK;
}

/**
* @internal cpssDxChPclEgressSourcePortSelectionModeGet function
* @endinternal
*
* @brief   Get EPCL source port field selection mode for DSA tagged packets.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] portSelectionModePtr     - (pointer to) Source port selection mode for
*                                      DSA packets
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note EPCL key <SrcPort> always reflects the local device source physical
*       ingress port, even for DSA-tagged packets. To maintain backward
*       compatibility for DSA-tagged packets, a global mode allows working in
*       the backward compatible mode where <SrcPort> is taken from the DSA tag
*       if packet was received DSA tagged.
*
*/
GT_STATUS cpssDxChPclEgressSourcePortSelectionModeGet
(
    IN  GT_U8                                               devNum,
    OUT CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ENT *portSelectionModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressSourcePortSelectionModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portSelectionModePtr));

    rc = internal_cpssDxChPclEgressSourcePortSelectionModeGet(devNum, portSelectionModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portSelectionModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressTargetPortSelectionModeSet function
* @endinternal
*
* @brief   Set EPCL target port field selection mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portSelectionMode        - Target port selection mode
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclEgressTargetPortSelectionModeSet
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_ENT portSelectionMode
)
{
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    switch (portSelectionMode)
    {
        case CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_LOCAL_E:
            hwData = 0;
            break;
        case CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_FINAL_E:
            hwData = 1;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_DXCH_REG1_UNIT_HA_MAC(devNum).haGlobalConfig;

    return prvCpssHwPpSetRegField(devNum, regAddr, 21, 1, hwData);
}

/**
* @internal cpssDxChPclEgressTargetPortSelectionModeSet function
* @endinternal
*
* @brief   Set EPCL target port field selection mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portSelectionMode        - Target port selection mode
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclEgressTargetPortSelectionModeSet
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_ENT portSelectionMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressTargetPortSelectionModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portSelectionMode));

    rc = internal_cpssDxChPclEgressTargetPortSelectionModeSet(devNum, portSelectionMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portSelectionMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressTargetPortSelectionModeGet function
* @endinternal
*
* @brief   Get EPCL target port field selection mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] portSelectionModePtr     - (pointer to) Target port selection mode
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclEgressTargetPortSelectionModeGet
(
    IN  GT_U8                                           devNum,
    OUT CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_ENT
                                                        *portSelectionModePtr
)
{
    GT_STATUS   rc;      /* return code          */
    GT_U32      regAddr; /* register address     */
    GT_U32      hwData;  /* data in HW format    */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(portSelectionModePtr);

    regAddr = PRV_DXCH_REG1_UNIT_HA_MAC(devNum).haGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 21, 1, &hwData);
    if (rc != GT_OK)
    {
        return rc;
    }

    *portSelectionModePtr = (hwData == 0) ?
            CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_LOCAL_E :
            CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_FINAL_E;

    return GT_OK;
}

/**
* @internal cpssDxChPclEgressTargetPortSelectionModeGet function
* @endinternal
*
* @brief   Get EPCL target port field selection mode.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @param[out] portSelectionModePtr     - (pointer to) Target port selection mode
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclEgressTargetPortSelectionModeGet
(
    IN  GT_U8                                           devNum,
    OUT CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_ENT
                                                        *portSelectionModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressTargetPortSelectionModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portSelectionModePtr));

    rc = internal_cpssDxChPclEgressTargetPortSelectionModeGet(devNum, portSelectionModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portSelectionModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclSourceIdMaskSet function
* @endinternal
*
* @brief   Set mask so only certain bits in the source ID will be modified due to PCL
*         action.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] lookupNum                - lookup number
* @param[in] mask                     - Source ID  (APPLICABLE RANGES: 0..4095)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range.
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclSourceIdMaskSet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum,
    IN  GT_U32                      mask
)
{
    GT_U32      regAddr;     /* register address     */
    GT_U32      lookupIndex; /* index in register array for requested lookup */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    if( mask > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_SRC_ID_MAC(devNum) )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    switch (lookupNum)
    {
        case CPSS_PCL_LOOKUP_0_E:
        case CPSS_PCL_LOOKUP_0_0_E:
            lookupIndex = 0;
            break;
        case CPSS_PCL_LOOKUP_0_1_E:
            lookupIndex = 1;
            break;
        case CPSS_PCL_LOOKUP_1_E:
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            lookupIndex = 2;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr =
        PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).lookupSourceIDMask[lookupIndex];

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 12, mask);
}

/**
* @internal cpssDxChPclSourceIdMaskSet function
* @endinternal
*
* @brief   Set mask so only certain bits in the source ID will be modified due to PCL
*         action.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] lookupNum                - lookup number
* @param[in] mask                     - Source ID  (APPLICABLE RANGES: 0..4095)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_OUT_OF_RANGE          - one of the parameters is out of range.
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclSourceIdMaskSet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum,
    IN  GT_U32                      mask
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclSourceIdMaskSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, lookupNum, mask));

    rc = internal_cpssDxChPclSourceIdMaskSet(devNum, lookupNum, mask);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, lookupNum, mask));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclSourceIdMaskGet function
* @endinternal
*
* @brief   Get mask used for source ID modify due to PCL action.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] lookupNum                - lookup number
*
* @param[out] maskPtr                  - (pointer to) Source ID mask (APPLICABLE RANGES: 0..4095)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclSourceIdMaskGet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum,
    OUT GT_U32                      *maskPtr
)
{
    GT_U32      regAddr;     /* register address     */
    GT_U32      lookupIndex; /* index in register array for requested lookup */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(maskPtr);

    switch (lookupNum)
    {
        case CPSS_PCL_LOOKUP_0_E:
        case CPSS_PCL_LOOKUP_0_0_E:
            lookupIndex = 0;
            break;
        case CPSS_PCL_LOOKUP_0_1_E:
            lookupIndex = 1;
            break;
        case CPSS_PCL_LOOKUP_1_E:
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            lookupIndex = 2;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr =
        PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).lookupSourceIDMask[lookupIndex];

    return prvCpssHwPpGetRegField(devNum, regAddr, 0, 12, maskPtr);
}

/**
* @internal cpssDxChPclSourceIdMaskGet function
* @endinternal
*
* @brief   Get mask used for source ID modify due to PCL action.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] lookupNum                - lookup number
*
* @param[out] maskPtr                  - (pointer to) Source ID mask (APPLICABLE RANGES: 0..4095)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise.
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclSourceIdMaskGet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum,
    OUT GT_U32                      *maskPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclSourceIdMaskGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, lookupNum, maskPtr));

    rc = internal_cpssDxChPclSourceIdMaskGet(devNum, lookupNum, maskPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, lookupNum, maskPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclIpPayloadMinSizeSet function
* @endinternal
*
* @brief   Set the IP payload minimum size. This value will determine the Layer 4
*         validity
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] ipPayloadMinSize         - the IP payload minimum size
*                                      (APPLICABLE RANGES: 0..16383)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The L4_Valid in the packet descriptor will be cleared if:
*       For IPv4: total length - header length < IP payload minimum size
*       For IPv6: payload length < IP payload minimum size
*
*/
static GT_STATUS internal_cpssDxChPclIpPayloadMinSizeSet
(
    IN GT_U8        devNum,
    IN GT_U32       ipPayloadMinSize
)
{
    GT_U32      regAddr;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    if ((CHECK_BITS_DATA_RANGE_MAC(ipPayloadMinSize, 14)) == GT_FALSE)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).IPLengthChecks;

    return prvCpssHwPpSetRegField(devNum, regAddr, 12, 14, ipPayloadMinSize);
}

/**
* @internal cpssDxChPclIpPayloadMinSizeSet function
* @endinternal
*
* @brief   Set the IP payload minimum size. This value will determine the Layer 4
*         validity
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] ipPayloadMinSize         - the IP payload minimum size
*                                      (APPLICABLE RANGES: 0..16383)
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The L4_Valid in the packet descriptor will be cleared if:
*       For IPv4: total length - header length < IP payload minimum size
*       For IPv6: payload length < IP payload minimum size
*
*/
GT_STATUS cpssDxChPclIpPayloadMinSizeSet
(
    IN GT_U8        devNum,
    IN GT_U32       ipPayloadMinSize
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclIpPayloadMinSizeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ipPayloadMinSize));

    rc = internal_cpssDxChPclIpPayloadMinSizeSet(devNum, ipPayloadMinSize);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ipPayloadMinSize));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclIpPayloadMinSizeGet function
* @endinternal
*
* @brief   Get the IP payload minimum size. This value will determine the Layer 4
*         validity
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] ipPayloadMinSizePtr      - the IP payload minimum size
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The L4_Valid in the packet descriptor will be cleared if:
*       For IPv4: total length - header length < IP payload minimum size
*       For IPv6: payload length < IP payload minimum size
*
*/
static GT_STATUS internal_cpssDxChPclIpPayloadMinSizeGet
(
    IN  GT_U8       devNum,
    OUT GT_U32      *ipPayloadMinSizePtr
)
{
    GT_U32      regAddr;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(ipPayloadMinSizePtr);

    regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).IPLengthChecks;

    return prvCpssHwPpGetRegField(devNum, regAddr, 12, 14, ipPayloadMinSizePtr);
}

/**
* @internal cpssDxChPclIpPayloadMinSizeGet function
* @endinternal
*
* @brief   Get the IP payload minimum size. This value will determine the Layer 4
*         validity
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] ipPayloadMinSizePtr      - the IP payload minimum size
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - on wrong input parameters
* @retval GT_HW_ERROR              - failed to write to hardware
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* @note The L4_Valid in the packet descriptor will be cleared if:
*       For IPv4: total length - header length < IP payload minimum size
*       For IPv6: payload length < IP payload minimum size
*
*/
GT_STATUS cpssDxChPclIpPayloadMinSizeGet
(
    IN  GT_U8       devNum,
    OUT GT_U32      *ipPayloadMinSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclIpPayloadMinSizeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ipPayloadMinSizePtr));

    rc = internal_cpssDxChPclIpPayloadMinSizeGet(devNum, ipPayloadMinSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ipPayloadMinSizePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet function
* @endinternal
*
* @brief   Function enables/disables for ingress analyzed packet the using of VID from
*         the incoming packet to access the EPCL Configuration table and for lookup
*         keys generation.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - GT_TRUE  - use original VID
*                                      GT_FALSE - use VLAN assigned by the processing pipe
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet
(
    IN  GT_U8        devNum,
    IN  GT_BOOL      enable
)
{
    GT_U32    regAddr;       /* register address */
    GT_U32    value;         /* register value */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egrPolicyGlobalConfig;

    value = BOOL2BIT_MAC(enable);
    return prvCpssHwPpSetRegField(devNum, regAddr, 3, 1, value);
}

/**
* @internal cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet function
* @endinternal
*
* @brief   Function enables/disables for ingress analyzed packet the using of VID from
*         the incoming packet to access the EPCL Configuration table and for lookup
*         keys generation.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] enable                   - GT_TRUE  - use original VID
*                                      GT_FALSE - use VLAN assigned by the processing pipe
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet
(
    IN  GT_U8        devNum,
    IN  GT_BOOL      enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet function
* @endinternal
*
* @brief   Get state of the flag in charge of the using of VID of the incoming packet
*         for ingress analyzed packet to access the EPCL Configuration table and for
*         lookup keys generation.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to)enable/disable the using of original VID.
*                                      GT_TRUE  - use original VID
*                                      GT_FALSE - use VLAN assigned by the processing pipe
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet
(
    IN  GT_U8         devNum,
    OUT GT_BOOL       *enablePtr
)
{
    GT_U32      regAddr;       /* register address */
    GT_U32      hwValue;       /* HW Value */
    GT_STATUS   rc;            /* return code  */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egrPolicyGlobalConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 3, 1, &hwValue);
    if (rc != GT_OK)
    {
        return rc;
    }
    *enablePtr = BIT2BOOL_MAC(hwValue);
    return GT_OK;
}

/**
* @internal cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet function
* @endinternal
*
* @brief   Get state of the flag in charge of the using of VID of the incoming packet
*         for ingress analyzed packet to access the EPCL Configuration table and for
*         lookup keys generation.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
*
* @param[out] enablePtr                - (pointer to)enable/disable the using of original VID.
*                                      GT_TRUE  - use original VID
*                                      GT_FALSE - use VLAN assigned by the processing pipe
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong parameters
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet
(
    IN  GT_U8         devNum,
    OUT GT_BOOL       *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPclEgressSubLookupPhaInfoSet function
* @endinternal
*
* @brief   Function sets the masks for PHA related info that will
*          be overridden by the specific sub-lookup.
*       NOTE: relate only to EPCL (Egress PCL)
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; .
*
* @param[in] devNum                   - device number
* @param[in] subLookupNum             - sub lookup number for lookup.
*                                      (APPLICABLE RANGES: 0..3).
* @param[in] phaMetadataMask          - the PHA 'meta data' mask for this sub-lookup.(32 bits mask)
* @param[in] phaThreadIdMask          - the PHA 'thread Id' mask for this sub-lookup.( 8 bits mask)
*                                      (APPLICABLE RANGES: 0..255).
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong devNum or subLookupNum or phaThreadIdMask
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_INITIALIZED       - the PHA library was not initialized
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclEgressSubLookupPhaInfoSet
(
    IN GT_U8        devNum,
    IN GT_U32       subLookupNum,
    IN GT_U32       phaMetadataMask,
    IN GT_U32       phaThreadIdMask
)
{
    GT_STATUS   rc;
    GT_U32  regAddr;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E);

    /******************************************/
    /* check that the PHA LIB was initialized */
    /******************************************/
    PRV_CPSS_DXCH_PHA_LIB_INIT_CHECK_MAC(devNum);

    CPSS_PARAM_CHECK_MAX_MAC(subLookupNum,4);
    CPSS_PARAM_CHECK_MAX_MAC(phaThreadIdMask,BIT_8);

    switch(subLookupNum)
    {
        default:
        case 0:
            regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).PHAMetadataMask1;
            break;
        case 1:
            regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).PHAMetadataMask2;
            break;
        case 2:
            regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).PHAMetadataMask3;
            break;
        case 3:
            regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).PHAMetadataMask4;
            break;
    }

    rc = prvCpssHwPpWriteRegister(devNum,regAddr,phaMetadataMask);
    if(rc != GT_OK)
    {
        return rc;
    }

    regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).PHAThreadNumMask;

    return prvCpssHwPpSetRegField(devNum,regAddr,8*subLookupNum,8,phaThreadIdMask);
}

/**
* @internal cpssDxChPclEgressSubLookupPhaInfoSet function
* @endinternal
*
* @brief   Function sets the masks for PHA related info that will
*          be overridden by the specific sub-lookup.
*       NOTE: relate only to EPCL (Egress PCL)
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; .
*
* @param[in] devNum                   - device number
* @param[in] subLookupNum             - sub lookup number for lookup.
*                                      (APPLICABLE RANGES: 0..3).
* @param[in] phaMetadataMask          - the PHA 'meta data' mask for this sub-lookup.(32 bits mask)
* @param[in] phaThreadIdMask          - the PHA 'thread Id' mask for this sub-lookup.( 8 bits mask)
*                                      (APPLICABLE RANGES: 0..255).
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong devNum or subLookupNum or phaThreadIdMask
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_INITIALIZED       - the PHA library was not initialized
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclEgressSubLookupPhaInfoSet
(
    IN GT_U8        devNum,
    IN GT_U32       subLookupNum,
    IN GT_U32       phaMetadataMask,
    IN GT_U32       phaThreadIdMask
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressSubLookupPhaInfoSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, subLookupNum, phaMetadataMask, phaThreadIdMask));

    rc = internal_cpssDxChPclEgressSubLookupPhaInfoSet(devNum, subLookupNum, phaMetadataMask, phaThreadIdMask);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, subLookupNum, phaMetadataMask, phaThreadIdMask));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEgressSubLookupPhaInfoGet function
* @endinternal
*
* @brief   Function gets the masks for PHA related info that will
*          be overridden by the specific sub-lookup.
*       NOTE: relate only to EPCL (Egress PCL)
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; .
*
* @param[in] devNum                   - device number
* @param[in] subLookupNum             - sub lookup number for lookup.
*                                      (APPLICABLE RANGES: 0..3).
* @param[out] phaMetadataMaskPtr      - (pointer to)the PHA 'meta data' mask for this sub-lookup.(32 bits mask)
* @param[out] phaThreadIdMaskPtr      - (pointer to)the PHA 'thread Id' mask for this sub-lookup.( 8 bits mask)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong devNum or subLookupNum
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_INITIALIZED       - the PHA library was not initialized
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclEgressSubLookupPhaInfoGet
(
    IN GT_U8        devNum,
    IN GT_U32       subLookupNum,
    OUT GT_U32      *phaMetadataMaskPtr,
    OUT GT_U32      *phaThreadIdMaskPtr
)
{
    GT_STATUS   rc;
    GT_U32  regAddr;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E);

    /******************************************/
    /* check that the PHA LIB was initialized */
    /******************************************/
    PRV_CPSS_DXCH_PHA_LIB_INIT_CHECK_MAC(devNum);

    CPSS_PARAM_CHECK_MAX_MAC(subLookupNum,4);
    CPSS_NULL_PTR_CHECK_MAC(phaMetadataMaskPtr);
    CPSS_NULL_PTR_CHECK_MAC(phaThreadIdMaskPtr);

    switch(subLookupNum)
    {
        default:
        case 0:
            regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).PHAMetadataMask1;
            break;
        case 1:
            regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).PHAMetadataMask2;
            break;
        case 2:
            regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).PHAMetadataMask3;
            break;
        case 3:
            regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).PHAMetadataMask4;
            break;
    }

    rc = prvCpssHwPpReadRegister(devNum,regAddr,phaMetadataMaskPtr);
    if(rc != GT_OK)
    {
        return rc;
    }

    regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).PHAThreadNumMask;

    return prvCpssHwPpGetRegField(devNum,regAddr,8*subLookupNum,8,phaThreadIdMaskPtr);
}

/**
* @internal cpssDxChPclEgressSubLookupPhaInfoGet function
* @endinternal
*
* @brief   Function gets the masks for PHA related info that will
*          be overridden by the specific sub-lookup.
*       NOTE: relate only to EPCL (Egress PCL)
*
* @note   APPLICABLE DEVICES:      Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; .
*
* @param[in] devNum                   - device number
* @param[in] subLookupNum             - sub lookup number for lookup.
*                                      (APPLICABLE RANGES: 0..3).
* @param[out] phaMetadataMaskPtr      - (pointer to)the PHA 'meta data' mask for this sub-lookup.(32 bits mask)
* @param[out] phaThreadIdMaskPtr      - (pointer to)the PHA 'thread Id' mask for this sub-lookup.( 8 bits mask)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - on wrong devNum or subLookupNum
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_INITIALIZED       - the PHA library was not initialized
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclEgressSubLookupPhaInfoGet
(
    IN GT_U8        devNum,
    IN GT_U32       subLookupNum,
    OUT GT_U32      *phaMetadataMaskPtr,
    OUT GT_U32      *phaThreadIdMaskPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEgressSubLookupPhaInfoGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, subLookupNum, phaMetadataMaskPtr, phaThreadIdMaskPtr));

    rc = internal_cpssDxChPclEgressSubLookupPhaInfoGet(devNum, subLookupNum, phaMetadataMaskPtr, phaThreadIdMaskPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, subLookupNum, phaMetadataMaskPtr, phaThreadIdMaskPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal prvUtilCpssDxChPclRuleDump function
* @endinternal
*
* @brief   Dump PCL rule
*
* @note     APPLICABLE DEVICES:   xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of rule
* @param[in] ruleIndex                - index of rule
* @param[in] maskArr[]                - mask words array
* @param[in] patternArr[]             - pattern words array
* @param[in] actionArr[]              - action words array
*
* @retval None
*/
static void prvUtilCpssDxChPclRuleDump
(
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN GT_U32                             maskArr[],
    IN GT_U32                             patternArr[],
    IN GT_U32                             actionArr[]
)
{
    static const GT_U32 firstLineWords = 8;
    static const GT_U32 nextLineWords = 10;
    GT_U32 wordsNum;
    GT_U32 i;

    /* strings with the same printed length */
    static const char maskHdr[]   =   "# %04X M ";
    static const char pattHdr[]   = "\n       P ";
    static const char actnHdr[]   = "\n       A ";
    static const char lineBreak[] = "\n         ";


    /* ULTRA rule for XCAT2 hal unused high halfwords in words 6,13,20 */
    /* for SIP5 it is 80 bytes and 20 words is enough                 */
    switch (ruleSize)
    {
        case CPSS_PCL_RULE_SIZE_STD_E:       wordsNum =   8;  break;
        case CPSS_PCL_RULE_SIZE_EXT_E:       wordsNum =  15;  break;
        case CPSS_PCL_RULE_SIZE_ULTRA_E:     wordsNum =  21;  break;
        case CPSS_PCL_RULE_SIZE_10_BYTES_E:  wordsNum =   3;  break;
        case CPSS_PCL_RULE_SIZE_20_BYTES_E:  wordsNum =   5;  break;
        case CPSS_PCL_RULE_SIZE_40_BYTES_E:  wordsNum =  10;  break;
        case CPSS_PCL_RULE_SIZE_50_BYTES_E:  wordsNum =  13;  break;
        default:                             wordsNum =  20;  break;
    }

    /* mask */
    cpssOsPrintf(maskHdr, ruleIndex);
    for (i = 0; (i < wordsNum); i++)
    {
        if ((i % nextLineWords) == firstLineWords)
        {
            cpssOsPrintf(lineBreak);
        }
        cpssOsPrintf("%08X ", maskArr[i]);
    }

    /* pattern */
    cpssOsPrintf(pattHdr);
    for (i = 0; (i < wordsNum); i++)
    {
        if ((i % nextLineWords) == firstLineWords)
        {
            cpssOsPrintf(lineBreak);
        }
        cpssOsPrintf("%08X ", patternArr[i]);
    }

    /* action */
    cpssOsPrintf(actnHdr);
    for (i = 0; (i < CPSS_DXCH_PCL_ACTION_SIZE_IN_WORDS_CNS); i++)
    {
        cpssOsPrintf("%08X ", actionArr[i]);
    }
    cpssOsPrintf("\n");
}

/**
* @internal internal_cpssDxChPclRulesDump function
* @endinternal
*
* @brief    Dump all valid PCL rules of specified size.
*
* @note     APPLICABLE DEVICES:   xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                       NOTEs:
*                                       1. for non multi-port groups device this parameter is IGNORED.
*                                       2. for multi-port groups device :
*                                          (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                          bitmap must be set with at least one bit representing
*                                          valid port group(s). If a bit of non valid port group
*                                          is set then function returns GT_BAD_PARAM.
*                                          value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of rule
* @param[in] startIndex               - index of first rule
* @param[in] rulesAmount              - number of rules to scan and dump
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong parameter
* @retval GT_BAD_PTR               - null pointer
* @retval GT_OUT_OF_RANGE          - on trying to dump rules from powered down TCAM floors
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
static GT_STATUS internal_cpssDxChPclRulesDump
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             startIndex,
    IN GT_U32                             rulesAmount
)
{
    GT_U32                  ruleIndex;
    CPSS_PCL_RULE_SIZE_ENT  actualSize;
    GT_BOOL                 isValid;
    GT_U32                  actionArr[CPSS_DXCH_PCL_ACTION_SIZE_IN_WORDS_CNS];
    GT_U32                  maskArr[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS];
    GT_U32                  patternArr[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS];
    GT_U32                  numOfActiveFloors = 0;
    GT_STATUS               rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        /* Get the number of active floors */
        rc = cpssDxChTcamPortGroupActiveFloorsGet(devNum, portGroupsBmp, &numOfActiveFloors);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Check whether range of rule indexes are within the allowed max number of rules per active floor */
        if((startIndex + rulesAmount) > (CPSS_DXCH_TCAM_MAX_NUM_RULES_PER_FLOOR_CNS * numOfActiveFloors))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
    }

    for (ruleIndex = startIndex; ruleIndex <= (startIndex + rulesAmount); ruleIndex++)
    {
        rc = cpssDxChPclPortGroupRuleAnyStateGet(
            devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex,
            &isValid, &actualSize);
        if (rc == GT_BAD_PARAM)
        {
            /* In case of bad rule index*/
            continue;
        }
        else if ((rc != GT_OK)  && (rc != GT_BAD_STATE))
        {
            return rc;
        }

        if ((isValid == GT_FALSE) || (rc != GT_OK) || (actualSize != ruleSize))
        {
            continue;
        }

        rc = cpssDxChPclPortGroupRuleGet(
            devNum, portGroupsBmp, tcamIndex, ruleSize, ruleIndex,
            maskArr, patternArr, actionArr);
        if (rc != GT_OK)
        {
            cpssOsPrintf("cpssDxChPclRuleGet error: index %d rc %d\n", ruleIndex, rc);
            return rc;
        }

        /* dump rule */
        prvUtilCpssDxChPclRuleDump(ruleSize, ruleIndex, maskArr, patternArr, actionArr);
    }

    return GT_OK;
}

/**
* @internal cpssDxChPclRulesDump function
* @endinternal
*
* @brief    Dump all valid PCL rules of specified size.
*
* @note     APPLICABLE DEVICES:   xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                       NOTEs:
*                                       1. for non multi-port groups device this parameter is IGNORED.
*                                       2. for multi-port groups device :
*                                          (APPLICABLE DEVICES Lion2; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                          bitmap must be set with at least one bit representing
*                                          valid port group(s). If a bit of non valid port group
*                                          is set then function returns GT_BAD_PARAM.
*                                          value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] tcamIndex                - index of the TCAM unit.
*                                       (APPLICABLE DEVICES AC5) (APPLICABLE RANGES 0..1)
* @param[in] ruleSize                 - size of rule
* @param[in] startIndex               - index of first rule
* @param[in] rulesAmount              - number of rules to scan and dump
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong parameter
* @retval GT_BAD_PTR               - null pointer
* @retval GT_OUT_OF_RANGE          - on trying to dump rules from powered down TCAM floors
* @retval GT_BAD_STATE             - For DxCh3 and above if cannot determinate
*                                       the rule size by found X/Y bits of compare mode
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_FAIL                  - otherwise
*/
GT_STATUS cpssDxChPclRulesDump
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN GT_U32                             tcamIndex,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             startIndex,
    IN GT_U32                             rulesAmount
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclRulesDump);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, tcamIndex, ruleSize, startIndex, rulesAmount));

    rc = internal_cpssDxChPclRulesDump(devNum, portGroupsBmp, tcamIndex, ruleSize, startIndex, rulesAmount);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, tcamIndex, ruleSize, startIndex, rulesAmount));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal cpssDxChPclCopyReservedMaskSet function
* @endinternal
*
* @brief   Sets the copyReserved mask for specific direction and lookup stages.  The mask is used to
*          set the bit of the IPCL/EPCL action <copyReserved> field
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                         - device number
* @param[in] direction                      - Policy direction: Ingress or Egress
* @param[in] lookupNum                      - lookup stage number for which mask to be set
* @param[in] mask                           - CopyReserved bit mask for IPCL/EPCL action <copyReserved> Field.
*                                             (APPLICABLE RANGES: Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon 0..0x3FFFF)
*                                             (APPLICABLE RANGES: AC5X; Harrier; Ironman, AC5P 0..0x7FFFF)
*
* @retval GT_OK                             - on success
* @retval GT_OUT_OF_RANGE                   - on out of range value for mask
* @retval GT_BAD_PARAM                      - on wrong value for devNum, direction or lookupNum
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclCopyReservedMaskSet
(
    IN   GT_U8                             devNum,
    IN   CPSS_PCL_DIRECTION_ENT            direction,
    IN   CPSS_PCL_LOOKUP_NUMBER_ENT        lookupNum,
    IN   GT_U32                            mask
)
{
    GT_U32      regAddr;            /* register address     */
    GT_U32      lookupIndex;        /* index in register array for requested lookup */
    GT_U32      copyReservedMask;   /* max range for copyReserved mask */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    copyReservedMask = PRV_CPSS_SIP_6_10_CHECK_MAC(devNum) ? BIT_19 : BIT_18;
    if( mask >= copyReservedMask )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:

            switch (lookupNum)
            {
                case CPSS_PCL_LOOKUP_0_E:
                case CPSS_PCL_LOOKUP_0_0_E:
                    lookupIndex = 0;
                    break;
                case CPSS_PCL_LOOKUP_0_1_E:
                    lookupIndex = 1;
                    break;
                case CPSS_PCL_LOOKUP_1_E:
                    if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                    {
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                    }
                    lookupIndex = 2;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).IPCLReservedBitMask[lookupIndex];
            break;

        case CPSS_PCL_DIRECTION_EGRESS_E:
            regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCLReservedBitMask;
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* IPCL/EPCL action can set bits[19:2] of <copyReserved> for SIP_5 and Falcon */
    /* IPCL/EPCL action can set bits[19:1] of <copyReserved> for SIP_6_10 and above */
    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        return prvCpssHwPpSetRegField(devNum, regAddr, 1, 19, mask);
    }
    else
    {
        return prvCpssHwPpSetRegField(devNum, regAddr, 2, 18, mask);
    }
}

/**
* @internal cpssDxChPclCopyReservedMaskSet function
* @endinternal
*
* @brief   Sets the copyReserved mask for specific direction and lookup stages.  The mask is used to
*          set the bit of the IPCL/EPCL action <copyReserved> field
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                         - device number
* @param[in] direction                      - Policy direction: Ingress or Egress
* @param[in] lookupNum                      - lookup stage number for which mask to be set
* @param[in] mask                           - CopyReserved bit mask for IPCL/EPCL action <copyReserved> Field.
*                                             (APPLICABLE RANGES: Bobcat2, Caelum, Aldrin, AC3X, Bobcat3, Aldrin2, Falcon 0..0x3FFFF)
*                                             (APPLICABLE RANGES: AC5X; Harrier; Ironman, AC5P 0..0x7FFFF)
*
* @retval GT_OK                             - on success
* @retval GT_OUT_OF_RANGE                   - on out of range value for mask
* @retval GT_BAD_PARAM                      - on wrong value for devNum, direction or lookupNum
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
GT_STATUS cpssDxChPclCopyReservedMaskSet
(
    IN   GT_U8                             devNum,
    IN   CPSS_PCL_DIRECTION_ENT            direction,
    IN   CPSS_PCL_LOOKUP_NUMBER_ENT        lookupNum,
    IN   GT_U32                            mask
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclCopyReservedMaskSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, lookupNum, mask));

    rc = internal_cpssDxChPclCopyReservedMaskSet(devNum, direction, lookupNum, mask);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, lookupNum, mask));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclCopyReservedMaskGet function
* @endinternal
*
* @brief  Get the mask based on specific direction(ingress/egress) and lookup stage
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                  - device number
* @param[in] direction               - Policy direction: Ingress or Egress
* @param[in] lookupNum               - lookup stage number for which mask to be set
*
* @param[out] maskPtr                 - (pointer to) copyReserved bit mask for IPCL action <copyReserved> Field.
*
* @retval GT_OK                      - on success
* @retval GT_BAD_PARAM               - on wrong values of devNum, direction and lookupNum
* @retval GT_HW_ERROR                - on hardware error
* @retval GT_BAD_PTR                 - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE   - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclCopyReservedMaskGet
(
    IN    GT_U8                          devNum,
    IN    CPSS_PCL_DIRECTION_ENT         direction,
    IN    CPSS_PCL_LOOKUP_NUMBER_ENT     lookupNum,
    OUT   GT_U32                        *maskPtr
)
{
    GT_U32      regAddr;     /* register address     */
    GT_U32      lookupIndex; /* index in register array for requested lookup */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(maskPtr);

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:

            switch (lookupNum)
            {
                case CPSS_PCL_LOOKUP_0_E:
                case CPSS_PCL_LOOKUP_0_0_E:
                    lookupIndex = 0;
                    break;
                case CPSS_PCL_LOOKUP_0_1_E:
                    lookupIndex = 1;
                    break;
                case CPSS_PCL_LOOKUP_1_E:
                    if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                    {
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                    }
                    lookupIndex = 2;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).IPCLReservedBitMask[lookupIndex];
            break;

        case CPSS_PCL_DIRECTION_EGRESS_E:
            regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).EPCLReservedBitMask;
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
    {
        return prvCpssHwPpGetRegField(devNum, regAddr, 1, 19, maskPtr);
    }
    else
    {
        return prvCpssHwPpGetRegField(devNum, regAddr, 2, 18, maskPtr);
    }
}
/**
* @internal cpssDxChPclCopyReservedMaskGet function
* @endinternal
*
* @brief  Get the mask based on specific direction(ingress/egress) and lookup stage
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                  - device number
* @param[in] direction               - Policy direction: Ingress or Egress
* @param[in] lookupNum               - lookup stage number for which mask to be set
*
* @param[out] maskPtr                 - (pointer to) copyReserved bit mask for IPCL action <copyReserved> Field.
*
* @retval GT_OK                      - on success
* @retval GT_BAD_PARAM               - on wrong devNum, direction and lookupNum
* @retval GT_HW_ERROR                - on hardware error
* @retval GT_BAD_PTR                 - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE   - on not applicable device
*/

GT_STATUS cpssDxChPclCopyReservedMaskGet
(
    IN    GT_U8                          devNum,
    IN    CPSS_PCL_DIRECTION_ENT         direction,
    IN    CPSS_PCL_LOOKUP_NUMBER_ENT     lookupNum,
    OUT   GT_U32                        *maskPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclCopyReservedMaskGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, lookupNum, maskPtr));

    rc = internal_cpssDxChPclCopyReservedMaskGet(devNum, direction, lookupNum, maskPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, lookupNum, maskPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclTriggerHashCncClientMaskSet function
* @endinternal
*
* @brief   Enable/disable of CNC Hash client trigger overwrite by specific lookup stage
*
* @note   APPLICABLE DEVICES:      Falcon;
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman; xCat3; AC5; Lion2.
*
* @param[in] devNum                         - device number
* @param[in] lookupNum                      - lookup stage number for which mask to be set
* @param[in] maskEn                         - GT_TRUE - enable overwrite by IPCL action
*                                             GT_FALSE - disable overwrite by IPCL action.
*
* @retval GT_OK                             - on success
* @retval GT_BAD_PARAM                      - on wrong value devNum or lookupNum
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclTriggerHashCncClientMaskSet
(
    IN   GT_U8                             devNum,
    IN   CPSS_PCL_LOOKUP_NUMBER_ENT        lookupNum,
    IN   GT_BOOL                           maskEn
)
{
    GT_U32      regAddr;     /* register address     */
    GT_U32      lookupIndex; /* index in register array for requested lookup */
    GT_U32      value;       /* data to write to register */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
                                           CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    /* Get index for IPCL lookup */
    switch (lookupNum)
    {
        case CPSS_PCL_LOOKUP_0_E:
        case CPSS_PCL_LOOKUP_0_0_E:
            lookupIndex = 0;
            break;
        case CPSS_PCL_LOOKUP_0_1_E:
            lookupIndex = 1;
            break;
        case CPSS_PCL_LOOKUP_1_E:
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            lookupIndex = 2;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* Get register address */
    regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).IPCLReservedBitMask[lookupIndex];

    /* Convert bool type to int so it can be written to HW register */
    value = BOOL2BIT_MAC(maskEn);

    /* IPCL action set bit #1 of <copyReserved> */
    return prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, value);
}

/**
* @internal cpssDxChPclTriggerHashCncClientMaskSet function
* @endinternal
*
* @brief   Enable/disable of CNC Hash client trigger overwrite by specific lookup stage
*
* @note   APPLICABLE DEVICES:      Falcon;
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman; xCat3; AC5; Lion2.
*
* @param[in] devNum                         - device number
* @param[in] lookupNum                      - lookup stage number for which mask to be set
* @param[in] maskEn                         - GT_TRUE - enable overwrite by IPCL action
*                                             GT_FALSE - disable overwrite by IPCL action.
*
* @retval GT_OK                             - on success
* @retval GT_BAD_PARAM                      - on wrong value devNum or lookupNum
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
GT_STATUS cpssDxChPclTriggerHashCncClientMaskSet
(
    IN   GT_U8                             devNum,
    IN   CPSS_PCL_LOOKUP_NUMBER_ENT        lookupNum,
    IN   GT_BOOL                           maskEn
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclTriggerHashCncClientMaskSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, lookupNum, maskEn));

    rc = internal_cpssDxChPclTriggerHashCncClientMaskSet(devNum, lookupNum, maskEn);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, lookupNum, maskEn));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclTriggerHashCncClientMaskGet function
* @endinternal
*
* @brief  Get the mask of CNC Hash client trigger based on specific lookup stage
*
* @note   APPLICABLE DEVICES:      Falcon;
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman; xCat3; AC5; Lion2.
*
* @param[in] devNum                  - device number
* @param[in] lookupNum               - lookup stage number for which mask to be set
*
* @param[out] maskPtr                - (pointer to) overwrite mask by IPCL action state
*
* @retval GT_OK                      - on success
* @retval GT_BAD_PARAM               - on wrong value for devNum or lookupNum
* @retval GT_HW_ERROR                - on hardware error
* @retval GT_BAD_PTR                 - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE   - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclTriggerHashCncClientMaskGet
(
    IN    GT_U8                          devNum,
    IN    CPSS_PCL_LOOKUP_NUMBER_ENT     lookupNum,
    OUT   GT_BOOL                        *maskPtr
)
{
    GT_STATUS   rc = GT_OK;  /* rc status                                    */
    GT_U32      regAddr;     /* register address                             */
    GT_U32      lookupIndex; /* index in register array for requested lookup */
    GT_U32      value;       /* data to read from register                   */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
                                           CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_BOBCAT3_E | CPSS_ALDRIN2_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E | CPSS_IRONMAN_E);

    CPSS_NULL_PTR_CHECK_MAC(maskPtr);

    /* Get index for IPCL lookup */
    switch (lookupNum)
    {
        case CPSS_PCL_LOOKUP_0_E:
        case CPSS_PCL_LOOKUP_0_0_E:
            lookupIndex = 0;
            break;
        case CPSS_PCL_LOOKUP_0_1_E:
            lookupIndex = 1;
            break;
        case CPSS_PCL_LOOKUP_1_E:
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            lookupIndex = 2;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* Get register address */
    regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).IPCLReservedBitMask[lookupIndex];

    /* IPCL action get bit #1 value of <copyReserved> */
    rc = prvCpssHwPpGetRegField(devNum, regAddr, 1, 1, &value);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Write value to output parameter */
    *maskPtr = BIT2BOOL_MAC(value);

    return rc;
}


/**
* @internal cpssDxChPclTriggerHashCncClientMaskGet function
* @endinternal
*
* @brief  Get the mask of CNC Hash client trigger based on specific lookup stage
*
* @note   APPLICABLE DEVICES:      Falcon;
* @note   NOT APPLICABLE DEVICES:  Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; AC5P; AC5X; Harrier; Ironman; xCat3; AC5; Lion2.
*
* @param[in] devNum                  - device number
* @param[in] lookupNum               - lookup stage number for which mask to be set
*
* @param[out] maskPtr                - (pointer to) overwrite by IPCL action state
*
* @retval GT_OK                      - on success
* @retval GT_BAD_PARAM               - on wrong value for devNum or lookupNum
* @retval GT_HW_ERROR                - on hardware error
* @retval GT_BAD_PTR                 - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE   - on not applicable device
*/
GT_STATUS cpssDxChPclTriggerHashCncClientMaskGet
(
    IN    GT_U8                          devNum,
    IN    CPSS_PCL_LOOKUP_NUMBER_ENT     lookupNum,
    OUT   GT_BOOL                        *maskPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclTriggerHashCncClientMaskGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, lookupNum, maskPtr));

    rc = internal_cpssDxChPclTriggerHashCncClientMaskGet(devNum, lookupNum, maskPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, lookupNum, maskPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet function
* @endinternal
*
* @brief   Sets Map Configuration Table Entry Profile Id to TCAM Profile Id
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                         - device number
* @param[in] direction                      - Policy direction: Ingress or Egress
* @param[in] packetType                     - packet Type
* @param[in] cfgTableEmProfileId            - Configuration Table Entry EM Profile Id (used 4 LSBs only)
*                                             (APPLICABLE RANGES: 0 ... 15)
* @param[in] tcamProfileId                  - TCAM Profile Id.
*                                             (APPLICABLE RANGES: 0 ... 63)
*
* @retval GT_OK                             - on success
* @retval GT_BAD_PARAM                      - on wrong parameter value
* @retval GT_OUT_OF_RANGE                   - on out-of-range parameter value
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet
(
    IN   GT_U8                             devNum,
    IN   CPSS_PCL_DIRECTION_ENT            direction,
    IN   CPSS_DXCH_PCL_PACKET_TYPE_ENT     packetType,
    IN   GT_U32                            cfgTableEmProfileId,
    IN   GT_U32                            tcamProfileId
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;
    GT_U32      packetTypeIndex;
    GT_U32      index;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
        CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E);

    if (cfgTableEmProfileId  >=  16)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    if (tcamProfileId  >=  64)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    rc = sip5PclUDBEntryIndexGet(
        devNum, packetType, &packetTypeIndex);
    if (rc != GT_OK)
    {
        return rc;
    }

    index = ((packetTypeIndex & 0xF) << 4) | (cfgTableEmProfileId & 0xF);

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).exactMatchProfileIdMapEntry[index];
            return prvCpssHwPpSetRegField(devNum, regAddr, 8, 6, tcamProfileId);

        case CPSS_PCL_DIRECTION_EGRESS_E:
            return prvCpssDxChWriteTableEntryField(
                devNum, CPSS_DXCH_SIP6_TABLE_EGRESS_PCL_EXACT_MATCH_PROFILE_ID_MAPPING_E,
                index /*EntryIndex*/,
                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS, 8, 6, tcamProfileId);

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
}

/**
* @internal cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet function
* @endinternal
*
* @brief   Sets Map Configuration Table Entry Profile Id to TCAM Profile Id
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                         - device number
* @param[in] direction                      - Policy direction: Ingress or Egress
* @param[in] packetType                     - packet Type
* @param[in] cfgTableEmProfileId            - Configuration Table Entry EM Profile Id (used 4 LSBs only)
*                                             (APPLICABLE RANGES: 0 ... 15)
* @param[in] tcamProfileId                  - TCAM Profile Id.
*                                             (APPLICABLE RANGES: 0 ... 63)
*
* @retval GT_OK                             - on success
* @retval GT_BAD_PARAM                      - on wrong parameter value
* @retval GT_OUT_OF_RANGE                   - on out-of-range parameter value
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
GT_STATUS cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet
(
    IN   GT_U8                             devNum,
    IN   CPSS_PCL_DIRECTION_ENT            direction,
    IN   CPSS_DXCH_PCL_PACKET_TYPE_ENT     packetType,
    IN   GT_U32                            cfgTableEmProfileId,
    IN   GT_U32                            tcamProfileId
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, packetType, cfgTableEmProfileId, tcamProfileId));

    rc = internal_cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet(
        devNum, direction, packetType, cfgTableEmProfileId, tcamProfileId);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, packetType, cfgTableEmProfileId, tcamProfileId));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet function
* @endinternal
*
* @brief   Gets Map Configuration Table Entry Profile Id to TCAM Profile Id
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                         - device number
* @param[in] direction                      - Policy direction: Ingress or Egress
* @param[in] packetType                     - packet Type
* @param[in] cfgTableEmProfileId            - Configuration Table Entry EM Profile Id (used 4 LSBs only)
*                                             (APPLICABLE RANGES: 0 ... 15)
* @param[out] tcamProfileIdPtr              - (Pointer to)TCAM Profile Id.
*
* @retval GT_OK                             - on success
* @retval GT_BAD_PARAM                      - on wrong parameter value
* @retval GT_BAD_PTR                        - on NULL pointer parameter value
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet
(
    IN   GT_U8                             devNum,
    IN   CPSS_PCL_DIRECTION_ENT            direction,
    IN   CPSS_DXCH_PCL_PACKET_TYPE_ENT     packetType,
    IN   GT_U32                            cfgTableEmProfileId,
    OUT  GT_U32                            *tcamProfileIdPtr
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;
    GT_U32      packetTypeIndex;
    GT_U32      index = 0;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
        CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E);
    CPSS_NULL_PTR_CHECK_MAC(tcamProfileIdPtr);

    if (cfgTableEmProfileId  >=  16)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = sip5PclUDBEntryIndexGet(
        devNum, packetType, &packetTypeIndex);
    if (rc != GT_OK)
    {
        return rc;
    }

    index = ((packetTypeIndex & 0xF) << 4) | (cfgTableEmProfileId & 0xF);

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:
            regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).exactMatchProfileIdMapEntry[index];
            return prvCpssHwPpGetRegField(devNum, regAddr, 8, 6, tcamProfileIdPtr);

        case CPSS_PCL_DIRECTION_EGRESS_E:
            return prvCpssDxChReadTableEntryField(
                devNum, CPSS_DXCH_SIP6_TABLE_EGRESS_PCL_EXACT_MATCH_PROFILE_ID_MAPPING_E,
                index /*EntryIndex*/,
                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS, 8, 6, tcamProfileIdPtr);

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
}

/**
* @internal cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet function
* @endinternal
*
* @brief   Gets Map Configuration Table Entry Profile Id to TCAM Profile Id
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                         - device number
* @param[in] direction                      - Policy direction: Ingress or Egress
* @param[in] packetType                     - packet Type
* @param[in] cfgTableEmProfileId            - Configuration Table Entry EM Profile Id (used 4 LSBs only)
*                                             (APPLICABLE RANGES: 0 ... 15)
* @param[out] tcamProfileIdPtr              - (Pointer to)TCAM Profile Id.
*
* @retval GT_OK                             - on success
* @retval GT_BAD_PARAM                      - on wrong parameter value
* @retval GT_BAD_PTR                        - on NULL pointer parameter value
* @retval GT_HW_ERROR                       - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE          - on not applicable device
*/
GT_STATUS cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet
(
    IN   GT_U8                             devNum,
    IN   CPSS_PCL_DIRECTION_ENT            direction,
    IN   CPSS_DXCH_PCL_PACKET_TYPE_ENT     packetType,
    IN   GT_U32                            cfgTableEmProfileId,
    OUT  GT_U32                            *tcamProfileIdPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, packetType, cfgTableEmProfileId, tcamProfileIdPtr));

    rc = internal_cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet(
        devNum, direction, packetType, cfgTableEmProfileId, tcamProfileIdPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, packetType, cfgTableEmProfileId, tcamProfileIdPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortPclId2Set function
* @endinternal
*
* @brief   Set source/target port PCL-ID2 value per lookup stage
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; AC5 Bobcat3; Aldrin2; Falcon;
*
* @param[in] devNum                  - device number
* @param[in] portNum                 - port number
* @param[in] direction               - Policy direction: Ingress or Egress
* @param[in] lookupNum               - lookup stage number for which port PCL-ID2 need to be configured
* @param[in] portPclId2              - PCL-ID2 bytes to be included in PCL lookup key
*                                      (APPLICABLE RANGE: 0...FFFFFF)
*
* @retval GT_OK               - on success
* @retval GT_HW_ERROR         - on hardware error
* @retval GT_BAD_PARAM        - on wrong device or port number, direction or lookupNum
* @retval GT_OUT_OF_RANGE     - portPclId2 value is out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclPortPclId2Set
(
    IN GT_U8                         devNum,
    IN GT_PHYSICAL_PORT_NUM          portNum,
    IN CPSS_PCL_DIRECTION_ENT        direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN GT_U32                        portPclId2
)
{

    CPSS_DXCH_TABLE_ENT      tableName;   /* Table name */
    GT_U32                   tableOffset; /* Offset of required table */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum, portNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
        CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E);

    if(portPclId2 >= BIT_24 )
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:

           switch (lookupNum)
            {
                case CPSS_PCL_LOOKUP_0_E:
                case CPSS_PCL_LOOKUP_0_0_E:
                    tableName = CPSS_DXCH_SIP6_10_TABLE_IPCL0_SOURCE_PORT_CONFIG_E;
                    break;
                case CPSS_PCL_LOOKUP_0_1_E:
                    tableName = CPSS_DXCH_SIP6_10_TABLE_IPCL1_SOURCE_PORT_CONFIG_E;
                    break;
                case CPSS_PCL_LOOKUP_1_E:
                    if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                    {
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                    }
                    tableName = CPSS_DXCH_SIP6_10_TABLE_IPCL2_SOURCE_PORT_CONFIG_E;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            tableOffset = 0;
            break;

        case CPSS_PCL_DIRECTION_EGRESS_E:
            tableName = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E;
            tableOffset = 27;
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return prvCpssDxChWriteTableEntryField(
                devNum, tableName,
                portNum /*EntryIndex*/,
                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS, tableOffset, 24, portPclId2);
}

/**
* @internal cpssDxChPclPortPclId2Set function
* @endinternal
*
* @brief   Set source/target port PCL-ID2 value per lookup stage
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; AC5 Bobcat3; Aldrin2; Falcon;
*
* @param[in] devNum                  - device number
* @param[in] portNum                 - port number
* @param[in] direction               - Policy direction: Ingress or Egress
* @param[in] lookupNum               - lookup stage number for which port PCL-ID2 need to be configured
* @param[in] portPclId2              - PCL-ID2 bytes to be included in PCL lookup key
*
* @retval GT_OK               - on success
* @retval GT_HW_ERROR         - on hardware error
* @retval GT_BAD_PARAM        - on wrong device or port number, direction or lookupNum
* @retval GT_OUT_OF_RANGE     - portPclId2 value is out of range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclPortPclId2Set
(
    IN GT_U8                         devNum,
    IN GT_PHYSICAL_PORT_NUM          portNum,
    IN CPSS_PCL_DIRECTION_ENT        direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN GT_U32                        portPclId2
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortPclId2Set);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((devNum, portNum, direction, lookupNum, portPclId2));

    rc = internal_cpssDxChPclPortPclId2Set(devNum, portNum, direction, lookupNum, portPclId2);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, direction, lookupNum, portPclId2));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal internal_cpssDxChPclPortPclId2Get function
* @endinternal
*
* @brief   Get source/target port PCL-ID2 value per lookup stage
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; AC5 Bobcat3; Aldrin2; Falcon;
*
* @param[in] devNum         - device number
* @param[in] portNum        - port number
* @param[in] direction      - Policy direction: Ingress or Egress
* @param[in] lookupNum      - lookup stage number for which port PCL-ID2 need to be configured
*
* @param[out] portPclId2Ptr - (pointer to) PCL-ID2 bytes to be included in PCL lookup key
*
* @retval GT_OK             - on success
* @retval GT_HW_ERROR       - on hardware error
* @retval GT_BAD_PARAM      - on wrong device, port number, direction or lookupNum
* @retval GT_BAD_PTR        - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclPortPclId2Get
(
    IN GT_U8                           devNum,
    IN GT_PHYSICAL_PORT_NUM            portNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    OUT GT_U32                         *portPclId2Ptr
)
{

    CPSS_DXCH_TABLE_ENT      tableName;   /* Table name */
    GT_U32                   tableOffset; /* Offset of required table */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum, portNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
        CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E);
    CPSS_NULL_PTR_CHECK_MAC(portPclId2Ptr);

    switch (direction)
    {
        case CPSS_PCL_DIRECTION_INGRESS_E:

           switch (lookupNum)
            {
                case CPSS_PCL_LOOKUP_0_E:
                case CPSS_PCL_LOOKUP_0_0_E:
                    tableName = CPSS_DXCH_SIP6_10_TABLE_IPCL0_SOURCE_PORT_CONFIG_E;
                    break;
                case CPSS_PCL_LOOKUP_0_1_E:
                    tableName = CPSS_DXCH_SIP6_10_TABLE_IPCL1_SOURCE_PORT_CONFIG_E;
                    break;
                case CPSS_PCL_LOOKUP_1_E:
                    if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                    {
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                    }
                    tableName = CPSS_DXCH_SIP6_10_TABLE_IPCL2_SOURCE_PORT_CONFIG_E;
                    break;
                default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            tableOffset = 0;
            break;

        case CPSS_PCL_DIRECTION_EGRESS_E:
            tableName = CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E;
            tableOffset = 27;
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return prvCpssDxChReadTableEntryField(
                devNum, tableName,
                portNum /*EntryIndex*/,
                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS, tableOffset, 24, portPclId2Ptr);
}

/**
* @internal cpssDxChPclPortPclId2Get function
* @endinternal
*
* @brief   Get source/target port PCL-ID2 value per lookup stage
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; AC5 Bobcat3; Aldrin2; Falcon;
*
* @param[in] devNum         - device number
* @param[in] portNum        - port number
* @param[in] direction      - Policy direction: Ingress or Egress
* @param[in] lookupNum      - lookup stage number for which port PCL-ID2 need to be configured
*
* @param[out] portPclId2Ptr - (pointer to) PCL-ID2 bytes to be included in PCL lookup key
*
* @retval GT_OK             - on success
* @retval GT_HW_ERROR       - on hardware error
* @retval GT_BAD_PARAM      - on wrong device, port number, direction or lookupNum
* @retval GT_BAD_PTR        - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclPortPclId2Get
(
    IN GT_U8                           devNum,
    IN GT_PHYSICAL_PORT_NUM            portNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    OUT GT_U32                         *portPclId2Ptr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortPclId2Get);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((devNum, portNum, direction, lookupNum, portPclId2Ptr));

    rc = internal_cpssDxChPclPortPclId2Get(devNum, portNum, direction, lookupNum, portPclId2Ptr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, direction, lookupNum, portPclId2Ptr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclFlowIdActionAssignModeSet function
* @endinternal
*
* @brief   Set per stage per parallel lookup the action field of 'flow-id' assignment mode.
*          to assign 'flow-id' field descriptor and/or 'stream-id' field descriptor.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] direction             - Policy direction:
*                                   Ingress or Egress
* @param[in] lookupNum             - Lookup number: 0/1/2
*                                    Relevant only to Ingress direction
* @param[in] hitNum                - the hit num. (in the parallel lookup)
*                                    the device may support 2 or 4 parallel lookups.
* @param[in] mode                  - the action field of 'flow-id' assignment mode
*                                    to assign 'flow-id' field descriptor and/or 'stream-id' field descriptor.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclFlowIdActionAssignModeSet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN GT_U32                          hitNum,
    IN CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_ENT mode
)
{
    GT_U32  hwValue;
    GT_U32  hwStage;
    GT_U32  regAddr;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
        CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E |
        CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);

    if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
    {
        switch (lookupNum)
        {
            case CPSS_PCL_LOOKUP_0_E:
            case CPSS_PCL_LOOKUP_0_0_E:
                hwStage = 0;
                break;
            case CPSS_PCL_LOOKUP_0_1_E:
                hwStage = 1;
                break;
            case CPSS_PCL_LOOKUP_1_E:
                if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                {
                  CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                hwStage = 2;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_ON_ENUM_MAC(lookupNum);
        }

        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).flowIdActionAssignmentModeConfig[hwStage];
    }
    else
    if(direction == CPSS_PCL_DIRECTION_EGRESS_E)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egressPolicyFlowIdActionAssignmentModeConfig;
        /* no more checks 'lookupNum' checks */
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "unknown direction [%d]",direction);
    }

    PRV_CPSS_DXCH_TCAM_HIT_NUM_CHECK_MAC(devNum,hitNum);

    switch(mode)
    {
        case CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_STREAM_ID_E:
            hwValue = 0;
            break;
        case CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_ONLY_E:
            hwValue = 1;
            break;
        case CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_STREAM_ID_ONLY_E:
            hwValue = 2;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_ON_ENUM_MAC(mode);
    }

    return prvCpssHwPpSetRegField(devNum,
        regAddr,
        2*hitNum , 2,
        hwValue);
}

/**
* @internal cpssDxChPclFlowIdActionAssignModeSet function
* @endinternal
*
* @brief   Set per stage per parallel lookup the action field of 'flow-id' assignment mode.
*          to assign 'flow-id' field descriptor and/or 'stream-id' field descriptor.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] direction             - Policy direction:
*                                   Ingress or Egress
* @param[in] lookupNum             - Lookup number: 0/1/2
*                                    Relevant only to Ingress direction
* @param[in] hitNum                - the hit num. (in the parallel lookup)
*                                    the device may support 2 or 4 parallel lookups.
* @param[in] mode                  - the action field of 'flow-id' assignment mode
*                                    to assign 'flow-id' field descriptor and/or 'stream-id' field descriptor.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclFlowIdActionAssignModeSet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN GT_U32                          hitNum,
    IN CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_ENT mode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclFlowIdActionAssignModeSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((devNum,  direction, lookupNum, hitNum , mode));

    rc = internal_cpssDxChPclFlowIdActionAssignModeSet(devNum, direction, lookupNum, hitNum , mode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, lookupNum, hitNum , mode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclFlowIdActionAssignModeGet function
* @endinternal
*
* @brief   Get per stage per parallel lookup the action field of 'flow-id' assignment mode.
*          to assign 'flow-id' field descriptor and/or 'stream-id' field descriptor.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] direction             - Policy direction:
*                                   Ingress or Egress
* @param[in] lookupNum             - Lookup number: 0/1/2
*                                    Relevant only to Ingress direction
* @param[in] hitNum                - the hit num. (in the parallel lookup)
*                                    the device may support 2 or 4 parallel lookups.
*
* @param[out] modePtr              - (pointer to) the action field of 'flow-id' assignment mode
*                                    to assign 'flow-id' field descriptor and/or 'stream-id' field descriptor.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclFlowIdActionAssignModeGet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN GT_U32                          hitNum,
    OUT CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_ENT *modePtr
)
{
    GT_STATUS   rc;
    GT_U32  hwValue;
    GT_U32  hwStage;
    GT_U32  regAddr;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
        CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E |
        CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);

    CPSS_NULL_PTR_CHECK_MAC(modePtr);

    if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
    {
        switch (lookupNum)
        {
            case CPSS_PCL_LOOKUP_0_E:
            case CPSS_PCL_LOOKUP_0_0_E:
                hwStage = 0;
                break;
            case CPSS_PCL_LOOKUP_0_1_E:
                hwStage = 1;
                break;
            case CPSS_PCL_LOOKUP_1_E:
                if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                hwStage = 2;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_ON_ENUM_MAC(lookupNum);
        }

        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).flowIdActionAssignmentModeConfig[hwStage];
    }
    else
    if(direction == CPSS_PCL_DIRECTION_EGRESS_E)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egressPolicyFlowIdActionAssignmentModeConfig;
        /* no more checks 'lookupNum' checks */
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "unknown direction [%d]",direction);
    }

    PRV_CPSS_DXCH_TCAM_HIT_NUM_CHECK_MAC(devNum,hitNum);

    rc = prvCpssHwPpGetRegField(devNum,
        regAddr,
        2*hitNum , 2,
        &hwValue);
    if(rc != GT_OK)
    {
        return rc;
    }

    switch(hwValue)
    {
        case 0:
            *modePtr = CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_STREAM_ID_E;
            break;
        case 1:
            *modePtr = CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_ONLY_E;
            break;
        case 2:
            *modePtr = CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_STREAM_ID_ONLY_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, "hwValue = 3 , not expected and not supported");
    }

    return GT_OK;

}
/**
* @internal cpssDxChPclFlowIdActionAssignModeGet function
* @endinternal
*
* @brief   Get per stage per parallel lookup the action field of 'flow-id' assignment mode.
*          to assign 'flow-id' field descriptor and/or 'stream-id' field descriptor.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] direction             - Policy direction:
*                                   Ingress or Egress
* @param[in] lookupNum             - Lookup number: 0/1/2
*                                    Relevant only to Ingress direction
* @param[in] hitNum                - the hit num. (in the parallel lookup)
*                                    the device may support 2 or 4 parallel lookups.
*
* @param[out] modePtr              - (pointer to) the action field of 'flow-id' assignment mode
*                                    to assign 'flow-id' field descriptor and/or 'stream-id' field descriptor.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclFlowIdActionAssignModeGet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN GT_U32                          hitNum,
    OUT CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_ENT *modePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclFlowIdActionAssignModeGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((devNum,  direction, lookupNum, hitNum , modePtr));

    rc = internal_cpssDxChPclFlowIdActionAssignModeGet(devNum, direction, lookupNum, hitNum , modePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, lookupNum, hitNum , modePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclNumberOfStreamIdsSet function
* @endinternal
*
* @brief   Set the maxNumber of stream-Ids that the IPCL/EPCL will assign into
*           descriptor 'stream-Id' , in mode :
*           CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_STREAM_ID_E
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; AC5 Bobcat3; Aldrin2; Falcon;AC5P; AC5X; Harrier.
*
* @param[in] devNum         - device number
* @param[in] direction      - Policy direction: Ingress or Egress
* @param[in] maxNum         - The maxNumber of stream-Ids that the IPCL/EPCL will assign into descriptor 'stream-Id'
*                              in mode : CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_STREAM_ID_E
*                              APPLICABLE RANGE : 0..(64K-1)
*
* @retval GT_OK             - on success
* @retval GT_HW_ERROR       - on hardware error
* @retval GT_BAD_PARAM      - on wrong device, direction
* @retval GT_OUT_OF_RANGE   - on out of range maxNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclNumberOfStreamIdsSet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN GT_U32                          maxNum
)
{
    GT_U32  regAddr;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
        CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E |
        CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);

    if(maxNum >= BIT_16)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "maxNum[0x%8.8x] >= 'max'[0x1000]",
            maxNum);
    }

    if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).globalConfig_ext_1;
    }
    else
    if(direction == CPSS_PCL_DIRECTION_EGRESS_E)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egressPolicyGlobalConfig_ext_1;
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "unknown direction [%d]",direction);
    }

    return prvCpssHwPpSetRegField(devNum,
        regAddr,
        0 , 16,
        maxNum);
}

/**
* @internal cpssDxChPclNumberOfStreamIdsSet function
* @endinternal
*
* @brief   Set the maxNumber of stream-Ids that the IPCL/EPCL will assign into
*           descriptor 'stream-Id' , in mode :
*           CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_STREAM_ID_E
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; AC5 Bobcat3; Aldrin2; Falcon;AC5P; AC5X; Harrier.
*
* @param[in] devNum         - device number
* @param[in] direction      - Policy direction: Ingress or Egress
* @param[in] maxNum         - The maxNumber of stream-Ids that the IPCL/EPCL will assign into descriptor 'stream-Id'
*                              in mode : CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_STREAM_ID_E
*                              APPLICABLE RANGE : 0..(64K-1)
*
* @retval GT_OK             - on success
* @retval GT_HW_ERROR       - on hardware error
* @retval GT_BAD_PARAM      - on wrong device, direction
* @retval GT_OUT_OF_RANGE   - on out of range maxNum
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclNumberOfStreamIdsSet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN GT_U32                          maxNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclNumberOfStreamIdsSet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((devNum,  direction, maxNum));

    rc = internal_cpssDxChPclNumberOfStreamIdsSet(devNum, direction, maxNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, maxNum));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclNumberOfStreamIdsGet function
* @endinternal
*
* @brief   Get the maxNumber of stream-Ids that the IPCL/EPCL will assign into
*           descriptor 'stream-Id' , in mode :
*           CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_STREAM_ID_E
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; AC5 Bobcat3; Aldrin2; Falcon;AC5P; AC5X; Harrier;
*
* @param[in] devNum         - device number
* @param[in] direction      - Policy direction: Ingress or Egress
*
* @param[out] maxNumPtr     - (pointer to)The maxNumber of stream-Ids that the IPCL/EPCL will assign into descriptor 'stream-Id'
*                              in mode : CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_STREAM_ID_E
*                              APPLICABLE RANGE : 0..(64K-1)
*
* @retval GT_OK             - on success
* @retval GT_HW_ERROR       - on hardware error
* @retval GT_BAD_PARAM      - on wrong device, direction
* @retval GT_BAD_PTR        - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclNumberOfStreamIdsGet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    OUT GT_U32                         *maxNumPtr
)
{
    GT_U32  regAddr;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
        CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E |
        CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);

    CPSS_NULL_PTR_CHECK_MAC(maxNumPtr);

    if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
    {
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).globalConfig_ext_1;
    }
    else
    if(direction == CPSS_PCL_DIRECTION_EGRESS_E)
    {
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egressPolicyGlobalConfig_ext_1;
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "unknown direction [%d]",direction);
    }

    return prvCpssHwPpGetRegField(devNum,
        regAddr,
        0 , 16,
        maxNumPtr);
}

/**
* @internal cpssDxChPclNumberOfStreamIdsGet function
* @endinternal
*
* @brief   Get the maxNumber of stream-Ids that the IPCL/EPCL will assign into
*           descriptor 'stream-Id' , in mode :
*           CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_STREAM_ID_E
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; AC5 Bobcat3; Aldrin2; Falcon;AC5P; AC5X; Harrier;
*
* @param[in] devNum         - device number
* @param[in] direction      - Policy direction: Ingress or Egress
*
* @param[out] maxNumPtr     - (pointer to)The maxNumber of stream-Ids that the IPCL/EPCL will assign into descriptor 'stream-Id'
*                              in mode : CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_STREAM_ID_E
*                              APPLICABLE RANGE : 0..(64K-1)
*
* @retval GT_OK             - on success
* @retval GT_HW_ERROR       - on hardware error
* @retval GT_BAD_PARAM      - on wrong device, direction
* @retval GT_BAD_PTR        - on null pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclNumberOfStreamIdsGet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    OUT GT_U32                         *maxNumPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclNumberOfStreamIdsGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((devNum,  direction, maxNumPtr));

    rc = internal_cpssDxChPclNumberOfStreamIdsGet(devNum, direction, maxNumPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, maxNumPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortEpgConfigSet function
* @endinternal
*
* @brief   Sets the per port EPG Configuration.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] portNum               - port number
* @param[in] portEpgConfigPtr      - (pointer to)EPG configurations.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - NULL pointer parameter
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortEpgConfigSet
(
    IN  GT_U8                                       devNum,
    IN  GT_PORT_NUM                                 portNum,
    IN  CPSS_DXCH_PCL_PORT_EPG_CONFIG_STC          *portEpgConfigPtr
)
{
    GT_U32      regData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
        CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);

    CPSS_NULL_PTR_CHECK_MAC(portEpgConfigPtr);
    PRV_CPSS_DXCH_DEFAULT_EPORT_CHECK_MAC(devNum,portNum);

    if(portEpgConfigPtr->srcEpg >= BIT_12)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "srcEpg[0x%x] >= 'srcEpg'[0x1000]",
                portEpgConfigPtr->srcEpg);
    }

    /* write to pre-tti-lookup-ingress-eport table - SRC EPG */
    regData = portEpgConfigPtr->srcEpg;
    rc = prvCpssDxChWriteTableEntryField(devNum,
            CPSS_DXCH_SIP5_TABLE_PRE_TTI_LOOKUP_INGRESS_EPORT_E,
            portNum,
            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
            SIP6_30_TTI_DEFAULT_EPORT_TABLE_FIELDS_SOURCE_EPG_E,        /* field name */
            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
            regData);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* write to pre-tti-lookup-ingress-eport table - copyTag1VidToSrcEpg */
    regData = BOOL2BIT_MAC(portEpgConfigPtr->copyTag1VidToSrcEpg);
    return prvCpssDxChWriteTableEntryField(devNum,
            CPSS_DXCH_SIP5_TABLE_PRE_TTI_LOOKUP_INGRESS_EPORT_E,
            portNum,
            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
            SIP6_30_TTI_DEFAULT_EPORT_TABLE_FIELDS_COPY_TAG1_VID_TO_SRC_EPG_E,        /* field name */
            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
            regData);
}

/**
* @internal cpssDxChPclPortEpgConfigSet function
* @endinternal
*
* @brief   Sets the per port EPG Configuration.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] portNum               - port number
* @param[in] portEpgConfigPtr      - (pointer to)EPG configurations.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - NULL pointer parameter
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortEpgConfigSet
(
    IN  GT_U8                                       devNum,
    IN  GT_PORT_NUM                                 portNum,
    IN  CPSS_DXCH_PCL_PORT_EPG_CONFIG_STC          *portEpgConfigPtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortEpgConfigSet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, portEpgConfigPtr));

    rc = internal_cpssDxChPclPortEpgConfigSet(devNum, portNum, portEpgConfigPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, portEpgConfigPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortEpgConfigGet function
* @endinternal
*
* @brief   Gets the per port EPG Configuration.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] portNum               - port number
* @param[out] epgConfigPtr         - (pointer to)EPG configurations.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - NULL pointer parameter
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclPortEpgConfigGet
(
    IN  GT_U8                                       devNum,
    IN  GT_PORT_NUM                                 portNum,
    OUT CPSS_DXCH_PCL_PORT_EPG_CONFIG_STC          *portEpgConfigPtr
)
{
    GT_U32      regData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
        devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
        CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);
    CPSS_NULL_PTR_CHECK_MAC(portEpgConfigPtr);
    PRV_CPSS_DXCH_DEFAULT_EPORT_CHECK_MAC(devNum,portNum);

    rc = prvCpssDxChReadTableEntryField(devNum,
            CPSS_DXCH_SIP5_TABLE_PRE_TTI_LOOKUP_INGRESS_EPORT_E,
            portNum,/*global port*/
            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
            SIP6_30_TTI_DEFAULT_EPORT_TABLE_FIELDS_SOURCE_EPG_E, /* field name */
            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
            &regData);
    if(rc != GT_OK)
    {
        return rc;
    }

    portEpgConfigPtr->srcEpg = regData;

    rc = prvCpssDxChReadTableEntryField(devNum,
            CPSS_DXCH_SIP5_TABLE_PRE_TTI_LOOKUP_INGRESS_EPORT_E,
            portNum,/*global port*/
            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
            SIP6_30_TTI_DEFAULT_EPORT_TABLE_FIELDS_COPY_TAG1_VID_TO_SRC_EPG_E, /* field name */
            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
            &regData);
    portEpgConfigPtr->copyTag1VidToSrcEpg = BIT2BOOL_MAC(regData);
    return rc;
}

/**
* @internal cpssDxChPclPortEpgConfigGet function
* @endinternal
*
* @brief   Gets the per port EPG Configuration.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] portNum               - port number
* @param[out] epgConfigPtr         - (pointer to)EPG configurations.
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - wrong value in any of the parameters
* @retval GT_BAD_PTR               - NULL pointer parameter
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclPortEpgConfigGet
(
    IN  GT_U8                                       devNum,
    IN  GT_PORT_NUM                                 portNum,
    OUT CPSS_DXCH_PCL_PORT_EPG_CONFIG_STC          *portEpgConfigPtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortEpgConfigGet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, portEpgConfigPtr));

    rc = internal_cpssDxChPclPortEpgConfigGet(devNum, portNum, portEpgConfigPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, portEpgConfigPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEpgConfigSet function
* @endinternal
*
* @brief   Sets per stage EPG related config.
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                - device number
* @param[in] lookupNum             - Lookup number: 0/1/2, Ignored for AC5P, AC5X, Harrier.
* @param[in] epgConfigPtr          - (Pointer to) EPG config.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclEpgConfigSet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN CPSS_DXCH_PCL_EPG_CONFIG_STC    *epgConfigPtr
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;
    GT_U32      hwStage;
    GT_U32      regData;
    GT_U32      value;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
            devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
            CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E);
    CPSS_NULL_PTR_CHECK_MAC(epgConfigPtr);

    if (PRV_CPSS_SIP_6_30_CHECK_MAC(devNum) == 0)
    {
        /*AC5P; AC5X; Harrier*/
        /* Set Assign from UDBs Mode */
        switch(epgConfigPtr->assignFromUdbsMode)
        {
            case CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_TAG1_DEST_E:
                value = 0;
                break;
            case CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_SRC_EPG_E:
                value = 1;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_ON_ENUM_MAC(epgConfigPtr->assignFromUdbsMode);
        }
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineConfig;
        return prvCpssHwPpSetRegField(
            devNum, regAddr, 29, 1, value);
    }

    switch (lookupNum)
    {
        case CPSS_PCL_LOOKUP_0_E:
        case CPSS_PCL_LOOKUP_0_0_E:
            hwStage = 0;
            break;
        case CPSS_PCL_LOOKUP_0_1_E:
            hwStage = 1;
            break;
        case CPSS_PCL_LOOKUP_1_E:
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            hwStage = 2;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_ON_ENUM_MAC(lookupNum);
    }

    /* Read global config */
    regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyGlobalConfig[hwStage];
    rc = prvCpssHwPpReadRegister(devNum, regAddr, &regData);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Set Use SRC TRG Mode */
    switch(epgConfigPtr->useSrcTrgMode)
    {
        case CPSS_DXCH_PCL_USE_SRC_TRG_MODE_SRC_DST_EPG_E:
            value = 0;
            break;
        case CPSS_DXCH_PCL_USE_SRC_TRG_MODE_COPY_RESERVED_SRC_ID_E:
            value = 1;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_ON_ENUM_MAC(epgConfigPtr->useSrcTrgMode);
    }
    U32_SET_FIELD_MAC(regData, 14, 1, value);

    /* Set Assign from UDBs Mode */
    switch(epgConfigPtr->assignFromUdbsMode)
    {
        case CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_TAG1_DEST_E:
            value = 0;
            break;
        case CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_SRC_EPG_E:
            value = 2;
            break;
        case CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_TAG1_SRC_EPG_E:
            value = 3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_ON_ENUM_MAC(epgConfigPtr->assignFromUdbsMode);
    }
    U32_SET_FIELD_MAC(regData, 12, 2, value);
    return prvCpssHwPpWriteRegister(devNum, regAddr, regData);;
}

/**
* @internal cpssDxChPclEpgConfigSet function
* @endinternal
*
* @brief   Sets per stage EPG related config.
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                - device number
* @param[in] lookupNum             - Lookup number: 0/1/2, Ignored for AC5P, AC5X, Harrier.
* @param[in] epgConfigPtr          - (Pointer to) EPG config.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclEpgConfigSet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN CPSS_DXCH_PCL_EPG_CONFIG_STC    *epgConfigPtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEpgConfigSet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, lookupNum, epgConfigPtr));

    rc = internal_cpssDxChPclEpgConfigSet(devNum, lookupNum, epgConfigPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, lookupNum, epgConfigPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclEpgConfigGet function
* @endinternal
*
* @brief   Gets per stage EPG related Configuration.
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                - device number
* @param[in] lookupNum             - Lookup number: 0/1/2, Ignored for AC5P, AC5X, Harrier.
* @param[out] epgConfigPtr         - (Pointer to) EPG config.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_STATE             - on unexpected value in HW
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclEpgConfigGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    OUT CPSS_DXCH_PCL_EPG_CONFIG_STC   *epgConfigPtr
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;
    GT_U32      hwStage;
    GT_U32      regData;
    GT_U32      value;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
            devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
            CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E);
    CPSS_NULL_PTR_CHECK_MAC(epgConfigPtr);

    if (PRV_CPSS_SIP_6_30_CHECK_MAC(devNum) == 0)
    {
        /*AC5P; AC5X; Harrier*/
        /* Get Assign from UDBs Mode */
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyEngineConfig;
        rc = prvCpssHwPpGetRegField(
            devNum, regAddr, 29, 1, &value);
        if (rc != GT_OK)
        {
            return rc;
        }

        epgConfigPtr->assignFromUdbsMode = 
            (value == 0)
                ? CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_TAG1_DEST_E
                : CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_SRC_EPG_E;
        return GT_OK;
    }

    switch (lookupNum)
    {
        case CPSS_PCL_LOOKUP_0_E:
        case CPSS_PCL_LOOKUP_0_0_E:
            hwStage = 0;
            break;
        case CPSS_PCL_LOOKUP_0_1_E:
            hwStage = 1;
            break;
        case CPSS_PCL_LOOKUP_1_E:
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            hwStage = 2;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_ON_ENUM_MAC(lookupNum);
    }

    /* get Source Target Mode */
    regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyGlobalConfig[hwStage];
    rc = prvCpssHwPpReadRegister(devNum, regAddr, &regData);
    if(rc != GT_OK)
    {
        return rc;
    }

    value = U32_GET_FIELD_MAC(regData, 14, 1);
    epgConfigPtr->useSrcTrgMode = (value == 0) ?
        CPSS_DXCH_PCL_USE_SRC_TRG_MODE_SRC_DST_EPG_E :
        CPSS_DXCH_PCL_USE_SRC_TRG_MODE_COPY_RESERVED_SRC_ID_E;

    value = U32_GET_FIELD_MAC(regData, 12, 2);
    switch(value)
    {
        case 0:
            epgConfigPtr->assignFromUdbsMode = CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_TAG1_DEST_E;
            break;
        case 2:
            epgConfigPtr->assignFromUdbsMode = CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_SRC_EPG_E;
            break;
        case 3:
            epgConfigPtr->assignFromUdbsMode = CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_TAG1_SRC_EPG_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }
    return rc;
}

/**
* @internal cpssDxChPclEpgConfigGet function
* @endinternal
*
* @brief   Gets per stage EPG related Configuration.
*
* @note   APPLICABLE DEVICES:      AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon.
*
* @param[in] devNum                - device number
* @param[in] lookupNum             - Lookup number: 0/1/2, Ignored for AC5P, AC5X, Harrier.
* @param[out] epgConfigPtr         - (Pointer to) EPG config.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_STATE             - on unexpected value in HW
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclEpgConfigGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    OUT CPSS_DXCH_PCL_EPG_CONFIG_STC   *epgConfigPtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclEpgConfigGet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, lookupNum, epgConfigPtr));

    rc = internal_cpssDxChPclEpgConfigGet(devNum, lookupNum, epgConfigPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, lookupNum, epgConfigPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}
/**
* @internal internal_cpssDxChPclGenericActionModeSet function
* @endinternal
*
* @brief   Sets the per lookup, generic action mode.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] lookupNum             - Lookup number: 0/1/2
* @param[in] hitNum                - the hit num. (in the parallel lookup)
*                                    the device may support 2 or 4 parallel lookups.
* @param[in] genericActionMode     - Generic Action mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclGenericActionModeSet
(
    IN GT_U8                                    devNum,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT               lookupNum,
    IN GT_U32                                   hitNum,
    IN CPSS_DXCH_PCL_GENERIC_ACTION_MODE_ENT    genericActionMode
)
{
    GT_U32      regAddr;
    GT_U32      hwStage;
    GT_U32      regData;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
            devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
            CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);
    PRV_CPSS_DXCH_TCAM_HIT_NUM_CHECK_MAC(devNum,hitNum);

    switch (lookupNum)
    {
        case CPSS_PCL_LOOKUP_0_E:
        case CPSS_PCL_LOOKUP_0_0_E:
            hwStage = 0;
            break;
        case CPSS_PCL_LOOKUP_0_1_E:
            hwStage = 1;
            break;
        case CPSS_PCL_LOOKUP_1_E:
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            hwStage = 2;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_ON_ENUM_MAC(lookupNum);
    }
    regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyGenericActionConfig[hwStage];
    switch(genericActionMode)
    {
        case CPSS_DXCH_PCL_GENERIC_ACTION_MODE_SRC_EPG_E:
            regData = 2;
            break;
        case CPSS_DXCH_PCL_GENERIC_ACTION_MODE_DST_EPG_E:
            regData = 1;
            break;
        case CPSS_DXCH_PCL_GENERIC_ACTION_MODE_802_1_QCI_E:
            regData = 0;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_ON_ENUM_MAC(genericActionMode);
    }
    return prvCpssHwPpSetRegField(devNum, regAddr, (hitNum*2), 2, regData);
}

/**
* @internal cpssDxChPclGenericActionModeSet function
* @endinternal
*
* @brief   Sets the per lookup, generic action mode.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] lookupNum             - Lookup number: 0/1/2
* @param[in] hitNum                - the hit num. (in the parallel lookup)
*                                    the device may support 2 or 4 parallel lookups.
* @param[in] genericActionMode     - Generic Action mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclGenericActionModeSet
(
    IN GT_U8                                    devNum,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT               lookupNum,
    IN GT_U32                                   hitNum,
    IN CPSS_DXCH_PCL_GENERIC_ACTION_MODE_ENT    genericActionMode
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclGenericActionModeSet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, lookupNum, hitNum, genericActionMode));

    rc = internal_cpssDxChPclGenericActionModeSet(devNum, lookupNum, hitNum, genericActionMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, lookupNum, hitNum, genericActionMode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclGenericActionModeGet function
* @endinternal
*
* @brief  Gets the per lookup, generic action mode.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] lookupNum             - Lookup number: 0/1/2
* @param[in] hitNum                - the hit num. (in the parallel lookup)
*                                    the device may support 2 or 4 parallel lookups.
* @param[out] genericActionModePtr - (pointer to)Generic Action mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_STATE             - on unexpected value in HW
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclGenericActionModeGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT              lookupNum,
    IN  GT_U32                                  hitNum,
    OUT CPSS_DXCH_PCL_GENERIC_ACTION_MODE_ENT   *genericActionModePtr
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;
    GT_U32      regData;
    GT_U32      hwStage;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
            devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
            CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);
    CPSS_NULL_PTR_CHECK_MAC(genericActionModePtr);
    PRV_CPSS_DXCH_TCAM_HIT_NUM_CHECK_MAC(devNum,hitNum);

    switch (lookupNum)
    {
        case CPSS_PCL_LOOKUP_0_E:
        case CPSS_PCL_LOOKUP_0_0_E:
            hwStage = 0;
            break;
        case CPSS_PCL_LOOKUP_0_1_E:
            hwStage = 1;
            break;
        case CPSS_PCL_LOOKUP_1_E:
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.pcl.iPcl0Bypass)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            hwStage = 2;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_ON_ENUM_MAC(lookupNum);
    }
    regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).policyGenericActionConfig[hwStage];
    rc = prvCpssHwPpGetRegField(devNum, regAddr, (hitNum*2), 2, &regData);
    if(rc != GT_OK)
    {
        return rc;
    }

    switch(regData)
    {
        case 0:
            *genericActionModePtr = CPSS_DXCH_PCL_GENERIC_ACTION_MODE_802_1_QCI_E;
            break;
        case 1:
            *genericActionModePtr = CPSS_DXCH_PCL_GENERIC_ACTION_MODE_DST_EPG_E;
            break;
        case 2:
            *genericActionModePtr = CPSS_DXCH_PCL_GENERIC_ACTION_MODE_SRC_EPG_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, "HW value is not expected and not supported");
    }
    return rc;
}

/**
* @internal cpssDxChPclGenericActionModeGet function
* @endinternal
*
* @brief  Gets the per lookup, generic action mode.
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] lookupNum             - Lookup number: 0/1/2
* @param[in] hitNum                - the hit num. (in the parallel lookup)
*                                    the device may support 2 or 4 parallel lookups.
* @param[out] genericActionModePtr - (pointer to)Generic Action mode.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_BAD_STATE             - on unexpected value in HW
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclGenericActionModeGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT              lookupNum,
    IN  GT_U32                                  hitNum,
    OUT CPSS_DXCH_PCL_GENERIC_ACTION_MODE_ENT   *genericActionModePtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclGenericActionModeGet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, lookupNum, hitNum, genericActionModePtr));

    rc = internal_cpssDxChPclGenericActionModeGet(devNum, lookupNum, hitNum, genericActionModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, lookupNum, hitNum, genericActionModePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortDestinationEpgConfigSet function
* @endinternal
*
* @brief  Sets the Destination EPG configuration per physical port
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] portNum               - port number
* @param[in] portDstEpgConfigPtr   - (Pointer to)Port Destination EPG configuration.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclPortDestinationEpgConfigSet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    IN  CPSS_DXCH_PCL_PORT_DST_EPG_CONFIG_STC   *portDstEpgConfigPtr
)
{
    GT_STATUS   rc;
    GT_U32      hwValue;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
            devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
            CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);
    CPSS_NULL_PTR_CHECK_MAC(portDstEpgConfigPtr);
    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum, portNum);

    if(portDstEpgConfigPtr->dstEpg >= BIT_12)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, "dstEpg[0x%x] >= 'dstEpg'[0x1000]",
                portDstEpgConfigPtr->dstEpg);
    }
    hwValue = portDstEpgConfigPtr->dstEpg;
    rc = prvCpssDxChWriteTableEntryField(
            devNum,
            CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
            portNum,
            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
            SIP6_30_HA_PHYSICAL_PORT_TABLE_1_FIELDS_DESTINATION_EPG_E,
            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
            hwValue);
    if(GT_OK != rc)
    {
        return rc;
    }

    hwValue = BOOL2BIT_MAC(portDstEpgConfigPtr->setDstEpgEnable);
    return prvCpssDxChWriteTableEntryField(
            devNum,
            CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
            portNum,
            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
            SIP6_30_HA_PHYSICAL_PORT_TABLE_1_FIELDS_SET_DESTINATION_EPG_E,
            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
            hwValue);
}

/**
* @internal cpssDxChPclPortDestinationEpgConfigSet function
* @endinternal
*
* @brief  Sets the Destination EPG configuration per physical port
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] portNum               - port number
* @param[in] portDstEpgConfigPtr   - (Pointer to)Port Destination EPG configuration.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclPortDestinationEpgConfigSet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    IN  CPSS_DXCH_PCL_PORT_DST_EPG_CONFIG_STC   *portDstEpgConfigPtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortDestinationEpgConfigSet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, portDstEpgConfigPtr));

    rc = internal_cpssDxChPclPortDestinationEpgConfigSet(devNum, portNum, portDstEpgConfigPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, portDstEpgConfigPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclPortDestinationEpgConfigGet function
* @endinternal
*
* @brief  Gets the Destination EPG configuration per physical port
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] portNum               - port number
* @param[out] portDstEpgConfigPtr  - (Pointer to)Port Destination EPG configuration.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
static GT_STATUS internal_cpssDxChPclPortDestinationEpgConfigGet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    OUT CPSS_DXCH_PCL_PORT_DST_EPG_CONFIG_STC   *portDstEpgConfigPtr
)
{
    GT_STATUS   rc;
    GT_U32      hwValue;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(
            devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
            CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);
    CPSS_NULL_PTR_CHECK_MAC(portDstEpgConfigPtr);
    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum, portNum);

    rc = prvCpssDxChReadTableEntryField(
            devNum,
            CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
            portNum,
            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
            SIP6_30_HA_PHYSICAL_PORT_TABLE_1_FIELDS_DESTINATION_EPG_E,
            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
            &hwValue);
    if(GT_OK != rc)
    {
        return rc;
    }
    portDstEpgConfigPtr->dstEpg = hwValue;

    rc = prvCpssDxChReadTableEntryField(
            devNum,
            CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
            portNum,
            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
            SIP6_30_HA_PHYSICAL_PORT_TABLE_1_FIELDS_SET_DESTINATION_EPG_E,
            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
            &hwValue);
    portDstEpgConfigPtr->setDstEpgEnable = BIT2BOOL_MAC(hwValue);
    return rc;
}

/**
* @internal cpssDxChPclPortDestinationEpgConfigGet function
* @endinternal
*
* @brief  Gets the Destination EPG configuration per physical port
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum                - device number
* @param[in] portNum               - port number
* @param[out] portDstEpgConfigPtr  - (Pointer to)Port Destination EPG configuration.
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*/
GT_STATUS cpssDxChPclPortDestinationEpgConfigGet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    OUT CPSS_DXCH_PCL_PORT_DST_EPG_CONFIG_STC   *portDstEpgConfigPtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclPortDestinationEpgConfigGet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, portDstEpgConfigPtr));

    rc = internal_cpssDxChPclPortDestinationEpgConfigGet(devNum, portNum, portDstEpgConfigPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, portDstEpgConfigPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclMaxSduSizeProfileSet function
* @endinternal
*
* @brief   Set the maximum Service Data Unit (SDU) bytes size per profile
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum             - device number
* @param[in] direction          - Policy direction: Ingress or Egress
* @param[in] profileNum         - profile number (APPLICABLE RANGES:  0..3)
* @param[in] maxSduSize         - maximum Service Data Unit (SDU) bytes size for this profileNum
*                                 (APPLICABLE RANGES:  0..2^16 - 1)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - one of the input parameters is not valid
* @retval GT_OUT_OF_RANGE          - on maxSduSize value out of range.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclMaxSduSizeProfileSet
(
    IN GT_U8                     devNum,
    IN CPSS_PCL_DIRECTION_ENT    direction,
    IN GT_U32                    profileNum,
    IN GT_U32                    maxSduSize
)
{
    GT_STATUS    rc;           /* Return Code status                           */
    GT_U32       regAddr;      /* HW register address                          */
    GT_U32       fieldOffset;  /* The start bit number in the register         */
    GT_U32       fieldLength;  /* The number of bits to be written to register */

    /* Check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
            CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);
    CPSS_DATA_CHECK_MAX_MAC(maxSduSize, BIT_16);
    CPSS_PARAM_CHECK_MAX_MAC(profileNum, BIT_2);


    if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
    {
        /* Get register address of Ingress maxSduSizeProfile */
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).maxSduSizeProfile[profileNum];
    }
    else if(direction == CPSS_PCL_DIRECTION_EGRESS_E)
    {
        /* Get register address of Egress maxSduSizeProfile */
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egressMaxSduSizeProfile[profileNum];
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "invalid direction [%d]",direction);
    }

    /* Set maxSduSizeProfile register with SDU Size Profile byte count */
    fieldOffset = 0;
    fieldLength = 16;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, fieldOffset, fieldLength, maxSduSize);

    return rc;
}

/**
* @internal cpssDxChPclMaxSduSizeProfileSet function
* @endinternal
*
* @brief   Set the maximum Service Data Unit (SDU) bytes size per profile
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum             - device number
* @param[in] direction          - Policy direction: Ingress or Egress
* @param[in] profileNum         - profile number (APPLICABLE RANGES:  0..3)
* @param[in] maxSduSize         - maximum Service Data Unit (SDU) bytes size for this profileNum
*                                 (APPLICABLE RANGES:  0..2^16 - 1)
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - one of the input parameters is not valid
* @retval GT_OUT_OF_RANGE          - on maxSduSize value out of range.
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclMaxSduSizeProfileSet
(
    IN GT_U8                     devNum,
    IN CPSS_PCL_DIRECTION_ENT    direction,
    IN GT_U32                    profileNum,
    IN GT_U32                    maxSduSize
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclMaxSduSizeProfileSet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, profileNum, maxSduSize));

    rc = internal_cpssDxChPclMaxSduSizeProfileSet(devNum, direction, profileNum, maxSduSize);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, profileNum, maxSduSize));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclMaxSduSizeProfileGet function
* @endinternal
*
* @brief   Get the maximum Service Data Unit (SDU) bytes size per profile
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in]  devNum           - device number
* @param[in]  direction        - Policy direction: Ingress or Egress
* @param[in]  profileNum       - profile number (APPLICABLE RANGES:  0..3)
* @param[out] maxSduSizePtr    - (pointer to) maximum Service Data Unit (SDU) bytes size for this profileNum
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclMaxSduSizeProfileGet
(
    IN GT_U8                     devNum,
    IN CPSS_PCL_DIRECTION_ENT    direction,
    IN GT_U32                    profileNum,
    IN GT_U32                    *maxSduSizePtr
)
{
    GT_STATUS    rc;           /* Return Code status                           */
    GT_U32       regAddr;      /* HW register address                          */
    GT_U32       fieldOffset;  /* The start bit number in the register         */
    GT_U32       fieldLength;  /* The number of bits to be written to register */
    GT_U32       hwValue;      /* Value read from HW                           */

    /* Check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
            CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);
    CPSS_NULL_PTR_CHECK_MAC(maxSduSizePtr);
    CPSS_PARAM_CHECK_MAX_MAC(profileNum, BIT_2);


    if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
    {
        /* Get register address of Ingress maxSduSizeProfile */
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).maxSduSizeProfile[profileNum];
    }
    else if(direction == CPSS_PCL_DIRECTION_EGRESS_E)
    {
        /* Get register address of Egress maxSduSizeProfile */
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egressMaxSduSizeProfile[profileNum];
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "invalid direction [%d]",direction);
    }

    /* Get SDU Size Profile byte count from maxSduSizeProfile register */
    fieldOffset = 0;
    fieldLength = 16;
    rc = prvCpssHwPpGetRegField(devNum, regAddr, fieldOffset, fieldLength, &hwValue);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Set output parameter */
    *maxSduSizePtr = hwValue;

    return rc;
}

/**
* @internal cpssDxChPclMaxSduSizeProfileGet function
* @endinternal
*
* @brief   Get the maximum Service Data Unit (SDU) bytes size per profile
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in]  devNum           - device number
* @param[in]  direction        - Policy direction: Ingress or Egress
* @param[in]  profileNum       - profile number (APPLICABLE RANGES:  0..3)
* @param[out] maxSduSizePtr    - (pointer to) maximum Service Data Unit (SDU) bytes size for this profileNum
*
* @retval GT_OK                    - on success.
* @retval GT_BAD_PARAM             - one of the input parameters is not valid.
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclMaxSduSizeProfileGet
(
    IN  GT_U8                     devNum,
    IN  CPSS_PCL_DIRECTION_ENT    direction,
    IN  GT_U32                    profileNum,
    OUT GT_U32                    *maxSduSizePtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclMaxSduSizeProfileGet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, profileNum, maxSduSizePtr));

    rc = internal_cpssDxChPclMaxSduSizeProfileGet(devNum, direction, profileNum, maxSduSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, profileNum, maxSduSizePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclMaxSduSizeExceptionSet function
* @endinternal
*
* @brief  Set the packet command and CPU drop code for exception case in which
*         packet byte count is bigger than Service Data Unit (SDU) Size Profile byte count
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum        - device number.
* @param[in] direction     - Ingress Policy or Egress Policy
* @param[in] command       - the packet command.
*                            APPLICABLE VALUES: CPSS_PACKET_CMD_FORWARD_E;
*                                               CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
*                                               CPSS_PACKET_CMD_TRAP_TO_CPU_E;
*                                               CPSS_PACKET_CMD_DROP_HARD_E;
*                                               CPSS_PACKET_CMD_DROP_SOFT_E.
* @param[in] cpuCode       - the cpu code in case of none forward command
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - one of the input parameters is not valid
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclMaxSduSizeExceptionSet
(
    IN GT_U8                       devNum,
    IN CPSS_PCL_DIRECTION_ENT      direction,
    IN CPSS_PACKET_CMD_ENT         command,
    IN CPSS_NET_RX_CPU_CODE_ENT    cpuCode
)
{
    GT_STATUS                              rc;             /* Return Code status                           */
    GT_U32                                 regAddr;        /* HW register address                          */
    GT_U32                                 fieldOffset;    /* The start bit number in the register         */
    GT_U32                                 fieldLength;    /* The number of bits to be written to register */
    PRV_CPSS_DXCH_NET_DSA_TAG_CPU_CODE_ENT dsaCpuCode;     /* HW cpu code enumeration                      */
    GT_U32                                 commandHwValue; /* Command HW value                             */


    /* Check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
            CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);


    /* Verify packet command is valid and convert it to hardware value */
    PRV_CPSS_CONVERT_PACKET_CMD_TO_HW_VAL_MAC(commandHwValue,command);

    if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
    {
        /* Get register address of Ingress maxSduException */
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).maxSduException;
    }
    else if(direction == CPSS_PCL_DIRECTION_EGRESS_E)
    {
        /* Get register address of Egress maxSduException */
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egressMaxSduException;
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "invalid direction [%d]",direction);
    }

    /* Set maxSduException register with command value */
    fieldOffset = 0;
    fieldLength = 3;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, fieldOffset, fieldLength, commandHwValue);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Write cpu drop code in case of none forward command */
    if (command !=  CPSS_PACKET_CMD_FORWARD_E)
    {
        /* Convert generic cpu code into 'hw cpu code' */
        rc = prvCpssDxChNetIfCpuToDsaCode(cpuCode, &dsaCpuCode);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* Set maxSduException register with 'hw cpu code' value */
        fieldOffset = 3;
        fieldLength = 8;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, fieldOffset, fieldLength, dsaCpuCode);
    }

    return rc;
}

/**
* @internal cpssDxChPclMaxSduSizeExceptionSet function
* @endinternal
*
* @brief  Set the packet command and CPU drop code for exception case in which
*         packet byte count is bigger than Service Data Unit (SDU) Size Profile byte count
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in] devNum        - device number.
* @param[in] direction     - Ingress Policy or Egress Policy
* @param[in] command       - the packet command.
*                            APPLICABLE VALUES: CPSS_PACKET_CMD_FORWARD_E;
*                                               CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
*                                               CPSS_PACKET_CMD_TRAP_TO_CPU_E;
*                                               CPSS_PACKET_CMD_DROP_HARD_E;
*                                               CPSS_PACKET_CMD_DROP_SOFT_E.
* @param[in] cpuCode       - the cpu code in case of none forward command
*
* @retval GT_OK                    - on success
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - one of the input parameters is not valid
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclMaxSduSizeExceptionSet
(
    IN GT_U8                       devNum,
    IN CPSS_PCL_DIRECTION_ENT      direction,
    IN CPSS_PACKET_CMD_ENT         command,
    IN CPSS_NET_RX_CPU_CODE_ENT    cpuCode
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclMaxSduSizeExceptionSet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, command, cpuCode));

    rc = internal_cpssDxChPclMaxSduSizeExceptionSet(devNum, direction, command, cpuCode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, command, cpuCode));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

/**
* @internal internal_cpssDxChPclMaxSduSizeExceptionGet function
* @endinternal
*
* @brief  Get the packet command and CPU drop code for exception case in which
*         packet byte count is bigger than Service Data Unit (SDU) Size Profile byte count
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in]   devNum        - device number.
* @param[in]   direction     - Ingress Policy or Egress Policy
* @param[out] commandPtr     - (pointer to) the packet command.
* @param[out] cpuCodePtr     - (pointer to) the cpu code in case of none forward command
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - one of the input parameters is not valid
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChPclMaxSduSizeExceptionGet
(
    IN  GT_U8                     devNum,
    IN  CPSS_PCL_DIRECTION_ENT    direction,
    OUT CPSS_PACKET_CMD_ENT       *commandPtr,
    OUT CPSS_NET_RX_CPU_CODE_ENT  *cpuCodePtr
)
{
    GT_STATUS                              rc;          /* Return Code status                           */
    GT_U32                                 regAddr;     /* HW register address                          */
    GT_U32                                 fieldOffset; /* The start bit number in the register         */
    GT_U32                                 fieldLength; /* The number of bits to be written to register */
    PRV_CPSS_DXCH_NET_DSA_TAG_CPU_CODE_ENT dsaCpuCode;  /* HW cpu code enumeration                      */
    GT_U32                                 hwValue;     /* Value read from HW                           */


    /* Check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E |
            CPSS_ALDRIN_E | CPSS_BOBCAT3_E | CPSS_AC3X_E | CPSS_ALDRIN2_E | CPSS_FALCON_E | CPSS_AC5P_E | CPSS_AC5X_E | CPSS_HARRIER_E);
    CPSS_NULL_PTR_CHECK_MAC(commandPtr);
    CPSS_NULL_PTR_CHECK_MAC(cpuCodePtr);


    if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
    {
        /* Get register address of Ingress maxSduException */
        regAddr = PRV_DXCH_REG1_UNIT_PCL_MAC(devNum).maxSduException;
    }
    else if(direction == CPSS_PCL_DIRECTION_EGRESS_E)
    {
        /* Get register address of Egress maxSduException */
        regAddr = PRV_DXCH_REG1_UNIT_EPCL_MAC(devNum).egressMaxSduException;
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "invalid direction [%d]",direction);
    }

    /* Get Max SDU Size Exception Command from maxSduException register */
    fieldOffset = 0;
    fieldLength = 3;
    rc = prvCpssHwPpGetRegField(devNum, regAddr, fieldOffset, fieldLength, &hwValue);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Convert hardware value to packet command */
    PRV_CPSS_CONVERT_HW_VAL_TO_PACKET_CMD_MAC((*commandPtr),hwValue);

    /* Get Max SDU Size Exception DROP CODE from maxSduException register */
    fieldOffset = 3;
    fieldLength = 8;
    rc = prvCpssHwPpGetRegField(devNum, regAddr, fieldOffset, fieldLength, &hwValue);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Convert 'hw cpu code' into generic cpu code */
    dsaCpuCode = hwValue;
    rc = prvCpssDxChNetIfDsaToCpuCode(dsaCpuCode,cpuCodePtr);

    return rc;
}

/**
* @internal cpssDxChPclMaxSduSizeExceptionGet function
* @endinternal
*
* @brief  Get the packet command and CPU drop code for exception case in which
*         packet byte count is bigger than Service Data Unit (SDU) Size Profile byte count
*
* @note   APPLICABLE DEVICES:      Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier.
*
* @param[in]   devNum        - device number.
* @param[in]   direction     - Ingress Policy or Egress Policy
* @param[out] commandPtr     - (pointer to) the packet command.
* @param[out] cpuCodePtr     - (pointer to) the cpu code in case of none forward command
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PTR               - on null pointer
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_BAD_PARAM             - one of the input parameters is not valid
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChPclMaxSduSizeExceptionGet
(
    IN  GT_U8                     devNum,
    IN  CPSS_PCL_DIRECTION_ENT    direction,
    OUT CPSS_PACKET_CMD_ENT       *commandPtr,
    OUT CPSS_NET_RX_CPU_CODE_ENT  *cpuCodePtr
)
{
    GT_STATUS rc;

    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPclMaxSduSizeExceptionGet);
    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, direction, commandPtr, cpuCodePtr));

    rc = internal_cpssDxChPclMaxSduSizeExceptionGet(devNum, direction, commandPtr, cpuCodePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, direction, commandPtr, cpuCodePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

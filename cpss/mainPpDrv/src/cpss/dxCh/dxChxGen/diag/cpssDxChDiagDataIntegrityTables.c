/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
*/
/**
********************************************************************************
* @file cpssDxChDiagDataIntegrityTables.c
*
* @brief API implementation for tables Diag Data Integrity.
*
* @version   1
********************************************************************************
*/
#define CPSS_LOG_IN_MODULE_ENABLE
#include <cpss/dxCh/dxChxGen/diag/private/prvCpssDxChDiagLog.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/cpssDxChTables.h>
#include <cpss/dxCh/dxChxGen/diag/cpssDxChDiagDataIntegrityTables.h>
#include <cpss/generic/cpssHwInit/cpssHwInit.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChHwTables.h>
#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChInfo.h>
#include <cpss/dxCh/dxChxGen/diag/private/prvCpssDxChDiagDataIntegrityMainMappingDb.h>
#include <cpss/dxCh/dxChxGen/diag/private/prvCpssDxChDiag.h>
#include <cpss/dxCh/dxChxGen/tcam/private/prvCpssDxChTcam.h>
#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChCfg.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDb.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDbInterface.h>

/* hw tables array max capacity */
#define PRV_CPSS_HW_IN_LOGICAL_MAX_CNS 34

/* non exists address */
#define SPECIAL_ADDRESS_NOT_EXISTS_CNS   0x0FFFFFFF

/* logical table entry */
typedef struct
{
   const CPSS_DXCH_LOGICAL_TABLE_ENT logicalName;
   const CPSS_DXCH_TABLE_ENT     hwNameArr[PRV_CPSS_HW_IN_LOGICAL_MAX_CNS];
} PRV_CPSS_DXCH_LOGICAL_ENTRY_STC;

/* the number of entries allocated for IPLR0 to use */
#define IPLR0_SIZE_MAC(devNum) \
    PRV_CPSS_DXCH_PP_MAC(devNum)->policer.memSize[CPSS_DXCH_POLICER_STAGE_INGRESS_0_E]

/* the number of entries allocated for IPLR1 to use */
#define IPLR1_SIZE_MAC(devNum) \
    PRV_CPSS_DXCH_PP_MAC(devNum)->policer.memSize[CPSS_DXCH_POLICER_STAGE_INGRESS_1_E]

/* the number of entries allocated for EPLR to use */
#define EPLR_SIZE_MAC(devNum) \
    PRV_CPSS_DXCH_PP_MAC(devNum)->policer.memSize[CPSS_DXCH_POLICER_STAGE_EGRESS_E]

/* the number of counting entries allocated for IPLR0 to use */
#define IPLR0_COUNTING_SIZE_MAC(devNum) \
    PRV_CPSS_DXCH_PP_MAC(devNum)->policer.countingMemSize[CPSS_DXCH_POLICER_STAGE_INGRESS_0_E]

/* the number of counting entries allocated for IPLR1 to use */
#define IPLR1_COUNTING_SIZE_MAC(devNum) \
    PRV_CPSS_DXCH_PP_MAC(devNum)->policer.countingMemSize[CPSS_DXCH_POLICER_STAGE_INGRESS_1_E]

/* the number of counting entries allocated for EPLR to use */
#define EPLR_COUNTING_SIZE_MAC(devNum) \
    PRV_CPSS_DXCH_PP_MAC(devNum)->policer.countingMemSize[CPSS_DXCH_POLICER_STAGE_EGRESS_E]

/* array of the hw tables that should not be in the shadow */
static const CPSS_DXCH_TABLE_ENT  hwTablesNoNeedShadowArr[] = {

    /* the FDB not supported for several reasons:
        1. shadow by the application.
        2. aging daemon that changes values
        3. aging bit modified by 'refresh'
        4. there are 'complex' operations by vlan/port/trunk/etc... to do by aging daemon
    */
     CPSS_DXCH_TABLE_FDB_E
     /*CNC counters changed by the Device on traffic ... so no shadow support */
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 1
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 2
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 3
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 4
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 5
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 6
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 7
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 8
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 9
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 10
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 11
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 12
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 13
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 14
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 15
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 16
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 17
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 18
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 19
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 20
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 21
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 22
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 23
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 24
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 25
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 26
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 27
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 28
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 29
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 30
    ,CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + 31

    /* the table not supported properly by the CPSS .. no need to allocate table */
    ,CPSS_DXCH_SIP5_TABLE_ADJACENCY_E
     /* counters changed by the Device on traffic ... so no shadow support */
    ,CPSS_DXCH_SIP5_TABLE_BMA_MULTICAST_COUNTERS_E /**/
     /* counters changed by the Device on traffic ... so no shadow support */
    ,CPSS_DXCH_SIP5_TABLE_TXQ_LINK_LIST_COUNTERS_Q_MAIN_DESC_E
     /* counters changed by the Device on traffic ... so no shadow support */
    ,CPSS_DXCH_SIP5_TABLE_PFC_LLFC_COUNTERS_E
    /* the 32 bits are <age> that the device changes to 1 when traffic hit rout entry */
    ,CPSS_DXCH_SIP5_TABLE_IPVX_ROUTER_NEXTHOP_AGE_BITS_E
    /* the 32 bits are <Wraparound indication> that the device changes to 1 when IPFIX entry counters Wraparound */
    ,CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_IPFIX_ALERT_WRAPAROUND_E
    /* the 32 bits are <Wraparound indication> that the device changes to 1 when IPFIX entry counters Wraparound */
    ,CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_IPFIX_ALERT_WRAPAROUND_E
    /* the 32 bits are <Wraparound indication> that the device changes to 1 when IPFIX entry counters Wraparound */
    ,CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_IPFIX_ALERT_WRAPAROUND_E
    /* <Aging table entry>. Set to 1 by device when IPFIX memory entry is accessed by traffic */
    ,CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_IPFIX_ALERT_AGING_E
    /* <Aging table entry>. Set to 1 by device when IPFIX memory entry is accessed by traffic */
    ,CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_IPFIX_ALERT_AGING_E
    /* <Aging table entry>. Set to 1 by device when IPFIX memory entry is accessed by traffic */
    ,CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_IPFIX_ALERT_AGING_E

    /* counters changed by the Device on traffic ... so no shadow support */
    ,CPSS_DXCH_SIP5_TABLE_BRIDGE_PHYSICAL_PORT_RATE_LIMIT_COUNTERS_E

    /* aging bit updated by HW during traffic so no shadow support */
    ,CPSS_DXCH_SIP6_TABLE_LPM_AGING_E

    /* device manages content of following tables */
    ,CPSS_DXCH_SIP6_10_TABLE_EXACT_MATCH_AUTO_LEARNED_ENTRY_INDEX_E
    ,CPSS_DXCH_SIP6_15_TXQ_SDQ_PORT_PFC_STATE_E

     /*CNC counters changed by the Device on traffic ... so no shadow support */
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 1
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 2
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 3
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 4
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 5
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 6
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 7
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 8
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 9
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 10
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 11
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 12
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 13
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 14
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 15
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 16
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 17
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 18
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 19
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 20
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 21
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 22
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 23
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 24
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 25
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 26
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 27
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 28
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 29
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 30
    ,CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + 31

    /* HW tables not under CPSS control so no shadow support */
    ,CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_PARITY_E
    ,CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_ECC_E
    ,CPSS_DXCH_INTERNAL_TABLE_DESCRIPTORS_CONTROL_PARITY_E
    ,CPSS_DXCH_INTERNAL_TABLE_DESCRIPTORS_CONTROL_ECC_E
    ,CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_CONTROL_PARITY_E
    ,CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_CONTROL_ECC_E
    ,CPSS_DXCH_INTERNAL_TABLE_PHA_RAM_E
    ,CPSS_DXCH_INTERNAL_TABLE_CM3_RAM_E
    ,CPSS_DXCH_INTERNAL_TABLE_MANAGEMENT_E

    ,CPSS_DXCH_TABLE_LAST_E/* must be last*/
};


#define CNC_BIND_LOGICAL_TO_HW_MAC(index)\
    { CPSS_DXCH_LOGICAL_TABLE_CNC_BLOCK_0_E + index, { \
      CPSS_DXCH_SIP5_TABLE_CNC_0_COUNTERS_E + index,   \
        LAST_VALID_TABLE_CNS } }

#define CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(index)\
    { CPSS_DXCH_LOGICAL_TABLE_CNC_BLOCK_0_E + index, { \
      CPSS_DXCH_SIP6_10_TABLE_CNC_32_COUNTERS_E + index-32,   \
        LAST_VALID_TABLE_CNS } }

/*
 * cpssLogicalToHwTablesDB
 *
 * Description:
 *      Database with 'logical' tables content - hw tables list for each logical table
 *
 */
static const PRV_CPSS_DXCH_LOGICAL_ENTRY_STC cpssLogicalToHwTablesDB[] =
{

    { CPSS_DXCH_LOGICAL_TABLE_VLAN_E, {
        CPSS_DXCH_LION_TABLE_VLAN_INGRESS_E,
        CPSS_DXCH_SIP5_TABLE_INGRESS_BRIDGE_PORT_MEMBERS_E,
        CPSS_DXCH_SIP5_TABLE_INGRESS_SPAN_STATE_GROUP_INDEX_E,
        CPSS_DXCH_LION_TABLE_VLAN_EGRESS_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_VLAN_ATTRIBUTES_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_VLAN_SPANNING_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_QAG_EGRESS_VLAN_E,
        CPSS_DXCH_SIP5_TABLE_IPVX_EVLAN_E,
        CPSS_DXCH_SIP6_TABLE_TTI_VLAN_TO_VRF_ID_TABLE_E,
        CPSS_DXCH_SIP6_20_EGF_QAG_PORT_VLAN_Q_OFFSET_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_EPORT_E, {
        CPSS_DXCH_SIP5_TABLE_POST_TTI_LOOKUP_INGRESS_EPORT_E,
        CPSS_DXCH_SIP5_TABLE_BRIDGE_INGRESS_EPORT_E,
        CPSS_DXCH_SIP5_TABLE_BRIDGE_INGRESS_EPORT_LEARN_PRIO_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_EPORT_FILTER_E,
        CPSS_DXCH_SIP5_TABLE_EQ_INGRESS_EPORT_E,
        CPSS_DXCH_SIP5_TABLE_EQ_EPORT_TO_PHYSICAL_PORT_TARGET_MAPPING_E,
        CPSS_DXCH_SIP5_TABLE_EQ_EPORT_TO_LOC_MAPPING_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_QAG_EGRESS_EPORT_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_EGRESS_EPORT_E,
        CPSS_DXCH_SIP5_TABLE_HA_EGRESS_EPORT_1_E,
        CPSS_DXCH_SIP5_TABLE_HA_EGRESS_EPORT_2_E,
        CPSS_DXCH_SIP5_TABLE_IPVX_INGRESS_EPORT_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_PHYSICAL_PORT_E, {
        CPSS_DXCH_SIP5_TABLE_TTI_PHYSICAL_PORT_ATTRIBUTE_E,
        CPSS_DXCH_SIP5_TABLE_BRIDGE_PHYSICAL_PORT_E,
        CPSS_DXCH_SIP5_TABLE_BRIDGE_PHYSICAL_PORT_RATE_LIMIT_COUNTERS_E,
        CPSS_DXCH_SIP5_TABLE_EQ_INGRESS_STC_PHYSICAL_PORT_E,
        CPSS_DXCH_LION_TABLE_TXQ_EGRESS_STC_E,
        CPSS_DXCH_SIP5_TABLE_EQ_INGRESS_MIRROR_PHYSICAL_PORT_E,
        CPSS_DXCH_SIP5_TABLE_TM_FCU_PORT_TO_PHYSICAL_PORT_MAPPING_E,
        CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_1_E,
        CPSS_DXCH_SIP5_TABLE_HA_PHYSICAL_PORT_2_E,
        CPSS_DXCH_SIP5_20_TABLE_TTI_PHYSICAL_PORT_ATTRIBUTE_2_E,
        CPSS_DXCH_SIP5_20_TABLE_EGF_QAG_PORT_SOURCE_ATTRIBUTES_E,
        CPSS_DXCH_SIP5_20_TABLE_EGF_QAG_PORT_TARGET_ATTRIBUTES_E,
        CPSS_DXCH_SIP5_TABLE_TM_FCU_TC_PORT_TO_CNODE_PORT_MAPPING_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_QAG_TARGET_PORT_MAPPER_E,
        CPSS_DXCH_SIP5_TABLE_BMA_PORT_MAPPING_E,
        CPSS_DXCH_SIP5_TABLE_TTI_PTP_COMMAND_E,
        CPSS_DXCH_SIP5_TABLE_ERMRK_PTP_TARGET_PORT_E,
        CPSS_DXCH_SIP5_TABLE_ERMRK_PTP_SOURCE_PORT_E,
        CPSS_DXCH_SIP6_TABLE_TTI_PORT_TO_QUEUE_TRANSLATION_TABLE_E,
        CPSS_DXCH_SIP6_TXQ_PDX_DX_QGRPMAP_E,
        CPSS_DXCH_SIP6_TABLE_PREQ_CNC_PORT_MAPPING_E,
        CPSS_DXCH_SIP6_TABLE_PREQ_TARGET_PHYSICAL_PORT_E,

        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_TXQ_EGRESS_STC__DQ_1_E,
        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_TXQ_EGRESS_STC__DQ_2_E,
        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_TXQ_EGRESS_STC__DQ_3_E,
        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_TXQ_EGRESS_STC__DQ_4_E,
        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_TXQ_EGRESS_STC__DQ_5_E,

        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_TTI_PORT_MAPPING__DQ_0_E,
        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_TTI_PORT_MAPPING__DQ_1_E,
        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_TTI_PORT_MAPPING__DQ_2_E,
        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_TTI_PORT_MAPPING__DQ_3_E,
        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_TTI_PORT_MAPPING__DQ_4_E,
        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_TTI_PORT_MAPPING__DQ_5_E,


#if 0
        /* Is accessed through CPSS_DXCH_SIP5_TABLE_EQ_INGRESS_STC_PHYSICAL_PORT_E */
        CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_EQ_INGRESS_STC_PHYSICAL_PORT_PIPE_1_E */,
#endif
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_PORT_ISOLATION_E, {
        CPSS_DXCH_LION_TABLE_PORT_ISOLATION_L2_E,
        CPSS_DXCH_LION_TABLE_PORT_ISOLATION_L3_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_STG_E, {
        CPSS_DXCH_LION_TABLE_STG_INGRESS_E,
        CPSS_DXCH_LION_TABLE_STG_EGRESS_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_VLAN_TRANSLATION_E, {
        CPSS_DXCH3_TABLE_INGRESS_VLAN_TRANSLATION_E,
        CPSS_DXCH3_TABLE_EGRESS_VLAN_TRANSLATION_E,
        LAST_VALID_TABLE_CNS }  },


    { CPSS_DXCH_LOGICAL_TABLE_VRF_E, {
        CPSS_DXCH_SIP5_TABLE_IPV4_VRF_E,
        CPSS_DXCH_SIP5_TABLE_IPV6_VRF_E,
        CPSS_DXCH_SIP5_TABLE_FCOE_VRF_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_QOS_PROFILE_E, {
        CPSS_DXCH_TABLE_QOS_PROFILE_E,
        CPSS_DXCH_SIP5_TABLE_HA_QOS_PROFILE_TO_EXP_E,
        CPSS_DXCH_SIP6_TABLE_INGRESS_POLICER_0_QOS_ATTRIBUTE_TABLE_E,
        CPSS_DXCH_SIP6_TABLE_EGRESS_POLICER_QOS_ATTRIBUTE_TABLE_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_PROTECTION_LOC_E, {
        CPSS_DXCH_SIP5_TABLE_EQ_PROTECTION_LOC_E,
        CPSS_DXCH_SIP5_20_TABLE_EQ_TX_PROTECTION_LOC_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_TRUNK_MEMBERS_E, {
        CPSS_DXCH_LION_TABLE_TXQ_NON_TRUNK_MEMBERS_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_NON_TRUNK_MEMBERS2_E,
        CPSS_DXCH_SIP5_TABLE_EQ_TRUNK_LTT_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_TM_MAPPING_E, {
        CPSS_DXCH_SIP5_TABLE_TM_EGR_GLUE_TARGET_INTERFACE_E,
        CPSS_DXCH_SIP5_TABLE_TM_FCU_ETH_DMA_TO_TM_PORT_MAPPING_E,
        CPSS_DXCH_SIP5_TABLE_TM_FCU_ILK_DMA_TO_TM_PORT_MAPPING_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_PFC_MODE_PROFILE_TC_THRESHOLDS_E, {
        CPSS_DXCH_SIP5_TABLE_PFC_MODE_PROFILE_TC_XOFF_THRESHOLDS_E,
        CPSS_DXCH_SIP5_TABLE_PFC_MODE_PROFILE_TC_XON_THRESHOLDS_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_TAIL_DROP_QUEUE_LIMITS_E, {
        CPSS_DXCH_SIP5_TABLE_TAIL_DROP_MAX_QUEUE_LIMITS_E,
        CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP0_E,
        CPSS_DXCH_SIP5_TABLE_TAIL_DROP_DQ_QUEUE_BUF_LIMITS_E,
        CPSS_DXCH_SIP5_TABLE_TAIL_DROP_DQ_QUEUE_DESC_LIMITS_E,
        CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP1_E,
        CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP2_E,
        CPSS_DXCH_SIP6_TABLE_PREQ_QUEUE_DP_CONFIGURATIONS_E,
        CPSS_DXCH_SIP6_TABLE_PREQ_QUEUE_CONFIGURATIONS_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_PCL_CONFIG_E, {
        CPSS_DXCH_TABLE_PCL_CONFIG_E,
        CPSS_DXCH_XCAT2_TABLE_INGRESS_PCL_LOOKUP01_CONFIG_E,
        CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_LOOKUP1_CONFIG_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_PCL_UDB_CONFIG_E, {
        CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_UDB_CONFIG_E,
        CPSS_DXCH_SIP5_TABLE_HA_EPCL_UDB_CONFIG_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_PCL_UDB_SELECT_E, {
        CPSS_DXCH_SIP5_TABLE_IPCL0_UDB_SELECT_E,
        CPSS_DXCH_SIP5_TABLE_IPCL1_UDB_SELECT_E,
        CPSS_DXCH_SIP5_TABLE_IPCL2_UDB_SELECT_E,
        CPSS_DXCH_SIP5_TABLE_EPCL_UDB_SELECT_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_OAM_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_OAM_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_OAM_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_OAM_KEEPALIVE_AGING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_OAM_KEEPALIVE_AGING_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_OAM_KEEPALIVE_AGING_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_OAM_EXCEPTION_SUMMARY_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_OAM_EXCEPTION_SUMMARY_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_OAM_EXCEPTION_SUMMARY_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_OAM_EXCEPTIONS_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_OAM_MEG_EXCEPTION_E,
        CPSS_DXCH_SIP5_TABLE_INGRESS_OAM_SOURCE_INTERFACE_EXCEPTION_E,
        CPSS_DXCH_SIP5_TABLE_INGRESS_OAM_INVALID_KEEPALIVE_HASH_E,
        CPSS_DXCH_SIP5_TABLE_INGRESS_OAM_KEEPALIVE_EXCESS_E,
        CPSS_DXCH_SIP5_TABLE_INGRESS_OAM_RDI_STATUS_CHANGE_EXCEPTION_E,
        CPSS_DXCH_SIP5_TABLE_INGRESS_OAM_TX_PERIOD_EXCEPTION_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_OAM_MEG_EXCEPTION_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_OAM_SOURCE_INTERFACE_EXCEPTION_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_OAM_INVALID_KEEPALIVE_HASH_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_OAM_KEEPALIVE_EXCESS_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_OAM_RDI_STATUS_CHANGE_EXCEPTION_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_OAM_TX_PERIOD_EXCEPTION_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_OAM_OPCODE_PACKET_COMMAND_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_OAM_OPCODE_PACKET_COMMAND_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_OAM_OPCODE_PACKET_COMMAND_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_POLICER_ATTRIBUTES_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_E_ATTRIBUTES_E,
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_E_ATTRIBUTES_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_E_ATTRIBUTES_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_REMARKING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_REMARKING_E,
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_REMARKING_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_0_METERING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_METERING_E,
        CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_0_METERING_CONFIG_E,
        CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_0_METERING_CONFORM_SIGN_E,
        LAST_VALID_TABLE_CNS }  },


    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_METERING_E, {
        /* in sip5.15, sip5.20 HW table list is different.
           see prvCpssDxChDiagDataIntegrityTableLogicalToHwListGet */
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_METERING_E,
        CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_1_METERING_CONFIG_E,
        CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_1_METERING_CONFORM_SIGN_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_METERING_E, {
        /* in sip5.20 HW table list is different. See cpssLogicalToHwTableDbSip5_20 */
        CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_METERING_E,
        CPSS_DXCH_SIP5_15_TABLE_EGRESS_POLICER_METERING_CONFIG_E,
        CPSS_DXCH_SIP5_15_TABLE_EGRESS_POLICER_METERING_CONFORM_SIGN_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_0_COUNTING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_COUNTING_E,
        LAST_VALID_TABLE_CNS }  },
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_COUNTING_E, {
        /* in sip5.20 HW table list is different. See cpssLogicalToHwTableDbSip5_20 */
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_COUNTING_E,
        LAST_VALID_TABLE_CNS }  },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_COUNTING_E, {
        /* in sip5.20 HW table list is different. See cpssLogicalToHwTableDbSip5_20 */
        CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_COUNTING_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_0_IPFIX_ALERT_WRAPAROUND_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_IPFIX_ALERT_WRAPAROUND_E,
        LAST_VALID_TABLE_CNS }  },
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_IPFIX_ALERT_WRAPAROUND_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_IPFIX_ALERT_WRAPAROUND_E,
        LAST_VALID_TABLE_CNS }  },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_IPFIX_ALERT_WRAPAROUND_E, {
        CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_IPFIX_ALERT_WRAPAROUND_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_0_IPFIX_ALERT_AGING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_IPFIX_ALERT_AGING_E,
        LAST_VALID_TABLE_CNS }  },
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_IPFIX_ALERT_AGING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_IPFIX_ALERT_AGING_E,
        LAST_VALID_TABLE_CNS }  },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_IPFIX_ALERT_AGING_E, {
        CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_IPFIX_ALERT_AGING_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_DEFAULT_EPORT_E, { CPSS_DXCH_SIP5_TABLE_PRE_TTI_LOOKUP_INGRESS_EPORT_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_FDB_E, {  CPSS_DXCH_TABLE_FDB_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_IPVX_ROUTER_ACCESS_MATRIX_E, {  CPSS_DXCH_SIP5_TABLE_IPVX_ROUTER_ACCESS_MATRIX_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TM_QUEUE_MAP_CPU_CODE_TO_TC_E, {  CPSS_DXCH_SIP5_TABLE_TM_QMAP_CPU_CODE_TO_TC_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TM_QUEUE_MAP_TARGET_DEV_TO_INDEX_E, {  CPSS_DXCH_SIP5_TABLE_TM_QMAP_TARGET_DEV_TO_INDEX_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TM_QUEUE_MAP_POLICING_ENABLE_E, {  CPSS_DXCH_SIP5_TABLE_TM_QMAP_POLICING_ENABLE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TM_QUEUE_MAP_QUEUE_ID_SELECTOR_E, {  CPSS_DXCH_SIP5_TABLE_TM_QMAP_QUEUE_ID_SELECTOR_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TM_L1_PACKET_LENGTH_OFFSET_E, {  CPSS_DXCH_SIP5_TABLE_TM_INGR_GLUE_L1_PKT_LEN_OFFSET_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TM_DROP_MASKING_E, {  CPSS_DXCH_SIP5_TABLE_TM_DROP_DROP_MASKING_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TM_DROP_QUEUE_PROFILE_ID_E, {  CPSS_DXCH_SIP5_TABLE_TM_DROP_QUEUE_PROFILE_ID_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TCAM_E, {  CPSS_DXCH_SIP5_TABLE_TCAM_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TCAM_ACTION_E, {  CPSS_DXCH_SIP5_TABLE_TCAM_PCL_TTI_ACTION_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_FORWARD_FROM_CPU_TO_LOOPBACK_MAPPER_E, {
                CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_QAG_FWD_FROM_CPU_TO_LOOPBACK_MAPPER_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_FAST_STACK_FAILOVER_SECONDARY_TARGET_PORT_E, {
                CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_EFT_FAST_STACK_FAILOVER_SECONDARY_TARGET_PORT_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_DEVICE_MAP_TABLE_E, {  CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_DEVICE_MAP_TABLE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TX_PROTECTION_E, {  CPSS_DXCH_SIP5_TABLE_EQ_TX_PROTECTION_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_L2_MLL_E, {  CPSS_DXCH_SIP5_TABLE_L2_MLL_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_L2_MLL_LTT_E, {  CPSS_DXCH_SIP5_TABLE_L2_MLL_LTT_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TRUNK_HASH_MASK_CRC_E, {  CPSS_DXCH_LION_TABLE_TRUNK_HASH_MASK_CRC_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_BRIDGE_SOURCE_TRUNK_ATTRIBUTE_E, {  CPSS_DXCH_SIP5_TABLE_BRIDGE_SOURCE_TRUNK_ATTRIBUTE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TUNNEL_START_CONFIG_E, {  CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_ARP_E, {  CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_NAT_E, {  CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_GENERIC_TUNNEL_START_PROFILE_E, {  CPSS_DXCH_SIP5_TABLE_HA_GENERIC_TS_PROFILE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_CN_SAMPLE_INTERVALS_E, {  CPSS_DXCH_SIP5_TABLE_CN_SAMPLE_INTERVALS_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_BUFFERS_MANAGER_MULTICAST_COUNTERS_E, {  CPSS_DXCH_SIP5_TABLE_BMA_MULTICAST_COUNTERS_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_PFC_LLFC_COUNTERS_E, {  CPSS_DXCH_SIP5_TABLE_PFC_LLFC_COUNTERS_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TAIL_DROP_QUEUES_BUFFERS_COUNTERS_E, {  CPSS_DXCH_SIP5_TABLE_TAIL_DROP_COUNTERS_Q_MAIN_BUFF_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TAIL_DROP_QUEUES_MULTICASTC_BUFFERS_COUNTERS_E, {  CPSS_DXCH_SIP5_TABLE_TAIL_DROP_COUNTERS_Q_MAIN_MC_BUFF_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TXQ_LINK_LIST_QUEUES_DESCRIPTORS_COUNTERS_E, {  CPSS_DXCH_SIP5_TABLE_TXQ_LINK_LIST_COUNTERS_Q_MAIN_DESC_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_IP_MLL_E, {  CPSS_DXCH_SIP5_TABLE_IP_MLL_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_IPVX_ROUTER_NEXTHOP_E, {  CPSS_DXCH_SIP5_TABLE_IPVX_ROUTER_NEXTHOP_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_IPVX_ROUTER_NEXTHOP_AGE_BITS_E, {  CPSS_DXCH_SIP5_TABLE_IPVX_ROUTER_NEXTHOP_AGE_BITS_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_ROUTER_MAC_SA_E, {  CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_GLOBAL_MAC_SA_E, {  CPSS_DXCH_SIP5_TABLE_HA_GLOBAL_MAC_SA_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_IPVX_ROUTER_QOS_PROFILE_OFFSETS_E, {  CPSS_DXCH_SIP5_TABLE_IPVX_ROUTER_QOS_PROFILE_OFFSETS_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_MAC2ME_E, {  CPSS_DXCH3_TABLE_MAC2ME_E,
        LAST_VALID_TABLE_CNS } },
/*  removed because not memory in the device .. it is 'registers'
    { CPSS_DXCH_LOGICAL_TABLE_ADJACENCY_E, {  CPSS_DXCH_SIP5_TABLE_ADJACENCY_E,
        LAST_VALID_TABLE_CNS } },*/
    { CPSS_DXCH_LOGICAL_TABLE_TTI_UDB_CONFIG_E, {  CPSS_DXCH_SIP5_TABLE_TTI_UDB_CONFIG_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_PTP_DOMAIN_E, {  CPSS_DXCH_SIP5_TABLE_HA_PTP_DOMAIN_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_REMARKING_TIMESTAMP_CFG_E, {  CPSS_DXCH_SIP5_TABLE_ERMRK_TIMESTAMP_CFG_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_REMARKING_PTP_LOCAL_ACTION_E, {  CPSS_DXCH_SIP5_TABLE_ERMRK_PTP_LOCAL_ACTION_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_OAM_LM_OFFSET_E, {  CPSS_DXCH_SIP5_TABLE_OAM_LM_OFFSET_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_REMARKING_E, {  CPSS_DXCH_XCAT_TABLE_EGRESS_POLICER_REMARKING_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_0_HIERARCHICAL_E, {  CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_HIERARCHICAL_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TXQ_DESIGNATED_PORT_E, {  CPSS_DXCH_LION_TABLE_TXQ_DESIGNATED_PORT_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_TC_DP_MAPPER_E, {  CPSS_DXCH_SIP5_20_TABLE_EGF_QAG_TC_DP_MAPPER_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_MULTICAST_E, {  CPSS_DXCH_TABLE_MULTICAST_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TXQ_SOURCE_ID_MEMBERS_E, {  CPSS_DXCH_LION_TABLE_TXQ_SOURCE_ID_MEMBERS_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_STATISTICAL_RATE_LIMIT_E, {  CPSS_DXCH_TABLE_STATISTICAL_RATE_LIMIT_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_CPU_CODE_E, {  CPSS_DXCH_TABLE_CPU_CODE_E,
        CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_QAG_CPU_CODE_TO_LOOPBACK_MAPPER_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TO_CPU_RATE_LIMITER_CONFIG_E, {  CPSS_DXCH_SIP5_TABLE_EQ_TO_CPU_RATE_LIMITER_CONFIG_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_E_VLAN_MAPPER_E, {  CPSS_DXCH_SIP5_TABLE_EGRESS_EGF_SHT_VLAN_MAPPER_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_LPM_MEM_E, {  CPSS_DXCH_SIP5_TABLE_LPM_MEM_E,
        CPSS_DXCH_SIP5_20_TABLE_LPM_MEM_PIPE_1_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_ECMP_E, {
        CPSS_DXCH_SIP5_TABLE_ECMP_E,
        CPSS_DXCH_SIP6_TABLE_IPVX_ECMP_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TTI_QOS_MAP_DSCP_TO_QOS_PROFILE_E, {  CPSS_DXCH_SIP5_TABLE_TTI_QOS_MAP_DSCP_TO_QOS_PROFILE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TTI_QOS_MAP_UP_CFI_TO_QOS_PROFILE_E, {  CPSS_DXCH_SIP5_TABLE_TTI_QOS_MAP_UP_CFI_TO_QOS_PROFILE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TTI_QOS_MAP_EXP_TO_QOS_PROFILE_E, {  CPSS_DXCH_SIP5_TABLE_TTI_QOS_MAP_EXP_TO_QOS_PROFILE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TTI_QOS_MAP_DSCP_TO_DSCP_E, {  CPSS_DXCH_SIP5_TABLE_TTI_QOS_MAP_DSCP_TO_DSCP_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_REMARKING_QOS_DSCP_MAP_E, {  CPSS_DXCH_SIP5_TABLE_ERMRK_QOS_DSCP_MAP_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_REMARKING_QOS_TC_DP_MAP_E, {  CPSS_DXCH_SIP5_TABLE_ERMRK_QOS_TC_DP_MAP_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TM_FCU_PORT_INGRESS_TIMERS_CONFIG_E, {  CPSS_DXCH_SIP5_TABLE_TM_FCU_PORT_INGRESS_TIMERS_CONFIG_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TM_AGING_QUEUE_PROFILE_E, {  CPSS_DXCH_SIP5_TABLE_TM_EGR_GLUE_AGING_QUEUE_PROFILE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TM_AGING_PROFILE_THESHOLDS_E, {  CPSS_DXCH_SIP5_TABLE_TM_EGR_GLUE_AGING_PROFILE_THESHOLDS_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_L2_ECMP_E, { CPSS_DXCH_SIP5_TABLE_EQ_L2_ECMP_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_VLAN_PORT_PROTOCOL_E, {  CPSS_DXCH_TABLE_VLAN_PORT_PROTOCOL_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_L2_ECMP_LTT_E, {  CPSS_DXCH_SIP5_TABLE_EQ_L2_ECMP_LTT_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TXQ_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG_E, {
            CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG_E,
            CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG__DQ_1_E,
            CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG__DQ_2_E,
            CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG__DQ_3_E,
            CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG__DQ_4_E,
            CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG__DQ_5_E,
            LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TXQ_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG_E, {
            CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG_E,
            CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG__DQ_1_E,
            CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG__DQ_2_E,
            CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG__DQ_3_E,
            CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG__DQ_4_E,
            CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG__DQ_5_E,

            LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_PCL_CONFIG_E, {  CPSS_DXCH2_TABLE_EGRESS_PCL_CONFIG_E,
        LAST_VALID_TABLE_CNS } },

    CNC_BIND_LOGICAL_TO_HW_MAC(0),
    CNC_BIND_LOGICAL_TO_HW_MAC(1),
    CNC_BIND_LOGICAL_TO_HW_MAC(2),
    CNC_BIND_LOGICAL_TO_HW_MAC(3),
    CNC_BIND_LOGICAL_TO_HW_MAC(4),
    CNC_BIND_LOGICAL_TO_HW_MAC(5),
    CNC_BIND_LOGICAL_TO_HW_MAC(6),
    CNC_BIND_LOGICAL_TO_HW_MAC(7),
    CNC_BIND_LOGICAL_TO_HW_MAC(8),
    CNC_BIND_LOGICAL_TO_HW_MAC(9),
    CNC_BIND_LOGICAL_TO_HW_MAC(10),
    CNC_BIND_LOGICAL_TO_HW_MAC(11),
    CNC_BIND_LOGICAL_TO_HW_MAC(12),
    CNC_BIND_LOGICAL_TO_HW_MAC(13),
    CNC_BIND_LOGICAL_TO_HW_MAC(14),
    CNC_BIND_LOGICAL_TO_HW_MAC(15),
    CNC_BIND_LOGICAL_TO_HW_MAC(16),
    CNC_BIND_LOGICAL_TO_HW_MAC(17),
    CNC_BIND_LOGICAL_TO_HW_MAC(18),
    CNC_BIND_LOGICAL_TO_HW_MAC(19),
    CNC_BIND_LOGICAL_TO_HW_MAC(20),
    CNC_BIND_LOGICAL_TO_HW_MAC(21),
    CNC_BIND_LOGICAL_TO_HW_MAC(22),
    CNC_BIND_LOGICAL_TO_HW_MAC(23),
    CNC_BIND_LOGICAL_TO_HW_MAC(24),
    CNC_BIND_LOGICAL_TO_HW_MAC(25),
    CNC_BIND_LOGICAL_TO_HW_MAC(26),
    CNC_BIND_LOGICAL_TO_HW_MAC(27),
    CNC_BIND_LOGICAL_TO_HW_MAC(28),
    CNC_BIND_LOGICAL_TO_HW_MAC(29),
    CNC_BIND_LOGICAL_TO_HW_MAC(30),
    CNC_BIND_LOGICAL_TO_HW_MAC(31),

    { CPSS_DXCH_LOGICAL_TABLE_IPVX_ROUTER_ECMP_INDIRECT_NEXT_HOP_E, {  CPSS_DXCH_SIP5_25_TABLE_IPVX_ROUTER_ECMP_POINTER_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TAIL_DROP_PORT_MAX_BUFFER_FILL_LEVEL_E, {  CPSS_DXCH_SIP5_25_TABLE_TAIL_DROP_PORT_MAX_BUFFER_FILL_LEVEL_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_TAIL_DROP_QUEUE_MAX_BUFFER_FILL_LEVEL_E, {  CPSS_DXCH_SIP5_25_TABLE_TAIL_DROP_QUEUE_MAX_BUFFER_FILL_LEVEL_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_LATENCY_MONITORING_E, {  CPSS_DXCH_SIP6_TABLE_EGRESS_PCL_PORT_LATENCY_MONITORING_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_LATENCY_MONITORING_PORT_CONFIG_E, {
        CPSS_DXCH_SIP6_TABLE_EGRESS_PCL_TARGET_PHYSICAL_PORT_MAPPING_E,
        CPSS_DXCH_SIP6_TABLE_EGRESS_PCL_SOURCE_PHYSICAL_PORT_MAPPING_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_PROFILE_CONFIG_E, {  CPSS_DXCH_SIP6_TABLE_PREQ_PORT_PROFILE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_BRIDGE_L2_DLB_PATH_UTILIZATION_TABLE_E, {  CPSS_DXCH_SIP6_TABLE_EQ_L2ECMP_PATH_UTILIZATION_TABLE0_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_POLICER_PORT_CONFIG_E, {
        CPSS_DXCH_SIP6_TABLE_INGRESS_POLICER_0_PORT_ATTRIBUTE_TABLE_E,
        CPSS_DXCH_SIP6_TABLE_INGRESS_POLICER_1_PORT_ATTRIBUTE_TABLE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_PHA_FW_IMAGE_E, {  CPSS_DXCH_SIP6_TABLE_PHA_FW_IMAGE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_PHA_SHARED_DMEM_E, {  CPSS_DXCH_SIP6_TABLE_PHA_SHARED_DMEM_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_PHA_THREAD_ID_E, {
        CPSS_DXCH_SIP6_TABLE_PHA_PPA_THREADS_CONF_1_E,
        CPSS_DXCH_SIP6_TABLE_PHA_PPA_THREADS_CONF_2_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_PHA_SOURCE_PORT_E, {  CPSS_DXCH_SIP6_TABLE_PHA_SOURCE_PHYSICAL_PORT_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_PHA_TARGET_PORT_E, {  CPSS_DXCH_SIP6_TABLE_PHA_TARGET_PHYSICAL_PORT_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_LPM_AGING_E, {  CPSS_DXCH_SIP6_TABLE_LPM_AGING_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_PARITY_E, {  CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_PARITY_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_ECC_E, {  CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_ECC_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_DESCRIPTORS_CONTROL_ECC_E, {  CPSS_DXCH_INTERNAL_TABLE_DESCRIPTORS_CONTROL_ECC_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_DESCRIPTORS_CONTROL_PARITY_E, {  CPSS_DXCH_INTERNAL_TABLE_DESCRIPTORS_CONTROL_PARITY_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_CONTROL_PARITY_E, {  CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_CONTROL_PARITY_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_CONTROL_ECC_E, {  CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_CONTROL_ECC_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PHA_RAM_E, {  CPSS_DXCH_INTERNAL_TABLE_PHA_RAM_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_CM3_RAM_E, {  CPSS_DXCH_INTERNAL_TABLE_CM3_RAM_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_MANAGEMENT_E, {  CPSS_DXCH_INTERNAL_TABLE_MANAGEMENT_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_LATENCY_MONITORING_CONFIG_E, {
        CPSS_DXCH_SIP6_TABLE_LMU_CONFIGURATION_E,
        CPSS_DXCH_SIP6_TABLE_LMU_CONFIGURATION_E + 1,
        CPSS_DXCH_SIP6_TABLE_LMU_CONFIGURATION_E + 2,
        CPSS_DXCH_SIP6_TABLE_LMU_CONFIGURATION_E + 3,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_LATENCY_MONITORING_STATISTICS_E, {
        CPSS_DXCH_SIP6_TABLE_LMU_STATISTICS_E,
        CPSS_DXCH_SIP6_TABLE_LMU_STATISTICS_E + 1,
        CPSS_DXCH_SIP6_TABLE_LMU_STATISTICS_E + 2,
        CPSS_DXCH_SIP6_TABLE_LMU_STATISTICS_E + 3,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EXACT_MATCH_E, {  CPSS_DXCH_SIP6_TABLE_EXACT_MATCH_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_PORT_MAC_COUNTERS_E, {  CPSS_DXCH_SIP6_TABLE_MTIP_MAC_STAT_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EXACT_MATCH_AUTO_LEARNED_ENTRY_INDEX_E, {  CPSS_DXCH_SIP6_10_TABLE_EXACT_MATCH_AUTO_LEARNED_ENTRY_INDEX_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_PPU_ACTION_TABLE_E, {
        CPSS_DXCH_SIP6_10_TABLE_PPU_ACTION_TABLE_0_E,
        CPSS_DXCH_SIP6_10_TABLE_PPU_ACTION_TABLE_1_E,
        CPSS_DXCH_SIP6_10_TABLE_PPU_ACTION_TABLE_2_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_0_IPFIX_FIRST_N_PACKETS_E, {
        CPSS_DXCH_SIP6_10_TABLE_INGRESS_POLICER_0_IPFIX_FIRST_N_PACKETS_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_IPFIX_FIRST_N_PACKETS_E, {
        CPSS_DXCH_SIP6_10_TABLE_INGRESS_POLICER_1_IPFIX_FIRST_N_PACKETS_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_IPFIX_FIRST_N_PACKETS_E, {
        CPSS_DXCH_SIP6_10_TABLE_EGRESS_POLICER_IPFIX_FIRST_N_PACKETS_E,
        LAST_VALID_TABLE_CNS } },

    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(32),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(33),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(34),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(35),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(36),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(37),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(38),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(39),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(40),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(41),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(42),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(43),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(44),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(45),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(46),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(47),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(48),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(49),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(50),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(51),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(52),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(53),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(54),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(55),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(56),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(57),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(58),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(59),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(60),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(61),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(62),
    CNC_BIND_HAWK_LOGICAL_TO_HW_MAC(63),

    /********* must be last ***************/
    { CPSS_DXCH_LOGICAL_TABLE_LAST_E, {  LAST_VALID_TABLE_CNS} }
};

static const PRV_CPSS_DXCH_LOGICAL_ENTRY_STC cpssLogicalToHwTableDbSip5_15[] = {
    /* Important! Functions making lookup in this DB assumes that items in this
       DB goes in the same order as in cpssLogicalToHwTablesDB */
    {CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_METERING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_METERING_E,
        CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_0_METERING_CONFIG_E,
        CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_1_METERING_CONFORM_SIGN_E,
        LAST_VALID_TABLE_CNS } },
    /********* must be last ***************/
    { CPSS_DXCH_LOGICAL_TABLE_LAST_E, {  LAST_VALID_TABLE_CNS} }
};

static const PRV_CPSS_DXCH_LOGICAL_ENTRY_STC cpssLogicalToHwTableDbSip5_20[] = {
    /* Important! Functions making lookup in this DB assumes that items in this
       DB goes in the same order as in cpssLogicalToHwTablesDB */
    {CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_METERING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_METERING_E,
        CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_0_METERING_CONFIG_E,
        CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_1_METERING_CONFORM_SIGN_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_METERING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_METERING_E,
        CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_0_METERING_CONFIG_E,
        CPSS_DXCH_SIP5_15_TABLE_EGRESS_POLICER_METERING_CONFORM_SIGN_E,
        LAST_VALID_TABLE_CNS }  },
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_COUNTING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_COUNTING_E,
        LAST_VALID_TABLE_CNS }  },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_COUNTING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_COUNTING_E,
        LAST_VALID_TABLE_CNS }  },


    /********* must be last ***************/
    { CPSS_DXCH_LOGICAL_TABLE_LAST_E, {  LAST_VALID_TABLE_CNS} }
};

static const PRV_CPSS_DXCH_LOGICAL_ENTRY_STC cpssLogicalToHwTableDbSip6[] = {
    /* Important! Functions making lookup in this DB assumes that items in this
       DB goes in the same order as in cpssLogicalToHwTablesDB */
    {CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_METERING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_METERING_E,
        CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_1_METERING_CONFIG_E,
        CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_1_METERING_CONFORM_SIGN_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_METERING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_METERING_E,
        CPSS_DXCH_SIP5_15_TABLE_EGRESS_POLICER_METERING_CONFIG_E,
        CPSS_DXCH_SIP5_15_TABLE_EGRESS_POLICER_METERING_CONFORM_SIGN_E,
        LAST_VALID_TABLE_CNS }  },
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_COUNTING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_COUNTING_E,
        LAST_VALID_TABLE_CNS }  },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_COUNTING_E, {
        CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_COUNTING_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_LPM_MEM_E, {
        CPSS_DXCH_SIP5_TABLE_LPM_MEM_E,
        CPSS_DXCH_SIP6_TABLE_PBR_E,
        LAST_VALID_TABLE_CNS }  },

    /********* must be last ***************/
    { CPSS_DXCH_LOGICAL_TABLE_LAST_E, {  LAST_VALID_TABLE_CNS} }
};

/*
 * cpssLogicalToHwTablesDBAc5
 *
 * Description:
 *      Database with 'logical' tables content for AC5 devices - hw tables list for each logical table
 *
 */
static const PRV_CPSS_DXCH_LOGICAL_ENTRY_STC cpssLogicalToHwTablesDBAc5[] =
{

    { CPSS_DXCH_LOGICAL_TABLE_VLAN_E, {
        CPSS_DXCH_TABLE_VLAN_E,
        CPSS_DXCH3_TABLE_VRF_ID_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_PHYSICAL_PORT_E, {
        CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
        CPSS_DXCH_TABLE_PORT_VLAN_QOS_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_STG_E, {
        CPSS_DXCH_TABLE_STG_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_VLAN_TRANSLATION_E, {
        CPSS_DXCH3_TABLE_INGRESS_VLAN_TRANSLATION_E,
        CPSS_DXCH3_TABLE_EGRESS_VLAN_TRANSLATION_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_QOS_PROFILE_E, {
        CPSS_DXCH_TABLE_QOS_PROFILE_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_TRUNK_MEMBERS_E, {
        CPSS_DXCH_TABLE_TRUNK_MEMBERS_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_PCL_CONFIG_E, {
        CPSS_DXCH_TABLE_PCL_CONFIG_E,
        CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_LOOKUP1_CONFIG_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_PCL_UDB_CONFIG_E, {
        CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_UDB_CONFIG_E,
        LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_FDB_E, {  CPSS_DXCH_TABLE_FDB_E,
        LAST_VALID_TABLE_CNS } },

    { CPSS_DXCH_LOGICAL_TABLE_L2_MLL_LTT_E, {  CPSS_DXCH_XCAT_TABLE_MLL_L2MLL_POINTER_MAPPING_E,
        LAST_VALID_TABLE_CNS } },

    { CPSS_DXCH_LOGICAL_TABLE_TUNNEL_START_CONFIG_E, {  CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E,
        LAST_VALID_TABLE_CNS } },

    { CPSS_DXCH_LOGICAL_TABLE_ARP_E, {  CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E,
        LAST_VALID_TABLE_CNS } },

    { CPSS_DXCH_LOGICAL_TABLE_CN_SAMPLE_INTERVALS_E, {  CPSS_DXCH_XCAT_TABLE_BCN_PROFILES_E,
        LAST_VALID_TABLE_CNS } },

    { CPSS_DXCH_LOGICAL_TABLE_IPVX_ROUTER_NEXTHOP_E, {  CPSS_DXCH2_UC_MC_ROUTE_NEXT_HOP_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_IPVX_ROUTER_NEXTHOP_AGE_BITS_E, {  CPSS_DXCH2_ROUTE_NEXT_HOP_AGE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_ROUTER_MAC_SA_E, {  CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_MAC2ME_E, {  CPSS_DXCH3_TABLE_MAC2ME_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_REMARKING_E, {  CPSS_DXCH_XCAT_TABLE_EGRESS_POLICER_REMARKING_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_MULTICAST_E, {  CPSS_DXCH_TABLE_MULTICAST_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_STATISTICAL_RATE_LIMIT_E, {  CPSS_DXCH_TABLE_STATISTICAL_RATE_LIMIT_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_CPU_CODE_E, {  CPSS_DXCH_TABLE_CPU_CODE_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_VLAN_PORT_PROTOCOL_E, {  CPSS_DXCH_TABLE_VLAN_PORT_PROTOCOL_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_PCL_CONFIG_E, {  CPSS_DXCH2_TABLE_EGRESS_PCL_CONFIG_E,
        LAST_VALID_TABLE_CNS } },

    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_PARITY_E, {  CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_PARITY_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_ECC_E, {  CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_ECC_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_DESCRIPTORS_CONTROL_ECC_E, {  CPSS_DXCH_INTERNAL_TABLE_DESCRIPTORS_CONTROL_ECC_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_DESCRIPTORS_CONTROL_PARITY_E, {  CPSS_DXCH_INTERNAL_TABLE_DESCRIPTORS_CONTROL_PARITY_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_CONTROL_PARITY_E, {  CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_CONTROL_PARITY_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_CONTROL_ECC_E, {  CPSS_DXCH_INTERNAL_TABLE_PACKET_DATA_CONTROL_ECC_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_CM3_RAM_E, {  CPSS_DXCH_INTERNAL_TABLE_CM3_RAM_E,
        LAST_VALID_TABLE_CNS } },
    { CPSS_DXCH_LOGICAL_INTERNAL_TABLE_MANAGEMENT_E, {  CPSS_DXCH_INTERNAL_TABLE_MANAGEMENT_E,
        LAST_VALID_TABLE_CNS } },

    { CPSS_DXCH_LOGICAL_TABLE_PORT_ISOLATION_E, { CPSS_DXCH_LION_TABLE_PORT_ISOLATION_L2_E,
                                                  CPSS_DXCH_LION_TABLE_PORT_ISOLATION_L3_E,
                                                  LAST_VALID_TABLE_CNS }  },

    CNC_BIND_LOGICAL_TO_HW_MAC(0),
    CNC_BIND_LOGICAL_TO_HW_MAC(1),
    CNC_BIND_LOGICAL_TO_HW_MAC(2),
    CNC_BIND_LOGICAL_TO_HW_MAC(3),

    { CPSS_DXCH_LOGICAL_TABLE_PORT_MAC_COUNTERS_E, { CPSS_DXCH_XCAT_TABLE_MIB_COUNTERS_E,
                                                     LAST_VALID_TABLE_CNS }  },

    { CPSS_DXCH_LOGICAL_TABLE_L2_MLL_E, { CPSS_DXCH_XCAT_TABLE_MLL_E,
                                            LAST_VALID_TABLE_CNS }  },

    /* Policer metering */
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_0_METERING_E, {CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_METERING_E,
                                                             LAST_VALID_TABLE_CNS}},
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_METERING_E, {CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_METERING_E,
                                                             LAST_VALID_TABLE_CNS}},
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_METERING_E,    {CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_METERING_E,
                                                             LAST_VALID_TABLE_CNS}},

    /* Policer counting */
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_0_COUNTING_E, {CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_COUNTING_E,
                                                             LAST_VALID_TABLE_CNS}},
    { CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_COUNTING_E, {CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_COUNTING_E,
                                                             LAST_VALID_TABLE_CNS}},
    { CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_COUNTING_E,    {CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_COUNTING_E,
                                                             LAST_VALID_TABLE_CNS}},

    /********* must be last ***************/
    { CPSS_DXCH_LOGICAL_TABLE_LAST_E, {  LAST_VALID_TABLE_CNS} }
};


/* returns number of relevant port group for given hw table */
static GT_U32 getNumOfRelevantPortGroups
(
    IN GT_U8                 devNum,
    IN GT_PORT_GROUPS_BMP    portGroupsBmp,
    IN CPSS_DXCH_TABLE_ENT   hwTable,
    OUT GT_U32               *myPortGroupPositionPtr
)
{
    GT_U32  portGroupId;
    GT_U32  numOfRelevantPortGroups = 0;
    GT_U32  firstPortGroupId = 0xFFFFFFFF;

    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* SIP_6 device has up to 8 processing pipes where most of tables hold
           exactly same data. Need only one shadow place for such tables.
           Small list of tables below has per port group management and need
           shadow per port group. */
        switch (hwTable)
        {
            case CPSS_DXCH_TABLE_PCL_CONFIG_E:
            case CPSS_DXCH_TABLE_POLICER_E:
            case CPSS_DXCH_TABLE_POLICER_COUNTERS_E:
            case CPSS_DXCH2_TABLE_EGRESS_PCL_CONFIG_E:
            case CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E:
            case CPSS_DXCH3_TABLE_MAC2ME_E:
            case CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_LOOKUP1_CONFIG_E:
            case CPSS_DXCH_XCAT_TABLE_INGRESS_PCL_UDB_CONFIG_E:
            case CPSS_DXCH_XCAT2_TABLE_INGRESS_PCL_LOOKUP01_CONFIG_E:
            case CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_PER_PRIO_TOKEN_BUCKET_CONFIG_E:
            case CPSS_DXCH_LION_TABLE_TXQ_SHAPER_PER_PORT_TOKEN_BUCKET_CONFIG_E:
            case CPSS_DXCH_LION_TABLE_TXQ_EGRESS_STC_E:
            case CPSS_DXCH_SIP5_TABLE_EQ_TO_CPU_RATE_LIMITER_CONFIG_E:
            case CPSS_DXCH_SIP5_TABLE_HA_EPCL_UDB_CONFIG_E:
            case CPSS_DXCH_SIP5_TABLE_HA_GENERIC_TS_PROFILE_E:
            case CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_METERING_E:
            case CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_METERING_E:
            case CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_METERING_E:
            case CPSS_DXCH_SIP5_TABLE_INGRESS_OAM_E:
            case CPSS_DXCH_SIP5_TABLE_EGRESS_OAM_E:
            case CPSS_DXCH_SIP5_TABLE_TTI_UDB_CONFIG_E:
            case CPSS_DXCH_SIP5_TABLE_IPCL0_UDB_SELECT_E:
            case CPSS_DXCH_SIP5_TABLE_IPCL1_UDB_SELECT_E:
            case CPSS_DXCH_SIP5_TABLE_IPCL2_UDB_SELECT_E:
            case CPSS_DXCH_SIP5_TABLE_TCAM_PCL_TTI_ACTION_E:
            case CPSS_DXCH_SIP5_TABLE_TCAM_E:
            case CPSS_DXCH_SIP5_TABLE_EPCL_UDB_SELECT_E:
            case CPSS_DXCH_SIP5_TABLE_TAIL_DROP_MAX_QUEUE_LIMITS_E:
            case CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP0_E:
            case CPSS_DXCH_SIP5_TABLE_TAIL_DROP_DQ_QUEUE_BUF_LIMITS_E:
            case CPSS_DXCH_SIP5_TABLE_TAIL_DROP_DQ_QUEUE_DESC_LIMITS_E:
            case CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP1_E:
            case CPSS_DXCH_SIP5_TABLE_TAIL_DROP_EQ_QUEUE_LIMITS_DP2_E:
            case CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_COUNTING_E:
            case CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_COUNTING_E:
            case CPSS_DXCH_SIP5_TABLE_EGRESS_POLICER_COUNTING_E:
            case CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_0_METERING_CONFIG_E:
            case CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_1_METERING_CONFIG_E:
            case CPSS_DXCH_SIP5_15_TABLE_EGRESS_POLICER_METERING_CONFIG_E:
            case CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_0_METERING_CONFORM_SIGN_E:
            case CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_1_METERING_CONFORM_SIGN_E:
            case CPSS_DXCH_SIP5_15_TABLE_EGRESS_POLICER_METERING_CONFORM_SIGN_E:
            case CPSS_DXCH_SIP5_20_MULTI_INSTANCE_TABLE_EQ_INGRESS_STC_PHYSICAL_PORT_PIPE_1_E:
            case CPSS_DXCH_SIP6_TABLE_EGRESS_PCL_EXACT_MATCH_PROFILE_ID_MAPPING_E:
            case CPSS_DXCH_SIP6_TABLE_EXACT_MATCH_E:
            case CPSS_DXCH_SIP6_10_TABLE_EXACT_MATCH_AUTO_LEARNED_ENTRY_INDEX_E:
                /* tables with configuration per port group */
                break;

            default:
                /* all other tables have same data for all instances */
                if(myPortGroupPositionPtr)
                {
                    *myPortGroupPositionPtr = 0;
                }
                return 1;
        }
    }

    /* get BMP of port groups that needs 'different' shadows */
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_TABLE_MAC(devNum,portGroupsBmp,hwTable);

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    {

        if ((firstPortGroupId>portGroupId) && (portGroupsBmp & (1 <<portGroupId)))
        {
            firstPortGroupId = portGroupId;
        }
        numOfRelevantPortGroups++;
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId);

    if(myPortGroupPositionPtr)
    {
        *myPortGroupPositionPtr = firstPortGroupId;
    }

    return numOfRelevantPortGroups;
}

/**
* @internal prvCpssDxChDiagDataIntegrityTableHwToLogicalGet function
* @endinternal
*
* @brief   Function returns logical tables for specific hw table.
*         Function can be called multiple times (with different startPtr)
*         to get all of logical table. The function returns GT_NOT_FOUND if given
*         hw tables was not found in logical tables DB or there are no logical
*         tables any more.
* @param[in] devNum                   - device number
* @param[in] hwTable                  - the hw table name
* @param[in,out] startPtr             - (pointer to) a marker where from to start search.
*                                      0 on NULL means "search from beginning".
*                                      An out-value is used as input for next call
*                                      to continue the search.
*
* @param[out] logicalTablePtr          - (pointer to) the logical table name
*
* @retval GT_OK                    - logical table is found
* @retval GT_NOT_FOUND             - logical table is not found
*
* @note an example how to get all logical tables:
*       i = 0;
*       while (prvCpssDxChDiagDataIntegrityTableHwToLogicalGet(hwTable, &i, &ltable) == GT_OK)
*       (
*       printf("logical table : %s", ltable);
*       )
*
*/
GT_STATUS prvCpssDxChDiagDataIntegrityTableHwToLogicalGet
(
    IN    GT_U8                          devNum,
    IN    CPSS_DXCH_TABLE_ENT            hwTable,
    INOUT GT_U32                         *startPtr,
    OUT   CPSS_DXCH_LOGICAL_TABLE_ENT    *logicalTablePtr
)
{
    GT_U32                                 ii, jj;
    const CPSS_DXCH_TABLE_ENT             *hwNameArr;
    const PRV_CPSS_DXCH_LOGICAL_ENTRY_STC *alterDb;
    GT_U32                                 alterIx;
    const PRV_CPSS_DXCH_LOGICAL_ENTRY_STC *logicalToHwTablesDBPtr;

    logicalToHwTablesDBPtr = (PRV_CPSS_SIP_5_CHECK_MAC(devNum)) ? cpssLogicalToHwTablesDB : cpssLogicalToHwTablesDBAc5;
    alterDb =
        (PRV_CPSS_SIP_6_CHECK_MAC(devNum))    ?cpssLogicalToHwTableDbSip6 :
        (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum)) ? cpssLogicalToHwTableDbSip5_20 :
        (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum)) ? cpssLogicalToHwTableDbSip5_15 :
        NULL;

    /* *startPtr is (ii<<16) | (alterIx & 0xffff) */
    for(ii = (startPtr ? (*startPtr >> 16) : 0), alterIx = (startPtr ? (*startPtr & 0xffff) : 0);
        logicalToHwTablesDBPtr[ii].logicalName != CPSS_DXCH_LOGICAL_TABLE_LAST_E;
        ii++)
    {
        /* substitute entry from alternative DB if necessary */
        if (alterDb &&
            alterDb[alterIx].logicalName == logicalToHwTablesDBPtr[ii].logicalName)
        {
            /* we assume that items in alternative DB goes in the same order as in
             * main DB */
            hwNameArr = alterDb[alterIx].hwNameArr;
            alterIx ++;
        }
        else
        {
            hwNameArr = logicalToHwTablesDBPtr[ii].hwNameArr;
        }

        for(jj = 0; hwNameArr[jj] != LAST_VALID_TABLE_CNS; jj++)
        {
            if(hwNameArr[jj] == hwTable)
            {
                *logicalTablePtr = logicalToHwTablesDBPtr[ii].logicalName;
                ii++;           /* store next index as start index for next call */
                if (ii >= BIT_16 || alterIx >= BIT_16)
                {
                    /* size of  *startPtr is not enough. Need to extend */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
                if (startPtr)
                {
                    *startPtr = (ii << 16) | (alterIx & 0xffff);
                }
                return GT_OK;
            }
        }
    }

    /* the HW table was not found as bound to a logical table */
    *logicalTablePtr = CPSS_DXCH_LOGICAL_TABLE_LAST_E; /* prevent wrong value usage */
    if (startPtr)
    {
        *startPtr = 0;
    }
    return /* it's OK to get this point */ GT_NOT_FOUND;
}

/**
* @internal prvCpssDxChDiagDataIntegrityTableLogicalToHwListGet function
* @endinternal
*
* @brief   Function returns the list of HW tables that relate to the logical table
*
* @param[in] devNum                   - PP device number
* @param[in] logicalTable             - the logical table
*
* @param[out] hwTablesListPtr          - (pointer to) the list of the HW tables
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - if table not supported
*/
GT_STATUS prvCpssDxChDiagDataIntegrityTableLogicalToHwListGet
(
    IN  GT_U8                               devNum,
    IN  CPSS_DXCH_LOGICAL_TABLE_ENT         logicalTable,
    OUT const CPSS_DXCH_TABLE_ENT           **hwTablesListPtr
)
{
    GT_U32  ii;
    const PRV_CPSS_DXCH_LOGICAL_ENTRY_STC *logicalToHwDb;

    logicalToHwDb = (PRV_CPSS_SIP_5_CHECK_MAC(devNum)) ? cpssLogicalToHwTablesDB : cpssLogicalToHwTablesDBAc5;

    if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        switch (logicalTable)
        {
            case CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_METERING_E:
            case CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_METERING_E:
            case CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_COUNTING_E:
            case CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_COUNTING_E:
            case CPSS_DXCH_LOGICAL_TABLE_LPM_MEM_E:
                logicalToHwDb = cpssLogicalToHwTableDbSip6;
                break;
            default:
                break;
        }
    }
    else if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        switch (logicalTable)
        {
            case CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_METERING_E:
            case CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_METERING_E:
            case CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_COUNTING_E:
            case CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_COUNTING_E:
                logicalToHwDb = cpssLogicalToHwTableDbSip5_20;
                break;
            default:
                break;
        }
    }
    else if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
    {
        switch (logicalTable)
        {
            case CPSS_DXCH_LOGICAL_TABLE_INGRESS_POLICER_1_METERING_E:
                logicalToHwDb = cpssLogicalToHwTableDbSip5_15;
                break;
            default:
                break;
        }
    }

    for(ii = 0 ; logicalToHwDb[ii].logicalName != CPSS_DXCH_LOGICAL_TABLE_LAST_E ; ii++)
    {
        if(logicalToHwDb[ii].logicalName == logicalTable)
        {
            *hwTablesListPtr =  &logicalToHwDb[ii].hwNameArr[0];
            return GT_OK;
        }
    }

    *hwTablesListPtr =  &logicalToHwDb[0].hwNameArr[0];

    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "the logical table not found in the DB");
}


/**
* @internal prvCpssDxChDiagDataIntegrityTableHwMaxIndexGet function
* @endinternal
*
* @brief   Function returns the number of entries,lines that HW table hold
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - PP device number
* @param[in] hwTable                  - the IPLR table
*
* @param[out] maxNumEntriesPtr         - (pointer to) the number of entries supported by the table
* @param[out] maxNumLinesPtr           - (pointer to) the number of lines   supported by the table
*
* @retval GT_OK                    - on success
* @retval GT_BAD_PARAM             - if table not covered by this function
*/
GT_STATUS prvCpssDxChDiagDataIntegrityTableHwMaxIndexGet
(
    IN  GT_U8                               devNum,
    IN  CPSS_DXCH_TABLE_ENT                 hwTable,
    OUT GT_U32                              *maxNumEntriesPtr,
    OUT GT_U32                              *maxNumLinesPtr
)
{
    GT_STATUS rc;
    GT_U32    maxNumLines;
    GT_U32    maxNumEntries;
    GT_U32    ratio;
    GT_BOOL   isMultiple;

    /* default value */
    maxNumLines = PRV_TABLE_INFO_PTR_GET_MAC(devNum,hwTable)->maxNumOfEntries;

    switch(hwTable)
    {
        case CPSS_DXCH_TABLE_FDB_E:
            maxNumLines = PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.fdb;
            break;

        case CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E:
            if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                /* SIP_6 devices use shared memory for TS/ARP and fine tuning holds actual number TS entires.
                   Fine Tuning use short TS entries. HW line hold two such entries */
                maxNumLines = PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.tunnelStart / 2;
            }
            break;

        case CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_0_METERING_CONFIG_E:
        case CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_METERING_E:
            if (PRV_CPSS_DXCH_BOBCAT2_CHECK_MAC(devNum) || PRV_CPSS_DXCH_AC5_CHECK_MAC(devNum))
            {
                /* not relevant for sip5.15. PLR_METERING_SHARED_USE_PLR0_AND_BASE_ADDR_LABEL */
                maxNumLines = IPLR0_SIZE_MAC(devNum);
            }
            break;

        case CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_1_METERING_CONFIG_E:
        case CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_METERING_E:
            if (PRV_CPSS_DXCH_BOBCAT2_CHECK_MAC(devNum) || PRV_CPSS_DXCH_AC5_CHECK_MAC(devNum))
            {
                /* not relevant for sip5.15. PLR_METERING_SHARED_USE_PLR0_AND_BASE_ADDR_LABEL */
                maxNumLines = IPLR1_SIZE_MAC(devNum);
            }
            break;

        case CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_0_COUNTING_E:
            if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                /* PLR_COUNTING_SHARED_USE_PLR0_AND_BASE_ADDR_LABEL */
                break;
            }
            /* else do next case */
            GT_ATTR_FALLTHROUGH;
        case CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_0_METERING_CONFORM_SIGN_E:
            maxNumLines = IPLR0_SIZE_MAC(devNum);
            break;

        case CPSS_DXCH_SIP5_TABLE_INGRESS_POLICER_1_COUNTING_E:
            if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
            {
                maxNumLines = IPLR1_COUNTING_SIZE_MAC(devNum);
            }
            else
            {
                maxNumLines = IPLR1_SIZE_MAC(devNum);
            }
            break;
        case CPSS_DXCH_SIP5_15_TABLE_INGRESS_POLICER_1_METERING_CONFORM_SIGN_E:
            maxNumLines = IPLR1_SIZE_MAC(devNum);
            break;

        case CPSS_DXCH_SIP6_TABLE_EXACT_MATCH_E:
            maxNumLines = PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.emNum;
            break;

        default:
            break;
    }
    rc = prvCpssDxChTableEngineToHwRatioGet(devNum,hwTable,&ratio,&isMultiple);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(ratio == 0)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    maxNumEntries = maxNumLines;

    if(ratio != 1)
    {
        if(isMultiple == GT_TRUE)
        {
            /* ratio is 'multiple' (number of entries in single line) */
            maxNumEntries *= ratio;
        }
        else
        {
            /* ratio is 'fraction' (number of lines  in single entry) */
            maxNumEntries /= ratio;
        }
    }

    if(maxNumEntriesPtr)
    {
        *maxNumEntriesPtr = maxNumEntries;
    }
    if(maxNumLinesPtr)
    {
        *maxNumLinesPtr   = maxNumLines;
    }

    return GT_OK;
}

/**
* @internal checkIsDevSupportHwTable function
* @endinternal
*
* @brief   Function checks if the device supports the HW table
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - PP device number
* @param[in] hwTableType              - the HW table
*
* @retval GT_TRUE                  - the device   supports the table
* @retval GT_FALSE                 - the device NOT supports the table
*/
static GT_BOOL  checkIsDevSupportHwTable(
    IN GT_U8                devNum ,
    IN CPSS_DXCH_TABLE_ENT  hwTableType
)
{
    GT_U32  numEntries; /* number of entries in a table */
    GT_STATUS rc;       /* return code                  */

    rc = prvCpssDxChTableNumEntriesGet(devNum, hwTableType, &numEntries);
    if(rc != GT_OK || numEntries == 0)
    {
        /* the HW table is not valid for this device */
        return GT_FALSE;
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* the HW table is implemented as registers, counters or for debug*/
        if(
            (hwTableType >=CPSS_DXCH_SIP6_TXQ_PDS_PER_QUEUE_COUNTERS_E &&
            hwTableType <= CPSS_DXCH_SIP6_TXQ_PDS_PER_QUEUE_COUNTERS_LAST_E) ||
            (hwTableType >= (CPSS_DXCH_SIP6_TXQ_SDQ_QUEUE_CFG_E + 0) &&
            hwTableType <= (CPSS_DXCH_SIP6_TXQ_SDQ_SEL_LIST_PTRS_E + 31)) ||
            (hwTableType >= CPSS_DXCH_SIP6_TXQ_PFCC_PFCC_CFG_E &&
             hwTableType <= CPSS_DXCH_SIP6_TXQ_PFCC_PFCC_CFG_LAST_E)
           )
        {
            /* the HW table is not valid for this device */
            return GT_FALSE;
        }
    }

    return GT_TRUE;
}

/**
* @internal prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTable function
* @endinternal
*
* @brief   Function checks if the device supports the HW table
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - PP device number
*                                      hwTable     - the HW table
* @param[in] entryIndex               - entry index
*
* @retval GT_TRUE                  - the device   supports the table
* @retval GT_FALSE                 - the device NOT supports the table or entry
*/
GT_BOOL  prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTable(
    IN GT_U8                devNum ,
    IN CPSS_DXCH_TABLE_ENT  hwTableType,
    IN GT_U32               entryIndex
)
{
    GT_STATUS   rc;
    GT_U32  maxLines;
    GT_U32  maxEntries;
    GT_U32  numOfLinesInBlock;
    GT_U32  totalNumOfLinesInBlockIncludingGap;
    GT_U32  exactMatchNumOfBanks;
    GT_U32  maxNumOfEntries;
    GT_U32  blockNum;

    if(GT_FALSE == checkIsDevSupportHwTable(devNum,hwTableType))
    {
        /* the HW table is not valid for this device */
        return GT_FALSE;
    }

    /* get number of entries in the table */
    rc = prvCpssDxChDiagDataIntegrityTableHwMaxIndexGet(devNum,hwTableType,&maxEntries,&maxLines);
    if(rc != GT_OK)
    {
        return GT_FALSE;
    }

    if(entryIndex >= maxEntries)
    {
        /* index is above valid range of this table ... ignore it !!! */
        return GT_FALSE;
    }

    switch (hwTableType)
    {
        case CPSS_DXCH_SIP5_TABLE_LPM_MEM_E:
        case CPSS_DXCH_SIP5_20_TABLE_LPM_MEM_PIPE_1_E:
            if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                PRV_CPSS_DXCH_MODULE_CONFIG_STC *moduleCfgPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg);
                PRV_CPSS_DXCH_TABLES_INFO_STC          *pbrTableInfoPtr;      /* pointer to PBR table info */

                /* virtual PBR table is in range of LPM, it may be in beginning or in end of LPM table.
                   Need to find it. */
                pbrTableInfoPtr = PRV_TABLE_INFO_PTR_GET_MAC(devNum,CPSS_DXCH_SIP6_TABLE_PBR_E);
                totalNumOfLinesInBlockIncludingGap = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.totalNumOfLinesInBlockIncludingGap;

                if (pbrTableInfoPtr->maxNumOfEntries)
                {
                    if ((entryIndex >= PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.indexForPbr) &&
                        (entryIndex < (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.indexForPbr + pbrTableInfoPtr->maxNumOfEntries)))
                    {
                        /* it's PBR range */
                        return GT_FALSE;
                    }
                }

                blockNum = entryIndex / totalNumOfLinesInBlockIncludingGap;

                if (blockNum < moduleCfgPtr->ip.lpmSharedMemoryBankNumber)
                {
                    if((entryIndex % totalNumOfLinesInBlockIncludingGap) >= moduleCfgPtr->ip.lpmBankSize)
                    {
                        /* the index is falling into 'gap' between memories ...
                           must not access to it */
                        return GT_FALSE;
                    }
                }
                else
                {
                    if((entryIndex % totalNumOfLinesInBlockIncludingGap) >=
                        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.sip6_numLinesPerBlockNonShared)
                    {
                        /* the index is falling into 'gap' between memories ...
                           must not access to it */
                        return GT_FALSE;
                    }
                }
            }
            else
            {
                numOfLinesInBlock = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.numOfLinesInBlock;
                totalNumOfLinesInBlockIncludingGap = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.totalNumOfLinesInBlockIncludingGap;

                if((entryIndex % totalNumOfLinesInBlockIncludingGap) >= numOfLinesInBlock)
                {
                    /* the index is falling into 'gap' between memories ...
                       must not access to it */
                    return GT_FALSE;
                }
            }
            break;

        case CPSS_DXCH_SIP5_TABLE_TCAM_E:
            /* check TCAM bank - bits 1:4 . Banks 12:15 are not valid. */
            if (((entryIndex >> 1) & 0xF) >= 12)
            {
                /* the index is falling into 'gap' between memories ...
                   must not access to it */
                return GT_FALSE;
            }
            break;

        case CPSS_DXCH_TABLE_VLAN_PORT_PROTOCOL_E:
        case CPSS_DXCH_SIP5_TABLE_TCAM_PCL_TTI_ACTION_E:
            if((entryIndex % 16) >= 12)
            {
                /* the HW holds no memory for those indexes */
                return GT_FALSE;
            }
            break;

        case  CPSS_DXCH_SIP5_TABLE_ERMRK_PTP_LOCAL_ACTION_E:
            /* in sip5 entries appropriate to PTP domains 5..7 are not valid
             * (whereas the place in HW table exists for them).
             * in sip5.20 this entries are not valid and there are no
             * place for them in HW table. Writing to this entries
             * will corrupt other entries. */
            if (entryIndex % 8 > 4)
            {
                return GT_FALSE;
            }
            break;

        case CPSS_DXCH_SIP6_TABLE_EXACT_MATCH_E:
            if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                PRV_CPSS_DXCH_EXACT_MATCH_NUM_OF_BANKS_GET_MAC(devNum,exactMatchNumOfBanks);
                switch(exactMatchNumOfBanks)
                {
                    case 4:/* Four Multiple Hash Tables */
                        /* 4 banks are used : bank=0..3
                            number of entries is banks * _8K */
                        maxNumOfEntries = _32K;
                        break;
                    case 8:/* Eight Multiple Hash Tables */
                        /* 8 banks are used: bank=0..7
                            number of entries is banks * _8K */
                        maxNumOfEntries = _64K;
                        break;
                    case 16:/* Sixteen Multiple Hash Tables  */
                        /* 16 banks are used: bank=0..15
                             number of entries is banks * _8K */
                        maxNumOfEntries = _128K;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_VALUE, LOG_ERROR_NO_MSG);
                }
                /* for indirect accsess the index For all MHT modes: 4/8/16 bank design, entry bits are as follows:
                 * [3:0] - Bank number
                 * [19:4] - Address inside bank
                 * No need conversion for MHT16 - all 4 bits are used for bank ID
                 * MHT 8 uses 3 bits for bank ID and MHT 4 uses 2 bits for bank ID and hence needs
                 * conversion of entry indexes to specified position in tables this ignoring the
                 * not required hash location.
                 */
                if (entryIndex >= maxNumOfEntries)
                {
                    return GT_FALSE;
                }
            }
            break;

        case CPSS_DXCH_SIP6_TABLE_PBR_E:
            {
                PRV_CPSS_DXCH_MODULE_CONFIG_STC *moduleCfgPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg);
                GT_U32                                  line;              /* LPM line number */

                totalNumOfLinesInBlockIncludingGap = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.totalNumOfLinesInBlockIncludingGap;

                /* each line holds 5 PBR entries */
                line = (entryIndex / PRV_CPSS_DXCH_CFG_SIP6_NUM_PBR_ENTRIES_IN_LPM_LINE_CNS) +
                       PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.indexForPbr;

                /* virtual PBR table is in range of LPM, it may be in beginning or in end of LPM table. */
                blockNum = line / totalNumOfLinesInBlockIncludingGap;

                if (blockNum < moduleCfgPtr->ip.lpmSharedMemoryBankNumber)
                {
                    if((line % totalNumOfLinesInBlockIncludingGap) >= moduleCfgPtr->ip.lpmBankSize)
                    {
                        /* the index is falling into 'gap' between memories ...
                           must not access to it */
                        return GT_FALSE;
                    }
                }
                else
                {
                    if((line % totalNumOfLinesInBlockIncludingGap) >=
                        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lpm.sip6_numLinesPerBlockNonShared)
                    {
                        /* the index is falling into 'gap' between memories ...
                           must not access to it */
                        return GT_FALSE;
                    }
                }
            }
            break;

        default:
            break;
    }

    return GT_TRUE;
}

/**
* @internal prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTableShadow function
* @endinternal
*
* @brief   Function returns the 'shadow type' that the CPSS may hold for the HW table
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - PP device number
*                                      hwTable     - the HW table
*                                       the 'shadow type'
*/
CPSS_DXCH_SHADOW_TYPE_ENT  prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTableShadow(
    IN GT_U8                devNum ,
    IN CPSS_DXCH_TABLE_ENT  hwTableType
)
{
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *tableInfoPtr;

    if(GT_FALSE == checkIsDevSupportHwTable(devNum,hwTableType))
    {
        /* the HW table is not valid for this device */
        return CPSS_DXCH_SHADOW_TYPE_NONE_E;
    }

    tableInfoPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[hwTableType]);

    return tableInfoPtr->shadowType;
}


/**
* @internal prvCpssPortGroupReadTableEntries function
* @endinternal
*
* @brief   function reads set of port group table entries
*
* @param[in] devNum                   - device number,
* @param[in] portGroupsBmp            - port group Bmp,
* @param[in] hwTable                  - hw table name,
* @param[in] entryIndex               - start entry index,
* @param[in] numOfEntries             - number of entries to read (0xFFFFFFFF means till end of table)
* @param[in] global_maxTableSize      - number of entries on which the 'wrap around' happen
*                                      value ignored if '0'
*
* @param[out] nextEntryIndexPtr        - next entry index pointer
* @param[out] wasWrapAroundPtr         - (pointer to) was wrap around indication
*                                      GT_TRUE - if 'wrap around' happen,
*                                      otherwise - not modified!
*                                      NOTE:
*                                      Ignored if NULL
*
* @retval GT_OK                    - no errors
* @retval GT_BAD_PARAM             - bad param given
*/
static GT_STATUS prvCpssPortGroupReadTableEntries
(
    IN  GT_U8                    devNum,
    IN  GT_PORT_GROUPS_BMP       portGroupsBmp,
    IN  CPSS_DXCH_TABLE_ENT      hwTable,
    IN  GT_U32                   entryIndex,
    IN  GT_U32                   numOfEntries,
    OUT GT_U32                  *nextEntryIndexPtr,
    OUT GT_BOOL                 *wasWrapAroundPtr,
    IN GT_U32                    global_maxTableSize
)
{
    GT_STATUS  rc = GT_FAIL;
    GT_U32     portGroupId; /* port group id */
    GT_U32     valueArr[PRV_CPSS_DXCH_TABLE_MAX_ENTRY_SIZE_CNS];
    GT_U32     maxTableSize;
    GT_U32     origEntryIndex;

    /**********************/
    /* table validity was done by calling to prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTable(...) */
    /**********************/
    /* get number of entries in the table */
    rc = prvCpssDxChDiagDataIntegrityTableHwMaxIndexGet(devNum,hwTable,&maxTableSize,NULL);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(global_maxTableSize == 0)
    {
        global_maxTableSize = maxTableSize;
    }

    if(entryIndex >= global_maxTableSize)
    {
        /*CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);*/
        return GT_OK;
    }

    if(numOfEntries == 0xFFFFFFFF)
    {
        numOfEntries = global_maxTableSize - entryIndex;
    }

    if(numOfEntries > global_maxTableSize)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* get BMP of port groups that needs 'different' shadows */
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_TABLE_MAC(devNum,portGroupsBmp,hwTable);

    origEntryIndex = entryIndex;

    for(entryIndex = origEntryIndex ;
        entryIndex < (origEntryIndex + numOfEntries);
        entryIndex++)
    {
        if((entryIndex % global_maxTableSize) >= maxTableSize)
        {
            /* the index is not applicable for this table !!! */
            /*
                Supporting 2 HW tables not in the same 'size' : one is 4K entries and the other is 8K entries.
                For example:
                    { CPSS_DXCH_LOGICAL_TABLE_VLAN_TRANSLATION_E, {
                        CPSS_DXCH3_TABLE_INGRESS_VLAN_TRANSLATION_E, --> 4K entries
                        CPSS_DXCH3_TABLE_EGRESS_VLAN_TRANSLATION_E,  --> 8K entries
                        LAST_VALID_TABLE_CNS }  },

                The function should 'ignore' entries 4K...(8K-1) on 'ingress table' and apply only on 'egress table'
            */
            continue;
        }

        if((hwTable == CPSS_DXCH_SIP5_TABLE_LPM_MEM_E) ||
           (hwTable == CPSS_DXCH_SIP5_TABLE_TCAM_E)    ||
           (hwTable == CPSS_DXCH_SIP5_20_TABLE_LPM_MEM_PIPE_1_E) ||
           (hwTable == CPSS_DXCH_SIP6_TABLE_EXACT_MATCH_E))
        {
            if(GT_FALSE ==
                prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTable(devNum,hwTable,entryIndex))
            {
                /* support the gaps */
                continue;
            }
        }

        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)
        {
            rc = prvCpssDxChPortGroupReadTableEntry(devNum, portGroupId, hwTable,
                                                    entryIndex % maxTableSize,
                                                    valueArr/*not relevant*/);
            if (rc != GT_OK)
            {
                return rc;
            }
        } /* end: port groups iteration */
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)

    } /* end: entries iteration */

    if(entryIndex > global_maxTableSize && wasWrapAroundPtr)
    {
        *wasWrapAroundPtr = GT_TRUE;
    }

    *nextEntryIndexPtr = entryIndex % global_maxTableSize;

    return GT_OK;
}

/**
* @internal internal_cpssDxChDiagDataIntegrityTableScan function
* @endinternal
*
* @brief   Data integrity SW daemon API
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] locationPtr              - (pointer to) location information,
*                                      ram location is not supported
* @param[in] numOfEntries             - number of entries to read (0xFFFFFFFF means till end of table)
*                                      NOTE: for 'logical table' this value is ignored and taken from :
* @param[in] locationPtr
*
* @param[out] nextEntryIndexPtr        - (pointer to) next index
* @param[out] wasWrapAroundPtr         - (pointer to) was wrap around indication
*                                      NOTE: ignored if NULL
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChDiagDataIntegrityTableScan
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_LOCATION_SPECIFIC_INFO_STC *locationPtr,
    IN  GT_U32                                numOfEntries,
    OUT GT_U32                               *nextEntryIndexPtr,
    OUT GT_BOOL                              *wasWrapAroundPtr
)
{
    GT_STATUS                    rc = GT_FAIL;
    GT_U32                       i;
    GT_U32                       j;
    GT_U32                       global_maxTableSize;
    GT_U32                       firstEntryIndex;
    CPSS_DXCH_TABLE_ENT          hwTableType;
    const CPSS_DXCH_TABLE_ENT   *hwNameArr;
    GT_BOOL                      wasWrapAround;
    GT_U32                       nextEntryIndex;
    CPSS_DXCH_LOGICAL_TABLE_ENT  logicalTable;
    GT_U32                       hwLogicalUp; /* upper logical index+1 relevant to HW table */
    GT_U32                       hwMaxLogicalUp; /* upper logical index +1 relevant to HW tables */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(locationPtr);
    CPSS_NULL_PTR_CHECK_MAC(nextEntryIndexPtr);

    /* must be initialized here ...
       the code along the way only make it 'GT_TRUE' */
    wasWrapAround = GT_FALSE;

    switch(locationPtr->type)
    {
        case CPSS_DXCH_LOCATION_HW_INDEX_INFO_TYPE:
            hwTableType = locationPtr->info.hwEntryInfo.hwTableType;
            if(GT_FALSE ==
                checkIsDevSupportHwTable(devNum,hwTableType))
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "HW table is not applicable");
            }

            global_maxTableSize = 0;/* value ignored when 0 */

            rc = prvCpssPortGroupReadTableEntries(devNum,
                                                  locationPtr->portGroupsBmp,
                                                  locationPtr->info.hwEntryInfo.hwTableType,
                                                  locationPtr->info.hwEntryInfo.hwTableEntryIndex,
                                                  numOfEntries,
                                                  &nextEntryIndex,
                                                  &wasWrapAround,
                                                  global_maxTableSize);
            if (rc != GT_OK)
            {
                return rc;
            }
        break;

        case CPSS_DXCH_LOCATION_LOGICAL_INDEX_INFO_TYPE:
            nextEntryIndex = 0;
            for(i = 0; i < locationPtr->info.logicalEntryInfo.numOfLogicalTables; i++)
            { /* logical tables iteration */
                logicalTable = locationPtr->info.logicalEntryInfo.logicaTableInfo[i].logicalTableType;

                if((GT_U32)logicalTable >= CPSS_DXCH_LOGICAL_TABLE_LAST_E)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /*
                    NOTE: 'numOfEntries' is taken 'per logical table' !!!!
                            and not 'globally' from the API
                */
                numOfEntries = locationPtr->info.logicalEntryInfo.logicaTableInfo[i].numEntries;
                firstEntryIndex = locationPtr->info.logicalEntryInfo.logicaTableInfo[i].logicalTableEntryIndex;

                rc = prvCpssDxChDiagDataIntegrityTableLogicalToHwListGet(
                    devNum, logicalTable, &hwNameArr);
                if(rc != GT_OK)
                {
                    return rc;
                }
                hwMaxLogicalUp = 0;
                wasWrapAround = GT_FALSE;
                nextEntryIndex = firstEntryIndex;
                while (numOfEntries)
                {
                    for(j = 0; hwNameArr[j] != LAST_VALID_TABLE_CNS; j++)
                    { /* hw tables iteration */
                        GT_U32 hwFirstEntryIndex;
                        GT_U32 hwNumOfEntries;
                        GT_U32 hwNextEntryIndex;
                        GT_BOOL hwWasWrapAround = GT_FALSE;

                        hwTableType = hwNameArr[j];
                        if(GT_FALSE ==
                           checkIsDevSupportHwTable(devNum,hwTableType))
                        {
                            /* the device doesn't support this HW table */
                            continue;
                        }

                        /* convert logical entries range to HW range */
                        rc = prvCpssDxChDiagDataIntegrityLogicalToHwTableMap(
                            devNum, logicalTable, firstEntryIndex, numOfEntries,
                            hwTableType, &hwFirstEntryIndex, &hwNumOfEntries,
                            NULL, &hwLogicalUp);
                        if (rc != GT_OK)
                        {
                            return rc;
                        }
                        if (hwLogicalUp > hwMaxLogicalUp)
                        {
                            hwMaxLogicalUp = hwLogicalUp;
                        }

                        if (hwNumOfEntries)
                        {
                            rc = prvCpssPortGroupReadTableEntries(devNum,
                                                                  locationPtr->portGroupsBmp,
                                                                  hwTableType,
                                                                  hwFirstEntryIndex,
                                                                  hwNumOfEntries,
                                                                  &hwNextEntryIndex,
                                                                  &hwWasWrapAround,
                                                                  0  /* ignored */);
                            if (rc != GT_OK)
                            {
                                return rc;
                            }
                            /* additional checking. Shouldn't happen */
                            if (hwWasWrapAround != GT_FALSE)
                            {
                                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                            }
                        }
                    } /* end: hw tables iteration */
                    if (0 == hwMaxLogicalUp)
                    {
                        /* Strange. Shouldn't happen */
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                    }
                    if (firstEntryIndex + numOfEntries > hwMaxLogicalUp)
                    {
                        wasWrapAround = GT_TRUE;
                        numOfEntries -=  (hwMaxLogicalUp - firstEntryIndex);
                        firstEntryIndex = 0;
                    }
                    else
                    {
                        nextEntryIndex = firstEntryIndex + numOfEntries;
                        numOfEntries = 0;

                    }
                }
            } /* end: logical tables iteration */
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    } /* end of switch */

    if (wasWrapAroundPtr)
    {
        *wasWrapAroundPtr = wasWrapAround;
    }
    *nextEntryIndexPtr = nextEntryIndex;
    return rc;
}

/**
* @internal cpssDxChDiagDataIntegrityTableScan function
* @endinternal
*
* @brief   Data integrity SW daemon API
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] locationPtr              - (pointer to) location information,
*                                      ram location is not supported
* @param[in] numOfEntries             - number of entries to read (0xFFFFFFFF means till end of table)
*                                      NOTE: for 'logical table' this value is ignored and taken from :
* @param[in] locationPtr
*
* @param[out] nextEntryIndexPtr        - (pointer to) next index
* @param[out] wasWrapAroundPtr         - (pointer to) was wrap around indication
*                                      NOTE: ignored if NULL
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChDiagDataIntegrityTableScan
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_LOCATION_SPECIFIC_INFO_STC *locationPtr,
    IN  GT_U32                                numOfEntries,
    OUT GT_U32                               *nextEntryIndexPtr,
    OUT GT_BOOL                              *wasWrapAroundPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChDiagDataIntegrityTableScan);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, locationPtr, numOfEntries, nextEntryIndexPtr, wasWrapAroundPtr));

    rc = internal_cpssDxChDiagDataIntegrityTableScan(devNum, locationPtr, numOfEntries,
                                                    nextEntryIndexPtr, wasWrapAroundPtr);
    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, devNum, locationPtr, numOfEntries, nextEntryIndexPtr, wasWrapAroundPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}

typedef enum{
    PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENTRY_E,
    PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_LINE_E
}PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENT;

/**
* @internal prvCpssDxChPortGroupShadowEntryGet function
* @endinternal
*
* @brief   return address of the specified bit of entry in the CPSS shadow.
*         NOTE: the 'entryIndex' is the same one that used by
*         prvCpssDxChPortGroupWriteTableEntry
*         the 'line index' is the same as the actual HW keeps it's 'lines'
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupId              - the port group Id , to support multi-port-group devices that need to access
*                                      specific port group
* @param[in] tableType                - the 'HW table' type
* @param[in] indexType                - indication that parameter entryIndex_or_lineIndex is considered as
*                                      'entry index' (PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENTRY_E) or
*                                      'line index'  (PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_LINE_E)
* @param[in] entryIndex_or_lineIndex  - the 'entry index' or 'line index'
*                                      startBitIndexPtr - (pointer to) the entry's bit we're looking for.
*                                      Non-zero value can be useful if the entry occupies several lines
*                                      Treated as zero if NULL.
*
* @retval GT_OK                    - on success.
* @retval GT_EMPTY                 - if the table hold no shadow
*
* @note 1. will return pointer to the entry/line in the shadow (no 'copy' is done)
*       2. caller must check that the 'table' holds shadow (otherwise will get 'pointer to NULL').
*       3. Please note you can't rely that all entry's bits are placed continuously
*       when you use indexType = PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENTRY_E,
*       See using of FRACTION_HALF_TABLE_INDICATION_CNS for details.
*
*/
static GT_STATUS prvCpssDxChPortGroupShadowEntryGet
(
    IN GT_U8                   devNum,
    IN GT_U32                  portGroupId,
    IN CPSS_DXCH_TABLE_ENT     tableType,
    IN PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENT indexType,
    IN GT_U32                  entryIndex_or_lineIndex,
    OUT GT_U32                 **entryInShadowPtrPtr, /* will return pointer to the entry in the shadow (no 'copy' is done)*/
    INOUT GT_U32                *startBitIndexPtr,
    OUT GT_U32                  *numBitsPerEntryPtr,
    OUT GT_U32                  *numEntriesPerLinePtr

)
{
    PRV_CPSS_DXCH_TABLES_INFO_STC      *tableInfoPtr; /* pointer to table info */
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *shadowInfoPtr       = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[tableType]);
    GT_U32                              entrySizeInWords;
    GT_U32                             *entryInShadowPtr;
    GT_U32                              myPortGroupPosition = 0;
    GT_U32                              firstWordInShadow;
    GT_U32                              numOfRelevantPortGroups;
    GT_PORT_GROUPS_BMP                  portGroupsBmp;
    GT_U32                              lineIndex;
    GT_U32                              numEntriesPerLine   = 1;
    GT_U32                              startBit;
    GT_U32                              numBitsPerEntry;

    if(NULL == shadowInfoPtr->hwTableMemPtr)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_EMPTY, "no shadow for the table [%d]",
            tableType);
    }

    startBit = startBitIndexPtr ? *startBitIndexPtr : 0;

    if(indexType == PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENTRY_E)
    {
        tableInfoPtr = PRV_TABLE_INFO_PTR_GET_MAC(devNum,tableType);

        lineIndex = entryIndex_or_lineIndex;
        if(GT_FALSE == prvCpssDxChTableEngineMultiEntriesInLineIndexAndGlobalBitConvert(
               devNum, tableType,
               INOUT &lineIndex, INOUT &startBit ,
               OUT &numBitsPerEntry , OUT &numEntriesPerLine))
        {
            numBitsPerEntry  = tableInfoPtr->entrySize * 32;
        }

        if(numBitsPerEntryPtr)
        {
            *numBitsPerEntryPtr = numBitsPerEntry;
        }
    }
    else  /*PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_LINE_E*/
    {
        lineIndex = entryIndex_or_lineIndex;
    }

    if(lineIndex >= (PRV_TABLE_INFO_PTR_GET_MAC(devNum,tableType)->maxNumOfEntries))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "shadow 'get' try to access index[%d] out of range[%d]",
            lineIndex,
            PRV_TABLE_INFO_PTR_GET_MAC(devNum,tableType)->maxNumOfEntries - 1);
    }

    portGroupsBmp = (portGroupId == CPSS_PORT_GROUP_UNAWARE_MODE_CNS) ?
                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS :
                    (GT_PORT_GROUPS_BMP)(1 << portGroupId);

    numOfRelevantPortGroups = getNumOfRelevantPortGroups(devNum, portGroupsBmp, tableType, &myPortGroupPosition);

    entrySizeInWords = PRV_CPSS_DXCH_PP_MAC(devNum)->accessTableInfoPtr[tableType].entrySize;

    firstWordInShadow = (lineIndex * entrySizeInWords * numOfRelevantPortGroups) +
                        (myPortGroupPosition * entrySizeInWords);

    if(firstWordInShadow >= (shadowInfoPtr->hwTableMemSize/4))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, "shadow 'get' try to access word[%d] out of range[%d]",
            firstWordInShadow,
            (shadowInfoPtr->hwTableMemSize/4) - 1);
    }


    entryInShadowPtr = &shadowInfoPtr->hwTableMemPtr[firstWordInShadow];

    *entryInShadowPtrPtr = entryInShadowPtr;


    if(startBitIndexPtr)
    {
        *startBitIndexPtr = startBit;
    }

    if(numEntriesPerLinePtr)
    {
        *numEntriesPerLinePtr = numEntriesPerLine;
    }


    return  GT_OK;
}

/**
* @internal prvCpssDxChPortGroupShadowEntryWrite function
* @endinternal
*
* @brief   Writes to PP's shadow at specific 'entry index'
*         (same index as in functions of prvCpssDxChPortGroupWriteTableEntry)
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - The PP device number to write to.
* @param[in] portGroupId              - The port group id. relevant only to 'multi-port-groups'
*                                      devices. Supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS
*                                      (APPLICABLE DEVICES Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman)
* @param[in] tableType                - the 'HW table'
* @param[in] entryIndex               - index in the table
*                                      (same index as in functions of prvCpssDxChPortGroupWriteTableEntry)
* @param[in] entryValuePtr            - (pointer to) An array containing the data to be
*                                      copied into the shadow
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on hardware of logical error
* @retval GT_NOT_INITIALIZED       - if the driver was not initialized
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChPortGroupShadowEntryWrite
(
    IN  GT_U8                 devNum,
    IN  GT_U32                portGroupId,
    IN  CPSS_DXCH_TABLE_ENT   tableType,
    IN  GT_U32                entryIndex,
    IN  GT_U32               *entryValuePtr
)
{
    GT_STATUS   rc;
    GT_U32  *shadowPtr;/* pointer to the shadow table line for the index in the table */
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *shadowInfoPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[tableType]);
    GT_U32  startBitIndex; /* the start bit index of entry in the line */
    GT_U32  numBitsPerEntry;/* number of bits per entry */
    GT_U32  numEntriesPerLine;
    GT_U32  ii;

    if(CPSS_DXCH_SHADOW_TYPE_CPSS_E != shadowInfoPtr->shadowType)
    {
        /* the device not supports it or the table not requires shadow */
        return GT_OK;
    }

    /* get pointer to the shadow (to start of the 'line' !!!) */
    startBitIndex = 0;
    rc = prvCpssDxChPortGroupShadowEntryGet(devNum,portGroupId,tableType,
        PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENTRY_E,
        entryIndex,    /* index is of 'entry'  */
        &shadowPtr,    /* pointer is to 'line' */
        &startBitIndex,/* offset of the start of the 'entry' in the 'line' */
        &numBitsPerEntry,/* number of bits for the 'entry' in the 'line(s)' */
        &numEntriesPerLine  /* number of lines the entry occupies */
        );
    if(rc != GT_OK)
    {
        return rc;
    }

    if (numEntriesPerLine & FRACTION_HALF_TABLE_INDICATION_CNS)
    {
        /* the entry occupies two non-continues lines - 1/x entry per line.
           Need to write them separately */
        /* Remove the indication of fraction , so we have 'real' number */
        numEntriesPerLine &= ~ FRACTION_HALF_TABLE_INDICATION_CNS;

        /* copy first part of the entry */
        copyBits(shadowPtr,        /* target */
                 startBitIndex,    /* start bit in the target */
                 entryValuePtr,    /* source */
                 0,                /* start bit in the source */
                 numBitsPerEntry); /* number of bits to copy */

        for(ii = 0 ; ii < (numEntriesPerLine - 1) ; ii++)
        {
            /* get the shadow line storing the next part of the entry */
            startBitIndex = (ii+1) * numBitsPerEntry;

            rc = prvCpssDxChPortGroupShadowEntryGet(
                devNum,portGroupId,tableType,
                PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENTRY_E,
                entryIndex,    /* index is of 'entry'  */
                &shadowPtr,    /* pointer is to 'line' */
                &startBitIndex,/* offset of the start of the 'entry' in the 'line' */
                NULL,  /* not interested. We've got it before */
                NULL); /* not interested. We've got it before */
            if(rc != GT_OK)
            {
                return rc;
            }

            /* NOTE: startBitIndex is changed by prvCpssDxChPortGroupShadowEntryGet and
                     at most times will be reset to 0 !!!
                    and this value is relative to shadowPtr
            */
            /* shadowPtr is the start of this line in the shadow */
            copyBits(shadowPtr,     /* target */
                     startBitIndex, /* start bit in the target */
                     entryValuePtr, /* source */
                     (ii+1) * numBitsPerEntry,  /* start bit in the source */
                     numBitsPerEntry); /* number of bits to copy */
        }
    }
    else
    {
        copyBits(shadowPtr,        /* target */
                 startBitIndex,    /* start bit in the target */
                 entryValuePtr,    /* source */
                 0,                /* start bit in the source */
                 numBitsPerEntry); /* number of bits to copy */
    }

    return  GT_OK;
}

/**
* @internal prvCpssDxChPortGroupShadowLineWrite function
* @endinternal
*
* @brief   Writes to PP's shadow at specific 'line index'
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - The PP device number to write to.
* @param[in] portGroupId              - The port group id. relevant only to 'multi-port-groups'
*                                      devices. Supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS
*                                      (APPLICABLE DEVICES Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman)
* @param[in] tableType                - the 'HW table'
* @param[in] lineIndex                - the line index in the 'HW table'
*                                      (not the same index as the functions of 'table engine' get (like
*                                      prvCpssDxChPortGroupWriteTableEntry))
* @param[in] entryValuePtr            - (pointer to) An array containing the data to be
*                                      copied into the shadow
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on hardware error
* @retval GT_NOT_INITIALIZED       - if the driver was not initialized
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChPortGroupShadowLineWrite
(
    IN  GT_U8                 devNum,
    IN  GT_U32                portGroupId,
    IN  CPSS_DXCH_TABLE_ENT   tableType,
    IN  GT_U32                lineIndex,
    IN  GT_U32               *entryValuePtr
)
{
    return prvCpssDxChPortGroupShadowLineUpdateMasked(devNum, portGroupId,
                                                      tableType, lineIndex,
                                                      entryValuePtr, NULL);
}


/**
* @internal prvCpssDxChDiagDataIntegrityLogicalTablePortGroupsBmpCheck function
* @endinternal
*
* @brief   the function checks if the portGroupsBmp is supported for the logical table
*         utility function called from the mainUT .. for tests.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] logicalTable             - the 'logical table'
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_BAD_PARAM             - on bad param
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChDiagDataIntegrityLogicalTablePortGroupsBmpCheck
(
    IN GT_U8 devNum ,
    IN GT_PORT_GROUPS_BMP    portGroupsBmp,
    IN CPSS_DXCH_LOGICAL_TABLE_ENT logicalTable
)
{
    GT_STATUS   rc;
    GT_U32  jj;
    CPSS_DXCH_TABLE_ENT                     hwTableType;
    const CPSS_DXCH_TABLE_ENT               *hwNameArr;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_LION2_E);

    if((GT_U32)logicalTable >= CPSS_DXCH_LOGICAL_TABLE_LAST_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssDxChDiagDataIntegrityTableLogicalToHwListGet(
        devNum, logicalTable, &hwNameArr);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* if all HW tables are not applicable ... this value will be returned */
    rc = GT_BAD_PARAM;

    for(jj = 0; hwNameArr[jj] != LAST_VALID_TABLE_CNS; jj++)
    { /* hw tables iteration */
        hwTableType = hwNameArr[jj];

        if(GT_FALSE ==
            prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTable(devNum,hwTableType,
            0))
        {
            /* the device not supports this HW table */
            continue;
        }

        rc = GT_OK;/* at least one HW table supported by the device */

        /* check if the table supports the BMP of port groups */
        PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_TABLE_MAC(devNum,portGroupsBmp,hwTableType);
    }

    return rc;
}



/**
* @internal shadowTableEntryFix function
* @endinternal
*
* @brief   Data integrity : fix specific table entry that is corrupted in the HW,
*         using CPSS shadow for this table.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupsBmp            - bitmap of Port Groups.
*                                      NOTEs:
*                                      1. for non multi-port groups device this parameter is IGNORED.
*                                      2. for multi-port groups device :
*                                      (APPLICABLE DEVICES Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman)
*                                      bitmap must be set with at least one bit representing
*                                      valid port group(s). If a bit of non valid port group
*                                      is set then function returns GT_BAD_PARAM.
*                                      value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* @param[in] hwTableType              - the 'HW table' to fix
* @param[in] hwTableEntryIndex        - the 'corrupted' index in the 'HW table'
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_BAD_PARAM             - on bad param
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS shadowTableEntryFix
(
    IN  GT_U8                                   devNum,
    IN  GT_PORT_GROUPS_BMP                      portGroupsBmp,
    IN  CPSS_DXCH_TABLE_ENT                     hwTableType,
    IN  GT_U32                                  hwTableEntryIndex
)
{
    GT_STATUS  rc;                          /* return code              */
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32  *shadowPtr;/* pointer to the shadow for the index in the table */
    GT_U32  startBitIndex;/* the start bit index of entry in the line */
    GT_U32  numBitsPerEntry;/* number of bits per entry */
    GT_U32     valueArr[PRV_CPSS_DXCH_TABLE_MAX_ENTRY_SIZE_CNS];
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *shadowInfoPtr;
    GT_U32 numEntriesPerLine;
    GT_U32 isHalfMode;
    GT_U32  ii;
    GT_U32 unused;
    CPSS_DXCH_TABLE_ENT convertedHwTableType;
    GT_U32              convertedHwTableEntryIndex;

    if(GT_FALSE ==
        prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTable(devNum,
            hwTableType,
            hwTableEntryIndex))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "HW table is not applicable or index out of range");
    }

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_TABLE_MAC(devNum,portGroupsBmp,hwTableType);

    prvCpssDxChIndexAsPortNumConvert(devNum, hwTableType, hwTableEntryIndex,
                                     &unused, &convertedHwTableEntryIndex, &convertedHwTableType);

    if (convertedHwTableType >= CPSS_DXCH_TABLE_LAST_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    shadowInfoPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[convertedHwTableType]);

    if(CPSS_DXCH_SHADOW_TYPE_HW_E == shadowInfoPtr->shadowType)
    {
        /* the device not supports it or the table not requires shadow */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED,
                                      "need special implementation for 'Shadow in HW' ");
    }
    else
    if(CPSS_DXCH_SHADOW_TYPE_CPSS_E != shadowInfoPtr->shadowType)
    {
        /* the device not supports it or the table not requires shadow */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,
                                      "The CPSS hold no shadow for HW table[%d]",
                                      hwTableType);
    }

    /* loop on all active port groups in the bmp */
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(devNum,portGroupsBmp,portGroupId)
    {
        /* get pointer to the shadow */
        startBitIndex = 0;
        rc = prvCpssDxChPortGroupShadowEntryGet(
            devNum, portGroupId, convertedHwTableType,
            PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENTRY_E,
            convertedHwTableEntryIndex, &shadowPtr,
            &startBitIndex, &numBitsPerEntry, &numEntriesPerLine);
        if(rc != GT_OK)
        {
            return rc;
        }

        isHalfMode = numEntriesPerLine & FRACTION_HALF_TABLE_INDICATION_CNS;

        if (!isHalfMode && (startBitIndex % 32))
        {
            /* optimization to skip copyBits(...) */
            if(startBitIndex) /* multiples of 0 but not equal to 0 */
            {
                /* we not need to copy , we can jump to needed word */
                shadowPtr += (startBitIndex / 32);

                /* indicate that no offset is left ... skiping the 'copyBits' */
                startBitIndex = 0;
            }
        }
        else
        {
            /* Need to copy entry from the line into the buffer and assign
             * shadowPtr with it */

            if (!isHalfMode)
            {
                copyBits(valueArr, 0, shadowPtr, startBitIndex, numBitsPerEntry);
                /* make sure that last 32 bits of the target buffer are zero */
                resetBitsInMemory(valueArr, numBitsPerEntry, 32);
            }
            else
            {
                /* the entry occupies two non-continues lines - 1/x entry per line.
                   Need to write them separately */
                /* Remove the indication of fraction , so we have 'real' number */
                numEntriesPerLine &= ~ FRACTION_HALF_TABLE_INDICATION_CNS;

                /* copy first part of the entry */
                copyBits(valueArr,  0, shadowPtr, startBitIndex, numBitsPerEntry);

                for(ii = 0 ; ii < (numEntriesPerLine - 1) ; ii++)
                {
                    /* get the shadow line storing the next part of the entry */
                    startBitIndex = (ii+1) * numBitsPerEntry;

                    rc = prvCpssDxChPortGroupShadowEntryGet(
                        devNum, portGroupId, convertedHwTableType,
                        PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENTRY_E,
                        convertedHwTableEntryIndex,    /* index is of 'entry'  */
                        &shadowPtr,           /* pointer is to 'line' */
                        &startBitIndex,/* offset of the start of the 'entry' in the 'line' */
                        NULL,  /* not interested. We've got it before */
                        NULL); /* not interested. We've got it before */
                    if(rc != GT_OK)
                    {
                        return rc;
                    }

                    /* NOTE: startBitIndex is changed by prvCpssDxChPortGroupShadowEntryGet and
                             at most times will be reset to 0 !!!
                            and this value is relative to shadowPtr
                    */
                    /* shadowPtr is the start of this line in the shadow */
                    copyBits(valueArr,      /* target */
                             (ii+1) * numBitsPerEntry,  /* start bit in target */
                             shadowPtr,     /* source*/
                             startBitIndex, /* start bit in the source */
                             numBitsPerEntry); /* number of bits in the entry */
                }

                /* make sure that last 32 bits of the target buffer are zero */
                resetBitsInMemory(valueArr, (ii+1) * numBitsPerEntry, 32);
            }

            shadowPtr = &valueArr[0];
        }

        /* write from the shadow to the HW */
        rc = prvCpssDxChPortGroupWriteTableEntry(devNum,portGroupId,
            hwTableType,hwTableEntryIndex,
            shadowPtr);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(devNum,portGroupsBmp,portGroupId)


    return GT_OK;
}



/**
* @internal internal_cpssDxChDiagDataIntegrityTableEntryFix function
* @endinternal
*
* @brief   Data integrity : fix specific table entry that is corrupted in the HW,
*         using CPSS shadow for this table.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] locationPtr              - (pointer to) location information
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_BAD_PARAM             - on bad param
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_EMPTY                 - the DFX location is not mapped to CPSS HW table.
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChDiagDataIntegrityTableEntryFix
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_LOCATION_SPECIFIC_INFO_STC *locationPtr
)
{
    GT_STATUS   rc;
    GT_U32     jj, ii;
    CPSS_DXCH_HW_INDEX_INFO_STC hwEntryInfo;
    GT_U32                      portGroupId;
    const CPSS_DXCH_TABLE_ENT   *hwNameArr;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(locationPtr);

    switch(locationPtr->type)
    {
        case CPSS_DXCH_LOCATION_HW_INDEX_INFO_TYPE:
            rc = shadowTableEntryFix(devNum,
                    locationPtr->portGroupsBmp,
                    locationPtr->info.hwEntryInfo.hwTableType,
                    locationPtr->info.hwEntryInfo.hwTableEntryIndex);
            if (rc != GT_OK)
            {
                return rc;
            }
            break;

        case CPSS_DXCH_LOCATION_LOGICAL_INDEX_INFO_TYPE:
            rc = GT_BAD_PARAM;/* if no tables */
            for(ii = 0; ii < locationPtr->info.logicalEntryInfo.numOfLogicalTables; ii++)
            { /* logical tables iteration */
                CPSS_DXCH_LOGICAL_TABLE_ENT logicalTable = locationPtr->info.logicalEntryInfo.logicaTableInfo[ii].logicalTableType;

                if((GT_U32)logicalTable >= CPSS_DXCH_LOGICAL_TABLE_LAST_E)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                rc = prvCpssDxChDiagDataIntegrityTableLogicalToHwListGet(
                    devNum, logicalTable, &hwNameArr);
                if(rc != GT_OK)
                {
                    return rc;
                }

                /* if all HW tables are not applicable ... this value will be returned */
                rc = GT_BAD_PARAM;

                for(jj = 0; hwNameArr[jj] != LAST_VALID_TABLE_CNS; jj++)
                { /* hw tables iteration */
                    CPSS_DXCH_TABLE_ENT                     hwTableType;

                    hwTableType = hwNameArr[jj];

                    if(GT_FALSE ==
                        prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTable(devNum,hwTableType,
                        locationPtr->info.logicalEntryInfo.logicaTableInfo[ii].logicalTableEntryIndex))
                    {
                        /* the device not supports this HW table */
                        continue;
                    }

                    if(CPSS_DXCH_SHADOW_TYPE_NONE_E ==
                       prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTableShadow(devNum,hwTableType))
                    {
                        /* there is no shadow for this HW table */
                        continue;
                    }

                    rc = shadowTableEntryFix(devNum,
                          locationPtr->portGroupsBmp,
                          hwTableType,
                          locationPtr->info.logicalEntryInfo.logicaTableInfo[ii].logicalTableEntryIndex);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                } /* end: hw tables iteration */

                if(rc != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "all HW tables are not applicable");
                }

            } /* end: logical tables iteration */
            break;

        case CPSS_DXCH_LOCATION_RAM_INDEX_INFO_TYPE:
            /* convert RAM info to 'HW info' */
            rc = prvCpssDxChDiagDataIntegrityDfxErrorConvert(devNum,
                    &locationPtr->info.ramEntryInfo.memLocation,
                    locationPtr->info.ramEntryInfo.ramRow,
                    &portGroupId,
                    &hwEntryInfo);
            if (rc != GT_OK)
            {
                return rc;
            }

            rc = shadowTableEntryFix(devNum,
                    locationPtr->portGroupsBmp,
                    hwEntryInfo.hwTableType,
                    hwEntryInfo.hwTableEntryIndex);
            if (rc != GT_OK)
            {
                return rc;
            }

            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    } /* end of switch */

    return GT_OK;
}

/**
* @internal cpssDxChDiagDataIntegrityTableEntryFix function
* @endinternal
*
* @brief   Data integrity : fix specific table entry that is corrupted in the HW,
*         using CPSS shadow for this table.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] locationPtr              - (pointer to) location information
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_BAD_PARAM             - on bad param
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_EMPTY                 - the DFX location is not mapped to CPSS HW table.
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChDiagDataIntegrityTableEntryFix
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_LOCATION_SPECIFIC_INFO_STC *locationPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChDiagDataIntegrityTableEntryFix);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, locationPtr));

    rc = internal_cpssDxChDiagDataIntegrityTableEntryFix(devNum, locationPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, devNum, locationPtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}


/**
* @internal prvCpssCalculateHwTableShadowSize function
* @endinternal
*
* @brief   This function performs cpss shadow hw entry size calculation
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] hwTable                  - hw table name
*
* @retval size                     - memory size (in bytes) required for hw table shadow
*/
static GT_U32 prvCpssCalculateHwTableShadowSize
(
    IN GT_U8               devNum,
    IN CPSS_DXCH_TABLE_ENT hwTable
)
{
    GT_U32 maxNumOfEntries = PRV_CPSS_DXCH_PP_MAC(devNum)->accessTableInfoPtr[hwTable].maxNumOfEntries;
    GT_U32 entrySizeInBytes;
    GT_U32 numOfRelevantPortGroups;
    GT_PORT_GROUPS_BMP    portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
    GT_U32 size;

    numOfRelevantPortGroups =
        getNumOfRelevantPortGroups(devNum,portGroupsBmp,hwTable,NULL);

    entrySizeInBytes = 4 * PRV_CPSS_DXCH_PP_MAC(devNum)->accessTableInfoPtr[hwTable].entrySize;

    size = maxNumOfEntries * entrySizeInBytes * numOfRelevantPortGroups;

/*#define SHADOW_DEBUG_INFO_PRINT*/
#ifdef SHADOW_DEBUG_INFO_PRINT
    {
        static GT_U32 total = 0;

        total += size;
        cpssOsPrintf("Shadow memory table size %d, total %d \n ", size, total);
    }
#endif

    return size;
}

/**
* @internal hwTableShadowDefaultValueSet function
* @endinternal
*
* @brief   This function sets default values of HW into cpss shadow.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] hwTable                  - hw table name
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
*/
static GT_STATUS hwTableShadowDefaultValueSet
(
    IN GT_U8                devNum,
    IN CPSS_DXCH_TABLE_ENT  hwTable
)
{
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *tableInfoPtr;

    GT_U32     portGroupId; /* port group id */
    GT_U32     index;

    GT_U32     maxTableSize;
    GT_U32     maxLines;
    GT_STATUS  rc;
    GT_U32     valueArr[PRV_CPSS_DXCH_TABLE_MAX_ENTRY_SIZE_CNS];
    GT_PORT_GROUPS_BMP portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
    GT_U32     numOfRelevantPortGroups;

    tableInfoPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[hwTable]);

    /* clear the memory first */
    cpssOsMemSet(tableInfoPtr->hwTableMemPtr,0,tableInfoPtr->hwTableMemSize);

    rc = prvCpssDxChDiagDataIntegrityTableHwMaxIndexGet(devNum,hwTable,&maxTableSize,&maxLines);
    if(rc != GT_OK)
    {
        return rc;
    }

    numOfRelevantPortGroups = getNumOfRelevantPortGroups(devNum,portGroupsBmp,hwTable,NULL);

    /* get BMP of port groups that needs 'different' shadows */
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_TABLE_MAC(devNum,portGroupsBmp,hwTable);

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)
    {
        for(index = 0; index < maxTableSize; index++)
        {
            if(GT_FALSE ==
                prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTable(devNum, hwTable, index))
            {
                /* support the gaps */
                continue;
            }

            /* read hw table entry */
            rc = prvCpssDxChPortGroupReadTableEntry(devNum, portGroupId, hwTable, index, valueArr);
            if (rc != GT_OK)
            {
                return rc;
            }

            /* init hw table shadow */
            rc = prvCpssDxChPortGroupShadowEntryWrite(devNum, portGroupId, hwTable, index, valueArr);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        if (numOfRelevantPortGroups == 1)
        {
            /* table has only one shadow that hold same info for all port groups */
            break;
        }
    } /* end: port groups iteration */
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
        devNum, portGroupsBmp, portGroupId)

    return GT_OK;
}
/**
* @internal isTmTable function
* @endinternal
*
* @brief   is the HW table relate to traffic manager (TM).
*
* @param[in] hwTable                  - the HW table to check
*
* @retval GT_TRUE                  - table relate to TM
* @retval GT_FALSE                 - table NOT relate to TM
*/
static GT_BOOL isTmTable(IN  CPSS_DXCH_TABLE_ENT hwTable)
{
    GT_U32  ii;
    for(ii = 0 ; prvCpssDxChHwTrafficManagerTablesArr[ii] != CPSS_DXCH_TABLE_LAST_E ; ii++)
    {
        if(prvCpssDxChHwTrafficManagerTablesArr[ii] == hwTable)
        {
            return GT_TRUE;
        }
    }

    return GT_FALSE;
}
/**
* @internal prvCpssInitHwTableShadow function
* @endinternal
*
* @brief   This function performs cpss shadow hw entry init
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] hwTable                  - hw table name
* @param[in] isHwShadow               - is hw shadow or cpss
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_CPU_MEM        - failed to allocate CPU memory,
*/
GT_STATUS prvCpssInitHwTableShadow
(
    IN GT_U8                devNum,
    IN CPSS_DXCH_TABLE_ENT  hwTable,
    IN GT_BOOL              isHwShadow
)
{
    GT_STATUS   rc;
    GT_U32 ii;
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *tableInfoPtr;
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *main_tableInfoPtr;
    CPSS_DXCH_TABLE_ENT mainTable;
    GT_U32  maxLmuIndex;

    tableInfoPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[hwTable]);

    if(GT_FALSE == checkIsDevSupportHwTable(devNum, hwTable))
    {
        /* the device does not support this HW table, skipping */
        /* the shadow type for such entries is NONE by default */
        return GT_OK;
    }

    /* filter tables that no meaning to hold SW shadow for them */
    for (ii = 0; hwTablesNoNeedShadowArr[ii] != CPSS_DXCH_TABLE_LAST_E ; ii++)
    {
        if(hwTable == hwTablesNoNeedShadowArr[ii])
        {
            tableInfoPtr->shadowType = CPSS_DXCH_SHADOW_TYPE_NONE_E;
            return GT_OK;
        }
    }

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        /* tables used for debug purpose so no shadow support */
        if((hwTable >= (CPSS_DXCH_SIP6_TXQ_PDS_DATA_STORAGE_E + 0) &&
            hwTable <= (CPSS_DXCH_SIP6_TXQ_PDS_FRAG_TAIL_E + 31)) ||
            /* counters changed by the Device on traffic so no shadow support */
            (hwTable >= CPSS_DXCH_SIP6_TABLE_LMU_STATISTICS_E &&
            hwTable <= CPSS_DXCH_SIP6_TABLE_LMU_STATISTICS_LAST_E))
        {
            tableInfoPtr->shadowType = CPSS_DXCH_SHADOW_TYPE_NONE_E;
            return GT_OK;
        }

        if(hwTable >= CPSS_DXCH_SIP6_TABLE_LMU_CONFIGURATION_E &&
            hwTable <= CPSS_DXCH_SIP6_TABLE_LMU_CONFIGURATION_LAST_E)
        {
            /* Some devices like Ironman has no LMU units and hence need to skip
               shadow creation for all LMU tables. For devices having LMU unit, need
               to skip shadow for not relevant LMU tables on the specific device. */
            if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lmuInfo.numLmuUnits)
            {
                maxLmuIndex = CPSS_DXCH_SIP6_TABLE_LMU_CONFIGURATION_E + PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.lmuInfo.numLmuUnits - 1;
                if(hwTable > maxLmuIndex)
                {
                    tableInfoPtr->shadowType = CPSS_DXCH_SHADOW_TYPE_NONE_E;
                    return GT_OK;
                }
            }
            else
            {
                tableInfoPtr->shadowType = CPSS_DXCH_SHADOW_TYPE_NONE_E;
                return GT_OK;
            }
        }
    }

    if(GT_TRUE == isHwShadow)
    {
        tableInfoPtr->shadowType  = CPSS_DXCH_SHADOW_TYPE_HW_E;
    }
    else
    {
        tableInfoPtr->shadowType  = CPSS_DXCH_SHADOW_TYPE_CPSS_E;

        if(GT_FALSE == prvCpssDxChDiagDataIntegrityIsMultipleNames(hwTable,&mainTable))
        {
            /* get the size in bytes */
            tableInfoPtr->hwTableMemSize = prvCpssCalculateHwTableShadowSize(devNum, hwTable);

            tableInfoPtr->hwTableMemPtr  = (GT_U32*)cpssOsMalloc(tableInfoPtr->hwTableMemSize);
            if(NULL == tableInfoPtr->hwTableMemPtr)
            {
                tableInfoPtr->hwTableMemSize = 0;
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
            }

            if(isTmTable(hwTable))
            {
                /* at this stage some of the TM tables maybe inaccessible */
                /* only after calling function prvCpssTmCtlGlobalParamsInit()
                   we can initialize those tables with HW values */

                /* so only clear the memory */
                cpssOsMemSet(tableInfoPtr->hwTableMemPtr,0,tableInfoPtr->hwTableMemSize);
                return GT_OK;
            }

            /* initialize the shadow with 'HW default values' */
            rc = hwTableShadowDefaultValueSet(devNum,hwTable);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            main_tableInfoPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[mainTable]);

            tableInfoPtr->hwTableMemSize = main_tableInfoPtr->hwTableMemSize;
            tableInfoPtr->hwTableMemPtr  = main_tableInfoPtr->hwTableMemPtr;
        }
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChHwPpPhase1ShadowInit function
* @endinternal
*
* @brief   This function performs basic cpss shadow configuration
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] ppPhase1ParamsPtr        - Packet processor hardware specific parameters
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on failure
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_OUT_OF_CPU_MEM        - failed to allocate memory
*/
GT_STATUS prvCpssDxChHwPpPhase1ShadowInit
(
    IN CPSS_DXCH_PP_PHASE1_INIT_INFO_STC *ppPhase1ParamsPtr
)
{
    GT_STATUS rc;
    GT_U8     devNum;
    GT_BOOL   allTheTablesIteration;
    GT_BOOL   isHwShadow;
    GT_U32    index;

    CPSS_NULL_PTR_CHECK_MAC(ppPhase1ParamsPtr);
    devNum = ppPhase1ParamsPtr->devNum;

    switch(ppPhase1ParamsPtr->numOfDataIntegrityElements)
    {
        case 0:
            /* nothing to do */
            return GT_OK;
        case CPSS_DXCH_SHADOW_TYPE_AS_MANY_HW_CNS:
            allTheTablesIteration = GT_TRUE;
            isHwShadow            = GT_TRUE;
            break;
        case CPSS_DXCH_SHADOW_TYPE_ALL_CPSS_CNS:
            allTheTablesIteration = GT_TRUE;
            isHwShadow            = GT_FALSE;
            break;
        default:
            allTheTablesIteration = GT_FALSE;
            isHwShadow            = GT_FALSE;
            break;
    }

    if(GT_TRUE == allTheTablesIteration)
    {
        /* iterate all the hw tables */
        for(index = 0; index < CPSS_DXCH_TABLE_LAST_E; index++)
        {
            /* The init sequence for Falcon and above calls cpssDxChCfgPpLogicalInit (responsible for filling into the shared
             * tables HW: FDB/EM/LPM/ARP the needed configuration) after cpssDxChHwPpPhase1Init (resposible for shadow
             * tables init) thus causing init failure so handling the below based on sharedTableMode check which gets populated during
             * cpssDxChCfgPpLogicalInit and is default set during cpssDxChHwPpPhase1Init.
             */
            if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                switch(index)
                {
                    case CPSS_DXCH_SIP5_TABLE_LPM_MEM_E:
                        PRV_CPSS_DXCH_PP_MAC(devNum)->diagInfo.doShadowLpm = GT_TRUE;
                        continue;
                        break;
                    case CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E:
                        PRV_CPSS_DXCH_PP_MAC(devNum)->diagInfo.doShadowTs = GT_TRUE;
                        continue;
                        break;
                    case CPSS_DXCH_SIP6_TABLE_EXACT_MATCH_E:
                        PRV_CPSS_DXCH_PP_MAC(devNum)->diagInfo.doShadowEm = GT_TRUE;
                        continue;
                        break;
                    case CPSS_DXCH_SIP6_TABLE_PBR_E:
                        PRV_CPSS_DXCH_PP_MAC(devNum)->diagInfo.doShadowPbr = GT_TRUE;
                        continue;
                        break;
                    default:
                        break;
                }
            }
            if(prvCpssDxChDiagDataIntegrityIsMultipleNames(index,NULL))
            {
                continue;
            }

            rc = prvCpssInitHwTableShadow(devNum, index, isHwShadow);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* init the DUP tables after the 'main' tables must be initialized first */
        for(index = 0; index < CPSS_DXCH_TABLE_LAST_E; index++)
        {
            if(GT_FALSE == prvCpssDxChDiagDataIntegrityIsMultipleNames(index,NULL))
            {
                continue;
            }

            rc = prvCpssInitHwTableShadow(devNum, index, isHwShadow);
            if(rc != GT_OK)
            {
                return rc;
            }
        }


    }
    else
    {
        GT_U32 j;
        const CPSS_DXCH_TABLE_ENT *hwNameArr;

        /* iterate requested list of logical tables */
        for(index = 0; index < ppPhase1ParamsPtr->numOfDataIntegrityElements; index++)
        {
            CPSS_DXCH_LOGICAL_TABLES_SHADOW_STC *logicalEntryPtr = &(ppPhase1ParamsPtr->dataIntegrityShadowPtr[index]);
            switch(logicalEntryPtr->shadowType)
            {
                case CPSS_DXCH_SHADOW_TYPE_NONE_E:
                    /* skip inactive entry */
                    continue;
                case CPSS_DXCH_SHADOW_TYPE_CPSS_E:
                    isHwShadow = GT_FALSE;
                    break;
                case CPSS_DXCH_SHADOW_TYPE_HW_E:
                    /*isHwShadow = GT_TRUE;*/
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            rc = prvCpssDxChDiagDataIntegrityTableLogicalToHwListGet(
                devNum, logicalEntryPtr->logicalTableName, &hwNameArr);
            if(rc != GT_OK)
            {
                return rc;
            }

            for(j = 0; hwNameArr[j] != LAST_VALID_TABLE_CNS; j++)
            {
                /* The init sequence for Falcon calls cpssDxChCfgPpLogicalInit (responsible for filling into the shared
                 * tables HW: FDB/EM/LPM/ARP the needed configuration) after cpssDxChHwPpPhase1Init (resposible for shadow
                 * tables init) thus causing init failure so handling the below based on sharedTableMode check which gets populated during
                 * cpssDxChCfgPpLogicalInit and is default set during cpssDxChHwPpPhase1Init.
                 */
                if(PRV_CPSS_SIP_6_CHECK_MAC(devNum) &&
                    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.sip6_sbmInfo.sharedMemoryNotUsed == GT_FALSE)
                {
                    switch(hwNameArr[j])
                    {
                        case CPSS_DXCH_SIP5_TABLE_LPM_MEM_E:
                            PRV_CPSS_DXCH_PP_MAC(devNum)->diagInfo.doShadowLpm = GT_TRUE;
                            continue;
                            break;
                        case CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E:
                            PRV_CPSS_DXCH_PP_MAC(devNum)->diagInfo.doShadowTs = GT_TRUE;
                            continue;
                            break;
                        case CPSS_DXCH_SIP6_TABLE_EXACT_MATCH_E:
                            PRV_CPSS_DXCH_PP_MAC(devNum)->diagInfo.doShadowEm = GT_TRUE;
                            continue;
                            break;
                        default:
                            break;
                    }
                }
                if(prvCpssDxChDiagDataIntegrityIsMultipleNames(hwNameArr[j],NULL))
                {
                    continue;
                }
                rc = prvCpssInitHwTableShadow(devNum, hwNameArr[j], isHwShadow);
                if(rc != GT_OK)
                {
                    return rc;
                }
            } /* end of hw tables iteration */

            /* init the DUP tables after the 'main' tables must be initialized first */
            for(j = 0; hwNameArr[j] != LAST_VALID_TABLE_CNS; j++)
            {
                if(GT_FALSE == prvCpssDxChDiagDataIntegrityIsMultipleNames(hwNameArr[j],NULL))
                {
                    continue;
                }
                rc = prvCpssInitHwTableShadow(devNum, hwNameArr[j], isHwShadow);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }

        } /* end of logical tables iteration */
    }

    return GT_OK;
}

/**
* @internal isLogicalTableSupport function
* @endinternal
*
* @brief   This function detects if the logical table is supported in the device.
*
* @note   APPLICABLE DEVICES:      Falcon; AC5; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2; Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2;
*
* @param[in] devNum                - device number
* @param[in] logicalTable          - Logical table name
*
* @retval GT_OK                    - Logical table is supported
* @retval GT_FAIL                  - Logical table is not supported
*
*/
static GT_STATUS isLogicalTableSupport
(
    IN GT_U8                       devNum,
    IN CPSS_DXCH_LOGICAL_TABLE_ENT logicalTable
)
{
    if(PRV_CPSS_DXCH_AC5_CHECK_MAC(devNum))
    {
        switch(logicalTable)
        {
            case CPSS_DXCH_LOGICAL_TABLE_VLAN_E:
            case CPSS_DXCH_LOGICAL_TABLE_PHYSICAL_PORT_E:
            case CPSS_DXCH_LOGICAL_TABLE_STG_E:
            case CPSS_DXCH_LOGICAL_TABLE_VLAN_TRANSLATION_E:
            case CPSS_DXCH_LOGICAL_TABLE_QOS_PROFILE_E:
            case CPSS_DXCH_LOGICAL_TABLE_TRUNK_MEMBERS_E:
            case CPSS_DXCH_LOGICAL_TABLE_INGRESS_PCL_CONFIG_E:
            case CPSS_DXCH_LOGICAL_TABLE_PCL_UDB_CONFIG_E:
            case CPSS_DXCH_LOGICAL_TABLE_FDB_E:
            case CPSS_DXCH_LOGICAL_TABLE_L2_MLL_LTT_E:
            case CPSS_DXCH_LOGICAL_TABLE_TUNNEL_START_CONFIG_E:
            case CPSS_DXCH_LOGICAL_TABLE_ARP_E:
            case CPSS_DXCH_LOGICAL_TABLE_CN_SAMPLE_INTERVALS_E:
            case CPSS_DXCH_LOGICAL_TABLE_IPVX_ROUTER_NEXTHOP_E:
            case CPSS_DXCH_LOGICAL_TABLE_IPVX_ROUTER_NEXTHOP_AGE_BITS_E:
            case CPSS_DXCH_LOGICAL_TABLE_ROUTER_MAC_SA_E:
            case CPSS_DXCH_LOGICAL_TABLE_MAC2ME_E:
            case CPSS_DXCH_LOGICAL_TABLE_EGRESS_POLICER_REMARKING_E:
            case CPSS_DXCH_LOGICAL_TABLE_MULTICAST_E:
            case CPSS_DXCH_LOGICAL_TABLE_STATISTICAL_RATE_LIMIT_E:
            case CPSS_DXCH_LOGICAL_TABLE_CPU_CODE_E:
            case CPSS_DXCH_LOGICAL_TABLE_VLAN_PORT_PROTOCOL_E:
            case CPSS_DXCH_LOGICAL_TABLE_EGRESS_PCL_CONFIG_E:
            case CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_PARITY_E:
            case CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_ECC_E:
            case CPSS_DXCH_LOGICAL_INTERNAL_TABLE_DESCRIPTORS_CONTROL_ECC_E:
            case CPSS_DXCH_LOGICAL_INTERNAL_TABLE_DESCRIPTORS_CONTROL_PARITY_E:
            case CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_CONTROL_PARITY_E:
            case CPSS_DXCH_LOGICAL_INTERNAL_TABLE_PACKET_DATA_CONTROL_ECC_E:
            case CPSS_DXCH_LOGICAL_INTERNAL_TABLE_CM3_RAM_E:
            case CPSS_DXCH_LOGICAL_INTERNAL_TABLE_MANAGEMENT_E:
                return GT_OK;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }
    }
    return GT_OK;
}

/**
* @internal internal_cpssDxChDiagDataIntegrityShadowEntryInfoGet function
* @endinternal
*
* @brief   This function calculates size of memory required for given shadow entry
*         the function allow to understand which tables can be given as parameter to
*         cpssDxChHwPpPhase1Init(...) for parameters :
*         CPSS_DXCH_PP_PHASE1_INIT_INFO_STC::numOfDataIntegrityElements
*         CPSS_DXCH_PP_PHASE1_INIT_INFO_STC::dataIntegrityShadowPtr
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - device number
* @param[in,out] tablesInfoPtr        - in : info for which logical tables need to
*                                            calculate size of shadow
*                                       out: info filled with size per supported table
*
* @param[out] totalMemSizePtr          - (pointer to) total memory size required for the shadow
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on failure
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
static GT_STATUS internal_cpssDxChDiagDataIntegrityShadowEntryInfoGet
(
    IN     GT_U8                                     devNum,
    INOUT  CPSS_DXCH_LOGICAL_TABLES_SHADOW_INFO_STC *tablesInfoPtr,
    OUT    GT_U32                                   *totalMemSizePtr
)
{
    GT_STATUS rc;

    GT_BOOL   allTheTablesIteration;
    GT_U32    index;
    GT_U32    j;
    const CPSS_DXCH_TABLE_ENT *hwNameArr;
    CPSS_DXCH_LOGICAL_TABLE_SHADOW_INFO_STC *logicalEntryPtr;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(tablesInfoPtr);
    CPSS_NULL_PTR_CHECK_MAC(totalMemSizePtr);

    switch(tablesInfoPtr->numOfDataIntegrityElements)
    {
        case 0:
        case CPSS_DXCH_SHADOW_TYPE_AS_MANY_HW_CNS:
        case CPSS_DXCH_SHADOW_TYPE_ALL_CPSS_CNS:
            allTheTablesIteration = GT_TRUE;
            break;
        default:
            allTheTablesIteration = GT_FALSE;
            break;
    }

    *totalMemSizePtr = 0;

    if(GT_TRUE == allTheTablesIteration)
    {
        /* iterate all the hw tables */
        for(index = 0; index < CPSS_DXCH_LOGICAL_TABLE_LAST_E; index++)
        {
            if(GT_FAIL == isLogicalTableSupport(devNum, index))
            {
                /* Logical table is not supported for this device */
                continue;
            }
            rc = prvCpssDxChDiagDataIntegrityTableLogicalToHwListGet(
                devNum, index, &hwNameArr);
            if(rc != GT_OK)
            {
                return rc;
            }
            for(j = 0; hwNameArr[j] != LAST_VALID_TABLE_CNS; j++)
            {
                if(GT_FALSE ==
                    prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTable(devNum,hwNameArr[j],0))
                {
                    /*skip HW table that is not relevant to current device*/
                    continue;
                }

                *totalMemSizePtr += prvCpssCalculateHwTableShadowSize(devNum, hwNameArr[j]);
            }
        }
    }
    else
    {
        CPSS_NULL_PTR_CHECK_MAC(tablesInfoPtr->logicalTablesArr);


        /* iterate requested list of logical tables */
        for(index = 0; index < tablesInfoPtr->numOfDataIntegrityElements; index++)
        {
            logicalEntryPtr = &(tablesInfoPtr->logicalTablesArr[index]);
            CPSS_NULL_PTR_CHECK_MAC(logicalEntryPtr);

            switch(logicalEntryPtr->shadowType)
            {
                case CPSS_DXCH_SHADOW_TYPE_NONE_E:
                    continue;
                case CPSS_DXCH_SHADOW_TYPE_HW_E:
                    break; /* ok */
                case CPSS_DXCH_SHADOW_TYPE_CPSS_E:
                    break; /* ok */
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            rc = prvCpssDxChDiagDataIntegrityTableLogicalToHwListGet(
                devNum, logicalEntryPtr->logicalTableName, &hwNameArr);
            if(rc != GT_OK)
            {
                return rc;
            }

            logicalEntryPtr->isSupported = GT_OK;
            logicalEntryPtr->numOfBytes = 0;

            for(j = 0; hwNameArr[j] != LAST_VALID_TABLE_CNS; j++)
            {
                if(GT_FALSE ==
                    prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTable(devNum,hwNameArr[j],0))
                {
                    /*skip HW table that is not relevant to current device*/
                    continue;
                }

                /* add this HW table size to total of this logical table */
                logicalEntryPtr->numOfBytes  +=
                    prvCpssCalculateHwTableShadowSize(devNum, hwNameArr[j]);

            } /* end of hw tables iteration */

            /* add this logical table size to total */
            *totalMemSizePtr += logicalEntryPtr->numOfBytes;
        } /* end of logical tables iteration */
    }

    return GT_OK;
}

/**
* @internal cpssDxChDiagDataIntegrityShadowEntryInfoGet function
* @endinternal
*
* @brief   This function calculates size of memory required for given shadow entry
*         the function allow to understand which tables can be given as parameter to
*         cpssDxChHwPpPhase1Init(...) for parameters :
*         CPSS_DXCH_PP_PHASE1_INIT_INFO_STC::numOfDataIntegrityElements
*         CPSS_DXCH_PP_PHASE1_INIT_INFO_STC::dataIntegrityShadowPtr
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - device number
* @param[in,out] tablesInfoPtr        - in : info for which logical tables need to
*                                            calculate size of shadow
*                                       out: info filled with size per supported table
*
* @param[out] totalMemSizePtr          - (pointer to) total memory size required for the shadow
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on failure
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS cpssDxChDiagDataIntegrityShadowEntryInfoGet
(
    IN     GT_U8                                     devNum,
    INOUT  CPSS_DXCH_LOGICAL_TABLES_SHADOW_INFO_STC *tablesInfoPtr,
    OUT    GT_U32                                   *totalMemSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChDiagDataIntegrityShadowEntryInfoGet);

    CPSS_API_LOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tablesInfoPtr, totalMemSizePtr));

    rc = internal_cpssDxChDiagDataIntegrityShadowEntryInfoGet(devNum, tablesInfoPtr, totalMemSizePtr);
    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, devNum, tablesInfoPtr, totalMemSizePtr));
    CPSS_API_UNLOCK_MAC(devNum,PRV_CPSS_FUNCTIONALITY_CONFIGURATION_CNS);

    return rc;
}



/**
* @internal prvCpssDxChPortGroupReadTableEntry_fromShadow function
* @endinternal
*
* @brief   Read a whole entry from the 'SHADOW' table. - for specific portGroupId
*         operation involves copy of values from the shadow to the 'OUT buffer'
*         (pointer of entryValuePtr)
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - the device number
* @param[in] portGroupId              - the port group Id , to support multi-port-group devices that need to access
*                                      specific port group
* @param[in] tableType                - the specific table name
* @param[in] entryIndex               - index in the table
*
* @param[out] entryValuePtr            - (pointer to) the data read from the entry in the table
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_BAD_PTR               - on NULL pointer
* @retval GT_OUT_OF_RANGE          - parameter not in valid range
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChPortGroupReadTableEntry_fromShadow
(
    IN GT_U8                   devNum,
    IN GT_U32                  portGroupId,
    IN CPSS_DXCH_TABLE_ENT     tableType,
    IN GT_U32                  entryIndex,
    OUT GT_U32                 *entryValuePtr
)
{
    GT_STATUS  rc;                          /* return code              */
    GT_U32  *shadowPtr;/* pointer to the shadow for the index in the table */
    GT_U32  startBitIndex;/* the start bit index of entry in the line */
    GT_U32  numBitsPerEntry;/* number of bits per entry */
    GT_PORT_GROUPS_BMP portGroupsBmp;
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *shadowInfoPtr;
    GT_U32 numEntriesPerLine;
    GT_U32 unused;
    GT_U32  ii;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(entryValuePtr);

    portGroupsBmp = (portGroupId == CPSS_PORT_GROUP_UNAWARE_MODE_CNS) ?
                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS :
                    (GT_PORT_GROUPS_BMP)(1 << portGroupId);

    /* get BMP of port groups that needs 'different' shadows */
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_SPECIFIC_TABLE_MAC(devNum,portGroupsBmp,tableType);

    if(GT_FALSE ==
        prvCpssDxChDiagDataIntegrityTableCheckIsDevSupportHwTable(devNum,
            tableType,
            entryIndex))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "HW table is not applicable or index out of range");
    }

    prvCpssDxChIndexAsPortNumConvert(devNum, tableType, entryIndex,
                                     &unused, &entryIndex, &tableType);

    if (tableType >= CPSS_DXCH_TABLE_LAST_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    shadowInfoPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[tableType]);

    if(CPSS_DXCH_SHADOW_TYPE_HW_E == shadowInfoPtr->shadowType)
    {
        /* the device not supports it or the table not requires shadow */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, "need special implementation for 'Shadow in HW' ");
    }
    else
    if(CPSS_DXCH_SHADOW_TYPE_CPSS_E != shadowInfoPtr->shadowType)
    {
        /* the device not supports it or the table not requires shadow */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "The CPSS hold no shadow for HW table[%d]",tableType);
    }

    /* get pointer to the shadow */
    startBitIndex = 0;
    rc = prvCpssDxChPortGroupShadowEntryGet(
        devNum, portGroupId, tableType,
        PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENTRY_E,
        entryIndex, &shadowPtr,
        &startBitIndex, &numBitsPerEntry, &numEntriesPerLine);
    if(rc != GT_OK)
    {
        return rc;
    }

    if (numEntriesPerLine & FRACTION_HALF_TABLE_INDICATION_CNS)
    {
        /* the entry occupies two non-continues lines - 1/x entry per line.
           Need to write them separately */
        /* Remove the indication of fraction , so we have 'real' number */
        numEntriesPerLine &= ~ FRACTION_HALF_TABLE_INDICATION_CNS;

        /* copy first part of the entry */
        copyBits(entryValuePtr, 0, shadowPtr, startBitIndex, numBitsPerEntry);

        for(ii = 0 ; ii < (numEntriesPerLine - 1) ; ii++)
        {
            /* get the shadow line storing the next part of the entry */
            startBitIndex = (ii+1) * numBitsPerEntry;
            rc = prvCpssDxChPortGroupShadowEntryGet(
                devNum, portGroupId, tableType,
                PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_ENTRY_E,
                entryIndex, &shadowPtr,
                &startBitIndex, NULL, NULL);
            if(rc != GT_OK)
            {
                return rc;
            }
            /* NOTE: startBitIndex is changed by prvCpssDxChPortGroupShadowEntryGet and
                     at most times will be reset to 0 !!!
                    and this value is relative to shadowPtr
            */
            /* shadowPtr is the start of this line in the shadow */
            copyBits(&entryValuePtr[0], (ii+1) * numBitsPerEntry,   /* target base, offset */
                     shadowPtr        , startBitIndex           ,   /* source base, offset */
                     numBitsPerEntry);                              /* number of bits */
        }
    }
    else
    {
        copyBits(&entryValuePtr[0], 0            ,  /* target base, offset */
                 shadowPtr        , startBitIndex,  /* source base, offset */
                 numBitsPerEntry);                  /* number of bits */
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChDiagDataIntegrityShadowAndHwSynch function
* @endinternal
*
* @brief   Synchronize all cpss shadow tables with values from HW.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman; AC5.
* @note   NOT APPLICABLE DEVICES:  xCat3; Lion2.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_BAD_PTR               - one of the parameters is NULL pointer
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChDiagDataIntegrityShadowAndHwSynch
(
    IN GT_U8                devNum
)
{
    GT_STATUS   rc;
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *tableInfoPtr;
    CPSS_DXCH_TABLE_ENT  hwTable;
    GT_U32              maxHwTable;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_LION2_E);

    maxHwTable = PRV_CPSS_DXCH_TABLE_SIZE_GET_MAC(devNum);

    for(hwTable = 0 ; (GT_U32)hwTable < maxHwTable; hwTable++)
    {
        tableInfoPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[hwTable]);

        if(tableInfoPtr->shadowType != CPSS_DXCH_SHADOW_TYPE_CPSS_E)
        {
            continue;
        }

        /* initialize the shadow with 'HW default values' */
        rc = hwTableShadowDefaultValueSet(devNum,hwTable);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/**
* @internal prvCpssDxChDiagDataIntegrityShadowAndHwSynchTable function
* @endinternal
*
* @brief   Synchronize specific table cpss shadow with values from HW.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - device number
* @param[in] hwTable                  - the HW table to Synchronize
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_SUPPORTED         - the table not supports the shadow
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChDiagDataIntegrityShadowAndHwSynchTable
(
    IN GT_U8                devNum,
    IN CPSS_DXCH_TABLE_ENT  hwTable
)
{
    GT_STATUS   rc;
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *tableInfoPtr;
    GT_U32              maxHwTable;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E);

    maxHwTable = PRV_CPSS_DXCH_TABLE_SIZE_GET_MAC(devNum);

    if((GT_U32)hwTable >= maxHwTable)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    tableInfoPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[hwTable]);

    if(tableInfoPtr->shadowType == CPSS_DXCH_SHADOW_TYPE_HW_E)
    {
        /* no synch needed */
        return GT_OK;
    }

    if(tableInfoPtr->shadowType != CPSS_DXCH_SHADOW_TYPE_CPSS_E)
    {
        return /* not error for the logger */ GT_NOT_SUPPORTED;
    }

    /* initialize the shadow with 'HW default values' */
    rc = hwTableShadowDefaultValueSet(devNum,hwTable);
    CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);

}

/**
* @internal prvCpssDxChDiagDataIntegrityShadowAndHwSynchTm function
* @endinternal
*
* @brief   Synchronize all TM related cpss shadow tables with values from HW.
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
*
* @param[in] devNum                   - device number
*
* @retval GT_OK                    - on success.
* @retval GT_FAIL                  - on failure.
* @retval GT_BAD_PARAM             - one of the parameters value is wrong
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChDiagDataIntegrityShadowAndHwSynchTm
(
    IN GT_U8                devNum
)
{
    GT_STATUS   rc;
    CPSS_DXCH_TABLE_ENT  hwTable;
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *tableInfoPtr;
    GT_U32  ii;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_XCAT3_E | CPSS_AC5_E | CPSS_LION2_E |
        CPSS_BOBCAT3_E | CPSS_ALDRIN_E | CPSS_AC3X_E | CPSS_ALDRIN2_E);

    for(ii = 0 ; prvCpssDxChHwTrafficManagerTablesArr[ii] != CPSS_DXCH_TABLE_LAST_E ; ii++)
    {
        hwTable = prvCpssDxChHwTrafficManagerTablesArr[ii];

        tableInfoPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[hwTable]);

        if(tableInfoPtr->shadowType != CPSS_DXCH_SHADOW_TYPE_CPSS_E)
        {
            continue;
        }

        /* initialize the shadow with 'HW default values' */
        rc = hwTableShadowDefaultValueSet(devNum,hwTable);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    return GT_OK;
}

/**
* @internal prvCpssDxChDiagDataIntegrityIsMultipleNames function
* @endinternal
*
* @brief   is the HW table duplicated in HW.
*
* @param[in] hwTable                  - the HW table to check
*
* @param[out] mainTablePtr             - pointer to the 'main table' (ignored if NULL)
*
* @retval GT_TRUE                  - table has other main table name
*/
GT_BOOL prvCpssDxChDiagDataIntegrityIsMultipleNames(
    IN  CPSS_DXCH_TABLE_ENT hwTable,
    OUT CPSS_DXCH_TABLE_ENT *mainTablePtr
)
{
    GT_U32 ii;
    struct {
        CPSS_DXCH_TABLE_ENT mainTable;
        CPSS_DXCH_TABLE_ENT dupTable;
    }dupTables[]= {
        {CPSS_DXCH_SIP5_TABLE_IP_MLL_E , CPSS_DXCH_SIP5_TABLE_L2_MLL_E}

         /* must be last*/
        ,{CPSS_DXCH_TABLE_LAST_E,CPSS_DXCH_TABLE_LAST_E}
    };

    for(ii = 0 ; dupTables[ii].mainTable != CPSS_DXCH_TABLE_LAST_E ; ii++)
    {
        if(dupTables[ii].dupTable == hwTable)
        {
            if(mainTablePtr)
            {
                *mainTablePtr =  dupTables[ii].mainTable;
            }
            return GT_TRUE;
        }
    }

    if(mainTablePtr)
    {
        *mainTablePtr = hwTable;/* 1:1 */
    }
    return GT_FALSE;
}


/**
* @internal prvCpssDxChPortGroupShadowLineUpdateMasked function
* @endinternal
*
* @brief   Either write a whole entry (if mask is not specified) into PP's shadow
*         DB table at specific 'line index' or update the shadow table entry
*         according to the specified mask
*
* @note   APPLICABLE DEVICES:      Bobcat2; Caelum; Aldrin; AC3X; Bobcat3; Aldrin2; Falcon; AC5P; AC5X; Harrier; Ironman.
* @note   NOT APPLICABLE DEVICES:  xCat3; AC5; Lion2.
*
* @param[in] devNum                   - The PP device number to write to.
* @param[in] portGroupId              - The port group id. relevant only to 'multi-port-groups'
*                                      devices. Supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS
*                                      (APPLICABLE DEVICES Bobcat3; Falcon; AC5P; AC5X; Harrier; Ironman)
* @param[in] tableType                - the 'HW table'
* @param[in] lineIndex                - the line index in the 'HW table'
*                                      (not the same index as the functions of 'table engine'
*                                      get (like prvCpssDxChPortGroupWriteTableEntry))
* @param[in] entryValuePtr            - (pointer to) an array containing the data to be
*                                      copied into the shadow
* @param[in] entryMaskPtr             - (pointer to) array of mask.
*                                      If NULL - the entry specified by entryValuePtr will
*                                      be written to shadow.
*                                      If not NULL  - only bits that are raised in the mask
*                                      will be updated in HW entry.
*
* @retval GT_OK                    - on success
* @retval GT_FAIL                  - on hardware error
* @retval GT_NOT_INITIALIZED       - if the driver was not initialized
* @retval GT_HW_ERROR              - on hardware error
* @retval GT_NOT_APPLICABLE_DEVICE - on not applicable device
*/
GT_STATUS prvCpssDxChPortGroupShadowLineUpdateMasked
(
    IN GT_U8                 devNum,
    IN GT_U32                portGroupId,
    IN CPSS_DXCH_TABLE_ENT   tableType,
    IN GT_U32                lineIndex,
    IN GT_U32               *entryValuePtr,
    IN GT_U32               *entryMaskPtr
)
{
    GT_STATUS   rc;
    PRV_CPSS_DXCH_HW_TABLES_SHADOW_STC *shadowInfoPtr = &(PRV_CPSS_DXCH_PP_MAC(devNum)->shadowInfoArr[tableType]);
    GT_U32 *entryInShadowPtr;/* pointer to the entry in the shadow */
    GT_U32 entrySize;
    GT_U32 entrySizeInBytes;

    if(CPSS_DXCH_SHADOW_TYPE_CPSS_E != shadowInfoPtr->shadowType)
    {
        /* the device not supports it or the table not requires shadow */
        return GT_OK;
    }

    rc = prvCpssDxChPortGroupShadowEntryGet(devNum,portGroupId,tableType,
                                            PRV_CPSS_DXCH_SHADOW_INDEX_TYPE_LINE_E,
                                            lineIndex,&entryInShadowPtr,
                                            NULL,NULL,NULL);
    if(rc != GT_OK)
    {
        return rc;
    }

    entrySize = PRV_CPSS_DXCH_PP_MAC(devNum)->accessTableInfoPtr[tableType].entrySize;
    entrySizeInBytes = 4 * entrySize;

    if (NULL == entryMaskPtr)
    {
        if (entryValuePtr !=  entryInShadowPtr)
        {
            /* write full entry as is */
            cpssOsMemCpy(entryInShadowPtr, entryValuePtr, entrySizeInBytes);
        }
    }
    else
    {
        GT_U32 i;

        for (i=0; i < entrySize; i++)
        {
            if (entryMaskPtr[i])
            {
                entryInShadowPtr[i] =
                    (entryValuePtr[i] & entryMaskPtr[i]) | (entryInShadowPtr[i] & ~entryMaskPtr[i]) ;
            }
        }
    }

    return  GT_OK;
}

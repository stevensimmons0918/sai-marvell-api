/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
*/
/**
********************************************************************************
* @file cpssDxChPtpUT.c
*
* @brief Unit tests for cpssDxChPtp, that provides
* CPSS DxCh Precision Time Protocol function implementations.
*
* @version   26
********************************************************************************
*/
/* includes */

#define UT_FIXED_PORT_TO_SUPPORT_U32_TYPE_MAC

#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChInfo.h>
#include <cpss/dxCh/dxChxGen/ptp/cpssDxChPtp.h>
#include <cpss/dxCh/dxChxGen/ptpManager/cpssDxChPtpManager.h>
#include <utf/utfMain.h>
#include <utf/private/prvUtfExtras.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDb.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDbInterface.h>

/* Defines */

#define SINGLE_TAI_DEV_MAC(_dev) \
    (PRV_CPSS_DXCH_PP_MAC(_dev)->hwInfo.gop_tai.supportSingleInstance != GT_FALSE)

static CPSS_DXCH_PTP_TAI_NUMBER_ENT    taiNumber[3] =
        {CPSS_DXCH_PTP_TAI_NUMBER_0_E, CPSS_DXCH_PTP_TAI_NUMBER_1_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E};

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpCpuCodeBaseGet
(
    IN  GT_U8                     dev,
    OUT CPSS_NET_RX_CPU_CODE_ENT  *cpuCodePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpCpuCodeBaseGet)
{
/*
    ITERATE_DEVICES(Lion and above)
    1.1. Call with not null cpuCodePtr.
    Expected: GT_OK.
    1.2. Call api with wrong cpuCodePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;

    GT_U8                     dev;
    CPSS_NET_RX_CPU_CODE_ENT  cpuCode;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with not null cpuCodePtr.
            Expected: GT_OK.
        */
        st = cpssDxChPtpCpuCodeBaseGet(dev, &cpuCode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call api with wrong cpuCodePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpCpuCodeBaseGet(dev, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
    }

    /* restore correct values */

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpCpuCodeBaseGet(dev, &cpuCode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpCpuCodeBaseGet(dev, &cpuCode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpCpuCodeBaseSet
(
    IN  GT_U8                    dev,
    IN  CPSS_NET_RX_CPU_CODE_ENT cpuCode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpCpuCodeBaseSet)
{
/*
    ITERATE_DEVICES(Lion and above)
    1.1. Call with cpuCode[(CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1) /
                           CPSS_NET_UN_KNOWN_UC_E /
                           CPSS_NET_UN_REGISTERD_MC_E /
                           CPSS_NET_CONTROL_BPDU_E /
                           CPSS_NET_CONTROL_DEST_MAC_TRAP_E],
    Expected: GT_OK.
    1.2. Call cpssDxChPtpCpuCodeBaseGet
           with the same parameters.
    Expected: GT_OK and the same values than was set.
    1.3. Call api with wrong cpuCode [wrong enum values].
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS st = GT_OK;

    GT_U8                    dev;
    CPSS_NET_RX_CPU_CODE_ENT cpuCode = (CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1);
    CPSS_NET_RX_CPU_CODE_ENT cpuCodeGet = (CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1);

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with cpuCode[(CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1) /
                                   CPSS_NET_UN_KNOWN_UC_E /
                                   CPSS_NET_UN_REGISTERD_MC_E /
                                   CPSS_NET_CONTROL_BPDU_E /
                                   CPSS_NET_CONTROL_DEST_MAC_TRAP_E],
            Expected: GT_OK.
        */
        /* call with cpuCode[(CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1)] */
        cpuCode = (CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1);

        st = cpssDxChPtpCpuCodeBaseSet(dev, cpuCode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpCpuCodeBaseGet
                   with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpCpuCodeBaseGet(dev, &cpuCodeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpCpuCodeBaseGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(cpuCode, cpuCodeGet,
                       "got another cpuCode then was set: %d", dev);

        /* call with cpuCode[CPSS_NET_IEEE_RSRVD_MULTICAST_ADDR_1_E] */
        cpuCode = CPSS_NET_IEEE_RSRVD_MULTICAST_ADDR_1_E;

        st = cpssDxChPtpCpuCodeBaseSet(dev, cpuCode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpCpuCodeBaseGet
                   with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpCpuCodeBaseGet(dev, &cpuCodeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpCpuCodeBaseGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(cpuCode, cpuCodeGet,
                       "got another cpuCode then was set: %d", dev);

        /* call with cpuCode[CPSS_NET_IPV6_HOP_BY_HOP_E] */
        cpuCode = CPSS_NET_IPV6_HOP_BY_HOP_E;

        st = cpssDxChPtpCpuCodeBaseSet(dev, cpuCode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpCpuCodeBaseGet
                   with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpCpuCodeBaseGet(dev, &cpuCodeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpCpuCodeBaseGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(cpuCode, cpuCodeGet,
                       "got another cpuCode then was set: %d", dev);

        /* call with cpuCode[CPSS_NET_CONTROL_BPDU_E] */
        cpuCode = CPSS_NET_CONTROL_BPDU_E;

        st = cpssDxChPtpCpuCodeBaseSet(dev, cpuCode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpCpuCodeBaseGet
                   with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpCpuCodeBaseGet(dev, &cpuCodeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpCpuCodeBaseGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(cpuCode, cpuCodeGet,
                       "got another cpuCode then was set: %d", dev);

        /* call with cpuCode[CPSS_NET_CLASS_KEY_MIRROR_E] */
        cpuCode = CPSS_NET_CLASS_KEY_MIRROR_E;

        st = cpssDxChPtpCpuCodeBaseSet(dev, cpuCode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpCpuCodeBaseGet
                   with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpCpuCodeBaseGet(dev, &cpuCodeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpCpuCodeBaseGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(cpuCode, cpuCodeGet,
                       "got another cpuCode then was set: %d", dev);

        /*
            1.3. Call api with wrong cpuCode [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpCpuCodeBaseSet
                            (dev, cpuCode),
                            cpuCode);
    }

    /* restore correct values */
    cpuCode = (CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1);

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpCpuCodeBaseSet(dev, cpuCode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpCpuCodeBaseSet(dev, cpuCode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpEtherTypeGet
(
    IN  GT_U8   dev,
    IN  GT_U32  etherTypeIndex,
    OUT GT_U32  *etherTypePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpEtherTypeGet)
{
/*
    ITERATE_DEVICES(Lion and above)
    1.1. Call with etherTypeIndex[0 / 1],
    Expected: GT_OK.
    1.2. Call api with wrong etherTypeIndex [2].
    Expected: NOT GT_OK.
    1.3. Call api with wrong etherTypePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;

    GT_U8   dev;
    GT_U32  etherTypeIndex = 0;
    GT_U32  etherType;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with etherTypeIndex[0 / 1],
            Expected: GT_OK.
        */

        st = cpssDxChPtpEtherTypeGet(dev, etherTypeIndex, &etherType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* call with etherTypeIndex[1] */
        etherTypeIndex = 1;

        st = cpssDxChPtpEtherTypeGet(dev, etherTypeIndex, &etherType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call api with wrong etherTypeIndex [2].
            Expected: NOT GT_OK.
        */
        etherTypeIndex = 2;

        st = cpssDxChPtpEtherTypeGet(dev, etherTypeIndex, &etherType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        etherTypeIndex = 0;

        /*
            1.3. Call api with wrong etherTypePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpEtherTypeGet(dev, etherTypeIndex, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
    }

    /* restore correct values */
    etherTypeIndex = 0;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpEtherTypeGet(dev, etherTypeIndex, &etherType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpEtherTypeGet(dev, etherTypeIndex, &etherType);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpEtherTypeSet
(
    IN  GT_U8  dev,
    IN  GT_U32 etherTypeIndex,
    IN  GT_U32 etherType
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpEtherTypeSet)
{
/*
    ITERATE_DEVICES(Lion and above)
    1.1. Call with etherTypeIndex[0 / 1], etherType[0 / 0xFFFF],
    Expected: GT_OK.
    1.2. Call cpssDxChPtpEtherTypeGet with the same parameters.
    Expected: GT_OK and the same values than was set.
    1.3. Call api with wrong etherTypeIndex [2].
    Expected: NOT GT_OK.
    1.4. Call api with wrong etherType [0xFFFF + 1].
    Expected: NOT GT_OK.
*/
    GT_STATUS st = GT_OK;

    GT_U8  dev;
    GT_U32 etherTypeIndex = 0;
    GT_U32 etherType = 0;
    GT_U32 etherTypeGet = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with etherTypeIndex[0 / 1], etherType[0 / 0xFFFF],
            Expected: GT_OK.
        */

        /* call with etherTypeIndex[0], etherType[0] */
        etherTypeIndex = 0;
        etherType = 0;

        st = cpssDxChPtpEtherTypeSet(dev, etherTypeIndex, etherType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpEtherTypeGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpEtherTypeGet(dev, etherTypeIndex, &etherTypeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpEtherTypeGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(etherType, etherTypeGet,
                       "got another etherType then was set: %d", dev);

        /* call with etherTypeIndex[1], etherType[0xFFFF] */
        etherTypeIndex = 1;
        etherType = 0xFFFF;

        st = cpssDxChPtpEtherTypeSet(dev, etherTypeIndex, etherType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpEtherTypeGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpEtherTypeGet(dev, etherTypeIndex, &etherTypeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpEtherTypeGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(etherType, etherTypeGet,
                       "got another etherType then was set: %d", dev);

        /*
            1.3. Call api with wrong etherTypeIndex [2].
            Expected: NOT GT_OK.
        */
        etherTypeIndex = 2;

        st = cpssDxChPtpEtherTypeSet(dev, etherTypeIndex, etherType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        etherTypeIndex = 0;

        /*
            1.4. Call api with wrong etherType [0xFFFF + 1].
            Expected: NOT GT_OK.
        */
        etherType = 0xFFFF + 1;

        st = cpssDxChPtpEtherTypeSet(dev, etherTypeIndex, etherType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, dev);

        etherType = 0;
    }

    /* restore correct values */
    etherTypeIndex = 0;
    etherType = 0;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpEtherTypeSet(dev, etherTypeIndex, etherType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpEtherTypeSet(dev, etherTypeIndex, etherType);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpMessageTypeCmdGet
(
    IN  GT_U8                dev,
    IN  GT_U32               messageType,
    OUT CPSS_PACKET_CMD_ENT  *commandPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpMessageTypeCmdGet)
{
/*
    ITERATE_DEVICES(Lion and above)
    1.1. Call with messageType[0 / 5 / 15],
    Expected: GT_OK.
    1.2. Call api with wrong messageType [16].
    Expected: NOT GT_OK.
    1.3. Call api with wrong commandPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;

    GT_U8                dev;
    GT_U32               messageType = 0;
    CPSS_PACKET_CMD_ENT  command;
    UTF_PHYSICAL_PORT_NUM   portNum;
    GT_U32                  domainNum;

    /* new parameter for SIP5 */
    portNum   = 0;
    domainNum = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with messageType[0 / 5 / 15],
            Expected: GT_OK.
        */
        /* call with messageType[0] */
        messageType = 0;

        st = cpssDxChPtpMessageTypeCmdGet(
            dev, portNum, domainNum, messageType, &command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* call with messageType[5] */
        messageType = 5;

        st = cpssDxChPtpMessageTypeCmdGet(
            dev, portNum, domainNum, messageType, &command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* call with messageType[15] */
        messageType = 15;

        st = cpssDxChPtpMessageTypeCmdGet(
            dev, portNum, domainNum, messageType, &command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call api with wrong messageType [16].
            Expected: NOT GT_OK.
        */
        messageType = 16;

        st = cpssDxChPtpMessageTypeCmdGet(
            dev, portNum, domainNum, messageType, &command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        messageType = 0;

        /*
            1.3. Call api with wrong commandPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpMessageTypeCmdGet(
            dev, portNum, domainNum, messageType, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
    }

    /* restore correct values */
    messageType = 0;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpMessageTypeCmdGet(
            dev, portNum, domainNum, messageType, &command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpMessageTypeCmdGet(
        dev, portNum, domainNum, messageType, &command);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpMessageTypeCmdSet
(
    IN  GT_U8               dev,
    IN  GT_U32              messageType,
    IN  CPSS_PACKET_CMD_ENT command
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpMessageTypeCmdSet)
{
/*
    ITERATE_DEVICES(Lion and above)
    1.1. Call with messageType[0 / 3 / 5 / 10 / 15],
                   command[CPSS_PACKET_CMD_FORWARD_E /
                           CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                           CPSS_PACKET_CMD_TRAP_TO_CPU_E /
                           CPSS_PACKET_CMD_DROP_HARD_E /
                           CPSS_PACKET_CMD_DROP_SOFT_E],
    Expected: GT_OK.
    1.2. Call cpssDxChPtpMessageTypeCmdGet with the same parameters.
    Expected: GT_OK and the same values than was set.
    1.3. Call api with wrong messageType [16].
    Expected: NOT GT_OK.
    1.4. Call api with wrong command [wrong enum values].
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS st = GT_OK;

    GT_U8               dev;
    GT_U32              messageType = 0;
    CPSS_PACKET_CMD_ENT command = CPSS_PACKET_CMD_FORWARD_E;
    CPSS_PACKET_CMD_ENT commandGet = CPSS_PACKET_CMD_FORWARD_E;
    UTF_PHYSICAL_PORT_NUM   portNum;
    GT_U32                  domainNum;

    /* new parameter for SIP5 */
    portNum   = 0;
    domainNum = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with messageType[0 / 3 / 5 / 10 / 15],
                           command[CPSS_PACKET_CMD_FORWARD_E /
                                   CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                   CPSS_PACKET_CMD_TRAP_TO_CPU_E /
                                   CPSS_PACKET_CMD_DROP_HARD_E /
                                   CPSS_PACKET_CMD_DROP_SOFT_E],
            Expected: GT_OK.
        */

        /* call with messageType[0], command[CPSS_PACKET_CMD_FORWARD_E] */
        messageType = 0;
        command = CPSS_PACKET_CMD_FORWARD_E;

        st = cpssDxChPtpMessageTypeCmdSet(
            dev, portNum, domainNum, messageType, command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpMessageTypeCmdGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpMessageTypeCmdGet(
            dev, portNum, domainNum, messageType, &commandGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpMessageTypeCmdGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(command, commandGet,
                       "got another command then was set: %d", dev);

        /* call with messageType[3], command[CPSS_PACKET_CMD_MIRROR_TO_CPU_E] */
        messageType = 3;
        command = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;

        st = cpssDxChPtpMessageTypeCmdSet(
            dev, portNum, domainNum, messageType, command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpMessageTypeCmdGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpMessageTypeCmdGet(
            dev, portNum, domainNum, messageType, &commandGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpMessageTypeCmdGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(command, commandGet,
                       "got another command then was set: %d", dev);

        /* call with messageType[5], command[CPSS_PACKET_CMD_TRAP_TO_CPU_E] */
        messageType = 5;
        command = CPSS_PACKET_CMD_TRAP_TO_CPU_E;

        st = cpssDxChPtpMessageTypeCmdSet(
            dev, portNum, domainNum, messageType, command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpMessageTypeCmdGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpMessageTypeCmdGet(
            dev, portNum, domainNum, messageType, &commandGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpMessageTypeCmdGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(command, commandGet,
                       "got another command then was set: %d", dev);

        /* call with messageType[10], command[CPSS_PACKET_CMD_DROP_HARD_E] */
        messageType = 10;
        command = CPSS_PACKET_CMD_DROP_HARD_E;

        st = cpssDxChPtpMessageTypeCmdSet(
            dev, portNum, domainNum, messageType, command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpMessageTypeCmdGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpMessageTypeCmdGet(
            dev, portNum, domainNum, messageType, &commandGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpMessageTypeCmdGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(command, commandGet,
                       "got another command then was set: %d", dev);

        /* call with messageType[15], command[CPSS_PACKET_CMD_DROP_SOFT_E] */
        messageType = 15;
        command = CPSS_PACKET_CMD_DROP_SOFT_E;

        st = cpssDxChPtpMessageTypeCmdSet(
            dev, portNum, domainNum, messageType, command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpMessageTypeCmdGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpMessageTypeCmdGet(
            dev, portNum, domainNum, messageType, &commandGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpMessageTypeCmdGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(command, commandGet,
                       "got another command then was set: %d", dev);

        /*
            1.3. Call api with wrong messageType [16].
            Expected: NOT GT_OK.
        */
        messageType = 16;

        st = cpssDxChPtpMessageTypeCmdSet(
            dev, portNum, domainNum, messageType, command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        messageType = 0;

        /*
            1.4. Call api with wrong command [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpMessageTypeCmdSet
                            (dev, portNum, domainNum, messageType, command),
                            command);
    }

    /* restore correct values */
    messageType = 0;
    command = CPSS_PACKET_CMD_FORWARD_E;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpMessageTypeCmdSet(
            dev, portNum, domainNum, messageType, command);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpMessageTypeCmdSet(
        dev, portNum, domainNum, messageType, command);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTodCounterFunctionGet
(
    IN  GT_U8                               dev,
    IN  CPSS_PORT_DIRECTION_ENT             direction,
    OUT CPSS_DXCH_PTP_TOD_COUNTER_FUNC_ENT  *functionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTodCounterFunctionGet)
{
/*
    ITERATE_DEVICES(Lion and above)
    1.1. Call with direction[CPSS_PORT_DIRECTION_RX_E /
                             CPSS_PORT_DIRECTION_TX_E /
                             CPSS_PORT_DIRECTION_BOTH_E],
    Expected: GT_OK.
    1.2. Call with wrong direction[CPSS_PORT_DIRECTION_BOTH_E],
    Expected: NOT GT_OK.
    1.3. Call api with wrong direction [wrong enum values].
    Expected: GT_BAD_PARAM.
    1.4. Call api with wrong functionPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;

    GT_U8                               dev;
    CPSS_PORT_DIRECTION_ENT             direction = CPSS_PORT_DIRECTION_RX_E;
    CPSS_DXCH_PTP_TOD_COUNTER_FUNC_ENT  function;
    CPSS_DXCH_PTP_TAI_ID_STC   taiId =
        {CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E, CPSS_DXCH_PTP_TAI_NUMBER_0_E, 0};

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with direction[CPSS_PORT_DIRECTION_RX_E /
                                     CPSS_PORT_DIRECTION_TX_E /
                                     CPSS_PORT_DIRECTION_BOTH_E],
            Expected: GT_OK.
        */

        /* call with direction[CPSS_PORT_DIRECTION_RX_E] */
        direction = CPSS_PORT_DIRECTION_RX_E;

        st = cpssDxChPtpTodCounterFunctionGet(dev, direction, &taiId, &function);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* call with direction[CPSS_PORT_DIRECTION_TX_E] */
        direction = CPSS_PORT_DIRECTION_TX_E;

        st = cpssDxChPtpTodCounterFunctionGet(dev, direction, &taiId, &function);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call with wrong direction[CPSS_PORT_DIRECTION_BOTH_E],
            Expected: NOT GT_OK.
        */
        direction = CPSS_PORT_DIRECTION_BOTH_E;

        st = cpssDxChPtpTodCounterFunctionGet(dev, direction, &taiId, &function);
        if (GT_FALSE == prvUtfDeviceTestNotSupport(dev, UTF_CPSS_PP_E_ARCH_CNS))
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }
        else
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }

        direction = CPSS_PORT_DIRECTION_TX_E;

        /*
            1.3. Call api with wrong direction [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        if (GT_FALSE == prvUtfDeviceTestNotSupport(dev, UTF_CPSS_PP_E_ARCH_CNS))
        {
            if (! SINGLE_TAI_DEV_MAC(dev))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTodCounterFunctionGet
                                        (dev, direction, &taiId, &function),
                                        taiId.taiInstance);
                }
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTodCounterFunctionGet
                                    (dev, direction, &taiId, &function),
                                    taiId.taiNumber);
            }
        }
        else
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTodCounterFunctionGet
                                (dev, direction, &taiId, &function),
                                direction);
        }

        /*
            1.4. Call api with wrong functionPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTodCounterFunctionGet(dev, direction, &taiId, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
    }

    /* restore correct values */
    direction = CPSS_PORT_DIRECTION_RX_E;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTodCounterFunctionGet(dev, direction, &taiId, &function);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTodCounterFunctionGet(dev, direction, &taiId, &function);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTodCounterFunctionSet
(
    IN  GT_U8                              dev,
    IN  CPSS_PORT_DIRECTION_ENT            direction,
    IN  CPSS_DXCH_PTP_TOD_COUNTER_FUNC_ENT function
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTodCounterFunctionSet)
{
/*
    ITERATE_DEVICES(Lion and above)
    1.1. Call with direction[CPSS_PORT_DIRECTION_RX_E /
                             CPSS_PORT_DIRECTION_TX_E /
                             CPSS_PORT_DIRECTION_BOTH_E /
                             CPSS_PORT_DIRECTION_RX_E],
                   function[CPSS_DXCH_PTP_TOD_COUNTER_FUNC_UPDATE_E /
                            CPSS_DXCH_PTP_TOD_COUNTER_FUNC_INCREMENT_E /
                            CPSS_DXCH_PTP_TOD_COUNTER_FUNC_CAPTURE_E /
                            CPSS_DXCH_PTP_TOD_COUNTER_FUNC_GENERATE_E],
    Expected: GT_OK.
    1.2. Call cpssDxChPtpTodCounterFunctionGet with the same parameters.
    Expected: GT_OK and the same values than was set.
    1.3. Call api with wrong direction [wrong enum values].
    Expected: GT_BAD_PARAM.
    1.4. Call api with wrong function [wrong enum values].
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS st = GT_OK;

    GT_U8                              dev;
    CPSS_PORT_DIRECTION_ENT            direction = CPSS_PORT_DIRECTION_RX_E;
    CPSS_DXCH_PTP_TOD_COUNTER_FUNC_ENT function = CPSS_DXCH_PTP_TOD_COUNTER_FUNC_UPDATE_E;
    CPSS_DXCH_PTP_TOD_COUNTER_FUNC_ENT functionGet = CPSS_DXCH_PTP_TOD_COUNTER_FUNC_UPDATE_E;
    CPSS_DXCH_PTP_TAI_ID_STC   taiId =
        {CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E, CPSS_DXCH_PTP_TAI_NUMBER_0_E, 0};

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with direction[CPSS_PORT_DIRECTION_RX_E /
                                     CPSS_PORT_DIRECTION_TX_E /
                                     CPSS_PORT_DIRECTION_BOTH_E /
                                     CPSS_PORT_DIRECTION_RX_E],
                           function[CPSS_DXCH_PTP_TOD_COUNTER_FUNC_UPDATE_E /
                                    CPSS_DXCH_PTP_TOD_COUNTER_FUNC_INCREMENT_E /
                                    CPSS_DXCH_PTP_TOD_COUNTER_FUNC_CAPTURE_E /
                                    CPSS_DXCH_PTP_TOD_COUNTER_FUNC_GENERATE_E],
            Expected: GT_OK.
        */

        /* call with direction[CPSS_PORT_DIRECTION_RX_E],
                     function[CPSS_DXCH_PTP_TOD_COUNTER_FUNC_UPDATE_E] */
        direction = CPSS_PORT_DIRECTION_RX_E;
        function = CPSS_DXCH_PTP_TOD_COUNTER_FUNC_UPDATE_E;

        st = cpssDxChPtpTodCounterFunctionSet(dev, direction, &taiId, function);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpTodCounterFunctionGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpTodCounterFunctionGet(dev, direction, &taiId, &functionGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpTodCounterFunctionGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(function, functionGet,
                       "got another function then was set: %d", dev);

        /* call with direction[CPSS_PORT_DIRECTION_TX_E],
                     function[CPSS_DXCH_PTP_TOD_COUNTER_FUNC_INCREMENT_E] */
        direction = CPSS_PORT_DIRECTION_TX_E;
        function = CPSS_DXCH_PTP_TOD_COUNTER_FUNC_INCREMENT_E;

        st = cpssDxChPtpTodCounterFunctionSet(dev, direction, &taiId, function);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpTodCounterFunctionGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpTodCounterFunctionGet(dev, direction, &taiId, &functionGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpTodCounterFunctionGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(function, functionGet,
                       "got another function then was set: %d", dev);

        /* call with direction[CPSS_PORT_DIRECTION_BOTH_E],
                     function[CPSS_DXCH_PTP_TOD_COUNTER_FUNC_CAPTURE_E] */
        direction = CPSS_PORT_DIRECTION_BOTH_E;
        function = CPSS_DXCH_PTP_TOD_COUNTER_FUNC_CAPTURE_E;

        st = cpssDxChPtpTodCounterFunctionSet(dev, direction, &taiId, function);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpTodCounterFunctionGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        direction = CPSS_PORT_DIRECTION_RX_E;
        st = cpssDxChPtpTodCounterFunctionGet(dev, direction, &taiId, &functionGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpTodCounterFunctionGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(function, functionGet,
                       "got another function then was set: %d", dev);

        direction = CPSS_PORT_DIRECTION_TX_E;
        st = cpssDxChPtpTodCounterFunctionGet(dev, direction, &taiId, &functionGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpTodCounterFunctionGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(function, functionGet,
                       "got another function then was set: %d", dev);

        /* call with direction[CPSS_PORT_DIRECTION_RX_E],
                     function[CPSS_DXCH_PTP_TOD_COUNTER_FUNC_GENERATE_E] */
        direction = CPSS_PORT_DIRECTION_RX_E;
        function = CPSS_DXCH_PTP_TOD_COUNTER_FUNC_GENERATE_E;

        st = cpssDxChPtpTodCounterFunctionSet(dev, direction, &taiId, function);
        if (GT_FALSE == prvUtfDeviceTestNotSupport(dev, UTF_CPSS_PP_E_ARCH_CNS))
        {
            /* generate function is old styled */
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }
        else
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }

        function = CPSS_DXCH_PTP_TOD_COUNTER_FUNC_CAPTURE_E;
        st = cpssDxChPtpTodCounterFunctionSet(dev, direction, &taiId, function);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpTodCounterFunctionGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpTodCounterFunctionGet(dev, direction, &taiId, &functionGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpTodCounterFunctionGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(function, functionGet,
                       "got another function then was set: %d", dev);

        /*
            1.3. Call api with wrong direction [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        if (GT_FALSE == prvUtfDeviceTestNotSupport(dev, UTF_CPSS_PP_E_ARCH_CNS))
        {
            if (! SINGLE_TAI_DEV_MAC(dev))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTodCounterFunctionSet
                                        (dev, direction, &taiId, function),
                                        taiId.taiInstance);
                }
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTodCounterFunctionSet
                                    (dev, direction, &taiId, function),
                                    taiId.taiNumber);
            }
        }
        else
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTodCounterFunctionSet
                                (dev, direction, &taiId, function),
                                direction);
        }

        /*
            1.4. Call api with wrong function [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTodCounterFunctionSet
                            (dev, direction, &taiId, function),
                            function);
    }

    /* restore correct values */
    direction = CPSS_PORT_DIRECTION_RX_E;
    function = CPSS_DXCH_PTP_TOD_COUNTER_FUNC_UPDATE_E;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTodCounterFunctionSet(dev, direction, &taiId, function);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTodCounterFunctionSet(dev, direction, &taiId, function);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTodCounterFunctionTriggerSet
(
    IN  GT_U8                   dev,
    IN  CPSS_PORT_DIRECTION_ENT direction
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTodCounterFunctionTriggerSet)
{
/*
    ITERATE_DEVICES(Lion and above)
    1.1. Call with direction[CPSS_PORT_DIRECTION_RX_E /
                             CPSS_PORT_DIRECTION_TX_E /
                             CPSS_PORT_DIRECTION_BOTH_E],
    Expected: GT_OK.
    1.2. Call cpssDxChPtpTodCounterFunctionTriggerGet
           with the same parameters.
    Expected: GT_OK and the same values than was set.
    1.3. Call api with wrong direction [wrong enum values].
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS st = GT_OK;

    GT_U8                   dev;
    CPSS_PORT_DIRECTION_ENT direction = CPSS_PORT_DIRECTION_RX_E;
    CPSS_DXCH_PTP_TAI_ID_STC   taiId =
        {CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E, CPSS_DXCH_PTP_TAI_NUMBER_0_E, 0};

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with direction[CPSS_PORT_DIRECTION_RX_E /
                                     CPSS_PORT_DIRECTION_TX_E /
                                     CPSS_PORT_DIRECTION_BOTH_E],
            Expected: GT_OK.
        */

        /* call with direction[CPSS_PORT_DIRECTION_RX_E] */
        direction = CPSS_PORT_DIRECTION_RX_E;

        st = cpssDxChPtpTodCounterFunctionTriggerSet(dev, direction, &taiId);
        if (st != GT_BAD_STATE)
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }




        /* call with direction[CPSS_PORT_DIRECTION_TX_E] */
        direction = CPSS_PORT_DIRECTION_TX_E;

        st = cpssDxChPtpTodCounterFunctionTriggerSet(dev, direction, &taiId);
        if (st != GT_BAD_STATE)
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }



        /* call with direction[CPSS_PORT_DIRECTION_BOTH_E] */
        direction = CPSS_PORT_DIRECTION_BOTH_E;

        st = cpssDxChPtpTodCounterFunctionTriggerSet(dev, direction, &taiId);
        if (st != GT_BAD_STATE)
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }


        /*
            1.3. Call api with wrong direction [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        if (GT_FALSE == prvUtfDeviceTestNotSupport(dev, UTF_CPSS_PP_E_ARCH_CNS))
        {
            if (! SINGLE_TAI_DEV_MAC(dev))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTodCounterFunctionTriggerSet
                                        (dev, direction, &taiId),
                                        taiId.taiInstance);
                }
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTodCounterFunctionTriggerSet
                                    (dev, direction, &taiId),
                                    taiId.taiNumber);
            }
        }
        else
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTodCounterFunctionTriggerSet
                                (dev, direction, &taiId),
                                direction);
        }
    }

    /* restore correct values */
    direction = CPSS_PORT_DIRECTION_RX_E;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTodCounterFunctionTriggerSet(dev, direction, &taiId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTodCounterFunctionTriggerSet(dev, direction, &taiId);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTodCounterFunctionTriggerStatusGet
(
    IN GT_U8                       devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC   *taiIdPtr,
    OUT GT_BOOL                    *finishPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTodCounterFunctionTriggerStatusGet)
{
/*
    ITERATE_DEVICES(SIP5 and above)

*/
    GT_STATUS st = GT_OK;

    GT_U8                    dev;
    GT_BOOL                  finish;
    CPSS_DXCH_PTP_TAI_ID_STC   taiId =
        {CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E, CPSS_DXCH_PTP_TAI_NUMBER_0_E, 0};

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {

        st = cpssDxChPtpTodCounterFunctionTriggerStatusGet(dev, &taiId, &finish);
        if (st != GT_BAD_STATE)
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }

        /*
            Call api with wrong finishPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTodCounterFunctionTriggerStatusGet(dev, &taiId, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
    }


    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTodCounterFunctionTriggerStatusGet(dev, &taiId, &finish);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTodCounterFunctionTriggerStatusGet(dev, &taiId, &finish);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpUdpDestPortsGet
(
    IN  GT_U8   dev,
    IN  GT_U32  udpPortIndex,
    OUT GT_U32  *udpPortNumPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpUdpDestPortsGet)
{
/*
    ITERATE_DEVICES(Lion and above)
    1.1. Call with udpPortIndex[0 / 1],
    Expected: GT_OK.
    1.2. Call api with wrong udpPortIndex [2].
    Expected: NOT GT_OK.
    1.3. Call api with wrong udpPortNumPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;

    GT_U8   dev;
    GT_U32  udpPortIndex = 0;
    GT_U32  udpPortNum;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with udpPortIndex[0 / 1],
            Expected: GT_OK.
        */
        /* call with udpPortIndex[0] */
        udpPortIndex = 0;

        st = cpssDxChPtpUdpDestPortsGet(dev, udpPortIndex, &udpPortNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* call with udpPortIndex[1] */
        udpPortIndex = 1;

        st = cpssDxChPtpUdpDestPortsGet(dev, udpPortIndex, &udpPortNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call api with wrong udpPortIndex [2].
            Expected: NOT GT_OK.
        */
        udpPortIndex = 2;

        st = cpssDxChPtpUdpDestPortsGet(dev, udpPortIndex, &udpPortNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        udpPortIndex = 0;

        /*
            1.3. Call api with wrong udpPortNumPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpUdpDestPortsGet(dev, udpPortIndex, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
    }

    /* restore correct values */
    udpPortIndex = 0;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpUdpDestPortsGet(dev, udpPortIndex, &udpPortNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpUdpDestPortsGet(dev, udpPortIndex, &udpPortNum);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpUdpDestPortsSet
(
    IN  GT_U8  dev,
    IN  GT_U32 udpPortIndex,
    IN  GT_U32 udpPortNum
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpUdpDestPortsSet)
{
/*
    ITERATE_DEVICES(Lion and above)
    1.1. Call with udpPortIndex[0 / 1], udpPortNum[0 / 0xFFFF],
    Expected: GT_OK.
    1.2. Call cpssDxChPtpUdpDestPortsGet with the same parameters.
    Expected: GT_OK and the same values than was set.
    1.3. Call api with wrong udpPortIndex [2].
    Expected: NOT GT_OK.
    1.4. Call api with wrong udpPortNum [0xFFFF + 1].
    Expected: NOT GT_OK.
*/
    GT_STATUS st = GT_OK;

    GT_U8  dev;
    GT_U32 udpPortIndex = 0;
    GT_U32 udpPortNum = 0;
    GT_U32 udpPortNumGet = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with udpPortIndex[0 / 1], udpPortNum[0 / 0xFFFF],
            Expected: GT_OK.
        */
        /* call with udpPortIndex[0], udpPortNum[0] */
        udpPortIndex = 0;
        udpPortNum = 0;

        st = cpssDxChPtpUdpDestPortsSet(dev, udpPortIndex, udpPortNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpUdpDestPortsGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpUdpDestPortsGet(dev, udpPortIndex, &udpPortNumGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpUdpDestPortsGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(udpPortNum, udpPortNumGet,
                       "got another udpPortNum then was set: %d", dev);

        /* call with udpPortIndex[1], udpPortNum[0xFFFF] */
        udpPortIndex = 1;
        udpPortNum = 0xFFFF;

        st = cpssDxChPtpUdpDestPortsSet(dev, udpPortIndex, udpPortNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpUdpDestPortsGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpUdpDestPortsGet(dev, udpPortIndex, &udpPortNumGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpUdpDestPortsGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(udpPortNum, udpPortNumGet,
                       "got another udpPortNum then was set: %d", dev);


        /* call with udpPortIndex[0], udpPortNum[0x8F07] */
        udpPortIndex = 0;
        udpPortNum = 0x8F07;

        st = cpssDxChPtpUdpDestPortsSet(dev, udpPortIndex, udpPortNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpUdpDestPortsGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpUdpDestPortsGet(dev, udpPortIndex, &udpPortNumGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpUdpDestPortsGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(udpPortNum, udpPortNumGet,
                       "got another udpPortNum then was set: %d", dev);

        /* call with udpPortIndex[1], udpPortNum[0xAA55] */
        udpPortIndex = 1;
        udpPortNum = 0xAA55;

        st = cpssDxChPtpUdpDestPortsSet(dev, udpPortIndex, udpPortNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpUdpDestPortsGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpUdpDestPortsGet(dev, udpPortIndex, &udpPortNumGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPtpUdpDestPortsGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(udpPortNum, udpPortNumGet,
                       "got another udpPortNum then was set: %d", dev);


        /*
            1.3. Call api with wrong udpPortIndex [2].
            Expected: NOT GT_OK.
        */
        udpPortIndex = 2;

        st = cpssDxChPtpUdpDestPortsSet(dev, udpPortIndex, udpPortNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        udpPortIndex = 0;

        /*
            1.4. Call api with wrong udpPortNum [0xFFFF + 1].
            Expected: NOT GT_OK.
        */
        udpPortNum = 0xFFFF + 1;

        st = cpssDxChPtpUdpDestPortsSet(dev, udpPortIndex, udpPortNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, dev);

        udpPortNum = 0;
    }

    /* restore correct values */
    udpPortIndex = 0;
    udpPortNum = 0;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_LION2_E | UTF_XCAT3_E | UTF_AC5_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpUdpDestPortsSet(dev, udpPortIndex, udpPortNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpUdpDestPortsSet(dev, udpPortIndex, udpPortNum);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
 GT_STATUS cpssDxChPtpTaiCaptureOverrideEnableGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    OUT GT_BOOL                                 *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiCaptureOverrideEnableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
    Expected: GT_OK.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
    Expected: GT_OK.
    1.3 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.5 Call with invalid enabledPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    GT_BOOL                      enable  =  GT_FALSE;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E |  UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                    &enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                    &enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                        &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                        &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiCaptureOverrideEnableGet
                                    (devNum, &taiId, &enable),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiCaptureOverrideEnableGet
                                (devNum, &taiId, &enable),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid enabledPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;
    enable  = GT_TRUE;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E |  UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiCaptureOverrideEnableSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    IN  GT_BOOL                                 enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiCaptureOverrideEnableSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E           /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid enabledPtr [NULL].
        Expected: GT_BAD_PTR.
    */
        GT_STATUS                    st      =  GT_OK;
        GT_U8                        devNum  =  0;
        CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
        GT_BOOL                      apEnable     =  GT_FALSE;
        GT_BOOL                      apEnableGet  =  GT_FALSE;
        UTF_PHYSICAL_PORT_NUM        port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;

        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E |  UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                Expected: GT_OK.
            */
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiCaptureOverrideEnableSet(devNum, &taiId,
                                                        apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                        &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiCaptureOverrideEnableSet(devNum, &taiId,
                                                        apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                        &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiCaptureOverrideEnableSet(devNum, &taiId,
                                                        apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                        &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E             /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E             /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
            Expected: GT_OK
            */
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                    Expected: GT_OK
                */
                taiId.portNum = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiCaptureOverrideEnableSet(devNum, &taiId,
                                                            apEnable);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);

                /*
                    1.3.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                            &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                    Expected: GT_OK
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiCaptureOverrideEnableSet(devNum, &taiId,
                                                            apEnable);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                            &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                    Expected: GT_OK
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiCaptureOverrideEnableSet(devNum, &taiId,
                                                            apEnable);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                            &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiCaptureOverrideEnableSet(devNum, &taiId,
                                                        apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                        &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;

            st = cpssDxChPtpTaiCaptureOverrideEnableSet(devNum, &taiId,
                                                        apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                        &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiCaptureOverrideEnableSet(devNum, &taiId,
                                                        apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiCaptureOverrideEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiCaptureOverrideEnableGet(devNum, &taiId,
                                                        &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiCaptureOverrideEnableSet
                                        (devNum, &taiId, apEnable),
                                        taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiCaptureOverrideEnableSet
                                    (devNum, &taiId, apEnable),
                                    taiId.taiNumber);
            }
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        apEnable  = GT_TRUE;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiCaptureOverrideEnableSet
                                (devNum, &taiId, apEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiCaptureOverrideEnableSet(devNum, &taiId, apEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockCycleGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    OUT GT_U32                                *secondsPtr,
    OUT GT_U32                                *nanoSecondsPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockCycleGet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid secondPtr [NULL].
        Expected: GT_BAD_PTR.
        1.5 Call with invalid nanoSecondPtr [NULL].
        Expected: GT_BAD_PTR.
    */

    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    OUT GT_U32                   seconds;
    OUT GT_U32                   nanoSeconds;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockCycleGet(devNum,
                                         &taiId,
                                         &seconds,
                                         &nanoSeconds);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                    st,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockCycleGet(devNum,
                                         &taiId,
                                         &seconds,
                                         &nanoSeconds);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                    st,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiClockCycleGet(devNum,
                                             &taiId,
                                             &seconds,
                                             &nanoSeconds);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiClockCycleGet(devNum,
                                             &taiId,
                                             &seconds,
                                             &nanoSeconds);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockCycleGet
                                    (devNum,
                                     &taiId,
                                     &seconds,
                                     &nanoSeconds),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockCycleGet
                                (devNum,
                                 &taiId,
                                 &seconds,
                                 &nanoSeconds),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid seconsPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockCycleGet(devNum,
                                 &taiId,
                                 NULL,
                                 &nanoSeconds);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);

        /*
           1.6 Call with invalid nanoSeconsPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockCycleGet(devNum,
                                 &taiId,
                                 &seconds,
                                 NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiClockCycleGet(devNum,
                                         &taiId,
                                         &seconds,
                                         &nanoSeconds);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiClockCycleGet(devNum,
                                     &taiId,
                                     &seconds,
                                     &nanoSeconds);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockCycleSet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    IN  GT_U32                                seconds,
    IN  GT_U32                                nanoSeconds
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockCycleSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E           /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiClockCycleGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiClockCycleGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiClockCycleGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid enabledPtr [NULL].
        Expected: GT_BAD_PTR.
    */
        GT_STATUS                    st      =  GT_OK;
        GT_U8                        devNum  =  0;
        CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
        GT_U32                       apSecond;
        GT_U32                       apSecondGet;
        GT_U32                       apNanoSecond;
        GT_U32                       apNanoSecondGet;
        UTF_PHYSICAL_PORT_NUM        port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;

        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                Expected: GT_OK.
            */
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            apSecond = 0;
            apNanoSecond = 0;
            st = cpssDxChPtpTaiClockCycleSet(devNum,
                                             &taiId,
                                             apSecond,
                                             apNanoSecond);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiClockCycleGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiClockCycleGet(devNum,
                                             &taiId,
                                             &apSecondGet,
                                             &apNanoSecondGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apSecond, apSecondGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apNanoSecond, apNanoSecondGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;
            apSecond = 0;
            apNanoSecond = 0;
            st = cpssDxChPtpTaiClockCycleSet(devNum,
                                             &taiId,
                                             apSecond,
                                             apNanoSecond);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiClockCycleGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiClockCycleGet(devNum,
                                             &taiId,
                                             &apSecondGet,
                                             &apNanoSecondGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apSecond, apSecondGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apNanoSecond, apNanoSecondGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);


           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            apSecond = 0;
            apNanoSecond = 0;
            st = cpssDxChPtpTaiClockCycleSet(devNum,
                                             &taiId,
                                             apSecond,
                                             apNanoSecond);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiClockCycleGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiClockCycleGet(devNum,
                                             &taiId,
                                             &apSecondGet,
                                             &apNanoSecondGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apSecond, apSecondGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apNanoSecond, apNanoSecondGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);


            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E             /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E             /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
            Expected: GT_OK.
            */
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                */
                taiId.portNum = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                apSecond = 0;
                apNanoSecond = 0;
                st = cpssDxChPtpTaiClockCycleSet(devNum,
                                                 &taiId,
                                                 apSecond,
                                                 apNanoSecond);
                /*
                    1.3.2. Call cpssDxChPtpTaiClockCycleGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiClockCycleGet(devNum,
                                                 &taiId,
                                                 &apSecondGet,
                                                 &apNanoSecondGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apSecond, apSecondGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apNanoSecond, apNanoSecondGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                apSecond = 0;
                apNanoSecond = 0;
                st = cpssDxChPtpTaiClockCycleSet(devNum,
                                             &taiId,
                                             apSecond,
                                             apNanoSecond);
                /*
                    1.3.2. Call cpssDxChPtpTaiClockCycleGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiClockCycleGet(devNum,
                                                 &taiId,
                                                 &apSecondGet,
                                                 &apNanoSecondGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apSecond, apSecondGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apNanoSecond,
                                            apNanoSecondGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                apSecond = 0;
                apNanoSecond = 0;
                st = cpssDxChPtpTaiClockCycleSet(devNum,
                                                 &taiId,
                                                 apSecond,
                                                 apNanoSecond);
                /*
                    1.3.2. Call cpssDxChPtpTaiClockCycleGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiClockCycleGet(devNum,
                                                 &taiId,
                                                 &apSecondGet,
                                                 &apNanoSecondGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apSecond, apSecondGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apNanoSecond, apNanoSecondGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            apSecond = 0;
            apNanoSecond = 0;
            st = cpssDxChPtpTaiClockCycleSet(devNum,
                                             &taiId,
                                             apSecond,
                                             apNanoSecond);
            /*
                1.1.2. Call cpssDxChPtpTaiClockCycleGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiClockCycleGet(devNum,
                                             &taiId,
                                             &apSecondGet,
                                             &apNanoSecondGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apSecond, apSecondGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apNanoSecond, apNanoSecondGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;
            apSecond = 0;
            apNanoSecond = 0;
            st = cpssDxChPtpTaiClockCycleSet(devNum,
                                             &taiId,
                                             apSecond,
                                             apNanoSecond);
            /*
                1.1.2. Call cpssDxChPtpTaiClockCycleGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiClockCycleGet(devNum,
                                             &taiId,
                                             &apSecondGet,
                                             &apNanoSecondGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apSecond, apSecondGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apNanoSecond, apNanoSecondGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            apSecond = 0;
            apNanoSecond = 0;
            st = cpssDxChPtpTaiClockCycleSet(devNum,
                                             &taiId,
                                             apSecond,
                                             apNanoSecond);
            /*
                1.1.2. Call cpssDxChPtpTaiClockCycleGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiClockCycleGet(devNum,
                                             &taiId,
                                             &apSecondGet,
                                             &apNanoSecondGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apSecond, apSecondGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apNanoSecond, apNanoSecondGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockCycleSet
                                        (devNum,
                                         &taiId,
                                         apSecond,
                                         apNanoSecond),
                                        taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockCycleSet
                                    (devNum,
                                    &taiId,
                                    apSecond,
                                    apNanoSecond),
                                    taiId.taiNumber);
            }
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        apSecond = 0;
        apNanoSecond = 0;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiClockCycleSet(devNum,
                                             &taiId,
                                             apSecond,
                                             apNanoSecond);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiClockCycleSet(devNum,
                                         &taiId,
                                         apSecond,
                                         apNanoSecond);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockModeGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    OUT CPSS_DXCH_PTP_TAI_CLOCK_MODE_ENT        *clockModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockModeGet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid clockModePtr [NULL].
        Expected: GT_BAD_PTR.
    */

    GT_STATUS                            st      =  GT_OK;
    GT_U8                                devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC             taiId   =  {0, 0, 0};
    UTF_PHYSICAL_PORT_NUM                port;
    CPSS_DXCH_PTP_TAI_CLOCK_MODE_ENT     clockMode;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiClockModeGet(devNum,
                                             &taiId,
                                             &clockMode);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiClockModeGet(devNum,
                                             &taiId,
                                             &clockMode);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockModeGet
                                    (devNum,
                                     &taiId,
                                     &clockMode),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockModeGet
                                (devNum,
                                 &taiId,
                                 &clockMode),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid clockModePtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                 &taiId,
                                 NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiClockModeGet(devNum,
                                     &taiId,
                                     &clockMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockModeSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    IN  CPSS_DXCH_PTP_TAI_CLOCK_MODE_ENT        clockMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockModeSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                clockMode [CPSS_DXCH_PTP_TAI_CLOCK_MODE_DISABLED_E /
                            CPSS_DXCH_PTP_TAI_CLOCK_MODE_INPUT_E   /]
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiClockModeGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
                clockMode [CPSS_DXCH_PTP_TAI_CLOCK_MODE_DISABLED_E /
                           CPSS_DXCH_PTP_TAI_CLOCK_MODE_INPUT_E    /]
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiClockModeGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
                clockMode [CPSS_DXCH_PTP_TAI_CLOCK_MODE_DISABLED_E /
                           CPSS_DXCH_PTP_TAI_CLOCK_MODE_INPUT_E    /]
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiClockModeGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid enabledPtr [NULL].
        Expected: GT_BAD_PTR.
    */
    GT_STATUS                        st      =  GT_OK;
    GT_U8                            devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC         taiId   =  {0, 0, 0};
    CPSS_DXCH_PTP_TAI_CLOCK_MODE_ENT clockMode;
    CPSS_DXCH_PTP_TAI_CLOCK_MODE_ENT clockModeGet;
    UTF_PHYSICAL_PORT_NUM            port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      0
                   }
            clockMode [CPSS_DXCH_PTP_TAI_CLOCK_MODE_DISABLED_E /
                       CPSS_DXCH_PTP_TAI_CLOCK_MODE_INPUT_E    /]
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        /*
            clockMode    [CPSS_DXCH_PTP_TAI_CLOCK_MODE_DISABLED_E]
        */
        clockMode         = CPSS_DXCH_PTP_TAI_CLOCK_MODE_DISABLED_E;
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        /*
            clockMode    [CPSS_DXCH_PTP_TAI_CLOCK_MODE_INPUT_E]
        */
        clockMode         = CPSS_DXCH_PTP_TAI_CLOCK_MODE_INPUT_E;
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);


        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        clockMode [CPSS_DXCH_PTP_TAI_CLOCK_MODE_DISABLED_E /
                   CPSS_DXCH_PTP_TAI_CLOCK_MODE_INPUT_E    /]
        Expected: GT_OK.
        */
        /*
            clockMode    [CPSS_DXCH_PTP_TAI_CLOCK_MODE_DISABLED_E]
        */
        clockMode         = CPSS_DXCH_PTP_TAI_CLOCK_MODE_DISABLED_E;
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiClockModeSet(devNum,
                                             &taiId,
                                             clockMode);
            /*
                1.3.2. Call cpssDxChPtpTaiClockModeGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiClockModeGet(devNum,
                                             &taiId,
                                             &clockModeGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiClockModeSet(devNum,
                                             &taiId,
                                             clockMode);
            /*
                1.3.2. Call cpssDxChPtpTaiClockModeGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiClockModeGet(devNum,
                                             &taiId,
                                             &clockModeGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            st = cpssDxChPtpTaiClockModeSet(devNum,
                                             &taiId,
                                             clockMode);
            /*
                1.3.2. Call cpssDxChPtpTaiClockModeGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiClockModeGet(devNum,
                                             &taiId,
                                             &clockModeGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode,
                                        clockModeGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
        }

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                    st,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode,
                                    clockModeGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                    st,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode,
                                    clockModeGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                    st,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode,
                                    clockModeGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            clockMode    [CPSS_DXCH_PTP_TAI_CLOCK_MODE_INPUT_E]
        */
        clockMode         = CPSS_DXCH_PTP_TAI_CLOCK_MODE_INPUT_E;
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiClockModeSet(devNum,
                                             &taiId,
                                             clockMode);
            /*
                1.3.2. Call cpssDxChPtpTaiClockModeGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiClockModeGet(devNum,
                                             &taiId,
                                             &clockModeGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode,
                                        clockModeGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiClockModeSet(devNum,
                                             &taiId,
                                             clockMode);
            /*
                1.3.2. Call cpssDxChPtpTaiClockModeGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiClockModeGet(devNum,
                                             &taiId,
                                             &clockModeGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode,
                                        clockModeGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            st = cpssDxChPtpTaiClockModeSet(devNum,
                                             &taiId,
                                             clockMode);
            /*
                1.3.2. Call cpssDxChPtpTaiClockModeGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiClockModeGet(devNum,
                                             &taiId,
                                             &clockModeGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
        }

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                    st,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode,
                                    clockModeGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                    st,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode,
                                    clockModeGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiClockModeSet(devNum,
                                             &taiId,
                                             clockMode);
            /*
                1.3.2. Call cpssDxChPtpTaiClockModeGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiClockModeGet(devNum,
                                             &taiId,
                                             &clockModeGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiClockModeSet(devNum,
                                             &taiId,
                                             clockMode);
            /*
                1.3.2. Call cpssDxChPtpTaiClockModeGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiClockModeGet(devNum,
                                             &taiId,
                                             &clockModeGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            st = cpssDxChPtpTaiClockModeSet(devNum,
                                             &taiId,
                                             clockMode);

            /*
                1.3.2. Call cpssDxChPtpTaiClockModeGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiClockModeGet(devNum,
                                             &taiId,
                                             &clockModeGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
        }

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);

        /*
            1.1.2. Call cpssDxChPtpTaiClockModeGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        st = cpssDxChPtpTaiClockModeGet(devNum,
                                         &taiId,
                                         &clockModeGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(clockMode, clockModeGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockModeSet
                                    (devNum,
                                     &taiId,
                                     clockMode),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockModeSet
                                (devNum,
                                &taiId,
                                clockMode),
                                taiId.taiNumber);
        }
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;
    clockMode = CPSS_DXCH_PTP_TAI_CLOCK_MODE_DISABLED_E;

    /* 2.For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiClockModeSet(devNum,
                                         &taiId,
                                         clockMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiClockModeSet(devNum,
                                     &taiId,
                                     clockMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiExternalPulseWidthGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    OUT GT_U32                                  *extPulseWidthPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiExternalPulseWidthGet)
{
   /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid extPulseWidthPtr [NULL].
        Expected: GT_BAD_PTR.
    */

    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    OUT GT_U32                   extPulseWidth;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                 &taiId,
                                                 &extPulseWidth);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                 &taiId,
                                                 &extPulseWidth);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                Expected: GT_OK.
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                     &taiId,
                                                     &extPulseWidth);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                     &taiId,
                                                     &extPulseWidth);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiExternalPulseWidthGet
                                    (devNum,
                                     &taiId,
                                     &extPulseWidth),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiExternalPulseWidthGet
                                (devNum,
                                 &taiId,
                                 &extPulseWidth),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid nanoSeconsPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                 &taiId,
                                                 NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                 &taiId,
                                                 &extPulseWidth);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                             &taiId,
                                             &extPulseWidth);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiExternalPulseWidthSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    IN  GT_U32                                  extPulseWidth
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiExternalPulseWidthSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid enabledPtr [NULL].
        Expected: GT_BAD_PTR.
    */
        GT_STATUS                    st      =  GT_OK;
        GT_U8                        devNum  =  0;
        CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
        GT_U32                       extPulseWidth;
        GT_U32                       extPulseWidthGet;
        UTF_PHYSICAL_PORT_NUM        port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;

        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                Expected: GT_OK.
            */
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            extPulseWidth = 0;
            st = cpssDxChPtpTaiExternalPulseWidthSet(devNum,
                                                     &taiId,
                                                     extPulseWidth);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                     &taiId,
                                                     &extPulseWidthGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(extPulseWidth, extPulseWidthGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;
            extPulseWidth = 0;
            st = cpssDxChPtpTaiExternalPulseWidthSet(devNum,
                                                     &taiId,
                                                     extPulseWidth);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                     &taiId,
                                                     &extPulseWidthGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(extPulseWidth, extPulseWidthGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            extPulseWidth = 0;
            st = cpssDxChPtpTaiExternalPulseWidthSet(devNum,
                                                     &taiId,
                                                     extPulseWidth);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                     &taiId,
                                                     &extPulseWidthGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(extPulseWidth, extPulseWidthGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
            Expected: GT_OK.
            */
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                */
                taiId.portNum = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                extPulseWidth = 0;
                st = cpssDxChPtpTaiExternalPulseWidthSet(devNum,
                                                         &taiId,
                                                         extPulseWidth);

                /*
                    1.3.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                         &taiId,
                                                         &extPulseWidthGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(extPulseWidth, extPulseWidthGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                extPulseWidth = 0;
                st = cpssDxChPtpTaiExternalPulseWidthSet(devNum,
                                                         &taiId,
                                                         extPulseWidth);

                /*
                    1.3.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                         &taiId,
                                                         &extPulseWidthGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(extPulseWidth, extPulseWidthGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                extPulseWidth = 0;
                st = cpssDxChPtpTaiExternalPulseWidthSet(devNum,
                                                         &taiId,
                                                         extPulseWidth);

                /*
                    1.3.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                         &taiId,
                                                         &extPulseWidthGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(extPulseWidth, extPulseWidthGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum     = 0;
            extPulseWidth     = 0;
            st = cpssDxChPtpTaiExternalPulseWidthSet(devNum,
                                                     &taiId,
                                                     extPulseWidth);
            /*
                1.1.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                     &taiId,
                                                     &extPulseWidthGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(extPulseWidth, extPulseWidthGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;
            extPulseWidth = 0;
            st = cpssDxChPtpTaiExternalPulseWidthSet(devNum,
                                                     &taiId,
                                                     extPulseWidth);
            /*
                1.1.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                     &taiId,
                                                     &extPulseWidthGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(extPulseWidth,
                                        extPulseWidthGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;
            extPulseWidth    = 0;
            st = cpssDxChPtpTaiExternalPulseWidthSet(devNum,
                                                     &taiId,
                                                     extPulseWidth);
            /*
                1.1.2. Call cpssDxChPtpTaiExternalPulseWidthGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiExternalPulseWidthGet(devNum,
                                                     &taiId,
                                                     &extPulseWidthGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(extPulseWidth,
                                        extPulseWidthGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiExternalPulseWidthSet
                                        (devNum,
                                         &taiId,
                                         extPulseWidth),
                                        taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiExternalPulseWidthSet
                                    (devNum,
                                    &taiId,
                                    extPulseWidth),
                                    taiId.taiNumber);
            }
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        extPulseWidth = 0;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiExternalPulseWidthSet(devNum,
                                                     &taiId,
                                                     extPulseWidth);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiExternalPulseWidthSet(devNum,
                                                 &taiId,
                                                 extPulseWidth);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*
GT_STATUS cpssDxChPtpTaiFractionalNanosecondDriftGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    OUT GT_32                                 *fracNanoSecondPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiFractionalNanosecondDriftGet)
{
   /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid fracNanoSecondPtr [NULL].
        Expected: GT_BAD_PTR.
    */

    GT_STATUS                st      =  GT_OK;
    GT_U8                    devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC taiId   =  {0, 0, 0};
    GT_32                    fracNanoSecond;
    UTF_PHYSICAL_PORT_NUM    port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, (UTF_BOBCAT2_E | UTF_CAELUM_E));

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiFractionalNanosecondDriftGet(devNum,
                                                        &taiId,
                                                        &fracNanoSecond);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiFractionalNanosecondDriftGet(devNum,
                                                         &taiId,
                                                         &fracNanoSecond);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiFractionalNanosecondDriftGet(devNum,
                                                             &taiId,
                                                             &fracNanoSecond);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiFractionalNanosecondDriftGet(devNum,
                                                             &taiId,
                                                             &fracNanoSecond);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiFractionalNanosecondDriftGet
                                    (devNum,
                                     &taiId,
                                     &fracNanoSecond),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiFractionalNanosecondDriftGet
                                (devNum,
                                 &taiId,
                                 &fracNanoSecond),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid nanoSeconsPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiFractionalNanosecondDriftGet(devNum,
                                                         &taiId,
                                                         NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiFractionalNanosecondDriftGet(devNum,
                                                         &taiId,
                                                         &fracNanoSecond);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiFractionalNanosecondDriftGet(devNum,
                                                     &taiId,
                                                     &fracNanoSecond);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiFractionalNanosecondDriftSet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    IN  GT_32                                 fracNanoSecond
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiFractionalNanosecondDriftSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E           /
                                  CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      0
                   }
    Expected: GT_OK.
    1.1.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
    Expected: GT_OK and the same parameters value as were set in 1.1.1.
    1.2.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                   }
    Expected: GT_OK.
    1.2.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
    Expected: GT_OK and the same parameters value as were set in 1.1.1.
    1.3.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                   }
    Expected: GT_OK.
    1.3.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
    Expected: GT_OK and the same parameters value as were set in 1.1.1.
    1.3 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.5 Call with invalid fracNanoSecondPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    GT_U32                       fracNanoSecond;
    GT_32                        fracNanoSecondGet;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */

    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, (UTF_BOBCAT2_E | UTF_CAELUM_E));


    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum  = 0;
        fracNanoSecond = 0;
        st = cpssDxChPtpTaiFractionalNanosecondDriftSet(
                devNum,
                &taiId,
                fracNanoSecond);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiFractionalNanosecondDriftGet(
                devNum,
                &taiId,
                &fracNanoSecondGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(fracNanoSecond, fracNanoSecondGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum  = 0;
        fracNanoSecond = 0;
        st = cpssDxChPtpTaiFractionalNanosecondDriftSet(
                devNum,
                &taiId,
                fracNanoSecond);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiFractionalNanosecondDriftGet(devNum,
                                                 &taiId,
                                                 &fracNanoSecondGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(fracNanoSecond, fracNanoSecondGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum     = 0;
        fracNanoSecond    = 0;
        st = cpssDxChPtpTaiFractionalNanosecondDriftSet(
                devNum,
                &taiId,
                fracNanoSecond);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        st = cpssDxChPtpTaiFractionalNanosecondDriftGet(
                devNum,
                &taiId,
                &fracNanoSecondGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(fracNanoSecond, fracNanoSecondGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                Expected: GT_OK.
            */
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            fracNanoSecond    = 0;
            st = cpssDxChPtpTaiFractionalNanosecondDriftSet(
                    devNum,
                    &taiId,
                    fracNanoSecond);
            /*
                1.3.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiFractionalNanosecondDriftGet(
                    devNum,
                    &taiId,
                    &fracNanoSecondGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(fracNanoSecond, fracNanoSecondGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            fracNanoSecond    = 0;
            st = cpssDxChPtpTaiFractionalNanosecondDriftSet(
                    devNum,
                    &taiId,
                    fracNanoSecond);
            /*
                1.3.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiFractionalNanosecondDriftGet(
                    devNum,
                    &taiId,
                    &fracNanoSecondGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(fracNanoSecond, fracNanoSecondGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      [all available ports]
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            fracNanoSecond    = 0;
            st = cpssDxChPtpTaiFractionalNanosecondDriftSet(
                    devNum,
                    &taiId,
                    fracNanoSecond);
            /*
                1.3.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiFractionalNanosecondDriftGet(
                    devNum,
                    &taiId,
                    &fracNanoSecondGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(fracNanoSecond, fracNanoSecondGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
        }

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        fracNanoSecond    = 0;
        st = cpssDxChPtpTaiFractionalNanosecondDriftSet(
                devNum,
                &taiId,
                fracNanoSecond);
        /*
            1.1.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiFractionalNanosecondDriftGet(
                devNum,
                &taiId,
                &fracNanoSecondGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(fracNanoSecond, fracNanoSecondGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        fracNanoSecond    = 0;
        st = cpssDxChPtpTaiFractionalNanosecondDriftSet(
                devNum,
                &taiId,
                fracNanoSecond);

        /*
            1.1.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiFractionalNanosecondDriftGet(
                devNum,
                &taiId,
                &fracNanoSecondGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(fracNanoSecond, fracNanoSecondGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum     = 0;
        fracNanoSecond    = 0;
        st = cpssDxChPtpTaiFractionalNanosecondDriftSet(
                devNum,
                &taiId,
                fracNanoSecond);
        /*
            1.1.2. Call cpssDxChPtpTaiFractionalNanosecondDriftGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        st = cpssDxChPtpTaiFractionalNanosecondDriftGet(
                devNum,
                &taiId,
                &fracNanoSecondGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(fracNanoSecond, fracNanoSecondGet, devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiFractionalNanosecondDriftSet
                                    (devNum,
                                     &taiId,
                                     fracNanoSecond),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiFractionalNanosecondDriftSet
                                (devNum,
                                &taiId,
                                fracNanoSecond),
                                taiId.taiNumber);
        }
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum     = 0;
    fracNanoSecond    = 0;

    /* 2.For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiFractionalNanosecondDriftSet(
                devNum,
                &taiId,
                fracNanoSecond);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiFractionalNanosecondDriftSet(
            devNum,
            &taiId,
            fracNanoSecond);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}



/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiIncomingClockCounterGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    OUT GT_BOOL                               *enablePtr,
    OUT GT_U32                                *valuePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiIncomingClockCounterGet)
{
   /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid enablePtr [NULL].
        1.5 Call with invalid valuePtr [NULL].
        Expected: GT_BAD_PTR.
    */

    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    UTF_PHYSICAL_PORT_NUM        port;
    GT_BOOL                      enable;
    GT_U32                       value;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiIncomingClockCounterGet(
                devNum,
                &taiId,
                &enable,
                &value);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiIncomingClockCounterGet(
                devNum,
                &taiId,
                &enable,
                &value);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &enable,
                    &value);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &enable,
                    &value);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiIncomingClockCounterGet
                                    (devNum,
                                     &taiId,
                                     &enable,
                                     &value),
                                     taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiIncomingClockCounterGet
                                (devNum,
                                 &taiId,
                                 &enable,
                                 &value),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid enablePtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiIncomingClockCounterGet(
                devNum,
                &taiId,
                NULL,
                &value);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
        /*
           1.6 Call with invalid valuePtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &enable,
                    NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiIncomingClockCounterGet(
                devNum,
                &taiId,
                &enable,
                &value);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiIncomingClockCounterGet(
            devNum,
            &taiId,
            &enable,
            &value);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiIncomingClockCounterSet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    IN  GT_BOOL                               enable,
    IN  GT_U32                                value
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiIncomingClockCounterSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E           /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                enable [GT_TRUE / GT_FALSE]
                value  [0 / 32768 / 65535]
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
                enable [GT_TRUE / GT_FALSE]
                value  [0 / 32768 / 65535]
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
                enable [GT_TRUE / GT_FALSE]
                value  [0 / 32768 / 65535]
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid enabledPtr [NULL].
        Expected: GT_BAD_PTR.
    */
        GT_STATUS                    st          =  GT_OK;
        GT_U8                        devNum      =  0;
        CPSS_DXCH_PTP_TAI_ID_STC     taiId       =  {0, 0, 0};
        GT_BOOL                      apEnable    =  GT_FALSE;
        GT_BOOL                      apEnableGet =  GT_FALSE;
        GT_U32                       value;
        GT_U32                       valueGet;
        UTF_PHYSICAL_PORT_NUM        port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;

        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                enable [GT_TRUE / GT_FALSE]
                value  [0 / 32768 / 65535]
                Expected: GT_OK.
            */
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            /*
                apEnable [GT_TRUE]
                value    [0]
            */
            apEnable = GT_TRUE;
            value    = 0;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
            /*
                apEnable [GT_FALSE]
                value    [32768]
            */
            apEnable = GT_FALSE;
            value    = 32768;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
            /*
                apEnable [GT_TRUE]
                value    [65535]
            */
            apEnable = GT_TRUE;
            value    = 65535;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
            Expected: GT_OK.
            */
             /*
                apEnable [GT_TRUE]
                value    [0]
            */
            apEnable = GT_TRUE;
            value    = 0;
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                */
                taiId.portNum = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiIncomingClockCounterSet(
                        devNum,
                        &taiId,
                        apEnable,
                        value);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);

                /*
                    1.3.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiIncomingClockCounterGet(
                        devNum,
                        &taiId,
                        &apEnableGet,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
                {
                    UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                }
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiIncomingClockCounterSet(
                        devNum,
                        &taiId,
                        apEnable,
                        value);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiIncomingClockCounterGet(
                        devNum,
                        &taiId,
                        &apEnableGet,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
                {
                    UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                }
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiIncomingClockCounterSet(
                        devNum,
                        &taiId,
                        apEnable,
                        value);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiIncomingClockCounterGet(
                        devNum,
                        &taiId,
                        &apEnableGet,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
                {
                    UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                }
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;

            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
             /*
                apEnable [GT_FALSE]
                value    [32768]
            */
            apEnable = GT_FALSE;
            value    = 32768;
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                    Expected: GT_OK.
                */
                taiId.portNum = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiIncomingClockCounterSet(
                        devNum,
                        &taiId,
                        apEnable,
                        value);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);

                /*
                    1.3.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiIncomingClockCounterGet(
                        devNum,
                        &taiId,
                        &apEnableGet,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
                {
                    UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                }
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                    Expected: GT_OK.
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiIncomingClockCounterSet(
                        devNum,
                        &taiId,
                        apEnable,
                        value);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiIncomingClockCounterGet(
                        devNum,
                        &taiId,
                        &apEnableGet,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
                {
                    UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                }
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                    Expected: GT_OK.
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiIncomingClockCounterSet(
                        devNum,
                        &taiId,
                        apEnable,
                        value);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiIncomingClockCounterGet(
                        devNum,
                        &taiId,
                        &apEnableGet,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
                {
                    UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                }
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;

            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
             /*
                apEnable [GT_FALSE]
                value    [65535]
            */
            apEnable = GT_FALSE;
            value    = 65535;
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                    Expected: GT_OK.
                */
                taiId.portNum = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiIncomingClockCounterSet(
                        devNum,
                        &taiId,
                        apEnable,
                        value);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);

                /*
                    1.3.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiIncomingClockCounterGet(
                        devNum,
                        &taiId,
                        &apEnableGet,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
                {
                    UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                }
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                    Expected: GT_OK.
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiIncomingClockCounterSet(
                        devNum,
                        &taiId,
                        apEnable,
                        value);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiIncomingClockCounterGet(
                        devNum,
                        &taiId,
                        &apEnableGet,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
                {
                    UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                }
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                    Expected: GT_OK.
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiIncomingClockCounterSet(
                        devNum,
                        &taiId,
                        apEnable,
                        value);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiIncomingClockCounterGet(
                        devNum,
                        &taiId,
                        &apEnableGet,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
                {
                    UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                }
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;

            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingClockCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiIncomingClockCounterGet(
                    devNum,
                    &taiId,
                    &apEnableGet,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            if (!PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            }
            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiIncomingClockCounterSet
                                        (devNum, &taiId, apEnable, value),
                                        taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiIncomingClockCounterSet
                                    (devNum, &taiId, apEnable, value),
                                    taiId.taiNumber);
            }
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        apEnable          = GT_TRUE;
        value             = 0;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiIncomingClockCounterSet(
                    devNum,
                    &taiId,
                    apEnable,
                    value);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiIncomingClockCounterSet(
                devNum,
                &taiId,
                apEnable,
                value);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiIncomingTriggerCounterGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    OUT GT_U32                                *valuePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiIncomingTriggerCounterGet)
{
   /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid valuePtr [NULL].
        Expected: GT_BAD_PTR.
    */

    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    OUT GT_U32                   value;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiIncomingTriggerCounterGet(devNum,
                                                     &taiId,
                                                     &value);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiIncomingTriggerCounterGet(devNum,
                                                     &taiId,
                                                     &value);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                Expected: GT_OK.
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiIncomingTriggerCounterGet(devNum,
                                                         &taiId,
                                                         &value);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiIncomingTriggerCounterGet(devNum,
                                                         &taiId,
                                                         &value);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiIncomingTriggerCounterGet
                                    (devNum,
                                     &taiId,
                                     &value),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiIncomingTriggerCounterGet
                                (devNum,
                                 &taiId,
                                 &value),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid nanoSeconsPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiIncomingTriggerCounterGet(devNum,
                                                     &taiId,
                                                     NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiIncomingTriggerCounterGet(devNum,
                                                     &taiId,
                                                     &value);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiIncomingTriggerCounterGet(devNum,
                                                 &taiId,
                                                 &value);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiIncomingTriggerCounterSet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    IN  GT_U32                                value
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiIncomingTriggerCounterSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E           /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid valuePtr [NULL].
        Expected: GT_BAD_PTR.
    */
        GT_STATUS                    st      =  GT_OK;
        GT_U8                        devNum  =  0;
        CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
        GT_U32                       value;
        GT_U32                       valueGet;
        UTF_PHYSICAL_PORT_NUM        port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;

        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                Expected: GT_OK.
            */
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum  = 0;
            value          = 0;
            st = cpssDxChPtpTaiIncomingTriggerCounterSet(
                    devNum,
                    &taiId,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiIncomingTriggerCounterGet(
                    devNum,
                    &taiId,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum  = 0;
            value = 0;
            st = cpssDxChPtpTaiIncomingTriggerCounterSet(
                    devNum,
                    &taiId,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiIncomingTriggerCounterGet(
                    devNum,
                    &taiId,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);


           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum  = 0;
            value          = 0;
            st = cpssDxChPtpTaiIncomingTriggerCounterSet(
                    devNum,
                    &taiId,
                    value);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiIncomingTriggerCounterGet(
                    devNum,
                    &taiId,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);


            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
            Expected: GT_OK.
            */
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                    Expected: GT_OK.
                */
                taiId.portNum     = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                value             = 0;
                st = cpssDxChPtpTaiIncomingTriggerCounterSet(
                        devNum,
                        &taiId,
                        value);
                /*
                    1.3.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiIncomingTriggerCounterGet(
                        devNum,
                        &taiId,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                    Expected: GT_OK.
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                value             = 0;
                st = cpssDxChPtpTaiIncomingTriggerCounterSet(
                        devNum,
                        &taiId,
                        value);
                /*
                    1.3.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiIncomingTriggerCounterGet(
                        devNum,
                        &taiId,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                    Expected: GT_OK.
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                value             = 0;
                st = cpssDxChPtpTaiIncomingTriggerCounterSet(
                        devNum,
                        &taiId,
                        value);
                /*
                    1.3.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiIncomingTriggerCounterGet(
                        devNum,
                        &taiId,
                        &valueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum     = 0;
            value             = 0;
            st = cpssDxChPtpTaiIncomingTriggerCounterSet(
                    devNum,
                    &taiId,
                    value);
            /*
                1.1.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiIncomingTriggerCounterGet(
                    devNum,
                    &taiId,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum     = 0;
            value             = 0;
            st = cpssDxChPtpTaiIncomingTriggerCounterSet(
                    devNum,
                    &taiId,
                    value);
            /*
                1.1.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiIncomingTriggerCounterGet(
                    devNum,
                    &taiId,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;
            value             = 0;
            st = cpssDxChPtpTaiIncomingTriggerCounterSet(
                    devNum,
                    &taiId,
                    value);
            /*
                1.1.2. Call cpssDxChPtpTaiIncomingTriggerCounterGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiIncomingTriggerCounterGet(
                    devNum,
                    &taiId,
                    &valueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(value, valueGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiIncomingTriggerCounterSet
                                        (devNum,
                                         &taiId,
                                         value),
                                        taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiIncomingTriggerCounterSet
                                    (devNum,
                                    &taiId,
                                    value),
                                    taiId.taiNumber);
            }
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        value             = 0;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiIncomingTriggerCounterSet(
                    devNum,
                    &taiId,
                    value);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiIncomingTriggerCounterSet(
                devNum,
                &taiId,
                value);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiInputTriggersCountEnableGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    OUT GT_BOOL                                 *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiInputTriggersCountEnableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
    Expected: GT_OK.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
    Expected: GT_OK.
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
    1.3 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.5 Call with invalid enabledPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    GT_BOOL                      enable  =  GT_FALSE;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                devNum,
                &taiId,
                &enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                devNum,
                &taiId,
                &enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                Expected: GT_OK.
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                    devNum,
                    &taiId,
                    &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                    devNum,
                    &taiId,
                    &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }
        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        port     = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        taiId.portNum = port;
        st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                devNum,
                &taiId,
                &enable);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
            }
            else
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
            }
        }
        else
        {
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiInputTriggersCountEnableGet
                                    (devNum, &taiId, &enable),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiInputTriggersCountEnableGet
                                (devNum, &taiId, &enable),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid enabledPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                devNum,
                &taiId,
                NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;
    enable  = GT_TRUE;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiInputTriggersCountEnableGet(devNum, &taiId, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiInputTriggersCountEnableGet(devNum, &taiId, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiInputTriggersCountEnableSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    IN  GT_BOOL                                 enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiInputTriggersCountEnableSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E           /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid enabledPtr [NULL].
        Expected: GT_BAD_PTR.
    */
        GT_STATUS                    st      =  GT_OK;
        GT_U8                        devNum  =  0;
        CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
        GT_BOOL                      apEnable     =  GT_FALSE;
        GT_BOOL                      apEnableGet  =  GT_FALSE;
        UTF_PHYSICAL_PORT_NUM        port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;

        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                Expected: GT_OK.
            */
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiInputTriggersCountEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiInputTriggersCountEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiInputTriggersCountEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
            Expected: GT_OK.
            */
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                */
                taiId.portNum = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiInputTriggersCountEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);

                /*
                    1.3.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiInputTriggersCountEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiInputTriggersCountEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiInputTriggersCountEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;

            st = cpssDxChPtpTaiInputTriggersCountEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiInputTriggersCountEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInputTriggersCountEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiInputTriggersCountEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiInputTriggersCountEnableSet
                                        (devNum, &taiId, apEnable),
                                        taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiInputTriggersCountEnableSet
                                    (devNum, &taiId, apEnable),
                                    taiId.taiNumber);
            }
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        apEnable  = GT_TRUE;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiInputTriggersCountEnableSet
                                (devNum, &taiId, apEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiInputTriggersCountEnableSet(
                devNum,
                &taiId,
                apEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiInternalClockGenerateEnableGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    OUT GT_BOOL                                 *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiInternalClockGenerateEnableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
    Expected: GT_OK.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
    Expected: GT_OK.
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
    1.3 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.5 Call with invalid enabledPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    GT_BOOL                      enable  =  GT_FALSE;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E |  UTF_LION2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                devNum,
                &taiId,
                &enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                devNum,
                &taiId,
                &enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                    devNum,
                    &taiId,
                    &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                    devNum,
                    &taiId,
                    &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }
        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        taiId.portNum = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                devNum,
                &taiId,
                &enable);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
            }
            else
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
            }
        }
        else
        {
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiInternalClockGenerateEnableGet
                                    (devNum, &taiId, &enable),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiInternalClockGenerateEnableGet
                                (devNum, &taiId, &enable),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid enabledPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                devNum,
                &taiId,
                NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;
    enable  = GT_TRUE;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                devNum,
                &taiId,
                &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiInternalClockGenerateEnableGet(devNum, &taiId, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiInternalClockGenerateEnableSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    IN  GT_BOOL                                 enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiInternalClockGenerateEnableSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E           /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid enabledPtr [NULL].
        Expected: GT_BAD_PTR.
    */
        GT_STATUS                    st      =  GT_OK;
        GT_U8                        devNum  =  0;
        CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
        GT_BOOL                      apEnable     =  GT_FALSE;
        GT_BOOL                      apEnableGet  =  GT_FALSE;
        UTF_PHYSICAL_PORT_NUM        port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;

        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                Expected: GT_OK.
            */
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiInternalClockGenerateEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiInternalClockGenerateEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiInternalClockGenerateEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
            Expected: GT_OK.
            */
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                */
                taiId.portNum = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiInternalClockGenerateEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);

                /*
                    1.3.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiInternalClockGenerateEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiInternalClockGenerateEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiInternalClockGenerateEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;

            st = cpssDxChPtpTaiInternalClockGenerateEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiInternalClockGenerateEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiInternalClockGenerateEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiInternalClockGenerateEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiInternalClockGenerateEnableSet
                                        (devNum, &taiId, apEnable),
                                        taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiInternalClockGenerateEnableSet
                                    (devNum, &taiId, apEnable),
                                    taiId.taiNumber);
            }
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        apEnable  = GT_TRUE;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiInternalClockGenerateEnableSet
                                (devNum, &taiId, apEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiInternalClockGenerateEnableSet(
                devNum,
                &taiId,
                apEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiOutputTriggerEnableGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    OUT GT_BOOL                               *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiOutputTriggerEnableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
    Expected: GT_OK.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
    Expected: GT_OK.
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
    1.3 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.5 Call with invalid enabledPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    GT_BOOL                      enable  =  GT_FALSE;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiOutputTriggerEnableGet(
                devNum,
                &taiId,
                &enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiOutputTriggerEnableGet(
                devNum,
                &taiId,
                &enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiOutputTriggerEnableGet(
                    devNum,
                    &taiId,
                    &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiOutputTriggerEnableGet(
                    devNum,
                    &taiId,
                    &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }
        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        taiId.portNum = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        st = cpssDxChPtpTaiOutputTriggerEnableGet(
                devNum,
                &taiId,
                &enable);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
            }
            else
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
            }
        }
        else
        {
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiOutputTriggerEnableGet
                                    (devNum, &taiId, &enable),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiOutputTriggerEnableGet
                                (devNum, &taiId, &enable),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid enabledPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiOutputTriggerEnableGet(
                devNum,
                &taiId,
                NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;
    enable  = GT_TRUE;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiOutputTriggerEnableGet(devNum, &taiId, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiOutputTriggerEnableGet(devNum, &taiId, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiOutputTriggerEnableSet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    IN  GT_BOOL                               enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiOutputTriggerEnableSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E           /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid enabledPtr [NULL].
        Expected: GT_BAD_PTR.
    */
        GT_STATUS                    st           =  GT_OK;
        GT_U8                        devNum       =  0;
        CPSS_DXCH_PTP_TAI_ID_STC     taiId        =  {0, 0, 0};
        GT_BOOL                      apEnable     =  GT_FALSE;
        GT_BOOL                      apEnableGet  =  GT_FALSE;
        UTF_PHYSICAL_PORT_NUM        port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;

        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                Expected: GT_OK.
            */
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable          = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiOutputTriggerEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiOutputTriggerEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiOutputTriggerEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiOutputTriggerEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiOutputTriggerEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiOutputTriggerEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
            Expected: GT_OK.
            */
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                */
                taiId.portNum = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiOutputTriggerEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);

                /*
                    1.3.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiOutputTriggerEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiOutputTriggerEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiOutputTriggerEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiOutputTriggerEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiOutputTriggerEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiOutputTriggerEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiOutputTriggerEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable          = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum     = 0;

            st = cpssDxChPtpTaiOutputTriggerEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiOutputTriggerEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable          = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiOutputTriggerEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiOutputTriggerEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiOutputTriggerEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiOutputTriggerEnableSet
                                        (devNum, &taiId, apEnable),
                                        taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiOutputTriggerEnableSet
                                    (devNum, &taiId, apEnable),
                                    taiId.taiNumber);
            }
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        apEnable          = GT_TRUE;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiOutputTriggerEnableSet
                                (devNum, &taiId, apEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiOutputTriggerEnableSet(devNum, &taiId, apEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPClkCycleGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    OUT GT_U32                                *nanoSecondsPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPClkCycleGet)
{
   /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid nanoSecondsPtr [NULL].
        Expected: GT_BAD_PTR.
    */

    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    OUT GT_U32                   nanoSeconds;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiPClkCycleGet(
                devNum,
                &taiId,
                &nanoSeconds);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiPClkCycleGet(
                devNum,
                &taiId,
                &nanoSeconds);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiPClkCycleGet(
                    devNum,
                    &taiId,
                    &nanoSeconds);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiPClkCycleGet(
                    devNum,
                    &taiId,
                    &nanoSeconds);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkCycleGet
                                    (devNum,
                                     &taiId,
                                     &nanoSeconds),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkCycleGet
                                (devNum,
                                 &taiId,
                                 &nanoSeconds),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid nanoSeconsPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiPClkCycleGet(
                devNum,
                &taiId,
                NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum     = 0;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiPClkCycleGet(
                devNum,
                &taiId,
                &nanoSeconds);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiPClkCycleGet(
            devNum,
            &taiId,
            &nanoSeconds);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPClkCycleSet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    IN  GT_U32                                nanoSeconds
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPClkCycleSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E           /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiPClkCycleGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiPClkCycleGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiPClkCycleGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
    */
        GT_STATUS                    st      =  GT_OK;
        GT_U8                        devNum  =  0;
        CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
        GT_U32                       nanoSeconds;
        GT_U32                       nanoSecondsGet;
        UTF_PHYSICAL_PORT_NUM        port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;


        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                Expected: GT_OK.
            */
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum     = 0;
            nanoSeconds       = 0x1234;
            st = cpssDxChPtpTaiPClkCycleSet(
                    devNum,
                    &taiId,
                    nanoSeconds);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiPClkCycleGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiPClkCycleGet(
                    devNum,
                    &taiId,
                    &nanoSecondsGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(nanoSeconds, nanoSecondsGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum     = 0;
            nanoSeconds       = 0x35566778;
            st = cpssDxChPtpTaiPClkCycleSet(
                    devNum,
                    &taiId,
                    nanoSeconds);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiPClkCycleGet().
                Expected: GT_OK and the same parameters nanoSeconds as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiPClkCycleGet(
                    devNum,
                    &taiId,
                    &nanoSecondsGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(nanoSeconds, nanoSecondsGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);


           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;
            nanoSeconds       = 0x22;
            st = cpssDxChPtpTaiPClkCycleSet(
                    devNum,
                    &taiId,
                    nanoSeconds);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiPClkCycleGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiPClkCycleGet(
                    devNum,
                    &taiId,
                    &nanoSecondsGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(nanoSeconds, nanoSecondsGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);


            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
            Expected: GT_OK.
            */
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                */
                taiId.portNum     = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                nanoSeconds       = 0;
                st = cpssDxChPtpTaiPClkCycleSet(
                        devNum,
                        &taiId,
                        nanoSeconds);
                /*
                    1.3.2. Call cpssDxChPtpTaiPClkCycleGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiPClkCycleGet(
                        devNum,
                        &taiId,
                        &nanoSecondsGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(nanoSeconds, nanoSecondsGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                nanoSeconds       = 0;
                st = cpssDxChPtpTaiPClkCycleSet(
                        devNum,
                        &taiId,
                        nanoSeconds);
                /*
                    1.3.2. Call cpssDxChPtpTaiPClkCycleGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiPClkCycleGet(
                        devNum,
                        &taiId,
                        &nanoSecondsGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(nanoSeconds, nanoSecondsGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                nanoSeconds       = 0;
                st = cpssDxChPtpTaiPClkCycleSet(
                        devNum,
                        &taiId,
                        nanoSeconds);
                /*
                    1.3.2. Call cpssDxChPtpTaiPClkCycleGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiPClkCycleGet(
                        devNum,
                        &taiId,
                        &nanoSecondsGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(nanoSeconds, nanoSecondsGet,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum     = 0;
            nanoSeconds       = 0;
            st = cpssDxChPtpTaiPClkCycleSet(
                    devNum,
                    &taiId,
                    nanoSeconds);
            /*
                1.1.2. Call cpssDxChPtpTaiPClkCycleGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiPClkCycleGet(
                    devNum,
                    &taiId,
                    &nanoSecondsGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(nanoSeconds, nanoSecondsGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum     = 0;
            nanoSeconds       = 0;
            st = cpssDxChPtpTaiPClkCycleSet(
                    devNum,
                    &taiId,
                    nanoSeconds);
            /*
                1.1.2. Call cpssDxChPtpTaiPClkCycleGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiPClkCycleGet(
                    devNum,
                    &taiId,
                    &nanoSecondsGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(nanoSeconds, nanoSecondsGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;
            nanoSeconds       = 0;
            st = cpssDxChPtpTaiPClkCycleSet(
                    devNum,
                    &taiId,
                    nanoSeconds);
            /*
                1.1.2. Call cpssDxChPtpTaiPClkCycleGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiPClkCycleGet(
                    devNum,
                    &taiId,
                    &nanoSecondsGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(nanoSeconds, nanoSecondsGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkCycleSet
                                        (devNum,
                                         &taiId,
                                         nanoSeconds),
                                        taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkCycleSet
                                    (devNum,
                                    &taiId,
                                    nanoSeconds),
                                    taiId.taiNumber);
            }
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        nanoSeconds       = 0;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiPClkCycleSet(
                    devNum,
                    &taiId,
                    nanoSeconds);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiPClkCycleSet(
                devNum,
                &taiId,
                nanoSeconds);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPClkDriftAdjustEnableGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    OUT GT_BOOL                                 *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPClkDriftAdjustEnableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
    Expected: GT_OK.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
    Expected: GT_OK.
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
    1.3 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.5 Call with invalid enabledPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    GT_BOOL                      enable  =  GT_FALSE;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                devNum,
                &taiId,
                &enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                devNum,
                &taiId,
                &enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                    devNum,
                    &taiId,
                    &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                    devNum,
                    &taiId,
                    &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }
        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        taiId.portNum = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                devNum,
                &taiId,
                &enable);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
            }
            else
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
            }
        }
        else
        {
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkDriftAdjustEnableGet
                                    (devNum, &taiId, &enable),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkDriftAdjustEnableGet
                                (devNum, &taiId, &enable),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid enabledPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                devNum,
                &taiId,
                NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum     = 0;
    enable            = GT_TRUE;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                  UTF_XCAT3_E | UTF_AC5_E |
                                      UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                devNum,
                &taiId,
                &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(devNum, &taiId, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPClkDriftAdjustEnableSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    IN  GT_BOOL                                 enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPClkDriftAdjustEnableSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E           /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid enabledPtr [NULL].
        Expected: GT_BAD_PTR.
    */
        GT_STATUS                    st      =  GT_OK;
        GT_U8                        devNum  =  0;
        CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
        GT_BOOL                      apEnable     =  GT_FALSE;
        GT_BOOL                      apEnableGet  =  GT_FALSE;
        UTF_PHYSICAL_PORT_NUM        port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;

        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E| UTF_CPSS_PP_ALL_SIP6_CNS);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                Expected: GT_OK.
            */
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiPClkDriftAdjustEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiPClkDriftAdjustEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiPClkDriftAdjustEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
            Expected: GT_OK.
            */
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum      [all available ports]
                */
                taiId.portNum = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiPClkDriftAdjustEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);

                /*
                    1.3.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiPClkDriftAdjustEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiPClkDriftAdjustEnableSet(
                        devNum,
                        &taiId,
                        apEnable);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.portNum);

                /*
                    1.2.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                        devNum,
                        &taiId,
                        &apEnableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum,
                                            taiId.taiInstance, taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiPClkDriftAdjustEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum = 0;

            st = cpssDxChPtpTaiPClkDriftAdjustEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                Expected: GT_OK.
            */
            apEnable = GT_TRUE;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum = 0;
            st = cpssDxChPtpTaiPClkDriftAdjustEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiPClkDriftAdjustEnableGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiPClkDriftAdjustEnableGet(
                    devNum,
                    &taiId,
                    &apEnableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(apEnable, apEnableGet, devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkDriftAdjustEnableSet
                                        (devNum, &taiId, apEnable),
                                        taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkDriftAdjustEnableSet
                                    (devNum, &taiId, apEnable),
                                    taiId.taiNumber);
            }
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        apEnable  = GT_TRUE;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                      UTF_XCAT3_E | UTF_AC5_E |
                                          UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiPClkDriftAdjustEnableSet(
                    devNum,
                    &taiId,
                    apEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiPClkDriftAdjustEnableSet(
                devNum,
                &taiId,
                apEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}



/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiTodCaptureStatusGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    IN  GT_U32                                captureIndex,
    OUT GT_BOOL                               *validPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiTodCaptureStatusGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            captureIndex [0 / 1]
    Expected: GT_OK.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
            captureIndex [0 / 1]
    Expected: GT_OK.
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
    1.3 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.5 Call with invalid validPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    GT_BOOL                      valid   =  GT_FALSE;
    GT_U32                       captureIndex;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            captureIndex [0 / 1]
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            captureIndex 0
            Expected: GT_OK.
        */
        captureIndex      = 0;
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodCaptureStatusGet(
                devNum,
                &taiId,
                captureIndex,
                &valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            captureIndex 0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodCaptureStatusGet(
                devNum,
                &taiId,
                captureIndex,
                &valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);


        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            captureIndex 1
            Expected: GT_OK.
        */
        captureIndex      = 1;
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodCaptureStatusGet(
                devNum,
                &taiId,
                captureIndex,
                &valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            captureIndex 1
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodCaptureStatusGet(
                devNum,
                &taiId,
                captureIndex,
                &valid);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
                captureIndex [0 / 1]
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                captureIndex 0
            */
            captureIndex      = 0;
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiTodCaptureStatusGet(
                    devNum,
                    &taiId,
                    captureIndex,
                    &valid);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                captureIndex 0
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodCaptureStatusGet(
                    devNum,
                    &taiId,
                    captureIndex,
                    &valid);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                captureIndex 1
            */
            captureIndex      = 1;
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiTodCaptureStatusGet(
                    devNum,
                    &taiId,
                    captureIndex,
                    &valid);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                captureIndex 1
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodCaptureStatusGet(
                    devNum,
                    &taiId,
                    captureIndex,
                    &valid);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }
        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        taiId.portNum     = port;
        st = cpssDxChPtpTaiTodCaptureStatusGet(
                devNum,
                &taiId,
                captureIndex,
                &valid);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
            }
            else
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
            }
        }
        else
        {
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
        }


        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodCaptureStatusGet
                                    (devNum, &taiId, captureIndex, &valid),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodCaptureStatusGet
                                (devNum, &taiId, captureIndex, &valid),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid validPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiTodCaptureStatusGet(
                devNum,
                &taiId,
                captureIndex,
                NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, valid = NULL",
                                     devNum);

        /*
           1.6 Call with invalid taiIdPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiTodCaptureStatusGet(
                devNum,
                NULL,
                captureIndex,
                &valid);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, valid = NULL",
                                         devNum);
        }
        else
        {
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "%d, valid = NULL", devNum);
        }
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum     = 0;
    valid             = GT_TRUE;
    captureIndex      = 0;


    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                  UTF_XCAT3_E | UTF_AC5_E |
                                      UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiTodCaptureStatusGet(
                devNum,
                &taiId,
                captureIndex,
                &valid);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiTodCaptureStatusGet(
            devNum,
            &taiId,
            captureIndex,
            &valid);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiTodGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    IN  CPSS_DXCH_PTP_TAI_TOD_TYPE_ENT        todValueType,
    OUT CPSS_DXCH_PTP_TOD_COUNT_STC           *todValuePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiTodGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E /
                          CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E           /
                          CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
    Expected: GT_OK.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E /
                          CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E           /
                          CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
    Expected: GT_OK.
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
    1.3 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.5 Call with invalid todValuePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                      st      =  GT_OK;
    GT_U8                          devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC       taiId   =  {0, 0, 0};
    CPSS_DXCH_PTP_TAI_TOD_TYPE_ENT todValueType;
    CPSS_DXCH_PTP_TOD_COUNT_STC    todValue;
    UTF_PHYSICAL_PORT_NUM          port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E /
                          CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E           /
                          CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
            Expected: GT_OK.
        */
        todValueType      = CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E;
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);


        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E]
            Expected: GT_OK.
        */
        todValueType      = CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E;
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E]
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);


        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E]
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E]
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
            Expected: GT_OK.
        */
        todValueType      = CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E;
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);


        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E           /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
            */
            todValueType      = CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E;
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
            */
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E]
            */
            todValueType      = CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E;
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E]
            */
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
            */
            todValueType      = CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E;
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
            */
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }
        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        taiId.portNum     = port;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);

        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
            }
            else
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
            }
        }
        else
        {
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodGet
                                    (devNum, &taiId, todValueType, &todValue),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodGet
                                (devNum, &taiId, todValueType, &todValue),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid todValuePtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, valid = NULL",
                                     devNum);

        /*
           1.6 Call with invalid taiIdPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodGet(
                devNum,
                NULL,
                todValueType,
                &todValue);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, valid = NULL",
                                         devNum);
        }
        else
        {
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "%d, valid = NULL", devNum);
        }
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum     = 0;
    todValueType      = CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                  UTF_XCAT3_E | UTF_AC5_E |
                                      UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiTodGet(
                devNum,
                &taiId,
                todValueType,
                &todValue);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiTodGet(
            devNum,
            &taiId,
            todValueType,
            &todValue);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiTodSet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    IN  CPSS_DXCH_PTP_TAI_TOD_TYPE_ENT        todValueType,
    IN  CPSS_DXCH_PTP_TOD_COUNT_STC           *todValuePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiTodSet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E         /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
                todValuePtr {
                                nanoSeconds     [0 / 16383 / 268435455]
                                seconds         [0 / 16383 / 268435455]
                                fracNanoSeconds [0 / 16383 / 268435455]
                            }
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiTodGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E         /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
                todValuePtr {
                                nanoSeconds     [0 / 16383 / 268435455]
                                seconds         [0 / 16383 / 268435455]
                                fracNanoSeconds [0 / 16383 / 268435455]
                            }
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiTodGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E         /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
                todValuePtr {
                                nanoSeconds     [0 / 16383 / 268435455]
                                seconds         [0 / 16383 / 268435455]
                                fracNanoSeconds [0 / 16383 / 268435455]
                            }
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiTodGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
    */
        GT_STATUS                      st      =  GT_OK;
        GT_U8                          devNum  =  0;
        CPSS_DXCH_PTP_TAI_ID_STC       taiId   =  {0, 0, 0};
        CPSS_DXCH_PTP_TAI_TOD_TYPE_ENT todValueType;
        CPSS_DXCH_PTP_TOD_COUNT_STC    todValue;
        CPSS_DXCH_PTP_TOD_COUNT_STC    todValueGet;
        UTF_PHYSICAL_PORT_NUM          port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;

        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                       UTF_XCAT3_E | UTF_AC5_E |
                                          UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E         /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
                todValuePtr {
                                nanoSeconds     [0 / 16383 / 268435455]
                                seconds         [0 / 16383 / 268435455]
                                fracNanoSeconds [0 / 16383 / 268435455]
                            }
                Expected: GT_OK.
            */
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
                todValue.nanoSeconds     0
                todValue.seconds         0
                todValue.fracNanoSeconds 0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum     = 0;
            todValueType      = CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E;
            todValue.nanoSeconds     = 0;
            todValue.seconds.l[0]    = 0;
            todValue.seconds.l[1]    = 0;
            todValue.fracNanoSeconds = 0;
            st = cpssDxChPtpTaiTodSet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiTodGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.nanoSeconds,
                                        todValueGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[0],
                                        todValueGet.seconds.l[0],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[1],
                                        todValueGet.seconds.l[1],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.fracNanoSeconds,
                                        todValueGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
                todValue.nanoSeconds     0
                todValue.seconds         0
                todValue.fracNanoSeconds 0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum  = 0;
            st = cpssDxChPtpTaiTodSet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiTodGet().
                Expected: GT_OK and the same parameters todValueGet as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.nanoSeconds,
                                        todValueGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[0],
                                        todValueGet.seconds.l[0],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[1],
                                        todValueGet.seconds.l[1],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.fracNanoSeconds,
                                        todValueGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);


           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
                todValue.nanoSeconds     0
                todValue.seconds         0
                todValue.fracNanoSeconds 0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodSet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiTodGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.nanoSeconds,
                                        todValueGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[0],
                                        todValueGet.seconds.l[0],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[1],
                                        todValueGet.seconds.l[1],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.fracNanoSeconds,
                                        todValueGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_LOAD_VALUE_E         /
                              CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE1_E]
                todValuePtr {
                                nanoSeconds     [0 / 16383 / 268435455]
                                seconds         [0 / 16383 / 268435455]
                                fracNanoSeconds [0 / 16383 / 268435455]
                            }
            Expected: GT_OK.
            */
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance
                        [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber
                        [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum
                        [all available ports]
                    todValueType
                        [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
                    todValue.nanoSeconds     0
                    todValue.seconds         0
                    todValue.fracNanoSeconds 0
                */
                todValueType = CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E;
                todValue.nanoSeconds     = 0;
                todValue.seconds.l[0]    = 0;
                todValue.seconds.l[1]    = 0;
                todValue.fracNanoSeconds = 0;
                taiId.portNum     = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiTodSet(
                        devNum,
                        &taiId,
                        todValueType,
                        &todValue);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiTodGet(
                        devNum,
                        &taiId,
                        todValueType,
                        &todValueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.nanoSeconds,
                                            todValueGet.nanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[0],
                                            todValueGet.seconds.l[0],
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[1],
                                            todValueGet.seconds.l[1],
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.fracNanoSeconds,
                                            todValueGet.fracNanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                /*
                    taiInstance
                        [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber
                        [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum
                        [all available ports]
                    todValueType
                        [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
                    todValue.nanoSeconds     0
                    todValue.seconds         0
                    todValue.fracNanoSeconds 0
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiTodSet(
                        devNum,
                        &taiId,
                        todValueType,
                        &todValue);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiTodGet(
                        devNum,
                        &taiId,
                        todValueType,
                        &todValueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.nanoSeconds,
                                            todValueGet.nanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[0],
                                            todValueGet.seconds.l[0],
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[1],
                                            todValueGet.seconds.l[1],
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.fracNanoSeconds,
                                            todValueGet.fracNanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance
                        [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber
                        [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum
                        [all available ports]
                    todValueType
                        [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
                    todValue.nanoSeconds     0
                    todValue.seconds         0
                    todValue.fracNanoSeconds 0
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiTodSet(
                        devNum,
                        &taiId,
                        todValueType,
                        &todValue);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiTodGet(
                        devNum,
                        &taiId,
                        todValueType,
                        &todValueGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.nanoSeconds,
                                            todValueGet.nanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[0],
                                            todValueGet.seconds.l[0],
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[1],
                                            todValueGet.seconds.l[1],
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.fracNanoSeconds,
                                            todValueGet.fracNanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      0
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
                todValue.nanoSeconds     0
                todValue.seconds         0
                todValue.fracNanoSeconds 0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodSet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            /*
                1.1.2. Call cpssDxChPtpTaiTodGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.nanoSeconds,
                                        todValueGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[0],
                                        todValueGet.seconds.l[0],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[1],
                                        todValueGet.seconds.l[1],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.fracNanoSeconds,
                                        todValueGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodSet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            /*
                1.1.2. Call cpssDxChPtpTaiTodGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.nanoSeconds,
                                        todValueGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[0],
                                        todValueGet.seconds.l[0],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[1],
                                        todValueGet.seconds.l[1],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.fracNanoSeconds,
                                        todValueGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      0
                todValueType [CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E]
                todValue.nanoSeconds     0
                todValue.seconds         0
                todValue.fracNanoSeconds 0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodSet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            /*
                1.1.2. Call cpssDxChPtpTaiTodGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiTodGet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValueGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.nanoSeconds,
                                        todValueGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[0],
                                        todValueGet.seconds.l[0],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.seconds.l[1],
                                        todValueGet.seconds.l[1],
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todValue.fracNanoSeconds,
                                        todValueGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodSet
                                        (devNum,
                                         &taiId,
                                         todValueType,
                                         &todValue),
                                         taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodSet
                                    (devNum,
                                     &taiId,
                                     todValueType,
                                     &todValue),
                                     taiId.taiNumber);
            }
        }

        /* restore valid values */
        todValueType = CPSS_DXCH_PTP_TAI_TOD_TYPE_TRIGGER_GENERATION_E;
        taiId.taiInstance        = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber          = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum            = 0;
        todValue.nanoSeconds     = 0;
        todValue.seconds.l[0]    = 0;
        todValue.seconds.l[1]    = 0;
        todValue.fracNanoSeconds = 0;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                      UTF_XCAT3_E | UTF_AC5_E |
                                          UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiTodSet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiTodSet(
                    devNum,
                    &taiId,
                    todValueType,
                    &todValue);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiTodStepGet
(
    IN  GT_U8                             devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC          *taiIdPtr,
    OUT CPSS_DXCH_PTP_TAI_TOD_STEP_STC    *todStepPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiTodStepGet)
{
   /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid todStepPtr [NULL].
        Expected: GT_BAD_PTR.
    */

    GT_STATUS                        st      =  GT_OK;
    GT_U8                            devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC         taiId   =  {0, 0, 0};
    UTF_PHYSICAL_PORT_NUM            port;
    CPSS_DXCH_PTP_TAI_TOD_STEP_STC  todStep;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiTodStepGet(
                devNum,
                &taiId,
                &todStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiTodStepGet(
                devNum,
                &taiId,
                &todStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStep);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStep);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodStepGet
                                    (devNum,
                                     &taiId,
                                     &todStep),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodStepGet
                                (devNum,
                                 &taiId,
                                 &todStep),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid nanoSeconsPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiTodStepGet(
                devNum,
                NULL,
                &todStep);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                         devNum);
        }
        else
        {
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "%d, enabled = NULL", devNum);
        }

        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiTodStepGet(
                devNum,
                &taiId,
                NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum     = 0;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                  UTF_XCAT3_E | UTF_AC5_E |
                                      UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiTodStepGet(
                devNum,
                &taiId,
                &todStep);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiTodStepGet(
            devNum,
            &taiId,
            &todStep);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiTodStepSet
(
    IN  GT_U8                             devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC          *taiIdPtr,
    IN  CPSS_DXCH_PTP_TAI_TOD_STEP_STC    *todStepPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiTodStepSet)
{
   /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                todStep {
                            nanoSeconds     [0 / 65535 / 2147483647]
                            fracNanoSeconds [0 / 65535 / 2147483647]
                        }
        Expected: GT_OK.
        1.1.2. Call cpssDxChPtpTaiTodStepGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
                todStep {
                            nanoSeconds     [0 / 65535 / 2147483647]
                            fracNanoSeconds [0 / 65535 / 2147483647]
                        }
        Expected: GT_OK.
        1.2.2. Call cpssDxChPtpTaiTodStepGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
                todStep {
                            nanoSeconds     [0 / 65535 / 2147483647]
                            fracNanoSeconds [0 / 65535 / 2147483647]
                        }
        Expected: GT_OK.
        1.3.2. Call cpssDxChPtpTaiTodStepGet().
        Expected: GT_OK and the same parameters value as were set in 1.1.1.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
    */
        GT_STATUS                      st      =  GT_OK;
        GT_U8                          devNum  =  0;
        CPSS_DXCH_PTP_TAI_ID_STC       taiId   =  {0, 0, 0};
        CPSS_DXCH_PTP_TAI_TOD_STEP_STC todStep;
        CPSS_DXCH_PTP_TAI_TOD_STEP_STC todStepGet;
        UTF_PHYSICAL_PORT_NUM          port;

        /* there is no TAI in GM */
        GM_NOT_SUPPORT_THIS_TEST_MAC;

        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                       UTF_XCAT3_E | UTF_AC5_E |
                                          UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            /*
                1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      0
                       }
                todStep {
                            nanoSeconds     [0 / 65535 / 2147483647]
                            fracNanoSeconds [0 / 65535 / 2147483647]
                        }
                Expected: GT_OK.
            */
            /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum         0
                nanoSeconds     0
                fracNanoSeconds 0
                Expected: GT_OK.
            */
            todStep.nanoSeconds     = 0;
            todStep.fracNanoSeconds = 0;
            taiId.taiInstance       = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber         = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum           = 0;
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiTodStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum         0
                nanoSeconds     0
                fracNanoSeconds 0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiTodStepGet().
                Expected: GT_OK and the same parameters todStep as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);


           /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum         0
                nanoSeconds     0
                fracNanoSeconds 0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiTodStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum         0
                nanoSeconds     65535
                fracNanoSeconds 65535
                Expected: GT_OK.
            */
            todStep.nanoSeconds     = 65535;
            todStep.fracNanoSeconds = 65535;
            taiId.taiInstance       = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber         = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum           = 0;
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiTodStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum         0
                nanoSeconds     65535
                fracNanoSeconds 65535
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiTodStepGet().
                Expected: GT_OK and the same parameters todStep as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);


           /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum         0
                nanoSeconds     65535
                fracNanoSeconds 65535
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiTodStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum         0
                nanoSeconds     2147483647
                fracNanoSeconds 2147483647
                Expected: GT_OK.
            */
            todStep.nanoSeconds     = 2147483647;
            if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                /* maximum acceptable value for Caelum and above is 0xFFFF */
                todStep.nanoSeconds     = 0xFFFF;
            }
            todStep.fracNanoSeconds = 2147483647;
            taiId.taiInstance       = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber         = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum           = 0;
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiTodStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum         0
                nanoSeconds     2147483647
                fracNanoSeconds 2147483647
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                1.1.2. Call cpssDxChPtpTaiTodStepGet().
                Expected: GT_OK and the same parameters todStep as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);


           /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum         0
                nanoSeconds     2147483647
                fracNanoSeconds 2147483647
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;

            if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                /* maximum acceptable value for Caelum and above is 0xFFFF */
                todStep.nanoSeconds     = 2147483647;
            }

            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum, taiId.taiInstance,
                                            taiId.taiNumber);
            }
            else
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    1.1.2. Call cpssDxChPtpTaiTodStepGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiTodStepGet(
                        devNum,
                        &taiId,
                        &todStepGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                            st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                            todStepGet.nanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                            todStepGet.fracNanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }
            /* restore to acceptable value */
            if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                /* maximum acceptable value for Caelum and above is 0xFFFF */
                todStep.nanoSeconds     = 0xFFFF;
            }

            /*
            1.2.1 Call with
                    taiId {
                            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                          CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                            portNum      [all available ports]
                           }
                    todStep {
                                nanoSeconds     [0 / 65535 / 2147483647]                                                                                                                                                ]
                                fracNanoSeconds [0 / 65535 / 2147483647]
                            }
            Expected: GT_OK.
            */
            st = prvUtfNextMacPortReset(&port, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /*  For all active devices go over all available physical ports. */
            while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
            {
                /*
                    taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum         [all available ports]
                    nanoSeconds     0
                    fracNanoSeconds 0
                */
                todStep.nanoSeconds     = 0;
                todStep.fracNanoSeconds = 0;
                taiId.portNum           = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiTodStepSet(
                        devNum,
                        &taiId,
                        &todStep);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodStepGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiTodStepGet(
                        devNum,
                        &taiId,
                        &todStepGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiTodStepSet(
                        devNum,
                        &taiId,
                        &todStep);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodStepGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiTodStepGet(
                        devNum,
                        &taiId,
                        &todStepGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                            todStepGet.nanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                            todStepGet.fracNanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum         [all available ports]
                    nanoSeconds     0
                    fracNanoSeconds 0
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiTodStepSet(
                        devNum,
                        &taiId,
                        &todStep);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodStepGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiTodStepGet(
                        devNum,
                        &taiId,
                        &todStepGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                            todStepGet.nanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                            todStepGet.fracNanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum         [all available ports]
                    nanoSeconds     65535
                    fracNanoSeconds 65535
                */
                todStep.nanoSeconds     = 65535;
                todStep.fracNanoSeconds = 65535;
                taiId.portNum           = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiTodStepSet(
                        devNum,
                        &taiId,
                        &todStep);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodStepGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiTodStepGet(
                        devNum,
                        &taiId,
                        &todStepGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiTodStepSet(
                        devNum,
                        &taiId,
                        &todStep);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodStepGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiTodStepGet(
                        devNum,
                        &taiId,
                        &todStepGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                            todStepGet.nanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                            todStepGet.fracNanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum         [all available ports]
                    nanoSeconds     65535
                    fracNanoSeconds 65535
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiTodStepSet(
                        devNum,
                        &taiId,
                        &todStep);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodStepGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiTodStepGet(
                        devNum,
                        &taiId,
                        &todStepGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                            todStepGet.nanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                            todStepGet.fracNanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                    portNum         [all available ports]
                    nanoSeconds     2147483647
                    fracNanoSeconds 2147483647
                */
                todStep.nanoSeconds     = 2147483647;
                if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
                {
                    /* maximum acceptable value for Caelum and above is 0xFFFF */
                    todStep.nanoSeconds     = 0xFFFF;
                }

                todStep.fracNanoSeconds = 2147483647;
                taiId.portNum           = port;
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiTodStepSet(
                        devNum,
                        &taiId,
                        &todStep);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodStepGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiTodStepGet(
                        devNum,
                        &taiId,
                        &todStepGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
                /*
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
                st = cpssDxChPtpTaiTodStepSet(
                        devNum,
                        &taiId,
                        &todStep);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodStepGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                st = cpssDxChPtpTaiTodStepGet(
                        devNum,
                        &taiId,
                        &todStepGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                            todStepGet.nanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                            todStepGet.fracNanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);

                /*
                    taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum         [all available ports]
                    nanoSeconds     0
                    fracNanoSeconds 0
                */
                taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
                st = cpssDxChPtpTaiTodStepSet(
                        devNum,
                        &taiId,
                        &todStep);
                /*
                    1.3.2. Call cpssDxChPtpTaiTodStepGet().
                    Expected: GT_OK and the same parameters value as were set
                        in 1.1.1.
                */
                taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
                st = cpssDxChPtpTaiTodStepGet(
                        devNum,
                        &taiId,
                        &todStepGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                            todStepGet.nanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
                UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                            todStepGet.fracNanoSeconds,
                                            devNum,
                                            taiId.taiInstance,
                                            taiId.taiNumber);
            }

            /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum         0
                nanoSeconds     0
                fracNanoSeconds 0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            /*
                1.1.2. Call cpssDxChPtpTaiTodStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum         0
                nanoSeconds     0
                fracNanoSeconds 0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            /*
                1.1.2. Call cpssDxChPtpTaiTodStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK,
                                        st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

           /*
                taiInstance     [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                taiNumber       [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum         0
                nanoSeconds     0
                fracNanoSeconds 0
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            taiId.portNum     = 0;
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            /*
                1.1.2. Call cpssDxChPtpTaiTodStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodStepGet(
                    devNum,
                    &taiId,
                    &todStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.nanoSeconds,
                                        todStepGet.nanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(todStep.fracNanoSeconds,
                                        todStepGet.fracNanoSeconds,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
               1.3  Call with taiId.taiInstance out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodStepSet
                                        (devNum,
                                         &taiId,
                                         &todStep),
                                        taiId.taiInstance);
                }
            }

            /*
               1.4  Call with taiId.taiNumber out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            if (! SINGLE_TAI_DEV_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodStepSet
                                    (devNum,
                                    &taiId,
                                    &todStep),
                                    taiId.taiNumber);
            }
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                      UTF_XCAT3_E | UTF_AC5_E |
                                          UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTaiTodStepSet(
                    devNum,
                    &taiId,
                    &todStep);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTaiTodStepSet(
                devNum,
                &taiId,
                &todStep);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*
GT_STATUS cpssDxChPtpTaiGracefulStepSet
(
    IN  GT_U8                             devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC          *taiIdPtr,
    IN  GT_U32                             gracefulStep
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiGracefulStepSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E           /
                                  CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      0
                   }
            gracefulStep     [0 / 15 / 31]
    Expected: GT_OK.
    1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
    Expected: GT_OK and the same parameters value as were set in 1.1.1.
    1.2.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                   }
            gracefulStep     [0 / 15 / 31]
    Expected: GT_OK.
    1.2.2. Call cpssDxChPtpTaiGracefulStepGet().
    Expected: GT_OK and the same parameters value as were set in 1.1.1.
    1.3.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      [all available ports]
                   }
    Expected: GT_OK.
    1.3.2. Call cpssDxChPtpTaiGracefulStepGet().
    Expected: GT_OK and the same parameters value as were set in 1.1.1.
    1.3 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    GT_U32                       gracefulStep;
    GT_U32                       gracefulStepGet;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                      UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                    portNum      0
                   }
            gracefulStep     [0 / 127 / 255]
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        /*
            gracefulStep     = 0
        */
        gracefulStep     = 0;
        taiId.taiInstance   = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber     = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum       = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum  = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            gracefulStep     = 15
        */
        gracefulStep     = 15;
        taiId.taiInstance   = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber     = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum       = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum  = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            gracefulStep     = 31
        */
        gracefulStep     = 31;
        taiId.taiInstance   = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber     = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum       = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum  = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E        /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E        /
                                      CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        /*
            gracefulStep     = 0
        */
        gracefulStep     = 0;
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiGracefulStepSet(
                    devNum,
                    &taiId,
                    gracefulStep);
            /*
                1.3.2. Call cpssDxChPtpTaiGracefulStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    &gracefulStepGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep,
                                        gracefulStepGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiGracefulStepSet(
                    devNum,
                    &taiId,
                    gracefulStep);
            /*
                1.3.2. Call cpssDxChPtpTaiGracefulStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    &gracefulStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep,
                                        gracefulStepGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            st = cpssDxChPtpTaiGracefulStepSet(
                    devNum,
                    &taiId,
                    gracefulStep);
            /*
                1.3.2. Call cpssDxChPtpTaiGracefulStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    &gracefulStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep,
                                        gracefulStepGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
        }

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            gracefulStep     = 31
        */
        gracefulStep     = 31;
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiGracefulStepSet(
                    devNum,
                    &taiId,
                    gracefulStep);
            /*
                1.3.2. Call cpssDxChPtpTaiGracefulStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    &gracefulStepGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep,
                                        gracefulStepGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiGracefulStepSet(
                    devNum,
                    &taiId,
                    gracefulStep);
            /*
                1.3.2. Call cpssDxChPtpTaiGracefulStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    &gracefulStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            st = cpssDxChPtpTaiGracefulStepSet(
                    devNum,
                    &taiId,
                    gracefulStep);
            /*
                1.3.2. Call cpssDxChPtpTaiGracefulStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    &gracefulStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
        }

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            gracefulStep     = 15
        */
        gracefulStep     = 15;
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
                Expected: GT_OK.
            */
            taiId.portNum     = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiGracefulStepSet(
                    devNum,
                    &taiId,
                    gracefulStep);
            /*
                1.3.2. Call cpssDxChPtpTaiGracefulStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    &gracefulStepGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep,
                                        gracefulStepGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiGracefulStepSet(
                    devNum,
                    &taiId,
                    gracefulStep);
            /*
                1.3.2. Call cpssDxChPtpTaiGracefulStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    &gracefulStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep,
                                        gracefulStepGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
                portNum      [all available ports]
                Expected: GT_OK.
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            st = cpssDxChPtpTaiGracefulStepSet(
                    devNum,
                    &taiId,
                    gracefulStep);
            /*
                1.3.2. Call cpssDxChPtpTaiGracefulStepGet().
                Expected: GT_OK and the same parameters value as were set
                    in 1.1.1.
            */
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    &gracefulStepGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
            UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep,
                                        gracefulStepGet,
                                        devNum,
                                        taiId.taiInstance,
                                        taiId.taiNumber);
        }

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);

       /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_ALL_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        /*
            1.1.2. Call cpssDxChPtpTaiGracefulStepGet().
            Expected: GT_OK and the same parameters value as were set
                in 1.1.1.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStepGet);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
        UTF_VERIFY_EQUAL3_PARAM_MAC(gracefulStep, gracefulStepGet,
                                    devNum,
                                    taiId.taiInstance,
                                    taiId.taiNumber);
        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiGracefulStepSet
                                    (devNum,
                                     &taiId,
                                     gracefulStep),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiGracefulStepSet
                                (devNum,
                                &taiId,
                                gracefulStep),
                                taiId.taiNumber);
        }

        /* restore valid values */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;

        /*
           1.5  Call with gracefulStep out of range
                and other params from 1.1.1.
           Expected: GT_OUT_OF_RANGE.
        */
        gracefulStep = 32;
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);
    }

    /* restore valid values */
    gracefulStep     = 0;
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum     = 0;

    /* 2.For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                  UTF_XCAT3_E | UTF_AC5_E |
                                      UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiGracefulStepSet(
                devNum,
                &taiId,
                gracefulStep);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiGracefulStepGet
(
    IN  GT_U8                             devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC          *taiIdPtr,
    OUT GT_U32                            *gracefulStepPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiGracefulStepGet)
{
   /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid gracefulStepPtr [NULL].
        Expected: GT_BAD_PTR.
    */

    GT_STATUS                    st      =  GT_OK;
    GT_U8                        devNum  =  0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId   =  {0, 0, 0};
    UTF_PHYSICAL_PORT_NUM        port;
    GT_U32                       gracefulStep;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStep);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    &gracefulStep);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    &gracefulStep);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiGracefulStepGet
                                    (devNum,
                                     &taiId,
                                     &gracefulStep),
                                     taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiGracefulStepGet
                                (devNum,
                                 &taiId,
                                 &gracefulStep),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid gracefulStepPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiGracefulStepGet(
                    devNum,
                    &taiId,
                    NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid gracefulSteps */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                  UTF_XCAT3_E | UTF_AC5_E |
                                      UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiGracefulStepGet(
                devNum,
                &taiId,
                &gracefulStep);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound gracefulStep for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiGracefulStepGet(
            devNum,
            &taiId,
            &gracefulStep);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiTodUpdateCounterGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              *taiIdPtr,
    OUT GT_U32                                *valuePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiTodUpdateCounterGet)
{
   /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      0
                       }
        Expected: GT_OK.
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        1.3 Call with taiId.taiInstance out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.4 Call with taiId.taiNumber out of range, and other params from 1.1
        Expected: GT_BAD_PARAM.
        1.5 Call with invalid valuePtr [NULL].
        Expected: GT_BAD_PTR.
    */

    GT_STATUS                    st     = GT_OK;
    GT_U8                        devNum = 0;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId  = {0, 0, 0};
    UTF_PHYSICAL_PORT_NUM        port;
    GT_U32                       value;

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E         /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            Expected: GT_OK.
        */
        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodUpdateCounterGet(devNum,
                                                &taiId,
                                                &value);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
            taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
            taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            portNum      0
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum     = 0;
        st = cpssDxChPtpTaiTodUpdateCounterGet(devNum,
                                                &taiId,
                                                &value);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, devNum, taiId.taiInstance,
                                    taiId.taiNumber);

        /*
        1.2.1 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E]
                portNum      [all available ports]
            */
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            st = cpssDxChPtpTaiTodUpdateCounterGet(devNum,
                                                    &taiId,
                                                    &value);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);

            /*
                taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                portNum      [all available ports]
            */
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
            st = cpssDxChPtpTaiTodUpdateCounterGet(devNum,
                                                    &taiId,
                                                    &value);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, taiId.portNum);
        }

        /*
           1.3  Call with taiId.taiInstance out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodUpdateCounterGet
                                    (devNum,
                                     &taiId,
                                     &value),
                                    taiId.taiInstance);
            }
        }

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiTodUpdateCounterGet
                                (devNum,
                                 &taiId,
                                 &value),
                                taiId.taiNumber);
        }

        /*
           1.5 Call with invalid nanoSeconsPtr [NULL].
           Expected: GT_BAD_PTR.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiTodUpdateCounterGet(devNum,
                                                NULL,
                                                &value);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                         devNum);
        }
        else
        {
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "%d, enabled = NULL", devNum);
        }

        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_1_E;
        taiId.portNum = 0;
        st = cpssDxChPtpTaiTodUpdateCounterGet(devNum,
                                                &taiId,
                                                NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
    }

    /* restore valid values */
    taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
    taiId.taiNumber   = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
    taiId.portNum = 0;

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                  UTF_XCAT3_E | UTF_AC5_E |
                                      UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiTodUpdateCounterGet(devNum,
                                                &taiId,
                                                &value);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiTodUpdateCounterGet(devNum,
                                            &taiId,
                                            &value);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_U32                  domainNum,
    OUT GT_32                   *egrAsymmetryCorrPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1. Call with domainNum 0, egrAsymmetryCorrPtr non-null
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
    1.3. For active device for out of bound value for domainNum number.
    Expected: GT_BAD_PARAM
    1.4. For active device for egrAsymmetryCorr[NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS    st              = GT_OK;
    GT_U8       devNum           = 0;
    UTF_PHYSICAL_PORT_NUM   port = 0;
    GT_U32      domainNum        = 0;
    GT_32       egrAsymmetryCorr = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1. Call with domainNum 0, egrAsymmetryCorrPtr non-null
                Expected: GT_OK.
            */
            domainNum = 0;
            st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet(devNum,
                                                             port,
                                                             domainNum,
                                                             &egrAsymmetryCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call with domainNum 4, egrAsymmetryCorrPtr non-null
                Expected: GT_OK.
            */
            domainNum = 4;
            st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet(devNum,
                                                             port,
                                                             domainNum,
                                                             &egrAsymmetryCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.3. Call with domainNum 8, egrAsymmetryCorrPtr non-null
                Expected: GT_OK.
            */
            domainNum = 8;
            st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet(devNum,
                                                             port,
                                                             domainNum,
                                                             &egrAsymmetryCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);
        }

        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        domainNum = 0;
        st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet(devNum,
                                                            port,
                                                            domainNum,
                                                            &egrAsymmetryCorr);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);

        /*
            1.3. For active device for out of bound value for domainNum number.
            Expected: GT_BAD_PARAM
        */
        port = 0;
        domainNum = 16;
        st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet(devNum,
                                                            port,
                                                            domainNum,
                                                            &egrAsymmetryCorr);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);

        /*
            1.4. For active device for egrAsymmetryCorr[NULL].
            Expected: GT_BAD_PTR.
        */
        port = 0;
        domainNum = 0;
        st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet(devNum,
                                                            port,
                                                            domainNum,
                                                            NULL);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, devNum, port);
    }

    /*set valid values*/
    port = 0;
    domainNum = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /*
        2. Go over all non-applicable devices.
        Expected: GT_NOT_APPLICABLE_DEVICE
    */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet(devNum,
                                                            port,
                                                            domainNum,
                                                            &egrAsymmetryCorr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*
        3. Call function with out of bound value for device id.
        Expected: GT_BAD_PARAM
    */
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet(devNum,
                                                        port,
                                                        domainNum,
                                                        &egrAsymmetryCorr);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayEgressAsymmetryCorrectionSet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_U32                  domainNum,
    IN  GT_32                   egrAsymmetryCorr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayEgressAsymmetryCorrectionSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1. Call with domainNum           [0 / 4 / 8]
                     egrAsymmetryCorr [-1000000000 / 0 / 999999999]
    Expected: GT_OK.
    1.1.2. Call cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.1.3. Call with domainNum ouf of range, egrAsymmetryCorr out of range
    Expected: GT_BAD_PARAM
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
*/
    GT_STATUS   st                  = GT_OK;
    GT_U8       devNum              = 0;
    UTF_PHYSICAL_PORT_NUM   port    = 0;
    GT_U32      domainNum           = 0;
    GT_32       egrAsymmetryCorr    = 0;
    GT_32       egrAsymmetryCorrGet = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1. Call with domainNum           [0]
                                 egrAsymmetryCorr [-1000000000]
            */
            domainNum = 0;
            egrAsymmetryCorr = -1000000000; /*-10^9 minimum value*/
            st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionSet(devNum,
                                                              port,
                                                              domainNum,
                                                              egrAsymmetryCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet(devNum,
                                                          port,
                                                          domainNum,
                                                          &egrAsymmetryCorrGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(egrAsymmetryCorr, egrAsymmetryCorrGet,
                                        devNum, port);

            /*
                1.1.1. Call with domainNum        [4]
                                 egrAsymmetryCorr [0]
            */
            domainNum = 4;
            egrAsymmetryCorr = 0; /*0 midle value*/
            st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionSet(devNum,
                                                             port,
                                                             domainNum,
                                                             egrAsymmetryCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet(devNum,
                                                          port,
                                                          domainNum,
                                                          &egrAsymmetryCorrGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(egrAsymmetryCorr, egrAsymmetryCorrGet,
                                        devNum, port);

            /*
                1.1.1. Call with domainNum           [0]
                                 egrAsymmetryCorr [999999999]
            */
            domainNum = 8;
            egrAsymmetryCorr = 999999999; /*999999999 maximum value*/
            st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionSet(devNum,
                                                            port,
                                                            domainNum,
                                                            egrAsymmetryCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet(devNum,
                                                          port,
                                                          domainNum,
                                                          &egrAsymmetryCorrGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(egrAsymmetryCorr, egrAsymmetryCorrGet,
                                        devNum, port);

            /*
                1.1.3. Call with domainNum ouf of range,
                Expected: GT_BAD_PARAM
            */
            domainNum = 10;
            egrAsymmetryCorr = 0;
            st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionSet(devNum,
                                                                port,
                                                                domainNum,
                                                                egrAsymmetryCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
            /*
                1.1.4. Call with egrAsymmetryCorr out of range
                Expected: GT_OUT_OF_RANGE
            */
            domainNum = 0;
            egrAsymmetryCorr = 1000000001;
            st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionSet(devNum,
                                                                port,
                                                                domainNum,
                                                                egrAsymmetryCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);
        }


        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        /*set valid parameters*/
        port              = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        domainNum          = 0;
        egrAsymmetryCorr = 0;
        st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionSet(devNum,
                                                            port,
                                                            domainNum,
                                                            egrAsymmetryCorr);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set valid values*/
    port             = 0;
    domainNum        = 0;
    egrAsymmetryCorr = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /*
        2. Go over all non-applicable devices.
        Expected: GT_NOT_APPLICABLE_DEVICE
    */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionSet(devNum,
                                                            port,
                                                            domainNum,
                                                            egrAsymmetryCorr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*
        3. Call function with out of bound value for device id.
        Expected: GT_BAD_PARAM
    */
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayEgressAsymmetryCorrectionSet(devNum,
                                                        port,
                                                        domainNum,
                                                        egrAsymmetryCorr);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_BOOL                 *egrCorrFldPBEnablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with non-null egrCorrFldPBEnablePtr.
    Expected: GT_OK
    1.1.2 Call with null egrCorrFldPBEnablePtr.
    Expected: GT_BAD_PTR
*/
    GT_STATUS                         st      =  GT_OK;
    GT_U8                             devNum  =  0;
    UTF_PHYSICAL_PORT_NUM             port;
    GT_BOOL                           egrCorrFldPBEnable;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with non-null egrCorrFldPBEnablePtr.
                Expected: GT_OK
            */
            st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet(
                    devNum,
                    port,
                    &egrCorrFldPBEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2 Call with null egrCorrFldPBEnablePtr.
                Expected: GT_BAD_PARAM
            */
            st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet(
                    devNum,
                    port,
                    NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet(
                devNum,
                port,
                &egrCorrFldPBEnable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet(
                devNum,
                port,
                &egrCorrFldPBEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet(
            devNum,
            port,
            &egrCorrFldPBEnable);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableSet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_BOOL                 egrCorrFldPBEnable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with egrCorrFldPBEnable [GT_TRUE / GT_FALSE]
    Expected: GT_OK
    1.1.2. Call cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.2. For active device for out of bound value for port number.
*/
    GT_STATUS                     st      =  GT_OK;
    GT_U8                         devNum  =  0;
    UTF_PHYSICAL_PORT_NUM         port;
    GT_BOOL                       egrCorrFldPBEnable;
    GT_BOOL                       egrCorrFldPBEnableGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with egrCorrFldPBEnable [GT_TRUE]
                Expected: GT_OK
            */
            egrCorrFldPBEnable = GT_TRUE;
            st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableSet(
                    devNum,
                    port,
                    egrCorrFldPBEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call
                    cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet(
                    devNum,
                    port,
                    &egrCorrFldPBEnableGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(egrCorrFldPBEnable,
                                        egrCorrFldPBEnableGet,
                                        devNum,
                                        port);

            /*
                1.1.1 Call with egrCorrFldPBEnable [GT_FALSE]
                Expected: GT_OK
            */
            egrCorrFldPBEnable = GT_FALSE;
            st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableSet(
                    devNum,
                    port,
                    egrCorrFldPBEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call
                    cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet(
                    devNum,
                    port,
                    &egrCorrFldPBEnableGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(egrCorrFldPBEnable,
                                        egrCorrFldPBEnableGet,
                                        devNum,
                                        port);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port                = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        egrCorrFldPBEnable = GT_TRUE;

        st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableSet(
                devNum,
                port,
                egrCorrFldPBEnable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM,
                                    st,
                                    devNum,
                                    port);
    }

    /*set port valid value*/
    port               = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
    egrCorrFldPBEnable = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableSet(
                devNum,
                port,
                egrCorrFldPBEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableSet(
            devNum,
            port,
            egrCorrFldPBEnable);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayEgressPipeDelayGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_32                   *egrPipeDelayCorrPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayEgressPipeDelayGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with non-null egrPipeDelayCorrPtr.
    Expected: GT_OK
    1.1.2 Call with null egrPipeDelayCorrPtr.
    Expected: GT_BAD_PTR
*/
    GT_STATUS                                 st      =  GT_OK;
    GT_U8                                     devNum  =  0;
    UTF_PHYSICAL_PORT_NUM                     port;
    CPSS_DXCH_PTP_TS_EGRESS_PIPE_DELAY_VALUES_STC                                     egrPipeDelayCorr;
    GT_U32 numRegularPorts;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with non-null egrPipeDelayCorrPtr.
                Expected: GT_OK
            */

            if (port >58 || port < 65 )
            {
                continue;
            }

            st = cpssDxChPtpTsDelayEgressPipeDelayGet(
                    devNum,
                    port,
                    &egrPipeDelayCorr);
            numRegularPorts = PRV_CPSS_DXCH_PP_MAC(devNum)->port.numRegularPorts;
           if (((port >= numRegularPorts && port < (numRegularPorts + PRV_CPSS_DXCH_PP_MAC(devNum)->port.numOfNetworkCpuPorts))|| (port >= PRV_CPSS_PP_MAC(devNum)->numOfPorts)) && (PRV_CPSS_SIP_6_CHECK_MAC(devNum)))
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
            }
           else
           {
               UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);
           }


            /*
                1.1.2 Call with null egrPipeDelayCorr.
                Expected: GT_BAD_PARAM
            */
            st = cpssDxChPtpTsDelayEgressPipeDelayGet(
                    devNum,
                    port,
                    NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsDelayEgressPipeDelayGet(
                devNum,
                port,
                &egrPipeDelayCorr);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port          = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayEgressPipeDelayGet(
                devNum,
                port,
                &egrPipeDelayCorr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayEgressPipeDelayGet(
            devNum,
            port,
            &egrPipeDelayCorr);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayEgressPipeDelaySet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_32                   egrPipeDelayCorr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayEgressPipeDelaySet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with egrPipeDelayCorr [0 / 65535 / 2147483647]
    Expected: GT_OK
    1.1.2. Call cpssDxChPtpTsDelayEgressPipeDelayGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.2. For active device for out of bound value for port number.
*/
    GT_STATUS                     st      =  GT_OK;
    GT_U8                         devNum  =  0;
    UTF_PHYSICAL_PORT_NUM         port;
    CPSS_DXCH_PTP_TS_EGRESS_PIPE_DELAY_VALUES_STC                        egrPipeDelayCorr;
    CPSS_DXCH_PTP_TS_EGRESS_PIPE_DELAY_VALUES_STC                         egrPipeDelayCorrGet;
    GT_U32                        numRegularPorts;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with egrPipeDelayCorr [0]
                Expected: GT_OK
            */

            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            egrPipeDelayCorr.egressPipeDelay = 0;
            if (port >58 || port < 65 )
            {
                continue;
            }
            st = cpssDxChPtpTsDelayEgressPipeDelaySet(devNum,
                                                       port,
                                                       &egrPipeDelayCorr);
            numRegularPorts = PRV_CPSS_DXCH_PP_MAC(devNum)->port.numRegularPorts;
            if (((port >= numRegularPorts && port < (numRegularPorts + PRV_CPSS_DXCH_PP_MAC(devNum)->port.numOfNetworkCpuPorts))|| (port >= PRV_CPSS_PP_MAC(devNum)->numOfPorts)) && (PRV_CPSS_SIP_6_CHECK_MAC(devNum)))
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
            }
            else
            {

                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

                /*
                    1.1.2. Call cpssDxChPtpTsDelayEgressPipeDelayGet().
                    Expected: GT_OK and same mode as was set in 1.1.1.
                */
                st = cpssDxChPtpTsDelayEgressPipeDelayGet(devNum,
                                                           port,
                                                           &egrPipeDelayCorrGet);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

                /* verifying values */
                UTF_VERIFY_EQUAL2_PARAM_MAC(egrPipeDelayCorr.egressPipeDelay, egrPipeDelayCorrGet.egressPipeDelay,
                                            devNum, port);
                /*
                    1.1.1 Call with egrPipeDelayCorr [65536]
                    Expected: GT_OK
                */
                egrPipeDelayCorr.egressPipeDelay = 65536;
                st = cpssDxChPtpTsDelayEgressPipeDelaySet(devNum,
                                                           port,
                                                           &egrPipeDelayCorr);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

                /*
                    1.1.2. Call cpssDxChPtpTsDelayEgressPipeDelayGet().
                    Expected: GT_OK and same mode as was set in 1.1.1.
                */
                st = cpssDxChPtpTsDelayEgressPipeDelayGet(devNum,
                                                           port,
                                                           &egrPipeDelayCorrGet);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

                /* verifying values */
                UTF_VERIFY_EQUAL2_PARAM_MAC(egrPipeDelayCorr.egressPipeDelay, egrPipeDelayCorrGet.egressPipeDelay,
                                            devNum, port);
                /*
                    1.1.1 Call with egrPipeDelayCorr [2147483647]
                    Expected: GT_OUT_OF_RANGE
                */
                egrPipeDelayCorr.egressPipeDelay = 2147483647;
                st = cpssDxChPtpTsDelayEgressPipeDelaySet(devNum,
                                                           port,
                                                           &egrPipeDelayCorr);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);
            }
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port             = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        egrPipeDelayCorr.egressPipeDelay = 0;

        st = cpssDxChPtpTsDelayEgressPipeDelaySet(devNum,
                                                   port,
                                                   &egrPipeDelayCorr);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    egrPipeDelayCorr.egressPipeDelay = 0;
    port             = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayEgressPipeDelaySet(devNum,
                                                  port,
                                                  &egrPipeDelayCorr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayEgressPipeDelaySet(devNum,
                                               port,
                                               &egrPipeDelayCorr);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet
(
    IN  GT_U8                                     devNum,
    IN  GT_PHYSICAL_PORT_NUM                      portNum,
    OUT CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_ENT   *egrTimeCorrTaiSelModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with non-null egrTimeCorrTaiSelModePtr.
    Expected: GT_OK
    1.1.2 Call with null egrTimeCorrTaiSelModePtr.
    Expected: GT_BAD_PTR
*/
    GT_STATUS                                 st      =  GT_OK;
    GT_U8                                     devNum  =  0;
    UTF_PHYSICAL_PORT_NUM                     port;
    CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_ENT   egrTimeCorrTaiSelMode;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                  UTF_XCAT3_E | UTF_AC5_E |  UTF_LION2_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with non-null egrTimeCorrTaiSelMode.
                Expected: GT_OK
            */
            st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet(
                    devNum,
                    port,
                    &egrTimeCorrTaiSelMode);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2 Call with null egrTimeCorrTaiSelMode.
                Expected: GT_BAD_PARAM
            */
            st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet(
                    devNum,
                    port,
                    NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet(
                devNum,
                port,
                &egrTimeCorrTaiSelMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port          = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                     UTF_XCAT3_E | UTF_AC5_E |
                                     UTF_LION2_E | UTF_IRONMAN_L_E);

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet(
                devNum,
                port,
                &egrTimeCorrTaiSelMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet(
            devNum,
            port,
            &egrTimeCorrTaiSelMode);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeSet
(
    IN  GT_U8                                     devNum,
    IN  GT_PHYSICAL_PORT_NUM                      portNum,
    IN  CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_ENT   egrTimeCorrTaiSelMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
          egrTimeCorrTaiSelMode [CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_INGRESS_E /
                                 CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_EGRESS_E]
    Expected: GT_OK
    1.1.2. Call cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.1.3  Call with egrTimeCorrTaiSelMode out of range
        and other params from 1.1.1.
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                                 st      =  GT_OK;
    GT_U8                                     devNum  =  0;
    UTF_PHYSICAL_PORT_NUM                     port;
    CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_ENT egrTimeCorrTaiSelMode;
    CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_ENT egrTimeCorrTaiSelModeGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                                                                UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with
           egrTimeCorrTaiSelMode [CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_INGRESS_E]
                Expected: GT_OK
            */
            egrTimeCorrTaiSelMode =
                                CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_INGRESS_E;

            st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeSet(
                    devNum,
                    port,
                    egrTimeCorrTaiSelMode);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet(
                    devNum,
                    port,
                    &egrTimeCorrTaiSelModeGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(egrTimeCorrTaiSelMode,
                                        egrTimeCorrTaiSelModeGet,
                                        devNum,
                                        port);
            /*
                1.1.1 Call with
            egrTimeCorrTaiSelMode [CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_EGRESS_E]
                Expected: GT_OK
            */
            egrTimeCorrTaiSelMode =
                CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_EGRESS_E;

            st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeSet(
                    devNum,
                    port,
                    egrTimeCorrTaiSelMode);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet(
                    devNum,
                    port,
                    &egrTimeCorrTaiSelModeGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(egrTimeCorrTaiSelMode,
                                        egrTimeCorrTaiSelModeGet,
                                        devNum,
                                        port);

            /*
               1.1.3  Call with egrTimeCorrTaiSelMode out of range
                    and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeSet
                                (devNum,
                                 port,
                                 egrTimeCorrTaiSelMode),
                                 egrTimeCorrTaiSelMode);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port             = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        egrTimeCorrTaiSelMode = CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_INGRESS_E;

        st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeSet(
                devNum,
                port,
                egrTimeCorrTaiSelMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port        = 0;
    egrTimeCorrTaiSelMode = CPSS_DXCH_PTP_TS_DELAY_TAI_SEL_MODE_INGRESS_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                   UTF_LION2_E | UTF_IRONMAN_L_E);

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeSet(
                devNum,
                port,
                egrTimeCorrTaiSelMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeSet(
            devNum,
            port,
            egrTimeCorrTaiSelMode);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayEgressTimestampTaiSelectGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_U32                  *egrTsTaiNumPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayEgressTimestampTaiSelectGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with non-null egrTsTaiNum.
    Expected: GT_OK
    1.1.2 Call with null egrTsTaiNum.
    Expected: GT_BAD_PTR
*/
    GT_STATUS                         st      =  GT_OK;
    GT_U8                             devNum  =  0;
    UTF_PHYSICAL_PORT_NUM             port;
    GT_U32                            egrTsTaiNum;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                     UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with non-null egrTsTaiNum.
                Expected: GT_OK
            */
            st = cpssDxChPtpTsDelayEgressTimestampTaiSelectGet(
                    devNum,
                    port,
                    &egrTsTaiNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2 Call with null egrTsTaiNum.
                Expected: GT_BAD_PARAM
            */
            st = cpssDxChPtpTsDelayEgressTimestampTaiSelectGet(
                    devNum,
                    port,
                    NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsDelayEgressTimestampTaiSelectGet(
                devNum,
                port,
                &egrTsTaiNum);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                   UTF_LION2_E | UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_IRONMAN_L_E);

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayEgressTimestampTaiSelectGet(
                devNum,
                port,
                &egrTsTaiNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayEgressTimestampTaiSelectGet(
            devNum,
            port,
            &egrTsTaiNum);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayEgressTimestampTaiSelectSet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_U32                  egrTsTaiNum
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayEgressTimestampTaiSelectSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with egrTsTaiNum [0 / 1]
    Expected: GT_OK
    1.1.2. Call cpssDxChPtpTsDelayEgressTimestampTaiSelectGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.2. For active device for out of bound value for port number.
*/
    GT_STATUS                     st      =  GT_OK;
    GT_U8                         devNum  =  0;
    UTF_PHYSICAL_PORT_NUM         port;
    GT_U32                        egrTsTaiNum;
    GT_U32                        egrTsTaiNumGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                     UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with egrTsTaiNum [0]
                Expected: GT_OK
            */
            egrTsTaiNum = 0;
            st = cpssDxChPtpTsDelayEgressTimestampTaiSelectSet(
                    devNum,
                    port,
                    egrTsTaiNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call cpssDxChPtpTsDelayEgressTimestampTaiSelectGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayEgressTimestampTaiSelectGet(
                    devNum,
                    port,
                    &egrTsTaiNumGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(egrTsTaiNum, egrTsTaiNumGet,
                                        devNum, port);
            /*
                1.1.1 Call with egrTsTaiNum [1]
                Expected: GT_OK
            */
            egrTsTaiNum = 1;
            st = cpssDxChPtpTsDelayEgressTimestampTaiSelectSet(
                    devNum,
                    port,
                    egrTsTaiNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call cpssDxChPtpTsDelayEgressTimestampTaiSelectGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayEgressTimestampTaiSelectGet(
                    devNum,
                    port,
                    &egrTsTaiNumGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(egrTsTaiNum, egrTsTaiNumGet,
                                        devNum, port);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port             = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        egrTsTaiNum = 0;

        st = cpssDxChPtpTsDelayEgressTimestampTaiSelectSet(
                devNum,
                port,
                egrTsTaiNum);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    egrTsTaiNum = 0;
    port        = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                   UTF_LION2_E | UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_IRONMAN_L_E);

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayEgressTimestampTaiSelectSet(
                devNum,
                port,
                egrTsTaiNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayEgressTimestampTaiSelectSet(
            devNum,
            port,
            egrTsTaiNum);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_BOOL                 *ingrCorrFldPBEnablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with non-null ingrCorrFldPBEnablePtr.
    Expected: GT_OK
    1.1.2 Call with null ingrCorrFldPBEnablePtr.
    Expected: GT_BAD_PTR
*/
    GT_STATUS                         st      = GT_OK;
    GT_U8                             devNum  = 0;
    UTF_PHYSICAL_PORT_NUM             port;
    GT_BOOL                            ingrCorrFldPBEnable;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with non-null ingrCorrFldPBEnable.
                Expected: GT_OK
            */
            st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet(
                    devNum,
                    port,
                    &ingrCorrFldPBEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2 Call with null ingrCorrFldPBEnable.
                Expected: GT_BAD_PARAM
            */
            st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet(
                    devNum,
                    port,
                    NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet(
                devNum,
                port,
                &ingrCorrFldPBEnable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet(
                devNum,
                port,
                &ingrCorrFldPBEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet(
            devNum,
            port,
            &ingrCorrFldPBEnable);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableSet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_BOOL                 ingrCorrFldPBEnable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with ingrCorrFldPBEnable [GT_TRUE / GT_FALSE]
    Expected: GT_OK
    1.1.2. Call cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.2. For active device for out of bound value for port number.
*/
    GT_STATUS                     st      =  GT_OK;
    GT_U8                         devNum  =  0;
    UTF_PHYSICAL_PORT_NUM         port;
    GT_BOOL                       ingrCorrFldPBEnable;
    GT_BOOL                       ingrCorrFldPBEnableGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with ingrCorrFldPBEnable [GT_TRUE]
                Expected: GT_OK
            */
            ingrCorrFldPBEnable = GT_TRUE;
            st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableSet(
                    devNum,
                    port,
                    ingrCorrFldPBEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call
                        cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet(
                    devNum,
                    port,
                    &ingrCorrFldPBEnableGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(ingrCorrFldPBEnable,
                                        ingrCorrFldPBEnableGet,
                                        devNum,
                                        port);

            /*
                1.1.1 Call with ingrCorrFldPBEnable [GT_FALSE]
                Expected: GT_OK
            */
            ingrCorrFldPBEnable = GT_FALSE;
            st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableSet(
                    devNum,
                    port,
                    ingrCorrFldPBEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call
                    cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet(
                    devNum,
                    port,
                    &ingrCorrFldPBEnableGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(ingrCorrFldPBEnable,
                                        ingrCorrFldPBEnableGet,
                                        devNum,
                                        port);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port                = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        ingrCorrFldPBEnable = GT_TRUE;

        st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableSet(
                devNum,
                port,
                ingrCorrFldPBEnable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port                = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
    ingrCorrFldPBEnable = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableSet(
                devNum,
                port,
                ingrCorrFldPBEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableSet(
            devNum,
            port,
            ingrCorrFldPBEnable);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayIngressPortDelayGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_32                   *ingressDelayCorrPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayIngressPortDelayGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with non-null ingressDelayCorrPtr.
    Expected: GT_OK
    1.1.2 Call with null ingressDelayCorrPtr.
    Expected: GT_BAD_PTR
*/
    GT_STATUS                         st      =  GT_OK;
    GT_U8                             devNum  =  0;
    UTF_PHYSICAL_PORT_NUM             port;
    GT_32                             ingressDelayCorr;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with non-null ingressDelayCorr.
                Expected: GT_OK
            */
            st = cpssDxChPtpTsDelayIngressPortDelayGet(devNum,
                                                       port,
                                                       &ingressDelayCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2 Call with null ingressDelayCorr.
                Expected: GT_BAD_PARAM
            */
            st = cpssDxChPtpTsDelayIngressPortDelayGet(devNum,
                                                       port,
                                                       NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsDelayIngressPortDelayGet(devNum,
                                                   port,
                                                   &ingressDelayCorr);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port          = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayIngressPortDelayGet(devNum,
                                                   port,
                                                   &ingressDelayCorr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayIngressPortDelayGet(devNum,
                                               port,
                                               &ingressDelayCorr);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayIngressPortDelaySet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_32                   ingressDelayCorr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayIngressPortDelaySet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with ingressDelayCorr [0 / 65535 / 2147483647]
    Expected: GT_OK
    1.1.2. Call cpssDxChPtpTsDelayIngressPortDelayGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.2. For active device for out of bound value for port number.
*/
    GT_STATUS                     st      =  GT_OK;
    GT_U8                         devNum  =  0;
    UTF_PHYSICAL_PORT_NUM         port;
    GT_32                        ingressDelayCorr;
    GT_32                        ingressDelayCorrGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with ingressDelayCorr [0]
                Expected: GT_OK
            */
            ingressDelayCorr = 0;
            st = cpssDxChPtpTsDelayIngressPortDelaySet(devNum,
                                                       port,
                                                       ingressDelayCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call cpssDxChPtpTsDelayIngressPortDelayGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayIngressPortDelayGet(devNum,
                                                       port,
                                                       &ingressDelayCorrGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(ingressDelayCorr, ingressDelayCorrGet,
                                        devNum, port);
            /*
                1.1.1 Call with ingressDelayCorr [65536]
                Expected: GT_OK
            */
            ingressDelayCorr = 65536;
            st = cpssDxChPtpTsDelayIngressPortDelaySet(devNum,
                                                       port,
                                                       ingressDelayCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call cpssDxChPtpTsDelayIngressPortDelayGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsDelayIngressPortDelayGet(devNum,
                                                       port,
                                                       &ingressDelayCorrGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(ingressDelayCorr, ingressDelayCorrGet,
                                        devNum, port);
            /*
                1.1.1 Call with ingressDelayCorr [2147483647]
                Expected: GT_OUT_OF_RANGE
            */
            ingressDelayCorr = 2147483647;
            st = cpssDxChPtpTsDelayIngressPortDelaySet(devNum,
                                                       port,
                                                       ingressDelayCorr);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port             = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        ingressDelayCorr = 0;

        st = cpssDxChPtpTsDelayIngressPortDelaySet(devNum,
                                                   port,
                                                   ingressDelayCorr);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    ingressDelayCorr = 0;
    port             = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDelayIngressPortDelaySet(devNum,
                                                   port,
                                                   ingressDelayCorr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDelayIngressPortDelaySet(devNum,
                                               port,
                                               ingressDelayCorr);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayIngressLinkDelaySet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_U32                  domainProfile,
    IN  GT_32                   ingressDelay
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayIngressLinkDelaySet)
{
    GT_STATUS                     rc      =  GT_OK;
    GT_U8                         devNum  =  0;
    UTF_PHYSICAL_PORT_NUM         correctPort;
    UTF_PHYSICAL_PORT_NUM         outOfRangePort;
    UTF_PHYSICAL_PORT_NUM         port;
    GT_32                         ingressDelayGet;
    GT_U32                        i;
    struct
    {
        GT_STATUS               expectedRc;
        GT_BOOL                 isPortCorrect;
        GT_U32                  domainProfile;
        GT_32                   ingressDelay;
    } cases[] =
    {
        {GT_OK, GT_TRUE, 0, 0},
        {GT_OK, GT_TRUE, 5, -1000000000},
        {GT_OK, GT_TRUE, 7, 1000000000},
        {GT_OUT_OF_RANGE, GT_TRUE, 0, -1000000001},
        {GT_OUT_OF_RANGE, GT_TRUE, 0, 1000000001},
        {GT_BAD_PARAM, GT_FALSE, 0, 0},
        {GT_BAD_PARAM, GT_TRUE, 9, 0}
    };
    GT_U32 casesNum = (sizeof(cases) / sizeof(cases[0]));

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        rc = prvUtfNextPhyPortReset(&correctPort, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, rc);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&correctPort, GT_TRUE))
        {
            /* retieved first port */
            break;
        }
        outOfRangePort = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        for (i = 0; (i < casesNum); i++)
        {
            port = (cases[i].isPortCorrect == GT_TRUE) ? correctPort : outOfRangePort;
            rc = cpssDxChPtpTsDelayIngressLinkDelaySet(
                devNum, port,
                cases[i].domainProfile, cases[i].ingressDelay);
            UTF_VERIFY_EQUAL0_PARAM_MAC(cases[i].expectedRc, rc);
            if (rc != GT_OK) continue;

            rc = cpssDxChPtpTsDelayIngressLinkDelayGet(
                devNum, port,
                cases[i].domainProfile, &ingressDelayGet);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, rc);
            UTF_VERIFY_EQUAL0_PARAM_MAC(cases[i].ingressDelay, ingressDelayGet);
        }
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        rc = cpssDxChPtpTsDelayIngressLinkDelaySet(
            devNum, 0/*port*/, 0 /*domainProfile*/, 0/*ingressDelay*/);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, rc, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    rc = cpssDxChPtpTsDelayIngressLinkDelaySet(
        devNum, 0/*port*/, 0 /*domainProfile*/, 0/*ingressDelay*/);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, rc, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDelayIngressLinkDelayGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_U32                  domainProfile,
    OUT GT_32                   *ingressDelayPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDelayIngressLinkDelayGet)
{
    GT_STATUS                     rc      =  GT_OK;
    GT_U8                         devNum  =  0;
    UTF_PHYSICAL_PORT_NUM         port;
    UTF_PHYSICAL_PORT_NUM         correctPort;
    UTF_PHYSICAL_PORT_NUM         outOfRangePort;
    GT_32                         ingressDelay;
    GT_32                         *ingressDelayPtr;
    GT_U32                        i;
    struct
    {
        GT_STATUS               expectedRc;
        GT_BOOL                 isPortCorrect;
        GT_U32                  domainProfile;
        GT_BOOL                 isCorrectDelayPtr;
    } cases[] =
    {
        {GT_OK, GT_TRUE, 0, GT_TRUE},
        {GT_OK, GT_TRUE, 8, GT_TRUE},
        {GT_BAD_PARAM, GT_TRUE, 9, GT_TRUE},
        {GT_BAD_PTR, GT_TRUE, 0, GT_FALSE},
        {GT_BAD_PARAM, GT_FALSE, 0, GT_TRUE}
    };
    GT_U32 casesNum = (sizeof(cases) / sizeof(cases[0]));

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        rc = prvUtfNextPhyPortReset(&correctPort, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, rc);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&correctPort, GT_TRUE))
        {
            /* retieved first port */
            break;
        }
        outOfRangePort = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        for (i = 0; (i < casesNum); i++)
        {
            port = (cases[i].isPortCorrect == GT_TRUE)
                ? correctPort : outOfRangePort;
            ingressDelayPtr = (cases[i].isCorrectDelayPtr == GT_TRUE)
                ? &ingressDelay : NULL;
            rc = cpssDxChPtpTsDelayIngressLinkDelayGet(
                devNum, port,
                cases[i].domainProfile, ingressDelayPtr);
            UTF_VERIFY_EQUAL0_PARAM_MAC(cases[i].expectedRc, rc);
        }
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        rc = cpssDxChPtpTsDelayIngressLinkDelayGet(
            devNum, 0/*port*/, 0 /*domainProfile*/, &ingressDelay);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, rc, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    rc = cpssDxChPtpTsDelayIngressLinkDelayGet(
        devNum, 0/*port*/, 0 /*domainProfile*/, &ingressDelay);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, rc, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsTagGlobalCfgGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_DXCH_PTP_TS_TAG_GLOBAL_CFG_STC *tsTagGlobalCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsTagGlobalCfgGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with non-null tsTagGlobalCfg
    Expected: GT_OK
    1.2 For active device for tsTagGlobalCfg[NULL]
    Expected: GT_BAD_PTR
*/
    GT_STATUS                           st      =  GT_OK;
    GT_U8                               devNum  =  0;
    CPSS_DXCH_PTP_TS_TAG_GLOBAL_CFG_STC tsTagGlobalCfg;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with non-null tsTagGlobalCfg
            Expected: GT_OK
        */

        tsTagGlobalCfg.tsTagParseEnable       = GT_TRUE;
        tsTagGlobalCfg.hybridTsTagParseEnable = GT_TRUE;
        tsTagGlobalCfg.tsTagEtherType         = 0x0;
        tsTagGlobalCfg.hybridTsTagEtherType   = 0x0;

        st = cpssDxChPtpTsTagGlobalCfgGet(devNum, &tsTagGlobalCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);


        /*
            1.2 For active device for tsTagGlobalCfg[NULL]
            Expected: GT_BAD_PTR
        */
        st = cpssDxChPtpTsTagGlobalCfgGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /*set port valid value*/
    tsTagGlobalCfg.tsTagParseEnable       = GT_TRUE;
    tsTagGlobalCfg.hybridTsTagParseEnable = GT_TRUE;
    tsTagGlobalCfg.tsTagEtherType         = 0x0;
    tsTagGlobalCfg.hybridTsTagEtherType   = 0x0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsTagGlobalCfgGet(devNum, &tsTagGlobalCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsTagGlobalCfgGet(devNum, &tsTagGlobalCfg);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*
GT_STATUS cpssDxChPtpTsTagGlobalCfgSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_DXCH_PTP_TS_TAG_GLOBAL_CFG_STC *tsTagGlobalCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsTagGlobalCfgSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with tsTagGlobalCfg{
                        tsTagParseEnable       [GT_TRUE / GT_FALSE],
                        hybridTsTagParseEnable [GT_TRUE / GT_FALSE],
                        tsTagEtherType         [0x0 / 0xFF / 0xFFFF],
                        hybridTsTagEtherType   [0x0 / 0xFF / 0xFFFF]
                                }
    Expected: GT_OK
    1.2 For active device for egrAsymmetryCorr[NULL]
    Expected: GT_BAD_PTR
    1.3 Call function with out of bound value for
    tsTagEtherType and hybridTsTagEtherType
    Expected: GT_BAD_PARAM
*/
    GT_STATUS                           st      =  GT_OK;
    GT_U8                               devNum  =  0;
    CPSS_DXCH_PTP_TS_TAG_GLOBAL_CFG_STC tsTagGlobalCfg;
    CPSS_DXCH_PTP_TS_TAG_GLOBAL_CFG_STC tsTagGlobalCfgGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with tsTagGlobalCfg{
                                tsTagParseEnable       [GT_TRUE],
                                hybridTsTagParseEnable [GT_TRUE],
                                tsTagEtherType         [0x0],
                                hybridTsTagEtherType   [0x0]
                                        }
            Expected: GT_OK
        */

        tsTagGlobalCfg.tsTagParseEnable       = GT_TRUE;
        tsTagGlobalCfg.hybridTsTagParseEnable = GT_TRUE;
        tsTagGlobalCfg.tsTagEtherType         = 0x0;
        tsTagGlobalCfg.hybridTsTagEtherType   = 0x0;

        st = cpssDxChPtpTsTagGlobalCfgSet(devNum, &tsTagGlobalCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1.2. Call cpssDxChPtpTsTagGlobalCfgGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsTagGlobalCfgGet(devNum, &tsTagGlobalCfgGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.tsTagParseEnable,
                                    tsTagGlobalCfgGet.tsTagParseEnable,
                                    devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.hybridTsTagParseEnable,
                                    tsTagGlobalCfgGet.hybridTsTagParseEnable,
                                    devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.tsTagEtherType,
                                    tsTagGlobalCfgGet.tsTagEtherType,
                                    devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.hybridTsTagEtherType,
                                    tsTagGlobalCfgGet.hybridTsTagEtherType,
                                    devNum);

        /*
            1.1 Call with tsTagGlobalCfg{
                                tsTagParseEnable       [GT_FALSE],
                                hybridTsTagParseEnable [GT_FALSE],
                                tsTagEtherType         [0xFF],
                                hybridTsTagEtherType   [0xFF]
                                        }
            Expected: GT_OK
        */

        tsTagGlobalCfg.tsTagParseEnable       = GT_FALSE;
        tsTagGlobalCfg.hybridTsTagParseEnable = GT_FALSE;
        tsTagGlobalCfg.tsTagEtherType         = 0xFF;
        tsTagGlobalCfg.hybridTsTagEtherType   = 0xFF;

        st = cpssDxChPtpTsTagGlobalCfgSet(devNum, &tsTagGlobalCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1.2. Call cpssDxChPtpTsTagGlobalCfgGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsTagGlobalCfgGet(devNum, &tsTagGlobalCfgGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.tsTagParseEnable,
                                    tsTagGlobalCfgGet.tsTagParseEnable,
                                    devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.hybridTsTagParseEnable,
                                    tsTagGlobalCfgGet.hybridTsTagParseEnable,
                                    devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.tsTagEtherType,
                                    tsTagGlobalCfgGet.tsTagEtherType,
                                    devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.hybridTsTagEtherType,
                                    tsTagGlobalCfgGet.hybridTsTagEtherType,
                                    devNum);

        /*
            1.1 Call with tsTagGlobalCfg{
                                tsTagParseEnable       [GT_FALSE],
                                hybridTsTagParseEnable [GT_FALSE],
                                tsTagEtherType         [0xFFFF],
                                hybridTsTagEtherType   [0xFFFF]
                                        }
            Expected: GT_OK
        */

        tsTagGlobalCfg.tsTagParseEnable       = GT_FALSE;
        tsTagGlobalCfg.hybridTsTagParseEnable = GT_FALSE;
        tsTagGlobalCfg.tsTagEtherType         = 0xFFFF;
        tsTagGlobalCfg.hybridTsTagEtherType   = 0xFFFF;

        st = cpssDxChPtpTsTagGlobalCfgSet(devNum, &tsTagGlobalCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1.2. Call cpssDxChPtpTsTagGlobalCfgGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsTagGlobalCfgGet(devNum, &tsTagGlobalCfgGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.tsTagParseEnable,
                                    tsTagGlobalCfgGet.tsTagParseEnable,
                                    devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.hybridTsTagParseEnable,
                                    tsTagGlobalCfgGet.hybridTsTagParseEnable,
                                    devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.tsTagEtherType,
                                    tsTagGlobalCfgGet.tsTagEtherType,
                                    devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(tsTagGlobalCfg.hybridTsTagEtherType,
                                    tsTagGlobalCfgGet.hybridTsTagEtherType,
                                    devNum);

        /*
            1.2 For active device for egrAsymmetryCorr[NULL]
            Expected: GT_BAD_PTR
        */
        tsTagGlobalCfg.tsTagParseEnable       = GT_FALSE;
        tsTagGlobalCfg.hybridTsTagParseEnable = GT_FALSE;
        tsTagGlobalCfg.tsTagEtherType         = 0x0;
        tsTagGlobalCfg.hybridTsTagEtherType   = 0x0;

        st = cpssDxChPtpTsTagGlobalCfgSet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);

        /*
            1.3 Call function with out of bound value for
            tsTagEtherType and hybridTsTagEtherType
            Expected: GT_BAD_PARAM
        */
        tsTagGlobalCfg.tsTagParseEnable       = GT_FALSE;
        tsTagGlobalCfg.hybridTsTagParseEnable = GT_FALSE;
        tsTagGlobalCfg.tsTagEtherType         = 0xFFFFFF;
        tsTagGlobalCfg.hybridTsTagEtherType   = 0xFFFFFF;

        st = cpssDxChPtpTsTagGlobalCfgSet(devNum, &tsTagGlobalCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
    }

   /*set port valid value*/
    tsTagGlobalCfg.tsTagParseEnable       = GT_TRUE;
    tsTagGlobalCfg.hybridTsTagParseEnable = GT_TRUE;
    tsTagGlobalCfg.tsTagEtherType         = 0x0;
    tsTagGlobalCfg.hybridTsTagEtherType   = 0x0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsTagGlobalCfgSet(devNum, &tsTagGlobalCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsTagGlobalCfgSet(devNum, &tsTagGlobalCfg);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsTagPortCfgGet
(
    IN  GT_U8                               devNum,
    IN  GT_PHYSICAL_PORT_NUM                portNum,
    OUT CPSS_DXCH_PTP_TS_TAG_PORT_CFG_STC   *tsTagPortCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsTagPortCfgGet)
{
    /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1.1 Call with non-null ntpTimeOffsetPtr.
        Expected: GT_OK
        1.1.2 Call with null ntpTimeOffsetPtr.
        Expected: GT_BAD_PTR
    */
    GT_STATUS                         st      =  GT_OK;
    GT_U8                             devNum  =  0;
    UTF_PHYSICAL_PORT_NUM             port;
    CPSS_DXCH_PTP_TS_TAG_PORT_CFG_STC tsTagPortCfg;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with non-null ntpTimeOffsetPtr.
                Expected: GT_OK
            */
            st = cpssDxChPtpTsTagPortCfgGet(devNum,
                                            port,
                                            &tsTagPortCfg);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2 Call with null tsTagPortCfgPtr.
                Expected: GT_BAD_PTR
            */
            st = cpssDxChPtpTsTagPortCfgGet(devNum,
                                            port,
                                            NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsTagPortCfgGet(devNum,
                                        port,
                                        &tsTagPortCfg);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port          = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsTagPortCfgGet(devNum,
                                        port,
                                        &tsTagPortCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsTagPortCfgGet(devNum,
                                    port,
                                    &tsTagPortCfg);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsTagPortCfgSet
(
    IN  GT_U8                               devNum,
    IN  GT_PHYSICAL_PORT_NUM                portNum,
    IN  CPSS_DXCH_PTP_TS_TAG_PORT_CFG_STC   *tsTagPortCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsTagPortCfgSet)
{
   /*
        ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
        1.1 Call with tsTagPortCfg{
                        tsReceptionEnable [GT_TRUE / GT_FALSE],
                        tsPiggyBackEnable [GT_TRUE / GT_FALSE],
                        tsTagMode    [CPSS_DXCH_PTP_TS_TAG_MODE_NONE_E /
                                      CPSS_DXCH_PTP_TS_TAG_MODE_NON_EXTENDED_E /
                                      CPSS_DXCH_PTP_TS_TAG_MODE_HYBRID_E]
                                   }
        Expected: GT_OK
        1.1.2. Call cpssDxChPtpTsTagPortCfgGet().
        Expected: GT_OK and same mode as was set in 1.1.1.
        1.1.3 Call with null tsTagPortCfgPtr.
        Expected: GT_BAD_PTR
        1.2. For active device for out of bound value for port number.
        Expected: GT_BAD_PARAM
    */
    GT_STATUS                         st      =  GT_OK;
    GT_U8                             devNum  =  0;
    UTF_PHYSICAL_PORT_NUM             port;
    CPSS_DXCH_PTP_TS_TAG_PORT_CFG_STC tsTagPortCfg;
    CPSS_DXCH_PTP_TS_TAG_PORT_CFG_STC tsTagPortCfgGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1 Call with tsTagPortCfg{
                                tsReceptionEnable [GT_TRUE],
                                tsPiggyBackEnable [GT_TRUE],
                                tsTagMode     [CPSS_DXCH_PTP_TS_TAG_MODE_NONE_E]
                                           }
                Expected: GT_OK
            */
            tsTagPortCfg.tsReceptionEnable = GT_TRUE;
            tsTagPortCfg.tsPiggyBackEnable = GT_TRUE;
            tsTagPortCfg.tsTagMode         = CPSS_DXCH_PTP_TS_TAG_MODE_NONE_E;

            st = cpssDxChPtpTsTagPortCfgSet(devNum,
                                            port,
                                            &tsTagPortCfg);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsTagPortCfgGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */

            st = cpssDxChPtpTsTagPortCfgGet(devNum,
                                            port,
                                            &tsTagPortCfgGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsReceptionEnable,
                                        tsTagPortCfgGet.tsReceptionEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsPiggyBackEnable,
                                        tsTagPortCfgGet.tsPiggyBackEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsTagMode,
                                        tsTagPortCfgGet.tsTagMode,
                                        devNum, port);

            /*
                1.1 Call with tsTagPortCfg{
                                tsReceptionEnable [GT_FALSE],
                                tsPiggyBackEnable [GT_FALSE],
                                tsTagMode     [CPSS_DXCH_PTP_TS_TAG_MODE_NONE_E]
                                           }
                Expected: GT_OK
            */
            tsTagPortCfg.tsReceptionEnable = GT_FALSE;
            tsTagPortCfg.tsPiggyBackEnable = GT_FALSE;
            tsTagPortCfg.tsTagMode         = CPSS_DXCH_PTP_TS_TAG_MODE_NONE_E;

            st = cpssDxChPtpTsTagPortCfgSet(devNum,
                                            port,
                                            &tsTagPortCfg);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsTagPortCfgGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */

            st = cpssDxChPtpTsTagPortCfgGet(devNum,
                                            port,
                                            &tsTagPortCfgGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsReceptionEnable,
                                        tsTagPortCfgGet.tsReceptionEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsPiggyBackEnable,
                                        tsTagPortCfgGet.tsPiggyBackEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsTagMode,
                                        tsTagPortCfgGet.tsTagMode,
                                        devNum, port);

            /*
                1.1 Call with
                tsTagPortCfg{
                            tsReceptionEnable [GT_TRUE],
                            tsPiggyBackEnable [GT_TRUE],
                            tsTagMode [CPSS_DXCH_PTP_TS_TAG_MODE_NON_EXTENDED_E]
                            }
                Expected: GT_OK
            */
            tsTagPortCfg.tsReceptionEnable = GT_TRUE;
            tsTagPortCfg.tsPiggyBackEnable = GT_TRUE;
            tsTagPortCfg.tsTagMode         = CPSS_DXCH_PTP_TS_TAG_MODE_NON_EXTENDED_E;

            st = cpssDxChPtpTsTagPortCfgSet(devNum,
                                            port,
                                            &tsTagPortCfg);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsTagPortCfgGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */

            st = cpssDxChPtpTsTagPortCfgGet(devNum,
                                            port,
                                            &tsTagPortCfgGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsReceptionEnable,
                                        tsTagPortCfgGet.tsReceptionEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsPiggyBackEnable,
                                        tsTagPortCfgGet.tsPiggyBackEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsTagMode,
                                        tsTagPortCfgGet.tsTagMode,
                                        devNum, port);

            /*
                1.1 Call with
                tsTagPortCfg{
                    tsReceptionEnable [GT_FALSE],
                    tsPiggyBackEnable [GT_FALSE],
                    tsTagMode         [CPSS_DXCH_PTP_TS_TAG_MODE_NON_EXTENDED_E]
                            }
                Expected: GT_OK
            */
            tsTagPortCfg.tsReceptionEnable = GT_FALSE;
            tsTagPortCfg.tsPiggyBackEnable = GT_FALSE;
            tsTagPortCfg.tsTagMode         =
                            CPSS_DXCH_PTP_TS_TAG_MODE_NON_EXTENDED_E;

            st = cpssDxChPtpTsTagPortCfgSet(devNum,
                                            port,
                                            &tsTagPortCfg);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsTagPortCfgGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */

            st = cpssDxChPtpTsTagPortCfgGet(devNum,
                                            port,
                                            &tsTagPortCfgGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsReceptionEnable,
                                        tsTagPortCfgGet.tsReceptionEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsPiggyBackEnable,
                                        tsTagPortCfgGet.tsPiggyBackEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsTagMode,
                                        tsTagPortCfgGet.tsTagMode,
                                        devNum, port);
            /*
                1.1 Call with tsTagPortCfg{
                                tsReceptionEnable [GT_TRUE],
                                tsPiggyBackEnable [GT_TRUE],
                                tsTagMode   [CPSS_DXCH_PTP_TS_TAG_MODE_HYBRID_E]
                                           }
                Expected: GT_OK
            */
            tsTagPortCfg.tsReceptionEnable = GT_TRUE;
            tsTagPortCfg.tsPiggyBackEnable = GT_TRUE;
            tsTagPortCfg.tsTagMode         = CPSS_DXCH_PTP_TS_TAG_MODE_HYBRID_E;

            st = cpssDxChPtpTsTagPortCfgSet(devNum,
                                            port,
                                            &tsTagPortCfg);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsTagPortCfgGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */

            st = cpssDxChPtpTsTagPortCfgGet(devNum,
                                            port,
                                            &tsTagPortCfgGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsReceptionEnable,
                                        tsTagPortCfgGet.tsReceptionEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsPiggyBackEnable,
                                        tsTagPortCfgGet.tsPiggyBackEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsTagMode,
                                        tsTagPortCfgGet.tsTagMode,
                                        devNum, port);

            /*
                1.1 Call with tsTagPortCfg{
                                tsReceptionEnable [GT_FALSE],
                                tsPiggyBackEnable [GT_FALSE],
                                tsTagMode   [CPSS_DXCH_PTP_TS_TAG_MODE_HYBRID_E]
                                           }
                Expected: GT_OK
            */
            tsTagPortCfg.tsReceptionEnable = GT_FALSE;
            tsTagPortCfg.tsPiggyBackEnable = GT_FALSE;
            tsTagPortCfg.tsTagMode         = CPSS_DXCH_PTP_TS_TAG_MODE_HYBRID_E;

            st = cpssDxChPtpTsTagPortCfgSet(devNum,
                                            port,
                                            &tsTagPortCfg);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsTagPortCfgGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */

            st = cpssDxChPtpTsTagPortCfgGet(devNum,
                                            port,
                                            &tsTagPortCfgGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsReceptionEnable,
                                        tsTagPortCfgGet.tsReceptionEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsPiggyBackEnable,
                                        tsTagPortCfgGet.tsPiggyBackEnable,
                                        devNum, port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(tsTagPortCfg.tsTagMode,
                                        tsTagPortCfgGet.tsTagMode,
                                        devNum, port);

            /*
                1.1.3 Call with null tsTagPortCfgPtr.
                Expected: GT_BAD_PTR
            */
            st = cpssDxChPtpTsTagPortCfgSet(devNum,
                                            port,
                                            NULL);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, devNum, port);
        }

        tsTagPortCfg.tsReceptionEnable = GT_TRUE;
        tsTagPortCfg.tsPiggyBackEnable = GT_TRUE;
        tsTagPortCfg.tsTagMode         = CPSS_DXCH_PTP_TS_TAG_MODE_NONE_E;

        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsTagPortCfgSet(devNum,
                                        port,
                                        &tsTagPortCfg);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid parameters*/
    port                             = 0;
    tsTagPortCfg.tsReceptionEnable = GT_TRUE;
    tsTagPortCfg.tsPiggyBackEnable = GT_TRUE;
    tsTagPortCfg.tsTagMode         = CPSS_DXCH_PTP_TS_TAG_MODE_NONE_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsTagPortCfgSet(devNum,
                                        port,
                                        &tsTagPortCfg);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum, port);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsTagPortCfgSet(devNum,
                                    port,
                                    &tsTagPortCfg);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuControlGet
(
    IN  GT_U8                             devNum,
    IN  GT_PHYSICAL_PORT_NUM              portNum,
    OUT CPSS_DXCH_PTP_TSU_CONTROL_STC     *controlPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuControlGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with non-null controlPrt.
    Expected: GT_OK
    1.1.2 Call with null controlPrt.
    Expected: GT_BAD_PTR
*/
    GT_STATUS                          st      =  GT_OK;
    GT_U8                             devNum  =  0;
    UTF_PHYSICAL_PORT_NUM             port;
    CPSS_DXCH_PTP_TSU_CONTROL_STC     control = {GT_TRUE, 0};

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            if(prvCpssDxChPortRemotePortCheck(devNum, port))
            {
                st = cpssDxChPtpTsuControlGet(devNum,
                                              port,
                                              &control);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
                continue;
            }

            /*
                1.1.1 Call with non-null controlPrt.
                Expected: GT_OK
            */
            st = cpssDxChPtpTsuControlGet(devNum,
                                          port,
                                          &control);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2 Call with null controlPrt.
                Expected: GT_BAD_PTR
            */
            st = cpssDxChPtpTsuControlGet(devNum,
                                          port,
                                          NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsuControlGet(devNum,
                                      port,
                                      &control);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    control.unitEnable          = GT_TRUE;
    control.taiNumber           = 0;
    port                                 = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsuControlGet(devNum,
                                      port,
                                      &control);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsuControlGet(devNum,
                                  port,
                                  &control);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuControlSet
(
    IN  GT_U8                             devNum,
    IN  GT_PHYSICAL_PORT_NUM              portNum,
    IN  CPSS_DXCH_PTP_TSU_CONTROL_STC     *controlPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuControlSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with controlPtr {
                        control.unitEnable          [GT_TRUE / GT_FALSE]
                        control.taiNumber         [0 / 1]
                                }
    Expected: GT_OK
    1.1.2. Call cpssDxChPtpTsuControlGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.1.3 Call with null controlPrt.
    Expected: GT_BAD_PTR
*/
    GT_STATUS                      st      =  GT_OK;
    GT_U8                         devNum  =  0;
    UTF_PHYSICAL_PORT_NUM         port;
    CPSS_DXCH_PTP_TSU_CONTROL_STC control = {GT_TRUE, 0};
    CPSS_DXCH_PTP_TSU_CONTROL_STC controlGet;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with controlPtr {
                                    control.unitEnable          [GT_TRUE]
                                    control.taiNumber         [0]
                                            }
                Expected: GT_OK
            */
            control.unitEnable          = GT_TRUE;
            control.taiNumber          = 0;
            if(prvCpssDxChPortRemotePortCheck(devNum, port))
            {
                st = cpssDxChPtpTsuControlSet(devNum,
                                              port,
                                              &control);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
                continue;
            }

            st = cpssDxChPtpTsuControlSet(devNum,
                                          port,
                                          &control);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            control.unitEnable          = GT_TRUE;
            control.taiNumber          = 1;

            st = cpssDxChPtpTsuControlSet(devNum,
                                          port,
                                          &control);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);


            /*
                1.1.2. Call cpssDxChPtpTsuControlGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */

            st = cpssDxChPtpTsuControlGet(devNum,
                                          port,
                                          &controlGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(control.unitEnable,
                                        controlGet.unitEnable,
                                        devNum,
                                        port);

            if (!(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_IRONMAN_E))
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(control.taiNumber,
                                            controlGet.taiNumber,
                                            devNum,
                                            port);
            }

            /*
                1.1.1 Call with controlPtr {
                                    control.unitEnable          [GT_FALSE]
                                    control.taiNumber          [0]
                                            }
                Expected: GT_OK
            */
            control.unitEnable          = GT_FALSE;
            control.taiNumber          = 0;

            st = cpssDxChPtpTsuControlSet(devNum,
                                          port,
                                          &control);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2. Call cpssDxChPtpTsuControlGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */

            st = cpssDxChPtpTsuControlGet(devNum,
                                          port,
                                          &controlGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL2_PARAM_MAC(control.unitEnable,
                                        controlGet.unitEnable,
                                        devNum,
                                        port);
            UTF_VERIFY_EQUAL2_PARAM_MAC(control.taiNumber,
                                        controlGet.taiNumber,
                                        devNum,
                                        port);

            /*
                1.1.3 Call with null controlPrt.
                Expected: GT_BAD_PARAM
            */
            st = cpssDxChPtpTsuControlSet(devNum,
                                          port,
                                          NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsuControlSet(devNum,
                                      port,
                                      &control);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    control.unitEnable          = GT_TRUE;
    control.taiNumber          = 0;
    port                         = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsuControlSet(devNum,
                                      port,
                                      &control);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsuControlSet(devNum,
                                  port,
                                  &control);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuCountersClear
(
    IN  GT_U8                             devNum,
    IN  GT_PHYSICAL_PORT_NUM              portNum
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuCountersClear)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. For all active devices go over all available physical ports.
    1.2. For active device for out of bound value for port number.
*/
    GT_STATUS              st      =  GT_OK;
    GT_U8                  devNum  =  0;
    UTF_PHYSICAL_PORT_NUM  port;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            if(prvCpssDxChPortRemotePortCheck(devNum, port))
            {
                st = cpssDxChPtpTsuCountersClear(devNum, port);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
                continue;
            }

            st = cpssDxChPtpTsuCountersClear(devNum, port);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsuCountersClear(devNum, port);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsuCountersClear(devNum, port);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsuCountersClear(devNum, port);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuNtpTimeOffsetGet
(
    IN  GT_U8                             devNum,
    IN  GT_PHYSICAL_PORT_NUM              portNum,
    OUT GT_U32                            *ntpTimeOffsetPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuNtpTimeOffsetGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with non-null ntpTimeOffsetPtr.
    Expected: GT_OK
    1.1.2 Call with null ntpTimeOffsetPtr.
    Expected: GT_BAD_PTR
*/
    GT_STATUS                         st      =  GT_OK;
    GT_U8                             devNum  =  0;
    UTF_PHYSICAL_PORT_NUM             port;
    GT_U32                            ntpTimeOffset;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            if(prvCpssDxChPortRemotePortCheck(devNum, port))
            {
                st = cpssDxChPtpTsuNtpTimeOffsetGet(devNum,
                                                    port,
                                                    &ntpTimeOffset);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
                continue;
            }

            /*
                1.1.1 Call with non-null ntpTimeOffsetPtr.
                Expected: GT_OK
            */
            st = cpssDxChPtpTsuNtpTimeOffsetGet(devNum,
                                                port,
                                                &ntpTimeOffset);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2 Call with null ntpTimeOffsetPtr.
                Expected: GT_BAD_PARAM
            */
            st = cpssDxChPtpTsuNtpTimeOffsetGet(devNum,
                                                port,
                                                NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }

        /* 1.2. For active device for out of bound value for port number.*/
        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsuNtpTimeOffsetGet(devNum,
                                            port,
                                            &ntpTimeOffset);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port          = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsuNtpTimeOffsetGet(devNum,
                                            port,
                                            &ntpTimeOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsuNtpTimeOffsetGet(devNum,
                                        port,
                                        &ntpTimeOffset);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuPacketCounterGet
(
    IN  GT_U8                                     devNum,
    IN  GT_PHYSICAL_PORT_NUM                      portNum,
    IN  CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_ENT counterType,
    IN  GT_U32                                    index, (for Falcon only)
    OUT GT_U32                                    *valuePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuPacketCounterGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with counterType
    [CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_TOTAL_E   /
     CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_FORWARD_E /
     CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_CAPTURE_INGRESS_TIME_E]
    Expected: GT_OK
    1.1.2 Call with NULL value
    Expected: GT_BAD_PTR
    1.2  Call with counterType out of range
         and other params from 1.1.1.
    Expected: GT_BAD_PARAM.
    1.3. For active device for out of bound value for port number.
*/
    GT_STATUS                                 st      =  GT_OK;
    GT_U8                                     devNum  =  0;
    UTF_PHYSICAL_PORT_NUM                     port;
    CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_ENT counterType;
    GT_U32                                    value;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with counterType
                [CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_TOTAL_E]
                Expected: GT_OK
            */
            counterType = CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_TOTAL_E;
            if(prvCpssDxChPortRemotePortCheck(devNum, port))
            {
                st = cpssDxChPtpTsuPacketCounterGet(devNum,
                                                    port,
                                                    counterType,
                                                    0,
                                                    &value);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
                continue;
            }

            st = cpssDxChPtpTsuPacketCounterGet(devNum,
                                                port,
                                                counterType,
                                                0,
                                                &value);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.1 Call with counterType
                [CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_FORWARD_E]
                Expected: GT_OK
            */
            counterType = CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_FORWARD_E;

            st = cpssDxChPtpTsuPacketCounterGet(devNum,
                                                port,
                                                counterType,
                                                0,
                                                &value);
            if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);
            }

            /*
                1.1.1 Call with counterType
                [CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_CAPTURE_INGRESS_TIME_E]
                Expected: GT_OK
            */
            counterType =
                   CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_CAPTURE_INGRESS_TIME_E;

            st = cpssDxChPtpTsuPacketCounterGet(devNum,
                                                port,
                                                counterType,
                                                0,
                                                &value);
            if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);
            }

            /*
                1.1.2 Call with NULL value
                Expected: GT_BAD_PARAM
            */
            counterType = CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_TOTAL_E;

            st = cpssDxChPtpTsuPacketCounterGet(devNum,
                                                port,
                                                counterType,
                                                0,
                                                NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }

        /*
           1.2  Call with counterType out of range
                 and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        /* set valid parameters*/
        port        = 0;
        counterType = CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_TOTAL_E;
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsuPacketCounterGet
                            (devNum, port, counterType, 0, &value),
                            counterType);

        /* 1.3. For active device for out of bound value for port number.*/
        counterType = CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_TOTAL_E;
        port        = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpTsuPacketCounterGet(devNum,
                                            port,
                                            counterType,
                                            0,
                                            &value);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set port valid value*/
    port        = 0;
    counterType = CPSS_DXCH_PTP_TSU_PACKET_COUNTER_TYPE_TOTAL_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsuPacketCounterGet(devNum,
                                            port,
                                            counterType,
                                            0,
                                            &value);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsuPacketCounterGet(devNum,
                                        port,
                                        counterType,
                                        0,
                                        &value);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuTxTimestampQueueRead
(
    IN  GT_U8                                              devNum,
    IN  GT_PHYSICAL_PORT_NUM                               portNum,
    IN  GT_U32                                             queueNum,
    OUT CPSS_DXCH_PTP_TSU_TX_TIMESTAMP_QUEUE_ENTRY_STC     *entryPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuTxTimestampQueueRead)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with queueNum [0 / 1]
    Expected: GT_OK
    1.1.2 Call with null entry
    Expected: GT_BAD_PTR
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
*/

    GT_STATUS                                      st      =  GT_OK;
    GT_U8                                          devNum  =  0;
    UTF_PHYSICAL_PORT_NUM                          port;
    CPSS_DXCH_PTP_TSU_TX_TIMESTAMP_QUEUE_ENTRY_STC entry;
    GT_U32                                         queueNum;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with queueNum [0]
                Expected: GT_OK
            */
            queueNum = 0;
            if(prvCpssDxChPortRemotePortCheck(devNum, port))
            {
                st = cpssDxChPtpTsuTxTimestampQueueRead(devNum,
                                                        port,
                                                        queueNum,
                                                        &entry);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
                continue;
            }

            st = cpssDxChPtpTsuTxTimestampQueueRead(devNum,
                                                    port,
                                                    queueNum,
                                                    &entry);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.1 Call with queueNum [1]
                Expected: GT_OK
            */
            queueNum = 1;
            st = cpssDxChPtpTsuTxTimestampQueueRead(devNum,
                                                    port,
                                                    queueNum,
                                                    &entry);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2 Call with null entry
                Expected: GT_BAD_PTR
            */
            queueNum = 0; /*set valid queueNum*/
            st = cpssDxChPtpTsuTxTimestampQueueRead(devNum,
                                                    port,
                                                    queueNum,
                                                    NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }
        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        port     = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        queueNum = 0;
        st = cpssDxChPtpTsuTxTimestampQueueRead(devNum,
                                                port,
                                                queueNum,
                                                &entry);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }
    /*set port valid value*/
    queueNum = 0;
    port     = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsuTxTimestampQueueRead(devNum,
                                                port,
                                                queueNum,
                                                &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    queueNum = 0;
    st = cpssDxChPtpTsuTxTimestampQueueRead(devNum,
                                            port,
                                            queueNum,
                                            &entry);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsCfgTableSet
(
    IN  GT_U8                          devNum,
    IN  GT_U32                         entryIndex,
    IN  CPSS_DXCH_PTP_TS_CFG_ENTRY_STC *entryPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsCfgTableSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with
        entryIndex  [0 / 64 / 127]
        entry
        {
            tsMode         [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E |
                            CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E]
            offsetProfile  [0 / 64 / 127]
            OE             [GT_TRUE / GT_FALSE]
            tsAction       [CPSS_DXCH_PTP_TS_ACTION_NONE_E                   |
                            CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_TIME_E       |
                            CPSS_DXCH_PTP_TS_ACTION_ADD_CORRECTED_TIME_E]
            packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E   |
                            CPSS_DXCH_PTP_TS_PACKET_TYPE_NTP_TS_E    |
                            CPSS_DXCH_PTP_TS_PACKET_TYPE_WAMP_E]
            ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E |
                            CPSS_DXCH_PTP_TRANSPORT_TYPE_UDP_IPV4_E |
                            CPSS_DXCH_PTP_TRANSPORT_TYPE_UDP_IPV6_E]
            offset         [0 / 64 / 127]
            offset2        [254]            - Only for SIP6
            ptpMessageType [0 / 7 / 15]
            domain         [0 / 2 /4]
            ingrLinkDelayEnable     [GT_TRUE / GT_FALSE]
            packetDispatchingEnable [GT_TRUE / GT_FALSE]
        }
    Expected: GT_OK.
    1.2. Call cpssDxChPtpTsCfgTableGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.3. Call with
        entryIndex  [out of the range]
        entry
        {
            tsMode         [out of the range]
            offsetProfile  [out of the range]
            OE             [out of the range]
            tsAction       [out of the range]
            packetFormat   [out of the range]
            ptpTransport   [out of the range]
            offset         [out of the range]
            offset2        [out of the range]
            ptpMessageType [out of the range]
            domain         [out of the range]
            ingrLinkDelayEnable     [GT_TRUE]
            packetDispatchingEnable [GT_TRUE]
        }
    Expected: GT_BAD_PARAM.
    1.4. Call with null entryPtr
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                      st        = GT_OK;
    GT_U8                          devNum    = 0;
    GT_U32                         entryIndex;
    CPSS_DXCH_PTP_TS_CFG_ENTRY_STC entry;
    CPSS_DXCH_PTP_TS_CFG_ENTRY_STC entryGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {

        /*
            The sructure members vaues relevaltness depends from the
            "tsMode" value:
            tsMode                    - always
            offsetProfile             - MODIFY_TAG_E
            OE                        - MODIFY_TAG_E
            tsAction                  - DO_ACTION_E
            packetFormat              - DO_ACTION_E
            ptpTransport              - DO_ACTION_E
            offset                    - DO_ACTION_E
            ptpMessageType            - DO_ACTION_E
            domain                    - DO_ACTION_E
            ingrLinkDelayEnable       - always
            packetDispatchingEnable   - always
        */

        /*
            1.1 Call with
                entryIndex  [0]
                entry
                {
                    tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E]
                    tsAction       [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                    packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E]
                    ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E]
                    offset         [0]
                    ptpMessageType [0]
                    domain         [0]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: GT_OK.
        */

        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 0;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
        entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
        entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E;
        entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
        entry.offset         = 0;
        entry.ptpMessageType = 0;
        entry.domain         = 0;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsCfgTableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsCfgTableGet(devNum, entryIndex, &entryGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsMode, entryGet.tsMode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction, entryGet.tsAction, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetFormat, entryGet.packetFormat,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ptpTransport, entryGet.ptpTransport,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.offset, entryGet.offset, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ptpMessageType,
        entryGet.ptpMessageType, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.domain, entryGet.domain, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
            entryGet.ingrLinkDelayEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
            entryGet.packetDispatchingEnable, devNum);

        /*
            1.1. Call with
                entryIndex  [0]
                entry
                {
                    tsMode         [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E]
                    offsetProfile  [64]
                    OE             [GT_FALSE]
                    ingrLinkDelayEnable     [GT_FALSE]
                    packetDispatchingEnable [GT_FALSE]
                }
            Expected: GT_OK.
        */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 0;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E;
        entry.offsetProfile  = 64;
        entry.OE             = GT_FALSE;
        entry.ingrLinkDelayEnable     = GT_FALSE;
        entry.packetDispatchingEnable = GT_FALSE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsCfgTableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsCfgTableGet(devNum, entryIndex, &entryGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsMode, entryGet.tsMode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.offsetProfile, entryGet.offsetProfile,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.OE, entryGet.OE, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
            entryGet.ingrLinkDelayEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
            entryGet.packetDispatchingEnable, devNum);

        /*
            1.1. Call with
                entryIndex  [0]
                entry
                {
                    tsMode         [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E]
                    offsetProfile  [127]
                    OE             [GT_TRUE]
                    ingrLinkDelayEnable     [GT_FALSE]
                    packetDispatchingEnable [GT_FALSE]
                }
            Expected: GT_OK.
        */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 0;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E;
        entry.offsetProfile  = 127;
        entry.OE             = GT_TRUE;
        entry.ingrLinkDelayEnable     = GT_FALSE;
        entry.packetDispatchingEnable = GT_FALSE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsCfgTableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsCfgTableGet(devNum, entryIndex, &entryGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsMode, entryGet.tsMode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.offsetProfile, entryGet.offsetProfile,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.OE, entryGet.OE, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
            entryGet.ingrLinkDelayEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
            entryGet.packetDispatchingEnable, devNum);

        /*
            1.1 Call with
                entryIndex  [64]
                entry
                {
                    tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E]
                    offsetProfile  [0]
                    OE             [GT_TRUE]
                    tsAction       [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                    packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E]
                    ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E]
                    offset         [0]
                    ptpMessageType [0]
                    domain         [0]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: GT_OK.
        */

        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 64;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
        entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
        entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E;
        entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
        entry.offset         = 0;
        entry.ptpMessageType = 0;
        entry.domain         = 0;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsCfgTableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsCfgTableGet(devNum, entryIndex, &entryGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsMode, entryGet.tsMode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction, entryGet.tsAction, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetFormat, entryGet.packetFormat,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ptpTransport, entryGet.ptpTransport,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.offset, entryGet.offset, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ptpMessageType,
        entryGet.ptpMessageType, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.domain, entryGet.domain, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
            entryGet.ingrLinkDelayEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
            entryGet.packetDispatchingEnable, devNum);

        /*
            1.1. Call with
                entryIndex  [64]
                entry
                {
                    tsMode         [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E]
                    offsetProfile  [64]
                    OE             [GT_FALSE]
                    ingrLinkDelayEnable     [GT_FALSE]
                    packetDispatchingEnable [GT_FALSE]
                }
            Expected: GT_OK.
        */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 64;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E;
        entry.offsetProfile  = 64;
        entry.OE             = GT_FALSE;
        entry.ingrLinkDelayEnable     = GT_FALSE;
        entry.packetDispatchingEnable = GT_FALSE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsCfgTableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsCfgTableGet(devNum, entryIndex, &entryGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsMode, entryGet.tsMode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.offsetProfile, entryGet.offsetProfile,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.OE, entryGet.OE, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
            entryGet.ingrLinkDelayEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
            entryGet.packetDispatchingEnable, devNum);

        /*
            1.1. Call with
                entryIndex  [64]
                entry
                {
                    tsMode         [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E]
                    offsetProfile  [127]
                    OE             [GT_FALSE]
                    ingrLinkDelayEnable     [GT_FALSE]
                    packetDispatchingEnable [GT_FALSE]
                }
            Expected: GT_OK.
        */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 64;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E;
        entry.offsetProfile  = 127;
        entry.OE             = GT_FALSE;
        entry.ingrLinkDelayEnable     = GT_FALSE;
        entry.packetDispatchingEnable = GT_FALSE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsCfgTableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsCfgTableGet(devNum, entryIndex, &entryGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsMode, entryGet.tsMode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.offsetProfile, entryGet.offsetProfile,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.OE, entryGet.OE, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
            entryGet.ingrLinkDelayEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
            entryGet.packetDispatchingEnable, devNum);

       /*
            1.1 Call with
                entryIndex  [127]
                entry
                {
                    tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E]
                    tsAction       [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                    packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E]
                    ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E]
                    offset         [0]
                    ptpMessageType [0]
                    domain         [0]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: GT_OK.
        */

        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 127;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
        entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
        entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E;
        entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
        entry.offset         = 0;
        entry.ptpMessageType = 0;
        entry.domain         = 0;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsCfgTableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsCfgTableGet(devNum, entryIndex, &entryGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsMode, entryGet.tsMode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction, entryGet.tsAction, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetFormat, entryGet.packetFormat,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ptpTransport, entryGet.ptpTransport,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.offset, entryGet.offset, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ptpMessageType,
        entryGet.ptpMessageType, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.domain, entryGet.domain, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
            entryGet.ingrLinkDelayEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
            entryGet.packetDispatchingEnable, devNum);

        /*
            1.1. Call with
                entryIndex  [127]
                entry
                {
                    tsMode         [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E]
                    offsetProfile  [64]
                    OE             [GT_FALSE]
                    ingrLinkDelayEnable     [GT_FALSE]
                    packetDispatchingEnable [GT_FALSE]
                }
            Expected: GT_OK.
        */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 127;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E;
        entry.offsetProfile  = 64;
        entry.OE             = GT_FALSE;
        entry.ingrLinkDelayEnable     = GT_FALSE;
        entry.packetDispatchingEnable = GT_FALSE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsCfgTableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsCfgTableGet(devNum, entryIndex, &entryGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsMode, entryGet.tsMode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.offsetProfile, entryGet.offsetProfile,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.OE, entryGet.OE, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
            entryGet.ingrLinkDelayEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
            entryGet.packetDispatchingEnable, devNum);

        /*
            1.1. Call with
                entryIndex  [127]
                entry
                {
                    tsMode         [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E]
                    offsetProfile  [127]
                    OE             [GT_FALSE]
                    ingrLinkDelayEnable     [GT_FALSE]
                    packetDispatchingEnable [GT_FALSE]
                }
            Expected: GT_OK.
        */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 127;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E;
        entry.offsetProfile  = 127;
        entry.OE             = GT_FALSE;
        entry.ingrLinkDelayEnable     = GT_FALSE;
        entry.packetDispatchingEnable = GT_FALSE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsCfgTableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsCfgTableGet(devNum, entryIndex, &entryGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsMode, entryGet.tsMode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.offsetProfile, entryGet.offsetProfile,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.OE, entryGet.OE, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
            entryGet.ingrLinkDelayEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
            entryGet.packetDispatchingEnable, devNum);

        /*
            1.3 Call with
                entryIndex  [out of range]
                entry
                {
                    tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E]
                    tsAction       [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                    packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E]
                    ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E]
                    offset         [0]
                    ptpMessageType [0]
                    domain         [0]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: not GT_OK.
        */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 300;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
        entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
        entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E;
        entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
        entry.offset         = 0;
        entry.ptpMessageType = 0;
        entry.domain         = 0;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);


        /*
            1.3 Call with
                entryIndex  [0]
                entry
                {
                    tsMode [out of range]
                    offsetProfile  [0]
                    OE             [GT_TRUE]
                    tsAction       [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                    packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E]
                    ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E]
                    offset         [0]
                    ptpMessageType [0]
                    domain         [0]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: GT_OK.
        */

        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 0;
        entry.offsetProfile  = 0;
        entry.OE             = GT_TRUE;
        entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
        entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E;
        entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
        entry.offset         = 0;
        entry.ptpMessageType = 0;
        entry.domain         = 0;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsCfgTableSet
                            (devNum, entryIndex, &entry),
                            entry.tsMode);

        /*
            1.3 Call with
                entryIndex  [0]
                entry
                {
                    tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E]
                    offsetProfile  [out of range]
                    OE             [GT_TRUE]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: GT_OUT_OF_RANGE.
        */

        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 0;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E;
        entry.offsetProfile  = 300;
        entry.OE             = GT_TRUE;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);



        /*
            1.3 Call with
                entryIndex  [0]
                entry
                {
                    tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E]
                    tsAction       [out of range]
                    packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E]
                    ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E]
                    offset         [0]
                    ptpMessageType [0]
                    domain         [0]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: GT_OK.
        */

        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 0;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
        entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E;
        entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
        entry.offset         = 0;
        entry.ptpMessageType = 0;
        entry.domain         = 0;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsCfgTableSet
                            (devNum, entryIndex, &entry),
                            entry.tsAction);
        /*
            1.3 Call with
                entryIndex  [0]
                entry
                {
                    tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E]
                    tsAction       [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                    packetFormat   [out of range]
                    ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E]
                    offset         [0]
                    ptpMessageType [0]
                    domain         [0]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: GT_OK.
        */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 0;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
        entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
        entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
        entry.offset         = 0;
        entry.ptpMessageType = 0;
        entry.domain         = 0;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsCfgTableSet
                            (devNum, entryIndex, &entry),
                            entry.packetFormat);

        /*
            1.3 Call with
                entryIndex  [0]
                entry
                {
                    tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E]
                    tsAction       [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                    packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E]
                    ptpTransport   [out of range]
                    offset         [0]
                    ptpMessageType [0]
                    domain         [0]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: GT_OK.
        */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 0;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
        entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
        entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E;
        entry.offset         = 0;
        entry.ptpMessageType = 0;
        entry.domain         = 0;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsCfgTableSet
                            (devNum, entryIndex, &entry),
                            entry.ptpTransport);

        /*
            1.3 Call with
                entryIndex  [0]
                entry
                {
                    tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E]
                    tsAction       [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                    packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E]
                    ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E]
                    offset         [out of range]
                    ptpMessageType [0]
                    domain         [0]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: GT_OUTֹֹֹ_OFֹ_RANGE.
        */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 0;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
        entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
        entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E;
        entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
        if(UTF_CPSS_SIP5_0_ONLY_CHECK_MAC(devNum) == GT_FALSE)
        {
            entry.offset     = 256;
        }
        else
        {
            entry.offset     = 128;
        }
        entry.ptpMessageType = 0;
        entry.domain         = 0;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);



        /*
            1.3 Call with
                entryIndex  [0]
                entry
                {
                    tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E]
                    tsAction       [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                    packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E]
                    ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E]
                    offset         [0]
                    ptpMessageType [out of range]
                    domain         [0]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: GT_OUTֹֹֹ_OFֹ_RANGE.
        */
        entryIndex           = 0;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
        entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
        entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E;
        entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
        entry.offset         = 0;
        entry.ptpMessageType = 300;
        entry.domain         = 0;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);

        /*
            1.3 Call with
                entryIndex  [0]
                entry
                {
                    tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E]
                    tsAction       [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                    packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E]
                    ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E]
                    offset         [0]
                    ptpMessageType [0]
                    domain         [out of range]
                    ingrLinkDelayEnable     [GT_TRUE]
                    packetDispatchingEnable [GT_TRUE]
                }
            Expected: GT_BAD_PARAM.
        */
        cpssOsMemSet(&entry, 0, sizeof(entry));
        cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
        entryIndex           = 0;
        entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
        entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
        entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E;
        entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
        entry.offset         = 0;
        entry.ptpMessageType = 0;
        entry.domain         = 300;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;

        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.4. Call with null entryPtr
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);

        if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            /*
               1.1 Call with
               entry
               {
                   tsMode [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E]
                   tsAction       [CPSS_DXCH_PTP_TS_ACTION_ADD_INGRESS_EGRESS_TIME_E]
                   packetFormat   [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V2_E]
                   ptpTransport   [CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E]
                   offset         0
                   ptpMessageType [0]
                   domain         [0]
                   ingrLinkDelayEnable     [GT_TRUE]
                   packetDispatchingEnable [GT_TRUE]
               }
                Expected: GT_OK.
            */
            cpssOsMemSet(&entry, 0, sizeof(entry));
            cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
            entryIndex           = 0;
            entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
            entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_ADD_INGRESS_EGRESS_TIME_E;
            entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_NTP_TS_E;
            entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
            entry.offset         = 0;
            entry.offset2        = 254;
            entry.ptpMessageType = 0;
            entry.domain         = 0;
            entry.ingrLinkDelayEnable     = GT_TRUE;
            entry.packetDispatchingEnable = GT_TRUE;

            st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);
            /*
               1.2. Call cpssDxChPtpTsCfgTableGet().
                Expected: GT_OK and same mode as was set in 1.1
            */
            st = cpssDxChPtpTsCfgTableGet(devNum, entryIndex, &entryGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsMode, entryGet.tsMode, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction, entryGet.tsAction, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.offset2, entryGet.offset2, devNum);

            /*
            1.1. Call with
                offset2  [129]  Odd values are not allowed
                offset2  [256]  Out of range
                entry
                {
                    tsAction       [CPSS_DXCH_PTP_TS_ACTION_ADD_INGRESS_EGRESS_TIME_E]
                    tsMode         [CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E]
                    offset2        [129 / 256]
                    OE             [GT_FALSE]
                    ingrLinkDelayEnable     [GT_FALSE]
                    packetDispatchingEnable [GT_FALSE]
                }
            Expected: GT_BAD_PARAM.
            */

            cpssOsMemSet(&entry, 0, sizeof(entry));
            cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
            entryIndex           = 127;
            entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_ADD_INGRESS_EGRESS_TIME_E;
            entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_MODIFY_TAG_E;
            entry.offset2        = 129;
            entry.OE             = GT_FALSE;

            st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

            entry.offset2        = 256;
            st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
        }
    }

    /*set valid parameters*/
    cpssOsMemSet(&entry, 0, sizeof(entry));
    cpssOsMemSet(&entryGet, 0, sizeof(entryGet));
    entryIndex           = 0;
    entry.tsMode         = CPSS_DXCH_PTP_TS_TIMESTAMPING_MODE_DO_ACTION_E;
    entry.tsAction       = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
    entry.packetFormat   = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E;
    entry.ptpTransport   = CPSS_DXCH_PTP_TRANSPORT_TYPE_ETHERNET_E;
    entry.offset         = 0;
    entry.ptpMessageType = 0;
    entry.domain         = 0;
    entry.ingrLinkDelayEnable     = GT_TRUE;
    entry.packetDispatchingEnable = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsCfgTableSet(devNum, entryIndex, &entry);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsCfgTableGet
(
    IN  GT_U8                          devNum,
    IN  GT_U32                         entryIndex,
    OUT CPSS_DXCH_PTP_TS_CFG_ENTRY_STC *entryPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsCfgTableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with entryIndex [0 / 60 / 127]
    Expected: GT_OK.
    1.2 Call with entryIndex out of range
    Expected: GT_BAD_PARAM.
    1.3 Call api with wrong enable entryPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st          = GT_OK;
    GT_U8                             devNum      = 0;
    GT_U32                            entryIndex;
    CPSS_DXCH_PTP_TS_CFG_ENTRY_STC    entry;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with entryIndex [0]
            Expected: GT_OK.
        */
        entryIndex = 0;
        st = cpssDxChPtpTsCfgTableGet(
                devNum,
                entryIndex,
                &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1 Call with entryIndex [60]
            Expected: GT_OK.
        */
        entryIndex = 60;
        st = cpssDxChPtpTsCfgTableGet(
                devNum,
                entryIndex,
                &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1 Call with entryIndex [127]
            Expected: GT_OK.
        */
        entryIndex = 127;
        st = cpssDxChPtpTsCfgTableGet(
                devNum,
                entryIndex,
                &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call with entryIndex out of range
            Expected: GT_BAD_PARAM.
        */
        entryIndex = 200;
        st = cpssDxChPtpTsCfgTableGet(
                devNum,
                entryIndex,
                &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.3 Call api with wrong enable entryPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        entryIndex = 0;
        st = cpssDxChPtpTsCfgTableGet(
                devNum,
                entryIndex,
                NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /*set valid parameters*/
    entryIndex = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsCfgTableGet(
                devNum,
                entryIndex,
                &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsCfgTableGet(
                devNum,
                entryIndex,
                &entry);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsLocalActionTableSet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    IN  GT_U32                                  domainNum,
    IN  GT_U32                                  messageType,
    IN  CPSS_DXCH_PTP_TS_LOCAL_ACTION_ENTRY_STC *entryPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsLocalActionTableSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1. Call with
        domainNum    [0 / 2 / 3]
        messageType  [0 / 7 / 15]
        entry
        {
            tsAction  [CPSS_DXCH_PTP_TS_ACTION_NONE_E                    |
                       CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_TIME_E        |
                       CPSS_DXCH_PTP_TS_ACTION_ADD_CORRECTED_TIME_E]
            ingrLinkDelayEnable     [GT_TRUE / GT_FALSE]
            packetDispatchingEnable [GT_TRUE / GT_FALSE]
        }
    Expected: GT_OK.
    1.1.2. Call cpssDxChPtpTsLocalActionTableGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.1.3. Call with
        domainNum    [out fo range]
        messageType  [out fo range]
        entry
        {
            tsAction                [out of range]
            ingrLinkDelayEnable     [GT_TRUE]
            packetDispatchingEnable [GT_TRUE]
        }
    Expected: GT_BAD_PARAM.
    1.1.4. Call with null entry
    Expected: GT_BAD_PTR.
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
*/
    GT_STATUS                                      st      =  GT_OK;
    GT_U8                                          devNum  =  0;
    UTF_PHYSICAL_PORT_NUM                          port;
    GT_U32                                         domainNum;
    GT_U32                                         messageType;
    CPSS_DXCH_PTP_TS_LOCAL_ACTION_ENTRY_STC        entry;
    CPSS_DXCH_PTP_TS_LOCAL_ACTION_ENTRY_STC        entryGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1. Call with
                    domainNum    [0]
                    messageType  [0]
                    entry
                    {
                        tsAction  [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                        ingrLinkDelayEnable     [GT_TRUE]
                        packetDispatchingEnable [GT_TRUE]
                    }
                Expected: GT_OK.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 0;
            messageType = 0;
            entry.tsAction                = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
            entry.ingrLinkDelayEnable     = GT_TRUE;
            entry.packetDispatchingEnable = GT_TRUE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsLocalActionTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction,
                entryGet.tsAction, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
                entryGet.ingrLinkDelayEnable, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
                entryGet.packetDispatchingEnable, devNum);

            /*
                1.1.1. Call with
                    domainNum    [0]
                    messageType  [0]
                    entry
                    {
                        tsAction  [CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_TIME_E]
                        ingrLinkDelayEnable     [GT_FALSE]
                        packetDispatchingEnable [GT_FALSE]
                    }
                Expected: GT_OK.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 0;
            messageType = 0;
            entry.tsAction                = CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_TIME_E;
            entry.ingrLinkDelayEnable     = GT_FALSE;
            entry.packetDispatchingEnable = GT_FALSE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsLocalActionTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction,
                entryGet.tsAction, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
                entryGet.ingrLinkDelayEnable, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
                entryGet.packetDispatchingEnable, devNum);

            /*
                1.1.1. Call with
                    domainNum    [0]
                    messageType  [0]
                    entry
                    {
                        tsAction
                            [CPSS_DXCH_PTP_TS_ACTION_ADD_CORRECTED_TIME_E]
                        ingrLinkDelayEnable     [GT_FALSE]
                        packetDispatchingEnable [GT_FALSE]
                    }
                Expected: GT_OK.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 0;
            messageType = 0;
            entry.tsAction                =
                CPSS_DXCH_PTP_TS_ACTION_ADD_CORRECTED_TIME_E;
            entry.ingrLinkDelayEnable     = GT_FALSE;
            entry.packetDispatchingEnable = GT_FALSE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsLocalActionTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction,
                entryGet.tsAction, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
                entryGet.ingrLinkDelayEnable, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
                entryGet.packetDispatchingEnable, devNum);

                /*
                1.1.1. Call with
                    domainNum    [2]
                    messageType  [7]
                    entry
                    {
                        tsAction  [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                        ingrLinkDelayEnable     [GT_TRUE]
                        packetDispatchingEnable [GT_TRUE]
                    }
                Expected: GT_OK.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 2;
            messageType = 7;
            entry.tsAction                = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
            entry.ingrLinkDelayEnable     = GT_TRUE;
            entry.packetDispatchingEnable = GT_TRUE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsLocalActionTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction,
                entryGet.tsAction, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
                entryGet.ingrLinkDelayEnable, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
                entryGet.packetDispatchingEnable, devNum);

            /*
                1.1.1. Call with
                    domainNum    [2]
                    messageType  [7]
                    entry
                    {
                        tsAction  [CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_TIME_E]
                        ingrLinkDelayEnable     [GT_FALSE]
                        packetDispatchingEnable [GT_FALSE]
                    }
                Expected: GT_OK.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 2;
            messageType = 7;
            entry.tsAction                = CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_TIME_E;
            entry.ingrLinkDelayEnable     = GT_FALSE;
            entry.packetDispatchingEnable = GT_FALSE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsLocalActionTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction,
                entryGet.tsAction, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
                entryGet.ingrLinkDelayEnable, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
                entryGet.packetDispatchingEnable, devNum);

            /*
                1.1.1. Call with
                    domainNum    [2]
                    messageType  [7]
                    entry
                    {
                        tsAction
                            [CPSS_DXCH_PTP_TS_ACTION_ADD_CORRECTED_TIME_E]
                        ingrLinkDelayEnable     [GT_FALSE]
                        packetDispatchingEnable [GT_FALSE]
                    }
                Expected: GT_OK.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 2;
            messageType = 7;
            entry.tsAction                =
                CPSS_DXCH_PTP_TS_ACTION_ADD_CORRECTED_TIME_E;
            entry.ingrLinkDelayEnable     = GT_FALSE;
            entry.packetDispatchingEnable = GT_FALSE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsLocalActionTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction,
                entryGet.tsAction, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
                entryGet.ingrLinkDelayEnable, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
                entryGet.packetDispatchingEnable, devNum);

            /*
                1.1.1. Call with
                    domainNum    [3]
                    messageType  [15]
                    entry
                    {
                        tsAction  [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                        ingrLinkDelayEnable     [GT_TRUE]
                        packetDispatchingEnable [GT_TRUE]
                    }
                Expected: GT_OK.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 3;
            messageType = 15;
            entry.tsAction                = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
            entry.ingrLinkDelayEnable     = GT_TRUE;
            entry.packetDispatchingEnable = GT_TRUE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsLocalActionTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction,
                entryGet.tsAction, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
                entryGet.ingrLinkDelayEnable, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
                entryGet.packetDispatchingEnable, devNum);

            /*
                1.1.1. Call with
                    domainNum    [3]
                    messageType  [15]
                    entry
                    {
                        tsAction  [CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_TIME_E]
                        ingrLinkDelayEnable     [GT_FALSE]
                        packetDispatchingEnable [GT_FALSE]
                    }
                Expected: GT_OK.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 3;
            messageType = 15;
            entry.tsAction                = CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_TIME_E;
            entry.ingrLinkDelayEnable     = GT_FALSE;
            entry.packetDispatchingEnable = GT_FALSE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsLocalActionTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction,
                entryGet.tsAction, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
                entryGet.ingrLinkDelayEnable, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
                entryGet.packetDispatchingEnable, devNum);

            /*
                1.1.1. Call with
                    domainNum    [3]
                    messageType  [15]
                    entry
                    {
                        tsAction
                            [CPSS_DXCH_PTP_TS_ACTION_ADD_CORRECTED_TIME_E]
                        ingrLinkDelayEnable     [GT_FALSE]
                        packetDispatchingEnable [GT_FALSE]
                    }
                Expected: GT_OK.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 3;
            messageType = 15;
            entry.tsAction                =
                CPSS_DXCH_PTP_TS_ACTION_ADD_CORRECTED_TIME_E;
            entry.ingrLinkDelayEnable     = GT_FALSE;
            entry.packetDispatchingEnable = GT_FALSE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2. Call cpssDxChPtpTsLocalActionTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.tsAction,
                entryGet.tsAction, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.ingrLinkDelayEnable,
                entryGet.ingrLinkDelayEnable, devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(entry.packetDispatchingEnable,
                entryGet.packetDispatchingEnable, devNum);

            /*
                1.1.3. Call with
                    domainNum    [out of the range]
                    messageType  [0]
                    entry
                    {
                        tsAction  [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                        ingrLinkDelayEnable     [GT_TRUE]
                        packetDispatchingEnable [GT_TRUE]
                    }
                Expected: GT_BAD_PARAM.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 300;
            messageType = 0;
            entry.tsAction                = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
            entry.ingrLinkDelayEnable     = GT_TRUE;
            entry.packetDispatchingEnable = GT_TRUE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.3. Call with
                    domainNum    [0]
                    messageType  [out of the range]
                    entry
                    {
                        tsAction  [CPSS_DXCH_PTP_TS_ACTION_NONE_E]
                        ingrLinkDelayEnable     [GT_TRUE]
                        packetDispatchingEnable [GT_TRUE]
                    }
                Expected: GT_BAD_PARAM.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 0;
            messageType = 300;
            entry.tsAction                = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
            entry.ingrLinkDelayEnable     = GT_TRUE;
            entry.packetDispatchingEnable = GT_TRUE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.3. Call with
                    domainNum    [0]
                    messageType  [0]
                    entry
                    {
                        tsAction  [out of the range]
                        ingrLinkDelayEnable     [GT_TRUE]
                        packetDispatchingEnable [GT_TRUE]
                    }
                Expected: GT_BAD_PARAM.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 0;
            messageType = 0;
            entry.ingrLinkDelayEnable     = GT_TRUE;
            entry.packetDispatchingEnable = GT_TRUE;

            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsLocalActionTableSet(
                                devNum,
                                port,
                                domainNum,
                                messageType,
                                &entry),
                                entry.tsAction);
            /*
                1.1.3. Call with null entry
                Expected: GT_BAD_PTR.
            */
            cpssOsMemSet(&entry ,0 ,sizeof(entry));
            cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
            domainNum   = 0;
            messageType = 0;
            entry.tsAction                = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
            entry.ingrLinkDelayEnable     = GT_TRUE;
            entry.packetDispatchingEnable = GT_TRUE;

            st = cpssDxChPtpTsLocalActionTableSet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    NULL);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, devNum, port);
        }
        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        cpssOsMemSet(&entry ,0 ,sizeof(entry));
        cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
        domainNum   = 0;
        domainNum   = 0;
        messageType = 0;
        entry.tsAction                = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
        entry.ingrLinkDelayEnable     = GT_TRUE;
        entry.packetDispatchingEnable = GT_TRUE;
        port        = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        st = cpssDxChPtpTsLocalActionTableSet(
                devNum,
                port,
                domainNum,
                messageType,
                &entry);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set valid parameters*/
    cpssOsMemSet(&entry ,0 ,sizeof(entry));
    cpssOsMemSet(&entryGet ,0 ,sizeof(entryGet));
    port        = 0;
    domainNum   = 0;
    messageType = 0;
    entry.tsAction                = CPSS_DXCH_PTP_TS_ACTION_NONE_E;
    entry.ingrLinkDelayEnable     = GT_TRUE;
    entry.packetDispatchingEnable = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsLocalActionTableSet(
                devNum,
                port,
                domainNum,
                messageType,
                &entry);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum, port);
    }

    /* 3. Call function with out of bound value for device id.*/
    st = cpssDxChPtpTsLocalActionTableSet(
            devNum,
            port,
            domainNum,
            messageType,
            &entry);
    UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsLocalActionTableGet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    IN  GT_U32                                  domainNum,
    IN  GT_U32                                  messageType,
    OUT CPSS_DXCH_PTP_TS_LOCAL_ACTION_ENTRY_STC *entryPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsLocalActionTableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            domainNum   [0 / 4 / 8]
            messageType [0 / 7 / 15]
    Expected: GT_OK
    1.1.2 Call with
        domainNum   [out of range]
        messageType [out of range]
    Expected: GT_BAD_PARAM.
    1.1.3 Call with null entryPtr
    Expected: GT_BAD_PTR
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
*/

    GT_STATUS                                      st      =  GT_OK;
    GT_U8                                          devNum  =  0;
    UTF_PHYSICAL_PORT_NUM                          port;
    GT_U32                                         domainNum;
    GT_U32                                         messageType;
    CPSS_DXCH_PTP_TS_LOCAL_ACTION_ENTRY_STC        entry;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with
                        domainNum   [0]
                        messageType [0]
                Expected: GT_OK
            */
            domainNum   = 0;
            messageType = 0;
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.1 Call with
                        domainNum   [4]
                        messageType [7]
                Expected: GT_OK
            */
            domainNum   = 4;
            messageType = 7;
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.1 Call with
                        domainNum   [8]
                        messageType [15]
                Expected: GT_OK
            */
            domainNum   = 0;
            messageType = 0;
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2 Call with
                        domainNum   [out of range]
                        messageType [0]
                Expected: GT_OK
            */
            domainNum   = 20;
            messageType = 0;
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2 Call with
                        domainNum   [0]
                        messageType [out of range]
                Expected: GT_OK
            */
            domainNum   = 0;
            messageType = 20;
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    &entry);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.3 Call with null entryPtr
                Expected: GT_BAD_PTR
            */
            domainNum   = 0;
            messageType = 0;
            st = cpssDxChPtpTsLocalActionTableGet(
                    devNum,
                    port,
                    domainNum,
                    messageType,
                    NULL);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
        }

        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        domainNum   = 0;
        messageType = 0;
        port     = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        st = cpssDxChPtpTsLocalActionTableGet(
                devNum,
                port,
                domainNum,
                messageType,
                &entry);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }
    /*set port valid value*/
    domainNum   = 0;
    messageType = 0;
    port     = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsLocalActionTableGet(
                devNum,
                port,
                domainNum,
                messageType,
                &entry);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum, port);
    }

    /* 3. Call function with out of bound value for device id.*/
    domainNum   = 0;
    messageType = 0;
    st = cpssDxChPtpTsLocalActionTableGet(
            devNum,
            port,
            domainNum,
            messageType,
            &entry);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsUdpChecksumUpdateModeSet
(
    IN  GT_U8                                         devNum,
    IN  CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_STC *udpCsUpdModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsUdpChecksumUpdateModeSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
        udpCsUpdMode
        {
            ptpIpv4Mode [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E |
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E|
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
            ptpIpv6Mode [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E |
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E|
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
            ntpIpv4Mode [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E |
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E|
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
            ntpIpv6Mode [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E |
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E|
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
            wampIpv4Mode [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E |
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E|
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
            wampIpv6Mode [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E |
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E|
                        CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
        }
    Expected: GT_OK.
    1.1.2. Call cpssDxChPtpTsUdpChecksumUpdateModeGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.1.3 Call with
        udpCsUpdMode
        {
            ptpIpv4Mode [out of range]
            ptpIpv6Mode [out of range]
            ntpIpv4Mode [out of range]
            ntpIpv6Mode [out of range]
            wampIpv4Mode [out of range]
            wampIpv6Mode [out of range]
        }
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                         st        = GT_OK;
    GT_U8                             devNum    = 0;
    CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_STC udpCsUpdMode;
    CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_STC udpCsUpdModeGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
        1.1.1 Call with
            udpCsUpdMode
            {
                ptpIpv4Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E]
                ptpIpv6Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E]
                ntpIpv4Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E]
                ntpIpv6Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E]
                wampIpv4Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E]
                wampIpv6Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E]
            }
        Expected: GT_OK.
        */
        udpCsUpdMode.ptpIpv4Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E;
        udpCsUpdMode.ptpIpv6Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E;
        udpCsUpdMode.ntpIpv4Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E;
        udpCsUpdMode.ntpIpv6Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E;
        udpCsUpdMode.wampIpv4Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E;
        udpCsUpdMode.wampIpv6Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_CLEAR_E;

        st = cpssDxChPtpTsUdpChecksumUpdateModeSet(devNum, &udpCsUpdMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1.2. Call cpssDxChPtpTsUdpChecksumUpdateModeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsUdpChecksumUpdateModeGet(devNum, &udpCsUpdModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ptpIpv4Mode, udpCsUpdModeGet.ptpIpv4Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ptpIpv6Mode, udpCsUpdModeGet.ptpIpv6Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ntpIpv4Mode, udpCsUpdModeGet.ntpIpv4Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ntpIpv6Mode, udpCsUpdModeGet.ntpIpv6Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.wampIpv4Mode, udpCsUpdModeGet.wampIpv4Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.wampIpv6Mode, udpCsUpdModeGet.wampIpv6Mode, devNum);

       /*
        1.1.1 Call with
            udpCsUpdMode
            {
                ptpIpv4Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E]
                ptpIpv6Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E]
                ntpIpv4Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E]
                ntpIpv6Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E]
                wampIpv4Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E]
                wampIpv6Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E]
            }
        Expected: GT_OK.
        */
        udpCsUpdMode.ptpIpv4Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E;
        udpCsUpdMode.ptpIpv6Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E;
        udpCsUpdMode.ntpIpv4Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E;
        udpCsUpdMode.ntpIpv6Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E;
        udpCsUpdMode.wampIpv4Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E;
        udpCsUpdMode.wampIpv6Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_RECALCULATE_E;

        st = cpssDxChPtpTsUdpChecksumUpdateModeSet(devNum, &udpCsUpdMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1.2. Call cpssDxChPtpTsUdpChecksumUpdateModeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsUdpChecksumUpdateModeGet(devNum, &udpCsUpdModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ptpIpv4Mode, udpCsUpdModeGet.ptpIpv4Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ptpIpv6Mode, udpCsUpdModeGet.ptpIpv6Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ntpIpv4Mode, udpCsUpdModeGet.ntpIpv4Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ntpIpv6Mode, udpCsUpdModeGet.ntpIpv6Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.wampIpv4Mode, udpCsUpdModeGet.wampIpv4Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.wampIpv6Mode, udpCsUpdModeGet.wampIpv6Mode, devNum);

        /*
        1.1.1 Call with
            udpCsUpdMode
            {
                ptpIpv4Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
                ptpIpv6Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
                ntpIpv4Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
                ntpIpv6Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
                wampIpv4Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
                wampIpv6Mode
                    [CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E]
            }
        Expected: GT_OK.
        */
        udpCsUpdMode.ptpIpv4Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E;
        udpCsUpdMode.ptpIpv6Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E;
        udpCsUpdMode.ntpIpv4Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E;
        udpCsUpdMode.ntpIpv6Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E;
        udpCsUpdMode.wampIpv4Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E;
        udpCsUpdMode.wampIpv6Mode =
            CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_KEEP_E;

        st = cpssDxChPtpTsUdpChecksumUpdateModeSet(devNum, &udpCsUpdMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1.2. Call cpssDxChPtpTsUdpChecksumUpdateModeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsUdpChecksumUpdateModeGet(devNum, &udpCsUpdModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ptpIpv4Mode, udpCsUpdModeGet.ptpIpv4Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ptpIpv6Mode, udpCsUpdModeGet.ptpIpv6Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ntpIpv4Mode, udpCsUpdModeGet.ntpIpv4Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.ntpIpv6Mode, udpCsUpdModeGet.ntpIpv6Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.wampIpv4Mode, udpCsUpdModeGet.wampIpv4Mode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            udpCsUpdMode.wampIpv6Mode, udpCsUpdModeGet.wampIpv6Mode, devNum);

        /*
            1.1.3 Call with
                udpCsUpdMode
                {
                    ptpIpv4Mode [out of range]
                    ptpIpv6Mode [out of range]
                    ntpIpv4Mode [out of range]
                    ntpIpv6Mode [out of range]
                    wampIpv4Mode [out of range]
                    wampIpv6Mode [out of range]
                }
            Expected: GT_BAD_PARAM.
        */

        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsUdpChecksumUpdateModeSet
                            (devNum, &udpCsUpdMode),
                            udpCsUpdMode.ptpIpv4Mode);
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsUdpChecksumUpdateModeSet
                            (devNum, &udpCsUpdMode),
                            udpCsUpdMode.ptpIpv6Mode);
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsUdpChecksumUpdateModeSet
                            (devNum, &udpCsUpdMode),
                            udpCsUpdMode.ntpIpv4Mode);
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsUdpChecksumUpdateModeSet
                            (devNum, &udpCsUpdMode),
                            udpCsUpdMode.ntpIpv6Mode);
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsUdpChecksumUpdateModeSet
                            (devNum, &udpCsUpdMode),
                            udpCsUpdMode.wampIpv4Mode);
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTsUdpChecksumUpdateModeSet
                            (devNum, &udpCsUpdMode),
                            udpCsUpdMode.wampIpv6Mode);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsUdpChecksumUpdateModeSet(devNum, &udpCsUpdMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsUdpChecksumUpdateModeSet(devNum, &udpCsUpdMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsUdpChecksumUpdateModeGet
(
    IN  GT_U8                                         devNum,
    OUT CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_STC *udpCsUpdModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsUdpChecksumUpdateModeGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with non-null udpCsUpdModePtr
    Expected: GT_OK.
    1.2 Call api with wrong enable udpCsUpdModePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st     = GT_OK;
    GT_U8                             devNum = 0;
    CPSS_DXCH_PTP_TS_UDP_CHECKSUM_UPDATE_MODE_STC udpCsUpdMode;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with non-null udpCsUpdModePtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpTsUdpChecksumUpdateModeGet(devNum, &udpCsUpdMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call api with wrong enable udpCsUpdModePtr [NULL].
            Expected: GT_OK.
        */
        st = cpssDxChPtpTsUdpChecksumUpdateModeGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsUdpChecksumUpdateModeGet(devNum, &udpCsUpdMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsUdpChecksumUpdateModeGet(devNum, &udpCsUpdMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpOverEthernetEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpOverEthernetEnableSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with enable [GT_TRUE / GT_FALSE]
    Expected: GT_OK.
    1.2. Call cpssDxChPtpOverEthernetEnableGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
*/
    GT_STATUS                         st        = GT_OK;
    GT_U8                             devNum    = 0;
    GT_BOOL                           enable    = GT_TRUE;
    GT_BOOL                           enableGet = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with enable [GT_TRUE]
            Expected: GT_OK.
        */
        enable = GT_TRUE;
        st = cpssDxChPtpOverEthernetEnableSet(devNum, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpOverEthernetEnableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpOverEthernetEnableGet(devNum, &enableGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(enable, enableGet, devNum);

        /*
            1.1 Call with enable [GT_FALSE]
            Expected: GT_OK.
        */
        enable = GT_FALSE;
        st = cpssDxChPtpOverEthernetEnableSet(devNum, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpOverEthernetEnableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpOverEthernetEnableGet(devNum, &enableGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(enable, enableGet, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpOverEthernetEnableSet(devNum, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpOverEthernetEnableSet(devNum, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpOverEthernetEnableGet
(
    IN  GT_U8    devNum,
    OUT GT_BOOL  *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpOverEthernetEnableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with non-null enable
    Expected: GT_OK.
    1.2 Call api with wrong enable [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st     = GT_OK;
    GT_U8                             devNum = 0;
    GT_BOOL                           enable = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with non-null enable
            Expected: GT_OK.
        */
        st = cpssDxChPtpOverEthernetEnableGet(devNum, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call api with wrong enable [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpOverEthernetEnableGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpOverEthernetEnableGet(devNum, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpOverEthernetEnableGet(devNum, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpOverUdpEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpOverUdpEnableSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with enable [GT_TRUE / GT_FALSE]
    Expected: GT_OK.
    1.2. Call cpssDxChPtpOverUdpEnableGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
*/
    GT_STATUS                         st        = GT_OK;
    GT_U8                             devNum    = 0;
    GT_BOOL                           enable    = GT_TRUE;
    GT_BOOL                           enableGet = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with enable [GT_TRUE]
            Expected: GT_OK.
        */
        enable = GT_TRUE;
        st = cpssDxChPtpOverUdpEnableSet(devNum, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpOverUdpEnableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpOverUdpEnableGet(devNum, &enableGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(enable, enableGet, devNum);

        /*
            1.1. Call with enable [GT_FALSE]
            Expected: GT_OK.
        */
        enable = GT_FALSE;
        st = cpssDxChPtpOverUdpEnableSet(devNum, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpOverUdpEnableGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpOverUdpEnableGet(devNum, &enableGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(enable, enableGet, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpOverUdpEnableSet(devNum, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpOverUdpEnableSet(devNum, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpOverUdpEnableGet
(
    IN  GT_U8    devNum,
    OUT GT_BOOL  *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpOverUdpEnableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with non-null enable
    Expected: GT_OK.
    1.2 Call api with wrong enable [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st     = GT_OK;
    GT_U8                             devNum = 0;
    GT_BOOL                           enable = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with non-null enable
            Expected: GT_OK.
        */
        st = cpssDxChPtpOverUdpEnableGet(devNum, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call api with wrong enable [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpOverUdpEnableGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpOverUdpEnableGet(devNum, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpOverUdpEnableGet(devNum, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpDomainModeSet
(
    IN  GT_U8                                  devNum,
    IN  GT_U32                                 domainNum,
    IN  CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_ENT  domainMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpDomainModeSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with
        domainNum  [0 / 2 / 3]
        domainMode [CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_DISABLE_E |
                    CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_PTP_V1_E |
                    CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_PTP_V2_E]
    Expected: GT_OK.
    1.2. Call cpssDxChPtpDomainModeGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.3 Call with domainNum and domainMode out of range
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                              st        = GT_OK;
    GT_U8                                  devNum    = 0;
    GT_U32                                 domainNum;
    CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_ENT  domainMode;
    CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_ENT  domainModeGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with
                domainNum  [0]
                domainMode [CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_DISABLE_E]
            Expected: GT_OK.
        */
        domainNum  = 0;
        domainMode = CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_DISABLE_E;
        st = cpssDxChPtpDomainModeSet(devNum, domainNum, domainMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpDomainModeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpDomainModeGet(devNum, domainNum, &domainModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainMode, domainModeGet, devNum);

        /*
            1.1 Call with
                domainNum  [2]
                domainMode [CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_PTP_V1_E]
            Expected: GT_OK.
        */
        domainNum  = 2;
        domainMode = CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_PTP_V1_E;
        st = cpssDxChPtpDomainModeSet(devNum, domainNum, domainMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpDomainModeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpDomainModeGet(devNum, domainNum, &domainModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainMode, domainModeGet, devNum);


        /*
            1.1 Call with
                domainNum  [3]
                domainMode [CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_PTP_V2_E]
            Expected: GT_OK.
        */
        domainNum  = 3;
        domainMode = CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_PTP_V2_E;
        st = cpssDxChPtpDomainModeSet(devNum, domainNum, domainMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1.2. Call cpssDxChPtpDomainModeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpDomainModeGet(devNum, domainNum, &domainModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainMode, domainModeGet, devNum);

        /*
            1.3 Call with domainNum out of range
            Expected: GT_BAD_PARAM.
        */
        domainNum  = 10;
        domainMode = CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_PTP_V2_E;
        st = cpssDxChPtpDomainModeSet(devNum, domainNum, domainMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.3 Call with domainMode out of range
            Expected: GT_BAD_PARAM.
        */
        domainNum  = 0;
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpDomainModeSet
                            (devNum, domainNum, domainMode),
                            domainMode);
    }

    /*set valid parameters*/
    domainNum  = 0;
    domainMode = CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_DISABLE_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpDomainModeSet(devNum, domainNum, domainMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpDomainModeSet(devNum, domainNum, domainMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpDomainModeGet
(
    IN  GT_U8                                  devNum,
    IN  GT_U32                                 domainNum,
    OUT CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_ENT  *domainModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpDomainModeGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with domainNum [0 / 2 / 3]
    Expected: GT_OK.
    1.2 Call with domainNum out of range
    Expected: GT_BAD_PARAM.
    1.3 Call api with wrong enable domainModePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS    st          = GT_OK;
    GT_U8        devNum      = 0;
    GT_U32       domainNum;
    CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_ENT  domainMode;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with domainNum [0]
            Expected: GT_OK.
        */
        domainNum = 0;
        st = cpssDxChPtpDomainModeGet(
                devNum,
                domainNum,
                &domainMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1 Call with domainNum [2]
            Expected: GT_OK.
        */
        domainNum = 2;
        st = cpssDxChPtpDomainModeGet(
                devNum,
                domainNum,
                &domainMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1 Call with domainNum [3]
            Expected: GT_OK.
        */
        domainNum = 3;
        st = cpssDxChPtpDomainModeGet(
                devNum,
                domainNum,
                &domainMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call with domainNum out of range
            Expected: GT_BAD_PARAM.
        */
        domainNum = 10;
        st = cpssDxChPtpDomainModeGet(
                devNum,
                domainNum,
                &domainMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.3 Call api with wrong enable domainModePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        domainNum = 0;
        st = cpssDxChPtpDomainModeGet(
                devNum,
                domainNum,
                NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /*set valid parameters*/
    domainNum = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpDomainModeGet(
                devNum,
                domainNum,
                &domainMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpDomainModeGet(
                devNum,
                domainNum,
                &domainMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpDomainV1IdSet
(
    IN  GT_U8        devNum,
    IN  GT_U32       domainNum,
    IN  GT_U32       domainIdArr[4]
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpDomainV1IdSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with
        domainNum   [0 / 2 / 3]
        domainIdArr [0x0:0x0:0x0:0x0 |
                     0xFFFFF:0xFFFFF:0xFFFFF:0xFFFFF |
                     0xFFFFFFFFFF:0xFFFFFFFFFF:0xFFFFFFFFFF:0xFFFFFFFFFF]
    Expected: GT_OK.
    1.2. Call cpssDxChPtpDomainV1IdGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.3 Call with domainNum out of range
    Expected: GT_BAD_PARAM.
    1.4 Call with null domainIdArr
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st        = GT_OK;
    GT_U8                             devNum    = 0;
    GT_U32                            domainNum;
    GT_U32                            domainIdArr[4];
    GT_U32                            domainIdArrGet[4];

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with
                domainNum   [0]
                domainIdArr [0x0:0x0:0x0:0x0]
            Expected: GT_OK.
        */
        domainNum = 0;
        domainIdArr[0] = 0;
        domainIdArr[1] = 0;
        domainIdArr[2] = 0;
        domainIdArr[3] = 0;

        st = cpssDxChPtpDomainV1IdSet(devNum, domainNum, domainIdArr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpDomainV1IdGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpDomainV1IdGet(devNum, domainNum, domainIdArrGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[0], domainIdArrGet[0], devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[1], domainIdArrGet[1], devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[2], domainIdArrGet[2], devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[3], domainIdArrGet[3], devNum);

        /*
            1.1. Call with
                domainNum   [2]
                domainIdArr [0xFFFF:0xFFFF:0xFFFF:0xFFFF]
            Expected: GT_OK.
        */
        domainNum = 2;
        domainIdArr[0] = 0xFFFF;
        domainIdArr[1] = 0xFFFF;
        domainIdArr[2] = 0xFFFF;
        domainIdArr[3] = 0xFFFF;

        st = cpssDxChPtpDomainV1IdSet(devNum, domainNum, domainIdArr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpDomainV1IdGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpDomainV1IdGet(devNum, domainNum, domainIdArrGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[0], domainIdArrGet[0], devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[1], domainIdArrGet[1], devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[2], domainIdArrGet[2], devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[3], domainIdArrGet[3], devNum);

        /*
            1.1. Call with
                domainNum   [3]
                domainIdArr [0xFFFFFFFF:0xFFFFFFFF:0xFFFFFFFF:0xFFFFFFFF]
            Expected: GT_OK.
        */
        domainNum = 3;
        domainIdArr[0] = 0xFFFFFFFF;
        domainIdArr[1] = 0xFFFFFFFF;
        domainIdArr[2] = 0xFFFFFFFF;
        domainIdArr[3] = 0xFFFFFFFF;

        st = cpssDxChPtpDomainV1IdSet(devNum, domainNum, domainIdArr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpDomainV1IdGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpDomainV1IdGet(devNum, domainNum, domainIdArrGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[0], domainIdArrGet[0], devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[1], domainIdArrGet[1], devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[2], domainIdArrGet[2], devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainIdArr[3], domainIdArrGet[3], devNum);

        /*
            1.3 Call with domainNum out of range
            Expected: GT_BAD_PARAM.
        */
        domainNum = 10;
        domainIdArr[0] = 0;
        domainIdArr[1] = 0;
        domainIdArr[2] = 0;
        domainIdArr[3] = 0;

        st = cpssDxChPtpDomainV1IdSet(devNum, domainNum, domainIdArr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.4 Call with null domainIdArr
            Expected: GT_BAD_PARAM.
        */
        domainNum = 0;
        st = cpssDxChPtpDomainV1IdSet(devNum, domainNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /*set valid params*/
    domainNum = 0;
    domainIdArr[0] = 0;
    domainIdArr[1] = 0;
    domainIdArr[2] = 0;
    domainIdArr[3] = 0;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpDomainV1IdSet(devNum, domainNum, domainIdArr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpDomainV1IdSet(devNum, domainNum, domainIdArr);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpDomainV1IdGet
(
    IN  GT_U8        devNum,
    IN  GT_U32       domainNum,
    OUT GT_U32       domainIdArr[4]
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpDomainV1IdGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with domainNum [0 / 2 / 3]
    Expected: GT_OK.
    1.2 Call with domainNum out of range
    Expected: GT_BAD_PARAM.
    1.3 Call api with wrong enable domainIdArr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS    st          = GT_OK;
    GT_U8        devNum      = 0;
    GT_U32       domainNum;
    GT_U32       domainIdArr[4];

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with domainNum [0]
            Expected: GT_OK.
        */
        domainNum = 0;
        st = cpssDxChPtpDomainV1IdGet(
                devNum,
                domainNum,
                domainIdArr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1 Call with domainNum [2]
            Expected: GT_OK.
        */
        domainNum = 2;
        st = cpssDxChPtpDomainV1IdGet(
                devNum,
                domainNum,
                domainIdArr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1 Call with domainNum [3]
            Expected: GT_OK.
        */
        domainNum = 3;
        st = cpssDxChPtpDomainV1IdGet(
                devNum,
                domainNum,
                domainIdArr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call with domainNum out of range
            Expected: GT_BAD_PARAM.
        */
        domainNum = 10;
        st = cpssDxChPtpDomainV1IdGet(
                devNum,
                domainNum,
                domainIdArr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.3 Call api with wrong enable domainIdArr [NULL].
            Expected: GT_BAD_PTR.
        */
        domainNum = 0;
        st = cpssDxChPtpDomainV1IdGet(
                devNum,
                domainNum,
                NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /*set valid parameters*/
    domainNum = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpDomainV1IdGet(
                devNum,
                domainNum,
                domainIdArr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpDomainV1IdGet(
                devNum,
                domainNum,
                domainIdArr);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpDomainV2IdSet
(
    IN  GT_U8        devNum,
    IN  GT_U32       domainNum,
    IN  GT_U32       domainId
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpDomainV2IdSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with
        domainNum [0 / 2 / 3]
        domainId  [0 / 126 / 255]
    Expected: GT_OK.
    1.2. Call cpssDxChPtpDomainV2IdGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.3 Call with domainNum out of range
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                         st        = GT_OK;
    GT_U8                             devNum    = 0;
    GT_U32                            domainNum;
    GT_U32                            domainId;
    GT_U32                            domainIdGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with
                domainNum [0]
                domainId  [0]
            Expected: GT_OK.
        */
        domainNum = 0;
        domainId  = 0;
        st = cpssDxChPtpDomainV2IdSet(devNum, domainNum, domainId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpDomainV2IdGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpDomainV2IdGet(devNum, domainNum, &domainIdGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainId, domainIdGet, devNum);

        /*
            1.1. Call with
                domainNum [2]
                domainId  [126]
            Expected: GT_OK.
        */
        domainNum = 2;
        domainId  = 126;
        st = cpssDxChPtpDomainV2IdSet(devNum, domainNum, domainId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpDomainV2IdGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpDomainV2IdGet(devNum, domainNum, &domainIdGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainId, domainIdGet, devNum);

        /*
            1.1. Call with
                domainNum [3]
                domainId  [255]
            Expected: GT_OK.
        */
        domainNum = 3;
        domainId  = 255;
        st = cpssDxChPtpDomainV2IdSet(devNum, domainNum, domainId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpDomainV2IdGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpDomainV2IdGet(devNum, domainNum, &domainIdGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(domainId, domainIdGet, devNum);

       /*
            1.3. Call with
                domainNum [out of range]
                domainId  [0]
            Expected: GT_OUT_OF_RANGE.
        */
        domainNum = 10;
        domainId  = 0;
        st = cpssDxChPtpDomainV2IdSet(devNum, domainNum, domainId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);

       /*
            1.3. Call with
                domainNum [0]
                domainId  [out of range]
            Expected: GT_OUT_OF_RANGE.
        */
        domainNum = 0;
        domainId  = 300;
        st = cpssDxChPtpDomainV2IdSet(devNum, domainNum, domainId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);
    }

    /*set valid params*/
    domainNum = 0;
    domainId  = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpDomainV2IdSet(devNum, domainNum, domainId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpDomainV2IdSet(devNum, domainNum, domainId);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpDomainV2IdGet
(
    IN  GT_U8        devNum,
    IN  GT_U32       domainNum,
    OUT GT_U32       *domainIdPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpDomainV2IdGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with domainNum [0 / 2 / 3]
    Expected: GT_OK.
    1.2 Call with domainNum out of range
    Expected: GT_BAD_PARAM.
    1.3 Call api with wrong enable domainIdPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st          = GT_OK;
    GT_U8                             devNum      = 0;
    GT_U32                            domainNum;
    GT_U32                            domainId;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with domainNum [0]
            Expected: GT_OK.
        */
        domainNum = 0;
        st = cpssDxChPtpDomainV2IdGet(
                devNum,
                domainNum,
                &domainId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1 Call with domainNum [2]
            Expected: GT_OK.
        */
        domainNum = 2;
        st = cpssDxChPtpDomainV2IdGet(
                devNum,
                domainNum,
                &domainId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1 Call with domainNum [3]
            Expected: GT_OK.
        */
        domainNum = 3;
        st = cpssDxChPtpDomainV2IdGet(
                devNum,
                domainNum,
                &domainId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call with domainNum out of range
            Expected: GT_BAD_PARAM.
        */
        domainNum = 4;
        st = cpssDxChPtpDomainV2IdGet(
                devNum,
                domainNum,
                &domainId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.3 Call api with wrong enable domainIdPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        domainNum = 0;
        st = cpssDxChPtpDomainV2IdGet(
                devNum,
                domainNum,
                NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /*set valid parameters*/
    domainNum = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpDomainV2IdGet(
                devNum,
                domainNum,
                &domainId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpDomainV2IdGet(
                devNum,
                domainNum,
                &domainId);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpEgressDomainTableSet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    IN  GT_U32                                  domainNum,
    IN  CPSS_DXCH_PTP_EGRESS_DOMAIN_ENTRY_STC   *entryPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpEgressDomainTableSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1. Call with
        domainNum    [0 / 2 / 3]
        entry
        {
            ptpOverEhernetTsEnable          [GT_TRUE / GT_FALSE]
            ptpOverUdpIpv4TsEnable          [GT_TRUE / GT_FALSE]
            ptpOverUdpIpv6TsEnable          [GT_TRUE / GT_FALSE]
            messageTypeTsEnableBmp          [0 / 1]
            transportSpecificTsEnableBmp    [0 / 1]
        }
    Expected: GT_OK.
    1.1.2. Call cpssDxChPtpEgressDomainTableGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.1.3. Call with
        domainNum    [out of range]
        entry
        {
            ptpOverEhernetTsEnable          [GT_TRUE]
            ptpOverUdpIpv4TsEnable          [GT_TRUE]
            ptpOverUdpIpv6TsEnable          [GT_TRUE]
            messageTypeTsEnableBmp          [out of range]
            transportSpecificTsEnableBmp    [out of range]
        }
    Expected: GT_BAD_PARAM.
    1.1.4. Call with null entry
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                                      st      =  GT_OK;
    GT_U8                                          devNum  =  0;
    UTF_PHYSICAL_PORT_NUM                          port;
    GT_U32                                         domainNum;
    CPSS_DXCH_PTP_EGRESS_DOMAIN_ENTRY_STC          entry;
    CPSS_DXCH_PTP_EGRESS_DOMAIN_ENTRY_STC          entryGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
            1.1.1. Call with
                domainNum    [0]
                entry
                {
                    ptpOverEhernetTsEnable          [GT_TRUE]
                    ptpOverUdpIpv4TsEnable          [GT_TRUE]
                    ptpOverUdpIpv6TsEnable          [GT_TRUE]
                    messageTypeTsEnableBmp          [0]
                    transportSpecificTsEnableBmp    [0]
                }
                Expected: GT_OK.
            */
            domainNum    = 0;
            entry.ptpOverEhernetTsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv4TsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv6TsEnable       = GT_TRUE;
            entry.messageTypeTsEnableBmp       = 0;
            entry.transportSpecificTsEnableBmp = 0;

            st = cpssDxChPtpEgressDomainTableSet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.2. Call cpssDxChPtpEgressDomainTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpEgressDomainTableGet(
                    devNum,
                    port,
                    domainNum,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverEhernetTsEnable,
                entryGet.ptpOverEhernetTsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv4TsEnable,
                entryGet.ptpOverUdpIpv4TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv6TsEnable,
                entryGet.ptpOverUdpIpv6TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.messageTypeTsEnableBmp,
                entryGet.messageTypeTsEnableBmp,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.transportSpecificTsEnableBmp,
                entryGet.transportSpecificTsEnableBmp,
                devNum);

            /*
            1.1.1. Call with
                domainNum    [0]
                entry
                {
                    ptpOverEhernetTsEnable          [GT_FALSE]
                    ptpOverUdpIpv4TsEnable          [GT_FALSE]
                    ptpOverUdpIpv6TsEnable          [GT_FALSE]
                    messageTypeTsEnableBmp          [0]
                    transportSpecificTsEnableBmp    [0]
                }
                Expected: GT_OK.
            */
            domainNum    = 0;
            entry.ptpOverEhernetTsEnable       = GT_FALSE;
            entry.ptpOverUdpIpv4TsEnable       = GT_FALSE;
            entry.ptpOverUdpIpv6TsEnable       = GT_FALSE;
            entry.messageTypeTsEnableBmp       = 1;
            entry.transportSpecificTsEnableBmp = 1;

            st = cpssDxChPtpEgressDomainTableSet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.2. Call cpssDxChPtpEgressDomainTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpEgressDomainTableGet(
                    devNum,
                    port,
                    domainNum,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverEhernetTsEnable,
                entryGet.ptpOverEhernetTsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv4TsEnable,
                entryGet.ptpOverUdpIpv4TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv6TsEnable,
                entryGet.ptpOverUdpIpv6TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.messageTypeTsEnableBmp,
                entryGet.messageTypeTsEnableBmp,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.transportSpecificTsEnableBmp,
                entryGet.transportSpecificTsEnableBmp,
                devNum);

            /*
            1.1.1. Call with
                domainNum    [2]
                entry
                {
                    ptpOverEhernetTsEnable          [GT_TRUE]
                    ptpOverUdpIpv4TsEnable          [GT_TRUE]
                    ptpOverUdpIpv6TsEnable          [GT_TRUE]
                    messageTypeTsEnableBmp          [0]
                    transportSpecificTsEnableBmp    [0]
                }
                Expected: GT_OK.
            */
            domainNum    = 2;
            entry.ptpOverEhernetTsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv4TsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv6TsEnable       = GT_TRUE;
            entry.messageTypeTsEnableBmp       = 0;
            entry.transportSpecificTsEnableBmp = 0;

            st = cpssDxChPtpEgressDomainTableSet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.2. Call cpssDxChPtpEgressDomainTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpEgressDomainTableGet(
                    devNum,
                    port,
                    domainNum,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverEhernetTsEnable,
                entryGet.ptpOverEhernetTsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv4TsEnable,
                entryGet.ptpOverUdpIpv4TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv6TsEnable,
                entryGet.ptpOverUdpIpv6TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.messageTypeTsEnableBmp,
                entryGet.messageTypeTsEnableBmp,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.transportSpecificTsEnableBmp,
                entryGet.transportSpecificTsEnableBmp,
                devNum);

            /*
            1.1.1. Call with
                domainNum    [2]
                entry
                {
                    ptpOverEhernetTsEnable          [GT_FALSE]
                    ptpOverUdpIpv4TsEnable          [GT_FALSE]
                    ptpOverUdpIpv6TsEnable          [GT_FALSE]
                    messageTypeTsEnableBmp          [1]
                    transportSpecificTsEnableBmp    [1]
                }
                Expected: GT_OK.
            */
            domainNum    = 2;
            entry.ptpOverEhernetTsEnable       = GT_FALSE;
            entry.ptpOverUdpIpv4TsEnable       = GT_FALSE;
            entry.ptpOverUdpIpv6TsEnable       = GT_FALSE;
            entry.messageTypeTsEnableBmp       = 1;
            entry.transportSpecificTsEnableBmp = 1;

            st = cpssDxChPtpEgressDomainTableSet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.2. Call cpssDxChPtpEgressDomainTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpEgressDomainTableGet(
                    devNum,
                    port,
                    domainNum,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverEhernetTsEnable,
                entryGet.ptpOverEhernetTsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv4TsEnable,
                entryGet.ptpOverUdpIpv4TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv6TsEnable,
                entryGet.ptpOverUdpIpv6TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.messageTypeTsEnableBmp,
                entryGet.messageTypeTsEnableBmp,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.transportSpecificTsEnableBmp,
                entryGet.transportSpecificTsEnableBmp,
                devNum);

            /*
            1.1.1. Call with
                domainNum    [3]
                entry
                {
                    ptpOverEhernetTsEnable          [GT_TRUE]
                    ptpOverUdpIpv4TsEnable          [GT_TRUE]
                    ptpOverUdpIpv6TsEnable          [GT_TRUE]
                    messageTypeTsEnableBmp          [0]
                    transportSpecificTsEnableBmp    [0]
                }
                Expected: GT_OK.
            */
            domainNum    = 3;
            entry.ptpOverEhernetTsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv4TsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv6TsEnable       = GT_TRUE;
            entry.messageTypeTsEnableBmp       = 0;
            entry.transportSpecificTsEnableBmp = 0;

            st = cpssDxChPtpEgressDomainTableSet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.2. Call cpssDxChPtpEgressDomainTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpEgressDomainTableGet(
                    devNum,
                    port,
                    domainNum,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverEhernetTsEnable,
                entryGet.ptpOverEhernetTsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv4TsEnable,
                entryGet.ptpOverUdpIpv4TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv6TsEnable,
                entryGet.ptpOverUdpIpv6TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.messageTypeTsEnableBmp,
                entryGet.messageTypeTsEnableBmp,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.transportSpecificTsEnableBmp,
                entryGet.transportSpecificTsEnableBmp,
                devNum);

            /*
            1.1.1. Call with
                domainNum    [3]
                entry
                {
                    ptpOverEhernetTsEnable          [GT_FALSE]
                    ptpOverUdpIpv4TsEnable          [GT_FALSE]
                    ptpOverUdpIpv6TsEnable          [GT_FALSE]
                    messageTypeTsEnableBmp          [1]
                    transportSpecificTsEnableBmp    [1]
                }
                Expected: GT_OK.
            */
            domainNum    = 3;
            entry.ptpOverEhernetTsEnable       = GT_FALSE;
            entry.ptpOverUdpIpv4TsEnable       = GT_FALSE;
            entry.ptpOverUdpIpv6TsEnable       = GT_FALSE;
            entry.messageTypeTsEnableBmp       = 1;
            entry.transportSpecificTsEnableBmp = 1;

            st = cpssDxChPtpEgressDomainTableSet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.2. Call cpssDxChPtpEgressDomainTableGet().
                Expected: GT_OK and same mode as was set in 1.1.1.
            */
            st = cpssDxChPtpEgressDomainTableGet(
                    devNum,
                    port,
                    domainNum,
                    &entryGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverEhernetTsEnable,
                entryGet.ptpOverEhernetTsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv4TsEnable,
                entryGet.ptpOverUdpIpv4TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.ptpOverUdpIpv6TsEnable,
                entryGet.ptpOverUdpIpv6TsEnable,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.messageTypeTsEnableBmp,
                entryGet.messageTypeTsEnableBmp,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                entry.transportSpecificTsEnableBmp,
                entryGet.transportSpecificTsEnableBmp,
                devNum);

            /*
            1.1.3. Call with domainNum out of the range
                domainNum    [out of the range]
                entry
                {
                    ptpOverEhernetTsEnable          [GT_TRUE]
                    ptpOverUdpIpv4TsEnable          [GT_TRUE]
                    ptpOverUdpIpv6TsEnable          [GT_TRUE]
                    messageTypeTsEnableBmp          [0]
                    transportSpecificTsEnableBmp    [0]
                }
                Expected: GT_OK.
            */
            domainNum    = 10;
            entry.ptpOverEhernetTsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv4TsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv6TsEnable       = GT_TRUE;
            entry.messageTypeTsEnableBmp       = 0;
            entry.transportSpecificTsEnableBmp = 0;

            st = cpssDxChPtpEgressDomainTableSet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
            1.1.3. Call with messageTypeTsEnableBmp out of the range
                domainNum    [0]
                entry
                {
                    ptpOverEhernetTsEnable          [GT_TRUE]
                    ptpOverUdpIpv4TsEnable          [GT_TRUE]
                    ptpOverUdpIpv6TsEnable          [GT_TRUE]
                    messageTypeTsEnableBmp          [out of the range]
                    transportSpecificTsEnableBmp    [0]
                }
                Expected: GT_OK.
            */
            domainNum    = 0;
            entry.ptpOverEhernetTsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv4TsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv6TsEnable       = GT_TRUE;
            entry.messageTypeTsEnableBmp       = 0xFFFFF;
            entry.transportSpecificTsEnableBmp = 0;

            st = cpssDxChPtpEgressDomainTableSet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
            1.1.3. Call with transportSpecificTsEnableBmp out of the range
                domainNum    [0]
                entry
                {
                    ptpOverEhernetTsEnable          [GT_TRUE]
                    ptpOverUdpIpv4TsEnable          [GT_TRUE]
                    ptpOverUdpIpv6TsEnable          [GT_TRUE]
                    messageTypeTsEnableBmp          [0]
                    transportSpecificTsEnableBmp    [out of the range]
                }
                Expected: GT_OK.
            */
            domainNum    = 0;
            entry.ptpOverEhernetTsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv4TsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv6TsEnable       = GT_TRUE;
            entry.messageTypeTsEnableBmp       = 0;
            entry.transportSpecificTsEnableBmp = 0xFFFFF;

            st = cpssDxChPtpEgressDomainTableSet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.4. Call with null entry
                Expected: GT_BAD_PTR.
            */
            domainNum    = 0;
            entry.ptpOverEhernetTsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv4TsEnable       = GT_TRUE;
            entry.ptpOverUdpIpv6TsEnable       = GT_TRUE;
            entry.messageTypeTsEnableBmp       = 0;
            entry.transportSpecificTsEnableBmp = 0;

            st = cpssDxChPtpEgressDomainTableSet(
                    devNum,
                    port,
                    domainNum,
                    NULL);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, devNum, port);
        }

        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        domainNum    = 0;
        entry.ptpOverEhernetTsEnable       = GT_TRUE;
        entry.ptpOverUdpIpv4TsEnable       = GT_TRUE;
        entry.ptpOverUdpIpv6TsEnable       = GT_TRUE;
        entry.messageTypeTsEnableBmp       = 0;
        entry.transportSpecificTsEnableBmp = 0;

        port = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);

        st = cpssDxChPtpEgressDomainTableSet(
                devNum,
                port,
                domainNum,
                &entry);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }

    /*set valid parameters*/
    domainNum = 0;
    port      = 0;
    entry.ptpOverEhernetTsEnable       = GT_TRUE;
    entry.ptpOverUdpIpv4TsEnable       = GT_TRUE;
    entry.ptpOverUdpIpv6TsEnable       = GT_TRUE;
    entry.messageTypeTsEnableBmp       = 0;
    entry.transportSpecificTsEnableBmp = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpEgressDomainTableSet(
                devNum,
                port,
                domainNum,
                &entryGet);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum, port);
    }

    /* 3. Call function with out of bound value for device id.*/
    st = cpssDxChPtpEgressDomainTableSet(
            devNum,
            port,
            domainNum,
            &entryGet);
    UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpEgressDomainTableGet
(
    IN  GT_U8                                   devNum,
    IN  GT_PHYSICAL_PORT_NUM                    portNum,
    IN  GT_U32                                  domainNum,
    OUT CPSS_DXCH_PTP_EGRESS_DOMAIN_ENTRY_STC   *entryPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpEgressDomainTableGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            domainNum   [0 / 2 / 4]
    Expected: GT_OK
    1.1.2 Call with domainNum out of range
    Expected: GT_BAD_PARAM.
    1.1.3 Call with null entryPtr
    Expected: GT_BAD_PTR
    1.2. For active device for out of bound value for port number.
    Expected: GT_BAD_PARAM
*/

    GT_STATUS                                      st      =  GT_OK;
    GT_U8                                          devNum  =  0;
    UTF_PHYSICAL_PORT_NUM                          port;
    GT_U32                                         domainNum;
    CPSS_DXCH_PTP_EGRESS_DOMAIN_ENTRY_STC          entry;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextPhyPortReset(&port, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports.*/
        while(GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1 Call with domainNum [0]
                Expected: GT_OK
            */
            domainNum   = 0;
            st = cpssDxChPtpEgressDomainTableGet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.1 Call with domainNum [2]
                Expected: GT_OK
            */
            domainNum   = 2;
            st = cpssDxChPtpEgressDomainTableGet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.1 Call with domainNum [4]
                Expected: GT_OK
            */
            domainNum   = 4;
            st = cpssDxChPtpEgressDomainTableGet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, devNum, port);

            /*
                1.1.2 Call with domainNum out of range
                Expected: GT_BAD_PARAM
            */
            domainNum   = 10;
            st = cpssDxChPtpEgressDomainTableGet(
                    devNum,
                    port,
                    domainNum,
                    &entry);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);

            /*
                1.1.3 Call with domainNum [NULL]
                Expected: GT_OK
            */
            domainNum   = 0;
            st = cpssDxChPtpEgressDomainTableGet(
                    devNum,
                    port,
                    domainNum,
                    NULL);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, devNum, port);
        }

        /*
            1.2. For active device for out of bound value for port number.
            Expected: GT_BAD_PARAM
        */
        domainNum   = 0;
        port        = UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(devNum);
        st = cpssDxChPtpEgressDomainTableGet(
                devNum,
                port,
                domainNum,
                &entry);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
    }
    /*set port valid value*/
    domainNum   = 0;
    port        = 0;
    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpEgressDomainTableGet(
                devNum,
                port,
                domainNum,
                &entry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    domainNum   = 0;
    st = cpssDxChPtpEgressDomainTableGet(
            devNum,
            port,
            domainNum,
            &entry);
    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, devNum, port);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpIngressExceptionCfgSet
(
    IN  GT_U8                                     devNum,
    IN  CPSS_DXCH_PTP_INGRESS_EXCEPTION_CFG_STC   *ingrExceptionCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpIngressExceptionCfgSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with
        ingrExceptionCfg
        {
            ptpExceptionCommandEnable[GT_TRUE]
            ptpExceptionCommand      [CPSS_PACKET_CMD_FORWARD_E   |
                                      CPSS_PACKET_CMD_TRAP_TO_CPU_E     |
                                      CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
            ptpExceptionCpuCode      [(CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1)          |
                                      CPSS_NET_CLASS_KEY_MIRROR_E |
                                      CPSS_NET_UNKNOWN_UC_E]
            ptpVersionCheckEnable    [GT_TRUE]
        }
    Expected: GT_OK.
    1.2. Call cpssDxChPtpIngressExceptionCfgGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.3. Call with
        ingrExceptionCfg
        {
            ptpExceptionCommandEnable[GT_TRUE]
            ptpExceptionCommand      [out of range]
            ptpExceptionCpuCode      [out of range]
            ptpVersionCheckEnable    [GT_TRUE]
        }
    Expected: GT_BAD_PARAM.
    1.4. Call with null ingrExceptionCfgPtr
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                               st          = GT_OK;
    GT_U8                                   devNum      = 0;
    CPSS_DXCH_PTP_INGRESS_EXCEPTION_CFG_STC ingrExceptionCfg;
    CPSS_DXCH_PTP_INGRESS_EXCEPTION_CFG_STC ingrExceptionCfgGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with
                ingrExceptionCfg
                {
                    ptpExceptionCommandEnable[GT_TRUE]
                    ptpExceptionCommand      [CPSS_PACKET_CMD_FORWARD_E]
                    ptpExceptionCpuCode      [(CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1)]
                    ptpVersionCheckEnable    [GT_TRUE]
                }
            Expected: GT_OK.
        */
        ingrExceptionCfg.ptpExceptionCommandEnable = GT_TRUE;
        ingrExceptionCfg.ptpExceptionCommand       =
            CPSS_PACKET_CMD_FORWARD_E;
        ingrExceptionCfg.ptpExceptionCpuCode       =
            (CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1);
        ingrExceptionCfg.ptpVersionCheckEnable     = GT_TRUE;

        st = cpssDxChPtpIngressExceptionCfgSet(devNum, &ingrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpIngressExceptionCfgGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpIngressExceptionCfgGet(devNum, &ingrExceptionCfgGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpExceptionCommandEnable,
            ingrExceptionCfgGet.ptpExceptionCommandEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpExceptionCommand,
            ingrExceptionCfgGet.ptpExceptionCommand, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpExceptionCpuCode,
            ingrExceptionCfgGet.ptpExceptionCpuCode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpVersionCheckEnable,
            ingrExceptionCfgGet.ptpVersionCheckEnable, devNum);

        /*
            1.1. Call with
                ingrExceptionCfg
                {
                    ptpExceptionCommandEnable[GT_TRUE]
                    ptpExceptionCommand      [CPSS_PACKET_CMD_TRAP_TO_CPU_E]
                    ptpExceptionCpuCode      [CPSS_NET_CLASS_KEY_MIRROR_E]
                    ptpVersionCheckEnable    [GT_TRUE]
                }
            Expected: GT_OK.
        */
        ingrExceptionCfg.ptpExceptionCommandEnable = GT_TRUE;
        ingrExceptionCfg.ptpExceptionCommand       =
            CPSS_PACKET_CMD_TRAP_TO_CPU_E;
        ingrExceptionCfg.ptpExceptionCpuCode       =
            CPSS_NET_CLASS_KEY_MIRROR_E;
        ingrExceptionCfg.ptpVersionCheckEnable     = GT_TRUE;

        st = cpssDxChPtpIngressExceptionCfgSet(devNum, &ingrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpIngressExceptionCfgGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpIngressExceptionCfgGet(devNum, &ingrExceptionCfgGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpExceptionCommandEnable,
            ingrExceptionCfgGet.ptpExceptionCommandEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpExceptionCommand,
            ingrExceptionCfgGet.ptpExceptionCommand, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpExceptionCpuCode,
            ingrExceptionCfgGet.ptpExceptionCpuCode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpVersionCheckEnable,
            ingrExceptionCfgGet.ptpVersionCheckEnable, devNum);

        /*
            1.1. Call with
                ingrExceptionCfg
                {
                    ptpExceptionCommandEnable[GT_TRUE]
                    ptpExceptionCommand      [CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
                    ptpExceptionCpuCode      [CPSS_NET_UNKNOWN_UC_E]
                    ptpVersionCheckEnable    [GT_TRUE]
                }
            Expected: GT_OK.
        */
        ingrExceptionCfg.ptpExceptionCommandEnable = GT_TRUE;
        ingrExceptionCfg.ptpExceptionCommand       =
            CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
        ingrExceptionCfg.ptpExceptionCpuCode       =
            CPSS_NET_UNKNOWN_UC_E;
        ingrExceptionCfg.ptpVersionCheckEnable     = GT_TRUE;

        st = cpssDxChPtpIngressExceptionCfgSet(devNum, &ingrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpIngressExceptionCfgGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpIngressExceptionCfgGet(devNum, &ingrExceptionCfgGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpExceptionCommandEnable,
            ingrExceptionCfgGet.ptpExceptionCommandEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpExceptionCommand,
            ingrExceptionCfgGet.ptpExceptionCommand, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpExceptionCpuCode,
            ingrExceptionCfgGet.ptpExceptionCpuCode, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpVersionCheckEnable,
            ingrExceptionCfgGet.ptpVersionCheckEnable, devNum);

        /*
            1.1. Call with
                ingrExceptionCfg
                {
                    ptpExceptionCommandEnable[GT_FALSE]
                    ptpVersionCheckEnable    [GT_FALSE]
                }
            Expected: GT_OK.
        */
        ingrExceptionCfg.ptpExceptionCommandEnable = GT_FALSE;
        ingrExceptionCfg.ptpVersionCheckEnable     = GT_FALSE;

        st = cpssDxChPtpIngressExceptionCfgSet(devNum, &ingrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpIngressExceptionCfgGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpIngressExceptionCfgGet(devNum, &ingrExceptionCfgGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpExceptionCommandEnable,
            ingrExceptionCfgGet.ptpExceptionCommandEnable, devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            ingrExceptionCfg.ptpVersionCheckEnable,
            ingrExceptionCfgGet.ptpVersionCheckEnable, devNum);

       /*
            1.3. Call with
                ingrExceptionCfg
                {
                    ptpExceptionCommandEnable[GT_TRUE]
                    ptpExceptionCommand      [out of the range]
                    ptpExceptionCpuCode      [(CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1)]
                    ptpVersionCheckEnable    [GT_TRUE]
                }
            Expected: GT_OK.
        */
        ingrExceptionCfg.ptpExceptionCommandEnable = GT_TRUE;
        ingrExceptionCfg.ptpExceptionCpuCode       =
            (CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1);
        ingrExceptionCfg.ptpVersionCheckEnable     = GT_TRUE;

        UTF_ENUMS_CHECK_MAC(cpssDxChPtpIngressExceptionCfgSet
                    (devNum, &ingrExceptionCfg),
                    ingrExceptionCfg.ptpExceptionCommand);

       /*
            1.3. Call with
                ingrExceptionCfg
                {
                    ptpExceptionCommandEnable[GT_TRUE]
                    ptpExceptionCommand      [CPSS_PACKET_CMD_TRAP_TO_CPU_E]
                    ptpExceptionCpuCode      [out of the range]
                    ptpVersionCheckEnable    [GT_TRUE]
                }
            Expected: GT_OK.
        */
        ingrExceptionCfg.ptpExceptionCommandEnable = GT_TRUE;
        ingrExceptionCfg.ptpExceptionCommand       =
            CPSS_PACKET_CMD_TRAP_TO_CPU_E;
        ingrExceptionCfg.ptpVersionCheckEnable     = GT_TRUE;

        UTF_ENUMS_CHECK_MAC(cpssDxChPtpIngressExceptionCfgSet
                    (devNum, &ingrExceptionCfg),
                    ingrExceptionCfg.ptpExceptionCpuCode);

        /*
            1.4. Call with null ingrExceptionCfgPtr
            Expected: GT_BAD_PTR.
        */
        ingrExceptionCfg.ptpExceptionCommandEnable = GT_TRUE;
        ingrExceptionCfg.ptpExceptionCommand       =
            CPSS_PACKET_CMD_FORWARD_E;
        ingrExceptionCfg.ptpExceptionCpuCode       =
            (CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1);
        ingrExceptionCfg.ptpVersionCheckEnable     = GT_TRUE;

        st = cpssDxChPtpIngressExceptionCfgSet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /*set valid parameters*/
    ingrExceptionCfg.ptpExceptionCommandEnable = GT_TRUE;
    ingrExceptionCfg.ptpExceptionCommand       =
        CPSS_PACKET_CMD_FORWARD_E;
    ingrExceptionCfg.ptpExceptionCpuCode       =
        (CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E + 1);
    ingrExceptionCfg.ptpVersionCheckEnable     = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpIngressExceptionCfgSet(devNum, &ingrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpIngressExceptionCfgSet(devNum, &ingrExceptionCfg);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpIngressExceptionCfgGet
(
    IN  GT_U8                                     devNum,
    OUT CPSS_DXCH_PTP_INGRESS_EXCEPTION_CFG_STC   *ingrExceptionCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpIngressExceptionCfgGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with non-null ingrExceptionCfgPtr
    Expected: GT_OK.
    1.2 Call api with wrong enable ingrExceptionCfgPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st     = GT_OK;
    GT_U8                             devNum = 0;
    CPSS_DXCH_PTP_INGRESS_EXCEPTION_CFG_STC ingrExceptionCfg;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with non-null ingrExceptionCfgPtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpIngressExceptionCfgGet(devNum, &ingrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call api with wrong enable ingrExceptionCfgPtr [NULL].
            Expected: GT_OK.
        */
        st = cpssDxChPtpIngressExceptionCfgGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpIngressExceptionCfgGet(devNum, &ingrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpIngressExceptionCfgGet(devNum, &ingrExceptionCfg);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpIngressPacketCheckingModeSet
(
    IN  GT_U8                                    devNum,
    IN  GT_U32                                   domainNum,
    IN  GT_U32                                   messageType,
    IN  CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_ENT  checkingMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpIngressPacketCheckingModeSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with
        domainNum    [0 / 2 / 3]
        messageType  [0 / 8 / 15]
        checkingMode [CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_BASIC_E |
                      CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_PIGGY_BACK_E |
                      CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_BOUNDRY_CLK_E]
    Expected: GT_OK.
    1.2. Call cpssDxChPtpIngressPacketCheckingModeGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.3 Call with
        domainNum   [out of range]
        messageType [out of range]
        checkingMode[out of range]
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st        = GT_OK;
    GT_U8                                   devNum    = 0;
    GT_U32                                  domainNum;
    GT_U32                                  messageType;
    CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_ENT checkingMode;
    CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_ENT checkingModeGet;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with
                domainNum    [0]
                messageType  [0]
                checkingMode [CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_DISABLE_E]
            Expected: GT_OK.
        */
        domainNum    = 0;
        messageType  = 0;
        checkingMode = CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_BASIC_E;

        st = cpssDxChPtpIngressPacketCheckingModeSet(
                devNum,
                domainNum,
                messageType,
                checkingMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpIngressPacketCheckingModeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpIngressPacketCheckingModeGet(
                devNum,
                domainNum,
                messageType,
                &checkingModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(checkingMode, checkingModeGet, devNum);

       /*
            1.1 Call with
                domainNum    [2]
                messageType  [8]
                checkingMode [CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_PIGGY_BACK_E]
            Expected: GT_OK.
        */
        domainNum    = 2;
        messageType  = 8;
        checkingMode = CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_BASIC_E;

        st = cpssDxChPtpIngressPacketCheckingModeSet(
                devNum,
                domainNum,
                messageType,
                checkingMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpIngressPacketCheckingModeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpIngressPacketCheckingModeGet(
                devNum,
                domainNum,
                messageType,
                &checkingModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(checkingMode, checkingModeGet, devNum);


       /*
            1.1 Call with
                domainNum    [3]
                messageType  [15]
                checkingMode [CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_PIGGY_BACK_E]
            Expected: GT_OK.
        */
        domainNum    = 3;
        messageType  = 15;
        checkingMode = CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_BOUNDRY_CLK_E;

        st = cpssDxChPtpIngressPacketCheckingModeSet(
                devNum,
                domainNum,
                messageType,
                checkingMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpIngressPacketCheckingModeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpIngressPacketCheckingModeGet(
                devNum,
                domainNum,
                messageType,
                &checkingModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(checkingMode, checkingModeGet, devNum);

       /*
            1.3 Call with
                domainNum    [out of range]
                messageType  [0]
                checkingMode [CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_DISABLE_E]
            Expected: GT_OUT_OF_RANGE.
        */
        domainNum    = 20;
        messageType  = 0;
        checkingMode = CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_BASIC_E;

        st = cpssDxChPtpIngressPacketCheckingModeSet(
                devNum,
                domainNum,
                messageType,
                checkingMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);

       /*
            1.3 Call with
                domainNum    [0]
                messageType  [out of range]
                checkingMode [CPSS_DXCH_PTP_INGRESS_DOMAIN_MODE_DISABLE_E]
            Expected: GT_OUT_OF_RANGE.
        */
        domainNum    = 0;
        messageType  = 20;
        checkingMode = CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_BASIC_E;

        st = cpssDxChPtpIngressPacketCheckingModeSet(
                devNum,
                domainNum,
                messageType,
                checkingMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);

       /*
            1.3 Call with
                domainNum    [0]
                messageType  [0]
                checkingMode [out of range]
            Expected: GT_OK.
        */
        domainNum    = 0;
        messageType  = 0;
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpIngressPacketCheckingModeSet
                            (devNum,
                             domainNum,
                             messageType,
                             checkingMode), checkingMode);
    }

    /*set valid parameters*/
    domainNum    = 0;
    messageType  = 0;
    checkingMode = CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_BASIC_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpIngressPacketCheckingModeSet(
                devNum,
                domainNum,
                messageType,
                checkingMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    domainNum    = 0;
    messageType  = 0;
    checkingMode = CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_BASIC_E;
    st = cpssDxChPtpIngressPacketCheckingModeSet(
            devNum,
            domainNum,
            messageType,
            checkingMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpIngressPacketCheckingModeGet
(
    IN  GT_U8                                    devNum,
    IN  GT_U32                                   domainNum,
    IN  GT_U32                                   messageType,
    OUT CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_ENT  *checkingModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpIngressPacketCheckingModeGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with
            domainNum   [0 / 2 / 4]
            messageType [0 / 7 / 15]
    Expected: GT_OK.
    1.2. Call with domainNum and messageType out of range
    Expected: GT_BAD_PARAM.
    1.3. Call api with wrong enable checkingModePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st          = GT_OK;
    GT_U8                             devNum      = 0;
    GT_U32                            domainNum;
    GT_U32                            messageType;
    CPSS_DXCH_PTP_INGRESS_CHECKING_MODE_ENT  checkingMode;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with
                    domainNum   [0]
                    messageType [0]
        */
        domainNum = 0;
        messageType = 0;
        st = cpssDxChPtpIngressPacketCheckingModeGet(
                devNum,
                domainNum,
                messageType,
                &checkingMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call with domainNum and messageType out of range
            Expected: GT_BAD_PARAM.
        */
        domainNum = 20;
        messageType = 20;
        st = cpssDxChPtpIngressPacketCheckingModeGet(
                devNum,
                domainNum,
                messageType,
                &checkingMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.3. Call api with wrong enable checkingModePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        domainNum = 0;
        messageType = 0;
        st = cpssDxChPtpIngressPacketCheckingModeGet(
                devNum,
                domainNum,
                messageType,
                NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /*set valid parameters*/
    domainNum = 0;
    messageType = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpIngressPacketCheckingModeGet(
                devNum,
                domainNum,
                messageType,
                &checkingMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpIngressPacketCheckingModeGet(
            devNum,
            domainNum,
            messageType,
            &checkingMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpIngressExceptionCounterGet
(
    IN  GT_U8    devNum,
    OUT GT_U32   *counterPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpIngressExceptionCounterGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with non-null counterPtr
    Expected: GT_OK.
    1.2. Call api with wrong enable counterPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st      = GT_OK;
    GT_U8       devNum  = 0;
    GT_U32      counter = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with non-null counterPtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpIngressExceptionCounterGet(devNum, &counter);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call api with wrong enable counterPtr [NULL].
            Expected: GT_OK.
        */
        st = cpssDxChPtpIngressExceptionCounterGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpIngressExceptionCounterGet(devNum, &counter);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpIngressExceptionCounterGet(devNum, &counter);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpEgressExceptionCfgSet
(
    IN  GT_U8                                     devNum,
    IN  CPSS_DXCH_PTP_EGRESS_EXCEPTION_CFG_STC   *egrExceptionCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpEgressExceptionCfgSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with
        egrExceptionCfg
        {
            invalidPtpPktCmd          [CPSS_PACKET_CMD_FORWARD_E    |
                                       CPSS_PACKET_CMD_DROP_HARD_E]
            invalidOutPiggybackPktCmd [CPSS_PACKET_CMD_FORWARD_E    |
                                       CPSS_PACKET_CMD_DROP_HARD_E]
            invalidInPiggybackPktCmd  [CPSS_PACKET_CMD_FORWARD_E    |
                                       CPSS_PACKET_CMD_DROP_HARD_E]
            invalidTsPktCmd          [CPSS_PACKET_CMD_FORWARD_E     |
                                       CPSS_PACKET_CMD_DROP_HARD_E]
        }
    Expected: GT_OK.
    1.2. Call cpssDxChPtpEgressExceptionCfgGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.3. Call with
        egrExceptionCfg
        {
            invalidPtpPktCmd          [out of range]
            invalidOutPiggybackPktCmd [out of range]
            invalidInPiggybackPktCmd  [out of range]
            invalidTsPktCmd           [out of range]
        }
    Expected: GT_BAD_PARAM.
    1.4. Call with null egrExceptionCfg
    Expected: GT_BAD_PTR.
    1.5. Call with
         egrExceptionCfg
         {
             invalidPtpPktCmd          [CPSS_PACKET_CMD_TRAP_TO_CPU_E |
                                        CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
             invalidPtpCpuCode         [CPSS_NET_PTP_HEADER_ERROR_E]
             invalidOutPiggybackPktCmd [CPSS_PACKET_CMD_TRAP_TO_CPU_E|
                                        CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
             invalidOutPiggybackCpuCode[CPSS_NET_PTP_HEADER_ERROR_E]
             invalidInPiggybackPktCmd  [CPSS_PACKET_CMD_TRAP_TO_CPU_E|
                                        CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
             invalidInPiggybackCpuCode [CPSS_NET_PTP_HEADER_ERROR_E]
             invalidTsPktCmd          [CPSS_PACKET_CMD_TRAP_TO_CPU_E |
                                        CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
             invalidTsCpuCode         [CPSS_NET_PTP_HEADER_ERROR_E]
         }
    1.6. Call with
         egrExceptionCfg
         {
             invalidPtpCpuCode         [CPSS_NET_PTP_HEADER_ERROR_E]
             invalidOutPiggybackCpuCode[CPSS_NET_PTP_HEADER_ERROR_E]
             invalidInPiggybackCpuCode [CPSS_NET_PTP_HEADER_ERROR_E]
             invalidTsCpuCode          [CPSS_NET_PTP_HEADER_ERROR_E]
         }
*/
    GT_STATUS                               st          = GT_OK;
    GT_U8                                   devNum      = 0;
    CPSS_DXCH_PTP_EGRESS_EXCEPTION_CFG_STC  egrExceptionCfg;
    CPSS_DXCH_PTP_EGRESS_EXCEPTION_CFG_STC  egrExceptionCfgGet;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with
                egrExceptionCfg
                {
                    invalidPtpPktCmd          [CPSS_PACKET_CMD_FORWARD_E]
                    invalidOutPiggybackPktCmd [CPSS_PACKET_CMD_FORWARD_E]
                    invalidInPiggybackPktCmd  [CPSS_PACKET_CMD_FORWARD_E]
                    invalidTsPktCmd           [CPSS_PACKET_CMD_FORWARD_E]
                }
            Expected: GT_OK.
        */
        egrExceptionCfg.invalidPtpPktCmd          = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidOutPiggybackPktCmd = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidInPiggybackPktCmd  = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidTsPktCmd           = CPSS_PACKET_CMD_FORWARD_E;

        st = cpssDxChPtpEgressExceptionCfgSet(devNum, &egrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpEgressExceptionCfgGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpEgressExceptionCfgGet(devNum, &egrExceptionCfgGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidPtpPktCmd,
            egrExceptionCfgGet.invalidPtpPktCmd,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidOutPiggybackPktCmd,
            egrExceptionCfgGet.invalidOutPiggybackPktCmd,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidInPiggybackPktCmd,
            egrExceptionCfgGet.invalidInPiggybackPktCmd,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidTsPktCmd,
            egrExceptionCfgGet.invalidTsPktCmd,
            devNum);

        /*
            1.1. Call with
                egrExceptionCfg
                {
                    invalidPtpPktCmd          [CPSS_PACKET_CMD_FORWARD_E]
                    invalidOutPiggybackPktCmd [CPSS_PACKET_CMD_DROP_HARD_E]
                    invalidInPiggybackPktCmd  [CPSS_PACKET_CMD_DROP_HARD_E]
                    invalidTsPktCmd           [CPSS_PACKET_CMD_DROP_HARD_E]
                }
            Expected: GT_OK.
        */
        egrExceptionCfg.invalidPtpPktCmd          = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidOutPiggybackPktCmd = CPSS_PACKET_CMD_DROP_HARD_E;
        egrExceptionCfg.invalidOutPiggybackCpuCode = CPSS_NET_PTP_HEADER_ERROR_E;
        egrExceptionCfg.invalidInPiggybackPktCmd  = CPSS_PACKET_CMD_DROP_HARD_E;
        egrExceptionCfg.invalidInPiggybackCpuCode  = CPSS_NET_PTP_HEADER_ERROR_E;
        egrExceptionCfg.invalidTsPktCmd           = CPSS_PACKET_CMD_DROP_HARD_E;
        egrExceptionCfg.invalidTsCpuCode           = CPSS_NET_PTP_HEADER_ERROR_E;

        st = cpssDxChPtpEgressExceptionCfgSet(devNum, &egrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpEgressExceptionCfgGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpEgressExceptionCfgGet(devNum, &egrExceptionCfgGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidPtpPktCmd,
            egrExceptionCfgGet.invalidPtpPktCmd,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidOutPiggybackPktCmd,
            egrExceptionCfgGet.invalidOutPiggybackPktCmd,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidInPiggybackPktCmd,
            egrExceptionCfgGet.invalidInPiggybackPktCmd,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidTsPktCmd,
            egrExceptionCfgGet.invalidTsPktCmd,
            devNum);

        /*
            1.1. Call with
                egrExceptionCfg
                {
                    invalidPtpPktCmd          [CPSS_PACKET_CMD_FORWARD_E]
                    invalidOutPiggybackPktCmd [CPSS_PACKET_CMD_DROP_HARD_E]
                    invalidInPiggybackPktCmd  [CPSS_PACKET_CMD_FORWARD_E]
                    invalidTsPktCmd           [CPSS_PACKET_CMD_DROP_HARD_E]
                }
            Expected: GT_OK.
        */
        egrExceptionCfg.invalidPtpPktCmd          = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidOutPiggybackPktCmd = CPSS_PACKET_CMD_DROP_HARD_E;
        egrExceptionCfg.invalidOutPiggybackCpuCode = CPSS_NET_PTP_HEADER_ERROR_E;
        egrExceptionCfg.invalidInPiggybackPktCmd  = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidTsPktCmd           = CPSS_PACKET_CMD_DROP_HARD_E;
        egrExceptionCfg.invalidTsCpuCode           = CPSS_NET_PTP_HEADER_ERROR_E;

        st = cpssDxChPtpEgressExceptionCfgSet(devNum, &egrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpEgressExceptionCfgGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpEgressExceptionCfgGet(devNum, &egrExceptionCfgGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidPtpPktCmd,
            egrExceptionCfgGet.invalidPtpPktCmd,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidOutPiggybackPktCmd,
            egrExceptionCfgGet.invalidOutPiggybackPktCmd,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidInPiggybackPktCmd,
            egrExceptionCfgGet.invalidInPiggybackPktCmd,
            devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(
            egrExceptionCfg.invalidTsPktCmd,
            egrExceptionCfgGet.invalidTsPktCmd,
            devNum);
        /*
            1.3. Call with
                egrExceptionCfg
                {
                    invalidPtpPktCmd          [out of range]
                    invalidOutPiggybackPktCmd [CPSS_PACKET_CMD_FORWARD_E]
                    invalidInPiggybackPktCmd  [CPSS_PACKET_CMD_FORWARD_E]
                    invalidTsPktCmd           [CPSS_PACKET_CMD_FORWARD_E]
                }
            Expected: GT_OK.
        */
        egrExceptionCfg.invalidOutPiggybackPktCmd = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidInPiggybackPktCmd  = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidTsPktCmd           = CPSS_PACKET_CMD_FORWARD_E;

        UTF_ENUMS_CHECK_MAC(cpssDxChPtpEgressExceptionCfgSet(
                            devNum,
                            &egrExceptionCfg),
                            egrExceptionCfg.invalidPtpPktCmd);

        /*
            1.3. Call with
                egrExceptionCfg
                {
                    invalidPtpPktCmd          [CPSS_PACKET_CMD_FORWARD_E]
                    invalidOutPiggybackPktCmd [out of range]
                    invalidInPiggybackPktCmd  [CPSS_PACKET_CMD_FORWARD_E]
                    invalidTsPktCmd           [CPSS_PACKET_CMD_FORWARD_E]
                }
            Expected: GT_OK.
        */
        egrExceptionCfg.invalidPtpPktCmd          = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidInPiggybackPktCmd  = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidTsPktCmd           = CPSS_PACKET_CMD_FORWARD_E;

        UTF_ENUMS_CHECK_MAC(cpssDxChPtpEgressExceptionCfgSet(
                            devNum,
                            &egrExceptionCfg),
                            egrExceptionCfg.invalidOutPiggybackPktCmd);

        /*
            1.3. Call with
                egrExceptionCfg
                {
                    invalidPtpPktCmd          [CPSS_PACKET_CMD_FORWARD_E]
                    invalidOutPiggybackPktCmd [CPSS_PACKET_CMD_FORWARD_E]
                    invalidInPiggybackPktCmd  [out of range]
                    invalidTsPktCmd           [CPSS_PACKET_CMD_FORWARD_E]
                }
            Expected: GT_OK.
        */
        egrExceptionCfg.invalidPtpPktCmd          = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidOutPiggybackPktCmd = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidTsPktCmd           = CPSS_PACKET_CMD_FORWARD_E;

        UTF_ENUMS_CHECK_MAC(cpssDxChPtpEgressExceptionCfgSet(
                            devNum,
                            &egrExceptionCfg),
                            egrExceptionCfg.invalidInPiggybackPktCmd);
        /*
            1.3. Call with
                egrExceptionCfg
                {
                    invalidPtpPktCmd          [CPSS_PACKET_CMD_FORWARD_E]
                    invalidOutPiggybackPktCmd [CPSS_PACKET_CMD_FORWARD_E]
                    invalidInPiggybackPktCmd  [CPSS_PACKET_CMD_FORWARD_E]
                    invalidTsPktCmd           [out of range]
                }
            Expected: GT_OK.
        */
        egrExceptionCfg.invalidPtpPktCmd          = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidOutPiggybackPktCmd = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidInPiggybackPktCmd  = CPSS_PACKET_CMD_FORWARD_E;

        UTF_ENUMS_CHECK_MAC(cpssDxChPtpEgressExceptionCfgSet(
                            devNum,
                            &egrExceptionCfg),
                            egrExceptionCfg.invalidTsPktCmd);
        /*
            1.4. Call with null egrExceptionCfg
            Expected: GT_BAD_PTR.
        */
        egrExceptionCfg.invalidPtpPktCmd          = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidOutPiggybackPktCmd = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidInPiggybackPktCmd  = CPSS_PACKET_CMD_FORWARD_E;
        egrExceptionCfg.invalidTsPktCmd           = CPSS_PACKET_CMD_FORWARD_E;

        st = cpssDxChPtpEgressExceptionCfgSet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);

       /* 1.5. Call with
         egrExceptionCfg
         {
             invalidPtpPktCmd          [CPSS_PACKET_CMD_TRAP_TO_CPU_E |
                                        CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
             invalidPtpCpuCode         [CPSS_NET_PTP_HEADER_ERROR_E]
             invalidOutPiggybackPktCmd [CPSS_PACKET_CMD_TRAP_TO_CPU_E|
                                        CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
             invalidOutPiggybackCpuCode[CPSS_NET_PTP_HEADER_ERROR_E]
             invalidInPiggybackPktCmd  [CPSS_PACKET_CMD_TRAP_TO_CPU_E|
                                        CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
             invalidInPiggybackCpuCode [CPSS_NET_PTP_HEADER_ERROR_E]
             invalidTsPktCmd          [CPSS_PACKET_CMD_TRAP_TO_CPU_E |
                                        CPSS_PACKET_CMD_MIRROR_TO_CPU_E]
             invalidTsCpuCode         [CPSS_NET_PTP_HEADER_ERROR_E]
         }
         Expected: GT_OK
       */
        if (PRV_CPSS_SIP_6_CHECK_MAC(devNum))
        {
            egrExceptionCfg.invalidPtpPktCmd          = CPSS_PACKET_CMD_TRAP_TO_CPU_E;
            egrExceptionCfg.invalidPtpCpuCode         = CPSS_NET_PTP_HEADER_ERROR_E;
            egrExceptionCfg.invalidOutPiggybackPktCmd = CPSS_PACKET_CMD_TRAP_TO_CPU_E;
            egrExceptionCfg.invalidOutPiggybackCpuCode = CPSS_NET_PTP_HEADER_ERROR_E;
            egrExceptionCfg.invalidInPiggybackPktCmd  = CPSS_PACKET_CMD_TRAP_TO_CPU_E;
            egrExceptionCfg.invalidInPiggybackCpuCode  = CPSS_NET_PTP_HEADER_ERROR_E;
            egrExceptionCfg.invalidTsPktCmd           = CPSS_PACKET_CMD_TRAP_TO_CPU_E;
            egrExceptionCfg.invalidTsCpuCode           = CPSS_NET_PTP_HEADER_ERROR_E;

            st = cpssDxChPtpEgressExceptionCfgSet(devNum, &egrExceptionCfg);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
            1.6. Call cpssDxChPtpEgressExceptionCfgGet().
            Expected: GT_OK and same mode and cpu code as set
            */
            st = cpssDxChPtpEgressExceptionCfgGet(devNum, &egrExceptionCfgGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidPtpPktCmd,
                egrExceptionCfgGet.invalidPtpPktCmd,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidPtpCpuCode,
                egrExceptionCfgGet.invalidPtpCpuCode,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidOutPiggybackPktCmd,
                egrExceptionCfgGet.invalidOutPiggybackPktCmd,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidOutPiggybackCpuCode,
                egrExceptionCfgGet.invalidOutPiggybackCpuCode,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidInPiggybackPktCmd,
                egrExceptionCfgGet.invalidInPiggybackPktCmd,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidInPiggybackCpuCode,
                egrExceptionCfgGet.invalidInPiggybackCpuCode,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidTsPktCmd,
                egrExceptionCfgGet.invalidTsPktCmd,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidTsCpuCode,
                egrExceptionCfgGet.invalidTsCpuCode,
                devNum);

            egrExceptionCfg.invalidPtpPktCmd          = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
            egrExceptionCfg.invalidPtpCpuCode         = CPSS_NET_PTP_HEADER_ERROR_E;
            egrExceptionCfg.invalidOutPiggybackPktCmd = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
            egrExceptionCfg.invalidOutPiggybackCpuCode = CPSS_NET_PTP_HEADER_ERROR_E;
            egrExceptionCfg.invalidInPiggybackPktCmd  = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
            egrExceptionCfg.invalidInPiggybackCpuCode  = CPSS_NET_PTP_HEADER_ERROR_E;
            egrExceptionCfg.invalidTsPktCmd           = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
            egrExceptionCfg.invalidTsCpuCode           = CPSS_NET_PTP_HEADER_ERROR_E;

            st = cpssDxChPtpEgressExceptionCfgSet(devNum, &egrExceptionCfg);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                Call cpssDxChPtpEgressExceptionCfgGet().
                Expected: GT_OK and same mode and cpu code as set
            */
            st = cpssDxChPtpEgressExceptionCfgGet(devNum, &egrExceptionCfgGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* verifying values */
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidPtpPktCmd,
                egrExceptionCfgGet.invalidPtpPktCmd,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidPtpCpuCode,
                egrExceptionCfgGet.invalidPtpCpuCode,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidOutPiggybackPktCmd,
                egrExceptionCfgGet.invalidOutPiggybackPktCmd,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidOutPiggybackCpuCode,
                egrExceptionCfgGet.invalidOutPiggybackCpuCode,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidInPiggybackPktCmd,
                egrExceptionCfgGet.invalidInPiggybackPktCmd,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidInPiggybackCpuCode,
                egrExceptionCfgGet.invalidInPiggybackCpuCode,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidTsPktCmd,
                egrExceptionCfgGet.invalidTsPktCmd,
                devNum);
            UTF_VERIFY_EQUAL1_PARAM_MAC(
                egrExceptionCfg.invalidTsCpuCode,
                egrExceptionCfgGet.invalidTsCpuCode,
                devNum);
        }
    }

    /*set valid parameters*/
    egrExceptionCfg.invalidPtpPktCmd          = CPSS_PACKET_CMD_FORWARD_E;
    egrExceptionCfg.invalidOutPiggybackPktCmd = CPSS_PACKET_CMD_FORWARD_E;
    egrExceptionCfg.invalidInPiggybackPktCmd  = CPSS_PACKET_CMD_FORWARD_E;
    egrExceptionCfg.invalidTsPktCmd           = CPSS_PACKET_CMD_FORWARD_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpEgressExceptionCfgSet(devNum, &egrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpEgressExceptionCfgSet(devNum, &egrExceptionCfg);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpEgressExceptionCfgGet
(
    IN  GT_U8                                    devNum,
    OUT CPSS_DXCH_PTP_EGRESS_EXCEPTION_CFG_STC   *egrExceptionCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpEgressExceptionCfgGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with non-null egrExceptionCfgPtr
    Expected: GT_OK.
    1.2. Call api with wrong enable egrExceptionCfgPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st      = GT_OK;
    GT_U8       devNum  = 0;
    CPSS_DXCH_PTP_EGRESS_EXCEPTION_CFG_STC   egrExceptionCfg;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with non-null egrExceptionCfgPtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpEgressExceptionCfgGet(devNum, &egrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call api with wrong enable egrExceptionCfgPtr [NULL].
            Expected: GT_OK.
        */
        st = cpssDxChPtpEgressExceptionCfgGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpEgressExceptionCfgGet(devNum, &egrExceptionCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpEgressExceptionCfgGet(devNum, &egrExceptionCfg);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpEgressExceptionCountersGet
(
    IN  GT_U8                                         devNum,
    OUT CPSS_DXCH_PTP_EGRESS_EXCEPTION_COUNTERS_STC   *egrExceptionCntPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpEgressExceptionCountersGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with non-null egrExceptionCntPtr
    Expected: GT_OK.
    1.2 Call api with wrong enable egrExceptionCntPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st      = GT_OK;
    GT_U8       devNum  = 0;
    CPSS_DXCH_PTP_EGRESS_EXCEPTION_COUNTERS_STC   egrExceptionCnt;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with non-null egrExceptionCntPtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpEgressExceptionCountersGet(devNum, &egrExceptionCnt);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call api with wrong enable egrExceptionCntPtr [NULL].
            Expected: GT_OK.
        */
        st = cpssDxChPtpEgressExceptionCountersGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpEgressExceptionCountersGet(devNum, &egrExceptionCnt);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpEgressExceptionCountersGet(devNum, &egrExceptionCnt);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsIngressTimestampQueueEntryRead
(
    IN  GT_U8                                                devNum,
    IN  GT_U32                                               queueNum,
    OUT CPSS_DXCH_PTP_TS_INGRESS_TIMESTAMP_QUEUE_ENTRY_STC   *tsQueueEntryPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsIngressTimestampQueueEntryRead)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with queueNum [0 / 1]
    Expected: GT_OK.
    1.2. Call with queueNum out of range
    Expected: GT_BAD_PARAM.
    1.3. Call api with wrong enable tsQueueEntryPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st          = GT_OK;
    GT_U8                             devNum      = 0;
    GT_U32                            queueNum;
    CPSS_DXCH_PTP_TS_INGRESS_TIMESTAMP_QUEUE_ENTRY_STC   tsQueueEntry;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with queueNum [0]
            Expected: GT_OK.
        */
        queueNum = 0;
        st = cpssDxChPtpTsIngressTimestampQueueEntryRead(
                devNum,
                queueNum,
                &tsQueueEntry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1. Call with queueNum [1]
            Expected: GT_OK.
        */
        queueNum = 1;
        st = cpssDxChPtpTsIngressTimestampQueueEntryRead(
                devNum,
                queueNum,
                &tsQueueEntry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call with queueNum out of range
            Expected: GT_BAD_PARAM.
        */
        queueNum = 2;
        st = cpssDxChPtpTsIngressTimestampQueueEntryRead(
                devNum,
                queueNum,
                &tsQueueEntry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.3. Call api with wrong enable tsQueueEntryPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        queueNum = 0;
        st = cpssDxChPtpTsIngressTimestampQueueEntryRead(
                devNum,
                queueNum,
                NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /*set valid parameters*/
    queueNum = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsIngressTimestampQueueEntryRead(
                devNum,
                queueNum,
                &tsQueueEntry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsIngressTimestampQueueEntryRead(
                devNum,
                queueNum,
                &tsQueueEntry);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsEgressTimestampQueueEntryRead
(
    IN  GT_U8                                                devNum,
    IN  GT_U32                                               queueNum,
    OUT CPSS_DXCH_PTP_TS_EGRESS_TIMESTAMP_QUEUE_ENTRY_STC    *tsQueueEntryPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsEgressTimestampQueueEntryRead)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with queueNum [0 / 1]
    Expected: GT_OK.
    1.2. Call with queueNum out of range
    Expected: GT_BAD_PARAM.
    1.3. Call api with wrong enable tsQueueEntryPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st          = GT_OK;
    GT_U8                             devNum      = 0;
    GT_U32                            queueNum;
    CPSS_DXCH_PTP_TS_EGRESS_TIMESTAMP_QUEUE_ENTRY_STC    tsQueueEntry;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with queueNum [0]
            Expected: GT_OK.
        */
        queueNum = 0;
        st = cpssDxChPtpTsEgressTimestampQueueEntryRead(
                devNum,
                queueNum,
                &tsQueueEntry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1. Call with queueNum [1]
            Expected: GT_OK.
        */
        queueNum = 1;
        st = cpssDxChPtpTsEgressTimestampQueueEntryRead(
                devNum,
                queueNum,
                &tsQueueEntry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call with queueNum out of range
            Expected: GT_BAD_PARAM.
        */
        queueNum = 2;
        st = cpssDxChPtpTsEgressTimestampQueueEntryRead(
                devNum,
                queueNum,
                &tsQueueEntry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.3. Call api with wrong enable tsQueueEntryPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        queueNum = 0;
        st = cpssDxChPtpTsEgressTimestampQueueEntryRead(
                devNum,
                queueNum,
                NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /*set valid parameters*/
    queueNum = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsEgressTimestampQueueEntryRead(
                devNum,
                queueNum,
                &tsQueueEntry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsEgressTimestampQueueEntryRead(
                devNum,
                queueNum,
                &tsQueueEntry);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsMessageTypeToQueueIdMapSet
(
    IN  GT_U8        devNum,
    IN  GT_U32       idMapBmp
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsMessageTypeToQueueIdMapSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with idMapBmp [0 / 0xFF / 0xFFFF]
    Expected: GT_OK.
    1.2. Call cpssDxChPtpTsMessageTypeToQueueIdMapGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.3. Call with idMapBmp out of range
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                         st          = GT_OK;
    GT_U8                             devNum      = 0;
    GT_U32                            idMapBmp    = GT_TRUE;
    GT_U32                            idMapBmpGet = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with idMapBmp [0]
            Expected: GT_OK.
        */
        idMapBmp = 0;
        st = cpssDxChPtpTsMessageTypeToQueueIdMapSet(devNum, idMapBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsMessageTypeToQueueIdMapGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsMessageTypeToQueueIdMapGet(devNum, &idMapBmpGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(idMapBmp, idMapBmpGet, devNum);

        /*
            1.1. Call with idMapBmp [0xFF]
            Expected: GT_OK.
        */
        idMapBmp = 0xFF;
        st = cpssDxChPtpTsMessageTypeToQueueIdMapSet(devNum, idMapBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsMessageTypeToQueueIdMapGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsMessageTypeToQueueIdMapGet(devNum, &idMapBmpGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(idMapBmp, idMapBmpGet, devNum);

        /*
            1.1 Call with idMapBmp [0xFFFF]
            Expected: GT_OK.
        */
        idMapBmp = 0xFFFF;
        st = cpssDxChPtpTsMessageTypeToQueueIdMapSet(devNum, idMapBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsMessageTypeToQueueIdMapGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsMessageTypeToQueueIdMapGet(devNum, &idMapBmpGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(idMapBmp, idMapBmpGet, devNum);


        /*
            1.3. Call with idMapBmp out of range
            Expected: GT_OUT_OF_RANGE.
        */
        idMapBmp = 0xFFFFF;
        st = cpssDxChPtpTsMessageTypeToQueueIdMapSet(devNum, idMapBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);
    }

    /*set valid parameters*/
    idMapBmp = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsMessageTypeToQueueIdMapSet(devNum, idMapBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsMessageTypeToQueueIdMapSet(devNum, idMapBmp);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsMessageTypeToQueueIdMapGet
(
    IN  GT_U8        devNum,
    OUT GT_U32       *idMapBmpPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsMessageTypeToQueueIdMapGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with non-null idMapBmpPtr
    Expected: GT_OK.
    1.2. Call api with wrong enable idMapBmpPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st      = GT_OK;
    GT_U8       devNum  = 0;
    GT_U32      idMapBmp;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with non-null idMapBmpPtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpTsMessageTypeToQueueIdMapGet(devNum, &idMapBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call api with wrong enable idMapBmpPtr [NULL].
            Expected: GT_OK.
        */
        st = cpssDxChPtpTsMessageTypeToQueueIdMapGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsMessageTypeToQueueIdMapGet(devNum, &idMapBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsMessageTypeToQueueIdMapGet(devNum, &idMapBmp);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsQueuesSizeSet
(
    IN  GT_U8       devNum,
    IN  GT_U32      queueSize
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsQueuesSizeSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with queueSize [0 / 127 / 254]
    Expected: GT_OK.
    1.2. Call cpssDxChPtpTsQueuesSizeGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
    1.3. Call with queueSize out of range
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                         st           = GT_OK;
    GT_U8                             devNum       = 0;
    GT_U32                            queueSize    = GT_TRUE;
    GT_U32                            queueSizeGet = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with queueSize [0]
            Expected: GT_OK.
        */
        queueSize = 0;
        st = cpssDxChPtpTsQueuesSizeSet(devNum, queueSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsQueuesSizeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsQueuesSizeGet(devNum, &queueSizeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(queueSize, queueSizeGet, devNum);

        /*
            1.1. Call with queueSize [127]
            Expected: GT_OK.
        */
        queueSize = 127;
        st = cpssDxChPtpTsQueuesSizeSet(devNum, queueSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsQueuesSizeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsQueuesSizeGet(devNum, &queueSizeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(queueSize, queueSizeGet, devNum);

        /*
            1.1. Call with queueSize [254]
            Expected: GT_OK.
        */
        queueSize = 254;
        st = cpssDxChPtpTsQueuesSizeSet(devNum, queueSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsQueuesSizeGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsQueuesSizeGet(devNum, &queueSizeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(queueSize, queueSizeGet, devNum);

        /*
            1.1 Call with queueSize out of range
            Expected: GT_BAD_PARAM.
        */

        queueSize = 300;
        st = cpssDxChPtpTsQueuesSizeSet(devNum, queueSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
    }

    /*set valid parameters*/
    queueSize = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsQueuesSizeSet(devNum, queueSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsQueuesSizeSet(devNum, queueSize);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsQueuesSizeGet
(
    IN  GT_U8       devNum,
    OUT GT_U32      *queueSizePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsQueuesSizeGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1 Call with non-null queueSizePtr
    Expected: GT_OK.
    1.2 Call api with wrong queueSizePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st     = GT_OK;
    GT_U8                             devNum = 0;
    GT_U32                            queueSize;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with non-null queueSizePtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpTsQueuesSizeGet(devNum, &queueSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call api with wrong queueSizePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTsQueuesSizeGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsQueuesSizeGet(devNum, &queueSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsQueuesSizeGet(devNum, &queueSize);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDebugQueuesEntryIdsClear
(
    IN  GT_U8       devNum
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDebugQueuesEntryIdsClear)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1. Go over all active devices.
    Expected: GT_OK.
    2. Go over all non-applicable devices.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    3. Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                         st     = GT_OK;
    GT_U8                             devNum = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = cpssDxChPtpTsDebugQueuesEntryIdsClear(devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDebugQueuesEntryIdsClear(devNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDebugQueuesEntryIdsClear(devNum);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsDebugQueuesEntryIdsGet
(
    IN  GT_U8       devNum,
    OUT GT_U32      *queueEntryId0Ptr,
    OUT GT_U32      *queueEntryId1Ptr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsDebugQueuesEntryIdsGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with non-null queueEntryId0Ptr and queueEntryId1Ptr
    Expected: GT_OK.
    1.2. Call api with wrong queueEntryId0Ptr [NULL]
                          and queueEntryId1Ptr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st            = GT_OK;
    GT_U8                             devNum        = 0;
    GT_U32                            queueEntryId0 = 0;
    GT_U32                            queueEntryId1 = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with non-null queueEntryId0Ptr and queueEntryId1Ptr
            Expected: GT_OK.
        */
        st = cpssDxChPtpTsDebugQueuesEntryIdsGet(
                devNum,
                &queueEntryId0,
                &queueEntryId1);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call api with wrong queueEntryId0Ptr [NULL]
                                  and queueEntryId1Ptr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTsDebugQueuesEntryIdsGet(devNum, NULL, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsDebugQueuesEntryIdsGet(
                devNum,
                &queueEntryId0,
                &queueEntryId1);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsDebugQueuesEntryIdsGet(
            devNum,
            &queueEntryId0,
            &queueEntryId1);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsNtpTimeOffsetSet
(
    IN  GT_U8                             devNum,
    IN  GT_U32                            ntpTimeOffset
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsNtpTimeOffsetSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1. Call with ntpTimeOffset [0 / 0xFFFF / 0xFFFFFFFF]
    Expected: GT_OK.
    1.2. Call cpssDxChPtpTsNtpTimeOffsetGet().
    Expected: GT_OK and same mode as was set in 1.1.1.
*/
    GT_STATUS                         st        = GT_OK;
    GT_U8                             devNum    = 0;
    GT_U32                            ntpTimeOffset;
    GT_U32                            ntpTimeOffsetGet;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1. Call with ntpTimeOffset [0]
            Expected: GT_OK.
        */
        ntpTimeOffset = 0;
        st = cpssDxChPtpTsNtpTimeOffsetSet(devNum, ntpTimeOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsNtpTimeOffsetGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsNtpTimeOffsetGet(devNum, &ntpTimeOffsetGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(ntpTimeOffset, ntpTimeOffsetGet, devNum);

        /*
            1.1 Call with ntpTimeOffset [0xFFFF]
            Expected: GT_OK.
        */
        ntpTimeOffset = 0xFFFF;
        st = cpssDxChPtpTsNtpTimeOffsetSet(devNum, ntpTimeOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsNtpTimeOffsetGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsNtpTimeOffsetGet(devNum, &ntpTimeOffsetGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(ntpTimeOffset, ntpTimeOffsetGet, devNum);

        /*
            1.1. Call with ntpTimeOffset [0xFFFF]
            Expected: GT_OK.
        */
        ntpTimeOffset = 0xFFFFFFFF;
        st = cpssDxChPtpTsNtpTimeOffsetSet(devNum, ntpTimeOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTsNtpTimeOffsetGet().
            Expected: GT_OK and same mode as was set in 1.1.1.
        */
        st = cpssDxChPtpTsNtpTimeOffsetGet(devNum, &ntpTimeOffsetGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* verifying values */
        UTF_VERIFY_EQUAL1_PARAM_MAC(ntpTimeOffset, ntpTimeOffsetGet, devNum);
    }

    /*set valid parameters*/
    ntpTimeOffset = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsNtpTimeOffsetSet(devNum, ntpTimeOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsNtpTimeOffsetSet(devNum, ntpTimeOffset);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsNtpTimeOffsetGet
(
    IN  GT_U8                             devNum,
    OUT GT_U32                            *ntpTimeOffsetPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsNtpTimeOffsetGet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with non-null ntpTimeOffsetPtr
    Expected: GT_OK.
    1.1.2 Call api with wrong ntpTimeOffsetPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS  st     = GT_OK;
    GT_U8      devNum = 0;
    GT_U32     ntpTimeOffset;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with non-null ntpTimeOffsetPtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpTsNtpTimeOffsetGet(devNum, &ntpTimeOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1.2 Call api with wrong ntpTimeOffsetPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTsNtpTimeOffsetGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E);
    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsNtpTimeOffsetGet(devNum, &ntpTimeOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsNtpTimeOffsetGet(devNum, &ntpTimeOffset);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}
/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPtpPulseInterfaceSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DIRECTION_ENT                      pulseInterfaceDirection,
    IN  CPSS_DXCH_PTP_TAI_NUMBER_ENT            taiNumber
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPtpPulseInterfaceSet)
{
/*
    ITERATE_DEVICES(Bobcat2)
    1.1. Call cpssDxChPtpTaiPtpPulseInterfaceSet with pulseInterfaceDirection[CPSS_DIRECTION_INGRESS_E /
                                           CPSS_DIRECTION_EGRESS_E],
                   taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_0_E / CPSS_DXCH_PTP_TAI_NUMBER_1_E]
    Expected: GT_OK.
    1.2. Call cpssDxChPtpTaiPtpPulseInterfaceGet
           with the same parameters.
    Expected: GT_OK and the same taiNumber for pulseInterfaceDirection[CPSS_DIRECTION_INGRESS_E].
    1.3. Call api with wrong pulseInterfaceDirection[CPSS_DIRECTION_BOTH_E].
    Expected: GT_BAD_PARAM.
    1.4. Call api with wrong taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_ALL_E].
*/
    GT_STATUS st = GT_OK;

    GT_U8                           dev;
    CPSS_DIRECTION_ENT              pulseInterfaceDirection[3] =
        {CPSS_DIRECTION_INGRESS_E, CPSS_DIRECTION_EGRESS_E, CPSS_DIRECTION_BOTH_E};
    CPSS_DIRECTION_ENT              pulseInterfaceDirectionGet[3] =
        {CPSS_DIRECTION_INGRESS_E, CPSS_DIRECTION_EGRESS_E, CPSS_DIRECTION_BOTH_E};
    CPSS_DXCH_PTP_TAI_NUMBER_ENT    taiNumber[3] =
        {CPSS_DXCH_PTP_TAI_NUMBER_0_E, CPSS_DXCH_PTP_TAI_NUMBER_1_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E};
    CPSS_DXCH_PTP_TAI_NUMBER_ENT    taiNumberGet[3] =
        {CPSS_DXCH_PTP_TAI_NUMBER_0_E, CPSS_DXCH_PTP_TAI_NUMBER_1_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E};

    GT_U32 i, j;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                                                                UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        for(i = 0; i < CPSS_DIRECTION_BOTH_E; i++)
        {
            for(j = 0; j < CPSS_DXCH_PTP_TAI_NUMBER_2_E; j++)
            {

                /*
                    1.1. Call with pulseInterfaceDirection[CPSS_DIRECTION_INGRESS_E /
                                                           CPSS_DIRECTION_EGRESS_E],
                                   taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_0_E / CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    Expected: GT_OK.
                */
                st = cpssDxChPtpTaiPtpPulseInterfaceSet(dev, pulseInterfaceDirection[i], taiNumber[j]);

                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                /*
                    1.2. Call cpssDxChPtpTaiPtpPulseInterfaceGet with the same parameters.
                    Expected: GT_OK and the same values than was set.
                */
                st = cpssDxChPtpTaiPtpPulseInterfaceGet(dev, &pulseInterfaceDirectionGet[i], &taiNumberGet[j]);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                          "cpssDxChPtpTaiPtpPulseInterfaceGet: %d ", dev);

                if (PRV_CPSS_SIP_5_20_CHECK_MAC(dev) && !(PRV_CPSS_SIP_6_CHECK_MAC(dev)))
                {
                    if(pulseInterfaceDirection[i] == CPSS_DIRECTION_INGRESS_E)
                    {
                        /* Verifying values */
                        UTF_VERIFY_EQUAL1_STRING_MAC(CPSS_DIRECTION_EGRESS_E, pulseInterfaceDirectionGet[i],
                                       "got another pulseInterfaceDirection then was set: %d", dev);
                    }
                    else
                    {
                        UTF_VERIFY_EQUAL1_STRING_MAC(taiNumber[j], taiNumberGet[j],
                                       "got another taiNumber then was set: %d", dev);
                    }
                }
                else
                {
                    /* Verifying values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(pulseInterfaceDirection[i], pulseInterfaceDirectionGet[i],
                                   "got another pulseInterfaceDirection then was set: %d", dev);

                    if(pulseInterfaceDirectionGet[i] == CPSS_DIRECTION_EGRESS_E)
                    {
                        UTF_VERIFY_EQUAL1_STRING_MAC(taiNumber[j], taiNumberGet[j],
                                       "got another taiNumber then was set: %d", dev);
                    }
                }
            }
        }

        for(j = 0; j < CPSS_DXCH_PTP_TAI_NUMBER_2_E; j++)
        {
            /*
                1.3. Call api with wrong pulseInterfaceDirection[CPSS_DIRECTION_BOTH_E].
                Expected: GT_BAD_PARAM.
            */
            st = cpssDxChPtpTaiPtpPulseInterfaceSet(dev, CPSS_DIRECTION_BOTH_E, taiNumber[j]);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }

        /*
            1.4. Call api with wrong CPSS_DIRECTION_EGRESS_E and taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_ALL_E].
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiPtpPulseInterfaceSet(dev, CPSS_DIRECTION_EGRESS_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E);
        if (! SINGLE_TAI_DEV_MAC(dev))
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }
        else
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }

        /*
            1.5. Call api with wrong pulseInterfaceDirection[wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPtpPulseInterfaceSet(dev, pulseInterfaceDirection[0], taiNumber[0]),
                            pulseInterfaceDirection[0]);
        /*
            1.6. Call api with wrong taiNumber[wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(
                cpssDxChPtpTaiPtpPulseInterfaceSet(dev, pulseInterfaceDirection[1], taiNumber[0]),
                    taiNumber[0]);
        }
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                   UTF_LION2_E | UTF_IRONMAN_L_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiPtpPulseInterfaceSet(dev, pulseInterfaceDirection[0], taiNumber[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiPtpPulseInterfaceSet(dev, pulseInterfaceDirection[0], taiNumber[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPtpPulseInterfaceGet
(
    IN  GT_U8                                devNum,
    OUT CPSS_DIRECTION_ENT                   *pulseInterfaceDirectionPtr,
    OUT CPSS_DXCH_PTP_TAI_NUMBER_ENT         *taiNumberPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPtpPulseInterfaceGet)
{
/*
    ITERATE_DEVICES(Bobcat2)
    1.1.1 Call with non-null pulseInterfaceDirectionPtr & taiNumberPtr
    Expected: GT_OK.
    1.1.2 Call api with wrong pulseInterfaceDirectionPtr [NULL].
    Expected: GT_BAD_PTR.
    1.1.3 Call api with wrong taiNumberPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                           st = GT_OK;
    GT_U8                               devNum = 0;
    CPSS_DIRECTION_ENT              pulseInterfaceDirection;
    CPSS_DXCH_PTP_TAI_NUMBER_ENT    taiNumber;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                                                                UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_IRONMAN_L_E );

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with non-null pulseInterfaceDirectionPtr & taiNumber
            Expected: GT_OK.
        */
        st = cpssDxChPtpTaiPtpPulseInterfaceGet(devNum, &pulseInterfaceDirection, &taiNumber);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1.2 Call api with wrong pulseInterfaceDirectionPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTaiPtpPulseInterfaceGet(devNum, NULL, &taiNumber);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);


        /*
            1.1.3 Call api with wrong taiNumberPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            st = cpssDxChPtpTaiPtpPulseInterfaceGet(devNum, &pulseInterfaceDirection, NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                   UTF_LION2_E | UTF_IRONMAN_L_E);

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiPtpPulseInterfaceGet(devNum, &pulseInterfaceDirection, &taiNumber);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiPtpPulseInterfaceGet(devNum, &pulseInterfaceDirection, &taiNumber);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPClkInterfaceSet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PTP_TAI_NUMBER_ENT         taiNumber,
    IN  CPSS_DIRECTION_ENT                   clockInterfaceDirection
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPClkInterfaceSet)
{
/*
    ITERATE_DEVICES(Bobcat2)
    1.1. Call cpssDxChPtpTaiPClkInterfaceSet with taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_0_E / CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            pulseInterfaceDirection[CPSS_DIRECTION_INGRESS_E /CPSS_DIRECTION_EGRESS_E],
    Expected: GT_OK.
    1.2. Call cpssDxChPtpTaiPClkInterfaceGet
           with the same parameters.
    Expected: GT_OK.
    1.3. Call api with wrong pulseInterfaceDirection[CPSS_DIRECTION_BOTH_E].
    Expected: GT_BAD_PARAM.
    1.4. Call api with wrong taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_ALL_E].
*/
    GT_STATUS st = GT_OK;

    GT_U8                           dev;
    CPSS_DXCH_PTP_TAI_NUMBER_ENT    taiNumber[3] =
        {CPSS_DXCH_PTP_TAI_NUMBER_0_E, CPSS_DXCH_PTP_TAI_NUMBER_1_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E};
    CPSS_DIRECTION_ENT              clockInterfaceDirection[3] =
        {CPSS_DIRECTION_INGRESS_E, CPSS_DIRECTION_EGRESS_E, CPSS_DIRECTION_BOTH_E};
    CPSS_DIRECTION_ENT              clockInterfaceDirectionGet[3] =
        {CPSS_DIRECTION_INGRESS_E, CPSS_DIRECTION_EGRESS_E, CPSS_DIRECTION_BOTH_E};

    GT_U32 i, j;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                                                                UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            for(j = 0; j < CPSS_DIRECTION_BOTH_E; j++)
            {
                /*
                    1.1. Call with taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_0_E / CPSS_DXCH_PTP_TAI_NUMBER_1_E],
                                   clockInterfaceDirection[CPSS_DIRECTION_INGRESS_E /
                                                           CPSS_DIRECTION_EGRESS_E]
                    Expected: GT_OK.
                */
                st = cpssDxChPtpTaiPClkInterfaceSet(dev, taiNumber[i], clockInterfaceDirection[j]);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                /*
                    1.2. Call cpssDxChPtpTaiPClkInterfaceGet with the same parameters.
                    Expected: GT_OK and the same values than was set.
                */
                st = cpssDxChPtpTaiPClkInterfaceGet(dev, taiNumber[i], &clockInterfaceDirectionGet[j]);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                          "cpssDxChPtpTaiPtpPulseInterfaceGet: %d ", dev);

                /* Verifying values */
                if (! SINGLE_TAI_DEV_MAC(dev))
                {
                    UTF_VERIFY_EQUAL1_STRING_MAC(taiNumber[i], taiNumber[i],
                                   "got another taiNumber then was set: %d", dev);
                }
                UTF_VERIFY_EQUAL1_STRING_MAC(clockInterfaceDirection[j], clockInterfaceDirectionGet[j],
                               "got another taiNumber then was set: %d", dev);
            }
        }

        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            /*
                1.3. Call api with wrong clockInterfaceDirection[CPSS_DIRECTION_BOTH_E].
                Expected: GT_BAD_PARAM.
            */
            st = cpssDxChPtpTaiPClkInterfaceSet(dev, taiNumber[i], CPSS_DIRECTION_BOTH_E);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }

        for(j = 0; j < CPSS_DIRECTION_BOTH_E; j++)
        {
            /*
                1.4. Call api with wrong taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_ALL_E].
                Expected: GT_BAD_PARAM.
            */
            st = cpssDxChPtpTaiPClkInterfaceSet(dev, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E, clockInterfaceDirection[j]);
            if (! SINGLE_TAI_DEV_MAC(dev))
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }
        }

        /*
            1.5. Call api with wrong taiNumber[wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(
                cpssDxChPtpTaiPClkInterfaceSet(dev, taiNumber[0], clockInterfaceDirection[0]),
                    taiNumber[0]);
        }
        /*
            1.6. Call api with wrong clockInterfaceDirection[wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkInterfaceSet(dev, taiNumber[0], clockInterfaceDirection[0]),
                            clockInterfaceDirection[0]);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                   UTF_LION2_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E | UTF_IRONMAN_L_E );

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiPClkInterfaceSet(dev, taiNumber[0], clockInterfaceDirection[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiPClkInterfaceSet(dev, taiNumber[0], clockInterfaceDirection[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPClkInterfaceGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PTP_TAI_NUMBER_ENT         taiNumber,
    OUT CPSS_DIRECTION_ENT                   *clockInterfaceDirectionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPClkInterfaceGet)
{
/*
    ITERATE_DEVICES(Bobcat2)
    1.1.1 Call with non-null clockInterfaceDirectionPtr
    Expected: GT_OK.
    1.1.2 Call api with wrong clockInterfaceDirectionPtr[NULL].
    Expected: GT_BAD_PTR.
    1.1.3 Call api with wrong taiNumber.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                           st = GT_OK;
    GT_U8                               devNum = 0;
    CPSS_DIRECTION_ENT                  clockInterfaceDirection;
    CPSS_DXCH_PTP_TAI_NUMBER_ENT        taiNumber[3] =
        {CPSS_DXCH_PTP_TAI_NUMBER_0_E, CPSS_DXCH_PTP_TAI_NUMBER_1_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E};
    GT_U32 i;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                                                                UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            /*
                1.1.1 Call with non-null clockInterfaceDirectionPtr
                Expected: GT_OK.
            */
            st = cpssDxChPtpTaiPClkInterfaceGet(devNum, taiNumber[i], &clockInterfaceDirection);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2 Call api with wrong clockInterfaceDirectionPtr [NULL].
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPtpTaiPClkInterfaceGet(devNum, taiNumber[i], NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }
        /*
            1.1.3 Call api with wrong taiNumber.
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiPClkInterfaceGet(devNum, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E, &clockInterfaceDirection);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
        }
        else
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);
        }
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                   UTF_LION2_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E | UTF_IRONMAN_L_E);

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiPClkInterfaceGet(devNum, taiNumber[0], &clockInterfaceDirection);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiPClkInterfaceGet(devNum, taiNumber[0], &clockInterfaceDirection);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPClkOutputInterfaceSet
(
    IN  GT_U8                                       devNum,
    IN  CPSS_DXCH_PTP_TAI_NUMBER_ENT                taiNumber,
    IN  CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_ENT    pclkRcvrClkMode

)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPClkOutputInterfaceSet)
{
/*
    ITERATE_DEVICES(Bobcat2)
    1.1. Call cpssDxChPtpTaiPClkOutputInterfaceSet with pclkRcvrClkMode[CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_PCLK_E/CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_RCVR_CLK_E]
            taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_0_E/CPSS_DXCH_PTP_TAI_NUMBER_1_E]
    Expected: GT_OK.
    1.2. Call cpssDxChPtpTaiPClkOutputInterfaceGet
           with the same parameters.
    Expected: GT_OK.
    1.3. Call api with wrong taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_ALL_E].
*/
    GT_STATUS st = GT_OK;

    GT_U8                                       dev;
    CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_ENT    pclkRcvrClkMode[2] =
            {CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_PCLK_E, CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_RCVR_CLK_E};
    CPSS_DXCH_PTP_TAI_NUMBER_ENT                taiNumber[3] =
            {CPSS_DXCH_PTP_TAI_NUMBER_0_E, CPSS_DXCH_PTP_TAI_NUMBER_1_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E};
    CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_ENT    pclkRcvrClkModeGet[2] =
            {CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_PCLK_E, CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_RCVR_CLK_E};
    CPSS_DXCH_PTP_TAI_NUMBER_ENT                taiNumberGet[3] =
            {CPSS_DXCH_PTP_TAI_NUMBER_0_E, CPSS_DXCH_PTP_TAI_NUMBER_1_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E};

    GT_U32 i, j;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_AC5X_E | UTF_HARRIER_E | UTF_IRONMAN_L_E );

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            for(j = 0; j < CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_RCVR_CLK_E + 1; j++)
            {
                /*
                    1.1. Call cpssDxChPtpTaiPClkOutputInterfaceSet with taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_0_E/CPSS_DXCH_PTP_TAI_NUMBER_1_E],
                            pclkRcvrClkMode[CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_PCLK_E/CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_RCVR_CLK_E]

                    Expected: GT_OK.
                */
                st = cpssDxChPtpTaiPClkOutputInterfaceSet(dev, taiNumber[i], pclkRcvrClkMode[j]);
                if (PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
                {
                    if(pclkRcvrClkMode[j] == CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_RCVR_CLK_E)
                    {
                        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_SUPPORTED, st, dev);
                    }
                }
                else
                {
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                }

                /*
                    1.2. Call cpssDxChPtpTaiPClkOutputInterfaceGet
                           with the same parameters.
                    Expected: GT_OK.
                */
                st = cpssDxChPtpTaiPClkOutputInterfaceGet(dev, &taiNumberGet[i], &pclkRcvrClkModeGet[j]);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                          "cpssDxChPtpTaiPClkOutputInterfaceGet: %d ", dev);

                if (PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
                {
                    if(pclkRcvrClkMode[j] == CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_RCVR_CLK_E)
                    {
                        /* Verifying values */
                        UTF_VERIFY_EQUAL1_STRING_MAC(CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_PCLK_E, pclkRcvrClkModeGet[j],
                                       "got another pclkRcvrClkMode then was set: %d", dev);
                    }
                }
                else
                {
                    /* Verifying values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(pclkRcvrClkMode[j], pclkRcvrClkModeGet[j],
                                   "got another pclkRcvrClkMode then was set: %d", dev);
                }


                if(pclkRcvrClkMode[j] == CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_PCLK_E)
                {
                    /* Verifying values */
                    if (! SINGLE_TAI_DEV_MAC(dev))
                    {
                        UTF_VERIFY_EQUAL1_STRING_MAC(taiNumber[i], taiNumberGet[i],
                                       "got another taiNumber then was set: %d", dev);
                    }
                }
            }
        }

        /*
            1.4. Call api with wrong pclkRcvrClkMode[CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_RCVR_CLK_E] + 1.
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiPClkOutputInterfaceSet(dev, taiNumberGet[0], CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_RCVR_CLK_E + 1);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        /*
            1.5. Call api with wrong taiNumberGet[CPSS_DXCH_PTP_TAI_NUMBER_ALL_E].
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiPClkOutputInterfaceSet(dev, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E, pclkRcvrClkMode[0]);
        if (! SINGLE_TAI_DEV_MAC(dev))
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }
        else
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }

        /*
            1.6. Call api with wrong pclkRcvrClkMode[wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkOutputInterfaceSet(dev, taiNumberGet[0], pclkRcvrClkMode[0]),
                            pclkRcvrClkMode[0]);
        /*
            1.7. Call api with wrong taiNumberGet[wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        if (! SINGLE_TAI_DEV_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(
                cpssDxChPtpTaiPClkOutputInterfaceSet(dev, taiNumberGet[0], pclkRcvrClkMode[0]),
                    taiNumberGet[0]);
        }
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                   UTF_LION2_E | UTF_IRONMAN_L_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiPClkOutputInterfaceSet(dev, taiNumberGet[0], pclkRcvrClkMode[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiPClkOutputInterfaceSet(dev, taiNumberGet[0], pclkRcvrClkMode[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPClkOutputInterfaceGet
(
    IN  GT_U8                                       devNum,
    OUT CPSS_DXCH_PTP_TAI_NUMBER_ENT                *taiNumberPtr,
    OUT CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_ENT    *pclkRcvrClkModePtr

)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPClkOutputInterfaceGet)
{
/*
    ITERATE_DEVICES(Bobcat2)
    1.1.1 Call with non-null pclkRcvrClkModePtr & taiNumberPtr
    Expected: GT_OK.
    1.1.2 Call api with wrong pclkRcvrClkMode[NULL].
    Expected: GT_BAD_PTR.
    1.1.3 Call api Call with wrong taiNumberPtr[NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                           st = GT_OK;
    GT_U8                               devNum = 0;
    CPSS_DXCH_PTP_TAI_PCLK_RCVR_CLK_MODE_ENT    pclkRcvrClkMode;
    CPSS_DXCH_PTP_TAI_NUMBER_ENT                taiNumber;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                                                                UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1.1 Call with non-null pclkRcvrClkMode & taiNumber
            Expected: GT_OK.
        */
        st = cpssDxChPtpTaiPClkOutputInterfaceGet(devNum, &taiNumber, &pclkRcvrClkMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.1.2 Call api with wrong pclkRcvrClkModePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTaiPClkOutputInterfaceGet(devNum, &taiNumber, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);

        /*
            1.1.3 Call api with wrong taiNumber [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTaiPClkOutputInterfaceGet(devNum, NULL, &pclkRcvrClkMode);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }
        else
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);
        }
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                   UTF_LION2_E | UTF_IRONMAN_L_E);

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiPClkOutputInterfaceGet(devNum, &taiNumber, &pclkRcvrClkMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiPClkOutputInterfaceGet(devNum, &taiNumber, &pclkRcvrClkMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiInputClockSelectSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_DXCH_PTP_TAI_NUMBER_ENT        taiNumber,
    IN  CPSS_DXCH_PTP_TAI_CLOCK_SELECT_ENT  clockSelect,
    IN  CPSS_DXCH_PTP_TAI_CLOCK_FREQ_ENT    clockFrequency
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiInputClockSelectSet)
{
/*
    ITERATE_DEVICES(Bobcat2)
    1.1. Call cpssDxChPtpTaiInputClockSelectSet with taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_0_E / CPSS_DXCH_PTP_TAI_NUMBER_1_E]
            clockSelect[CPSS_DXCH_PTP_TAI_CLOCK_SELECT_PTP_PLL_E /CPSS_DXCH_PTP_TAI_CLOCK_SELECT_CORE_PLL_E],
    Expected: GT_OK.
    1.2. Call cpssDxChPtpTaiInputClockSelectGet
           with the same parameters.
    Expected: GT_OK.
    1.3. Call api with wrong taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_ALL_E].
*/
    GT_STATUS st = GT_OK;

    GT_U8                           dev = 0;
    CPSS_DXCH_PTP_TAI_NUMBER_ENT    taiNumber[3] =
        {CPSS_DXCH_PTP_TAI_NUMBER_0_E, CPSS_DXCH_PTP_TAI_NUMBER_1_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E};
    CPSS_DXCH_PTP_TAI_CLOCK_SELECT_ENT  clockSelect[2] =
        {CPSS_DXCH_PTP_TAI_CLOCK_SELECT_PTP_PLL_E, CPSS_DXCH_PTP_TAI_CLOCK_SELECT_CORE_PLL_E};
    CPSS_DXCH_PTP_TAI_CLOCK_SELECT_ENT  clockSelectGet[2] =
        {CPSS_DXCH_PTP_TAI_CLOCK_SELECT_PTP_PLL_E, CPSS_DXCH_PTP_TAI_CLOCK_SELECT_CORE_PLL_E};

    GT_U32 i, j;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CAELUM_E | UTF_IRONMAN_L_E );

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            for(j = 0; j < CPSS_DXCH_PTP_TAI_CLOCK_SELECT_CORE_PLL_E + 1; j++)
            {
                /*
                    1.1. Call with taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_0_E / CPSS_DXCH_PTP_TAI_NUMBER_1_E],
                                   clockSelect[CPSS_DXCH_PTP_TAI_CLOCK_SELECT_PTP_PLL_E /CPSS_DXCH_PTP_TAI_CLOCK_SELECT_CORE_PLL_E].
                    Expected: GT_OK.
                */
                st = cpssDxChPtpTaiInputClockSelectSet(dev, taiNumber[i], clockSelect[j], CPSS_DXCH_PTP_25_FREQ_E);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                /*
                    1.2. Call cpssDxChPtpTaiInputClockSelectGet with the same parameters.
                    Expected: GT_OK and the same values than was set.
                */
                st = cpssDxChPtpTaiInputClockSelectGet(dev, taiNumber[i], &clockSelectGet[j]);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                          "cpssDxChPtpTaiInputClockSelectGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(clockSelect[j], clockSelectGet[j],
                               "got another taiNumber then was set: %d", dev);
            }
        }

        for(j = 0; j < CPSS_DXCH_PTP_TAI_CLOCK_SELECT_CORE_PLL_E + 1; j++)
        {
            /*
                1.3. Call api with wrong taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_ALL_E].
                Expected: GT_BAD_PARAM.
            */
            st = cpssDxChPtpTaiInputClockSelectSet(dev, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E, clockSelect[j], CPSS_DXCH_PTP_25_FREQ_E);
            if (! SINGLE_TAI_DEV_MAC(dev))
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }
        }
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CAELUM_E | UTF_IRONMAN_L_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiInputClockSelectSet(dev, taiNumber[0], clockSelect[0], CPSS_DXCH_PTP_25_FREQ_E);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiInputClockSelectSet(dev, taiNumber[0], clockSelect[0], CPSS_DXCH_PTP_25_FREQ_E);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiInputClockSelectGet
(
    IN  GT_U8                               devNum,
    IN  CPSS_DXCH_PTP_TAI_NUMBER_ENT        taiNumber,
    OUT CPSS_DXCH_PTP_TAI_CLOCK_SELECT_ENT  *clockSelectPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiInputClockSelectGet)
{
/*
    ITERATE_DEVICES(Bobcat2)
    1.1.1 Call api with non-null clockSelectPtr
    Expected: GT_OK.
    1.1.2 Call api with wrong clockSelectPtr[NULL].
    Expected: GT_BAD_PTR.
    1.1.3 Call api with wrong taiNumber.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                           st = GT_OK;
    GT_U8                               devNum = 0;
    OUT CPSS_DXCH_PTP_TAI_CLOCK_SELECT_ENT  clockSelect;
    CPSS_DXCH_PTP_TAI_NUMBER_ENT        taiNumber[3] =
        {CPSS_DXCH_PTP_TAI_NUMBER_0_E, CPSS_DXCH_PTP_TAI_NUMBER_1_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E};
    GT_U32 i;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CAELUM_E | UTF_IRONMAN_L_E );

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            /*
                1.1.1 Call with non-null clockInterfaceDirectionPtr
                Expected: GT_OK.
            */
            st = cpssDxChPtpTaiInputClockSelectGet(devNum, taiNumber[i], &clockSelect);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.1.2 Call api with wrong clockSelectPtr [NULL].
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPtpTaiInputClockSelectGet(devNum, taiNumber[i], NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
        }
        /*
            1.1.3 Call api with wrong taiNumber.
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiInputClockSelectGet(devNum, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E, &clockSelect);
        if (! SINGLE_TAI_DEV_MAC(devNum))
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
        }
        else
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);
        }
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CAELUM_E | UTF_IRONMAN_L_E);

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiInputClockSelectGet(devNum, taiNumber[0], &clockSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiInputClockSelectGet(devNum, taiNumber[0], &clockSelect);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}
/* check if diff between the TOD values is within the tolerance */
/* return GT_TRUE - OK */
/* return GT_FALSE - ERROR */
static  GT_BOOL todValueCompareWithTolerance(
    IN CPSS_DXCH_PTP_TOD_COUNT_STC *newValuePtr , /* timer newer then the 'old' */
    IN CPSS_DXCH_PTP_TOD_COUNT_STC *oldValue2ptr ,/* timer older then the 'new' */
    IN GT_U32                   numOfMilisecTolerance/* tolerance in millisec*/
)
{
    GT_U32  oldNanoWithTolerance = oldValue2ptr->nanoSeconds + /* assumed under 1000000000*/
                            (numOfMilisecTolerance * 1000000); /* assumed under 3 seconds */
    GT_U32  oldOverlapedSeconds = oldNanoWithTolerance / (1000 * 1000 * 1000);

    if (oldOverlapedSeconds)
    {
        if (newValuePtr->seconds.l[0] < (oldValue2ptr->seconds.l[0] + oldOverlapedSeconds))
        {
            /* OK  */
            return GT_TRUE;
        }
        else if (newValuePtr->seconds.l[0] == (oldValue2ptr->seconds.l[0] + oldOverlapedSeconds))
        {
            GT_U32  diff = 1000 - oldValue2ptr->nanoSeconds/1000000 + newValuePtr->nanoSeconds/1000000;
            if (diff < numOfMilisecTolerance)
            {
                return GT_TRUE;
            }
        }
    }
    else
    {
        if (newValuePtr->seconds.l[0] != oldValue2ptr->seconds.l[0])
        {
            return GT_FALSE;
        }

        if(newValuePtr->nanoSeconds <= oldNanoWithTolerance)
        {
            return GT_TRUE;
        }

    }

    return GT_FALSE;
}
/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiTodCounterFunctionAllTriggerSet
(
    IN GT_U8                    devNum
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiTodCounterFunctionAllTriggerSet)
{
    GT_U8   dev;
    GT_STATUS st = GT_OK;
    CPSS_DXCH_PTP_TAI_ID_STC tai_id;
    GT_BOOL valid;
    GT_U32 index;
    CPSS_DXCH_PTP_TOD_COUNT_STC           todValue;
    CPSS_DXCH_PTP_TOD_COUNT_STC           lastTodValue[2];
    GT_U32  iter,iterMax = 3;
    GT_U32  testedPort = 48;
    GT_BOOL startSecondRound;
    GT_BOOL diffOk;
    GT_U32 isPtpMgr=0;  /* whether system working mode is in PTP Manager mode or Legacy mode*/
    CPSS_DXCH_PTP_MANAGER_TAI_OUTPUT_INTERFACE_STC   outputInterfaceConf;
    CPSS_DXCH_PTP_MANAGER_PTP_OVER_ETHERNET_STC         ptpOverEthernetConf;
    CPSS_DXCH_PTP_MANAGER_PTP_OVER_IP_UDP_STC               ptpOverIpUdpConf;
    CPSS_DXCH_PTP_TS_TAG_GLOBAL_CFG_STC                             ptpTsTagGlobalConf;
    CPSS_NET_RX_CPU_CODE_ENT                         cpuCode = CPSS_NET_FIRST_USER_DEFINED_E;

    cpssOsMemSet(&outputInterfaceConf,0, sizeof(outputInterfaceConf));
    cpssOsMemSet(&ptpOverEthernetConf,0, sizeof(ptpOverEthernetConf));
    cpssOsMemSet(&ptpOverIpUdpConf,0, sizeof(ptpOverIpUdpConf));
    cpssOsMemSet(&ptpTsTagGlobalConf,0, sizeof(ptpTsTagGlobalConf));

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E );

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {

        if((prvWrAppDbEntryGet("ptpMgr", &isPtpMgr) == GT_OK) && (isPtpMgr != 0))
        {
            /* all the init sequence is done using PTP Manager */
            /* set default setting */
            outputInterfaceConf.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;

            st = cpssDxChPtpManagerPtpInit(dev,&outputInterfaceConf,&ptpOverEthernetConf,&ptpOverIpUdpConf,&ptpTsTagGlobalConf,cpuCode);
            UTF_VERIFY_EQUAL0_STRING_MAC(GT_OK, st,"cpssDxChPtpManagerPtpInit");
        }

        startSecondRound = GT_FALSE;

        startSecondRound_lbl:

        for (iter = 0 ; iter < iterMax ; iter++)
        {
            /* Initialize TAI structure */
            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            tai_id.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            tai_id.portNum = testedPort;

            st = cpssDxChPtpTodCounterFunctionSet(dev,
                            CPSS_PORT_DIRECTION_RX_E,
                            &tai_id,
                            CPSS_DXCH_PTP_TOD_COUNTER_FUNC_CAPTURE_E);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* trigger capture 0 */
            st = cpssDxChPtpTaiTodCounterFunctionAllTriggerSet(dev);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* do diff between the triggers */
            cpssOsTimerWkAfter(1);

            /* trigger capture 1 */
            st = cpssDxChPtpTaiTodCounterFunctionAllTriggerSet(dev);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* Check capture status, read valid values of both TAI capture regs (0 & 1) */
            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for (index = 0; index < 2; index++)
            {
                st = cpssDxChPtpTaiTodCaptureStatusGet(dev, &tai_id, index, &valid);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, valid, dev);

                /* on last iteration do not 'get' the TOD ... so the both TODs are 'valid' */
                if((iter + 1) < iterMax)
                {
                    st = cpssDxChPtpTaiTodGet(dev,&tai_id,
                                CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE0_E + index,
                                &todValue);

                    lastTodValue[index] = todValue;/* save the value */

                    cpssOsPrintf("taiInstance[%d] , taiNumber[%d], index[%d] , nanoSeconds = [%d] , seconds = [%d][%d] , fracNanoSeconds = [%d] \n",
                        tai_id.taiInstance,
                        tai_id.taiNumber,
                        index,
                        todValue.nanoSeconds,
                        todValue.seconds.l[1],
                        todValue.seconds.l[0],
                        todValue.fracNanoSeconds
                    );

                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                                                tai_id.taiNumber,index);

                    st = cpssDxChPtpTaiTodCaptureStatusGet(dev, &tai_id, index, &valid);
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                    /* we read the counter ... the valid must be now 'not valid'*/
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_FALSE, valid, dev);
                }
            }

            /* do diff between the triggers */
            cpssOsTimerWkAfter(1);
        }

        if (startSecondRound == GT_FALSE)
        {
            /* check that trigger capture without 'read' of previous captured TOD
               not update the TOD */
            st = cpssDxChPtpTaiCaptureOverrideEnableSet(dev, &tai_id, GT_FALSE);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                                tai_id.taiNumber);

            /* Initialize TAI structure */
            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            tai_id.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            tai_id.portNum = testedPort;

            /* trigger capture 0 */
            st = cpssDxChPtpTaiTodCounterFunctionAllTriggerSet(dev);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for (index = 0; index < 2; index++)
            {
                st = cpssDxChPtpTaiTodCaptureStatusGet(dev, &tai_id, index, &valid);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, valid, dev);

                st = cpssDxChPtpTaiTodGet(dev,&tai_id,
                            CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE0_E + index,
                            &todValue);
                cpssOsPrintf("taiInstance[%d] , taiNumber[%d], index[%d] , nanoSeconds = [%d] , seconds = [%d][%d] , fracNanoSeconds = [%d] \n",
                    tai_id.taiInstance,
                    tai_id.taiNumber,
                    index,
                    todValue.nanoSeconds,
                    todValue.seconds.l[1],
                    todValue.seconds.l[0],
                    todValue.fracNanoSeconds
                );
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                                            tai_id.taiNumber,index);

                /* check that the capture 0,1 values did not changed more than 1000 milli from 'last time' */
                diffOk = todValueCompareWithTolerance(
                    &todValue,
                    &lastTodValue[index],
                    1000);/*1000 mili*/
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, diffOk, dev);
            }

            startSecondRound = GT_TRUE;

            /* do iterations to fill the TOD capture iwth valid values that are not read*/
            goto startSecondRound_lbl;
        }

        /* Skip this section for emulator - performance reason */
        if (!cpssDeviceRunCheck_onEmulator())
        {
            /* this is 'secondRound' */

            /* do 'big' diff between the triggers , from those of previous triggers */
            cpssOsTimerWkAfter(1000);

            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;

            /* allow the capture to override 'capture' 0 */
            st = cpssDxChPtpTaiCaptureOverrideEnableSet(dev, &tai_id, GT_TRUE);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                                tai_id.taiNumber);

            /* do diff between the triggers */
            cpssOsTimerWkAfter(1);

            /* Initialize TAI structure */
            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            tai_id.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_0_E;
            tai_id.portNum = testedPort;

            /* trigger capture 0 */
            st = cpssDxChPtpTaiTodCounterFunctionAllTriggerSet(dev);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* do diff between the triggers */
            cpssOsTimerWkAfter(1);

            /* trigger capture 1 */
            st = cpssDxChPtpTaiTodCounterFunctionAllTriggerSet(dev);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for (index = 0; index < 2; index++)
            {
                st = cpssDxChPtpTaiTodCaptureStatusGet(dev, &tai_id, index, &valid);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, valid, dev);

                st = cpssDxChPtpTaiTodGet(dev,&tai_id,
                            CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE0_E + index,
                            &todValue);
                cpssOsPrintf("taiInstance[%d] , taiNumber[%d], index[%d] , nanoSeconds = [%d] , seconds = [%d][%d] , fracNanoSeconds = [%d] \n",
                    tai_id.taiInstance,
                    tai_id.taiNumber,
                    index,
                    todValue.nanoSeconds,
                    todValue.seconds.l[1],
                    todValue.seconds.l[0],
                    todValue.fracNanoSeconds
                );
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                                            tai_id.taiNumber,index);

                if (index == 1)
                {
                    /* check that the capture 1 values did not changed more than 1000 milli from 'last time' */
                    diffOk = todValueCompareWithTolerance(
                        &todValue,
                        &lastTodValue[index],
                        1000);/*1000 mili*/
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, diffOk, dev);
                }
                else
                {
                    /* check that the capture 0 values changed
                        more than 1000 milli from 'last time'
                        but less than 1100 milli */
                    diffOk = todValueCompareWithTolerance(
                        &todValue,
                        &lastTodValue[index],
                        1000);/*1000 mili*/
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_FALSE, diffOk, dev);

                    diffOk = todValueCompareWithTolerance(
                        &todValue,
                        &lastTodValue[index],
                        1100);/*1100 mili*/
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, diffOk, dev);
                }
            }
        }

        /* restore default */
        tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;

        /* allow the capture to override 'capture' 0 */
        st = cpssDxChPtpTaiCaptureOverrideEnableSet(dev, &tai_id, GT_FALSE);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                            tai_id.taiNumber);
    }


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E );

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiTodCounterFunctionAllTriggerSet(dev);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* Call function with out of bound value for device id.*/
    st = cpssDxChPtpTaiTodCounterFunctionAllTriggerSet(PRV_CPSS_MAX_PP_DEVICES_CNS);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, PRV_CPSS_MAX_PP_DEVICES_CNS);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpPortUnitResetSet
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    IN  GT_BOOL                         resetTxUnit,
    IN  GT_BOOL                         resetRxUnit
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpPortUnitResetSet)
{
/*
    ITERATE_DEVICES(Bobcat2 and above)
*/
    GT_STATUS st = GT_OK;

    GT_U8                   dev;
    UTF_PHYSICAL_PORT_NUM   portNum = 0;
    GT_BOOL                 resetTxUnit = GT_FALSE;
    GT_BOOL                 resetRxUnit = GT_FALSE;
    GT_BOOL                 resetTxUnitGet = GT_FALSE;
    GT_BOOL                 resetRxUnitGet = GT_FALSE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&portNum, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_TRUE))
        {
            resetTxUnit = (portNum % 2) ? GT_TRUE : GT_FALSE;
            resetRxUnit = (portNum % 3) ? GT_TRUE : GT_FALSE;
            if(prvCpssDxChPortRemotePortCheck(dev, portNum))
            {
                st = cpssDxChPtpPortUnitResetSet(dev, portNum,  resetTxUnit, resetRxUnit);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
                continue;
            }

            st = cpssDxChPtpPortUnitResetSet(dev, portNum,  resetTxUnit, resetRxUnit);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* copy for cases of not relevant parameters */
            resetTxUnitGet = resetTxUnit;
            resetRxUnitGet = resetRxUnit;
            st = cpssDxChPtpPortUnitResetGet(dev, portNum,  &resetTxUnitGet, &resetRxUnitGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* check get == set */
            UTF_VERIFY_EQUAL2_PARAM_MAC(resetTxUnit, resetTxUnitGet, dev, portNum);
            if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
            {
                /* SIP_6 always returns Normal state */
                resetRxUnit = GT_FALSE;
            }

            UTF_VERIFY_EQUAL2_PARAM_MAC(resetRxUnit, resetRxUnitGet, dev, portNum);

            /*restore*/
            resetTxUnit = GT_FALSE;
            resetRxUnit = GT_FALSE;
            st = cpssDxChPtpPortUnitResetSet(dev, portNum,  resetTxUnit, resetRxUnit);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }

        st = prvUtfNextMacPortReset(&portNum, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
        while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_FALSE))
        {
            /* 1.2.1. Call function for each non-active port */
            st = cpssDxChPtpPortUnitResetSet(dev, portNum,  resetTxUnit, resetRxUnit);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portNum);
        }
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpPortUnitResetSet(dev, portNum,  resetTxUnit, resetRxUnit);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpPortUnitResetSet(dev, portNum,  resetTxUnit, resetRxUnit);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpPortUnitResetGet
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    OUT GT_BOOL                         *resetTxUnitPtr,
    OUT GT_BOOL                         *resetRxUnitPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpPortUnitResetGet)
{
/*
    ITERATE_DEVICES(Bobcat2 and above)
*/
    GT_STATUS st = GT_OK;

    GT_U8                   dev;
    UTF_PHYSICAL_PORT_NUM   portNum = 0;
    GT_BOOL                 resetTxUnit = GT_FALSE;
    GT_BOOL                 resetRxUnit = GT_FALSE;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&portNum, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_TRUE))
        {
            if(prvCpssDxChPortRemotePortCheck(dev, portNum))
            {
                st = cpssDxChPtpPortUnitResetGet(dev, portNum,  &resetTxUnit, &resetRxUnit);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
                continue;
            }

            st = cpssDxChPtpPortUnitResetGet(dev, portNum,  &resetTxUnit, &resetRxUnit);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            st = cpssDxChPtpPortUnitResetGet(dev, portNum,  NULL, &resetRxUnit);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

            st = cpssDxChPtpPortUnitResetGet(dev, portNum,  &resetTxUnit, NULL);
            if (PRV_CPSS_SIP_5_15_CHECK_MAC(dev))
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }
        }

        st = prvUtfNextMacPortReset(&portNum, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
        /* 1.2.1. Call function for each non-active port */
        while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_FALSE))
        {
            st = cpssDxChPtpPortUnitResetGet(dev, portNum,  &resetTxUnit, &resetRxUnit);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portNum);
        }
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpPortUnitResetGet(dev, portNum,  &resetTxUnit, &resetRxUnit);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpPortUnitResetGet(dev, portNum,  &resetTxUnit, &resetRxUnit);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpPortTxPipeStatusDelaySet
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    IN  GT_U32                          delay
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpPortTxPipeStatusDelaySet)
{
/*
    ITERATE_DEVICES(Caelum and above)
*/
    GT_STATUS st = GT_OK;

    GT_U8                   dev;
    UTF_PHYSICAL_PORT_NUM   portNum = 0;
    GT_U32                  delay = 0;
    GT_U32                  delayGet = 0;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E |  UTF_LION2_E | UTF_BOBCAT2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&portNum, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_TRUE))
        {
            delay = portNum + 0xF00;
            if(prvCpssDxChPortRemotePortCheck(dev, portNum))
            {
                st = cpssDxChPtpPortTxPipeStatusDelaySet(dev, portNum,  delay);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
                continue;
            }

            st = cpssDxChPtpPortTxPipeStatusDelaySet(dev, portNum,  delay);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            st = cpssDxChPtpPortTxPipeStatusDelayGet(dev, portNum,  &delayGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* got == set check */
            UTF_VERIFY_EQUAL2_PARAM_MAC(delay, delayGet, dev, portNum);
            delay = PRV_CPSS_SIP_6_10_CHECK_MAC(dev)? 0xFFFFFFFF : 0xFFFFFF;
            st = cpssDxChPtpPortTxPipeStatusDelaySet(dev, portNum,  delay);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, dev);
        }

        delay = 0;
        st = prvUtfNextMacPortReset(&portNum, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
        while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_FALSE))
        {
            /* 1.2.1. Call function for each non-active port */
            st = cpssDxChPtpPortTxPipeStatusDelaySet(dev, portNum,  delay);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portNum);
        }
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E |  UTF_LION2_E | UTF_BOBCAT2_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpPortTxPipeStatusDelaySet(dev, portNum,  delay);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpPortTxPipeStatusDelaySet(dev, portNum,  delay);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpPortTxPipeStatusDelayGet
(
    IN  GT_U8                           devNum,
    IN  GT_PHYSICAL_PORT_NUM            portNum,
    OUT GT_U32                          *delayPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpPortTxPipeStatusDelayGet)
{
/*
    ITERATE_DEVICES(Caelum and above)
*/
    GT_STATUS st = GT_OK;

    GT_U8                   dev;
    UTF_PHYSICAL_PORT_NUM   portNum = 0;
    GT_U32                  delay = 0;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E |  UTF_LION2_E | UTF_BOBCAT2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&portNum, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_TRUE))
        {
            if(prvCpssDxChPortRemotePortCheck(dev, portNum))
            {
                st = cpssDxChPtpPortTxPipeStatusDelayGet(dev, portNum,  &delay);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
                continue;
            }

            st = cpssDxChPtpPortTxPipeStatusDelayGet(dev, portNum,  &delay);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            st = cpssDxChPtpPortTxPipeStatusDelayGet(dev, portNum,  NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
        }

        delay = 0;
        st = prvUtfNextMacPortReset(&portNum, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
        while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_FALSE))
        {
            /* 1.2.1. Call function for each non-active port */
            st = cpssDxChPtpPortTxPipeStatusDelayGet(dev, portNum,  &delay);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portNum);
        }
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E |  UTF_LION2_E | UTF_BOBCAT2_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpPortTxPipeStatusDelayGet(dev, portNum,  &delay);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpPortTxPipeStatusDelayGet(dev, portNum,  &delay);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPulseInModeSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_NUMBER_ENT            taiNumber,
    IN  CPSS_DXCH_PTP_TAI_PULSE_IN_MODE_ENT     pulseMode
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPulseInModeSet)
{
/*
    1.1. Call cpssDxChPtpTaiPulseInModeSet with
                        pulseMode[CPSS_DXCH_PTP_TAI_PULSE_IN_DISABLED_E /
                        CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_PULSE_IN_E /
                        CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_CLOCK_IN_E]
                        taiNumber[CPSS_DXCH_PTP_TAI_NUMBER_0_E / CPSS_DXCH_PTP_TAI_NUMBER_1_E]
    Expected: GT_OK & PulseInMode according to the set command.
    1.2. Call cpssDxChPtpTaiPulseInModeSet with invalid pulseMode.
    Expected: GT_BAD_PARAM.
    1.3. Call cpssDxChPtpTaiPulseInModeSet with invalid taiNumber.
    Expected: GT_BAD_PARAM.
    1.4. Call cpssDxChPtpTaiPulseInModeSet with invalid device number.
    Expected: GT_BAD_PARAM.
*/

    GT_STATUS st = GT_OK;
    GT_U8     dev = 0;
    CPSS_DXCH_PTP_TAI_NUMBER_ENT    taiNumber[3] =
        {CPSS_DXCH_PTP_TAI_NUMBER_0_E, CPSS_DXCH_PTP_TAI_NUMBER_1_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E};
    CPSS_DXCH_PTP_TAI_PULSE_IN_MODE_ENT pulseMode[3] =
        {CPSS_DXCH_PTP_TAI_PULSE_IN_DISABLED_E, CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_CLOCK_IN_E, CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_PULSE_IN_E};
    CPSS_DXCH_PTP_TAI_PULSE_IN_MODE_ENT pulseModeGet[3] =
        {CPSS_DXCH_PTP_TAI_PULSE_IN_DISABLED_E, CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_CLOCK_IN_E, CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_PULSE_IN_E};

    GT_U32 i, j;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                   UTF_LION2_E | UTF_BOBCAT2_E |
                                   UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {

            for(j = 0; j < 3; j++)
            {
                st = cpssDxChPtpTaiPulseInModeSet(dev, taiNumber[i], pulseMode[j]);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                st = cpssDxChPtpTaiPulseInModeGet(dev, taiNumber[i], &pulseModeGet[j]);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                          "cpssDxChPtpTaiPulseInModeGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(pulseModeGet[j], pulseMode[j],
                               "got another pulseMode then was set: %d", dev);
            }
        }

        /*
           1.2. Call api with wrong pulseMode[wrong enum values].
                Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPulseInModeSet(dev, taiNumber[0], pulseMode[0]), pulseMode[0]);

        /*
           1.3. Call api with wrong taiNumber[wrong enum values].
                Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPulseInModeSet(dev, taiNumber[0], pulseMode[0]), taiNumber[0]);
    }

    /*
       1.4. Call function with out of bound value for device id
            Expected: GT_BAD_PARAM.
    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiPulseInModeSet(dev, taiNumber[0], pulseMode[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPulseInModeGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_NUMBER_ENT            taiNumber,
    OUT CPSS_DXCH_PTP_TAI_PULSE_IN_MODE_ENT     *pulseModePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPulseInModeGet)
{
/*
    1.1. Call cpssDxChPtpTaiPulseInModeGet without any set operations
    Expected: GT_OK & PulseInMode as CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_PULSE_IN_E
    1.2. Call cpssDxChPtpTaiPulseInModeGet with invalid pulseMode.
    Expected: GT_BAD_PARAM.
    1.3. Call cpssDxChPtpTaiPulseInModeGet with invalid taiNumber.
    Expected: GT_BAD_PARAM.
    1.4. Call cpssDxChPtpTaiPulseInModeGet with invalid device number.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS st = GT_OK;
    GT_U8     dev = 0;
    CPSS_DXCH_PTP_TAI_NUMBER_ENT    taiNumber[3] =
        {CPSS_DXCH_PTP_TAI_NUMBER_0_E, CPSS_DXCH_PTP_TAI_NUMBER_1_E, CPSS_DXCH_PTP_TAI_NUMBER_ALL_E};
    CPSS_DXCH_PTP_TAI_PULSE_IN_MODE_ENT pulseMode[3] =
        {CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_PULSE_IN_E, CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_CLOCK_IN_E, CPSS_DXCH_PTP_TAI_PULSE_IN_DISABLED_E};
    CPSS_DXCH_PTP_TAI_PULSE_IN_MODE_ENT pulseModeGet[3] =
        {CPSS_DXCH_PTP_TAI_PULSE_IN_DISABLED_E, CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_CLOCK_IN_E, CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_PULSE_IN_E};

    GT_U32 i;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                   UTF_LION2_E | UTF_BOBCAT2_E |
                                   UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            /*
             * 1.1. Call cpssDxChPtpTaiPulseInModeGet without any set operations
             *           Expected: GT_OK & PulseInMode as CPSS_DXCH_PTP_TAI_PULSE_IN_IS_PTP_PULSE_IN_E
             */

            st = cpssDxChPtpTaiPulseInModeGet(dev, taiNumber[i], &pulseModeGet[0]);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                    "cpssDxChPtpTaiPulseInModeGet: %d ", dev);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(pulseMode[0], pulseModeGet[0],
                    "got another pulseMode then default: %d", dev);
        }

        /*
           1.2. Call api with NULL PulseMode pointer.
                Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiPulseInModeGet(dev, taiNumber[0], NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

        /*
           1.3. Call api with wrong taiNumber[wrong enum values].
                Expected: GT_BAD_PARAM.
        */
        if (!SINGLE_TAI_DEV_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPulseInModeGet(dev, taiNumber[0], &pulseModeGet[0]), taiNumber[0]);
        }
    }

    /*
       1.4. Call function with out of bound value for device id
            Expected: GT_BAD_PARAM.
    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiPulseInModeGet(dev, taiNumber[0], &pulseModeGet[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiCapturePreviousModeEnableSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    IN  GT_BOOL                                 enable
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiCapturePreviousModeEnableSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            enable [GT_TRUE / GT_FALSE]
    Expected: GT_OK & enable as set.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
            enable [GT_TRUE / GT_FALSE]
    Expected: GT_OK & enable as set.
    1.3 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    2. For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    3. Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                    st      =  GT_OK;
    GT_U8                        i, j;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId = {0,0,0};
    GT_BOOL                      enableGet;
    UTF_PHYSICAL_PORT_NUM        port;
    GT_U8                        dev = 0;
    GT_BOOL                      captureMode[2] = {GT_TRUE, GT_FALSE};

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E   /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            enable [GT_TRUE / GT_FALSE]
            Expected: GT_OK.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            taiId.taiNumber   = taiNumber[i];

            for(j = 0; j < 2; j++)
            {
                st = cpssDxChPtpTaiCapturePreviousModeEnableSet(dev, &taiId, captureMode[j]);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                        taiId.taiNumber, captureMode[j]);

                st = cpssDxChPtpTaiCapturePreviousModeEnableGet(dev, &taiId, &enableGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiCapturePreviousModeEnableGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(enableGet, captureMode[j],
                        "got another Capture previous Mode then was set: %d", dev);
            }
        }

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
        Expected: GT_OK.
        */
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {
                taiId.taiNumber   = taiNumber[i];
                for(j= 0; j < 2; j++)
                {
                    st = cpssDxChPtpTaiCapturePreviousModeEnableSet(dev, &taiId, captureMode[j]);
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                            taiId.taiNumber, captureMode[j]);

                    st = cpssDxChPtpTaiCapturePreviousModeEnableGet(dev, &taiId, &enableGet);
                    UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                            "cpssDxChPtpTaiCapturePreviousModeEnableGet: %d ", dev);

                    /* Verifying values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(enableGet, captureMode[j],
                            "got another Capture previous Mode then was set: %d", dev);
                }
            }
        }

        /*
           1.3  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiCapturePreviousModeEnableSet
                                (dev, &taiId, captureMode[0]), taiId.taiNumber);
    }

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiCapturePreviousModeEnableSet(dev, &taiId, captureMode[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiCapturePreviousModeEnableSet(dev, &taiId, captureMode[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiCapturePreviousModeEnableGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                *taiIdPtr,
    OUT GT_BOOL                                 *enablePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiCapturePreviousModeEnableGet)
{
/*
    1.1. Call cpssDxChPtpTaiCapturePreviousModeEnableGet without any set operations
    Expected: GT_OK & enable as GT_FALSE
    1.2 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.3 For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    2. For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    3. Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                    st = GT_OK;
    GT_U8                        dev = 0;
    GT_U32                       i;
    CPSS_DXCH_PTP_TAI_ID_STC     taiId = {0,0,0};
    GT_BOOL                      enableGet;
    UTF_PHYSICAL_PORT_NUM        port;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {

            /*
             * 1.1. Call cpssDxChPtpTaiCapturePreviousModeEnableGet without any set operations
             *           Expected: GT_OK & enable as GT_FALSE
             */

            st = cpssDxChPtpTaiCapturePreviousModeEnableGet(dev, &taiId, &enableGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                    "cpssDxChPtpTaiCapturePreviousModeEnableGet: %d", dev);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(enableGet, GT_FALSE,
                               "got another capture previous mode then default : %d", dev);
        }

        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {

                taiId.taiNumber = taiNumber[i];
                st = cpssDxChPtpTaiCapturePreviousModeEnableGet(dev, &taiId, &enableGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiCapturePreviousModeEnableGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_FALSE, enableGet,
                        "got another capture previous mode then default: %d", dev);
            }
        }

        /*
           1.2. Call api with NULL capture previous mode pointer.
                Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiCapturePreviousModeEnableGet(dev, &taiId, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

        /*
           1.3  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiCapturePreviousModeEnableGet
                                (dev, &taiId, &enableGet), taiId.taiNumber);
    }

    /* 2 For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiCapturePreviousModeEnableGet(dev, &taiId, &enableGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*
       3. Call function with out of bound value for device id
            Expected: GT_BAD_PARAM.
    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiCapturePreviousModeEnableGet(dev, &taiId, &enableGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPClkSelectionModeSet
(
    IN GT_U8                                   devNum,
    IN CPSS_DXCH_PTP_TAI_ID_STC               *taiIdPtr,
    IN CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_ENT    pClkSelMode
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPClkSelectionModeSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            pClkSelMode [CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_PCLK_E        /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_GEN_E   /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_RECEPTION_E]
    Expected: GT_OK & pClkSelMode as set.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
            pClkSelMode [CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_PCLK_E        /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_GEN_E   /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_RECEPTION_E]
    Expected: GT_OK & pClkSelMode as set.
    1.3 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.3 Call with pClkSelMode out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    2. For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    3. Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st;
    GT_U8                                   i, j;
    CPSS_DXCH_PTP_TAI_ID_STC                taiId = {0,0,0};
    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_ENT     pClkSelModeGet;
    UTF_PHYSICAL_PORT_NUM                   port;
    GT_U8                                   dev = 0;
    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_ENT     pClkSelMode[4] = {
                                                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_PCLK_E,
                                                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_GEN_E,
                                                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_RECEPTION_E,
                                                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_DISABLED_E};
    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E   /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            pClkSelMode [CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_PCLK_E        /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_GEN_E   /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_RECEPTION_E]
            Expected: GT_OK & pClkSelMode as set.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {

            taiId.taiNumber   = taiNumber[i];
            for(j = 0; j < 4; j++)
            {
                if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev) && (pClkSelMode[j] == CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_RECEPTION_E))
                        continue;
                st = cpssDxChPtpTaiPClkSelectionModeSet(dev, &taiId, pClkSelMode[j]);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                        taiId.taiNumber, pClkSelMode[j]);

                st = cpssDxChPtpTaiPClkSelectionModeGet(dev, &taiId, &pClkSelModeGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiPClkSelectionModeGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(pClkSelModeGet, pClkSelMode[j],
                        "got another PCLK Selection Mode then was set: %d", dev);
            }
        }

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
            pClkSelMode [CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_PCLK_E        /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_GEN_E   /
                    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_RECEPTION_E]
            Expected: GT_OK & pClkSelMode as set.
        */
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {
                taiId.taiNumber   = taiNumber[i];
                for(j= 0; j < 4; j++)
                {
                    if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev) && (pClkSelMode[j] == CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_CLOCK_RECEPTION_E))
                        continue;
                    st = cpssDxChPtpTaiPClkSelectionModeSet(dev, &taiId, pClkSelMode[j]);
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                            taiId.taiNumber, pClkSelMode[j]);

                    st = cpssDxChPtpTaiPClkSelectionModeGet(dev, &taiId, &pClkSelModeGet);
                    UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                            "cpssDxChPtpTaiPClkSelectionModeGet: %d ", dev);

                    /* Verifying values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(pClkSelModeGet, pClkSelMode[j],
                            "got another PCLK Selection Mode then was set: %d", dev);
                }
            }
        }

        /*
           1.3  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkSelectionModeSet
                                (dev, &taiId, pClkSelMode[0]), taiId.taiNumber);
        /*
           1.4  Call with pClkSelMode out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkSelectionModeSet
                                (dev, &taiId, pClkSelMode[0]), pClkSelMode[0]);

    }

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiPClkSelectionModeSet(dev, &taiId, pClkSelMode[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiPClkSelectionModeSet(dev, &taiId, pClkSelMode[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiPClkSelectionModeGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC               *taiIdPtr,
    OUT CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_ENT    *pClkSelModePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiPClkSelectionModeGet)
{
/*
    1.1. Call cpssDxChPtpTaiPClkSelectionModeGet without any set operations
    Expected: GT_OK & pClkSelMode as CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_DISABLED_E
    1.2 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.3 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    1.5 Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st = GT_OK;
    GT_U8                                   dev = 0;
    GT_U32                                  i;
    CPSS_DXCH_PTP_TAI_ID_STC                taiId = {0,0,0};
    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_ENT     pClkSelModeGet;
    CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_ENT     pClkSelMode = CPSS_DXCH_PTP_TAI_PCLK_SEL_MODE_DISABLED_E; /* Default */
    UTF_PHYSICAL_PORT_NUM                   port;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {

            /*
             * 1.1. Call cpssDxChPtpTaiPClkSelectionModeGet without any set operations
             *           Expected: GT_OK & pClkSelMode as Disable
             */

            st = cpssDxChPtpTaiPClkSelectionModeGet(dev, &taiId, &pClkSelModeGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                    "cpssDxChPtpTaiPClkSelectionModeGet: %d", dev);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(pClkSelModeGet, pClkSelMode,
                               "got another pclk selection mode then default: %d", dev);
        }

        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {

                taiId.taiNumber = taiNumber[i];
                st = cpssDxChPtpTaiPClkSelectionModeGet(dev, &taiId, &pClkSelModeGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiPClkSelectionModeGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(pClkSelModeGet, pClkSelMode,
                               "got another pclk selection mode then default: %d", dev);
            }
        }

        /*
           1.2. Call api with NULL pClk Selection mode pointer.
                Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiPClkSelectionModeGet(dev, &taiId, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiPClkSelectionModeGet
                                (dev, &taiId, &pClkSelModeGet), taiId.taiNumber);
    }

    /* 2 For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiPClkSelectionModeGet(dev, &taiId, &pClkSelModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*
       3. Call function with out of bound value for device id
            Expected: GT_BAD_PARAM.
    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiPClkSelectionModeGet(dev, &taiId, &pClkSelModeGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockGenerationModeSet
(
    IN GT_U8                                   devNum,
    IN CPSS_DXCH_PTP_TAI_ID_STC               *taiIdPtr,
    IN CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_ENT    clockGenerationMode
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockGenerationModeSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            clockGenerationMode [CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_GEN_E         /
                    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_RECEPTION_E]
    Expected: GT_OK & clockGenerationMode as set.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
            clockGenerationMode [CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_GEN_E         /
                    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_RECEPTION_E]
    Expected: GT_OK & clockGenerationMode as set.
    1.3 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.3 Call with clockGenerationMode out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    2. For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    3. Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st;
    GT_U8                                   i, j;
    CPSS_DXCH_PTP_TAI_ID_STC                taiId = {0,0,0};
    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_ENT    clockGenerationModeGet;
    UTF_PHYSICAL_PORT_NUM                   port;
    GT_U8                                   dev = 0;
    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_ENT    clockGenerationMode[3] = {
                                                    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_GEN_E,
                                                    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_RECEPTION_E,
                                                    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_DISABLED_E};
    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E   /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            clockGenerationMode [CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_GEN_E         /
                    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_RECEPTION_E]
            Expected: GT_OK & clockGenerationMode as set.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {

            taiId.taiNumber   = taiNumber[i];

            for(j = 0; j < 3; j++)
            {
                st = cpssDxChPtpTaiClockGenerationModeSet(dev, &taiId, clockGenerationMode[j]);
                if ((clockGenerationMode[j] == CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_RECEPTION_E) &&
                    PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
                {
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_BAD_PARAM, st, dev, taiId.taiInstance,
                            taiId.taiNumber, clockGenerationMode[j]);
                }
                else
                {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                        taiId.taiNumber, clockGenerationMode[j]);
                }
                 if ((clockGenerationMode[j] == CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_RECEPTION_E) &&
                    PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
                 {
                     continue;
                 }
                st = cpssDxChPtpTaiClockGenerationModeGet(dev, &taiId, &clockGenerationModeGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiClockGenerationModeGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(clockGenerationModeGet, clockGenerationMode[j],
                        "got another Clock Generation Mode then was set: %d", dev);
            }
        }

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
            clockGenerationMode [CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_GEN_E         /
                    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_RECEPTION_E]
            Expected: GT_OK & clockGenerationMode as set.
        */
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {
                taiId.taiNumber   = taiNumber[i];
                for(j= 0; j < 3; j++)
                {
                    st = cpssDxChPtpTaiClockGenerationModeSet(dev, &taiId, clockGenerationMode[j]);
                    if ((clockGenerationMode[j] == CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_RECEPTION_E) &&
                    PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
                    {
                        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_BAD_PARAM, st, dev, taiId.taiInstance,
                                                    taiId.taiNumber, clockGenerationMode[j]);
                    }
                    else
                    {
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                            taiId.taiNumber, clockGenerationMode[j]);
                    }
                    if ((clockGenerationMode[j] == CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_CLOCK_RECEPTION_E) &&
                    PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
                     {
                         continue;
                     }
                    st = cpssDxChPtpTaiClockGenerationModeGet(dev, &taiId, &clockGenerationModeGet);
                    UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                            "cpssDxChPtpTaiClockGenerationModeGet: %d ", dev);

                    /* Verifying values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(clockGenerationModeGet, clockGenerationMode[j],
                            "got another clock generation Mode then was set: %d", dev);
                }
            }
        }

        /*
           1.3  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockGenerationModeSet
                                (dev, &taiId, clockGenerationMode[0]), taiId.taiNumber);
        /*
           1.4  Call with clockGenerationMode out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockGenerationModeSet
                                (dev, &taiId, clockGenerationMode[0]), clockGenerationMode[0]);
    }

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiClockGenerationModeSet(dev, &taiId, clockGenerationMode[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiClockGenerationModeSet(dev, &taiId, clockGenerationMode[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockGenerationModeGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC               *taiIdPtr,
    OUT CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_ENT   *clockGenerationModePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockGenerationModeGet)
{
/*
    1.1. Call cpssDxChPtpTaiClockGenerationModeGet without any set operations
    Expected: GT_OK & clockGenerationMode as CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_DISABLED_E
    1.2 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.3 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    1.5 Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st = GT_OK;
    GT_U8                                   dev = 0;
    GT_U32                                  i;
    CPSS_DXCH_PTP_TAI_ID_STC                taiId = {0,0,0};
    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_ENT    clockGenerationModeGet;
    CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_ENT    clockGenerationMode = CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_DISABLED_E;
    UTF_PHYSICAL_PORT_NUM                   port;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {

            /*
             * 1.1. Call cpssDxChPtpTaiClockGenerationModeGet without any set operations
             *           Expected: GT_OK & clockGenerationMode as Disable
             */

            st = cpssDxChPtpTaiClockGenerationModeGet(dev, &taiId, &clockGenerationModeGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                    "cpssDxChPtpTaiClockGenerationModeGet: %d", dev);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(clockGenerationModeGet, clockGenerationMode,
                               "got another clock generation mode then default: %d", dev);
        }

        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {
                taiId.taiNumber = taiNumber[i];
                st = cpssDxChPtpTaiClockGenerationModeGet(dev, &taiId, &clockGenerationModeGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiClockGenerationModeGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(clockGenerationModeGet, clockGenerationMode,
                               "got another clk generation mode then default: %d", dev);
            }
        }

        /*
           1.2. Call api with NULL Clk generation mode pointer.
                Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiClockGenerationModeGet(dev, &taiId, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockGenerationModeGet
                                (dev, &taiId, &clockGenerationModeGet), taiId.taiNumber);
    }

    /* 2 For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiClockGenerationModeGet(dev, &taiId, &clockGenerationModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*
       3. Call function with out of bound value for device id
            Expected: GT_BAD_PARAM.
    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiClockGenerationModeGet(dev, &taiId, &clockGenerationModeGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockReceptionModeSet
(
    IN GT_U8                                        devNum,
    IN CPSS_DXCH_PTP_TAI_ID_STC                     *taiIdPtr,
    IN CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_ENT   clockReceptionMode
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockReceptionModeSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            clockReceptionMode [CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_CLOCK_RECEPTION_E]
    Expected: GT_OK & clockReceptionMode as set.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
            clockReceptionMode [CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_CLOCK_RECEPTION_E]
            Expected: GT_OK & clockReceptionMode as set.
    1.3 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.3 Call with clockReceptionMode out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    2. For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    3. Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                                       st;
    GT_U8                                           i, j;
    CPSS_DXCH_PTP_TAI_ID_STC                        taiId = {0,0,0};
    UTF_PHYSICAL_PORT_NUM                           port;
    GT_U8                                           dev = 0;
    CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_ENT      clockReceptionModeGet;
    CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_ENT      clockReceptionMode[3] = {
                                                            CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_CLOCK_RECEPTION_E,
                                                            CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_DISABLED_E};
    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E   /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            clockReceptionMode [CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_CLOCK_RECEPTION_E]
            Expected: GT_OK & clockReceptionMode as set.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            taiId.taiNumber   = taiNumber[i];

            for(j = 0; j < 3; j++)
            {
                st = cpssDxChPtpTaiClockReceptionModeSet(dev, &taiId, clockReceptionMode[j]);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                        taiId.taiNumber, clockReceptionMode[j]);

                st = cpssDxChPtpTaiClockReceptionModeGet(dev, &taiId, &clockReceptionModeGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiClockReceptionModeGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(clockReceptionModeGet, clockReceptionMode[j],
                        "got another Clock Reception Mode then was set: %d", dev);
            }
        }

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
            clockReceptionMode [CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_DISABLED_E    /
                    CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_CLOCK_RECEPTION_E]
            Expected: GT_OK & clockReceptionMode as set.
        */
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {
                taiId.taiNumber   = taiNumber[i];
                for(j= 0; j < 3; j++)
                {
                    st = cpssDxChPtpTaiClockReceptionModeSet(dev, &taiId, clockReceptionMode[j]);
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                            taiId.taiNumber, clockReceptionMode[j]);

                    st = cpssDxChPtpTaiClockReceptionModeGet(dev, &taiId, &clockReceptionModeGet);
                    UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                            "cpssDxChPtpTaiClockReceptionModeGet: %d ", dev);

                    /* Verifying values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(clockReceptionModeGet, clockReceptionMode[j],
                            "got another clock generation Mode then was set: %d", dev);
                }
            }
        }

        /*
           1.3  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockReceptionModeSet
                                (dev, &taiId, clockReceptionMode[0]), taiId.taiNumber);
        /*
           1.4  Call with clockReceptionMode out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockReceptionModeSet
                                (dev, &taiId, clockReceptionMode[0]), clockReceptionMode[0]);

    }

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiClockReceptionModeSet(dev, &taiId, clockReceptionMode[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiClockReceptionModeSet(dev, &taiId, clockReceptionMode[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockReceptionModeGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC               *taiIdPtr,
    OUT CPSS_DXCH_PTP_TAI_CLOCK_GEN_MODE_ENT   *clockReceptionModePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockReceptionModeGet)
{
/*
    1.1. Call cpssDxChPtpTaiClockReceptionModeGet without any set operations
    Expected: GT_OK & clockReceptionMode as CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_DISABLED_E
    1.2 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.3 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    1.5 Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                                       st = GT_OK;
    GT_U8                                           dev = 0;
    GT_U32                                          i;
    CPSS_DXCH_PTP_TAI_ID_STC                        taiId = {0,0,0};
    UTF_PHYSICAL_PORT_NUM                           port;
    CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_ENT      clockReceptionModeGet;
    CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_ENT      clockReceptionMode =
                                                        CPSS_DXCH_PTP_TAI_CLOCK_RECEPTION_MODE_DISABLED_E;/* Default */

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            /*
             * 1.1. Call cpssDxChPtpTaiClockReceptionModeGet without any set operations
             *           Expected: GT_OK & clockReceptionModeGet as Disable
             */

            st = cpssDxChPtpTaiClockReceptionModeGet(dev, &taiId, &clockReceptionModeGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                    "cpssDxChPtpTaiClockReceptionModeGet: %d", dev);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(clockReceptionModeGet, clockReceptionMode,
                               "got another clock reception mode then default: %d", dev);
        }

        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {

                taiId.taiNumber = taiNumber[i];
                st = cpssDxChPtpTaiClockReceptionModeGet(dev, &taiId, &clockReceptionModeGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiClockReceptionModeGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(clockReceptionModeGet, clockReceptionMode,
                               "got another clk reception mode then default: %d", dev);
            }
        }

        /*
           1.2. Call api with NULL Clk reception mode pointer.
                Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiClockReceptionModeGet(dev, &taiId, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockReceptionModeGet
                                (dev, &taiId, &clockReceptionModeGet), taiId.taiNumber);
    }

    /* 2 For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiClockReceptionModeGet(dev, &taiId, &clockReceptionModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*
       3. Call function with out of bound value for device id
            Expected: GT_BAD_PARAM.
    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiClockReceptionModeGet(dev, &taiId, &clockReceptionModeGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockGenerationEdgeSet
(
    IN GT_U8                                   devNum,
    IN CPSS_DXCH_PTP_TAI_ID_STC               *taiIdPtr,
    IN GT_U32                                  edge
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockGenerationEdgeSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            edge   [0/0x20000/0xFFFFFFFF]
    Expected: GT_OK & edge as set.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
            edge   [0/0x20000/0xFFFFFFFF]
    Expected: GT_OK & edge as set.
    1.3 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    2. For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    3. Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st;
    GT_U8                                   i, j;
    GT_U32                                  edgeGet;
    CPSS_DXCH_PTP_TAI_ID_STC                taiId = {0,0,0};
    UTF_PHYSICAL_PORT_NUM                   port;
    GT_U8                                   dev = 0;
    GT_U32                                  edge[3] = {0x20000, 0xFFFFFFF, 0};

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E   /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            edge   [0/0x20000/0xFFFFFFFF]
            Expected: GT_OK & edge as set.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            taiId.taiNumber   = taiNumber[i];
            for(j = 0; j < 3; j++)
            {
                st = cpssDxChPtpTaiClockGenerationEdgeSet(dev, &taiId, edge[j]);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                        taiId.taiNumber, edge[j]);

                st = cpssDxChPtpTaiClockGenerationEdgeGet(dev, &taiId, &edgeGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiClockGenerationEdgeGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(edgeGet, edge[j],
                        "got another Clock Generation Edge then was set: %d", dev);
            }
        }

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
            edge   [0/0x20000/0xFFFFFFFF]
            Expected: GT_OK & edge as set.
        */
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {

                taiId.taiNumber   = taiNumber[i];
                for(j= 0; j < 3; j++)
                {
                    st = cpssDxChPtpTaiClockGenerationEdgeSet(dev, &taiId, edge[j]);
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                            taiId.taiNumber, edge[j]);

                    st = cpssDxChPtpTaiClockGenerationEdgeGet(dev, &taiId, &edgeGet);
                    UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                            "cpssDxChPtpTaiClockGenerationEdgeGet: %d ", dev);

                    /* Verifying values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(edgeGet, edge[j],
                            "got another clock generation Edge then was set: %d", dev);
                }
            }
        }

        /*
           1.3  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockGenerationEdgeSet
                                (dev, &taiId, edge[0]), taiId.taiNumber);
    }

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiClockGenerationEdgeSet(dev, &taiId, edge[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiClockGenerationEdgeSet(dev, &taiId, edge[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockGenerationEdgeGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC               *taiIdPtr,
    OUT GT_U32                                 *edgePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockGenerationEdgeGet)
{
/*
    1.1. Call cpssDxChPtpTaiClockGenerationEdgeGet without any set operations
    Expected: GT_OK & edge as 0
    1.2 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.3 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    1.5 Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st = GT_OK;
    GT_U8                                   dev = 0;
    GT_U32                                  i, edgeGet, edgeDef = 0;
    CPSS_DXCH_PTP_TAI_ID_STC                taiId = {0,0,0};
    UTF_PHYSICAL_PORT_NUM                   port;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {

            /*
             * 1.1. Call cpssDxChPtpTaiClockGenerationEdgeGet without any set operations
             *           Expected: GT_OK & clockGenerationEdge as 0
             */

            st = cpssDxChPtpTaiClockGenerationEdgeGet(dev, &taiId, &edgeGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                    "cpssDxChPtpTaiClockGenerationEdgeGet: %d", dev);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(edgeGet, edgeDef,
                               "got another clock generation edge then default: %d", dev);
        }

        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {
                taiId.taiNumber = taiNumber[i];
                st = cpssDxChPtpTaiClockGenerationEdgeGet(dev, &taiId, &edgeGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiClockGenerationEdgeGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(edgeGet, edgeDef,
                               "got another clk generation edge then default: %d", dev);
            }
        }

        /*
           1.2. Call api with NULL Clk generation edge pointer.
                Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiClockGenerationEdgeGet(dev, &taiId, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockGenerationEdgeGet
                                (dev, &taiId, &edgeGet), taiId.taiNumber);
    }

    /* 2 For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiClockGenerationEdgeGet(dev, &taiId, &edgeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*
       3. Call function with out of bound value for device id
            Expected: GT_BAD_PARAM.
    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiClockGenerationEdgeGet(dev, &taiId, &edgeGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockReceptionEdgeSet
(
    IN GT_U8                                   devNum,
    IN CPSS_DXCH_PTP_TAI_ID_STC               *taiIdPtr,
    IN GT_U32                                  edge
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockReceptionEdgeSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            edge   [0/0x20000/0xFFFFFFFF]
            Expected: GT_OK & edge as set.
    1.1.2 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E    /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      [all available ports]
                   }
            edge   [0/0x20000/0xFFFFFFFF]
            Expected: GT_OK & edge as set.
    1.3 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.3 Call with clockReceptionEdge out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    2. For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    3. Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                                       st;
    GT_U8                                           i, j;
    CPSS_DXCH_PTP_TAI_ID_STC                        taiId = {0,0,0};
    UTF_PHYSICAL_PORT_NUM                           port;
    GT_U8                                           dev = 0;
    GT_U32                                          edgeGet;
    GT_U32                                          edge[3] = {0x20000, 0xFFFFFFF, 0};

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1.1 Call with
            taiId {
                    taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E]
                    taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E   /
                                  CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                    portNum      0
                   }
            edge   [0/0x20000/0xFFFFFFFF]
            Expected: GT_OK & edge as set.
        */
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {
            taiId.taiNumber   = taiNumber[i];

            for(j = 0; j < 3; j++)
            {
                st = cpssDxChPtpTaiClockReceptionEdgeSet(dev, &taiId, edge[j]);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                        taiId.taiNumber, edge[j]);

                st = cpssDxChPtpTaiClockReceptionEdgeGet(dev, &taiId, &edgeGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiClockReceptionEdgeGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(edgeGet, edge[j],
                        "got another Clock Reception Edge then was set: %d", dev);
            }
        }

        /*
        1.1.2 Call with
                taiId {
                        taiInstance  [CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E]
                        taiNumber    [CPSS_DXCH_PTP_TAI_NUMBER_0_E /
                                      CPSS_DXCH_PTP_TAI_NUMBER_1_E]
                        portNum      [all available ports]
                       }
            edge   [0/0x20000/0xFFFFFFFF]
            Expected: GT_OK & edge as set.
        */
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {

                taiId.taiNumber   = taiNumber[i];
                for(j= 0; j < 3; j++)
                {
                    st = cpssDxChPtpTaiClockReceptionEdgeSet(dev, &taiId, edge[j]);
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, taiId.taiInstance,
                            taiId.taiNumber, edge[j]);

                    st = cpssDxChPtpTaiClockReceptionEdgeGet(dev, &taiId, &edgeGet);
                    UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                            "cpssDxChPtpTaiClockReceptionEdgeGet: %d ", dev);

                    /* Verifying values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(edgeGet, edge[j],
                            "got another clock reception Edge then was set: %d", dev);
                }
            }
        }

        /*
           1.3  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockReceptionEdgeSet
                                (dev, &taiId, edge[0]), taiId.taiNumber);
    }

    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiClockReceptionEdgeSet(dev, &taiId, edge[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiClockReceptionEdgeSet(dev, &taiId, edge[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiClockReceptionEdgeGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC               *taiIdPtr,
    OUT GT_U32                                 *edgePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiClockReceptionEdgeGet)
{
/*
    1.1. Call cpssDxChPtpTaiClockReceptionEdgeGet without any set operations
    Expected: GT_OK & edge as 0
    1.2 Call with taiId.taiInstance out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.3 Call with taiId.taiNumber out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    1.5 Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                                       st = GT_OK;
    GT_U8                                           dev = 0;
    GT_U32                                          i, edgeGet, edgeDef = 0;
    CPSS_DXCH_PTP_TAI_ID_STC                        taiId = {0,0,0};
    UTF_PHYSICAL_PORT_NUM                           port;

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E;
        taiId.portNum = 0;
        for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
        {

            /*
             * 1.1. Call cpssDxChPtpTaiClockReceptionEdgeGet without any set operations
             *           Expected: GT_OK & edge as 0
             */

            st = cpssDxChPtpTaiClockReceptionEdgeGet(dev, &taiId, &edgeGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                    "cpssDxChPtpTaiClockReceptionEdgeGet: %d", dev);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(edgeGet, edgeDef,
                               "got another clock reception edge then default: %d", dev);
        }

        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            taiId.portNum = port;
            taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for(i = 0; i < CPSS_DXCH_PTP_TAI_NUMBER_2_E; i++)
            {

                taiId.taiNumber = taiNumber[i];
                st = cpssDxChPtpTaiClockReceptionEdgeGet(dev, &taiId, &edgeGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTaiClockReceptionEdgeGet: %d ", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(edgeGet, edgeDef,
                               "got another clk reception edge then default: %d", dev);
            }
        }

        /*
           1.2. Call api with NULL Clk reception edge pointer.
                Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiClockReceptionEdgeGet(dev, &taiId, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

        /*
           1.4  Call with taiId.taiNumber out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPtpTaiClockReceptionEdgeGet
                                (dev, &taiId, &edgeGet), taiId.taiNumber);
    }

    /* 2 For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiClockReceptionEdgeGet(dev, &taiId, &edgeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*
       3. Call function with out of bound value for device id
            Expected: GT_BAD_PARAM.
    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiClockReceptionEdgeGet(dev, &taiId, &edgeGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuTimeStampMaskingProfileSet
(
    IN GT_U8                                            devNum,
    IN GT_PHYSICAL_PORT_NUM                             portNum,
    IN GT_U32                                           index,
    IN CPSS_DXCH_PTP_TSU_TIMESTAMP_MASKING_PROFILE_STC  *maskingProfilePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuTimeStampMaskingProfileSet)
{
/*
    ITERATE_DEVICES(Bobcat2, Caelum, Bobcat3)
    1.1.1 Call with(Valid Combination)
            portNum [all available pors]
            index   [0..7]
            maskingProfile [numOfBits  [16, 48, 80, 80],
                            numOfLsbits[ 6, 20, 30, 70],
                            numOfShifts[ 8, 16, 48,  8]]
    Expected: GT_OK & maskingProfile as set.
    1.1.2 Call with(Invalid combinations)
            portNum [all available pors]
            index   [0..7]
            maskingProfile [numOfBits  [16, 48, 64, 64, 80, 80],
                            numOfLsbits[16, 20, 30, 70, 80, 16],
                            numOfShifts[ 8, 48, 72,  8,  8, 80]]
    Expected: GT_OK & maskingProfile as set.
    1.2. Call function with out of bound value for index.
    Expected: GT_BAD_PARAM.
    2. For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    4. Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st;
    GT_U8                                   index, j;
    UTF_PHYSICAL_PORT_NUM                   port;
    GT_U8                                   dev = 0;
    CPSS_DXCH_PTP_TSU_TIMESTAMP_MASKING_PROFILE_STC maskingProfileGet = {0,0,0};

    CPSS_DXCH_PTP_TSU_TIMESTAMP_MASKING_PROFILE_STC
                             validMaskingProfile[5]   = {{16,  6,  8},
                                                         {48, 20, 16},
                                                         {80, 30, 48},
                                                         {80, 70,  8},
                                                         {16,  0,  0}/* Default set at last*/};

    CPSS_DXCH_PTP_TSU_TIMESTAMP_MASKING_PROFILE_STC
                             invalidMaskingProfile[6] = {
                                                         {48, 20, 48},
                                                         {64, 30, 72},
                                                         {64, 70,  8},
                                                         {80, 16, 80}
                                                        };
    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                     UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1.1 Call with(Valid Combination)
            portNum [all available pors]
            index   [0..7]
            maskingProfile [numOfBits  [16, 48, 80, 80],
                            numOfLsbits[10, 20, 30, 70],
                            numOfShifts[ 8, 16, 72,  8]]
            Expected: GT_OK & maskingProfile as set.
        */
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            for(index = 0; index < 8; index++)
            {
                for(j= 0; j < 5; j++)
                {
                    st = cpssDxChPtpTsuTimeStampMaskingProfileSet(dev, port, index, &validMaskingProfile[j]);
                    UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, index,
                            validMaskingProfile[j].numOfBits, validMaskingProfile[j].numOfLsbits,
                            validMaskingProfile[j].numOfShifts);

                    st = cpssDxChPtpTsuTimeStampMaskingProfileGet(dev, port, index, &maskingProfileGet);
                    UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                            "cpssDxChPtpTsuTimeStampMaskingProfileGet: %d ", dev);

                    /* Verifying values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(maskingProfileGet.numOfBits, validMaskingProfile[j].numOfBits,
                            "got another maskingprofile numOfBits then was set: %d", dev);
                    UTF_VERIFY_EQUAL1_STRING_MAC(maskingProfileGet.numOfLsbits, validMaskingProfile[j].numOfLsbits,
                            "got another maskingprofile numOfLsbits then was set: %d", dev);
                    UTF_VERIFY_EQUAL1_STRING_MAC(maskingProfileGet.numOfShifts, validMaskingProfile[j].numOfShifts,
                            "got another maskingprofile numOfShifts then was set: %d", dev);
                }

                /*
                1.1.2 Call with(Invalid combinations)
                portNum [all available pors]
                index   [0..7]
                maskingProfile [numOfBits  [16, 48, 64, 64, 80, 80],
                                numOfLsbits[16, 20, 30, 70, 80, 16],
                                numOfShifts[ 8, 48, 72,  8,  8, 80]]
                */
                for(j= 0; j < 5; j++)
                {
                    st = cpssDxChPtpTsuTimeStampMaskingProfileSet(dev, port, index, &invalidMaskingProfile[j]);
                    UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, index,
                            invalidMaskingProfile[j].numOfBits, invalidMaskingProfile[j].numOfLsbits,
                            invalidMaskingProfile[j].numOfShifts);
                }
            }

        }

        /*
           1.2  Call with index out of range(index valid range [0:7])
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        cpssDxChPtpTsuTimeStampMaskingProfileSet(dev, port, 8, &validMaskingProfile[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
    }

    port = 0;  /* Valid Port */
    index = 3; /* Valid Index */
    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E | UTF_IRONMAN_L_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTsuTimeStampMaskingProfileSet(dev, port, index, &validMaskingProfile[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsuTimeStampMaskingProfileSet(dev, port, index, &validMaskingProfile[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuTimeStampMaskingProfileGet
(
    IN GT_U8                                            devNum,
    IN GT_PHYSICAL_PORT_NUM                             portNum,
    IN GT_U32                                           index,
    OUT CPSS_DXCH_PTP_TSU_TIMESTAMP_MASKING_PROFILE_STC *maskingProfilePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuTimeStampMaskingProfileGet)
{
/*
    1.1. Call cpssDxChPtpTsuTimeStampMaskingProfileGet without any set operations
    Expected: GT_OK & maskingProfile as default
    1.3 Call with index out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    1.5 Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                                       st = GT_OK;
    GT_U8                                           dev = 0;
    GT_U32                                          index;
    UTF_PHYSICAL_PORT_NUM                           port;
    CPSS_DXCH_PTP_TSU_TIMESTAMP_MASKING_PROFILE_STC maskingProfileGet = {0,0,0};
    CPSS_DXCH_PTP_TSU_TIMESTAMP_MASKING_PROFILE_STC maskingProfileDef = {16,0,0};

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                     UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E | UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            for(index = 0; index < 8; index++)
            {
                /* Set the default masking profile
                 * This feature is opional, so the default will not be populated at init */
                st = cpssDxChPtpTsuTimeStampMaskingProfileSet(dev, port, index, &maskingProfileDef);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTsuTimeStampMaskingProfileSet: %d", dev);

                /*
                 * 1.1. Call cpssDxChPtpTsuTimeStampMaskingProfileGet without any set operations
                 *           Expected: GT_OK & maskingProfile as default.
                 */
                st = cpssDxChPtpTsuTimeStampMaskingProfileGet(dev, port, index, &maskingProfileGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPtpTsuTimeStampMaskingProfileGet: %d", dev);

                /* Verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(maskingProfileGet.numOfBits, maskingProfileDef.numOfBits,
                        "got another maskProfile numOfBits then default: %d", dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(maskingProfileGet.numOfLsbits, maskingProfileDef.numOfLsbits,
                        "got another maskProfile numOfLsbits then default: %d", dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(maskingProfileGet.numOfShifts, maskingProfileDef.numOfShifts,
                        "got another maskProfile numOfShifts then default: %d", dev);
            }
        }

        /*
           1.2. Call api with NULL mask Profile pointer.
                Expected: GT_BAD_PARAM.
        */
        port = 0;  /* Valid Port */
        index = 3; /* Valid Index */
        st = cpssDxChPtpTsuTimeStampMaskingProfileGet(dev, port, index, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

        /*
           1.4  Call with index out of range
                and other params from 1.1.1.
           Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTsuTimeStampMaskingProfileGet(dev, port, 8, &maskingProfileGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
    }

    /* 2 For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E | UTF_IRONMAN_L_E);

    index = 0;
    port  = 0;

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
        st = prvUtfNextMacPortGet(&port, GT_TRUE);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        st = cpssDxChPtpTsuTimeStampMaskingProfileGet(dev, port, index, &maskingProfileGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*
       3. Call function with out of bound value for device id
            Expected: GT_BAD_PARAM.
    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsuTimeStampMaskingProfileGet(dev, port, index, &maskingProfileGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuTSFrameCounterControlSet
(
    IN GT_U8                                            devNum,
    IN GT_PHYSICAL_PORT_NUM                             portNum,
    IN GT_U32                                           index,
    IN CPSS_DXCH_PTP_TSU_FRAME_COUNTER_CFG_ENTRY_STC   *frameCounterConfigPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuTSFrameCounterControlSet)
{
/*
    1.1.1 Call with
            portNum [all available pors]
            index   [0..3]
            maskingProfile [anable [ GT_TRUE / GT_FALSE ],
                            action [CPSS_DXCH_PTP_TS_ACTION_NONE_E                      |
                                    CPSS_DXCH_PTP_TS_ACTION_DROP_E                      |
                                    CPSS_DXCH_PTP_TS_ACTION_CAPTURE_E                   |
                                    CPSS_DXCH_PTP_TS_ACTION_ADD_TIME_E                  |
                                    CPSS_DXCH_PTP_TS_ACTION_ADD_CORRECTED_TIME_E        |
                                    CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_TIME_E          |
                                    CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_CORRECTED_TIME_E|
                                    CPSS_DXCH_PTP_TS_ACTION_ADD_INGRESS_TIME_E          |
                                    CPSS_DXCH_PTP_TS_ACTION_CAPTURE_INGRESS_TIME_E      |
                                    CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_INGRESS_TIME_E  |
                                    CPSS_DXCH_PTP_TS_ACTION_ADD_INGRESS_EGRESS_TIME_E   |
                                    CPSS_DXCH_PTP_TS_ACTION_ALL_E                       |
                            ]
                            format [CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E               |
                                    CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V2_E               |
                                    CPSS_DXCH_PTP_TS_PACKET_TYPE_Y1731_E                |
                                    CPSS_DXCH_PTP_TS_PACKET_TYPE_NTP_TS_E               |
                                    CPSS_DXCH_PTP_TS_PACKET_TYPE_NTP_RX_E               |
                                    CPSS_DXCH_PTP_TS_PACKET_TYPE_NTP_TX_E               |
                                    CPSS_DXCH_PTP_TS_PACKET_TYPE_WAMP_E                 |
                                    CPSS_DXCH_PTP_TS_PACKET_TYPE_ALL_E                  |
                                    CPSS_DXCH_PTP_TS_PACKET_TYPE_RESERVED_E],
                            maskProfile [0..7]]
    Expected: GT_OK & maskingProfile as set.
    1.2. Call function with out of bound value for index.
    Expected: GT_BAD_PARAM.
    2. For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    4. Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                                     st;
    GT_32                                         index, statusCnt, maskProfile, actionCnt, formatCnt;
    UTF_PHYSICAL_PORT_NUM                         port;
    GT_U8                                         dev = 0;
    CPSS_DXCH_PTP_TSU_FRAME_COUNTER_CFG_ENTRY_STC frameCounterConfigGet = {0,0,0};
    CPSS_DXCH_PTP_TSU_FRAME_COUNTER_CFG_ENTRY_STC frameCounterConfig = {0,0,0};
    GT_BOOL                                       counterStatus[2] = {GT_TRUE, GT_FALSE};

    CPSS_DXCH_PTP_TS_ACTION_ENT action[12] = {CPSS_DXCH_PTP_TS_ACTION_DROP_E,
                                             CPSS_DXCH_PTP_TS_ACTION_CAPTURE_E,
                                             CPSS_DXCH_PTP_TS_ACTION_ADD_TIME_E,
                                             CPSS_DXCH_PTP_TS_ACTION_ADD_CORRECTED_TIME_E,
                                             CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_TIME_E,
                                             CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_CORRECTED_TIME_E,
                                             CPSS_DXCH_PTP_TS_ACTION_ADD_INGRESS_TIME_E,
                                             CPSS_DXCH_PTP_TS_ACTION_CAPTURE_INGRESS_TIME_E,
                                             CPSS_DXCH_PTP_TS_ACTION_CAPTURE_ADD_INGRESS_TIME_E,
                                             CPSS_DXCH_PTP_TS_ACTION_ADD_INGRESS_EGRESS_TIME_E,
                                             CPSS_DXCH_PTP_TS_ACTION_ALL_E,
                                             CPSS_DXCH_PTP_TS_ACTION_NONE_E};

    CPSS_DXCH_PTP_TS_PACKET_TYPE_ENT format[9] = {CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V2_E,
                                              CPSS_DXCH_PTP_TS_PACKET_TYPE_Y1731_E,
                                              CPSS_DXCH_PTP_TS_PACKET_TYPE_NTP_TS_E,
                                              CPSS_DXCH_PTP_TS_PACKET_TYPE_NTP_RX_E,
                                              CPSS_DXCH_PTP_TS_PACKET_TYPE_NTP_TX_E,
                                              CPSS_DXCH_PTP_TS_PACKET_TYPE_WAMP_E,
                                              CPSS_DXCH_PTP_TS_PACKET_TYPE_ALL_E,
                                              CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V1_E, /* Default */
                                              CPSS_DXCH_PTP_TS_PACKET_TYPE_RESERVED_E};
    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            for(index = 0; index < 4; index++)
            {
                for(maskProfile= 7; maskProfile >= 0; maskProfile--)
                {
                    for(actionCnt = 0; actionCnt<=CPSS_DXCH_PTP_TS_ACTION_ALL_E; actionCnt++)
                    {
                        for(formatCnt = 0; formatCnt<CPSS_DXCH_PTP_TS_PACKET_TYPE_RESERVED_E; formatCnt++)
                        {
                            for(statusCnt=0; statusCnt<2; statusCnt++)
                            {
                                frameCounterConfig.enable = counterStatus[statusCnt];
                                frameCounterConfig.format = format[formatCnt];
                                frameCounterConfig.action = action[actionCnt];
                                st = cpssDxChPtpTsuTSFrameCounterControlSet(dev, port, index, &frameCounterConfig);
                                UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, index,
                                        frameCounterConfig.enable, frameCounterConfig.action,
                                        frameCounterConfig.format);

                                st = cpssDxChPtpTsuTSFrameCounterControlGet(dev, port, index, &frameCounterConfigGet);
                                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                        "cpssDxChPtpTsuTSFrameCounterControlGet: %d ", dev);

                                if (frameCounterConfig.action == CPSS_DXCH_PTP_TS_ACTION_ADD_INGRESS_EGRESS_TIME_E)
                                {
                                    UTF_VERIFY_EQUAL1_STRING_MAC(frameCounterConfigGet.action, CPSS_DXCH_PTP_TS_ACTION_ADD_TIME_E,
                                            "got another frameCounterConfig counter action then was set: %d", dev);
                                }
                                /* Verifying values */
                                UTF_VERIFY_EQUAL1_STRING_MAC(frameCounterConfigGet.enable, frameCounterConfig.enable,
                                        "got another frameCounterConfig counter status then was set: %d", dev);
                                UTF_VERIFY_EQUAL1_STRING_MAC(frameCounterConfigGet.format, frameCounterConfig.format,
                                        "got another frameCounterConfig counter format then was set: %d", dev);
                                if (frameCounterConfig.action == CPSS_DXCH_PTP_TS_ACTION_ADD_INGRESS_EGRESS_TIME_E)
                                {
                                    UTF_VERIFY_EQUAL1_STRING_MAC(frameCounterConfigGet.action, CPSS_DXCH_PTP_TS_ACTION_ADD_TIME_E,
                                            "got another frameCounterConfig counter action then was set: %d", dev);
                                }
                                else
                                {
                                    UTF_VERIFY_EQUAL1_STRING_MAC(frameCounterConfigGet.action, frameCounterConfig.action,
                                            "got another frameCounterConfig counter action then was set: %d", dev);
                                }
                            }
                        }
                    }
                }
            }

            /*
               1.2  Call with index out of range(index valid range [0:3])
               and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            st = cpssDxChPtpTsuTSFrameCounterControlSet(dev, port, 65/*Index*/, &frameCounterConfig);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }
    }

    port = 0;  /* Valid Port */
    index = 3; /* Valid Index */
    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTsuTSFrameCounterControlSet(dev, port, index, &frameCounterConfig);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsuTSFrameCounterControlSet(dev, port, index, &frameCounterConfig);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuTSFrameCounterControlGet
(
    IN  GT_U8                                            devNum,
    IN  GT_PHYSICAL_PORT_NUM                             portNum,
    IN  GT_U32                                           index,
    OUT CPSS_DXCH_PTP_TSU_FRAME_COUNTER_CFG_ENTRY_STC   *frameCounterConfigPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuTSFrameCounterControlGet)
{
/*
    1.1. Call cpssDxChPtpTsuTSFrameCounterControlGet without any set operations
    Expected: GT_OK & frameCounterConfig as default
    1.3 Call with index out of range, and other params from 1.1
    Expected: GT_BAD_PARAM.
    1.4 For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    1.5 Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                                     st = GT_OK;
    GT_U8                                         dev = 0;
    GT_U8                                         index, statusCnt, maskProfile, actionCnt, formatCnt;
    UTF_PHYSICAL_PORT_NUM                         port;
    CPSS_DXCH_PTP_TSU_FRAME_COUNTER_CFG_ENTRY_STC frameCounterConfigGet = {0, 0, 0};
    CPSS_DXCH_PTP_TSU_FRAME_COUNTER_CFG_ENTRY_STC frameCounterConfigDef = {GT_FALSE, 0, 0};

    /* there is no TAI and PTP in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    if (cpssDeviceRunCheck_onEmulator())
    {
        /* default version on emulator is PTP V2 packets */
        frameCounterConfigDef.format = CPSS_DXCH_PTP_TS_PACKET_TYPE_PTP_V2_E;
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            for(index = 0; index < 4; index++)
            {
                for(maskProfile= 0; maskProfile < 8; maskProfile++)
                {
                    for(actionCnt = 0; actionCnt<=CPSS_DXCH_PTP_TS_ACTION_ALL_E; actionCnt++)
                    {
                        for(formatCnt = 0; formatCnt<CPSS_DXCH_PTP_TS_PACKET_TYPE_RESERVED_E; formatCnt++)
                        {
                            for(statusCnt=0; statusCnt<2; statusCnt++)
                            {
                                /*
                                 * 1.1. Call cpssDxChPtpTsuTSFrameCounterControlGet without any set operations
                                 *           Expected: GT_OK & maskProfile as default.
                                 */

                                st = cpssDxChPtpTsuTSFrameCounterControlGet(dev, port, index, &frameCounterConfigGet);
                                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                        "cpssDxChPtpTsuTSFrameCounterControlGet: %d", dev);

                                /* Verifying values */
                                UTF_VERIFY_EQUAL1_STRING_MAC(frameCounterConfigGet.enable, frameCounterConfigDef.enable,
                                        "got another frameCounterConfig counter status then was set: %d", dev);
                                UTF_VERIFY_EQUAL1_STRING_MAC(frameCounterConfigGet.format, frameCounterConfigDef.format,
                                        "got another frameCounterConfig counter format then was set: %d", dev);
                                UTF_VERIFY_EQUAL1_STRING_MAC(frameCounterConfigGet.action, frameCounterConfigDef.action,
                                        "got another frameCounterConfig counter action then was set: %d", dev);
                            }
                        }
                    }
                }
            }
            /*
               1.2. Call api with NULL frame counter control pointer.
               Expected: GT_BAD_PARAM.
            */
            st = cpssDxChPtpTsuTSFrameCounterControlGet(dev, port, 3, NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

            /*
               1.3  Call with index out of range
               and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            st = cpssDxChPtpTsuTSFrameCounterControlGet(dev, port, 65, &frameCounterConfigGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }
    }

    port = 0;  /* Valid Port */
    index = 3; /* Valid Index */
    /* 2 For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTsuTSFrameCounterControlGet(dev, port, index, &frameCounterConfigGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*
       3. Call function with out of bound value for device id
            Expected: GT_BAD_PARAM.
    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsuTSFrameCounterControlGet(dev, port, index, &frameCounterConfigGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuTsFrameCounterIndexSet
(
    IN GT_U8                                            devNum,
    IN GT_PHYSICAL_PORT_NUM                             portNum,
    IN GT_U32                                           index,
    IN GT_U32                                           frameCounter,
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuTsFrameCounterIndexSet)
{
/*
    1.1.1 Call with
            portNum [all available pors]
            index   [0..3]
            frameCounter [0/10000]
    Expected: GT_OK & frameCounter as set.
    1.2. Call function with out of bound value for index.
    Expected: GT_BAD_PARAM.
    2. For not applicable devices check that function returns non GT_OK.
    Expected: GT_NOT_APPLICABLE_DEVICE.
    4. Call function with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                                     st;
    GT_U32                                        index, i;
    UTF_PHYSICAL_PORT_NUM                         port;
    GT_U8                                         dev = 0;
    GT_U32                                        frameCounter[2] = {0, 10000};

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*  For all active devices go over all available physical ports. */
        while(GT_OK == prvUtfNextMacPortGet(&port, GT_TRUE))
        {
            for(index = 0; index < 4; index++)
            {
                for (i = 0; i < 2; i++)
                {
                    st = cpssDxChPtpTsuTsFrameCounterIndexSet(dev, port, index, frameCounter[i]);
                    UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, index, frameCounter);

            }

            /*
               1.2  Call with index out of range(index valid range [0:3])
               and other params from 1.1.1.
               Expected: GT_BAD_PARAM.
            */
            st = cpssDxChPtpTsuTsFrameCounterIndexSet(dev, port, 65/*Index*/, frameCounter[0]);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }
      }
    }

    port = 0;  /* Valid Port */
    index = 3; /* Valid Index */
    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev,
                                   UTF_XCAT3_E | UTF_AC5_E |
                                       UTF_LION2_E | UTF_BOBCAT2_E |
                                     UTF_CAELUM_E | UTF_ALDRIN_E | UTF_AC3X_E | UTF_BOBCAT3_E | UTF_ALDRIN2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTsuTsFrameCounterIndexSet(dev, port, index, frameCounter[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /*3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTsuTsFrameCounterIndexSet(dev, port, index, frameCounter[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpUBitModeGet
(
    IN  GT_U8                                    devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                 *taiIdPtr,
    OUT  CPSS_DXCH_PTP_U_BIT_MODE_ENT            *uBitModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpUBitModeGet)
{
/*
    ITERATE_DEVICES(Falcon)
    1.1 Call with non-null uBitModeptr
    Expected: GT_OK.
    1.2 Call api with wrong uBitModePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st     = GT_OK;
    GT_U8                             devNum = 0;
    CPSS_DXCH_PTP_U_BIT_MODE_ENT      uBitModePtr;
    CPSS_DXCH_PTP_TAI_ID_STC   taiId =
        {CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E, CPSS_DXCH_PTP_TAI_NUMBER_0_E, 0};

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, (UTF_FALCON_E | UTF_AC5P_E | UTF_AC5X_E | UTF_HARRIER_E));

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with non-null queueSizePtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpUBitModeSet(devNum, &taiId, CPSS_DXCH_PTP_TAI_U_BIT_MODE_ASSIGNED_E);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        st = cpssDxChPtpUBitModeGet(devNum, &taiId, &uBitModePtr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        UTF_VERIFY_EQUAL0_STRING_MAC(CPSS_DXCH_PTP_TAI_U_BIT_MODE_ASSIGNED_E, uBitModePtr, "" );
        /*
            1.2 Call api with wrong queueSizePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpUBitModeGet(devNum, &taiId, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, (UTF_CPSS_PP_ALL_SIP6_CNS));

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpUBitModeGet(devNum, &taiId, &uBitModePtr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpUBitModeGet(devNum, &taiId, &uBitModePtr);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpUBitModeSet
(
    IN  GT_U8                                    devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC                 *taiIdPtr,
    IN  CPSS_DXCH_PTP_U_BIT_MODE_ENT             uBitMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpUBitModeSet)
{
/*
    ITERATE_DEVICES(Falcon)
    1.1 Call with non-null uBitModeptr
    Expected: GT_OK.
    1.2 Call api with wrong uBitModePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st     = GT_OK;
    GT_U8                             devNum = 0;
    CPSS_DXCH_PTP_U_BIT_MODE_ENT      uBitModePtr;
    CPSS_DXCH_PTP_TAI_ID_STC   taiId =
        {CPSS_DXCH_PTP_TAI_INSTANCE_GLOBAL_E, CPSS_DXCH_PTP_TAI_NUMBER_0_E, 0};

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, (UTF_FALCON_E | UTF_AC5P_E | UTF_AC5X_E | UTF_HARRIER_E));

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        /*
            1.1 Call with non-null uBitModePtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpUBitModeSet(devNum, &taiId, CPSS_DXCH_PTP_TAI_U_BIT_MODE_ASSIGNED_E);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        st = cpssDxChPtpUBitModeGet(devNum, &taiId, &uBitModePtr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        UTF_VERIFY_EQUAL0_STRING_MAC(CPSS_DXCH_PTP_TAI_U_BIT_MODE_ASSIGNED_E, uBitModePtr, "" );

        st = cpssDxChPtpUBitModeSet(devNum, &taiId, 3);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum,(UTF_CPSS_PP_ALL_SIP6_CNS));

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpUBitModeSet(devNum, &taiId, uBitModePtr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpUBitModeSet(devNum, &taiId, CPSS_DXCH_PTP_TAI_U_BIT_MODE_ASSIGNED_E);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}
/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpPLLBypassEnableGet
(
    IN  GT_U8                    dev,
    OUT GT_BOOL                  *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpPLLBypassEnableGet)
{

    GT_STATUS st = GT_OK;

    GT_U8                    dev;
    GT_BOOL                  enable;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, (UTF_FALCON_E | UTF_AC5P_E | UTF_AC5X_E | UTF_HARRIER_E));

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = cpssDxChPtpPLLBypassEnableSet(dev, GT_TRUE);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        st = cpssDxChPtpPLLBypassEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        UTF_VERIFY_EQUAL0_STRING_MAC(GT_TRUE, enable, "");

        /*
            1.4. Call api with wrong enablePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpPLLBypassEnableGet(dev, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
    }



    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, (UTF_CPSS_PP_ALL_SIP6_CNS));;

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpPLLBypassEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpPLLBypassEnableGet(dev, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpPLLBypassEnableSet
(
    IN  GT_U8                   dev,
    IN  GT_BOOL                 enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpPLLBypassEnableSet)
{

    GT_STATUS st = GT_OK;

    GT_U8                   dev;
    GT_BOOL                 enable = GT_FALSE;
    GT_BOOL                 enableGet = GT_FALSE;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, (UTF_FALCON_E | UTF_AC5P_E | UTF_AC5X_E | UTF_HARRIER_E));

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {

        enable = GT_TRUE;

        st = cpssDxChPtpPLLBypassEnableSet(dev, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPtpPLLBypassEnableSet
                   with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpPLLBypassEnableGet(dev,  &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPtpPLLBypassEnableSet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                       "got another enable then was set: %d", dev);
    }
    enable = GT_TRUE;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, (UTF_CPSS_PP_ALL_SIP6_CNS));

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpPLLBypassEnableSet(dev, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpPLLBypassEnableSet(dev, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}
/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuBypassEnableGet
(
    IN  GT_U8                                 devNum,
    OUT GT_BOOL                               tsuEnable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuBypassEnableGet)
{

    GT_STATUS                    st;
    GT_U8                        devNum;
    GT_BOOL                      tsuEnable;


    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, (UTF_AC5P_E | UTF_AC5X_E | UTF_HARRIER_E | UTF_IRONMAN_L_E));

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {

            st = cpssDxChPtpTsuBypassEnableGet(
                    devNum,
                    &tsuEnable);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);


            /*
               1.5 Call with invalid enabledPtr [NULL].
               Expected: GT_BAD_PTR.
            */

            st = cpssDxChPtpTsuBypassEnableGet(
                    devNum,
                    NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                         devNum);
    }



    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, (UTF_AC5P_E | UTF_AC5X_E | UTF_HARRIER_E | UTF_IRONMAN_L_E));

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsuBypassEnableGet(devNum, &tsuEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTsuBypassEnableGet(devNum, &tsuEnable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuBypassEnableSet
(
    IN  GT_U8                                 devNum,
    IN  GT_BOOL                               tsuEnable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuBypassEnableSet)
{

        GT_STATUS                    st;
        GT_U8                        devNum;
        GT_BOOL                      tsuEnable = GT_TRUE;
        GT_BOOL                      tsuEnableGet = GT_TRUE;


        /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, (UTF_AC5P_E | UTF_AC5X_E | UTF_HARRIER_E | UTF_IRONMAN_L_E));

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {

                st = cpssDxChPtpTsuBypassEnableSet(devNum, tsuEnable);
                UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

                st = cpssDxChPtpTsuBypassEnableGet(devNum, &tsuEnable);
                UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
                UTF_VERIFY_EQUAL0_PARAM_MAC(tsuEnable, tsuEnableGet);
        }
        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, (UTF_AC5P_E | UTF_AC5X_E | UTF_HARRIER_E | UTF_IRONMAN_L_E));

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTsuBypassEnableSet(devNum, tsuEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTsuBypassEnableSet(devNum, tsuEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuEnableGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              portNum,
    OUT GT_BOOL                               tsuEnable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuEnableGet)
{

    GT_STATUS                    st;
    GT_U8                        devNum;
    GT_BOOL                      tsuEnable;
    UTF_PHYSICAL_PORT_NUM        portNum = 0;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&portNum, devNum);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
        while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_TRUE))
        {
            if(prvCpssDxChPortRemotePortCheck(devNum, portNum))
            {
                st = cpssDxChPtpTsuEnableGet(devNum,
                                          portNum,
                                          &tsuEnable);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
                continue;
            }
            st = cpssDxChPtpTsuEnableGet(
                    devNum,
                    portNum,
                    &tsuEnable);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);


            /*
               1.5 Call with invalid enabledPtr [NULL].
               Expected: GT_BAD_PTR.
            */

            st = cpssDxChPtpTsuEnableGet(
                    devNum,
                    portNum,
                    NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                         devNum);
      }
    }



    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTsuEnableGet(devNum, portNum, &tsuEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTsuEnableGet(devNum, portNum, &tsuEnable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTsuEnableSet
(
    IN  GT_U8                                 devNum,
    IN  GT_PHYSICAL_PORT_NUM                  portNum,
    IN  GT_BOOL                               tsuEnable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTsuEnableSet)
{

        GT_STATUS                    st;
        GT_U8                        devNum;
        GT_BOOL                      tsuEnable = GT_TRUE;
        GT_BOOL                      tsuEnableGet = GT_TRUE;
        UTF_PHYSICAL_PORT_NUM        portNum = 0;


        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            st = prvUtfNextMacPortReset(&portNum, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
            while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_TRUE))
            {
                if(prvCpssDxChPortRemotePortCheck(devNum, portNum))
                {
                    st = cpssDxChPtpTsuEnableSet(devNum,
                                              portNum,
                                              tsuEnable);
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
                    continue;
                }
                st = cpssDxChPtpTsuEnableSet(devNum,portNum,tsuEnable);
                UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);


                st = cpssDxChPtpTsuEnableGet(devNum, portNum, &tsuEnable);
                UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
                UTF_VERIFY_EQUAL0_PARAM_MAC(tsuEnable, tsuEnableGet);
            }
        }
        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpTsuEnableSet
                                (devNum, portNum, tsuEnable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpTsuEnableSet(devNum, portNum, tsuEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}
/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpRxTaiSelectGet
(
    IN  GT_U8                                 devNum,
    IN  CPSS_DXCH_PTP_TAI_ID_STC              portNum,
    OUT GT_BOOL                               rxTaiSelect
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpRxTaiSelectGet)
{

    GT_STATUS                    st;
    GT_U8                        devNum;
    GT_U32                       rxTaiSelect;
    UTF_PHYSICAL_PORT_NUM        portNum = 0;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        st = prvUtfNextMacPortReset(&portNum, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
         while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_TRUE))
         {
            if(prvCpssDxChPortRemotePortCheck(devNum, portNum))
            {
                st = cpssDxChPtpRxTaiSelectGet(devNum,
                                              portNum,
                                              &rxTaiSelect);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
                continue;
            }
            st = cpssDxChPtpRxTaiSelectGet(
                devNum,
                portNum,
                &rxTaiSelect);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);


        /*
           1.5 Call with invalid enabledPtr [NULL].
           Expected: GT_BAD_PTR.
        */

        st = cpssDxChPtpRxTaiSelectGet(
                devNum,
                portNum,
                NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enabled = NULL",
                                     devNum);
        }
    }



    /* 2. For not applicable devices check that function returns non GT_OK.*/
    /* prepare device iterator to go through all non-applicable devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non-applicable devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpRxTaiSelectGet(devNum, portNum, &rxTaiSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /*3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpRxTaiSelectGet(devNum, portNum, &rxTaiSelect);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpRxTaiSelectSet
(
    IN  GT_U8                                 devNum,
    IN  GT_PHYSICAL_PORT_NUM                  portNum,
    IN  GT_U32                               rxTaiSelect
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpRxTaiSelectSet)
{

        GT_STATUS                    st;
        GT_U8                        devNum;
        GT_U32                       rxTaiSelect = 1;
        GT_BOOL                      rxTaiSelectGet = 1;
        GT_PHYSICAL_PORT_NUM         portNum = 0;


        /* prepare device iterator */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* 1. Go over all active devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
        {
            st = prvUtfNextMacPortReset(&portNum, devNum);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /* 1.1. For all active devices go over all available physical ports.*/
            while(GT_OK == prvUtfNextMacPortGet(&portNum, GT_TRUE))
            {
                if(prvCpssDxChPortRemotePortCheck(devNum, portNum))
                {
                    st = cpssDxChPtpRxTaiSelectSet(devNum,
                                                  portNum,
                                                  rxTaiSelect);
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
                    continue;
                }
                st = cpssDxChPtpRxTaiSelectSet(
                        devNum,
                        portNum,
                        rxTaiSelect);

                UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);


                st = cpssDxChPtpRxTaiSelectGet(devNum, portNum, &rxTaiSelect);
                UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
                UTF_VERIFY_EQUAL0_PARAM_MAC(rxTaiSelect, rxTaiSelectGet);
            }

         }

        /* 2.For not applicable devices check that function returns non GT_OK.*/
        /* prepare device iterator to go through all non-applicable devices */
        PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&devNum, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

        /* Go over all non-applicable devices. */
        while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
        {
            st = cpssDxChPtpRxTaiSelectSet(devNum, portNum, rxTaiSelect);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
        }

        /*3. Call function with out of bound value for device id.*/
        devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
        st = cpssDxChPtpRxTaiSelectSet(devNum, portNum, rxTaiSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpRefClockSourceSelectSet
(
    IN  GT_U8                               devNum,
    IN  CPSS_DXCH_PTP_REF_CLOCK_SELECT_ENT  refClockSelect
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpRefClockSourceSelectSet)
{
    GT_STATUS st;
    GT_U8 devNum;
    CPSS_DXCH_PTP_REF_CLOCK_SELECT_ENT  refClockSelectGet;
    GT_U32 i;

     /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_AC5P_E );

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        for(i = 0; i <= CPSS_DXCH_PTP_REF_CLOCK_SELECT_SD_DIFFRENTIAL_REF_CLK_E; i++)
        {
             /*
                1.1. For all active devices go over all reference clock selection modes.
                Expected: GT_OK.
            */
            st = cpssDxChPtpRefClockSourceSelectSet(devNum,(CPSS_DXCH_PTP_REF_CLOCK_SELECT_ENT)i);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.2. Call cpssDxChPtpRefClockSelectGet with the same parameters.
                Expected: GT_OK and the same values than was set.
            */
            st = cpssDxChPtpRefClockSourceSelectGet(devNum,&refClockSelectGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC((CPSS_DXCH_PTP_REF_CLOCK_SELECT_ENT)i, refClockSelectGet,
                           "got another refClockSelect then was set: %d", devNum);
        }

         /*
            1.3. Call api with wrong refClockSelect.
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpRefClockSourceSelectSet(devNum,CPSS_DXCH_PTP_REF_CLOCK_SELECT_SD_DIFFRENTIAL_REF_CLK_E+1);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_AC5P_E );

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpRefClockSourceSelectSet(devNum,CPSS_DXCH_PTP_REF_CLOCK_SELECT_MAIN_25_MHZ_E);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpRefClockSourceSelectSet(devNum,CPSS_DXCH_PTP_REF_CLOCK_SELECT_MAIN_25_MHZ_E);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpRefClockSourceSelectGet
(
    IN  GT_U8                               devNum,
    OUT CPSS_DXCH_PTP_REF_CLOCK_SELECT_ENT  *refClockSelectPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpRefClockSourceSelectGet)
{
     GT_STATUS st;
    GT_U8 devNum;
    CPSS_DXCH_PTP_REF_CLOCK_SELECT_ENT  refClockSelect;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_AC5P_E );

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {

        /*
            1.1 Call with non-null refClockSelectPtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpRefClockSourceSelectGet(devNum, &refClockSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call api with wrong refClockSelectPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpRefClockSourceSelectGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_AC5P_E );

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpRefClockSourceSelectGet(devNum, &refClockSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpRefClockSourceSelectGet(devNum, &refClockSelect);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpNonPtpPacketTaiSelectSet
(
    IN  GT_U8                             devNum,
    IN  GT_U32                            taiSelect
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpNonPtpPacketTaiSelectSet)
{
    GT_STATUS st;
    GT_U8 devNum;
    GT_U32 taiSelect,taiSelectGet;

     /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        for(taiSelect = 0; taiSelect <=4; taiSelect++)
        {
             /*
                1.1. For all active devices go over all reference clock selection modes.
                Expected: GT_OK.
            */
            st = cpssDxChPtpNonPtpPacketTaiSelectSet(devNum,taiSelect);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /*
                1.2. Call cpssDxChPtpNonPtpPacketTaiSelectGet with the same parameters.
                Expected: GT_OK and the same values than was set.
            */
            st = cpssDxChPtpNonPtpPacketTaiSelectGet(devNum,&taiSelectGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(taiSelect,taiSelectGet,
                           "got another taiSelect then was set: %d", devNum);
        }

         /*
            1.3. Call api with wrong taiSelect.
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpNonPtpPacketTaiSelectSet(devNum,taiSelect+1);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpNonPtpPacketTaiSelectSet(devNum,taiSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpNonPtpPacketTaiSelectSet(devNum,taiSelect);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpNonPtpPacketTaiSelectGet
(
    IN  GT_U8                             devNum,
    OUT GT_U32                            *taiSelectPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpNonPtpPacketTaiSelectGet)
{
     GT_STATUS st;
    GT_U8 devNum;
    GT_U32  taiSelect;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E );

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {

        /*
            1.1 Call with non-null taiSelectPtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpNonPtpPacketTaiSelectGet(devNum, &taiSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call api with wrong taiSelectPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpNonPtpPacketTaiSelectGet(devNum, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E );

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpNonPtpPacketTaiSelectGet(devNum, &taiSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpNonPtpPacketTaiSelectGet(devNum, &taiSelect);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiOutputInterfaceSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_PIN_SELECT_ENT        pinId,
    IN  CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_ENT    interfaceType,
    IN  GT_U32                                  taiSelect
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiOutputInterfaceSet)
{
    GT_STATUS st;
    GT_U8 devNum;
    CPSS_DXCH_PTP_TAI_PIN_SELECT_ENT        pinId;
    CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_ENT    interfaceType;
    GT_U32 taiSelect,taiSelectGet;

     /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        for(pinId = CPSS_DXCH_PTP_TAI_PIN_SELECT_A_E; pinId <=CPSS_DXCH_PTP_TAI_PIN_SELECT_C_E; pinId++)
        {
            for (interfaceType = CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_CLOCK_E;interfaceType <= CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_PCLK_E;interfaceType++)
            {
                 for(taiSelect = 0; taiSelect <=4; taiSelect++)
                 {
                     /*
                        1.1. For all active devices go over all reference clock selection modes.
                        Expected: GT_OK.
                    */
                    st = cpssDxChPtpTaiOutputInterfaceSet(devNum,pinId,interfaceType,taiSelect);
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

                    /*
                        1.2. Call cpssDxChPtpTaiOutputInterfaceGet with the same parameters.
                        Expected: GT_OK and the same values than was set.
                    */
                    st = cpssDxChPtpTaiOutputInterfaceGet(devNum,pinId,interfaceType,&taiSelectGet);
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

                    /* Verifying values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(taiSelect,taiSelectGet,
                                   "got another taiSelect then was set: %d", devNum);
                }
            }
        }

         /*
            1.3. Call api with wrong taiSelect.
            Expected: GT_BAD_PARAM.
        */
        pinId = CPSS_DXCH_PTP_TAI_PIN_SELECT_C_E;
        interfaceType = CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_PCLK_E;
        taiSelect = 4;
        st = cpssDxChPtpTaiOutputInterfaceSet(devNum,pinId,interfaceType,taiSelect+1);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);

        /*
            1.3. Call api with wrong pinId.
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiOutputInterfaceSet(devNum,pinId+1,interfaceType,taiSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.3. Call api with wrong interfaceType.
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiOutputInterfaceSet(devNum,pinId,interfaceType+1,taiSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiOutputInterfaceSet(devNum,pinId,interfaceType,taiSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiOutputInterfaceSet(devNum,pinId,interfaceType,taiSelect);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiOutputInterfaceGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_PIN_SELECT_ENT        pinId,
    IN  CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_ENT    interfaceType,
    OUT GT_U32                                  *taiSelectPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiOutputInterfaceGet)
{
     GT_STATUS st;
    GT_U8 devNum;
    CPSS_DXCH_PTP_TAI_PIN_SELECT_ENT        pinId ;
    CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_ENT    interfaceType;
    GT_U32  taiSelect;

    pinId = CPSS_DXCH_PTP_TAI_PIN_SELECT_A_E;
    interfaceType = CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_CLOCK_E;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E );

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {

        /*
            1.1 Call with non-null taiSelectPtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpTaiOutputInterfaceGet(devNum,pinId,interfaceType,&taiSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call api with wrong taiSelectPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTaiOutputInterfaceGet(devNum,pinId,interfaceType,NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E );

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiOutputInterfaceGet(devNum,pinId,interfaceType,&taiSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiOutputInterfaceGet(devNum,pinId,interfaceType,&taiSelect);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiInputInterfaceSet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_PIN_SELECT_ENT        pinId,
    IN  CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_ENT    interfaceType,
    IN  GT_U32                                  taiSelectBmp
);
{
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiInputInterfaceSet)
{
    GT_STATUS st;
    GT_U8 devNum;
    CPSS_DXCH_PTP_TAI_PIN_SELECT_ENT        pinId;
    CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_ENT    interfaceType;
    GT_U32 taiSelectBmp,taiSelectBmpGet;

     /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {
        for(pinId = CPSS_DXCH_PTP_TAI_PIN_SELECT_C_E;; pinId--)
        {
            for (interfaceType = CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_CLOCK_E;interfaceType <= CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_PULSE_E;interfaceType++)
            {
                 for(taiSelectBmp = 1; taiSelectBmp <=0x1F;)
                 {
                     /*
                        1.1. For all active devices go over all reference clock selection modes.
                        Expected: GT_OK.
                    */
                    st = cpssDxChPtpTaiInputInterfaceSet(devNum,pinId,interfaceType,taiSelectBmp);
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

                    /*
                        1.2. Call cpssDxChPtpTaiInputInterfaceGet with the same parameters.
                        Expected: GT_OK and the same values than was set.
                    */
                    st = cpssDxChPtpTaiInputInterfaceGet(devNum,pinId,interfaceType,&taiSelectBmpGet);
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

                    /* Verifying values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(taiSelectBmp,taiSelectBmpGet,
                                   "got another taiSelectBmp then was set: %d", devNum);

                    taiSelectBmp = (taiSelectBmp << 1)+1;
                }
            }

            if (pinId == CPSS_DXCH_PTP_TAI_PIN_SELECT_A_E)
                break;
        }

         /*
            1.1. For all active devices go over all reference clock selection modes.
            Expected: GT_OK.
        */
        pinId = CPSS_DXCH_PTP_TAI_PIN_SELECT_NONE_E;
        interfaceType = CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_CLOCK_E;
        taiSelectBmp = 0x1F;
        st = cpssDxChPtpTaiInputInterfaceSet(devNum,pinId,interfaceType,taiSelectBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2. Call cpssDxChPtpTaiInputInterfaceGet with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPtpTaiInputInterfaceGet(devNum,pinId,interfaceType,&taiSelectBmpGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(taiSelectBmp,taiSelectBmpGet,
                       "got another taiSelectBmp then was set: %d", devNum);

         /*
            1.3. Call api with wrong taiSelectBmp.
            Expected: GT_BAD_PARAM.
        */
        pinId = CPSS_DXCH_PTP_TAI_PIN_SELECT_C_E;
        interfaceType = CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_PULSE_E;
        taiSelectBmp = 0x1F;
        st = cpssDxChPtpTaiInputInterfaceSet(devNum,pinId,interfaceType,taiSelectBmp+1);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, devNum);

        /*
            1.3. Call api with wrong pinId.
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiInputInterfaceSet(devNum,pinId+1,interfaceType,taiSelectBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

        /*
            1.3. Call api with wrong interfaceType.
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPtpTaiInputInterfaceSet(devNum,pinId,interfaceType+1,taiSelectBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    }

    pinId = CPSS_DXCH_PTP_TAI_PIN_SELECT_C_E;
    interfaceType = CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_PULSE_E;
    taiSelectBmp = 0x1F;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiInputInterfaceSet(devNum,pinId,interfaceType,taiSelectBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPtpTaiInputInterfaceSet(devNum,pinId,interfaceType,taiSelectBmp);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiInputInterfaceGet
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PTP_TAI_PIN_SELECT_ENT        pinId,
    IN  CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_ENT    interfaceType,
    OUT GT_U32                                  *taiSelectBmpPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiInputInterfaceGet)
{
     GT_STATUS st;
    GT_U8 devNum;
    CPSS_DXCH_PTP_TAI_PIN_SELECT_ENT        pinId;
    CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_ENT    interfaceType;
    GT_U32  taiSelectBmp;

    pinId = CPSS_DXCH_PTP_TAI_PIN_SELECT_A_E;
    interfaceType = CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_CLOCK_E;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E );

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {

        /*
            1.1 Call with non-null taiSelectPtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpTaiInputInterfaceGet(devNum,pinId,interfaceType,&taiSelectBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call api with wrong taiSelectBmpPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTaiInputInterfaceGet(devNum,pinId,interfaceType,NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);

          /*
            1.3. Call api with wrong state.
            Expected: GT_BAD_PARAM.
        */
        pinId = CPSS_DXCH_PTP_TAI_PIN_SELECT_NONE_E;
        interfaceType = CPSS_DXCH_PTP_TAI_INTERFACE_TYPE_PULSE_E;
        taiSelectBmp = 0x1F;
        st = cpssDxChPtpTaiInputInterfaceSet(devNum,pinId,interfaceType,taiSelectBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);

    }

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E );

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiInputInterfaceGet(devNum,pinId,interfaceType,&taiSelectBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiInputInterfaceGet(devNum,pinId,interfaceType,&taiSelectBmp);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiTodCounterFunctionGroupTriggerSet
(
    IN GT_U8                                    devNum,
    IN  GT_U32                                  taiSelectBmp
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiTodCounterFunctionGroupTriggerSet)
{
    GT_U8   dev;
    GT_STATUS st = GT_OK;
    CPSS_DXCH_PTP_TAI_ID_STC tai_id;
    GT_BOOL valid;
    GT_U32 index,taiSelectBmp;
    CPSS_DXCH_PTP_TOD_COUNT_STC           todValue;
    CPSS_DXCH_PTP_TOD_COUNT_STC           lastTodValue[2];
    GT_U32  iter,iterMax = 3;
    GT_U32  testedPort = 48;
    GT_BOOL startSecondRound;
    GT_BOOL diffOk;
    GT_U32 isPtpMgr=0;  /* whether system working mode is in PTP Manager mode or Legacy mode*/
    CPSS_DXCH_PTP_MANAGER_TAI_OUTPUT_INTERFACE_STC   outputInterfaceConf;
    CPSS_DXCH_PTP_MANAGER_PTP_OVER_ETHERNET_STC         ptpOverEthernetConf;
    CPSS_DXCH_PTP_MANAGER_PTP_OVER_IP_UDP_STC               ptpOverIpUdpConf;
    CPSS_DXCH_PTP_TS_TAG_GLOBAL_CFG_STC                             ptpTsTagGlobalConf;
    CPSS_NET_RX_CPU_CODE_ENT                         cpuCode = CPSS_NET_FIRST_USER_DEFINED_E;

    cpssOsMemSet(&outputInterfaceConf,0, sizeof(outputInterfaceConf));
    cpssOsMemSet(&ptpOverEthernetConf,0, sizeof(ptpOverEthernetConf));
    cpssOsMemSet(&ptpOverIpUdpConf,0, sizeof(ptpOverIpUdpConf));
    cpssOsMemSet(&ptpTsTagGlobalConf,0, sizeof(ptpTsTagGlobalConf));

    /* there is no TAI in GM */
    GM_NOT_SUPPORT_THIS_TEST_MAC;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_IRONMAN_L_E );

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {

        if((prvWrAppDbEntryGet("ptpMgr", &isPtpMgr) == GT_OK) && (isPtpMgr != 0))
        {
            /* all the init sequence is done using PTP Manager */
            /* set default setting */
            outputInterfaceConf.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;

            st = cpssDxChPtpManagerPtpInit(dev,&outputInterfaceConf,&ptpOverEthernetConf,&ptpOverIpUdpConf,&ptpTsTagGlobalConf,cpuCode);
            UTF_VERIFY_EQUAL0_STRING_MAC(GT_OK, st,"cpssDxChPtpManagerPtpInit");
        }

        startSecondRound = GT_FALSE;

        startSecondRound_lbl:

        for (iter = 0 ; iter < iterMax ; iter++)
        {
            /* Initialize TAI structure */
            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            tai_id.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;
            tai_id.portNum = testedPort;

            st = cpssDxChPtpTodCounterFunctionSet(dev,
                            CPSS_PORT_DIRECTION_RX_E,
                            &tai_id,
                            CPSS_DXCH_PTP_TOD_COUNTER_FUNC_CAPTURE_E);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            taiSelectBmp = 8; /* TAI 3 */

            /* trigger capture 0 */
            st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerSet(dev,taiSelectBmp);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* do diff between the triggers */
            cpssOsTimerWkAfter(1);

            /* trigger capture 1 */
            st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerSet(dev,taiSelectBmp);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* Check capture status, read valid values of both TAI capture regs (0 & 1) */
            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            tai_id.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_3_E;
            for (index = 0; index < 2; index++)
            {
                st = cpssDxChPtpTaiTodCaptureStatusGet(dev, &tai_id, index, &valid);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, valid, dev);

                /* on last iteration do not 'get' the TOD ... so the both TODs are 'valid' */
                if((iter + 1) < iterMax)
                {
                    st = cpssDxChPtpTaiTodGet(dev,&tai_id,
                                CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE0_E + index,
                                &todValue);

                    lastTodValue[index] = todValue;/* save the value */

                    cpssOsPrintf("taiInstance[%d] , taiNumber[%d], index[%d] , nanoSeconds = [%d] , seconds = [%d][%d] , fracNanoSeconds = [%d] \n",
                        tai_id.taiInstance,
                        tai_id.taiNumber,
                        index,
                        todValue.nanoSeconds,
                        todValue.seconds.l[1],
                        todValue.seconds.l[0],
                        todValue.fracNanoSeconds
                    );

                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                                                tai_id.taiNumber,index);

                    st = cpssDxChPtpTaiTodCaptureStatusGet(dev, &tai_id, index, &valid);
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                    /* we read the counter ... the valid must be now 'not valid'*/
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_FALSE, valid, dev);
                }
            }

            /* do diff between the triggers */
            cpssOsTimerWkAfter(1);
        }

        if (startSecondRound == GT_FALSE)
        {
            /* check that trigger capture without 'read' of previous captured TOD
               not update the TOD */
            st = cpssDxChPtpTaiCaptureOverrideEnableSet(dev, &tai_id, GT_FALSE);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                                tai_id.taiNumber);

            /* Initialize TAI structure */
            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            tai_id.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_3_E;
            tai_id.portNum = testedPort;

            taiSelectBmp = 8; /* TAI 3 */

            /* trigger capture 0 */
            st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerSet(dev,taiSelectBmp);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            tai_id.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_3_E;
            for (index = 0; index < 2; index++)
            {
                st = cpssDxChPtpTaiTodCaptureStatusGet(dev, &tai_id, index, &valid);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, valid, dev);

                st = cpssDxChPtpTaiTodGet(dev,&tai_id,
                            CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE0_E + index,
                            &todValue);
                cpssOsPrintf("taiInstance[%d] , taiNumber[%d], index[%d] , nanoSeconds = [%d] , seconds = [%d][%d] , fracNanoSeconds = [%d] \n",
                    tai_id.taiInstance,
                    tai_id.taiNumber,
                    index,
                    todValue.nanoSeconds,
                    todValue.seconds.l[1],
                    todValue.seconds.l[0],
                    todValue.fracNanoSeconds
                );
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                                            tai_id.taiNumber,index);

                /* check that the capture 0,1 values did not changed more than 1000 milli from 'last time' */
                diffOk = todValueCompareWithTolerance(
                    &todValue,
                    &lastTodValue[index],
                    1000);/*1000 mili*/
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, diffOk, dev);
            }

            startSecondRound = GT_TRUE;

            /* do iterations to fill the TOD capture iwth valid values that are not read*/
            goto startSecondRound_lbl;
        }

        /* Skip this section for emulator - performance reason */
        if (!cpssDeviceRunCheck_onEmulator())
        {
            /* this is 'secondRound' */

            /* do 'big' diff between the triggers , from those of previous triggers */
            cpssOsTimerWkAfter(1000);

            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            tai_id.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_3_E;

            /* allow the capture to override 'capture' 0 */
            st = cpssDxChPtpTaiCaptureOverrideEnableSet(dev, &tai_id, GT_TRUE);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                                tai_id.taiNumber);

            /* do diff between the triggers */
            cpssOsTimerWkAfter(1);

            /* Initialize TAI structure */
            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
            tai_id.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_3_E;
            tai_id.portNum = testedPort;

            taiSelectBmp = 8; /* TAI 3 */

            /* trigger capture 0 */
            st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerSet(dev,taiSelectBmp);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* do diff between the triggers */
            cpssOsTimerWkAfter(1);

            /* trigger capture 1 */
            st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerSet(dev,taiSelectBmp);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;
            for (index = 0; index < 2; index++)
            {
                st = cpssDxChPtpTaiTodCaptureStatusGet(dev, &tai_id, index, &valid);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, valid, dev);

                st = cpssDxChPtpTaiTodGet(dev,&tai_id,
                            CPSS_DXCH_PTP_TAI_TOD_TYPE_CAPTURE_VALUE0_E + index,
                            &todValue);
                cpssOsPrintf("taiInstance[%d] , taiNumber[%d], index[%d] , nanoSeconds = [%d] , seconds = [%d][%d] , fracNanoSeconds = [%d] \n",
                    tai_id.taiInstance,
                    tai_id.taiNumber,
                    index,
                    todValue.nanoSeconds,
                    todValue.seconds.l[1],
                    todValue.seconds.l[0],
                    todValue.fracNanoSeconds
                );
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                                            tai_id.taiNumber,index);

                if (index == 1)
                {
                    /* check that the capture 1 values did not changed more than 1000 milli from 'last time' */
                    diffOk = todValueCompareWithTolerance(
                        &todValue,
                        &lastTodValue[index],
                        1000);/*1000 mili*/
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, diffOk, dev);
                }
                else
                {
                    /* check that the capture 0 values changed
                        more than 1000 milli from 'last time'
                        but less than 1100 milli */
                    diffOk = todValueCompareWithTolerance(
                        &todValue,
                        &lastTodValue[index],
                        1000);/*1000 mili*/
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_FALSE, diffOk, dev);

                    diffOk = todValueCompareWithTolerance(
                        &todValue,
                        &lastTodValue[index],
                        1100);/*1100 mili*/
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_TRUE, diffOk, dev);
                }
            }
        }

        /* restore default */
        tai_id.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_PORT_E;

        /* allow the capture to override 'capture' 0 */
        st = cpssDxChPtpTaiCaptureOverrideEnableSet(dev, &tai_id, GT_FALSE);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, tai_id.taiInstance,
                            tai_id.taiNumber);
    }


    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_IRONMAN_L_E );

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerSet(dev,taiSelectBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* Call function with out of bound value for device id.*/
    st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerSet(PRV_CPSS_MAX_PP_DEVICES_CNS,taiSelectBmp);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, PRV_CPSS_MAX_PP_DEVICES_CNS);

    /* Call function with out of bound value for taiSelectBmp */
    st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerSet(dev,0xFFFF);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, PRV_CPSS_MAX_PP_DEVICES_CNS);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPtpTaiTodCounterFunctionGroupTriggerGet
(
    IN  GT_U8                                   devNum,
    OUT GT_U32                              *taiSelectBmpPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPtpTaiTodCounterFunctionGroupTriggerGet)
{
     GT_STATUS st;
    GT_U8 devNum;
    GT_U32  taiSelectBmp;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E );

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_TRUE))
    {

        /*
            1.1 Call with non-null taiSelectPtr
            Expected: GT_OK.
        */
        st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerGet(devNum,&taiSelectBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, devNum);

        /*
            1.2 Call api with wrong taiSelectBmpPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerGet(devNum,NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, devNum);
    }

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&devNum, UTF_IRONMAN_L_E );

    /* 2. Go over all non-applicable devices.*/
    while(GT_OK == prvUtfNextDeviceGet(&devNum, GT_FALSE))
    {
        st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerGet(devNum,&taiSelectBmp);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, devNum);
    }

    /* 3. Call function with out of bound value for device id.*/
    devNum = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPtpTaiTodCounterFunctionGroupTriggerGet(devNum,&taiSelectBmp);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, devNum);
}

/*----------------------------------------------------------------------------*/
/*
 * Configuration of cpssDxChPtp suit
 */
UTF_SUIT_BEGIN_TESTS_MAC(cpssDxChPtp)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiTodCounterFunctionAllTriggerSet) /* functional test and must be first */
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpCpuCodeBaseGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpCpuCodeBaseSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpEtherTypeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpEtherTypeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpMessageTypeCmdGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpMessageTypeCmdSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTodCounterFunctionGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTodCounterFunctionSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTodCounterFunctionTriggerSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpUdpDestPortsGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpUdpDestPortsSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiCaptureOverrideEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiCaptureOverrideEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockCycleGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockCycleSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiExternalPulseWidthGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiExternalPulseWidthSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiFractionalNanosecondDriftGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiFractionalNanosecondDriftSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiIncomingClockCounterGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiIncomingClockCounterSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiIncomingTriggerCounterGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiIncomingTriggerCounterSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiInputTriggersCountEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiInputTriggersCountEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiInternalClockGenerateEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiInternalClockGenerateEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiOutputTriggerEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiOutputTriggerEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPClkCycleGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPClkCycleSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPClkDriftAdjustEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPClkDriftAdjustEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiTodCaptureStatusGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiTodGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiTodSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiTodStepGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiTodStepSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiTodUpdateCounterGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiGracefulStepSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiGracefulStepGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayEgressAsymmetryCorrectionGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayEgressAsymmetryCorrectionSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayEgressCorrFieldPiggybackEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayEgressPipeDelayGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayEgressPipeDelaySet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayEgressTimeCorrTaiSelectModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayEgressTimestampTaiSelectGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayEgressTimestampTaiSelectSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayIngressCorrFieldPiggybackEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayIngressPortDelayGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayIngressPortDelaySet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayIngressLinkDelaySet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDelayIngressLinkDelayGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsTagGlobalCfgGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsTagGlobalCfgSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsTagPortCfgGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsTagPortCfgSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuControlGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuControlSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuCountersClear)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuNtpTimeOffsetGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuPacketCounterGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuTxTimestampQueueRead)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsCfgTableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsCfgTableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsLocalActionTableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsLocalActionTableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsUdpChecksumUpdateModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsUdpChecksumUpdateModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpOverEthernetEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpOverEthernetEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpOverUdpEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpOverUdpEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpDomainModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpDomainModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpDomainV1IdSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpDomainV1IdGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpDomainV2IdSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpDomainV2IdGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpEgressDomainTableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpEgressDomainTableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpIngressExceptionCfgSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpIngressExceptionCfgGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpIngressPacketCheckingModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpIngressPacketCheckingModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpIngressExceptionCounterGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpEgressExceptionCfgSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpEgressExceptionCfgGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpEgressExceptionCountersGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsIngressTimestampQueueEntryRead)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsEgressTimestampQueueEntryRead)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsMessageTypeToQueueIdMapSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsMessageTypeToQueueIdMapGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsQueuesSizeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsQueuesSizeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDebugQueuesEntryIdsClear)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsDebugQueuesEntryIdsGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsNtpTimeOffsetSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsNtpTimeOffsetGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPtpPulseInterfaceSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPtpPulseInterfaceGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPClkInterfaceSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPClkInterfaceGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPClkOutputInterfaceSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPClkOutputInterfaceGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiInputClockSelectSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiInputClockSelectGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpPortUnitResetSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpPortUnitResetGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpPortTxPipeStatusDelaySet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpPortTxPipeStatusDelayGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPulseInModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPulseInModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiCapturePreviousModeEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiCapturePreviousModeEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPClkSelectionModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiPClkSelectionModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockGenerationModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockGenerationModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockReceptionModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockReceptionModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockGenerationEdgeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockGenerationEdgeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockReceptionEdgeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiClockReceptionEdgeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuTimeStampMaskingProfileSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuTimeStampMaskingProfileGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuTSFrameCounterControlSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuTSFrameCounterControlGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuTsFrameCounterIndexSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpUBitModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpUBitModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpPLLBypassEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpPLLBypassEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuBypassEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuBypassEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTsuEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpRxTaiSelectGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpRxTaiSelectSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTodCounterFunctionTriggerStatusGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpRefClockSourceSelectSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpRefClockSourceSelectGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpNonPtpPacketTaiSelectSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpNonPtpPacketTaiSelectGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiOutputInterfaceSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiOutputInterfaceGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiInputInterfaceSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiInputInterfaceGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiTodCounterFunctionGroupTriggerSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPtpTaiTodCounterFunctionGroupTriggerGet)
UTF_SUIT_END_TESTS_MAC(cpssDxChPtp)



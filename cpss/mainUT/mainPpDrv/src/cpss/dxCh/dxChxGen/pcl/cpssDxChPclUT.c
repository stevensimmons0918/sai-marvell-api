/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
*/
/**
********************************************************************************
* @file cpssDxChPclUT.c
*
* @brief Unit tests for cpssDxChPcl.
*
* @version   86
********************************************************************************
*/
/* includes */
/* the define of UT_FIXED_PORT_TO_SUPPORT_U32_TYPE_MAC must come from C files that
   already fixed the types of ports from GT_U8 !

   NOTE: must come before ANY include to H files !!!!
*/
#define UT_FIXED_PORT_TO_SUPPORT_U32_TYPE_MAC

#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChInfo.h>
#include <cpss/dxCh/dxChxGen/pcl/cpssDxChPcl.h>
#include <cpss/dxCh/dxChxGen/pcl/private/prvCpssDxChPcl.h>
#include <cpss/dxCh/dxChxGen/tcam/cpssDxChTcam.h>
#include <cpss/dxCh/dxChxGen/tcam/private/prvCpssDxChTcam.h>

#include <utf/utfMain.h>
#include <utf/private/prvUtfExtras.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDb.h>
#include <cpss/common/private/globalShared/prvCpssGlobalDbInterface.h>

static GT_U8    currentTestedDevNum = 0;
static CPSS_PORTS_BMP_STC   testedPortListBmpMask = {{
     0x5555aaaa , 0xa5a5a5a , 0x5a5a5a5a , 0x55aa55aa,
#if CPSS_MAX_PORTS_NUM_CNS > 128
     0xaaaa5555 , 0xaaa555a , 0x555aaa55 , 0xaa55aa55
#endif
     }};


/* defines */

#define MAX_TUNNEL_PTR(dev)                         \
    (PRV_CPSS_DXCH_PP_MAC(dev)->fineTuning.tableSize.tunnelStart)

#define MAX_FLOW_ID(dev)                            \
    (PRV_CPSS_SIP_6_10_CHECK_MAC(dev) ? BIT_16 :    \
     PRV_CPSS_SIP_5_20_CHECK_MAC(dev) ? BIT_13 :    \
     BIT_12)

#define MAX_EPORT(dev)                              \
    (PRV_CPSS_SIP_5_20_CHECK_MAC(dev) ? BIT_14 :    \
     BIT_13)

#define MAX_ARP_PTR(dev)                            \
     (MAX_TUNNEL_PTR(dev) << 2)

#define SUPPORT_TCAM_SEGMENT_MODE_MAC(dev) \
    ((PRV_CPSS_SIP_5_CHECK_MAC(dev) && !PRV_CPSS_SIP_5_20_CHECK_MAC(dev)) ? 1 : 0)


static CPSS_PORTS_BMP_STC sip5Support28PortsInPortListBmp = {{0x0FFFFFFF/*0..27*/,0/*28..511*/}};

/* fill bmp of ports */
#define PORTS_BMP_FILL_MAC(field)       \
        if(GT_FALSE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(currentTestedDevNum)) \
        {   /*copy BMP*/                                                    \
            field = PRV_CPSS_PP_MAC(currentTestedDevNum)->existingPorts;    \
        }                                                                   \
        else                                                                \
        {   /*copy BMP*/                                                    \
            field = sip5Support28PortsInPortListBmp;                        \
        }                                                                   \
        if(PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(currentTestedDevNum))   \
        {                                                                   \
            /* add CPU port */                                              \
            CPSS_PORTS_BMP_PORT_SET_MAC(&field,CPSS_CPU_PORT_NUM_CNS);      \
        }                                                                   \
        if(fullFill == GT_FALSE)                                            \
        {                                                                   \
            CPSS_PORTS_BMP_BITWISE_AND_MAC(&field,                          \
                                           &field,                          \
                                           &testedPortListBmpMask);         \
        }

/* Invalid enum */
#define PCL_INVALID_ENUM_CNS    0x5AAAAAA5

#define PCL_TCAM_RAWS(_dev)                                           \
    ((_dev >= PRV_CPSS_MAX_PP_DEVICES_CNS) ? 64 :                     \
    PRV_CPSS_DXCH_PP_MAC(_dev)->fineTuning.tableSize.policyTcamRaws)

/* Valid value for Rule index that is used in tests                 */
/* for CH1 and CH2 policyTcamRaws == 512 - amount of exteded rule   */
/* so such index is invalid for exteded rules and must be decreased */
#define PCL_TESTED_RULE_INDEX_MAC(_dev)                                                                             \
    (((_dev < PRV_CPSS_MAX_PP_DEVICES_CNS) && (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(_dev) == GT_TRUE)) ?   \
     (PCL_TCAM_RAWS(_dev) - 36) :                                                                                \
     (PCL_TCAM_RAWS(_dev) - 32))

/* Invalid value for Rule index for std rule format */
#define PCL_INVALID_STD_RULE_INDEX(_dev)  \
     (((UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(_dev) == GT_TRUE)) ?   \
     (PCL_TCAM_RAWS(_dev) ):                                                                        \
     (PCL_TCAM_RAWS(_dev) * 4))

/* Invalid value for Rule index for extended rule format */
#define PCL_INVALID_EXT_RULE_INDEX(_dev)  \
     (((UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(_dev) == GT_TRUE)) ?   \
     (PCL_TCAM_RAWS(_dev) ):                                                                        \
     (PCL_TCAM_RAWS(_dev) * 2))

/* valid indexes for specific Copy and Status testing rules */
#define PCL_CORRECT_STD_RULE_INDEX_MAC(_dev) (PCL_TESTED_RULE_INDEX_MAC(_dev))
#define PCL_CORRECT_EXT_RULE_INDEX_MAC(_dev)                                                                        \
    (((_dev < PRV_CPSS_MAX_PP_DEVICES_CNS) && (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(_dev) == GT_TRUE)) ?   \
     (PCL_TESTED_RULE_INDEX_MAC(_dev) + 6) :                                                                        \
     (PCL_TESTED_RULE_INDEX_MAC(_dev) + 4))
#define PCL_DAMAGED_STD_RULE_INDEX_MAC(_dev)                                                                        \
    (((_dev < PRV_CPSS_MAX_PP_DEVICES_CNS) && (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(_dev) == GT_TRUE)) ?   \
     (PCL_TESTED_RULE_INDEX_MAC(_dev) + 0xC) :                                                                      \
     (PCL_TESTED_RULE_INDEX_MAC(_dev) + 8))
#define PCL_DAMAGED_EXT_RULE_INDEX_MAC(_dev)                                                                        \
    (((_dev < PRV_CPSS_MAX_PP_DEVICES_CNS) && (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(_dev) == GT_TRUE)) ?   \
     (PCL_TESTED_RULE_INDEX_MAC(_dev) + 0x12) :                                                                     \
     (PCL_TESTED_RULE_INDEX_MAC(_dev) + 12))


/* Tests use this value as default valid value for port */
#define DXCH_PCL_VALID_PHY_PORT_CNS 0

/* Tests use this value as out-of-range value for vlanId */
#define PRV_CPSS_MAX_NUM_VLANS_CNS  4096

/* Macro to operate with bitmaps larger than 32 bits*/
#define BMP_SUMM_AND(bmp1, bmp2){                                          \
    bmp1[0] &= bmp2[0]; bmp1[1] &= bmp2[1];}
#define BMP_SUMM_NAND(bmp1, bmp2){                                         \
     bmp1[0] &= ~bmp2[0]; bmp1[1] &= ~bmp2[1];}

#define BMP_FIND(value, bmp)                                               \
    ((value > 31)? (bmp[1] & (1 << (value - 32))):                         \
                   (bmp[0] & (1 << value)))

#define BMP_COMPARE(bmp1, bmp2)                                            \
    ((bmp1[0] & bmp2[0]) || (bmp1[1] & bmp2[1]))

/* macro to check that device supports 'range' of physical ports rather then only 'existing physical ports' */
#define IS_E_ARCH_AND_PHYSICAL_PORT_IN_RANGE_MAC(_dev,_port)   \
    (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(_dev) && ((_port) <= (UTF_CPSS_PP_MAX_PHYSICAL_PORTS_NUM_CNS(_dev)-1)))

#define PRV_CPSS_DXCH_PCL_UDBS_NUM_MAC(dev, isEgr) ((GT_TRUE == (isEgr)) ? \
    (PRV_CPSS_SIP_6_10_CHECK_MAC(dev)? 60 : 50) : (PRV_CPSS_SIP_5_20_CHECK_MAC(dev)? 70 : 50))

/*  Internal function. Is used for filling PCL action structure     */
/*  with default values which are used for most of all tests.       */
static void pclActionDefaultSet(IN CPSS_DXCH_PCL_ACTION_STC  *actionPtr);

/*  Internal function. Is used to set rule for testing.             */
/*  Set default values for structures and call cpssDxChPclRuleSet.  */
/*  Returns result of  cpssDxChPclRuleSet function.                 */
static GT_STATUS pclRuleTestingDefaultSet(IN GT_U8  dev);

/*  Internal function. Is used to set rule for testing.             */
static GT_STATUS pclRuleOverride
(
    IN GT_U8     dev,
    IN GT_BOOL   oldRuleExt,
    IN GT_BOOL   newRuleExt,
    IN GT_BOOL   valid,
    IN GT_U32    oldRuleIndex
);

/* writes 4 rules to TCAM                                     */
/* correctStdRuleIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev); */
/* correctExtRuleIndex = PCL_CORRECT_EXT_RULE_INDEX_MAC(dev); */
/* damagedStdRuleIndex = PCL_DAMAGED_STD_RULE_INDEX_MAC(dev); */
/* damagedExtRuleIndex = PCL_DAMAGED_EXT_RULE_INDEX_MAC(dev); */
static GT_STATUS pclRulesForCopyAndStatusTesting
(
    IN GT_U8     dev
);

/* help function for Rule Get testing                         */
/* Fill Mask and pattern of the rule                          */
/* All Port Group depended fields bypassed.                   */
/* All muxed fields bypassed.                                 */
/* All other fields get values:                               */
/* mask - maxvalues for all fields                            */
/* pattern:                                                   */
/* patternIndex == 0 - 1 for all fields                       */
/* patternIndex == 1 - (maxValue - 1) for all fields          */
/* patternIndex == 2 - (maxValue & byte index) for all fields */
/* patternIndex == 3 - relevant to multi-port group device
                       the srcPort field is tested for
                       mask.srcPort = 0..max
                       pattern.srcPort = changed */
static GT_VOID pclRuleTestFill
(
    IN  GT_U8                              devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat,
    IN  GT_U32                             patternIndex,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT      *maskPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT      *patternPtr,
    IN  GT_BOOL                            usePortsBmp,
    IN  GT_U32                             iterationIndex

);

static GT_VOID pclRuleStructureTestFill
(
    IN GT_U8    dev,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat,
    IN  GT_U32                            fullFill,
    IN  GT_U32                            ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT     *rulePtr
);
static GT_VOID add_bmp_value
(
    IN GT_U32  *bmp,
    IN GT_U32  value
);
static GT_U32 bitcount
(
    IN GT_U32  value
);

/* rule flags definitions                       */
/* xCat valid-bit in egress rules */
#define PRV_RF_EGR_VALID_CNS              BIT_0
/* ingress source port field bypass for Lion and Lion2A */
#define PRV_RF_NO_INGR_SRC_PORT_CNS       BIT_1
/* Lion2B physical and eArch field sizes */
#define PRV_RF_SIP5_CNS                  BIT_2

/* rule with 2-bit ingess l2Encap */
#define PRV_RF_2BIT_L2ENCAP_CNS           BIT_4
/* test with ports bitmap */
#define PRV_RF_USE_PORTS_BMP_CNS          BIT_5

/*set ruleFlags according to : usePortsBmp */
#define RULE_FLAGS_SET_MAC(devNum,ruleFlags,usePortsBmp)                        \
    {                                                                           \
        ruleFlags = 0;                                                          \
        if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(devNum))                       \
        {                                                                       \
            ruleFlags |= PRV_RF_EGR_VALID_CNS;                                  \
        }                                                                       \
        else                                                                    \
        if(PRV_CPSS_PP_MAC(devNum)->devFamily >= CPSS_PP_FAMILY_DXCH_XCAT2_E)   \
        {                                                                       \
            ruleFlags |= PRV_RF_2BIT_L2ENCAP_CNS;                               \
                                                                                \
            if(usePortsBmp)                                                     \
            {                                                                   \
                ruleFlags |= PRV_RF_USE_PORTS_BMP_CNS;                          \
            }                                                                   \
                                                                                \
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)      \
            {                                                                   \
                ruleFlags |= PRV_RF_SIP5_CNS;                                   \
            }                                                                   \
        }                                                                       \
    }

static GT_U32 mainUtCpssDxChPclTcamIndex = 0;
void mainUtCpssDxChPclTcamIndexSet(GT_U32 tcamIndex)
{
    mainUtCpssDxChPclTcamIndex = tcamIndex;
}


/* get port belogs to port group */
#define UTF_GET_PORT_FOR_PORT_GROUP_MAC(_portGroup) ((_portGroup) << 4)

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclUserDefinedByteSet
(
    IN GT_U8                                devNum,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN CPSS_PCL_DIRECTION_ENT               direction,
    IN GT_U32                               udbIndex,
    IN CPSS_DXCH_PCL_OFFSET_TYPE_ENT        offsetType,
    IN GT_U8                                offset
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclUserDefinedByteSet)
{
/*
    ITERATE_DEVICES
    1.1. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E],
                   direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                   udbIndex   [0],
                   offsetType [CPSS_DXCH_PCL_OFFSET_L2_E],
                   offset     [5].
    Expected: GT_OK for all type of devices.
    1.2. Call with ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E], udbIndex [1],
         offsetType [CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E], offset [5].
    Expected: GT_OK for ch/ch2/ch3 devices, GT_BAD_PARAM for others.
    1.3. Call with ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E], udbIndex [2],
         offsetType [CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E], offset [5].
    Expected: GT_OK for ch/ch2/ch3 devices, GT_BAD_PARAM for others.
    1.4. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E],
         udbIndex [5], offsetType [CPSS_DXCH_PCL_OFFSET_L3_E], offset [5]
         and wrong enum values packetType.
    Expected: GT_OK for 98DX2x3 devices, GT_BAD_PARAM for others.
    1.5. Call with ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E], udbIndex [2],
         offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
    Expected: GT_OK for 98DX2x5 (Cheetah2) devices, NON GT_OK for others.
    1.6. Call with ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E], udbIndex [0],
         offsetType [CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E], offset [5].
    Expected: GT_OK for Cheetah2 and above devices, NOT GT_OK for ch1.
    1.7. Call with out of range enum value packetType and
        direction[CPSS_PCL_DIRECTION_INGRESS_E].
    Expected: GT_BAD_PARAM for xCat and above, GT_OK for others.
    1.8. Call with out of range enum value packetType and
        direction[CPSS_PCL_DIRECTION_EGRESS_E].
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3, GT_BAD_PARAM for xCat and above, GT_OK for others.
    1.9. Call with out of range enum value direction.
    Expected: GT_BAD_PARAM  for Bobcat2; Caelum; Bobcat3, GT_OK for others.
    1.10. Check for invalid udbIndex. Call with
         ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
         udbIndex [2 for all dev families and 23 for xCat and above],
         offsetType [CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
    Expected: NON GT_OK.
    1.11. Check for invalid udbIndex. Call with
         ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E],
         udbIndex [6], offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
    Expected: NON GT_OK.
    1.12. Check for invalid offsetType. Call with
    ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
    udbIndex [0], offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
    Expected: NON GT_OK.
    1.13. Check for invalid offsetType. Call with
    ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
    udbIndex [2], offsetType [CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
    Expected: NON GT_OK.
    1.14. Check out-of-range ruleFormat. Call with ruleFormat [wrong enum values],
          udbIndex [0], offsetType[CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
    Expected: GT_BAD_PARAM for ch, ch2, ch3 and GT_OK for xCat and above.
    1.15. Check out-of-range offsetType. Call with
          offsetType [wrong enum values], other params same as in 1.1.
    Expected: GT_BAD_PARAM.
    1.16. Check for big value for offset. Call with offset [0xFE] and other
          parameters the same as in 1.1.
    Expected: GT_OUT_OF_RANGE.
    1.17. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_TCP_E],
                   direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                   udbIndex   [8],
                   offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E],
                   offset     [62].
    Expected: GT_OK for eArch devices.
              GT_BAD_PARAM for other devices
    1.18. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_TCP_E],
                   direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                   udbIndex   [7],
                   offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E],
                   offset     [63].
    Expected: GT_OUT_OF_RANGE for eArch devices.
              GT_BAD_PARAM for other devices
    1.19. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_UDP_E],
                   direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                   udbIndex   [6],
                   offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E],
                   offset     [18].
    Expected: GT_OK for eArch devices.
              GT_BAD_PARAM for other devices
    1.20. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_UDP_E],
                   direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                   udbIndex   [5],
                   offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E],
                   offset     [63].
    Expected: GT_OUT_OF_RANGE for eArch devices.
              GT_BAD_PARAM for other devices
    1.21. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_OTHER_E],
                   direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                   udbIndex   [4],
                   offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E],
                   offset     [56].
    Expected: GT_OK for eArch devices.
              GT_BAD_PARAM for other devices
    1.22. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_OTHER_E],
                   direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                   udbIndex   [3],
                   offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E],
                   offset     [57].
    Expected: GT_OUT_OF_RANGE for eArch devices.
              GT_BAD_PARAM for other devices
    1.23. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_UDE5_E],
                   direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                   udbIndex   [2],
                   offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E],
                   offset     [64].
    Expected: GT_OK for eArch devices.
              GT_BAD_PARAM for other devices
    1.24. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_UDE5_E],
                   direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                   udbIndex   [1],
                   offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E],
                   offset     [65].
    Expected: GT_OUT_OF_RANGE for eArch devices.
              GT_BAD_PARAM for other devices
    1.25. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_UDE6_E],
                   direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                   udbIndex   [49],
                   offsetType [CPSS_DXCH_PCL_OFFSET_METADATA_E],
                   offset     [127].
    Expected: GT_OK for eArch devices.
              GT_BAD_PARAM for other devices
    1.26. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_UDE6_E],
                   direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                   udbIndex   [40],
                   offsetType [CPSS_DXCH_PCL_OFFSET_METADATA_E],
                   offset     [128].
    Expected: GT_OUT_OF_RANGE for eArch devices.
              GT_BAD_PARAM for other devices
    1.27. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E],
                   direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                   udbIndex   [30],
                   offsetType [CPSS_DXCH_PCL_OFFSET_METADATA_E],
                   offset     [255].
    Expected: GT_OK for eArch devices.
              GT_OUT_OF_RANGE for other devices
    1.28. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                   packetType [CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E],
                   direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                   udbIndex   [29],
                   offsetType [CPSS_DXCH_PCL_OFFSET_METADATA_E],
                   offset     [100].
    Expected: GT_BAD_PARAM for eArch devices.
              GT_BAD_PARAM for other devices
*/
    GT_STATUS                           st = GT_OK;
    GT_U8                               dev;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat;
    CPSS_DXCH_PCL_PACKET_TYPE_ENT       packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;
    CPSS_PCL_DIRECTION_ENT              direction;
    GT_U32                              udbIndex;
    CPSS_DXCH_PCL_OFFSET_TYPE_ENT       offsetType;
    GT_U8                               offset;

    CPSS_DXCH_PCL_OFFSET_TYPE_ENT       offsetTypeGet;
    GT_U8                               offsetGet;
    CPSS_PP_FAMILY_TYPE_ENT             devFamily;
    CPSS_PP_DEVICE_TYPE                 devType;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

        st = prvUtfDeviceTypeGet(dev, &devType);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceTypeGet: %d", dev);

        /*
            1.1. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E],
                           direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                           udbIndex   [0],
                           offsetType [CPSS_DXCH_PCL_OFFSET_L2_E],
                           offset     [5].
            Expected: GT_OK for all type of devices.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        udbIndex   = 0;
        offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
        offset     = 5;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                     offsetType, offset);

        if(st == GT_OK)
        {
            /* verifying values */
            st = cpssDxChPclUserDefinedByteGet(
                dev, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

            UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offsetType than was set: dev = %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offset than was set: dev = %d", dev);
        }

        /*
            1.2. Call with ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E], udbIndex [1],
                 offsetType [CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E], offset [5].
            Expected: GT_OK for ch/ch2/ch3 devices, GT_BAD_PARAM for others.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
        udbIndex   = 1;
        offsetType = CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E;
        offset     = 5;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        }

        if(st == GT_OK)
        {
            /* verifying values */
            st = cpssDxChPclUserDefinedByteGet(
                dev, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

            UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offsetType than was set: dev = %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset,     offsetGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offset than was set: dev = %d", dev);
        }

        /*
            1.3. Call with ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E], udbIndex [2],
                 offsetType [CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E], offset [5].
            Expected: GT_OK for ch/ch2/ch3 devices, GT_BAD_PARAM for others.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E;
        udbIndex   = 2;
        offsetType = CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E;
        offset     = 5;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        }

        if(st == GT_OK)
        {
            /* verifying values */
            st = cpssDxChPclUserDefinedByteGet(
                dev, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

            UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offsetType than was set: dev = %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset,     offsetGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offset than was set: dev = %d", dev);
        }

        /*
            1.4. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E],
                 udbIndex [5], offsetType [CPSS_DXCH_PCL_OFFSET_L3_E], offset [5]
                 and wrong enum values packetType.
            Expected: GT_OK for 98DX2x3 devices, GT_BAD_PARAM for others.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E;
        udbIndex   = 5;
        offsetType = CPSS_DXCH_PCL_OFFSET_L3_E;
        offset     = 5;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclUserDefinedByteSet
                            (dev, ruleFormat, packetType, direction,
                             udbIndex, offsetType, offset),
                            packetType);

        /*
            1.5. Call with ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E], udbIndex [2],
                 offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
            Expected: GT_OK for 98DX2x5 (Cheetah2) devices, NON GT_OK for others.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
        udbIndex   = 2;
        offsetType = CPSS_DXCH_PCL_OFFSET_L4_E;
        offset     = 5;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                    offsetType, offset);
        if(st == GT_OK)
        {
            /* verifying values */
            st = cpssDxChPclUserDefinedByteGet(
                dev, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

            UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offsetType than was set: dev = %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset,     offsetGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offset than was set: dev = %d", dev);
        }
        /*
            1.6. Call with ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E], udbIndex [0],
                 offsetType [CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E], offset [5].
            Expected: GT_OK for Cheetah2 and above devices, NOT GT_OK for ch1.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
        udbIndex   = 0;
        offsetType = CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E;
        offset     = 5; /* offset is ignored for TCP_UDP_COMPARATOR */

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /* TCP_UDP_COMPARATOR is not supported as anchor */
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                            offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);

            /* verifying values */
            st = cpssDxChPclUserDefinedByteGet(
                dev, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

            UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offsetType than was set: dev = %d", dev);
        }

        /*
            1.7. Call with out of range enum value packetType and
                direction[CPSS_PCL_DIRECTION_INGRESS_E].
            Expected: GT_BAD_PARAM for xCat and above, GT_OK for others.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        udbIndex   = 0;
        offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
        offset     = 5;
        packetType = 0x5AAAAAA5;

        st = cpssDxChPclUserDefinedByteSet(dev, ruleFormat, packetType, direction,
                                           udbIndex, offsetType, offset);

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {

            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        }

        /* restore prvious value */
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;

        /*
            1.8. Call with out of range enum value packetType and
                direction[CPSS_PCL_DIRECTION_EGRESS_E].
            Expected: GT_OK for Bobcat2; Caelum; Bobcat3, GT_BAD_PARAM for xCat and above, GT_OK for others.
        */
        direction  = CPSS_PCL_DIRECTION_EGRESS_E;
        packetType = 0x5AAAAAA5;

        st = cpssDxChPclUserDefinedByteSet(dev, ruleFormat, packetType, direction,
                                           udbIndex, offsetType, offset);

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {

            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        }

        /* restore prvious value */
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;

        /*
            1.9. Call with out of range enum value direction.
            Expected: GT_BAD_PARAM  for Bobcat2; Caelum; Bobcat3, GT_OK for others.
        */
        direction  = 0x5AAAAAA5;

        st = cpssDxChPclUserDefinedByteSet(dev, ruleFormat, packetType, direction,
                                           udbIndex, offsetType, offset);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        }

        /* restore prvious value */
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;

        /*
            1.10. Check for invalid udbIndex. Call with
                 ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                 udbIndex [2 for all dev families and 23 for xCat and above],
                 offsetType [CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
            Expected: NON GT_OK.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
        udbIndex   = 2;
        offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
        offset     = 5;

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {
            udbIndex = 23;
        }

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) != GT_FALSE)
        {
            udbIndex = PRV_CPSS_DXCH_PCL_UDBS_NUM_MAC(dev, CPSS_PCL_DIRECTION_EGRESS_E == direction);
        }

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);
        UTF_VERIFY_NOT_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        /*
            1.11. Check for invalid udbIndex. Call with
                 ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E],
                 udbIndex [6], offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
            Expected: NON GT_OK.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E;
        udbIndex   = 6;
        offsetType = CPSS_DXCH_PCL_OFFSET_L4_E;
        offset     = 5;

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {
            offsetType = CPSS_DXCH_PCL_OFFSET_L3_E;
        }

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);
        UTF_VERIFY_NOT_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        /*
            1.12. Check for invalid offsetType. Call with
            ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
            udbIndex [0], offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
            Expected: NON GT_OK.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        udbIndex   = 0;
        offsetType = CPSS_DXCH_PCL_OFFSET_L4_E;
        offset     = 5;

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {
            offsetType = CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E;
        }

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);
        UTF_VERIFY_NOT_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        /*
            1.13. Check for invalid offsetType. Call with
            ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
            udbIndex [2], offsetType [CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
            Expected: NON GT_OK.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
        udbIndex   = 2;
        offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
        offset     = 5;

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {
            /* to cause "BAD_PARAM", for XCat the key type ignored */
            offsetType = CPSS_DXCH_PCL_OFFSET_L3_E;
        }

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);
        UTF_VERIFY_NOT_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        /*
            1.14. Check out-of-range ruleFormat. Call with ruleFormat [wrong enum values],
                  udbIndex [0], offsetType[CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
            Expected: GT_BAD_PARAM for ch, ch2, ch3 and GT_OK for xCat and above.
        */
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;
        udbIndex   = 0;
        offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
        offset     = 5;

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {
            /* to cause "BAD_PARAM", for XCat the key type ignored */
            offsetType = CPSS_DXCH_PCL_OFFSET_L3_E;
        }

        UTF_ENUMS_CHECK_MAC(cpssDxChPclUserDefinedByteSet
                            (dev, ruleFormat, packetType,
                             direction,
                             udbIndex, offsetType, offset),
                            ruleFormat);

        /*
            1.15. Check out-of-range offsetType. Call with
                  offsetType [wrong enum values], other params same as in 1.1.
            Expected: GT_BAD_PARAM.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        udbIndex   = 0;
        offset     = 5;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclUserDefinedByteSet
                            (dev, ruleFormat, packetType,
                             direction,
                             udbIndex, offsetType, offset),
                            offsetType);

        /*
            1.16. Check for big value for offset. Call with offset [0xFE] and other
                  parameters the same as in 1.1.
            Expected: GT_OUT_OF_RANGE.
        */
        offset     = 0xFE;
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        udbIndex   = 0;
        offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, ruleFormat, udbIndex,
                                    offsetType, offset);
        /*
            1.17. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_TCP_E],
                           direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                           udbIndex   [8],
                           offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E],
                           offset     [62].
            Expected: GT_OK for eArch devices.
                      GT_BAD_PARAM for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV6_TCP_E;
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        udbIndex   = 8;
        offsetType = CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E;
        offset     = 62;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }

        if(st == GT_OK)
        {
            /* verifying values */
            st = cpssDxChPclUserDefinedByteGet(
                dev, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

            UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offsetType than was set: dev = %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offset than was set: dev = %d", dev);
        }

        /*
            1.18. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_TCP_E],
                           direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                           udbIndex   [7],
                           offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E],
                           offset     [63].
            Expected: GT_OUT_OF_RANGE for eArch devices.
                      GT_BAD_PARAM for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV6_TCP_E;
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        udbIndex   = 7;
        offsetType = CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E;
        offset     = 63;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        /*
            1.19. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_UDP_E],
                           direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                           udbIndex   [6],
                           offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E],
                           offset     [18].
            Expected: GT_OK for eArch devices.
                      GT_BAD_PARAM for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV6_UDP_E;
        direction  = CPSS_PCL_DIRECTION_EGRESS_E;
        udbIndex   = 6;
        offsetType = CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E;
        offset     = 18;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }

        if(st == GT_OK)
        {
            /* verifying values */
            st = cpssDxChPclUserDefinedByteGet(
                dev, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

            UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offsetType than was set: dev = %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offset than was set: dev = %d", dev);
        }

        /*
            1.20. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_UDP_E],
                           direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                           udbIndex   [5],
                           offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E],
                           offset     [63].
            Expected: GT_OUT_OF_RANGE for eArch devices.
                      GT_BAD_PARAM for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV6_UDP_E;
        direction  = CPSS_PCL_DIRECTION_EGRESS_E;
        udbIndex   = 5;
        offsetType = CPSS_DXCH_PCL_OFFSET_TUNNEL_L2_E;
        offset     = 19;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }

        /*
            1.21. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_OTHER_E],
                           direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                           udbIndex   [4],
                           offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E],
                           offset     [56].
            Expected: GT_OK for eArch devices.
                      GT_BAD_PARAM for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV6_OTHER_E;
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        udbIndex   = 4;
        offsetType = CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E;
        offset     = 56;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }

        if(st == GT_OK)
        {
            /* verifying values */
            st = cpssDxChPclUserDefinedByteGet(
                dev, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

            UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offsetType than was set: dev = %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offset than was set: dev = %d", dev);
        }

        /*
            1.22. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_OTHER_E],
                           direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                           udbIndex   [3],
                           offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E],
                           offset     [57].
            Expected: GT_OUT_OF_RANGE for eArch devices.
                      GT_BAD_PARAM for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV6_OTHER_E;
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        udbIndex   = 3;
        offsetType = CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E;
        offset     = 57;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        /*
            1.23. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_UDE5_E],
                           direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                           udbIndex   [2],
                           offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E],
                           offset     [64].
            Expected: GT_OK for eArch devices.
                      GT_BAD_PARAM for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_UDE5_E;
        direction  = CPSS_PCL_DIRECTION_EGRESS_E;
        udbIndex   = 2;
        offsetType = CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E;
        offset     = 64;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }

        if(st == GT_OK)
        {
            /* verifying values */
            st = cpssDxChPclUserDefinedByteGet(
                dev, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

            UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offsetType than was set: dev = %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offset than was set: dev = %d", dev);
        }

        /*
            1.24. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_UDE5_E],
                           direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                           udbIndex   [1],
                           offsetType [CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E],
                           offset     [65].
            Expected: GT_OUT_OF_RANGE for eArch devices.
                      GT_BAD_PARAM for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_UDE5_E;
        direction  = CPSS_PCL_DIRECTION_EGRESS_E;
        udbIndex   = 1;
        offsetType = CPSS_DXCH_PCL_OFFSET_TUNNEL_L3_MINUS_2_E;
        offset     = 65;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }

        /*
            1.25. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_UDE6_E],
                           direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                           udbIndex   [49],
                           offsetType [CPSS_DXCH_PCL_OFFSET_METADATA_E],
                           offset     [127].
            Expected: GT_OK for eArch devices.
                      GT_BAD_PARAM for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_UDE6_E;
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        udbIndex   = 49;
        offsetType = CPSS_DXCH_PCL_OFFSET_METADATA_E;
        offset     = 127;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }

        if(st == GT_OK)
        {
            /* verifying values */
            st = cpssDxChPclUserDefinedByteGet(
                dev, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

            UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offsetType than was set: dev = %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offset than was set: dev = %d", dev);
        }

        /*
            1.26. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_UDE6_E],
                           direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                           udbIndex   [40],
                           offsetType [CPSS_DXCH_PCL_OFFSET_METADATA_E],
                           offset     [128].
            Expected: GT_OUT_OF_RANGE for eArch devices.
                      GT_BAD_PARAM for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_UDE6_E;
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        udbIndex   = 40;
        offsetType = CPSS_DXCH_PCL_OFFSET_METADATA_E;
        offset     = 128;
        if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
        {
            offset     = 179;
        }
        else if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
        {
            offset     = 160;
        }

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, ruleFormat, udbIndex,
                                     offsetType, offset);
        /*
            1.27. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E],
                           direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                           udbIndex   [30],
                           offsetType [CPSS_DXCH_PCL_OFFSET_METADATA_E],
                           offset     [255].
            Expected: GT_OK for eArch devices.
                      GT_OUT_OF_RANGE for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;
        direction  = CPSS_PCL_DIRECTION_EGRESS_E;
        udbIndex   = 30;
        offsetType = CPSS_DXCH_PCL_OFFSET_METADATA_E;
        offset     = 255;
        if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
        {
            offset     = 116;
        }
        else if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
        {
            offset     = 101;
        }

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }
        else
        {
            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, ruleFormat, udbIndex,
                                         offsetType, offset);
        }

        if(st == GT_OK)
        {
            /* verifying values */
            st = cpssDxChPclUserDefinedByteGet(
                dev, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

            UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offsetType than was set: dev = %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                 "cpssDxChPclUserDefinedByteGet: "
                 "get another offset than was set: dev = %d", dev);
        }

        /*
            1.28. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                           packetType [CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E],
                           direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                           udbIndex   [29],
                           offsetType [CPSS_DXCH_PCL_OFFSET_METADATA_E],
                           offset     [100].
            Expected: GT_BAD_PARAM for eArch devices.
                      GT_BAD_PARAM for other devices
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        udbIndex   = 29;
        offsetType = CPSS_DXCH_PCL_OFFSET_METADATA_E;
        offset     = 100;

        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);

        UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                     offsetType, offset);

        /* set valid parameters */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        udbIndex   = 0;
        offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
        offset = 5;
    }

    /* set correct values for all the parameters (except of device number) */
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;
    direction  = CPSS_PCL_DIRECTION_INGRESS_E;
    udbIndex   = 0;
    offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
    offset     = 5;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. Call function for non active device and valid parameters.*/
        /*  Expected: GT_BAD_PARAM.  */
        st = cpssDxChPclUserDefinedByteSet(
            dev, ruleFormat, packetType, direction,
            udbIndex, offsetType, offset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclUserDefinedByteSet(
        dev, ruleFormat, packetType, direction,
        udbIndex, offsetType, offset);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclRuleSet
(
    IN GT_U8                              devNum,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat,
    IN GT_U32                             ruleIndex,
    IN CPSS_DXCH_PCL_RULE_OPTION_ENT      ruleOptionsBmp,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT      *maskPtr,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT      *patternPtr,
    IN CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclRuleSet)
{
/*
    ITERATE_DEVICES
    1.1. Check standard rule for all active devices with legal parameters.
    Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
    ruleIndex [PCL_TESTED_RULE_INDEX],
    maskPtr->ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ...],
    patternPtr-> ruleStdNotIp [ common[pclId=0;
                                        sourcePort=5;
                                        isTagged=1;
                                        vid=100;
                                        up=0;
                                        qosProfile=0;
                                        isIp=0;
                                        isL2Valid=1;
                                        isUdbValid =1],
                                isIpv4 = 0;
                                etherType=0;
                                isArp=0;
                                l2Encap=0;
                                macDa=AB:CD:EF:00:00:02;
                                macSa=AB:CD:EF:00:00:01;
                                udb[10,20,30] ],
    actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
                mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
                matchCounter { enableMatchCount = GT_FALSE,
                               matchCounterIndex = 0 },
                qos { egressPolicy=GT_FALSE,
                      modifyDscp=GT_FALSE,
                      modifyUp=GT_FALSE ,
                      qos [ ingress[profileIndex=0,
                            profileAssignIndex=GT_FALSE,
                            profilePrecedence=GT_FALSE] ] },
                redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                           data[routerLttIndex=0] },
                policer  { policerEnable=GT_FALSE,
                           policerId=0 },
                vlan { egressTaggedModify=GT_FALSE,
                       modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E,
                       nestedVlan=GT_FALSE,
                       vlanId=100,
                       precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
                ipUcRoute { doIpUcRoute=GT_FALSE,
                            0, GT_FALSE, GT_FALSE, GT_FALSE } ].

    Expected: GT_OK.
    1.2. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], valid
        actionPtr->flowId[100](is relevant) and other params same as 1.1.
    Expected: GT_OK.
    1.3. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
        actionPtr->oam.offsetIndex[15], actionPtr->oam.oamProcessEnable[GT_TRUE],
        actionPtr->oam.oamProfile[1] and other params same as 1.1.
    Expected: GT_OK.

    1.4. Check for out of range ruleIndex. Other parameters is the same as in 1.1.
    Expected: NON GT_OK.
    1.5. Call with out of range actionPtr->matchCounter.matchCounterIndex [32]
       and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for other.
        1.4. For Ch3 and above call with out of range
        actionPtr->matchCounter.matchCounterIndex [16384] and other params from 1.1.
        Expected: NOT GT_OK.
    1.6. Call with out of range actionPtr->policer.policerId [policersTableSize],
    action->policer.policerEnable [CPSS_DXCH_PCL_POLICER_ENABLE_METER_AND_COUNTER_E]
    and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for other.
    1.7. Call with actionPtr->redirect.redirectCmd
                        [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                   actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                   out of range actionPtr->redirect.outIf.tunnelPtr[1024]
                   and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.
    1.8. For Ch3 and above call with actionPtr->redirect.redirectCmd
             [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                       actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                       out of range actionPtr->redirect.outIf.tunnelPtr[8192]
                       and other params from 1.1.
    Expected: NOT GT_OK.
    1.9. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                   out of range actionPtr->redirect.data.routerLttIndex[8192]
    and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2/ch3.
    1.10. For Ch3 and above call with
                actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                       out of range actionPtr->redirect.data.routerLttIndex[32768]
                       and other params from 1.1.
    Expected: NOT GT_OK.
    1.11. For Ch3 and above call with actionPtr->redirect.redirectCmd
          [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E],
                   out of range actionPtr->redirect.data.vrfId [4096]
                   and other params from 1.1.
    Expected: NOT GT_OK.
    1.12. Call with actionPtr->vlan.ingress.modifyVlan [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
                   out of range actionPtr->vlan.ingress.vlanId [4096]
                   and other params from 1.1.
    Expected: NOT GT_OK.
    1.13. For Ch3 and above call with out of range
    actionPtr->sourceId.sourceIdValue [32] and other params from 1.1.
    Expected: NOT GT_OK.
    1.14. Call with out of range actionPtr->pktCmd
    Expected: GT_BAD_PARAM
    1.15. Call with not valid actionPtr->pktCmd
                                  [CPSS_PACKET_CMD_ROUTE_E
                                   CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E
                                   CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E
                                   CPSS_PACKET_CMD_BRIDGE_E ]
    Expected: NOT GT_OK
    1.16. Call with out of range actionPtr->lookupConfig.pcl0_1OverrideConfigIndex,
          other parameters is the same as in 1.1.
    Expected: GT_BAD_PARAM for DxCh3 and above
    1.17. Call with out of range actionPtr->lookupConfig.pcl1OverrideConfigIndex,
          other parameters is the same as in 1.1.
    Expected: GT_BAD_PARAM
    1.18. Call with out of range actionPtr->mirror.cpuCode
    Expected: GT_BAD_PARAM
    1.19. Call with out of range actionPtr->mirror.ingressMirrorToAnalyzerIndex[7 / 8] (relevant for Lion2)
    Expected: NOT GT_OK for Lion2 and GT_OK for others.
    1.20. Call with out of range actionPtr->qos.ingress.modifyDscp
    Expected: GT_BAD_PARAM
    1.21. Call with out of range actionPtr->qos.ingress.modifyUp
    Expected: GT_BAD_PARAM
    1.22. Call with out of range actionPtr->qos.ingress.profileIndex
                [72] for DxCh1
                [256] for Lion2
                [128] for others -- DxCh2, DxCh3, xCat, Lion, xCat2
    Expected: NOT GT_OK
    1.23. Call with valid actionPtr->qos.ingress.profileIndex
                [0 / 15 / 36 / 71] for DxCh1
                [0 / / 45 / 64 / 127 ] for DxCh2, DxCh3, xCat, Lion, xCat2
                [0 / 127 / 128 / 255] for Lion2
    Expected: GT_OK
    1.24. Call with out of range actionPtr->qos.ingress.up1Cmd
          relevant for lion2.
    Expected: GT_BAD_PARAM
    1.25. Call with out of range actionPtr->qos.ingress.up1 [8]
          relevant for lion2.
    Expected: NOT GT_OK and GT_OK for others.
    1.26. Call with out of range actionPtr->qos.egress.modifyUp
    Expected: GT_BAD_PARAM.
    1.27. Call with actionPtr->vlan.ingress.modifyVlan [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
           out of range actionPtr->vlan.ingress.vlanId1 [4096]
           and other params from 1.1.
    Expected: NOT GT_OK.
    1.28. Call with actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE],
          out of range actionPtr->ipUcRoute.arpDaIndex [1024]
          and other params from 1.1.
    Expected: NOT GT_OK.
    1.29. Call with relevant actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE],
           out of range actionPtr->ipUcRoute.arpDaIndex [0 / 512 / 1023]
           and other params from 1.1.
    Expected: NOT GT_OK.
    1.30. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_TRUE], out of range
        actionPtr->flowId[0x10000](not relevant) and other params same as 1.1.
    Expected: GT_OK.
    1.31. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], out of range
        actionPtr->flowId[0x10000](is relevant) and other params same as 1.1.
    Expected: NOT GT_OK.
    1.32. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
        actionPtr->oam.oamProcessEnable[GT_TRUE],
        actionPtr->oam.oamProfile[1], out of range actionPtr->oam.offsetIndex[16],
        and other params same as 1.1.
    Expected: NOT GT_OK.
    1.33. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
        actionPtr->oam.oamProcessEnable[GT_TRUE],
        actionPtr->oam.offsetIndex[15], out of range actionPtr->oam.oamProfile[2],
        and other params same as 1.1.
    Expected: NOT GT_OK.
    1.34. Call with maskPtr [NULL], other parameters is the same as in 1.1.
    Expected: GT_BAD_PTR.
    1.35. Call with patternPtr [NULL], other parameters is the same as in 1.1.
    Expected: GT_BAD_PTR.
    1.36. Call with actionPtr [NULL], other parameters is the same as in 1.1.
    Expected: GT_BAD_PTR.
    1.37. Call with ruleFormat [wrong enum values],
    other parameters is the same as in 1.1.
    Expected: GT_BAD_PARAM.
    1.38.  call cpssDxChPclRuleInvalidate
    with ruleSize [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX]
    to cleanup after testing.
    Expected: GT_OK.
    1.39. Check extended rule. For all active device ids call with
        ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E],
        ruleIndex [511],
        maskPtr->ruleExtNotIpv6.common is the same as in 1.1., other fileds are zeroed,
        patternPtr->ruleExtNotIpv6 [ common[the same as in 1.1],
        commonExt[ isIpv6=0, ipProtocol=1, dscp=0, isL4Valid=1, l4Byte0=0, l4Byte1=0,
                    l4Byte2=0, l4Byte3=0, l4Byte13=0, ipHeaderOk=1 ],
        sip={ 64.233.167.1},
        dip={ 213.180.204.1},
        etherType=0,
        l2Encap=1,
        macDa=AB:CD:EF:00:00:02,
        macSa=AB:CD:EF:00:00:01,
        ipv4Fragmented=1,
        udb[6]={10,20,30,40,50,60} ],
        actionPtr is the same as in 1.1.
    Expected: GT_OK.
    1.40. Check for out of range ruleIndex for extended rule format.
    Call with wrong ruleIndex, other parameters is the same as 1.8.
    Expected: NON GT_OK.
    1.41. Check for out of range ruleIndex for standard rule format.
    Call with wrong ruleIndex, other parameters is the same as 1.8.
    Expected: NON GT_OK.
    1.42.  call cpssDxChPclRuleInvalidate
    with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], ruleIndex [511]
    to cleanup after testing.
    Expected: GT_OK.
    1.43. Check standard EGRESS rule for all active devices with legal parameters.
    Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
    ruleIndex [PCL_TESTED_RULE_INDEX],
    maskPtr->ruleEgrStdNotIp [0xFF, ..., 0xFF],
    patternPtr->ruleEgrStdNotIp
            [ common[pclId=0; sourcePort=5; isTagged=1; vid=100; up=0;
              isIp=0; isL2Valid =1;  egrPacketType=0; cpuCode=1;srcTrg=1;
              srcDev = 10; sourceId = 1; isVidx=0; others -zeroid],
    isIpv4 = 0;
    etherType=0;
    isArp=0;
    l2Encap=0;
    macDa=AB:CD:EF:00:00:02;
    macSa=AB:CD:EF:00:00:01],
    actionPtr - the same as in 1.1.
    Expected: GT_OK for all except ch1.
        1.44. For all devices except ch1 call cpssDxChPclRuleInvalidate with
        ruleSize [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX]
        to cleanup after testing.
        Expected: GT_OK.
    1.45. Check extended EGRESS rule for all active devices with legal parameters.
    Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E],
    ruleIndex [511],
    maskPtr-> ruleEgrExtIpv6L2 [0xFF, ..., 0xFF],
    patternPtr-> ruleEgrExtIpv6L2 [common [pclId=0; sourcePort=5;
        isTagged=1; vid=100; up=0; isIp=1; isL2Valid =1;  egrPacketType=0;
        cpuCode=1;srcTrg=1; srcDev = 10; sourceId = 1; isVidx=0; others -zeroid],
        commonExt [isIpv6=1; ipProtocol=1; dscp=2; isL4Valid=0;
                    egrTcpUdpPortComparator=0; others- theroid]
        sip[100; 1000; 10000; 100000];
        dipBits127to120=0xAA;
        macDa=AB:CD:EF:00:00:02;
        macSa=AB:CD:EF:00:00:01],
        actionPtr - the same as in 1.1.
    Expected: GT_OK for all except ch1.
    1.46. For all devices except ch1 call cpssDxChPclRuleInvalidate
        with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E] to cleanup after testing.
        Expected: GT_OK.
    1.47. Call with ruleOptionsBmp [CPSS_DXCH_PCL_RULE_OPTION_KEY_EXTENSION_ENABLED_E],
                and other params as in 1.23.
    Expected: GT_OK for Lion2.
    1.48. Call function with
            actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[0 / 3 / 6]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_REPLACE_MAC_SA_E],
                           data { modifyMacSa {macSa [00:00:00:00:00:00 /
                                                      A5:A5:A5:A5:A5:A5 /
                                                      FF:FF:FF:FF:FF:FF],
                                               arpPtr[0 / 0xA5A5 / BIT_17-1]}}},
                        oam { timeStampEnable [GT_FALSE / GT_TRUE],
                              offsetIndex [0 / 0xA / BIT_4-1],
                              oamProcessEnable [GT_FALSE / GT_TRUE],
                              oamProfile [0 / 1] },
                        sourcePort { assignSourcePortEnable [GT_FALSE / GT_TRUE]
                                 sourcePortValue [0 / 0xA5A5A5A5 / 0xFFFFFFFF] }
                        qos { ingress { up1Cmd[
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_DO_NOT_MODIFY_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG1_UNTAGGED_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG0_UNTAGGED_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_ALL_E],
                                       up1[0 / 5 / BIT_3-1]} }
                        vlan { ingress { vlanId1Cmd[
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_DO_NOT_MODIFY_E /
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_UNTAGGED_E /
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_ALL_E],
                                       vlanId1 [0 / 0xA5A / BIT_12-1]} },
                        flowId [0 / 0xA5A / BIT_12-1],
                        setMacToMe [GT_FALSE / GT_TRUE] }
            and other params from 1.1.
    Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
    1.49. Call function with out of range ingressMirrorToAnalyzerIndex [7]
           and other parameters from 1.48.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.50. Call function with out of range redirectCmd
           and other parameters from 1.48.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.51. Call function with out of range offsetIndex [BIT_4]
           and other parameters from 1.48.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.52. Call function with out of range oamProfile [2]
           and other parameters from 1.48.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.53. Call function with out of range up1Cmd
           and other parameters from 1.48.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.54. Call function with out of range up1 [BIT_3]
           and other parameters from 1.48.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.55. Call function with out of range vlanId1Cmd
           and other parameters from 1.48.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.56. Call function with out of range vlanId1 [BIT_12]
           and other parameters from 1.48.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.57. Call function with out of range flowId [BIT_12]
           and other parameters from 1.48.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.58. Call function with out of range sourcePortValue [BIT_13]
           and other parameters from 1.48.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.59. Call function with out of range arpPtr [BIT_17]
           and other parameters from 1.48.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.60. Call function with
            actionPtr { egressPolicy [GT_TRUE]
                        qos { egress { modifyDscp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_OUTER_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_INNER_E],
                                      modifyUp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                      up1ModifyEnable [GT_FALSE / GT_TRUE],
                                      up1[0 / 5 / BIT_3-1]} }
                        vlan { egress { vlanCmd[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                       vlanId1ModifyEnable [GT_FALSE / GT_TRUE],
                                       vlanId1 [0 / 0xA5A / BIT_12-1]} },
                        channelTypeToOpcodeMapEnable [GT_FALSE / GT_TRUE],
                        tmQueueId [0 / 0x2A5A / BIT_14-1] }
            and other params from 1.48.
    Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
    1.61. Call function with out of range modifyDscp
           and other parameters from 1.60.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.62. Call function with out of range modifyUp
           and other parameters from 1.60.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.63. Call function with out of range up1 [BIT_3]
           and other parameters from 1.60.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.64. Call function with out of range vlanCmd
           and other parameters from 1.60.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.65. Call function with out of range vlanId1 [BIT_12]
           and other parameters from 1.60.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.66. Call function with out of range tmQueueId [BIT_14]
           and other parameters from 1.60.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.67. Call function with
                    ruleFormatArr [],
                    udb [10,20,30,40,...].
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.68. Call function with out of range isIpv6ExtHdrExist
          ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.69. Call function with out of range isIpv6HopByHop
          ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.70. Call function with out of range isIpv6ExtHdrExist
          ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.71. Call function with out of range isIpv6HopByHop
          ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.72. Call function with vrfId [0xA5A / BIT_12-1], isUdbValid [0]
          ruleFormat
           [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.73. Call function with out of range isUdbValid [2]
          ruleFormat
           [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.74. Call function with tag1Exist [0],
                             vid1 [0 / BIT_12-1],
                             up1 [0 / 7],
                             cfi1 [0],
                             vrfId [0xA5A / BIT_12-1],
                             trunkHash [0 / BIT_6-1]
          ruleFormat
           [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.75. Call function with out of range tag1Exist [2],
                                          vid1 [BIT_12],
                                          up1 [8],
                                          cfi1 [2],
                                          trunkHash [BIT_6]
          ruleFormat
           [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.76. Call function with tag1Exist [0],
                             vid1 [0 / BIT_12-1],
                             up1 [0 / 7],
                             cfi1 [0],
                             vrfId [0xA5A / BIT_12-1],
                             trunkHash [0 / BIT_6-1],
                             srcPortOrTrunk [0xA5A / BIT_13-1],
                             srcIsTrunk [0]
          ruleFormat
          [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.77. Call function with out of range tag1Exist [2],
                                          vid1 [BIT_12],
                                          up1 [8],
                                          cfi1 [2],
                                          trunkHash [BIT_6],
                                          srcIsTrunk [2]
          ruleFormat
          [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.78. Call function with tag1Exist [0],
                             vid1 [0 / BIT_12-1],
                             up1 [0 / 7],
                             cfi1 [0],
                             vrfId [0xA5A / BIT_12-1],
                             trunkHash [0 / BIT_6-1],
                             srcPortOrTrunk [0xA5A / BIT_13-1],
                             srcIsTrunk [0]
          ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.79. Call function with out of range tag1Exist [2],
                                          vid1 [BIT_12],
                                          up1 [8],
                                          cfi1 [2],
                                          trunkHash [BIT_6],
                                          srcIsTrunk [2]
          ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.80. Call function with vid1 [0 / BIT_12-1],
                             up1 [0 / 7],
                             cfi1 [0]
          ruleFormat
               [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.81. Call function with out of range vid1 [BIT_12],
                                          up1 [8],
                                          cfi1 [2]
          ruleFormat
               [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.82. Call function with egressIpCommon.tag1Exist [0],
                             egressIpCommon.sourceId [10 / BIT_12-1],
                             vid1 [0 / BIT_12-1],
                             up1 [0 / 7],
                             cfi1 [0],
                             srcPort [0xA5A / BIT_13-1],
                             trgPort [0 / BIT_13-1]
          ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.83. Call function with out of range egressIpCommon.tag1Exist [2],
                                       egressIpCommon.sourceId [BIT_12],
                                          vid1 [BIT_12],
                                          up1 [8],
                                          cfi1 [2],
                                          srcPort [BIT_13],
                                          trgPort [BIT_13],
          ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.84. Call function with out of range udb60FixedFld.
                 isUdbValid [BIT_1]
                 pclId [BIT_10]
                 vid [BIT_13]
                 srcPort [BIT_13]
                 srcDevIsOwn [BIT_1]
                 vid1 [BIT_12]
                 up1 [BIT_3]
                 macToMe [BIT_1]
                 qosProfile [BIT_10]
                 flowId [BIT_12]
          ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.85. Call function with out of range udb60FixedFld.
                     pclId [BIT_10]
                     isUdbValid [BIT_1]
                     vid [BIT_13]
                     srcPort [BIT_13]
                     trgPort [BIT_13]
                     srcDev [BIT_10]
                     trgDev [BIT_10]
                     localDevTrgPhyPort [BIT_8]
          ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.86. Call function with
            action{
                redirect {
                   redirectCmd [
                    CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                   data {
                       logicalSourceInterface{
                           logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                             devPort {devNum=dev, portNum=0} ]
                           sourceMeshIdSetEnable[GT_TRUE/GT_FALSE]
                           sourceMeshId[0/1/3]
                           userTagAcEnable[GT_TRUE/GT_FALSE]
                       }}},
                unknownSaCommandEnable[GT_TRUE/GT_FALSE]
                unknownSaCommand[   CPSS_PACKET_CMD_FORWARD_E /
                                    CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                    CPSS_PACKET_CMD_TRAP_TO_CPU_E /
                                    CPSS_PACKET_CMD_DROP_HARD_E /
                                    CPSS_PACKET_CMD_DROP_SOFT_E /
                                    CPSS_PACKET_CMD_ROUTE_E /
                                    CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E /
                                    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E /
                                    CPSS_PACKET_CMD_BRIDGE_E /
                                    CPSS_PACKET_CMD_NONE_E /
                                    CPSS_PACKET_CMD_LOOPBACK_E]}
            and other parameters from 1.67.
    Expected: GT_OK  for xCat C0; xCat3.

    1.87. Call function with out of range sourceMeshId [4]
           and other parameters from 1.67.
    Expected: GT_OK  for xCat C0; xCat3.

    1.88. Call function with out of range unknownSaCommand
           and other parameters from 1.67.
    Expected: GT_OK  for xCat C0; xCat3.

    1.89. For bobCat2 and above, call cpssDxChPclRuleSet with
                  ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                  ruleIndex [PCL_TESTED_RULE_INDEX],
                  ruleOptionsBmp[CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E];
                  mask.ruleStdNotIp.common.pclId = 0x3FF,
                  pattern.ruleStdNotIp.common.pclId = 0,
                  action.copyReserved.assignEnable = GT_TRUE,
                  action.copyReserved.copyReserved = 0x15A and
                  get the value of the action from the same index using
                  cpssDxChPclRuleActionGet. Check for same value of actions
            Expected: GT_OK and same values of actions

    1.90. For Falcon and above, call cpssDxChPclRuleSet with
                  ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                  ruleIndex [PCL_TESTED_RULE_INDEX],
                  ruleOptionsBmp[CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E];
                  mask.ruleStdNotIp.common.pclId = 0x3FF,
                  pattern.ruleStdNotIp.common.pclId = 0,
                  action.triggerHashCncClient = GT_TRUE
                  get the value of the action from the same index using
                  cpssDxChPclRuleActionGet. Check for same value of actions
            Expected: GT_OK and same values of actions

    1.91. Test for PHA actions
                  For Falcon and above, call cpssDxChPclRuleSet with
                  ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                  ruleIndex [PCL_TESTED_RULE_INDEX],
                  ruleOptionsBmp[CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E];
                  mask.ruleStdNotIp.common.pclId = 0x3FF,
                  pattern.ruleStdNotIp.common.pclId = 0,
                  action.triggerHashCncClient = GT_TRUE
                  get the value of the action from the same index using
                  cpssDxChPclRuleActionGet. Check for same value of actions
            Expected: GT_OK and same values of actions

    1.92. For Ironman and above, call cpssDxChPclRuleSet with
                  ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                  ruleIndex [PCL_TESTED_RULE_INDEX],
                  mask.ruleStdNotIp.common.pclId = 0x3FF,
                  pattern.ruleStdNotIp.common.pclId = 0,
                  action.egressPolicy = GT_TRUE;
                  action.egressCncIndexMode = CPSS_DXCH_PCL_ACTION_EGRESS_CNC_INDEX_MODE_MAX_SDU_PASS_FAIL_E;
                  action.egressMaxSduSizeProfile = 0x1;
                  action.enableEgressMaxSduSizeCheck = GT_TRUE;
                  get the value of the actions from the same index using
                  cpssDxChPclRuleActionGet. Check for same value of actions
            Expected: GT_OK and same values of actions
*/
    GT_STATUS       st = GT_OK;
    GT_U32          policersTableSize = 0;

    GT_U8                               dev;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat;
    GT_U32                              ruleIndex;
    CPSS_DXCH_PCL_RULE_OPTION_ENT       ruleOptionsBmp = CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT       mask;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT       pattern;
    CPSS_DXCH_PCL_ACTION_STC            action, actionGet;
    GT_ETHERADDR                        mac1 = {{0xAB, 0xCD, 0xEF, 0x00, 0x00, 0x01}};
    GT_ETHERADDR                        mac2 = {{0xAB, 0xCD, 0xEF, 0x00, 0x00, 0x02}};
    GT_ETHERADDR                        macSa1 = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
    GT_ETHERADDR                        macSa2 = {{0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5}};
    GT_ETHERADDR                        macSa3 = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};
    CPSS_PP_FAMILY_TYPE_ENT             devFamily;
    CPSS_PCL_RULE_SIZE_ENT              ruleSize;
    GT_U32                      ii;
    GT_BOOL                     support_doIpUcRoute;/*indication that current device supports 'doIpUcRoute' */
    GT_U32                      ruleFlags = 0;
    GT_U32                      usePortsBmp = 0;
    CPSS_DXCH_PCL_ACTION_EGRESS_PHA_THREAD_TYPE_ENT phaThrType;

    static CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT        ruleFormatArr[] =
    {
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E,

    };
    GT_U32                              index = 0;
        pclActionDefaultSet(&action);

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,"prvUtfDeviceFamilyGet: %d", dev);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            support_doIpUcRoute = GT_FALSE;
        }
        else
        {
            support_doIpUcRoute = GT_TRUE;
        }

        /* get table sizes for current device */
        st = cpssDxChCfgTableNumEntriesGet(dev,
                    CPSS_DXCH_CFG_TABLE_POLICER_METERS_E, &policersTableSize);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChCfgTableNumEntriesGet: %d", dev);

        /*
            1.1. Check standard rule for all active devices with legal parameters.
            Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
            ruleIndex [PCL_TESTED_RULE_INDEX],
            maskPtr->ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ...],
            patternPtr-> ruleStdNotIp [ common[pclId=0;
                                                sourcePort=5;
                                                isTagged=1;
                                                vid=100;
                                                up=0;
                                                qosProfile=0;
                                                isIp=0;
                                                isL2Valid=1;
                                                isUdbValid =1],
                                        isIpv4 = 0;
                                        etherType=0;
                                        isArp=0;
                                        l2Encap=0;
                                        macDa=AB:CD:EF:00:00:02;
                                        macSa=AB:CD:EF:00:00:01;
                                        udb[10,20,30] ],
            actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
                        mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
                        matchCounter { enableMatchCount = GT_FALSE,
                                       matchCounterIndex = 0 },
                        qos { egressPolicy=GT_FALSE,
                              modifyDscp=GT_FALSE,
                              modifyUp=GT_FALSE ,
                              qos [ ingress[profileIndex=0,
                                    profileAssignIndex=GT_FALSE,
                                    profilePrecedence=GT_FALSE] ] },
                        redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                                   data[routerLttIndex=0] },
                        policer  { policerEnable=GT_FALSE,
                                   policerId=0 },
                        vlan { egressTaggedModify=GT_FALSE,
                               modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E,
                               nestedVlan=GT_FALSE,
                               vlanId=100,
                               precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
                        ipUcRoute { doIpUcRoute=GT_FALSE,
                                    0, GT_FALSE, GT_FALSE, GT_FALSE } ].

            Expected: GT_OK.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
        ruleOptionsBmp = 0;

        cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
        pattern.ruleStdNotIp.common.pclId = 0;
        pattern.ruleStdNotIp.common.sourcePort = 5;
        pattern.ruleStdNotIp.common.isTagged = 1;
        pattern.ruleStdNotIp.common.vid = 100;
        pattern.ruleStdNotIp.common.up = 0;
        pattern.ruleStdNotIp.common.qosProfile = 0;
        pattern.ruleStdNotIp.common.isIp = 0;
        pattern.ruleStdNotIp.common.isL2Valid = 1;
        pattern.ruleStdNotIp.common.isUdbValid = 1;
        pattern.ruleStdNotIp.isIpv4 = 0;
        pattern.ruleStdNotIp.etherType = 0;
        pattern.ruleStdNotIp.isArp = 0;
        pattern.ruleStdNotIp.l2Encap = 0;
        pattern.ruleStdNotIp.macDa = mac2;
        pattern.ruleStdNotIp.macSa = mac1;
        pattern.ruleStdNotIp.udb15_17[0] = 10;
        pattern.ruleStdNotIp.udb15_17[1] = 20;
        pattern.ruleStdNotIp.udb15_17[2] = 30;

        cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
        mask.ruleStdNotIp = pattern.ruleStdNotIp;
        mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/
        mask.ruleStdNotIp.common.sourcePort = 0x3F;
        action.egressPolicy = GT_FALSE;

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

        /*
            1.2. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], valid
                actionPtr->flowId[100](is relevant) and other params same as 1.1.
            Expected: GT_OK.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.egressPolicy = GT_FALSE;
            action.flowId  = 100;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                    ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);

        /*
            1.3. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                actionPtr->oam.offsetIndex[15], actionPtr->oam.oamProcessEnable[GT_TRUE],
                actionPtr->oam.oamProfile[1] and other params same as 1.1.
            Expected: GT_OK.
        */

            action.oam.timeStampEnable = GT_TRUE;
            action.oam.offsetIndex  = 15;
            action.oam.oamProcessEnable = GT_TRUE;
            action.oam.oamProfile = 1;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                    ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);

            /* basic test of <portListBmp> */

            /* reset muxed values */
            pattern.ruleStdNotIp.common.sourcePort = 0;

            mask.ruleStdNotIp.common.pclId = 0x300;/*2 MSbits*/
            mask.ruleStdNotIp.common.sourcePort = 0;/* no bits */

            /* set <portListBmp> values */
            pattern.ruleStdNotIp.common.portListBmp = sip5Support28PortsInPortListBmp;
            pattern.ruleStdNotIp.common.portListBmp.ports[0] &= ~(BIT_5 | BIT_20 | BIT_16);
            mask.ruleStdNotIp.common.portListBmp    = sip5Support28PortsInPortListBmp;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                    ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);


            /* set <portListBmp> 'OUT OF RANGE' values */
            pattern.ruleStdNotIp.common.portListBmp = sip5Support28PortsInPortListBmp;
            pattern.ruleStdNotIp.common.portListBmp.ports[0] |= BIT_28;
            mask.ruleStdNotIp.common.portListBmp    = sip5Support28PortsInPortListBmp;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                    ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            pattern.ruleStdNotIp.common.portListBmp = sip5Support28PortsInPortListBmp;
            mask.ruleStdNotIp.common.portListBmp    = sip5Support28PortsInPortListBmp;
            mask.ruleStdNotIp.common.portListBmp.ports[0] |= BIT_28;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                    ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            pattern.ruleStdNotIp.common.portListBmp = sip5Support28PortsInPortListBmp;
            mask.ruleStdNotIp.common.portListBmp    = sip5Support28PortsInPortListBmp;

            for(ii = 1 ; ii < CPSS_MAX_PORTS_BMP_NUM_CNS ; ii++)
            {
                mask.ruleStdNotIp.common.portListBmp.ports[ii] = 1;/* not ZERO */

                st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                        ruleOptionsBmp, &mask, &pattern, &action);
                UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

                mask.ruleStdNotIp.common.portListBmp.ports[ii] = 0;/* restore */
            }

            /* restore values */
            CPSS_PORTS_BMP_PORT_CLEAR_ALL_MAC(&pattern.ruleStdNotIp.common.portListBmp);
            CPSS_PORTS_BMP_PORT_CLEAR_ALL_MAC(&mask.ruleStdNotIp.common.portListBmp);

            pattern.ruleStdNotIp.common.sourcePort = 5;

            mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/
            mask.ruleStdNotIp.common.sourcePort = 0x3F;
        }

        /*
            1.4. Check for out of range ruleIndex. Other parameters is the same as in 1.1.
            Expected: NON GT_OK.
        */
        ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

        /*
            1.5. Call with out of range actionPtr->matchCounter.matchCounterIndex [32]
               and other params from 1.1.
            Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for other.
        */
        action.matchCounter.enableMatchCount = GT_TRUE;
        action.matchCounter.matchCounterIndex = 32;

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->matchCounter.matchCounterIndex = %d",
                dev, ruleFormat, ruleIndex, action.matchCounter.matchCounterIndex);

        /*
            1.6. For Ch3 and above call with out of range
            actionPtr->matchCounter.matchCounterIndex [16384/32768] and other params from 1.1.
            Expected: NOT GT_OK.
        */
        action.matchCounter.matchCounterIndex = 16384;
        if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
        {
            action.matchCounter.matchCounterIndex = 32768;
        }

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->matchCounter.matchCounterIndex = %d",
                dev, ruleFormat, ruleIndex, action.matchCounter.matchCounterIndex);

        action.matchCounter.matchCounterIndex = 0; /* restore valid value */

        /*
            1.7. Call with out of range actionPtr->policer.policerId [policersTableSize],
            action->policer.policerEnable [CPSS_DXCH_PCL_POLICER_ENABLE_METER_AND_COUNTER_E]
            and other params from 1.1.
            Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for other.
        */
        action.policer.policerEnable = CPSS_DXCH_PCL_POLICER_ENABLE_METER_AND_COUNTER_E;
        /* out of HW field range - real policersTableSize not checked */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.policer.policerId = BIT_16;
        }
        else
        {
            action.policer.policerId = BIT_12;
        }
        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                            "%d, %d, %d, actionPtr->policer.policerId = %d",
                                dev, ruleFormat, ruleIndex, action.policer.policerId);

        action.policer.policerId = 0; /* restore valid value */

        /*
            1.8. Call with actionPtr->redirect.redirectCmd
                                [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                           actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                           out of range actionPtr->redirect.outIf.tunnelPtr[1024]
                           and other params from 1.1.
            Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.
        */
        action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E;
        action.redirect.data.outIf.tunnelStart = GT_TRUE;
        action.redirect.data.outIf.tunnelPtr = MAX_TUNNEL_PTR(dev) - 1;

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern,&action);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->redirect.data.outIf.tunnelPtr = %d",
                dev, ruleFormat, ruleIndex, action.redirect.data.outIf.tunnelPtr);

        /*
            1.9. For Ch3 and above call with actionPtr->redirect.redirectCmd
                 [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                           actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                           out of range actionPtr->redirect.outIf.tunnelPtr[8192]
                           and other params from 1.1.
            Expected: NOT GT_OK.
        */
        action.redirect.data.outIf.tunnelPtr = MAX_TUNNEL_PTR(dev);

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern,&action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->redirect.data.outIf.tunnelPtr = %d",
                    dev, ruleFormat, ruleIndex, action.redirect.data.outIf.tunnelPtr);

        action.redirect.data.outIf.tunnelPtr = 0; /* restore valid value */

        /*
            1.10. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                           out of range actionPtr->redirect.data.routerLttIndex[8192]
            and other params from 1.1.
            Expected: NOT GT_OK for Ch1/Ch2/ch3.
        */
        action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E;
        action.redirect.data.routerLttIndex = BIT_13;

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);

        if ((devFamily <= CPSS_PP_FAMILY_CHEETAH3_E)
            || (devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E))
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                        "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                        dev, ruleFormat, ruleIndex, action.redirect.data.routerLttIndex);
        }
        else
        {
            if ((UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)&&
                (BIT_13>=PRV_CPSS_DXCH_PP_MAC(dev)->moduleCfg.ip.maxNumOfPbrEntries))
            {
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                                                 "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                                                 dev, ruleFormat, ruleIndex, action.redirect.data.routerLttIndex);
            }
            else
            {
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                             "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                                             dev, ruleFormat, ruleIndex, action.redirect.data.routerLttIndex);
            }
            /*
                1.11. For Ch3 and above call with
                        actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                               out of range actionPtr->redirect.data.routerLttIndex[32768]
                               and other params from 1.1.
                Expected: NOT GT_OK.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.redirect.data.routerLttIndex = PRV_CPSS_DXCH_PP_MAC(dev)->moduleCfg.ip.maxNumOfPbrEntries;
            }
            else
            {
                action.redirect.data.routerLttIndex = BIT_15;
            }

            st = cpssDxChPclRuleSet(
                dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                    dev, ruleFormat, ruleIndex, action.redirect.data.routerLttIndex);
        }

        action.redirect.data.routerLttIndex = 0; /* restore valid value */

        /*
            1.12. For Ch3 and above call with actionPtr->redirect.redirectCmd
                  [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E],
                           out of range actionPtr->redirect.data.vrfId [4096]
                           and other params from 1.1.
            Expected: NOT GT_OK.
        */
        if ((devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
            && (devFamily != CPSS_PP_FAMILY_DXCH_XCAT2_E))
        {
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E;
            action.redirect.data.vrfId = BIT_12;

            st = cpssDxChPclRuleSet(
                dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                            "%d, %d, %d, actionPtr->redirect.data.vrfId= %d",
                            dev, ruleFormat, ruleIndex, action.redirect.data.vrfId);

            action.redirect.data.vrfId = 0; /* restore valid value */
        }

        if (devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
        {
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E;
        }

        /*
            1.13. Call with actionPtr->vlan.ingress.modifyVlan [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
                           out of range actionPtr->vlan.ingress.vlanId [4096]
                           and other params from 1.1.
            Expected: NOT GT_OK.
        */
        action.vlan.ingress.modifyVlan = CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E;
        action.vlan.ingress.vlanId = UTF_CPSS_PP_MAX_VLAN_NUM_CNS(dev);

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->vlan.ingress.vlanId = %d",
                                         dev, ruleFormat, ruleIndex, action.vlan.ingress.vlanId);

        action.vlan.ingress.vlanId = 100; /* restore valid value */

        /*
            1.14. For Ch3 and above call with out of range
            actionPtr->sourceId.sourceIdValue [32] and other params from 1.1.
            Expected: NOT GT_OK.
        */
        if(devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
        {
            action.sourceId.assignSourceId = GT_TRUE;
            action.sourceId.sourceIdValue = UTF_CPSS_PP_MAX_SRC_ID_NUM_MAC(dev);

            st = cpssDxChPclRuleSet(
                dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                                "%d, %d, %d, actionPtr->sourceId.sourceIdValue = %d",
                                dev, ruleFormat, ruleIndex, action.sourceId.sourceIdValue);

            action.sourceId.sourceIdValue = 0; /* restore valid value */
        }

        /*
            1.15. Call with out of range actionPtr->pktCmd
            Expected: GT_BAD_PARAM
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet(
                            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action),
                            action.pktCmd);

        /*
            1.16. Call with not valid actionPtr->pktCmd
                                        [CPSS_PACKET_CMD_ROUTE_E
                                        CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E
                                        CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E
                                        CPSS_PACKET_CMD_BRIDGE_E ]
            Expected: NOT GT_OK
        */

        /* Call with CPSS_PACKET_CMD_ROUTE_E */
        action.pktCmd = CPSS_PACKET_CMD_ROUTE_E;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->action.pktCmd = %d",
                dev, ruleFormat, ruleIndex, action.pktCmd);

        /* Call with CPSS_PACKET_CMD_ROUTE_E */
        action.pktCmd = CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->action.pktCmd = %d",
                dev, ruleFormat, ruleIndex, action.pktCmd);

        /* Call with CPSS_PACKET_CMD_ROUTE_E */
        action.pktCmd = CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->action.pktCmd = %d",
                dev, ruleFormat, ruleIndex, action.pktCmd);

        /* Call with CPSS_PACKET_CMD_ROUTE_E */
        action.pktCmd = CPSS_PACKET_CMD_BRIDGE_E;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->action.pktCmd = %d",
                dev, ruleFormat, ruleIndex, action.pktCmd);

        /* restore valid value */
        action.pktCmd = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;

        /*
            1.17. Call with out of range actionPtr->lookupConfig.pcl0_1OverrideConfigIndex,
                  other parameters is the same as in 1.1.
            Expected: GT_BAD_PARAM for DxCh3 and above
        */
        action.egressPolicy = GT_TRUE;
        action.lookupConfig.ipclConfigIndex = 1;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet(
                            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action),
                            action.lookupConfig.pcl0_1OverrideConfigIndex);

        /* restore valid value */
        action.egressPolicy = GT_FALSE;

        /*
            1.18. Call with out of range actionPtr->lookupConfig.pcl1OverrideConfigIndex,
                other parameters is the same as in 1.1.
            Expected: GT_BAD_PARAM
        */
        action.egressPolicy = GT_TRUE;
        action.lookupConfig.ipclConfigIndex = 1;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet(
                            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action),
                            action.lookupConfig.pcl1OverrideConfigIndex);

        /* restore valid value */
        action.egressPolicy = GT_FALSE;
        action.lookupConfig.ipclConfigIndex = 0;

        /*
            1.19. Call with out of range actionPtr->mirror.cpuCode
            Expected: GT_BAD_PARAM
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet(
                            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action),
                            action.mirror.cpuCode);

        /*
            1.20. Call with out of range
                actionPtr->mirror.ingressMirrorToAnalyzerIndex[7 / 8]
                (relevant for Bobcat2; Caelum; Bobcat3)
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3 and GT_OK for others.
        */
        action.egressPolicy = GT_FALSE;
        action.mirror.mirrorToRxAnalyzerPort = GT_TRUE;

        /* call with actionPtr->mirror.ingressMirrorToAnalyzerIndex[7] */
        action.mirror.ingressMirrorToAnalyzerIndex = 7;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action);
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) != GT_FALSE)
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                    dev, ruleFormat, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
        }
        else
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                    dev, ruleFormat, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
        }

        /* call with actionPtr->mirror.ingressMirrorToAnalyzerIndex[8] */
        action.mirror.ingressMirrorToAnalyzerIndex = 8;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action);
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) != GT_FALSE)
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                    dev, ruleFormat, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
        }
        else
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                    dev, ruleFormat, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
        }

        /* restore valid value */
        action.mirror.mirrorToRxAnalyzerPort = GT_FALSE;
        action.mirror.ingressMirrorToAnalyzerIndex = 0;

        if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
        {
            /*
                Call with out of range
                actionPtr->mirror.egressMirrorToAnalyzerIndex[7 / 8]
                (relevant for Falcon)
            */
            action.egressPolicy = GT_TRUE;
            action.mirror.mirrorToTxAnalyzerPortEn = GT_TRUE;
            action.mirror.egressMirrorToAnalyzerMode = CPSS_DXCH_MIRROR_EGRESS_TAIL_DROP_E;

            /* call with actionPtr->mirror.egressMirrorToAnalyzerIndex[7] */
            action.mirror.egressMirrorToAnalyzerIndex = 7;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.egressMirrorToAnalyzerIndex = %d",
                    dev, ruleFormat, ruleIndex, action.mirror.egressMirrorToAnalyzerIndex);


            /* call with actionPtr->mirror.ingressMirrorToAnalyzerIndex[8] */
            action.mirror.egressMirrorToAnalyzerIndex = 8;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.egressMirrorToAnalyzerIndex = %d",
                    dev, ruleFormat, ruleIndex, action.mirror.egressMirrorToAnalyzerIndex);


            /* restore valid value */
            action.mirror.mirrorToTxAnalyzerPortEn = GT_FALSE;
            action.mirror.egressMirrorToAnalyzerIndex = 0;
            action.mirror.egressMirrorToAnalyzerMode = CPSS_DXCH_MIRROR_EGRESS_NOT_DROPPED_E;
        }

        /*
            1.21. Call with out of range actionPtr->qos.ingress.modifyDscp
            Expected: GT_BAD_PARAM
        */
        action.egressPolicy = GT_FALSE;
        action.qos.ingress.profileAssignIndex = GT_TRUE;
        action.qos.ingress.modifyUp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet(
                            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action),
                            action.qos.ingress.modifyDscp);

        /* restore default value */
        action.qos.ingress.profileAssignIndex = GT_FALSE;

        /*
            1.22. Call with out of range actionPtr->qos.ingress.modifyUp
            Expected: GT_BAD_PARAM
        */
        action.egressPolicy = GT_FALSE;
        action.qos.ingress.profileAssignIndex = GT_TRUE;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet(
                            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action),
                            action.qos.ingress.modifyUp);

        /* restore valid value */
        action.qos.ingress.profileAssignIndex = GT_FALSE;

        /*
            1.23. Call with out of range actionPtr->qos.ingress.profileIndex
                [72] for DxCh1
                [128] for Bobcat2; Caelum; Bobcat3
                [128] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2
            Expected: NOT GT_OK
        */
        action.qos.ingress.profileAssignIndex = GT_TRUE;
        action.qos.ingress.modifyUp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;
        action.qos.ingress.modifyDscp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.qos.ingress.profileIndex = BIT_10;
        }
        else
        {
            action.qos.ingress.profileIndex = 128;
        }

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                    dev, ruleFormat, ruleIndex, action.qos.ingress.profileIndex);

        /* restore valid value */
        action.qos.ingress.profileIndex = 0;
        action.qos.ingress.profileAssignIndex = GT_FALSE;

        /*
            1.24. Call with valid actionPtr->qos.ingress.profileIndex
                    [0 / 15 / 36 / 71] for DxCh1
                    [0 / 127 / 128 / 255] for Bobcat2; Caelum; Bobcat3
                    [0 / / 45 / 64 / 127 ] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2
            Expected: GT_OK
        */
        action.qos.ingress.profileAssignIndex = GT_TRUE;
        action.qos.ingress.modifyUp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;
        action.qos.ingress.modifyDscp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;

        /* Call with valid actionPtr->qos.ingress.profileIndex [0] */
        action.qos.ingress.profileIndex = 0;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                    dev, ruleFormat, ruleIndex, action.qos.ingress.profileIndex);

        /*  Call with valid actionPtr->qos.ingress.profileIndex
                [15] for DxCh1
                [127] for Bobcat2; Caelum; Bobcat3
                [45] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2 */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.qos.ingress.profileIndex = 666;/*less than BIT_10*/
        }
        else
        {
             action.qos.ingress.profileIndex = 45;
        }
        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                    dev, ruleFormat, ruleIndex, action.qos.ingress.profileIndex);

        /*  Call with valid actionPtr->qos.ingress.profileIndex
                [36] for DxCh1
                [64] for Bobcat2; Caelum; Bobcat3
                [64] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2 */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.qos.ingress.profileIndex = 777;/*less than BIT_10*/
        }
        else
        {
            action.qos.ingress.profileIndex = 64;
        }
        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                    dev, ruleFormat, ruleIndex, action.qos.ingress.profileIndex);

        /*  Call with valid actionPtr->qos.ingress.profileIndex
                [71] for DxCh1
                [127] for Bobcat2; Caelum; Bobcat3
                [127] for DxCh2, DxCh3, xCat, Lion, xCat2, Lion2 */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.qos.ingress.profileIndex = BIT_10 - 1;
        }
        else
        {
            action.qos.ingress.profileIndex = 127;
        }
        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                    dev, ruleFormat, ruleIndex, action.qos.ingress.profileIndex);

        /* restore valid value */
        action.qos.ingress.profileIndex = 0;
        action.qos.ingress.profileAssignIndex = GT_FALSE;

        /*
            1.25. Call with out of range actionPtr->qos.ingress.up1Cmd (relevant for Bobcat2; Caelum; Bobcat3)
            Expected: GT_BAD_PARAM
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet(
                                dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action),
                                action.qos.ingress.up1Cmd);
        }

        /*
            1.26. Call with out of range actionPtr->qos.ingress.up1 [8] (relevant for Bobcat2; Caelum; Bobcat3)
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3 and GT_OK for others.
        */
        action.qos.ingress.up1 = 8;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action);
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->qos.ingress.up1 = %d",
                    dev, ruleFormat, ruleIndex, action.qos.ingress.up1);
        }
        else
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->qos.ingress.up1 = %d",
                    dev, ruleFormat, ruleIndex, action.qos.ingress.up1);
        }

        /* restore valid value */
        action.qos.ingress.up1 = 0;

        /*
            1.27. Call with out of range actionPtr->qos.egress.modifyUp
            Expected: GT_BAD_PARAM.
        */
        action.egressPolicy = GT_TRUE;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet(
                            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action),
                            action.qos.egress.modifyUp);

        /* restore valid value */
        action.egressPolicy = GT_FALSE;


        /*
            1.28. Call with actionPtr->vlan.ingress.modifyVlan [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
                           out of range actionPtr->vlan.ingress.vlanId1 [4096]
                           and other params from 1.1. Applicable devices - Bobcat2; Caelum; Bobcat3; Aldrin; AC3X.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3; Aldrin and GT_OK for others.
        */
        action.vlan.ingress.modifyVlan = CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E;
        action.vlan.ingress.vlanId1 = _4K;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action);
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->vlan.ingress.vlanId1 = %d",
                                            dev, ruleFormat, ruleIndex, action.vlan.ingress.vlanId1);

        }
        else
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->vlan.ingress.vlanId1 = %d",
                                            dev, ruleFormat, ruleIndex, action.vlan.ingress.vlanId1);
        }

        action.vlan.ingress.vlanId1 = 100; /* restore valid value */

        /*
            1.29. Call with actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE] (relevant for non DxCh2, DxCh3),
                           out of range actionPtr->ipUcRoute.arpDaIndex [1024]
                           and other params from 1.1.
            Expected: NOT GT_OK
        */
        if (support_doIpUcRoute == GT_TRUE)
        {
            action.ipUcRoute.doIpUcRoute = GT_TRUE;
            action.policer.policerEnable = CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E;
            action.ipUcRoute.arpDaIndex = 1024;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                     dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);

            action.ipUcRoute.doIpUcRoute = GT_FALSE; /* restore valid value */
        }

        /*
            1.30. Call with relevant actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE],
                           out of range actionPtr->ipUcRoute.arpDaIndex [0 / 512 / 1023]
                           and other params from 1.1.
            Expected: GT_OK for non DxCh2, DxCh3 devices.
        */
        action.ipUcRoute.doIpUcRoute = GT_TRUE;

        /* Call with arpDaIndex [0] */
        action.ipUcRoute.arpDaIndex = 0;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action);
        if (support_doIpUcRoute == GT_TRUE)
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                        dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
        }
        else
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                             dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
        }

        /* Call with arpDaIndex [512] */
        action.ipUcRoute.arpDaIndex = 512;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action);
        if (support_doIpUcRoute == GT_TRUE)
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                        dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
        }
        else
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                             dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
        }

        /* Call with arpDaIndex [1023] */
        action.ipUcRoute.arpDaIndex = 1023;

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        if (support_doIpUcRoute == GT_TRUE)
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                        dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
        }
        else
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                             dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
        }

        action.ipUcRoute.doIpUcRoute = GT_FALSE; /* restore valid value */

        /*
            1.31. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE],
            maximal acceptable actionPtr->flowId and expected GT_OK.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /* restore previous value */
            pclActionDefaultSet(&action);

            action.egressPolicy = GT_FALSE;
            action.flowId  = MAX_FLOW_ID(dev)-1;
            action.actionStop = GT_FALSE;
            action.pktCmd = CPSS_PACKET_CMD_FORWARD_E;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                    ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);

        /*
            1.32. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], out of range
                actionPtr->flowId[0x100000](is relevant) and other params same as 1.1.
            Expected: NOT GT_OK.
        */

            action.egressPolicy = GT_FALSE;
            action.flowId  = MAX_FLOW_ID(dev);


            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                    ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);

        /*
            1.33. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                actionPtr->oam.oamProcessEnable[GT_TRUE],
                actionPtr->oam.oamProfile[1], out of range actionPtr->oam.offsetIndex[16],
                and other params same as 1.1.
            Expected: NOT GT_OK.
        */

            action.oam.timeStampEnable = GT_TRUE;
            action.oam.offsetIndex  = BIT_7;
            action.oam.oamProcessEnable = GT_TRUE;
            action.oam.oamProfile = 1;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                    ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);

        /*
            1.34. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                actionPtr->oam.oamProcessEnable[GT_TRUE],
                actionPtr->oam.offsetIndex[15], out of range actionPtr->oam.oamProfile[2],
                and other params same as 1.1.
            Expected: NOT GT_OK.
        */

            action.oam.timeStampEnable = GT_TRUE;
            action.oam.offsetIndex  = BIT_7 - 1;
            action.oam.oamProcessEnable = GT_TRUE;
            action.oam.oamProfile = 2;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                    ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);


            action.oam.timeStampEnable = GT_TRUE;
            action.oam.offsetIndex  = BIT_7 - 1;
            action.oam.oamProcessEnable = GT_TRUE;
            action.oam.oamProfile = 1;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                    ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);
        }

        /*
            1.35. Call with maskPtr [NULL], other parameters is the same as in 1.1.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            NULL, &pattern, &action);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_PTR, st, "%d, %d, %d, maskPtr = NULL",
                                     dev, ruleFormat, ruleIndex);

        /*
            1.36. Call with patternPtr [NULL], other parameters is the same as in 1.1.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, NULL, &action);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_PTR, st, "%d, %d, %d, patternPtr = NULL",
                                     dev, ruleFormat, ruleIndex);

        /*
            1.37. Call with actionPtr [NULL], other parameters is the same as in 1.1.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, NULL);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_PTR, st, "%d, %d, %d, actionPtr = NULL",
                                     dev, ruleFormat, ruleIndex);

        /*
            1.38. Call with ruleFormat [wrong enum values],
            other parameters is the same as in 1.1.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet
                            (dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                             &mask, &pattern, &action),
                            ruleFormat);

        /*
            1.40. Check extended rule. For all active device ids call with
                ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E],
                ruleIndex [511],
                maskPtr->ruleExtNotIpv6.common is the same as in 1.1., other fileds are zeroed,
                patternPtr->ruleExtNotIpv6 [ common[the same as in 1.1],
                commonExt[ isIpv6=0, ipProtocol=1, dscp=0, isL4Valid=1, l4Byte0=0, l4Byte1=0,
                            l4Byte2=0, l4Byte3=0, l4Byte13=0, ipHeaderOk=1 ],
                sip={ 64.233.167.1},
                dip={ 213.180.204.1},
                etherType=0,
                l2Encap=1,
                macDa=AB:CD:EF:00:00:02,
                macSa=AB:CD:EF:00:00:01,
                ipv4Fragmented=1,
                udb[6]={10,20,30,40,50,60} ],
                actionPtr is the same as in 1.1.
            Expected: GT_OK.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E;
        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

        cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
        pattern.ruleExtNotIpv6.common.pclId = 0;
        pattern.ruleExtNotIpv6.common.sourcePort = 5;
        pattern.ruleExtNotIpv6.common.isTagged = 1;
        pattern.ruleExtNotIpv6.common.vid = 100;
        pattern.ruleExtNotIpv6.common.up = 0;
        pattern.ruleExtNotIpv6.common.qosProfile = 0;
        pattern.ruleExtNotIpv6.common.isIp = 0;
        pattern.ruleExtNotIpv6.common.isL2Valid = 1;
        pattern.ruleExtNotIpv6.common.isUdbValid = 1;

        pattern.ruleExtNotIpv6.commonExt.isIpv6 = 0;
        pattern.ruleExtNotIpv6.commonExt.ipProtocol = 1;
        pattern.ruleExtNotIpv6.commonExt.dscp = 0;
        pattern.ruleExtNotIpv6.commonExt.isL4Valid = 1;
        pattern.ruleExtNotIpv6.commonExt.l4Byte0 = 0;
        pattern.ruleExtNotIpv6.commonExt.l4Byte1 = 0;
        pattern.ruleExtNotIpv6.commonExt.l4Byte2 = 0;
        pattern.ruleExtNotIpv6.commonExt.l4Byte3 = 0;
        pattern.ruleExtNotIpv6.commonExt.l4Byte13 = 0;
        pattern.ruleExtNotIpv6.commonExt.ipHeaderOk = 1;

        pattern.ruleExtNotIpv6.sip.arIP[0]= 64;
        pattern.ruleExtNotIpv6.sip.arIP[1]= 233;
        pattern.ruleExtNotIpv6.sip.arIP[2]= 167;
        pattern.ruleExtNotIpv6.sip.arIP[3]= 1;

        pattern.ruleExtNotIpv6.dip.arIP[0]= 213;
        pattern.ruleExtNotIpv6.dip.arIP[1]= 180;
        pattern.ruleExtNotIpv6.dip.arIP[2]= 204;
        pattern.ruleExtNotIpv6.dip.arIP[3]= 1;

        pattern.ruleExtNotIpv6.etherType = 0;
        pattern.ruleExtNotIpv6.l2Encap = 1;
        pattern.ruleExtNotIpv6.macDa = mac2;
        pattern.ruleExtNotIpv6.macSa = mac1;
        pattern.ruleExtNotIpv6.ipv4Fragmented = 1;

        pattern.ruleExtNotIpv6.udb0_5[0] = 10;
        pattern.ruleExtNotIpv6.udb0_5[1] = 20;
        pattern.ruleExtNotIpv6.udb0_5[2] = 30;
        pattern.ruleExtNotIpv6.udb0_5[3] = 40;
        pattern.ruleExtNotIpv6.udb0_5[4] = 50;
        pattern.ruleExtNotIpv6.udb0_5[5] = 60;

        cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
        mask.ruleExtNotIpv6 = pattern.ruleExtNotIpv6;
        mask.ruleExtNotIpv6.common.pclId = 0x3FF;/*10 bits*/

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);


        /*
            1.41. Check for out of range ruleIndex for extended rule format.
            Call with wrong ruleIndex, other parameters is the same as 1.8.
            Expected: NON GT_OK.
        */
        ruleIndex = PCL_INVALID_EXT_RULE_INDEX(dev);

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

        /*
            1.42. Check for out of range ruleIndex for standard rule format.
            Call with wrong ruleIndex, other parameters is the same as 1.8.
            Expected: NON GT_OK.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

        cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
        cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
        mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/
        pattern.ruleStdNotIp.common.pclId = 1;

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

        /* restore valid values */
        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E;

        /*
            1.44. Check standard EGRESS rule for all active devices with legal parameters.
            Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
            ruleIndex [PCL_TESTED_RULE_INDEX],
            maskPtr->ruleEgrStdNotIp [0xFF, ..., 0xFF],
            patternPtr->ruleEgrStdNotIp
                    [ common[pclId=0; sourcePort=5; isTagged=1; vid=100; up=0;
                      isIp=0; isL2Valid =1;  egrPacketType=0; cpuCode=1;srcTrg=1;
                      srcDev = 10; sourceId = 1; isVidx=0; others -zeroid],
            isIpv4 = 0;
            etherType=0;
            isArp=0;
            l2Encap=0;
            macDa=AB:CD:EF:00:00:02;
            macSa=AB:CD:EF:00:00:01],
            actionPtr - the same as in 1.1.
            Expected: GT_OK for all except ch1.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            /*set ruleFlags according to : usePortsBmp */
            RULE_FLAGS_SET_MAC(dev,ruleFlags,usePortsBmp);
            /*fill mask with values that not exceed field size*/
            pclRuleStructureTestFill(
                dev,
                ruleFormat, 1 /*fullFill*/, ruleFlags, &mask);
        }
        else
        {
            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            cpssOsMemSet((GT_VOID*)&(mask.ruleEgrStdNotIp), 0xFF, sizeof(mask.ruleEgrStdNotIp));
        }


        cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
        pattern.ruleEgrStdNotIp.common.pclId = 0;
        pattern.ruleEgrStdNotIp.common.sourcePort = 5;
        pattern.ruleEgrStdNotIp.common.isTagged = 1;
        pattern.ruleEgrStdNotIp.common.vid = 100;
        pattern.ruleEgrStdNotIp.common.up = 0;
        pattern.ruleEgrStdNotIp.common.isIp = 0;
        pattern.ruleEgrStdNotIp.common.isL2Valid = 1;
        pattern.ruleEgrStdNotIp.common.egrPacketType = 0;
        pattern.ruleEgrStdNotIp.common.toCpu.cpuCode = 1;
        pattern.ruleEgrStdNotIp.common.toCpu.srcTrg = 1;
        pattern.ruleEgrStdNotIp.common.srcHwDev = 10;
        pattern.ruleEgrStdNotIp.common.sourceId = 1;
        pattern.ruleEgrStdNotIp.common.isVidx = 0;

        pattern.ruleEgrStdNotIp.isIpv4 = 0;
        pattern.ruleEgrStdNotIp.etherType = 0;
        pattern.ruleEgrStdNotIp.isArp = 0;
        pattern.ruleEgrStdNotIp.l2Encap = 0;
        pattern.ruleEgrStdNotIp.macDa = mac2;
        pattern.ruleEgrStdNotIp.macSa = mac1;

        pclActionDefaultSet(&action);
        action.actionStop = GT_FALSE;
        action.pktCmd=CPSS_PACKET_CMD_FORWARD_E;
        action.egressPolicy = GT_TRUE;
        if(devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
        {   /* supported on CHEETAH 3 */
            action.qos.egress.modifyDscp = CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E;
            action.qos.egress.modifyUp = CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E;
        }

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);
        /*
            1.46. For all devices except ch1 call cpssDxChPclRuleInvalidate with
            ruleSize [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX]
            to cleanup after testing.
            Expected: GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;

        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
            "cpssDxChPclRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);

        /*
            1.45. Check extended EGRESS rule for all active devices with legal parameters.
            Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E],
            ruleIndex [511],
            maskPtr-> ruleEgrExtIpv6L2 [0xFF, ..., 0xFF],
            patternPtr-> ruleEgrExtIpv6L2 [common [pclId=0; sourcePort=5;
                isTagged=1; vid=100; up=0; isIp=1; isL2Valid =1;  egrPacketType=0;
                cpuCode=1;srcTrg=1; srcDev = 10; sourceId = 1; isVidx=0; others -zeroid],
                commonExt [isIpv6=1; ipProtocol=1; dscp=2; isL4Valid=0;
                            egrTcpUdpPortComparator=0; others- theroid]
                sip[100; 1000; 10000; 100000];
                dipBits127to120=0xAA;
                macDa=AB:CD:EF:00:00:02;
                macSa=AB:CD:EF:00:00:01],
                actionPtr - the same as in 1.1.
            Expected: GT_OK for all except ch1.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E;
        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            /*set ruleFlags according to : usePortsBmp */
            RULE_FLAGS_SET_MAC(dev,ruleFlags,usePortsBmp);
            /*fill mask with values that not exceed field size*/
            pclRuleStructureTestFill(
                dev,
                ruleFormat, 1 /*fullFill*/, ruleFlags, &mask);
        }
        else
        {
            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            cpssOsMemSet((GT_VOID*)&(mask.ruleEgrExtIpv6L2), 0xFF, sizeof(mask.ruleEgrExtIpv6L2));
        }

        mask.ruleStdNotIp.common.sourcePort = 0x3F;

        cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
        pattern.ruleEgrExtIpv6L2.common.pclId = 0;
        pattern.ruleEgrExtIpv6L2.common.sourcePort = 5;
        pattern.ruleEgrExtIpv6L2.common.sourceId = 0;
        pattern.ruleEgrExtIpv6L2.common.isTagged = 1;
        pattern.ruleEgrExtIpv6L2.common.vid = 100;
        pattern.ruleEgrExtIpv6L2.common.up = 0;
        pattern.ruleEgrExtIpv6L2.common.isIp = 1;
        pattern.ruleEgrExtIpv6L2.common.egrPacketType = 0;
        pattern.ruleEgrExtIpv6L2.common.toCpu.cpuCode = 1;
        pattern.ruleEgrExtIpv6L2.common.toCpu.srcTrg = 1;
        pattern.ruleEgrExtIpv6L2.common.srcHwDev = 10;
        pattern.ruleEgrExtIpv6L2.common.isVidx = 0;

        pattern.ruleEgrExtIpv6L2.commonExt.isIpv6 = 1;
        pattern.ruleEgrExtIpv6L2.commonExt.ipProtocol = 1;
        pattern.ruleEgrExtIpv6L2.commonExt.dscp = 2;
        pattern.ruleEgrExtIpv6L2.commonExt.isL4Valid = 0;
        pattern.ruleEgrExtIpv6L2.commonExt.egrTcpUdpPortComparator = 0;

        pattern.ruleEgrExtIpv6L2.dipBits127to120 = 0xAA;
        pattern.ruleEgrExtIpv6L2.sip.u32Ip[0] = 100;
        pattern.ruleEgrExtIpv6L2.sip.u32Ip[1] = 1000;
        pattern.ruleEgrExtIpv6L2.sip.u32Ip[2] = 10000;
        pattern.ruleEgrExtIpv6L2.sip.u32Ip[3] = 100000;
        pattern.ruleEgrExtIpv6L2.macDa = mac2;
        pattern.ruleEgrExtIpv6L2.macSa = mac1;

        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

        /*
            1.46. For all devices except ch1 call cpssDxChPclRuleInvalidate
            with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E] to cleanup after testing.
            Expected: GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;

        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
            "cpssDxChPclRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);

        /*
            1.47. Call with ruleOptionsBmp [CPSS_DXCH_PCL_RULE_OPTION_KEY_EXTENSION_ENABLED_E],
                and other params as in 1.23.
            Expected: GT_OK for Lion2.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E;
        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
        ruleOptionsBmp = 0;

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            /*set ruleFlags according to : usePortsBmp */
            RULE_FLAGS_SET_MAC(dev,ruleFlags,usePortsBmp);
            /*fill mask with values that not exceed field size*/
            pclRuleStructureTestFill(
                dev,
                ruleFormat, 1 /*fullFill*/, ruleFlags, &mask);
        }
        else
        {
            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            cpssOsMemSet((GT_VOID*)&(mask.ruleEgrExtIpv6L2), 0xFF, sizeof(mask.ruleEgrExtIpv6L2));
            mask.ruleStdNotIp.common.sourcePort = 0x3F;
        }

            cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
            pattern.ruleEgrExtIpv6L2.common.pclId = 0;
            pattern.ruleEgrExtIpv6L2.common.sourcePort = 5;
            pattern.ruleEgrExtIpv6L2.common.sourceId = 0;
            pattern.ruleEgrExtIpv6L2.common.isTagged = 1;
            pattern.ruleEgrExtIpv6L2.common.vid = 100;
            pattern.ruleEgrExtIpv6L2.common.up = 0;
            pattern.ruleEgrExtIpv6L2.common.isIp = 1;
            pattern.ruleEgrExtIpv6L2.common.egrPacketType = 0;
            pattern.ruleEgrExtIpv6L2.common.toCpu.cpuCode = 1;
            pattern.ruleEgrExtIpv6L2.common.toCpu.srcTrg = 1;
            pattern.ruleEgrExtIpv6L2.common.srcHwDev = 10;
            pattern.ruleEgrExtIpv6L2.common.isVidx = 0;

            pattern.ruleEgrExtIpv6L2.commonExt.isIpv6 = 1;
            pattern.ruleEgrExtIpv6L2.commonExt.ipProtocol = 1;
            pattern.ruleEgrExtIpv6L2.commonExt.dscp = 2;
            pattern.ruleEgrExtIpv6L2.commonExt.isL4Valid = 0;
            pattern.ruleEgrExtIpv6L2.commonExt.egrTcpUdpPortComparator = 0;

            pattern.ruleEgrExtIpv6L2.dipBits127to120 = 0xAA;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[0] = 100;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[1] = 1000;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[2] = 10000;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[3] = 100000;
            pattern.ruleEgrExtIpv6L2.macDa = mac2;
            pattern.ruleEgrExtIpv6L2.macSa = mac1;

        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

        /*
            1.48. Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[0 / 3 / 6]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_REPLACE_MAC_SA_E],
                           data { modifyMacSa {macSa [00:00:00:00:00:00 /
                                                      A5:A5:A5:A5:A5:A5 /
                                                      FF:FF:FF:FF:FF:FF],
                                               arpPtr[0 / 0xA5A5 / BIT_17-1]}}},
                        oam { timeStampEnable [GT_FALSE / GT_TRUE],
                              offsetIndex [0 / 0x5A / BIT_7-1],
                              oamProcessEnable [GT_FALSE / GT_TRUE],
                              oamProfile [0 / 1] },
                        sourcePort { assignSourcePortEnable [GT_FALSE / GT_TRUE]
                                 sourcePortValue [0 / 0x1A5A / BIT_13-1] }
                        qos { ingress { up1Cmd[
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_DO_NOT_MODIFY_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG1_UNTAGGED_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG0_UNTAGGED_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_ALL_E],
                                       up1[0 / 5 / BIT_3-1]} }
                        vlan { ingress { vlanId1Cmd[
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_DO_NOT_MODIFY_E /
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_UNTAGGED_E /
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_ALL_E],
                                       vlanId1 [0 / 0xA5A / BIT_12-1]} },
                        flowId [0 / 0xA5A / BIT_12-1],
                        setMacToMe [GT_FALSE / GT_TRUE] }
                    and other params from 1.1.
            Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /*
                Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[0]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E],
                           data { modifyMacSa {macSa [00:00:00:00:00:00],
                                               arpPtr [0] } } },
                        oam { timeStampEnable [GT_FALSE],
                              offsetIndex [0],
                              oamProcessEnable [GT_FALSE],
                              oamProfile [0] },
                        sourcePort { assignSourcePortEnable [GT_FALSE]
                                 sourcePortValue [0] }
                        qos { ingress { up1Cmd[
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_DO_NOT_MODIFY_E],
                                       up1[0]} }
                        vlan { ingress { vlanId1Cmd[
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_DO_NOT_MODIFY_E],
                                       vlanId1 [0]} },
                        flowId [0],
                        setMacToMe [GT_FALSE] }
                    and other params from 1.1.
            */

            action.egressPolicy = GT_FALSE;
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            ruleOptionsBmp = 0;

            cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
            pattern.ruleStdNotIp.common.pclId = 0;
            pattern.ruleStdNotIp.common.sourcePort = 5;
            pattern.ruleStdNotIp.common.isTagged = 1;
            pattern.ruleStdNotIp.common.vid = 100;
            pattern.ruleStdNotIp.common.up = 0;
            pattern.ruleStdNotIp.common.qosProfile = 0;
            pattern.ruleStdNotIp.common.isIp = 0;
            pattern.ruleStdNotIp.common.isL2Valid = 1;
            pattern.ruleStdNotIp.common.isUdbValid = 1;
            pattern.ruleStdNotIp.isIpv4 = 0;
            pattern.ruleStdNotIp.etherType = 0;
            pattern.ruleStdNotIp.isArp = 0;
            pattern.ruleStdNotIp.l2Encap = 0;
            pattern.ruleStdNotIp.macDa = mac2;
            pattern.ruleStdNotIp.macSa = mac1;
            pattern.ruleStdNotIp.udb15_17[0] = 10;
            pattern.ruleStdNotIp.udb15_17[1] = 20;
            pattern.ruleStdNotIp.udb15_17[2] = 30;

            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            mask.ruleStdNotIp = pattern.ruleStdNotIp;
            mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/
            mask.ruleStdNotIp.common.sourcePort = 0x3F;

            action.mirror.mirrorToRxAnalyzerPort = GT_TRUE;
            action.mirror.ingressMirrorToAnalyzerIndex = 0;
            action.redirect.redirectCmd =
                                       CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E;
            action.redirect.data.modifyMacSa.macSa = macSa1;
            action.redirect.data.modifyMacSa.arpPtr = 0;
            action.oam.timeStampEnable = GT_FALSE;
            action.oam.offsetIndex = 0;
            action.oam.oamProcessEnable = GT_FALSE;
            action.oam.oamProfile = 0;
            action.sourcePort.assignSourcePortEnable = GT_FALSE;
            action.sourcePort.sourcePortValue = 0;
            action.qos.ingress.up1Cmd =
                           CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_DO_NOT_MODIFY_E;
            action.qos.ingress.up1 = 0;
            action.vlan.ingress.vlanId1Cmd =
                      CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_DO_NOT_MODIFY_E;
            action.vlan.ingress.vlanId1 = 0;
            action.flowId = 0;
            action.setMacToMe = GT_FALSE;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
            {
                ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
                ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

                if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
                {
                    cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                    /*set ruleFlags according to : usePortsBmp */
                    RULE_FLAGS_SET_MAC(dev,ruleFlags,usePortsBmp);
                    /*fill mask with values that not exceed field size*/
                    pclRuleStructureTestFill(
                        dev,
                        ruleFormat, 1 /*fullFill*/, ruleFlags, &mask);
                }
                else
                {
                    cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                    cpssOsMemSet((GT_VOID*)&(mask.ruleEgrStdNotIp), 0xFF, sizeof(mask.ruleEgrStdNotIp));
                }

                cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
                pattern.ruleEgrStdNotIp.common.pclId = 0;
                pattern.ruleEgrStdNotIp.common.sourcePort = 5;
                pattern.ruleEgrStdNotIp.common.isTagged = 1;
                pattern.ruleEgrStdNotIp.common.vid = 100;
                pattern.ruleEgrStdNotIp.common.up = 0;
                pattern.ruleEgrStdNotIp.common.isIp = 0;
                pattern.ruleEgrStdNotIp.common.isL2Valid = 1;
                pattern.ruleEgrStdNotIp.common.egrPacketType = 0;
                pattern.ruleEgrStdNotIp.common.toCpu.cpuCode = 1;
                pattern.ruleEgrStdNotIp.common.toCpu.srcTrg = 1;
                pattern.ruleEgrStdNotIp.common.srcHwDev = 10;
                pattern.ruleEgrStdNotIp.common.sourceId = 1;
                pattern.ruleEgrStdNotIp.common.isVidx = 0;

                pattern.ruleEgrStdNotIp.isIpv4 = 0;
                pattern.ruleEgrStdNotIp.etherType = 0;
                pattern.ruleEgrStdNotIp.isArp = 0;
                pattern.ruleEgrStdNotIp.l2Encap = 0;
                pattern.ruleEgrStdNotIp.macDa = mac2;
                pattern.ruleEgrStdNotIp.macSa = mac1;

                pclActionDefaultSet(&action);
                action.actionStop = GT_FALSE;
                action.pktCmd = CPSS_PACKET_CMD_FORWARD_E;
                action.egressPolicy = GT_TRUE;
                if(devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
                {    /* supported on CHEETAH 3 */
                    action.qos.egress.modifyDscp = CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E;
                    action.qos.egress.modifyUp = CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E;
                }

                action.mirror.mirrorToRxAnalyzerPort = GT_FALSE;
                action.mirror.mirrorToTxAnalyzerPortEn = GT_TRUE;
                action.mirror.egressMirrorToAnalyzerIndex = 1;
                action.mirror.egressMirrorToAnalyzerMode = CPSS_DXCH_MIRROR_EGRESS_TAIL_DROP_E;
                st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                        &mask, &pattern, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                action.egressPolicy = GT_FALSE;
                action.mirror.mirrorToRxAnalyzerPort = GT_TRUE;
                action.mirror.mirrorToTxAnalyzerPortEn = GT_FALSE;
                action.mirror.egressMirrorToAnalyzerIndex = 0;
                action.mirror.egressMirrorToAnalyzerMode = CPSS_DXCH_MIRROR_EGRESS_NOT_DROPPED_E;

                ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
                ruleOptionsBmp = 0;

                cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
                pattern.ruleStdNotIp.common.pclId = 0;
                pattern.ruleStdNotIp.common.sourcePort = 5;
                pattern.ruleStdNotIp.common.isTagged = 1;
                pattern.ruleStdNotIp.common.vid = 100;
                pattern.ruleStdNotIp.common.up = 0;
                pattern.ruleStdNotIp.common.qosProfile = 0;
                pattern.ruleStdNotIp.common.isIp = 0;
                pattern.ruleStdNotIp.common.isL2Valid = 1;
                pattern.ruleStdNotIp.common.isUdbValid = 1;
                pattern.ruleStdNotIp.isIpv4 = 0;
                pattern.ruleStdNotIp.etherType = 0;
                pattern.ruleStdNotIp.isArp = 0;
                pattern.ruleStdNotIp.l2Encap = 0;
                pattern.ruleStdNotIp.macDa = mac2;
                pattern.ruleStdNotIp.macSa = mac1;
                pattern.ruleStdNotIp.udb15_17[0] = 10;
                pattern.ruleStdNotIp.udb15_17[1] = 20;
                pattern.ruleStdNotIp.udb15_17[2] = 30;

                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                mask.ruleStdNotIp = pattern.ruleStdNotIp;
                mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/
                mask.ruleStdNotIp.common.sourcePort = 0x3F;
            }

            /*
                Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[3]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                           data { modifyMacSa {macSa [00:00:00:00:00:00],
                                               arpPtr [0] } } },
                        oam { timeStampEnable [GT_TRUE],
                              offsetIndex [0x5A],
                              oamProcessEnable [GT_TRUE],
                              oamProfile [1] },
                        sourcePort { assignSourcePortEnable [GT_TRUE]
                                 sourcePortValue [0x1A5A] }
                        qos { ingress { up1Cmd[
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG1_UNTAGGED_E],
                                       up1[5]} }
                        vlan { ingress { vlanId1Cmd[
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_UNTAGGED_E],
                                       vlanId1 [0xA5A]} },
                        flowId [0xA5A],
                        setMacToMe [GT_TRUE] }
                    and other params from 1.1.
            */

            action.mirror.ingressMirrorToAnalyzerIndex = 3;
            action.redirect.redirectCmd =
                                     CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E;
            action.oam.timeStampEnable = GT_TRUE;
            action.oam.offsetIndex = 0x5A;
            action.oam.oamProcessEnable = GT_TRUE;
            action.oam.oamProfile = 1;
            action.sourcePort.assignSourcePortEnable = GT_TRUE;
            action.sourcePort.sourcePortValue = 0x1A5A;
            action.qos.ingress.up1Cmd =
                           CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG1_UNTAGGED_E;
            action.qos.ingress.up1 = 5;
            action.vlan.ingress.vlanId1Cmd =
                           CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_UNTAGGED_E;
            action.vlan.ingress.vlanId1 = 0xA5A;
            action.flowId = 0xA5A;
            action.setMacToMe = GT_TRUE;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /*
                Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[6]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E],
                           data { modifyMacSa {macSa [00:00:00:00:00:00],
                                               arpPtr [0] } } },
                        oam { timeStampEnable [GT_TRUE],
                              offsetIndex [BIT_7-1],
                              oamProcessEnable [GT_TRUE],
                              oamProfile [1] },
                        sourcePort { assignSourcePortEnable [GT_TRUE]
                                 sourcePortValue [BIT_13-1] }
                        qos { ingress { up1Cmd[
                         CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG0_UNTAGGED_E],
                                       up1[BIT_3-1]} }
                        vlan { ingress { vlanId1Cmd[
                               CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_ALL_E],
                                       vlanId1 [BIT_12-1]} },
                        flowId [BIT_12-1],
                        setMacToMe [GT_TRUE] }
                    and other params from 1.1.
            */

            action.mirror.ingressMirrorToAnalyzerIndex = 6;
            action.redirect.redirectCmd =
                                CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E;
            action.oam.offsetIndex = BIT_7-1;
            action.sourcePort.sourcePortValue = MAX_EPORT(dev)-1;
            action.qos.ingress.up1Cmd =
                           CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG0_UNTAGGED_E;
            action.qos.ingress.up1 = BIT_3-1;
            action.vlan.ingress.vlanId1Cmd =
                                CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_ALL_E;
            action.vlan.ingress.vlanId1 = BIT_12-1;
            action.flowId = MAX_FLOW_ID(dev)-1;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /*
                Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[6]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_REPLACE_MAC_SA_E],
                           data { modifyMacSa {macSa [A5:A5:A5:A5:A5:A5],
                                               arpPtr [0xA5A5] } } },
                        oam { timeStampEnable [GT_TRUE],
                              offsetIndex [BIT_7-1],
                              oamProcessEnable [GT_TRUE],
                              oamProfile [1] },
                        sourcePort { assignSourcePortEnable [GT_TRUE]
                                 sourcePortValue [BIT_13-1] }
                        qos { ingress { up1Cmd[
                                    CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_ALL_E],
                                       up1[BIT_3-1]} }
                                vlan { ingress { vlanId1Cmd[
                               CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_ALL_E],
                                       vlanId1 [BIT_12-1]} },
                        flowId [BIT_12-1],
                        setMacToMe [GT_TRUE] }
                    and other params from 1.1.
            */

            action.redirect.redirectCmd =
                             CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_REPLACE_MAC_SA_E;
            action.redirect.data.modifyMacSa.macSa = macSa2;
            action.redirect.data.modifyMacSa.arpPtr = 0xA5A5 % (MAX_ARP_PTR(dev));
            action.qos.ingress.up1Cmd =
                                     CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_ALL_E;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /*
                Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_REPLACE_MAC_SA_E],
                           data { modifyMacSa {macSa [FF:FF:FF:FF:FF:FF],
                                               arpPtr [BIT_17-1] } } } }
                    and other params from 1.48.
            */

            action.redirect.data.modifyMacSa.macSa = macSa3;
            action.redirect.data.modifyMacSa.arpPtr = MAX_ARP_PTR(dev)-1;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }
        /*
            1.49. Call function with
                   out of range ingressMirrorToAnalyzerIndex [7]
                   and other parameters from 1.48.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.egressPolicy = GT_FALSE;
            action.mirror.ingressMirrorToAnalyzerIndex = 7;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.mirror.ingressMirrorToAnalyzerIndex = 0;
            if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
            {
                ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
                ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

                if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
                {
                    cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                    /*set ruleFlags according to : usePortsBmp */
                    RULE_FLAGS_SET_MAC(dev,ruleFlags,usePortsBmp);
                    /*fill mask with values that not exceed field size*/
                    pclRuleStructureTestFill(
                        dev,
                        ruleFormat, 1 /*fullFill*/, ruleFlags, &mask);
                }
                else
                {
                    cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                    cpssOsMemSet((GT_VOID*)&(mask.ruleEgrStdNotIp), 0xFF, sizeof(mask.ruleEgrStdNotIp));
                }


                cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
                pattern.ruleEgrStdNotIp.common.pclId = 0;
                pattern.ruleEgrStdNotIp.common.sourcePort = 5;
                pattern.ruleEgrStdNotIp.common.isTagged = 1;
                pattern.ruleEgrStdNotIp.common.vid = 100;
                pattern.ruleEgrStdNotIp.common.up = 0;
                pattern.ruleEgrStdNotIp.common.isIp = 0;
                pattern.ruleEgrStdNotIp.common.isL2Valid = 1;
                pattern.ruleEgrStdNotIp.common.egrPacketType = 0;
                pattern.ruleEgrStdNotIp.common.toCpu.cpuCode = 1;
                pattern.ruleEgrStdNotIp.common.toCpu.srcTrg = 1;
                pattern.ruleEgrStdNotIp.common.srcHwDev = 10;
                pattern.ruleEgrStdNotIp.common.sourceId = 1;
                pattern.ruleEgrStdNotIp.common.isVidx = 0;

                pattern.ruleEgrStdNotIp.isIpv4 = 0;
                pattern.ruleEgrStdNotIp.etherType = 0;
                pattern.ruleEgrStdNotIp.isArp = 0;
                pattern.ruleEgrStdNotIp.l2Encap = 0;
                pattern.ruleEgrStdNotIp.macDa = mac2;
                pattern.ruleEgrStdNotIp.macSa = mac1;

                pclActionDefaultSet(&action);
                action.actionStop = GT_FALSE;
                action.pktCmd = CPSS_PACKET_CMD_FORWARD_E;
                action.egressPolicy = GT_TRUE;
                if(devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
                {   /* supported on CHEETAH 3 */
                    action.qos.egress.modifyDscp = CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E;
                    action.qos.egress.modifyUp = CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E;
                }
                action.mirror.mirrorToRxAnalyzerPort = GT_FALSE;
                action.mirror.mirrorToTxAnalyzerPortEn = GT_TRUE;
                action.mirror.egressMirrorToAnalyzerIndex = 7;
                action.mirror.egressMirrorToAnalyzerMode = CPSS_DXCH_MIRROR_EGRESS_TAIL_DROP_E;
                st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                        &mask, &pattern, &action);
                UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                action.egressPolicy = GT_FALSE;
                action.mirror.mirrorToRxAnalyzerPort = GT_TRUE;
                action.mirror.mirrorToTxAnalyzerPortEn = GT_FALSE;
                action.mirror.egressMirrorToAnalyzerIndex = 0;
                action.mirror.egressMirrorToAnalyzerMode = CPSS_DXCH_MIRROR_EGRESS_NOT_DROPPED_E;

                ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
                ruleOptionsBmp = 0;

                cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
                pattern.ruleStdNotIp.common.pclId = 0;
                pattern.ruleStdNotIp.common.sourcePort = 5;
                pattern.ruleStdNotIp.common.isTagged = 1;
                pattern.ruleStdNotIp.common.vid = 100;
                pattern.ruleStdNotIp.common.up = 0;
                pattern.ruleStdNotIp.common.qosProfile = 0;
                pattern.ruleStdNotIp.common.isIp = 0;
                pattern.ruleStdNotIp.common.isL2Valid = 1;
                pattern.ruleStdNotIp.common.isUdbValid = 1;
                pattern.ruleStdNotIp.isIpv4 = 0;
                pattern.ruleStdNotIp.etherType = 0;
                pattern.ruleStdNotIp.isArp = 0;
                pattern.ruleStdNotIp.l2Encap = 0;
                pattern.ruleStdNotIp.macDa = mac2;
                pattern.ruleStdNotIp.macSa = mac1;
                pattern.ruleStdNotIp.udb15_17[0] = 10;
                pattern.ruleStdNotIp.udb15_17[1] = 20;
                pattern.ruleStdNotIp.udb15_17[2] = 30;

                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                mask.ruleStdNotIp = pattern.ruleStdNotIp;
                mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/
                mask.ruleStdNotIp.common.sourcePort = 0x3F;
            }
        }
        /*
            1.50. Call function with out of range redirectCmd
                   and other parameters from 1.48.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet
                                (dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                 &mask, &pattern, &action),
                                action.redirect.redirectCmd);
        }
        /*
            1.51. Call function with out of range offsetIndex [BIT_7]
                   and other parameters from 1.48.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.oam.offsetIndex = BIT_7;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.oam.offsetIndex = 0;
        }
        /*
            1.52. Call function with out of range oamProfile [2]
                   and other parameters from 1.48.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.oam.oamProfile = 2;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.oam.oamProfile = 0;
        }
        /*
            1.53. Call function with out of range up1Cmd
                   and other parameters from 1.48.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet
                                (dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                 &mask, &pattern, &action),
                                action.qos.ingress.up1Cmd);
        }
        /*
            1.54. Call function with out of range up1 [BIT_3]
                   and other parameters from 1.48.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.qos.ingress.up1 = BIT_3;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.qos.ingress.up1 = 0;
        }
        /*
            1.55. Call function with out of range vlanId1Cmd
                   and other parameters from 1.48.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet
                                (dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                 &mask, &pattern, &action),
                                action.vlan.ingress.vlanId1Cmd);
        }
        /*
            1.56. Call function with out of range vlanId1 [BIT_12]
                   and other parameters from 1.48.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.vlan.ingress.vlanId1 = BIT_12;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.vlan.ingress.vlanId1 = 0;
        }
        /*
            1.57. Call function with out of range flowId [BIT_12]
                   and other parameters from 1.48.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.flowId = MAX_FLOW_ID(dev);

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.flowId = 0;
        }

        /*
            1.58. Call function with out of range sourcePortValue [BIT_13]
                   and other parameters from 1.48.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.sourcePort.sourcePortValue = MAX_EPORT(dev);

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.sourcePort.sourcePortValue = 0;
        }
        /*

            1.59. Call function with out of range arpPtr [BIT_17]
                   and other parameters from 1.48.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.redirect.data.modifyMacSa.arpPtr = MAX_ARP_PTR(dev);

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.redirect.data.modifyMacSa.arpPtr = 0;
        }
        /*
            1.60. Call function with
                    actionPtr { egressPolicy [GT_TRUE]
                        qos { egress { modifyDscp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_OUTER_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_INNER_E],
                                      modifyUp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                      up1ModifyEnable [GT_FALSE / GT_TRUE],
                                      up1[0 / 5 / BIT_3-1]} }
                        vlan { egress { vlanCmd[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                       vlanId1ModifyEnable [GT_FALSE / GT_TRUE],
                                       vlanId1 [0 / 0xA5A / BIT_12-1]} },
                        channelTypeToOpcodeMapEnable [GT_FALSE / GT_TRUE],
                        tmQueueId [0 / 0x2A5A / BIT_14-1] }
                    and other params from 1.48.
            Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {

            /*
                Call function with
                    actionPtr { egressPolicy [GT_TRUE]
                        qos { egress { modifyDscp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E],
                                      modifyUp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E],
                                      up1ModifyEnable [GT_TRUE],
                                      up1[0]} }
                        vlan { egress { vlanCmd[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E],
                                       vlanId1ModifyEnable [GT_FALSE],
                                       vlanId1 [0]} },
                        channelTypeToOpcodeMapEnable [GT_FALSE],
                        tmQueueId [0] }
                    and other params from 1.48.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                /*set ruleFlags according to : usePortsBmp */
                RULE_FLAGS_SET_MAC(dev,ruleFlags,usePortsBmp);
                /*fill mask with values that not exceed field size*/
                pclRuleStructureTestFill(
                    dev,
                    ruleFormat, 1 /*fullFill*/, ruleFlags, &mask);
            }
            else
            {
                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                cpssOsMemSet((GT_VOID*)&(mask.ruleEgrStdNotIp), 0xFF, sizeof(mask.ruleEgrStdNotIp));
            }

            cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
            pattern.ruleEgrStdNotIp.common.pclId = 0;
            pattern.ruleEgrStdNotIp.common.sourcePort = 5;
            pattern.ruleEgrStdNotIp.common.isTagged = 1;
            pattern.ruleEgrStdNotIp.common.vid = 100;
            pattern.ruleEgrStdNotIp.common.up = 0;
            pattern.ruleEgrStdNotIp.common.isIp = 0;
            pattern.ruleEgrStdNotIp.common.isL2Valid = 1;
            pattern.ruleEgrStdNotIp.common.egrPacketType = 0;
            pattern.ruleEgrStdNotIp.common.toCpu.cpuCode = 1;
            pattern.ruleEgrStdNotIp.common.toCpu.srcTrg = 1;
            pattern.ruleEgrStdNotIp.common.srcHwDev = 10;
            pattern.ruleEgrStdNotIp.common.sourceId = 1;
            pattern.ruleEgrStdNotIp.common.isVidx = 0;

            pattern.ruleEgrStdNotIp.isIpv4 = 0;
            pattern.ruleEgrStdNotIp.etherType = 0;
            pattern.ruleEgrStdNotIp.isArp = 0;
            pattern.ruleEgrStdNotIp.l2Encap = 0;
            pattern.ruleEgrStdNotIp.macDa = mac2;
            pattern.ruleEgrStdNotIp.macSa = mac1;

            pclActionDefaultSet(&action);
            action.egressPolicy = GT_TRUE;
            action.pktCmd = CPSS_PACKET_CMD_FORWARD_E;
            action.actionStop = GT_FALSE;

            action.qos.egress.modifyDscp =
                                CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E;
            action.qos.egress.modifyUp =
                           CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E;
            action.qos.egress.up1ModifyEnable = GT_FALSE;
            action.qos.egress.up1 = 0;
            action.vlan.egress.vlanCmd =
                           CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E;
            action.vlan.egress.vlanId1ModifyEnable = GT_FALSE;
            action.vlan.egress.vlanId1 = 0;
            action.channelTypeToOpcodeMapEnable = GT_FALSE;
            action.tmQueueId = 0;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /*
                Call function with
                    actionPtr { egressPolicy [GT_TRUE]
                        qos { egress { modifyDscp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_OUTER_E],
                                      modifyUp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E],
                                      up1ModifyEnable [GT_TRUE],
                                      up1[5]} }
                        vlan { egress { vlanCmd[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E],
                                       vlanId1ModifyEnable [GT_TRUE],
                                       vlanId1 [0xA5A]} },
                        channelTypeToOpcodeMapEnable [GT_TRUE],
                        tmQueueId [0x2A5A] }
                    and other params from 1.48.
            */

            action.qos.egress.modifyDscp =
                        CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_OUTER_E;
            action.qos.egress.modifyUp =
                        CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E;
            action.qos.egress.up1ModifyEnable = GT_TRUE;
            action.qos.egress.up1 = 5;
            action.vlan.egress.vlanCmd =
                        CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E;
            action.vlan.egress.vlanId1ModifyEnable = GT_TRUE;
            action.vlan.egress.vlanId1 = 0xA5A;
            action.channelTypeToOpcodeMapEnable = GT_TRUE;
            action.tmQueueId = 0x2A5A;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /*
                Call function with
                    actionPtr { egressPolicy [GT_TRUE]
                        qos { egress { modifyDscp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_INNER_E],
                                      modifyUp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                      up1ModifyEnable [GT_TRUE],
                                      up1[BIT_3-1]} }
                        vlan { egress { vlanCmd[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                       vlanId1ModifyEnable [GT_TRUE],
                                       vlanId1 [BIT_12-1]} },
                        channelTypeToOpcodeMapEnable [GT_TRUE],
                        tmQueueId [BIT_14-1] }
                    and other params from 1.48.
            */

            action.qos.egress.modifyDscp =
                                CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E;
            action.qos.egress.modifyUp =
                           CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E;
            action.qos.egress.up1 = BIT_3-1;
            action.vlan.egress.vlanCmd =
                      CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_DO_NOT_MODIFY_E;
            action.vlan.egress.vlanId1 = BIT_12-1;
            action.tmQueueId = BIT_14-1;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        }
        /*
            1.61. Call function with out of range modifyDscp
                   and other parameters from 1.60.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet
                                (dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                 &mask, &pattern, &action),
                                action.qos.egress.modifyDscp);
        }
        /*
            1.62. Call function with out of range modifyUp
                   and other parameters from 1.60.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet
                                (dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                 &mask, &pattern, &action),
                                action.qos.egress.modifyUp);
        }
        /*
            1.63. Call function with out of range up1 [BIT_3]
                   and other parameters from 1.60.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.qos.egress.up1 = BIT_3;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.qos.egress.up1 = 0;
        }
        /*
            1.64. Call function with out of range vlanCmd
                   and other parameters from 1.60.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet
                                (dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                 &mask, &pattern, &action),
                                action.vlan.egress.vlanCmd);
        }
        /*
            1.65. Call function with out of range vlanId1 [BIT_12]
                   and other parameters from 1.60.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.vlan.egress.vlanId1 = BIT_12;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.vlan.egress.vlanId1 = 0;
        }
        /*
            1.66. Call function with out of range tmQueueId [BIT_14]
                   and other parameters from 1.60.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.tmQueueId = BIT_14;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            if(PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.trafficManager.supported)
            {
                UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }
            else
            {
                /* tmQueueId is ignored */
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }

            action.tmQueueId = 0;
        }
        /*
            1.67. Call function with
                    ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                    sourceDevice [dev], udb23_26 [10,20,30,40].
            Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            ruleOptionsBmp = 0;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            for (index = 0;
                 index < (sizeof(ruleFormatArr) / sizeof(ruleFormatArr[0]));
                 index++) {
              cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
              cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
              cpssOsBzero((GT_VOID*)&action, sizeof(action));

              switch (ruleFormatArr[index])
              {
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleStdNotIp.common.sourceDevice = dev;
                    pattern.ruleStdNotIp.udb23_26[0] = 10;
                    pattern.ruleStdNotIp.udb23_26[1] = 20;
                    pattern.ruleStdNotIp.udb23_26[2] = 30;
                    pattern.ruleStdNotIp.udb23_26[3] = 40;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleStdIpL2Qos.common.sourceDevice = dev;
                    pattern.ruleStdIpL2Qos.udb27_30[0] = 10;
                    pattern.ruleStdIpL2Qos.udb27_30[1] = 20;
                    pattern.ruleStdIpL2Qos.udb27_30[2] = 30;
                    pattern.ruleStdIpL2Qos.udb27_30[3] = 40;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleStdIpv4L4.common.sourceDevice = dev;
                    pattern.ruleStdIpv4L4.udb31_34[0] = 10;
                    pattern.ruleStdIpv4L4.udb31_34[1] = 20;
                    pattern.ruleStdIpv4L4.udb31_34[2] = 30;
                    pattern.ruleStdIpv4L4.udb31_34[3] = 40;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleStdIpv6Dip.common.sourceDevice = dev;
                    pattern.ruleStdIpv6Dip.udb47_49[0] = 10;
                    pattern.ruleStdIpv6Dip.udb47_49[1] = 20;
                    pattern.ruleStdIpv6Dip.udb47_49[2] = 30;
                    pattern.ruleStdIpv6Dip.udb0        = 40;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleExtNotIpv6.common.sourceDevice = dev;
                    pattern.ruleExtNotIpv6.udb39_46[0] = 10;
                    pattern.ruleExtNotIpv6.udb39_46[1] = 20;
                    pattern.ruleExtNotIpv6.udb39_46[2] = 30;
                    pattern.ruleExtNotIpv6.udb39_46[3] = 40;
                    pattern.ruleExtNotIpv6.udb39_46[4] = 50;
                    pattern.ruleExtNotIpv6.udb39_46[5] = 60;
                    pattern.ruleExtNotIpv6.udb39_46[6] = 70;
                    pattern.ruleExtNotIpv6.udb39_46[7] = 80;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleExtIpv6L2.common.sourceDevice = dev;
                    pattern.ruleExtIpv6L2.udb47_49[0] = 10;
                    pattern.ruleExtIpv6L2.udb47_49[1] = 20;
                    pattern.ruleExtIpv6L2.udb47_49[2] = 30;
                    pattern.ruleExtIpv6L2.udb0_4[0]   = 40;
                    pattern.ruleExtIpv6L2.udb0_4[1]   = 50;
                    pattern.ruleExtIpv6L2.udb0_4[2]   = 60;
                    pattern.ruleExtIpv6L2.udb0_4[3]   = 70;
                    pattern.ruleExtIpv6L2.udb0_4[4]   = 80;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleExtIpv6L4.common.sourceDevice = dev;
                    pattern.ruleExtIpv6L4.udb15_22[0] = 10;
                    pattern.ruleExtIpv6L4.udb15_22[1] = 20;
                    pattern.ruleExtIpv6L4.udb15_22[2] = 30;
                    pattern.ruleExtIpv6L4.udb15_22[3] = 40;
                    pattern.ruleExtIpv6L4.udb15_22[4] = 50;
                    pattern.ruleExtIpv6L4.udb15_22[5] = 60;
                    pattern.ruleExtIpv6L4.udb15_22[6] = 70;
                    pattern.ruleExtIpv6L4.udb15_22[7] = 80;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E:
                    action.egressPolicy = GT_TRUE;
                    pattern.ruleEgrStdNotIp.udb0_3[0] = 10;
                    pattern.ruleEgrStdNotIp.udb0_3[1] = 20;
                    pattern.ruleEgrStdNotIp.udb0_3[2] = 30;
                    pattern.ruleEgrStdNotIp.udb0_3[3] = 40;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E:
                    action.egressPolicy = GT_TRUE;
                    pattern.ruleEgrStdIpL2Qos.udb4_7[0] = 10;
                    pattern.ruleEgrStdIpL2Qos.udb4_7[1] = 20;
                    pattern.ruleEgrStdIpL2Qos.udb4_7[2] = 30;
                    pattern.ruleEgrStdIpL2Qos.udb4_7[3] = 40;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E:
                    action.egressPolicy = GT_TRUE;
                    pattern.ruleEgrStdIpv4L4.udb8_11[0] = 10;
                    pattern.ruleEgrStdIpv4L4.udb8_11[1] = 20;
                    pattern.ruleEgrStdIpv4L4.udb8_11[2] = 30;
                    pattern.ruleEgrStdIpv4L4.udb8_11[3] = 40;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E:
                    action.egressPolicy = GT_TRUE;
                    pattern.ruleEgrExtNotIpv6.udb12_19[0] = 10;
                    pattern.ruleEgrExtNotIpv6.udb12_19[1] = 20;
                    pattern.ruleEgrExtNotIpv6.udb12_19[2] = 30;
                    pattern.ruleEgrExtNotIpv6.udb12_19[3] = 40;
                    pattern.ruleEgrExtNotIpv6.udb12_19[4] = 50;
                    pattern.ruleEgrExtNotIpv6.udb12_19[5] = 60;
                    pattern.ruleEgrExtNotIpv6.udb12_19[6] = 70;
                    pattern.ruleEgrExtNotIpv6.udb12_19[7] = 80;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E:
                    action.egressPolicy = GT_TRUE;
                    pattern.ruleEgrExtIpv6L2.udb20_27[0] = 10;
                    pattern.ruleEgrExtIpv6L2.udb20_27[1] = 20;
                    pattern.ruleEgrExtIpv6L2.udb20_27[2] = 30;
                    pattern.ruleEgrExtIpv6L2.udb20_27[3] = 40;
                    pattern.ruleEgrExtIpv6L2.udb20_27[4] = 50;
                    pattern.ruleEgrExtIpv6L2.udb20_27[5] = 60;
                    pattern.ruleEgrExtIpv6L2.udb20_27[6] = 70;
                    pattern.ruleEgrExtIpv6L2.udb20_27[7] = 80;
                    pattern.ruleEgrExtIpv6L2.isIpv6ExtHdrExist = 0;
                    pattern.ruleEgrExtIpv6L2.isIpv6HopByHop = 1;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E:
                    action.egressPolicy = GT_TRUE;
                    pattern.ruleEgrExtIpv6L4.udb28_35[0] = 10;
                    pattern.ruleEgrExtIpv6L4.udb28_35[1] = 20;
                    pattern.ruleEgrExtIpv6L4.udb28_35[2] = 30;
                    pattern.ruleEgrExtIpv6L4.udb28_35[3] = 40;
                    pattern.ruleEgrExtIpv6L4.udb28_35[4] = 50;
                    pattern.ruleEgrExtIpv6L4.udb28_35[5] = 60;
                    pattern.ruleEgrExtIpv6L4.udb28_35[6] = 70;
                    pattern.ruleEgrExtIpv6L4.udb28_35[7] = 80;
                    pattern.ruleEgrExtIpv6L4.isIpv6ExtHdrExist = 1;
                    pattern.ruleEgrExtIpv6L4.isIpv6HopByHop = 0;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleIngrStdUdb.commonIngrUdb.sourceDevice = dev;
                    pattern.ruleIngrStdUdb.udb35_38[0] = 10;
                    pattern.ruleIngrStdUdb.udb35_38[1] = 20;
                    pattern.ruleIngrStdUdb.udb35_38[2] = 30;
                    pattern.ruleIngrStdUdb.udb35_38[3] = 40;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleIngrExtUdb.commonIngrUdb.sourceDevice = dev;
                    pattern.ruleIngrExtUdb.udb23_30[0] = 10;
                    pattern.ruleIngrExtUdb.udb23_30[1] = 20;
                    pattern.ruleIngrExtUdb.udb23_30[2] = 30;
                    pattern.ruleIngrExtUdb.udb23_30[3] = 40;
                    pattern.ruleIngrExtUdb.udb23_30[4] = 50;
                    pattern.ruleIngrExtUdb.udb23_30[5] = 60;
                    pattern.ruleIngrExtUdb.udb23_30[6] = 70;
                    pattern.ruleIngrExtUdb.udb23_30[7] = 80;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleStdIpv4RoutedAclQos.ingressIpCommon.sourceDevice
                                                                          = dev;
                    pattern.ruleStdIpv4RoutedAclQos.udb41_44[0] = 10;
                    pattern.ruleStdIpv4RoutedAclQos.udb41_44[1] = 20;
                    pattern.ruleStdIpv4RoutedAclQos.udb41_44[2] = 30;
                    pattern.ruleStdIpv4RoutedAclQos.udb41_44[3] = 40;
                    pattern.ruleStdIpv4RoutedAclQos.vrfId = 0;
                    pattern.ruleStdIpv4RoutedAclQos.isUdbValid = 1;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleExtIpv4PortVlanQos.ingressIpCommon.sourceDevice
                                                                          = dev;
                    pattern.ruleExtIpv4PortVlanQos.udb31_38[0] = 10;
                    pattern.ruleExtIpv4PortVlanQos.udb31_38[1] = 20;
                    pattern.ruleExtIpv4PortVlanQos.udb31_38[2] = 30;
                    pattern.ruleExtIpv4PortVlanQos.udb31_38[3] = 40;
                    pattern.ruleExtIpv4PortVlanQos.udb31_38[4] = 50;
                    pattern.ruleExtIpv4PortVlanQos.udb31_38[5] = 60;
                    pattern.ruleExtIpv4PortVlanQos.udb31_38[6] = 70;
                    pattern.ruleExtIpv4PortVlanQos.udb31_38[7] = 80;
                    pattern.ruleExtIpv4PortVlanQos.tag1Exist = 1;
                    pattern.ruleExtIpv4PortVlanQos.vid1 = 100;
                    pattern.ruleExtIpv4PortVlanQos.up1 = 4;
                    pattern.ruleExtIpv4PortVlanQos.cfi1 = 1;
                    pattern.ruleExtIpv4PortVlanQos.vrfId = 0;
                    pattern.ruleExtIpv4PortVlanQos.trunkHash = 10;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleUltraIpv6PortVlanQos.ingressIpCommon.sourceDevice
                                                                          = dev;
                    pattern.ruleUltraIpv6PortVlanQos.udb39_40[0] = 10;
                    pattern.ruleUltraIpv6PortVlanQos.udb39_40[1] = 20;
                    pattern.ruleUltraIpv6PortVlanQos.tag1Exist = 1;
                    pattern.ruleUltraIpv6PortVlanQos.vid1 = 100;
                    pattern.ruleUltraIpv6PortVlanQos.up1 = 4;
                    pattern.ruleUltraIpv6PortVlanQos.cfi1 = 1;
                    pattern.ruleUltraIpv6PortVlanQos.vrfId = 0;
                    pattern.ruleUltraIpv6PortVlanQos.srcPortOrTrunk = 0;
                    pattern.ruleUltraIpv6PortVlanQos.srcIsTrunk = 1;
                    pattern.ruleUltraIpv6PortVlanQos.trunkHash = 10;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E:
                    action.egressPolicy = GT_FALSE;
                    pattern.ruleUltraIpv6RoutedAclQos.ingressIpCommon.sourceDevice
                                                                          = dev;
                    pattern.ruleUltraIpv6RoutedAclQos.udb45_46[0] = 10;
                    pattern.ruleUltraIpv6RoutedAclQos.udb45_46[1] = 20;
                    pattern.ruleUltraIpv6RoutedAclQos.tag1Exist = 1;
                    pattern.ruleUltraIpv6RoutedAclQos.vid1 = 100;
                    pattern.ruleUltraIpv6RoutedAclQos.up1 = 4;
                    pattern.ruleUltraIpv6RoutedAclQos.cfi1 = 1;
                    pattern.ruleUltraIpv6RoutedAclQos.vrfId = 0;
                    pattern.ruleUltraIpv6RoutedAclQos.srcPortOrTrunk = 0;
                    pattern.ruleUltraIpv6RoutedAclQos.srcIsTrunk = 1;
                    pattern.ruleUltraIpv6RoutedAclQos.trunkHash = 10;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E:
                    action.egressPolicy = GT_TRUE;
                    pattern.ruleEgrExtIpv4RaclVacl.egressIpCommon.srcHwDev = dev;
                    pattern.ruleEgrExtIpv4RaclVacl.egressIpCommon.tag1Exist = 1;
                    pattern.ruleEgrExtIpv4RaclVacl.egressIpCommon.sourceId  = 0;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[0] = 10;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[1] = 20;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[2] = 30;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[3] = 40;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[4] = 50;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[5] = 60;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[6] = 70;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[7] = 80;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[8] = 90;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[9] = 0xA0;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[10] = 0xB0;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[11] = 0xC0;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[12] = 0xD0;
                    pattern.ruleEgrExtIpv4RaclVacl.udb36_49[13] = 0xE0;
                    pattern.ruleEgrExtIpv4RaclVacl.udb0 = 80;
                    pattern.ruleEgrExtIpv4RaclVacl.vid1 = 100;
                    pattern.ruleEgrExtIpv4RaclVacl.up1 = 4;
                    pattern.ruleEgrExtIpv4RaclVacl.cfi1 = 1;
                    break;
                case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E:
                    action.egressPolicy = GT_TRUE;
                    pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.srcHwDev =dev;
                    pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.tag1Exist=1;
                    pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourceId =0;
                    pattern.ruleEgrUltraIpv6RaclVacl.udb1_4[0] = 10;
                    pattern.ruleEgrUltraIpv6RaclVacl.udb1_4[1] = 20;
                    pattern.ruleEgrUltraIpv6RaclVacl.udb1_4[2] = 30;
                    pattern.ruleEgrUltraIpv6RaclVacl.udb1_4[3] = 40;
                    pattern.ruleEgrUltraIpv6RaclVacl.srcPort = 0;
                    pattern.ruleEgrUltraIpv6RaclVacl.trgPort = 0xA5A;
                    pattern.ruleEgrUltraIpv6RaclVacl.vid1 = 100;
                    pattern.ruleEgrUltraIpv6RaclVacl.up1 = 4;
                    pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 1;
                    break;
                default:
                    break;
              }
              st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormatArr[index], ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
              if ((CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E == ruleFormatArr[index]) &&
                  (PRV_CPSS_SIP_6_10_CHECK_MAC(dev)))
              {
                  /* Ultra rules are not supported in EPCL of Hawk */
                  UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormatArr[index]);
              }
              else
              {
                  UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormatArr[index]);
              }
            }
        }
        /*
            1.68. Call function with out of range isIpv6ExtHdrExist [2]
                  ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            ruleOptionsBmp = 0;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
            cpssOsBzero((GT_VOID*)&action, sizeof(action));
            action.egressPolicy = GT_TRUE;

            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E;
            pattern.ruleEgrExtIpv6L2.isIpv6ExtHdrExist = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrExtIpv6L2.isIpv6ExtHdrExist = 0;
        }
        /*
            1.69. Call function with out of range isIpv6HopByHop [2]
                  ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            pattern.ruleEgrExtIpv6L2.isIpv6HopByHop = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrExtIpv6L2.isIpv6HopByHop = 0;

        }
        /*
            1.70. Call function with out of range isIpv6ExtHdrExist [2]
                  ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E;
            pattern.ruleEgrExtIpv6L4.isIpv6ExtHdrExist = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrExtIpv6L4.isIpv6ExtHdrExist = 0;
        }
        /*
            1.71. Call function with out of range isIpv6HopByHop [2]
                  ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            pattern.ruleEgrExtIpv6L4.isIpv6HopByHop = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrExtIpv6L4.isIpv6HopByHop = 0;

        }
        /*
            1.72. Call function with vrfId [0x5A / BIT_8-1], isUdbValid [0]
                  ruleFormat
                   [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E]
                  and other parameters from 1.67.
            Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.egressPolicy = GT_FALSE;
            ruleFormat =
                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E;

            /* Call with vrfId [0xA5A], isUdbValid [0] */
            pattern.ruleStdIpv4RoutedAclQos.vrfId = 0x5A;
            pattern.ruleStdIpv4RoutedAclQos.isUdbValid = 0;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            /* Call with vrfId [BIT_8-1] */
            pattern.ruleStdIpv4RoutedAclQos.vrfId = BIT_8-1;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

        }
        /*
            1.73. Call function with out of range isUdbValid [2]
                  ruleFormat
                   [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /* Call with out of range isUdbValid [2] */
            pattern.ruleStdIpv4RoutedAclQos.isUdbValid = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleStdIpv4RoutedAclQos.isUdbValid = 0;
        }
        /*
            1.74. Call function with tag1Exist [0],
                                     vid1 [0 / BIT_12-1],
                                     up1 [0 / 7],
                                     cfi1 [0],
                                     vrfId [0xA5A / BIT_12-1],
                                     trunkHash [0 / BIT_6-1]
                  ruleFormat
                   [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E]
                  and other parameters from 1.67.
            Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            ruleFormat =
                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E;

            /*
                Call with tag1Exist [0],
                          vid1 [0],
                          up1 [0],
                          cfi1 [0],
                          vrfId [0xA5A],
                          trunkHash [0]
            */
            pattern.ruleExtIpv4PortVlanQos.tag1Exist = 0;
            pattern.ruleExtIpv4PortVlanQos.vid1 = 0;
            pattern.ruleExtIpv4PortVlanQos.up1 = 0;
            pattern.ruleExtIpv4PortVlanQos.cfi1 = 0;
            pattern.ruleExtIpv4PortVlanQos.vrfId = 0xA5A;
            pattern.ruleExtIpv4PortVlanQos.trunkHash = 0;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            /*
                Call with vid1 [BIT_12-1],
                          up1 [7],
                          vrfId [BIT_12-1],
                          trunkHash [BIT_6-1]
            */
            pattern.ruleExtIpv4PortVlanQos.vid1 = BIT_12-1;
            pattern.ruleExtIpv4PortVlanQos.up1 = 7;
            pattern.ruleExtIpv4PortVlanQos.vrfId = BIT_12-1;
            pattern.ruleExtIpv4PortVlanQos.trunkHash = BIT_6-1;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            /* Call with vrfId [BIT_8-1] */
            pattern.ruleStdIpv4RoutedAclQos.vrfId = BIT_8-1;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

        }
        /*
            1.75. Call function with out of range tag1Exist [2],
                                                  vid1 [BIT_12],
                                                  up1 [8],
                                                  cfi1 [2],
                                                  trunkHash [BIT_6]
                  ruleFormat
                   [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /* Call with out of range tag1Exist [2] */
            pattern.ruleExtIpv4PortVlanQos.tag1Exist = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleExtIpv4PortVlanQos.tag1Exist = 0;

            /* Call with out of range vid1 [BIT_12] */
            pattern.ruleExtIpv4PortVlanQos.vid1 = BIT_12;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleExtIpv4PortVlanQos.vid1 = 0;

            /* Call with out of range up1 [8] */
            pattern.ruleExtIpv4PortVlanQos.up1 = 8;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleExtIpv4PortVlanQos.up1 = 0;

            /* Call with out of range cfi1 [2] */
            pattern.ruleExtIpv4PortVlanQos.cfi1 = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleExtIpv4PortVlanQos.cfi1 = 0;

            /* Call with out of range trunkHash [BIT_6] */
            pattern.ruleExtIpv4PortVlanQos.trunkHash = BIT_6;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleExtIpv4PortVlanQos.trunkHash = 0;
        }
        /*
            1.76. Call function with tag1Exist [0],
                                     vid1 [0 / BIT_12-1],
                                     up1 [0 / 7],
                                     cfi1 [0],
                                     vrfId [0xA5A / BIT_12-1],
                                     trunkHash [0 / BIT_6-1],
                                     srcPortOrTrunk [0xA5A / BIT_13-1],
                                     srcIsTrunk [0]
                  ruleFormat
                  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E]
                  and other parameters from 1.67.
            Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            ruleFormat =
                   CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E;

            /*
                Call with tag1Exist [0],
                          vid1 [0],
                          up1 [0],
                          cfi1 [0],
                          vrfId [0xA5A],
                          trunkHash [0],
                          srcPortOrTrunk [0xA5A / BIT_13-1],
                          srcIsTrunk [0]
            */
            pattern.ruleUltraIpv6PortVlanQos.tag1Exist = 0;
            pattern.ruleUltraIpv6PortVlanQos.vid1 = 0;
            pattern.ruleUltraIpv6PortVlanQos.up1 = 0;
            pattern.ruleUltraIpv6PortVlanQos.cfi1 = 0;
            pattern.ruleUltraIpv6PortVlanQos.vrfId = 0xA5A;
            pattern.ruleUltraIpv6PortVlanQos.trunkHash = 0;
            pattern.ruleUltraIpv6PortVlanQos.srcPortOrTrunk = 0xA5A;
            pattern.ruleUltraIpv6PortVlanQos.srcIsTrunk = 0;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            /*
                Call with vid1 [BIT_12-1],
                          up1 [7],
                          vrfId [BIT_12-1],
                          trunkHash [BIT_6-1],
                          srcPortOrTrunk [BIT_13-1]
            */
            pattern.ruleUltraIpv6PortVlanQos.vid1 = BIT_12-1;
            pattern.ruleUltraIpv6PortVlanQos.up1 = 7;
            pattern.ruleUltraIpv6PortVlanQos.vrfId = BIT_12-1;
            pattern.ruleUltraIpv6PortVlanQos.trunkHash = BIT_6-1;
            pattern.ruleUltraIpv6PortVlanQos.srcPortOrTrunk = BIT_13-1;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            /* Call with vrfId [BIT_8-1] */
            pattern.ruleStdIpv4RoutedAclQos.vrfId = BIT_8-1;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

        }
        /*
            1.77. Call function with out of range tag1Exist [2],
                                                  vid1 [BIT_12],
                                                  up1 [8],
                                                  cfi1 [2],
                                                  trunkHash [BIT_6],
                                                  srcIsTrunk [2]
                  ruleFormat
                  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /* Call with out of range tag1Exist [2] */
            pattern.ruleUltraIpv6PortVlanQos.tag1Exist = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6PortVlanQos.tag1Exist = 0;

            /* Call with out of range vid1 [BIT_12] */
            pattern.ruleUltraIpv6PortVlanQos.vid1 = BIT_12;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6PortVlanQos.vid1 = 0;

            /* Call with out of range up1 [8] */
            pattern.ruleUltraIpv6PortVlanQos.up1 = 8;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6PortVlanQos.up1 = 0;

            /* Call with out of range cfi1 [2] */
            pattern.ruleUltraIpv6PortVlanQos.cfi1 = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6PortVlanQos.cfi1 = 0;

            /* Call with out of range trunkHash [BIT_6] */
            pattern.ruleUltraIpv6PortVlanQos.trunkHash = BIT_6;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6PortVlanQos.trunkHash = 0;

            /* Call with out of range srcIsTrunk [2] */
            pattern.ruleUltraIpv6PortVlanQos.srcIsTrunk = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6PortVlanQos.srcIsTrunk = 0;

        }
        /*
            1.78. Call function with tag1Exist [0],
                                     vid1 [0 / BIT_12-1],
                                     up1 [0 / 7],
                                     cfi1 [0],
                                     vrfId [0xA5A / BIT_12-1],
                                     trunkHash [0 / BIT_6-1],
                                     srcPortOrTrunk [0xA5A / BIT_13-1],
                                     srcIsTrunk [0]
                  ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E]
                  and other parameters from 1.67.
            Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            ruleFormat =
                  CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E;

            /*
                Call with tag1Exist [0],
                          vid1 [0],
                          up1 [0],
                          cfi1 [0],
                          vrfId [0xA5A],
                          trunkHash [0],
                          srcPortOrTrunk [0xA5A / BIT_13-1],
                          srcIsTrunk [0]
            */
            pattern.ruleUltraIpv6RoutedAclQos.tag1Exist = 0;
            pattern.ruleUltraIpv6RoutedAclQos.vid1 = 0;
            pattern.ruleUltraIpv6RoutedAclQos.up1 = 0;
            pattern.ruleUltraIpv6RoutedAclQos.cfi1 = 0;
            pattern.ruleUltraIpv6RoutedAclQos.vrfId = 0xA5A;
            pattern.ruleUltraIpv6RoutedAclQos.trunkHash = 0;
            pattern.ruleUltraIpv6RoutedAclQos.srcPortOrTrunk = 0xA5A;
            pattern.ruleUltraIpv6RoutedAclQos.srcIsTrunk = 0;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            /*
                Call with vid1 [BIT_12-1],
                          up1 [7],
                          vrfId [BIT_12-1],
                          trunkHash [BIT_6-1],
                          srcPortOrTrunk [BIT_13-1]
            */
            pattern.ruleUltraIpv6RoutedAclQos.vid1 = BIT_12-1;
            pattern.ruleUltraIpv6RoutedAclQos.up1 = 7;
            pattern.ruleUltraIpv6RoutedAclQos.vrfId = BIT_12-1;
            pattern.ruleUltraIpv6RoutedAclQos.trunkHash = BIT_6-1;
            pattern.ruleUltraIpv6RoutedAclQos.srcPortOrTrunk = BIT_13-1;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            /* Call with vrfId [BIT_12-1] */
            pattern.ruleUltraIpv6RoutedAclQos.vrfId = BIT_12-1;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

        }
        /*
            1.79. Call function with out of range tag1Exist [2],
                                                  vid1 [BIT_12],
                                                  up1 [8],
                                                  cfi1 [2],
                                                  trunkHash [BIT_6],
                                                  srcIsTrunk [2]
                  ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /* Call with out of range tag1Exist [2] */
            pattern.ruleUltraIpv6RoutedAclQos.tag1Exist = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6RoutedAclQos.tag1Exist = 0;

            /* Call with out of range vid1 [BIT_12] */
            pattern.ruleUltraIpv6RoutedAclQos.vid1 = BIT_12;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6RoutedAclQos.vid1 = 0;

            /* Call with out of range up1 [8] */
            pattern.ruleUltraIpv6RoutedAclQos.up1 = 8;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6RoutedAclQos.up1 = 0;

            /* Call with out of range cfi1 [2] */
            pattern.ruleUltraIpv6RoutedAclQos.cfi1 = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6RoutedAclQos.cfi1 = 0;

            /* Call with out of range trunkHash [BIT_6] */
            pattern.ruleUltraIpv6RoutedAclQos.trunkHash = BIT_6;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6RoutedAclQos.trunkHash = 0;

            /* Call with out of range srcIsTrunk [2] */
            pattern.ruleUltraIpv6RoutedAclQos.srcIsTrunk = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleUltraIpv6RoutedAclQos.srcIsTrunk = 0;

        }
        /*
            1.80. Call function with vid1 [0 / BIT_12-1],
                                     up1 [0 / 7],
                                     cfi1 [0]
                  ruleFormat
                       [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
                  and other parameters from 1.67.
            Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) &&
           !PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
        {
            ruleFormat =
                        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E;
            action.egressPolicy = GT_TRUE;

            /*
                Call with vid1 [0], up1 [0], cfi1 [0]
            */
            pattern.ruleEgrUltraIpv6RaclVacl.vid1 = 0;
            pattern.ruleEgrUltraIpv6RaclVacl.up1 = 0;
            pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 0;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            /*
                Call with vid1 [BIT_12-1], up1 [7]
            */
            pattern.ruleEgrUltraIpv6RaclVacl.vid1 = BIT_12-1;
            pattern.ruleEgrUltraIpv6RaclVacl.up1 = 7;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

        }
        /*
            1.81. Call function with out of range vid1 [BIT_12],
                                                  up1 [8],
                                                  cfi1 [2]
                  ruleFormat
                       [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) &&
           !PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
        {

            /* Call with out of range vid1 [BIT_12] */
            pattern.ruleEgrUltraIpv6RaclVacl.vid1 = BIT_12;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrUltraIpv6RaclVacl.vid1 = 0;

            /* Call with out of range up1 [8] */
            pattern.ruleEgrUltraIpv6RaclVacl.up1 = 8;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrUltraIpv6RaclVacl.up1 = 0;

            /* Call with out of range cfi1 [2] */
            pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 0;

        }
        /*
            1.82. Call function with egressIpCommon.tag1Exist [0],
                                     egressIpCommon.sourceId [10 / BIT_12-1],
                                     vid1 [0 / BIT_12-1],
                                     up1 [0 / 7],
                                     cfi1 [0],
                                     srcPort [0xA5A / BIT_13-1],
                                     trgPort [0 / BIT_13-1]
                  ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
                  and other parameters from 1.67.
            Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) &&
           !PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
        {
            ruleFormat =
                  CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E;
            action.egressPolicy = GT_TRUE;

            /*
                Call with egressIpCommon.tag1Exist [0],
                          egressIpCommon.sourceId [10],
                          vid1 [0],
                          up1 [0],
                          cfi1 [0],
                          srcPort [0xA5A],
                          trgPort [BIT_13-1],
                          srcIsTrunk [0]
            */
            pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.tag1Exist = 0;
            pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourceId = 10;
            pattern.ruleEgrUltraIpv6RaclVacl.vid1 = 0;
            pattern.ruleEgrUltraIpv6RaclVacl.up1 = 0;
            pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 0;
            pattern.ruleEgrUltraIpv6RaclVacl.srcPort = 0xA5A;
            pattern.ruleEgrUltraIpv6RaclVacl.trgPort = BIT_13-1;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            /*
                Call with egressIpCommon.sourceId [BIT_12-1],
                          vid1 [BIT_12-1],
                          up1 [7],
                          srcPort [BIT_13-1],
                          trgPort [0]
            */
            pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourceId = BIT_12-1;
            pattern.ruleEgrUltraIpv6RaclVacl.vid1 = BIT_12-1;
            pattern.ruleEgrUltraIpv6RaclVacl.up1 = 7;
            pattern.ruleEgrUltraIpv6RaclVacl.srcPort = BIT_13-1;
            pattern.ruleEgrUltraIpv6RaclVacl.trgPort = 0;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            /* Call with srcPort [BIT_13-1] */
            pattern.ruleEgrUltraIpv6RaclVacl.srcPort = BIT_13-1;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

        }
        /*
            1.83. Call function with out of range egressIpCommon.tag1Exist [2],
                                               egressIpCommon.sourceId [BIT_12],
                                                  vid1 [BIT_12],
                                                  up1 [8],
                                                  cfi1 [2],
                                                  srcPort [BIT_13],
                                                  trgPort [BIT_13],
                  ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) &&
           !PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
        {
            /* Call with out of range egressIpCommon.tag1Exist [2] */
            pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.tag1Exist = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.tag1Exist = 0;

            /* Call with out of range egressIpCommon.sourceId [BIT_12] */
            pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourceId = BIT_12;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourceId = 0;

            /* Call with out of range vid1 [BIT_12] */
            pattern.ruleEgrUltraIpv6RaclVacl.vid1 = BIT_12;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrUltraIpv6RaclVacl.vid1 = 0;

            /* Call with out of range up1 [8] */
            pattern.ruleEgrUltraIpv6RaclVacl.up1 = 8;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrUltraIpv6RaclVacl.up1 = 0;

            /* Call with out of range cfi1 [2] */
            pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 2;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 0;

            /* Call with out of range srcPort [BIT_13] */
            pattern.ruleEgrUltraIpv6RaclVacl.srcPort = BIT_13;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrUltraIpv6RaclVacl.srcPort = 0;

            /* Call with out of range trgPort [BIT_13] */
            pattern.ruleEgrUltraIpv6RaclVacl.trgPort = BIT_13;

            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            pattern.ruleEgrUltraIpv6RaclVacl.trgPort = 0;

        }
        ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;

        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChPclRuleInvalidate: %d, %d, %d",
                                     dev, ruleSize, ruleIndex);
        /*
            1.84. Call function with out of range udb60FixedFld.
                         isUdbValid (APPLICABLE RANGES: 0..1)
                         pclId(APPLICABLE RANGES: 0..0x3FF)
                         vid(APPLICABLE RANGES: 0..0x1FFF)
                         srcPort(APPLICABLE RANGES: 0..0x1FFF)
                         srcDevIsOwn(APPLICABLE RANGES: 0..1)
                         vid1(APPLICABLE RANGES: 0..0xFFF)
                         up1(APPLICABLE RANGES: 0..7)
                         macToMe(APPLICABLE RANGES: 0..1)
                         qosProfile(APPLICABLE RANGES: 0..0x3FF)
                         flowId(APPLICABLE RANGES: 0..0xFFF)
                  ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3; Aldrin2.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E;
            action.egressPolicy = GT_FALSE;

            /* Call with out of range isUdbValid [BIT_1] */
            pattern.ruleIngrUdbOnly.udb60FixedFld.isUdbValid = BIT_1;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleIngrUdbOnly.udb60FixedFld.isUdbValid = 0;

            /* Call with out of range pclId [BIT_10] */
            pattern.ruleIngrUdbOnly.udb60FixedFld.pclId = BIT_10;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleIngrUdbOnly.udb60FixedFld.pclId = 0;

            /* Call with out of range vid [BIT_13] */
            pattern.ruleIngrUdbOnly.udb60FixedFld.vid = BIT_13;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleIngrUdbOnly.udb60FixedFld.vid = 0;

            /* Call with out of range srcPort [BIT_15] (fixed by Cider from 13) */
            pattern.ruleIngrUdbOnly.udb60FixedFld.srcPort = BIT_15;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleIngrUdbOnly.udb60FixedFld.srcPort = 0;

            /* Call with out of range srcDevIsOwn [BIT_1] */
            pattern.ruleIngrUdbOnly.udb60FixedFld.srcDevIsOwn = BIT_1;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleIngrUdbOnly.udb60FixedFld.srcDevIsOwn = 0;

            /* Call with out of range vid1 [BIT_12] */
            pattern.ruleIngrUdbOnly.udb60FixedFld.vid1 = BIT_12;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleIngrUdbOnly.udb60FixedFld.vid1 = 0;

            /* Call with out of range up1 [BIT_3] */
            pattern.ruleIngrUdbOnly.udb60FixedFld.up1 = BIT_3;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleIngrUdbOnly.udb60FixedFld.up1 = 0;

            /* Call with out of range macToMe [BIT_1] */
            pattern.ruleIngrUdbOnly.udb60FixedFld.macToMe = BIT_1;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleIngrUdbOnly.udb60FixedFld.macToMe = 0;

            /* Call with out of range qosProfile [BIT_10] */
            pattern.ruleIngrUdbOnly.udb60FixedFld.qosProfile = BIT_10;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleIngrUdbOnly.udb60FixedFld.qosProfile = 0;

            /* Call with out of range flowId [BIT_12] */
            pattern.ruleIngrUdbOnly.udb60FixedFld.flowId = MAX_FLOW_ID(dev);
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleIngrUdbOnly.udb60FixedFld.flowId = 0;

            ruleSize = CPSS_PCL_RULE_SIZE_60_BYTES_E;
            st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChPclRuleInvalidate: %d, %d, %d",
                                         dev, ruleSize, ruleIndex);
        }

        /*
            1.85. Call function with out of range udb60FixedFld.
                             pclId [BIT_10]
                             isUdbValid [BIT_1]
                             vid [BIT_13]
                             srcPort [BIT_13]
                             trgPort [BIT_13]
                             srcDev [BIT_10]
                             trgDev [BIT_10]
                             localDevTrgPhyPort [BIT_8]
                  ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E]
                  and other parameters from 1.67.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E;
            action.egressPolicy = GT_TRUE;

            /* Call with out of range pclId [BIT_10] */
            pattern.ruleEgrUdbOnly.udb60FixedFld.pclId = BIT_10;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleEgrUdbOnly.udb60FixedFld.pclId = 0;

            /* Call with out of range isUdbValid [BIT_1] */
            pattern.ruleEgrUdbOnly.udb60FixedFld.isUdbValid = BIT_1;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleEgrUdbOnly.udb60FixedFld.isUdbValid = 0;

            /* Call with out of range vid [BIT_13] */
            pattern.ruleEgrUdbOnly.udb60FixedFld.vid = BIT_13;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleEgrUdbOnly.udb60FixedFld.vid = 0;

            /* Call with out of range srcPort [BIT_13] */
            pattern.ruleEgrUdbOnly.udb60FixedFld.srcPort = BIT_13;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleEgrUdbOnly.udb60FixedFld.srcPort = 0;

            /* Call with out of range trgPort [BIT_13] */
            pattern.ruleEgrUdbOnly.udb60FixedFld.trgPort = BIT_13;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleEgrUdbOnly.udb60FixedFld.trgPort = 0;

            /* Call with out of range srcDev [BIT_10] */
            pattern.ruleEgrUdbOnly.udb60FixedFld.srcDev = BIT_10;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleEgrUdbOnly.udb60FixedFld.srcDev = 0;

            /* Call with out of range trgDev [BIT_10] */
            pattern.ruleEgrUdbOnly.udb60FixedFld.trgDev = BIT_10;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleEgrUdbOnly.udb60FixedFld.trgDev = 0;

            /* Call with out of range localDevTrgPhyPort [BIT_8] */
            pattern.ruleEgrUdbOnly.udb60FixedFld.localDevTrgPhyPort = BIT_8;
            st = cpssDxChPclRuleSet(
                  dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                  &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
            pattern.ruleEgrUdbOnly.udb60FixedFld.localDevTrgPhyPort = 0;

            ruleSize = CPSS_PCL_RULE_SIZE_60_BYTES_E;
            st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChPclRuleInvalidate: %d, %d, %d",
                                         dev, ruleSize, ruleIndex);
        }
        /*
            1.86. Call function with
                    action{
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                           data {
                               logicalSourceInterface{
                                   logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                                     devPort {devNum=dev, portNum=0}]
                                   sourceMeshIdSetEnable[GT_TRUE/GT_FALSE]
                                   sourceMeshId[0/1/3]
                                   userTagAcEnable[GT_TRUE/GT_FALSE]
                               }}},
                        unknownSaCommandEnable[GT_TRUE/GT_FALSE]
                        unknownSaCommand[  CPSS_PACKET_CMD_FORWARD_E /
                                           CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                           CPSS_PACKET_CMD_TRAP_TO_CPU_E /
                                           CPSS_PACKET_CMD_DROP_HARD_E /
                                           CPSS_PACKET_CMD_DROP_SOFT_E]}
                    and other parameters from 1.67.
            Expected: GT_OK  for xCat C0; xCat3.
        */
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
        {
            /*
                Call function with
                        action{
                            redirect {
                               redirectCmd [
                                CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                               data {
                                   logicalSourceInterface{
                                       logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                                         devPort {devNum=0, portNum=0} ]
                                       sourceMeshIdSetEnable[GT_FALSE]
                                       sourceMeshId[0]
                                       userTagAcEnable[GT_FALSE]
                                   }}},
                            unknownSaCommandEnable[GT_FALSE]
                            unknownSaCommand[   CPSS_PACKET_CMD_FORWARD_E ]}
                        and other parameters from 1.67.
            */
            action.egressPolicy = GT_FALSE;
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            ruleOptionsBmp = 0;

            cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
            pattern.ruleStdNotIp.common.pclId = 0;
            pattern.ruleStdNotIp.common.sourcePort = 5;
            pattern.ruleStdNotIp.common.isTagged = 1;
            pattern.ruleStdNotIp.common.vid = 100;
            pattern.ruleStdNotIp.common.up = 0;
            pattern.ruleStdNotIp.common.qosProfile = 0;
            pattern.ruleStdNotIp.common.isIp = 0;
            pattern.ruleStdNotIp.common.isL2Valid = 1;
            pattern.ruleStdNotIp.common.isUdbValid = 1;
            pattern.ruleStdNotIp.isIpv4 = 0;
            pattern.ruleStdNotIp.etherType = 0;
            pattern.ruleStdNotIp.isArp = 0;
            pattern.ruleStdNotIp.l2Encap = 0;
            pattern.ruleStdNotIp.macDa = mac2;
            pattern.ruleStdNotIp.macSa = mac1;
            pattern.ruleStdNotIp.udb15_17[0] = 10;
            pattern.ruleStdNotIp.udb15_17[1] = 20;
            pattern.ruleStdNotIp.udb15_17[2] = 30;

            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            mask.ruleStdNotIp = pattern.ruleStdNotIp;
            mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/
            mask.ruleStdNotIp.common.sourcePort = 0x3F;

            action.mirror.mirrorToRxAnalyzerPort = GT_TRUE;
            action.mirror.ingressMirrorToAnalyzerIndex = 0;
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E;
            action.redirect.data.modifyMacSa.macSa = macSa1;
            action.redirect.data.modifyMacSa.arpPtr = 0;
            action.oam.timeStampEnable = GT_FALSE;
            action.oam.offsetIndex = 0;
            action.oam.oamProcessEnable = GT_FALSE;
            action.oam.oamProfile = 0;
            action.sourcePort.assignSourcePortEnable = GT_FALSE;
            action.sourcePort.sourcePortValue = 0;
            action.qos.ingress.up1Cmd = CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_DO_NOT_MODIFY_E;
            action.qos.ingress.up1 = 0;
            action.vlan.ingress.vlanId1Cmd = CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_DO_NOT_MODIFY_E;
            action.vlan.ingress.vlanId1 = 0;
            action.flowId = 0;
            action.setMacToMe = GT_FALSE;
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E;
            action.redirect.data.logicalSourceInterface.logicalInterface.type = CPSS_INTERFACE_PORT_E;
            action.redirect.data.logicalSourceInterface.logicalInterface.devPort.hwDevNum = dev;
            action.redirect.data.logicalSourceInterface.logicalInterface.devPort.portNum = 0;
            action.redirect.data.logicalSourceInterface.sourceMeshIdSetEnable = GT_FALSE;
            action.redirect.data.logicalSourceInterface.sourceMeshId = 0;
            action.redirect.data.logicalSourceInterface.userTagAcEnable = GT_FALSE;
            action.unknownSaCommandEnable = GT_FALSE;
            action.unknownSaCommand = CPSS_PACKET_CMD_FORWARD_E;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /*
                Call function with
                        action{
                            redirect {
                               data {
                                   logicalSourceInterface{
                                       sourceMeshIdSetEnable[GT_TRUE]
                                       sourceMeshId[1]
                                       userTagAcEnable[GT_TRUE]
                                   }}},
                            unknownSaCommandEnable[GT_TRUE]
                            unknownSaCommand[ CPSS_PACKET_CMD_MIRROR_TO_CPU_E ]}
                        and other parameters from 1.67.
            */
            action.redirect.data.logicalSourceInterface.sourceMeshIdSetEnable = GT_TRUE;
            action.redirect.data.logicalSourceInterface.sourceMeshId = 1;
            action.redirect.data.logicalSourceInterface.userTagAcEnable = GT_TRUE;
            action.unknownSaCommandEnable = GT_TRUE;
            action.unknownSaCommand = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            /*
                Call function with
                        action{
                            redirect {
                               data {
                                   logicalSourceInterface{
                                       sourceMeshId[3]
                                   }}},
                            unknownSaCommand[   CPSS_PACKET_CMD_TRAP_TO_CPU_E ]}
                        and other parameters from 1.67.
            */

            action.redirect.data.logicalSourceInterface.sourceMeshId = 3;
            action.unknownSaCommand = CPSS_PACKET_CMD_TRAP_TO_CPU_E;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            /*
                Call function with
                        action{
                            unknownSaCommand[   CPSS_PACKET_CMD_DROP_HARD_E ]}
                        and other parameters from 1.67.
            */
            action.unknownSaCommand = CPSS_PACKET_CMD_DROP_HARD_E;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            /*
                Call function with
                        action{
                            unknownSaCommand[   CPSS_PACKET_CMD_DROP_SOFT_E ]}
                        and other parameters from 1.67.
            */
            action.unknownSaCommand = CPSS_PACKET_CMD_DROP_SOFT_E;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }
        /*
            1.87. Call function with out of range sourceMeshId [4]
                   and other parameters from 1.67.
            Expected: GT_OK  for xCat C0; xCat3.
        */
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.redirect.data.logicalSourceInterface.sourceMeshId = 4;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.redirect.data.logicalSourceInterface.sourceMeshId = 0;
        }

        /*
            1.88. Call function with out of range unknownSaCommand
                   and other parameters from 1.67.
            Expected: GT_OK  for xCat C0; xCat3.
        */
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleSet
                                (dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                 &mask, &pattern, &action),
                                action.unknownSaCommand);

            st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChPclRuleInvalidate: %d, %d, %d",
                                         dev, ruleSize, ruleIndex);
        }
        /*
            1.89. For bobCat2 and above, call cpssDxChPclRuleSet with
                  ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                  ruleIndex [PCL_TESTED_RULE_INDEX],
                  ruleOptionsBmp[CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E];
                  mask.ruleStdNotIp.common.pclId = 0x3FF,
                  pattern.ruleStdNotIp.common.pclId = 0,
                  action.copyReserved.assignEnable = GT_TRUE,
                  action.copyReserved.copyReserved = 0x15A and
                  get the value of the action from the same index using
                  cpssDxChPclRuleActionGet. Check for same value of actions
            Expected: GT_OK and same values of actions
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.egressPolicy = GT_FALSE;
            ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
            ruleOptionsBmp = CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E;
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;

            cpssOsMemSet(&mask, 0, sizeof(mask));
            cpssOsMemSet(&pattern, 0, sizeof(pattern));
            cpssOsMemSet(&action, 0, sizeof(action));
            cpssOsMemSet(&actionGet, 0, sizeof(actionGet));

            pattern.ruleStdNotIp.common.pclId = 0;
            mask.ruleStdNotIp.common.pclId = 0x3FF;
            action.copyReserved.assignEnable = GT_TRUE;
            action.copyReserved.copyReserved = 0x15A;

            st = cpssDxChPclRuleSet(
                        dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                        &mask, &pattern, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                "%d, %d, %d, action.copyReserved.copyReserved = %d",
                                dev, ruleFormat, ruleIndex, action.copyReserved.copyReserved);

            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_INGRESS_E,
                                          &actionGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                                "%d, %d, %d",dev, ruleSize, ruleIndex);

            /* verify values */
            UTF_VERIFY_EQUAL1_STRING_MAC(action.copyReserved.assignEnable, actionGet.copyReserved.assignEnable,
                                        "get another action.copyReserved.assignEnable than was set: %d", dev);

            UTF_VERIFY_EQUAL1_STRING_MAC(action.copyReserved.copyReserved, actionGet.copyReserved.copyReserved,
                                        "get another action.copyReserved.copyReserved than was set: %d", dev);

           action.copyReserved.copyReserved = 0; /* restore valid value */
        }

        /*
            1.90. For Falcon and above, call cpssDxChPclRuleSet with
                      ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                      ruleIndex [PCL_TESTED_RULE_INDEX],
                      ruleOptionsBmp[CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E];
                      mask.ruleStdNotIp.common.pclId = 0x3FF,
                      pattern.ruleStdNotIp.common.pclId = 0,
                      action.triggerHashCncClient = GT_TRUE
                      get the value of the action from the same index using
                      cpssDxChPclRuleActionGet. Check for same value of actions
                Expected: GT_OK and same values of actions
         */
        if(PRV_CPSS_SIP_6_CHECK_MAC(dev))
        {
            action.egressPolicy = GT_FALSE;
            ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
            ruleOptionsBmp = CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E;
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;

            cpssOsMemSet(&mask, 0, sizeof(mask));
            cpssOsMemSet(&pattern, 0, sizeof(pattern));
            cpssOsMemSet(&action, 0, sizeof(action));
            cpssOsMemSet(&actionGet, 0, sizeof(actionGet));

            pattern.ruleStdNotIp.common.pclId = 0;
            mask.ruleStdNotIp.common.pclId = 0x3FF;
            action.triggerHashCncClient = GT_TRUE;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,"%d, %d, %d, action.triggerHashCncClient = %d",
                                         dev, ruleFormat, ruleIndex, action.triggerHashCncClient);

            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_INGRESS_E, &actionGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "%d, %d, %d",dev, ruleSize, ruleIndex);

            /* verify values */
            UTF_VERIFY_EQUAL1_STRING_MAC(action.triggerHashCncClient, actionGet.triggerHashCncClient,
                                        "get another action.triggerHashCncClient than was set: %d", dev);

           action.triggerHashCncClient = GT_FALSE; /* restore valid value */
        }
        /*
           1.91. Test for PHA actions
           For Falcon and above, call cpssDxChPclRuleSet with
           ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
           ruleIndex [PCL_TESTED_RULE_INDEX],
           ruleOptionsBmp[CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E];
           mask.ruleStdNotIp.common.pclId = 0x3FF,
           pattern.ruleStdNotIp.common.pclId = 0,
           action.triggerHashCncClient = GT_TRUE
           get the value of the action from the same index using
           cpssDxChPclRuleActionGet. Check for same value of actions
            Expected: GT_OK and same values of actions
         */
        if(PRV_CPSS_SIP_6_CHECK_MAC(dev) && (0 != PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.phaInfo.numOfPpg))
        {
            /*1. Pha lib un intialized
              2. mode:
              PHA Disabled
              PHA bypass
              3. mode: PHA enable
              (phaThreadType, phaThreadUnion)
             */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
            cpssOsMemSet(&mask, 0, sizeof(mask));
            cpssOsMemSet(&pattern, 0, sizeof(pattern));
            cpssOsMemSet(&action, 0, sizeof(action));
            cpssOsMemSet(&actionGet, 0, sizeof(actionGet));

            action.egressPolicy = GT_TRUE;
            pattern.ruleStdNotIp.common.pclId = 0;
            mask.ruleStdNotIp.common.pclId = 0x3FF;

            /*1. PHA assign diable*/
            action.epclPhaInfo.phaThreadIdAssignmentMode = CPSS_DXCH_PCL_ACTION_EGRESS_PHA_THREAD_ID_ASSIGNMENT_MODE_DISABLED_E;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,"%d, %d, %d, phaThreadIdAssignmentMode = %d",
                    dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadIdAssignmentMode);

            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_EGRESS_E, &actionGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "%d, %d, %d",dev, ruleSize, ruleIndex);

            /* verify values */
            UTF_VERIFY_EQUAL1_STRING_MAC(action.epclPhaInfo.phaThreadIdAssignmentMode,
                    actionGet.epclPhaInfo.phaThreadIdAssignmentMode,
                    "phaThreadIdAssignmentMode mismatch dev: %d", dev);

            /*3. PHA assign bypass,
              expect GT_OK */
            action.epclPhaInfo.phaThreadIdAssignmentMode = CPSS_DXCH_PCL_ACTION_EGRESS_PHA_THREAD_ID_ASSIGNMENT_MODE_BYPASS_PHA_E;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,"%d, %d, %d, phaThreadIdAssignmentMode = %d",
                    dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadIdAssignmentMode);

            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_EGRESS_E, &actionGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "%d, %d, %d",dev, ruleSize, ruleIndex);

            /* verify values */
            UTF_VERIFY_EQUAL1_STRING_MAC(action.epclPhaInfo.phaThreadIdAssignmentMode,
                    actionGet.epclPhaInfo.phaThreadIdAssignmentMode,
                    "phaThreadIdAssignmentMode mismatch dev: %d", dev);

            /*5. PHA assign ENABLE, in valid thread id
              expect GT_OUT_OF_RANGE */
            action.epclPhaInfo.phaThreadIdAssignmentMode = CPSS_DXCH_PCL_ACTION_EGRESS_PHA_THREAD_ID_ASSIGNMENT_MODE_ENABLED_E;
            action.epclPhaInfo.phaThreadId = 0;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_BAD_PARAM, st,"%d, %d, %d, phaThreadId = %d",
                    dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadId);

            /*6. PHA assign ENABLE, in valid thread id
              expect GT_OUT_OF_RANGE */
            action.epclPhaInfo.phaThreadId = 256;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_BAD_PARAM, st,"%d, %d, %d, phaThreadId = %d",
                    dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadId);

            /*7. PHA assign ENABLE, valid thread id
              expect GT_OK */
            action.epclPhaInfo.phaThreadId = 10;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,"%d, %d, %d, phaThreadId = %d",
                    dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadId);

            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_EGRESS_E, &actionGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "%d, %d, %d",dev, ruleSize, ruleIndex);

            /* verify values */
            UTF_VERIFY_EQUAL1_STRING_MAC(action.epclPhaInfo.phaThreadId,
                    actionGet.epclPhaInfo.phaThreadId,
                    "phaThreadId mismatch dev: %d", dev);

            /*8. PHA assign ENABLE, valid thread id
              expect GT_OK */

            for (phaThrType = CPSS_DXCH_PCL_ACTION_EGRESS_PHA_THREAD_IOAM_INGRESS_SWITCH_E;
                    phaThrType != CPSS_DXCH_PCL_ACTION_EGRESS_PHA_THREAD___LAST___E;
                    phaThrType++)
            {
                action.epclPhaInfo.phaThreadType = actionGet.epclPhaInfo.phaThreadType = phaThrType;
                cpssOsMemSet(&action.epclPhaInfo.phaThreadUnion, 0, sizeof(action.epclPhaInfo.phaThreadUnion));
                cpssOsMemSet(&actionGet.epclPhaInfo.phaThreadUnion, 0, sizeof(action.epclPhaInfo.phaThreadUnion));
                switch (phaThrType)
                {
                    case CPSS_DXCH_PCL_ACTION_EGRESS_PHA_THREAD_IOAM_INGRESS_SWITCH_E:
                        action.epclPhaInfo.phaThreadUnion.epclIoamIngressSwitch.ioamIncludesBothE2EOptionAndTraceOption= GT_TRUE;

                        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,"%d, %d, %d, phaThreadType = %d",
                                dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_EGRESS_E, &actionGet);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d phaThrType %d",dev, ruleSize, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssOsMemCmp(&action.epclPhaInfo.phaThreadUnion, &actionGet.epclPhaInfo.phaThreadUnion, sizeof (actionGet.epclPhaInfo.phaThreadUnion)) ;
                        UTF_VERIFY_EQUAL1_STRING_MAC(0, st, "phaThrType %d data mismatch ", phaThrType);

                        break;

                    case CPSS_DXCH_PCL_ACTION_EGRESS_PHA_THREAD_INT_IOAM_MIRROR_E:
                        action.epclPhaInfo.phaThreadUnion.epclIntIoamMirror.erspanIII_P = GT_TRUE;
                        action.epclPhaInfo.phaThreadUnion.epclIntIoamMirror.erspanIII_FT = 10;

                        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,"%d, %d, %d, phaThreadType = %d",
                                dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_EGRESS_E, &actionGet);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d phaThrType %d",dev, ruleSize, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssOsMemCmp(&action.epclPhaInfo.phaThreadUnion, &actionGet.epclPhaInfo.phaThreadUnion, sizeof (actionGet.epclPhaInfo.phaThreadUnion)) ;
                        UTF_VERIFY_EQUAL1_STRING_MAC(0, st, "phaThrType %d data mismatch ", phaThrType);

                        action.epclPhaInfo.phaThreadUnion.epclIntIoamMirror.erspanIII_FT = 0x20;
                        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OUT_OF_RANGE, st,"%d, %d, %d, phaThreadType = %d",
                                dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadType);
                        break;

                    case CPSS_DXCH_PCL_ACTION_EGRESS_PHA_THREAD_CLASSIFIER_NSH_OVER_VXLAN_GPE_E:
                        action.epclPhaInfo.phaThreadUnion.epclClassifierNshOverVxlanGpe.classifierNshOverVxlanGpe_TenantID = 0x10000;
                        action.epclPhaInfo.phaThreadUnion.epclClassifierNshOverVxlanGpe.classifierNshOverVxlanGpe_SourceClass = 0x5678;
                        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OUT_OF_RANGE, st,"%d, %d, %d, phaThreadType = %d",
                                dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadType);

                        action.epclPhaInfo.phaThreadUnion.epclClassifierNshOverVxlanGpe.classifierNshOverVxlanGpe_TenantID = 0x1234;
                        action.epclPhaInfo.phaThreadUnion.epclClassifierNshOverVxlanGpe.classifierNshOverVxlanGpe_SourceClass = 0x10000;
                        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OUT_OF_RANGE, st,"%d, %d, %d, phaThreadType = %d",
                                dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadType);

                        action.epclPhaInfo.phaThreadUnion.epclClassifierNshOverVxlanGpe.classifierNshOverVxlanGpe_TenantID = 0x1234;
                        action.epclPhaInfo.phaThreadUnion.epclClassifierNshOverVxlanGpe.classifierNshOverVxlanGpe_SourceClass = 0x5678;

                        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,"%d, %d, %d, phaThreadType = %d",
                                dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_EGRESS_E, &actionGet);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d phaThrType %d",dev, ruleSize, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssOsMemCmp(&action.epclPhaInfo.phaThreadUnion, &actionGet.epclPhaInfo.phaThreadUnion, sizeof (actionGet.epclPhaInfo.phaThreadUnion)) ;
                        UTF_VERIFY_EQUAL1_STRING_MAC(0, st, "phaThrType %d data mismatch ", phaThrType);

                        break;

                    case CPSS_DXCH_PCL_ACTION_EGRESS_PHA_THREAD_ERSPAN_TYPE_II_MIRROR_E:
                        action.epclPhaInfo.phaThreadUnion.epclErspanTypeIImirror.erspanAnalyzerIndex = 0;

                        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,"%d, %d, %d, phaThreadType = %d",
                                dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_EGRESS_E, &actionGet);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d phaThrType %d",dev, ruleSize, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssOsMemCmp(&action.epclPhaInfo.phaThreadUnion, &actionGet.epclPhaInfo.phaThreadUnion, sizeof (actionGet.epclPhaInfo.phaThreadUnion)) ;
                        UTF_VERIFY_EQUAL1_STRING_MAC(0, st, "phaThrType %d data mismatch ", phaThrType);


                        action.epclPhaInfo.phaThreadUnion.epclErspanTypeIImirror.erspanAnalyzerIndex = 6;

                        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,"%d, %d, %d, phaThreadType = %d",
                                dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_EGRESS_E, &actionGet);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d phaThrType %d",dev, ruleSize, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssOsMemCmp(&action.epclPhaInfo.phaThreadUnion, &actionGet.epclPhaInfo.phaThreadUnion, sizeof (actionGet.epclPhaInfo.phaThreadUnion)) ;
                        UTF_VERIFY_EQUAL1_STRING_MAC(0, st, "phaThrType %d data mismatch ", phaThrType);

                        action.epclPhaInfo.phaThreadUnion.epclErspanTypeIImirror.erspanAnalyzerIndex = 7;
                        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OUT_OF_RANGE, st,"%d, %d, %d, phaThreadType = %d",
                                dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadType);
                        break;

                    case CPSS_DXCH_PCL_ACTION_EGRESS_PHA_THREAD_SFLOW_V5_MIRROR_E:
                        action.epclPhaInfo.phaThreadUnion.epclSflowV5Mirror.sflowSamplingRate = 100;

                        st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,"%d, %d, %d, phaThreadType = %d",
                                dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_EGRESS_E, &actionGet);
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d phaThrType %d",dev, ruleSize, ruleIndex, action.epclPhaInfo.phaThreadType);
                        st = cpssOsMemCmp(&action.epclPhaInfo.phaThreadUnion, &actionGet.epclPhaInfo.phaThreadUnion, sizeof (actionGet.epclPhaInfo.phaThreadUnion)) ;
                        UTF_VERIFY_EQUAL1_STRING_MAC(0, st, "phaThrType %d data mismatch ", phaThrType);

                        break;

                    default:
                        UTF_VERIFY_EQUAL4_STRING_MAC(GT_NOT_IMPLEMENTED, st,"%d, %d, %d, PHA pcl action Not implemented for phaThreadType = %d",
                                dev, ruleFormat, ruleIndex, action.epclPhaInfo.phaThreadType);
                        break;
                }
            }

            cpssOsMemSet(&action, 0, sizeof(action));
            cpssOsMemSet(&actionGet, 0, sizeof(actionGet));
        } /*EPCL PHA TC ends*/
        else
        {
            PRV_UTF_LOG0_MAC("********EPCL PHA action skipped********\n");
        }

        /*
            1.92. For Ironman and above, call cpssDxChPclRuleSet with
                      ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                      ruleIndex [PCL_TESTED_RULE_INDEX],
                      mask.ruleStdNotIp.common.pclId = 0x3FF,
                      pattern.ruleStdNotIp.common.pclId = 0,
                      action.egressPolicy = GT_TRUE;
                      action.egressCncIndexMode = CPSS_DXCH_PCL_ACTION_EGRESS_CNC_INDEX_MODE_MAX_SDU_PASS_FAIL_E;
                      action.egressMaxSduSizeProfile = 0x1;
                      action.enableEgressMaxSduSizeCheck = GT_TRUE;
                      get the value of the actions from the same index using
                      cpssDxChPclRuleActionGet. Check for same value of actions
                Expected: GT_OK and same values of actions
         */
        if(PRV_CPSS_SIP_6_30_CHECK_MAC(dev))
        {
            ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;

            cpssOsMemSet(&mask, 0, sizeof(mask));
            cpssOsMemSet(&pattern, 0, sizeof(pattern));
            cpssOsMemSet(&action, 0, sizeof(action));
            cpssOsMemSet(&actionGet, 0, sizeof(actionGet));

            pattern.ruleStdNotIp.common.pclId = 0;
            mask.ruleStdNotIp.common.pclId = 0x3FF;
            action.egressPolicy = GT_TRUE;
            action.egressCncIndexMode = CPSS_DXCH_PCL_ACTION_EGRESS_CNC_INDEX_MODE_MAX_SDU_PASS_FAIL_E;
            action.egressMaxSduSizeProfile = 0x1;
            action.enableEgressMaxSduSizeCheck = GT_TRUE;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp, &mask, &pattern, &action);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,"%d, %d, %d \n", dev, ruleFormat, ruleIndex);

            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, CPSS_PCL_DIRECTION_EGRESS_E, &actionGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "%d, %d, %d",dev, ruleSize, ruleIndex);

            /* Verify values */
            UTF_VERIFY_EQUAL1_STRING_MAC(action.egressCncIndexMode, actionGet.egressCncIndexMode,
                                        "get another action.egressCncIndexMode than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(action.egressMaxSduSizeProfile, actionGet.egressMaxSduSizeProfile,
                                        "get another action.egressMaxSduSizeProfile than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(action.enableEgressMaxSduSizeCheck, actionGet.enableEgressMaxSduSizeCheck,
                                        "get another action.enableEgressMaxSduSizeCheck than was set: %d", dev);

           /* Restore valid value */
           action.egressCncIndexMode = CPSS_DXCH_PCL_ACTION_EGRESS_CNC_INDEX_MODE_HIT_COUNTER_E;
           action.egressMaxSduSizeProfile = 0x0;
           action.enableEgressMaxSduSizeCheck = GT_FALSE;
        }
    }

    /* Set valid parameters. As soon as family of device can't be determined */
    /* - values valid for any family                                         */
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    ruleIndex = 0;
    cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
    cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclRuleSet(
        dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
        &mask, &pattern, &action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclRuleActionUpdate
(
    IN GT_U8                              devNum,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN CPSS_DXCH_PCL_ACTION_STC           *actionPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclRuleActionUpdate)
{
/*
    ITERATE_DEVICES
    1.1. Set rule for testing.  Call cpssDxChPclRuleSet with
        ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
        ruleIndex [PCL_TESTED_RULE_INDEX],
        maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ...],
        patternPtr-> ruleStdNotIp [ common[pclId=0; sourcePort=5; isTagged=1;
            vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1; isUdbValid =1],
            isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
            macSa=AB:CD:EF:00:00:01; udb[10,20,30] ],
        actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
            mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
            matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
            qos { egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE ,
                qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
                profilePrecedence=GT_FALSE] ] },
            redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                data[routerLttIndex=0] },
            policer { policerEnable=GT_FALSE, policerId=0 },
            vlan { egressTaggedModify=GT_FALSE,
                modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
                vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
            ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
    Expected: GT_OK.
    1.2. For all devices update action with legal parameters.
    Call with ruleSize [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX],
    actionPtr is the same as in 1.1.
    Expected: GT_OK.
    1.3. Call cpssDxChPclRuleActionGet with ruleSize[CPSS_PCL_RULE_SIZE_STD_E],
    ruleIndex [PCL_TESTED_RULE_INDEX], direction [CPSS_PCL_DIRECTION_INGRESS_E],
    non-NULL actionPtr.
    Expected: GT_OK and same values in actionPtr as were written.

    1.4. Check with rule size for other type of rule.
    Call with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], ruleIndex [PCL_TESTED_RULE_INDEX],
    actionPtr is the same as in 1.1.
    Expected: NOT GT_OK.
    1.5. For eArch devices call with ruleSize[CPSS_PCL_RULE_SIZE_ULTRA_E]
        and other params same as 1.1.
    Expected: GT_OK.
    1.6. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], valid
        actionPtr->flowId[100](is relevant) and other params same as 1.1.
    Expected: GT_OK.
    1.7. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
        actionPtr->oam.offsetIndex[15], actionPtr->oam.oamProcessEnable[GT_TRUE],
        actionPtr->oam.oamProfile[1] and other params same as 1.1.
    Expected: GT_OK.

    1.8. Check invalid rule size value.  Call with ruleSize [wrong enum values],
    ruleIndex [PCL_TESTED_RULE_INDEX], actionPtr is the same as in 1.1.
    Expected: GT_BAD_PARAM.
    1.9. Call with out of range ruleIndex and other parameters is the same as in 1.2.
    Expected: NON GT_OK.
    1.10. Call with out of range actionPtr->matchCounter.matchCounterIndex [32]
       and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3.
    1.11. For Ch3 and above call with
    out of range actionPtr->matchCounter.matchCounterIndex [16384]
    and other params from 1.1.
    Expected: NOT GT_OK.
    1.12. Call with out of range actionPtr->policer.policerId [policersTableSize]
    and other params from 1.1.
    Expected: NOT GT_OK
    1.13. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                   actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                   out of range actionPtr->redirect.outIf.tunnelPtr[1024]
                   and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.
    1.14. For Ch3 and above call with actionPtr->redirect.redirectCmd
                [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
           actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
           out of range actionPtr->redirect.outIf.tunnelPtr[8192]
           and other params from 1.1.
    Expected: NOT GT_OK.
    1.15. Call with actionPtr->redirect.redirectCmd
                        [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                   out of range actionPtr->redirect.data.routerLttIndex[8192]
                   and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2/Ch3 and GT_OK for xCat and above.
    1.16. For xCat and above call with actionPtr->redirect.redirectCmd
                        [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                   out of range actionPtr->redirect.data.routerLttIndex[32768]
                   and other params from 1.1.
    Expected: NOT GT_OK.
    1.17. For Ch3 and above call with actionPtr->redirect.redirectCmd
                        [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E],
                   out of range actionPtr->redirect.data.vrfId [4096]
                   and other params from 1.1.
    Expected: NOT GT_OK.
    1.18. Call with actionPtr->vlan.ingress.modifyVlan
                        [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
                   out of range actionPtr->vlan.ingress.vlanId [4096]
                   and other params from 1.1.
    Expected: NOT GT_OK.
    1.19. For Ch3 and above call with out of range
    actionPtr->sourceId.sourceIdValue [32] and other params from 1.1.
    Expected: NOT GT_OK.

    1.20. Call with out of range actionPtr->pktCmd
    Expected: GT_BAD_PARAM
    1.21. Call with not valid actionPtr->pktCmd
                                  [CPSS_PACKET_CMD_ROUTE_E
                                   CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E
                                   CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E
                                   CPSS_PACKET_CMD_BRIDGE_E ]
    Expected: NOT GT_OK
    1.22. Call with out of range actionPtr->lookupConfig.pcl0_1OverrideConfigIndex,
          other parameters is the same as in 1.1.
    Expected: GT_BAD_PARAM for DxCh3 and above
    1.23. Call with out of range actionPtr->lookupConfig.pcl1OverrideConfigIndex,
          other parameters is the same as in 1.1.
    Expected: GT_BAD_PARAM
    1.24. Call with out of range actionPtr->mirror.cpuCode
    Expected: GT_BAD_PARAM
    1.25. Call with out of range actionPtr->mirror.ingressMirrorToAnalyzerIndex[7 / 8] (relevant for Lion2)
    Expected: NOT GT_OK for Lion2 and GT_OK for others.
    1.26. Call with out of range actionPtr->qos.ingress.modifyDscp
    Expected: GT_BAD_PARAM
    1.27. Call with out of range actionPtr->qos.ingress.modifyUp
    Expected: GT_BAD_PARAM
    1.28. Call with out of range actionPtr->qos.ingress.profileIndex
                [72] for DxCh1
                [256] for Lion2
                [128] for others -- DxCh2, DxCh3, xCat, Lion, xCat2
    Expected: NOT GT_OK
    1.29. Call with valid actionPtr->qos.ingress.profileIndex
                [0 / 15 / 36 / 71] for DxCh1
                [0 / / 45 / 64 / 127 ] for DxCh2, DxCh3, xCat, Lion, xCat2
                [0 / 127 / 128 / 255] for Lion2
    Expected: GT_OK
    1.30. Call with out of range actionPtr->qos.ingress.up1Cmd
          relevant for lion2.
    Expected: GT_BAD_PARAM
    1.31. Call with out of range actionPtr->qos.ingress.up1 [8]
          relevant for lion2.
    Expected: NOT GT_OK and GT_OK for others.
    1.32. Call with out of range actionPtr->qos.egress.modifyUp
    Expected: GT_BAD_PARAM.
    1.33. Call with actionPtr->vlan.ingress.modifyVlan [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
           out of range actionPtr->vlan.ingress.vlanId1 [4096]
           and other params from 1.1.
    Expected: NOT GT_OK.
    1.34. Call with actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE],
          out of range actionPtr->ipUcRoute.arpDaIndex [1024]
          and other params from 1.1.
    Expected: NOT GT_OK.
    1.35. Call with relevant actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE],
           out of range actionPtr->ipUcRoute.arpDaIndex [0 / 512 / 1023]
           and other params from 1.1.
    Expected: NOT GT_OK.
    1.36. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_TRUE], out of range
           actionPtr->flowId[0x10000](not relevant) and other params same as 1.1.
    Expected: GT_OK.
    1.37. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], out of range
           actionPtr->flowId[0x10000](is relevant) and other params same as 1.1.
    Expected: NOT GT_OK.
    1.38. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
           actionPtr->oam.oamProcessEnable[GT_TRUE],
           actionPtr->oam.oamProfile[1], out of range actionPtr->oam.offsetIndex[16],
           and other params same as 1.1.
    Expected: NOT GT_OK.
    1.39. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
           actionPtr->oam.oamProcessEnable[GT_TRUE],
           actionPtr->oam.offsetIndex[15], out of range actionPtr->oam.oamProfile[2],
           and other params same as 1.1.
    Expected: NOT GT_OK.
    1.40. Check for NULL pointer. Call with actionPtr [NULL],
    other parameters same as in 1.2.
    Expected: GT_BAD_PTR.
    1.41. Call function with
            actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[0 / 3 / 6]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_REPLACE_MAC_SA_E],
                           data { modifyMacSa {macSa [00:00:00:00:00:00 /
                                                      A5:A5:A5:A5:A5:A5 /
                                                      FF:FF:FF:FF:FF:FF],
                                               arpPtr[0 / 0xA5A5 / BIT_17-1]}}},
                        oam { timeStampEnable [GT_FALSE / GT_TRUE],
                              offsetIndex [0 / 0xA / BIT_4-1],
                              oamProcessEnable [GT_FALSE / GT_TRUE],
                              oamProfile [0 / 1] },
                        sourcePort { assignSourcePortEnable [GT_FALSE / GT_TRUE]
                                 sourcePortValue [0 / 0xA5A5A5A5 / 0xFFFFFFFF] }
                        qos { ingress { up1Cmd[
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_DO_NOT_MODIFY_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG1_UNTAGGED_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG0_UNTAGGED_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_ALL_E],
                                       up1[0 / 5 / BIT_3-1]} }
                        vlan { ingress { vlanId1Cmd[
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_DO_NOT_MODIFY_E /
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_UNTAGGED_E /
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_ALL_E],
                                       vlanId1 [0 / 0xA5A / BIT_12-1]} },
                        flowId [0 / 0xA5A / BIT_12-1],
                        setMacToMe [GT_FALSE / GT_TRUE] }
            and other params from 1.1.
    Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
    1.42. Call cpssDxChPclRuleActionGet with params same as 1.1.
    Expected: GT_OK and same values in actionPtr as were written.
    1.43. Call function with out of range ingressMirrorToAnalyzerIndex [7]
           and other parameters from 1.41.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.44. Call function with out of range redirectCmd
           and other parameters from 1.41.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.45. Call function with out of range offsetIndex [BIT_4]
           and other parameters from 1.41.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.46. Call function with out of range oamProfile [2]
           and other parameters from 1.41.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.47. Call function with out of range up1Cmd
           and other parameters from 1.41.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.48. Call function with out of range up1 [BIT_3]
           and other parameters from 1.41.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.49. Call function with out of range vlanId1Cmd
           and other parameters from 1.41.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.50. Call function with out of range vlanId1 [BIT_12]
           and other parameters from 1.41.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.51. Call function with out of range flowId [BIT_12]
           and other parameters from 1.41.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.52. Call function with out of range sourcePortValue [BIT_13]
           and other parameters from 1.41.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.53. Call function with out of range arpPtr [BIT_17]
           and other parameters from 1.41.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.54. Call function with
            actionPtr { egressPolicy [GT_TRUE]
                        qos { egress { modifyDscp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_OUTER_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_INNER_E],
                                      modifyUp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                      up1ModifyEnable [GT_FALSE / GT_TRUE],
                                      up1[0 / 5 / BIT_3-1]} }
                        vlan { egress { vlanCmd[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                       vlanId1ModifyEnable [GT_FALSE / GT_TRUE],
                                       vlanId1 [0 / 0xA5A / BIT_12-1]} },
                        channelTypeToOpcodeMapEnable [GT_FALSE / GT_TRUE],
                        tmQueueId [0 / 0x2A5A / BIT_14-1] }
            and other params from 1.41.
    Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
    1.55. Call cpssDxChPclRuleActionGet with params same as 1.53.
    Expected: GT_OK and same values in actionPtr as were written.
    1.56. Call function with out of range modifyDscp
           and other parameters from 1.54.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.57. Call function with out of range modifyUp
           and other parameters from 1.54.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.58. Call function with out of range up1 [BIT_3]
           and other parameters from 1.54.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.59. Call function with out of range vlanCmd
           and other parameters from 1.54.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.60. Call function with out of range vlanId1 [BIT_12]
           and other parameters from 1.54.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.61. Call function with out of range tmQueueId [BIT_14]
           and other parameters from 1.54.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.62. Call function with
            action{
                redirect {
                   redirectCmd [
                    CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                   data {
                       logicalSourceInterface{
                           logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                             devPort {devNum=dev, portNum=0} ]
                           sourceMeshIdSetEnable[GT_TRUE/GT_FALSE]
                           sourceMeshId[0/1/3]
                           userTagAcEnable[GT_TRUE/GT_FALSE]
                       }}},
                unknownSaCommandEnable[GT_TRUE/GT_FALSE]
                unknownSaCommand[   CPSS_PACKET_CMD_FORWARD_E /
                                    CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                    CPSS_PACKET_CMD_TRAP_TO_CPU_E /
                                    CPSS_PACKET_CMD_DROP_HARD_E /
                                    CPSS_PACKET_CMD_DROP_SOFT_E]}
            and other parameters from 1.54.
    Expected: GT_OK  for xCat C0; xCat3.

    1.63. Call function with out of range sourceMeshId [4]
           and other parameters from 1.54.
    Expected: GT_OK  for xCat C0; xCat3.

    1.64. Call function with out of range unknownSaCommand
           and other parameters from 1.54.
    Expected: GT_OK  for xCat C0; xCat3.
    1.66. For bobCat2 and above call with out of range
            actionPtr->copyReserved.copyReserved and other params from 1.54
            Expected: GT_OUT_OF_RANGE.
    1.67 Call function with action.pktcmd = CPSS_PACKET_CMD_MIRROR_TO_CPU_E
                                    action.mirror.cpuCode = CPSS_NET_CONTROL_SRC_DST_MAC_TRAP_E
                 Call function with action.pktcmd = CPSS_PACKET_CMD_TRAP_TO_CPU_E
                                    action.mirror.cpuCode = CPSS_NET_CONTROL_SRC_DST_MAC_TRAP_E
    Expected: GT_OK. for Falcon

    1.68 Call function with action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ECMP_E;
                                    action.redirect.data.routerLttIndex = 964;
    Expected: GT_OK and same values in actionPtr as were written for AC5P.
    1.69 Call function with action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ECMP_E;
                                    action.redirect.data.routerLttIndex = 964;
    Expected: GT_OK and same values in actionPtr as were written for AC5P.

    1.70. Call cpssDxChPclRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
    ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
    Expected: GT_OK.
    */
    GT_STATUS       st = GT_OK;
    GT_U32          policersTableSize = 0;

    GT_U8                               dev;
    CPSS_PCL_RULE_SIZE_ENT              ruleSize;
    GT_U32                              ruleIndex;
    CPSS_DXCH_PCL_ACTION_STC            action;
    CPSS_DXCH_PCL_ACTION_STC            actionGet;

    GT_BOOL                             isEqual     = GT_FALSE;
    CPSS_PCL_DIRECTION_ENT              direction;
    CPSS_DXCH_PCL_ACTION_STC            retAction;
    GT_BOOL                             failureWas;
    CPSS_PP_FAMILY_TYPE_ENT             devFamily;
    GT_BOOL                     support_doIpUcRoute;/*indication that current device supports 'doIpUcRoute' */
    GT_ETHERADDR                macSa1 = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
    GT_ETHERADDR                macSa2 = {{0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5}};
    GT_ETHERADDR                macSa3 = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        pclActionDefaultSet(&action);
        direction = CPSS_PCL_DIRECTION_INGRESS_E;

        /* get device family */
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            support_doIpUcRoute = GT_FALSE;
        }
        else
        {
            support_doIpUcRoute = GT_TRUE;
        }

        /* get table sizes for current device */
        st = cpssDxChCfgTableNumEntriesGet(dev,
                    CPSS_DXCH_CFG_TABLE_POLICER_METERS_E, &policersTableSize);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChCfgTableNumEntriesGet: %d", dev);

        /*
            1.1. Set rule for testing.  Call cpssDxChPclRuleSet with
            ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
            ruleIndex [PCL_TESTED_RULE_INDEX],
            maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ...],
            patternPtr-> ruleStdNotIp [ common[pclId=0; sourcePort=5; isTagged=1;
                vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1; isUdbValid =1],
                isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
                macSa=AB:CD:EF:00:00:01; udb[10,20,30] ],
            actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
                mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
                matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
                qos { egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE ,
                    qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
                    profilePrecedence=GT_FALSE] ] },
                redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                    data[routerLttIndex=0] },
                policer { policerEnable=GT_FALSE, policerId=0 },
                vlan { egressTaggedModify=GT_FALSE,
                    modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
                    vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
                ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
            Expected: GT_OK.
        */
        st = pclRuleTestingDefaultSet(dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclRuleSet: %d", dev);

        /*
            1.2. For all devices update action with legal parameters.
            Call with ruleSize [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX],
            actionPtr is the same as in 1.1.
            Expected: GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

        /*
            1.3. Call cpssDxChPclRuleActionGet with ruleSize[CPSS_PCL_RULE_SIZE_STD_E],
            ruleIndex [PCL_TESTED_RULE_INDEX], direction [CPSS_PCL_DIRECTION_INGRESS_E],
            non-NULL actionPtr.
            Expected: GT_OK and same values in actionPtr as were written.
        */
        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                     dev, ruleSize, ruleIndex, direction);
        if (GT_OK == st)
        {
            /* verifying values */
            /*pktCmd*/
            UTF_VERIFY_EQUAL1_STRING_MAC(action.pktCmd, retAction.pktCmd,
                 "cpssDxChPclRuleActionGet: "
                 "get another action.pktCmd than was set: dev = %d", dev);

            if (devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
            {
                UTF_VERIFY_EQUAL1_STRING_MAC(action.actionStop, retAction.actionStop,
                 "cpssDxChPclRuleActionGet: "
                 "get another action.actionStop than was set: dev = %d", dev);
            }

            /*mirror*/
            failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&action.mirror,
                                            (const GT_VOID*)&retAction.mirror,
                                            sizeof(action.mirror))) ? GT_FALSE : GT_TRUE;
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                "cpssDxChPclRuleActionGet: "
                "get another action.mirror than was set: %d, %d, %d",
                                         dev, ruleSize, ruleIndex);

            /*matchCounter*/
            failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&action.matchCounter,
                                            (const GT_VOID*)&retAction.matchCounter,
                                            sizeof(action.matchCounter))) ? GT_FALSE : GT_TRUE;
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                "cpssDxChPclRuleActionGet: "
                "get another action.matchCounter than was set: %d, %d, %d",
                                         dev, ruleSize, ruleIndex);

            /*redirect*/
            if (devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
            {
                UTF_VERIFY_EQUAL3_STRING_MAC(action.redirect.redirectCmd,
                                             retAction.redirect.redirectCmd,
                     "cpssDxChPclRuleActionGet: "
                     "get another actionPtr->redirect.redirectCmd than was set: %d, %d, %d",
                                             dev, ruleSize, ruleIndex);
                UTF_VERIFY_EQUAL3_STRING_MAC(action.redirect.data.outIf.tunnelPtr,
                                             retAction.redirect.data.outIf.tunnelPtr,
                     "cpssDxChPclRuleActionGet: "
                     "get another actionPtr->redirect.data.outIf.tunnelPtr than was set: %d, %d, %d",
                                             dev, ruleSize, ruleIndex);
                UTF_VERIFY_EQUAL3_STRING_MAC(action.redirect.data.outIf.tunnelStart,
                                             retAction.redirect.data.outIf.tunnelStart,
                     "cpssDxChPclRuleActionGet: "
                     "get another actionPtr->redirect.data.outIf.tunnelStart than was set: %d, %d, %d",
                                             dev, ruleSize, ruleIndex);
                UTF_VERIFY_EQUAL3_STRING_MAC(action.redirect.data.outIf.tunnelType,
                                             retAction.redirect.data.outIf.tunnelType,
                     "cpssDxChPclRuleActionGet: "
                     "get another actionPtr->redirect.data.outIf.tunnelType than was set: %d, %d, %d",
                                             dev, ruleSize, ruleIndex);
                UTF_VERIFY_EQUAL3_STRING_MAC(action.redirect.data.outIf.vntL2Echo,
                                             retAction.redirect.data.outIf.vntL2Echo,
                     "cpssDxChPclRuleActionGet: "
                     "get another actionPtr->redirect.data.outIf.vntL2Echo than was set: %d, %d, %d",
                                             dev, ruleSize, ruleIndex);
            }

            /*policer*/
            failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&action.policer,
                                            (const GT_VOID*)&retAction.policer,
                                            sizeof(action.policer))) ? GT_FALSE : GT_TRUE;
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                "cpssDxChPclRuleActionGet: get another action.policer than was set: %d, %d, %d",
                                         dev, ruleSize, ruleIndex);

            /*vlan*/
            failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&action.vlan,
                                            (const GT_VOID*)&retAction.vlan,
                                            sizeof(action.vlan))) ? GT_FALSE : GT_TRUE;
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                "cpssDxChPclRuleActionGet: get another action.vlan than was set: %d, %d, %d",
                                         dev, ruleSize, ruleIndex);

        }

        /*
            1.4. Check with rule size for other type of rule.
            Call with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], ruleIndex [PCL_TESTED_RULE_INDEX],
            actionPtr is the same as in 1.1.
            Expected: NOT GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;
        /* maximal index of standard rule, invalid for exteded rule */
        /* RuleActionUpdate uses ruleIndex only for action HW index */
        /* calculation                                              */
         if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_TRUE) {
             ruleIndex = (PCL_TCAM_RAWS(dev));
        }
        else
            ruleIndex = (PCL_TCAM_RAWS(dev) * 4) - 1;


        st = cpssDxChPclRuleActionUpdate(
            dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

        ruleSize = CPSS_PCL_RULE_SIZE_STD_E; /* restore valid values */
        ruleIndex = PCL_TCAM_RAWS(dev) - 1;

        /*
            1.5. For eArch devices call with ruleSize[CPSS_PCL_RULE_SIZE_ULTRA_E]
                and other params same as 1.1.
            Expected: GT_OK.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            ruleSize = CPSS_PCL_RULE_SIZE_ULTRA_E;
            ruleIndex = PCL_TCAM_RAWS(dev) - 1;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

            ruleSize = CPSS_PCL_RULE_SIZE_STD_E; /* restore valid values */


        /*
            1.6. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], valid
                actionPtr->flowId[100](is relevant) and other params same as 1.1.
            Expected: GT_OK.
        */

            action.egressPolicy = GT_FALSE;
            action.flowId  = 100;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);


        /*
            1.7. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                actionPtr->oam.offsetIndex[15], actionPtr->oam.oamProcessEnable[GT_TRUE],
                actionPtr->oam.oamProfile[1] and other params same as 1.1.
            Expected: GT_OK.
        */

            action.oam.timeStampEnable = GT_TRUE;
            action.oam.offsetIndex  = 15;
            action.oam.oamProcessEnable = GT_TRUE;
            action.oam.oamProfile = 1;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);
        }

        /*
            1.8. Check invalid rule size value.  Call with ruleSize [wrong enum values],
            ruleIndex [PCL_TESTED_RULE_INDEX], actionPtr is the same as in 1.1.
            Expected: GT_BAD_PARAM.
        */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_FALSE)
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                                (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                                ruleSize);
        }

        /*
            1.9. Call with out of range ruleIndex and other parameters is the same as in 1.2.
            Expected: NON GT_OK.
        */
        ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

        /*
            1.10. Call with out of range actionPtr->matchCounter.matchCounterIndex [32]
               and other params from 1.1.
            Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3.
        */
        action.matchCounter.enableMatchCount = GT_TRUE;
        action.matchCounter.matchCounterIndex = 32;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->matchCounter.matchCounterIndex = %d",
                dev, ruleSize, ruleIndex, action.matchCounter.matchCounterIndex);

        /*
            1.11. For Ch3 and above call with
            out of range actionPtr->matchCounter.matchCounterIndex [16384/32768]
            and other params from 1.1.
            Expected: NOT GT_OK.
        */
        action.matchCounter.matchCounterIndex = 16384;
        if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
        {
            action.matchCounter.matchCounterIndex = 32768;
        }

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->matchCounter.matchCounterIndex = %d",
                dev, ruleSize, ruleIndex, action.matchCounter.matchCounterIndex);

        action.matchCounter.matchCounterIndex = 0; /* restore valid value */

        /*
            1.12. Call with out of range actionPtr->policer.policerId [policersTableSize]
            and other params from 1.1.
            Expected: NOT GT_OK
        */
        action.policer.policerEnable = CPSS_DXCH_PCL_POLICER_ENABLE_METER_AND_COUNTER_E;
        /* out of HW field range - real policersTableSize not checked */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.policer.policerId     = BIT_16;
        }
        else
        {
            action.policer.policerId     = BIT_12;
        }

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);

        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                        "%d, %d, %d, actionPtr->policer.policerId = %d",
                                dev, ruleSize, ruleIndex, action.policer.policerId);

        action.policer.policerId = 0; /* restore valid value */

        /*
            1.13. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                           actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                           out of range actionPtr->redirect.outIf.tunnelPtr[1023]
                           and other params from 1.1.
            Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.
        */
        action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E;
        action.redirect.data.outIf.tunnelStart = GT_TRUE;
        action.redirect.data.outIf.tunnelPtr = MAX_TUNNEL_PTR(dev)-1;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);

        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->redirect.data.outIf.tunnelPtr = %d",
                dev, ruleSize, ruleIndex, action.redirect.data.outIf.tunnelPtr);

        /*
            1.14. For Ch3 and above call with actionPtr->redirect.redirectCmd
                        [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                   actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                   out of range actionPtr->redirect.outIf.tunnelPtr[8192]
                   and other params from 1.1.
            Expected: NOT GT_OK.
        */
        action.redirect.data.outIf.tunnelPtr = MAX_TUNNEL_PTR(dev);

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->redirect.data.outIf.tunnelPtr = %d",
                dev, ruleSize, ruleIndex, action.redirect.data.outIf.tunnelPtr);

        action.redirect.data.outIf.tunnelStart = GT_FALSE;
        action.redirect.data.outIf.tunnelPtr = 0; /* restore valid value */

        /*
            1.15. Call with actionPtr->redirect.redirectCmd
                                [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                           out of range actionPtr->redirect.data.routerLttIndex[8192]
                           and other params from 1.1.
            Expected: NOT GT_OK for Ch1/Ch2/Ch3 and GT_OK for xCat and above.
        */
        action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E;
        action.redirect.data.routerLttIndex = 8192;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);

        if ((devFamily <= CPSS_PP_FAMILY_CHEETAH3_E)
            || (devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E))
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                    dev, ruleSize, ruleIndex, action.redirect.data.routerLttIndex);

            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E;
        }
        else
        {
            if ((UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)&&
                (action.redirect.data.routerLttIndex>=PRV_CPSS_DXCH_PP_MAC(dev)->moduleCfg.ip.maxNumOfPbrEntries))
            {
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                                                 "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                                                 dev, ruleSize, ruleIndex, action.redirect.data.routerLttIndex);
            }
            else
            {
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                             "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                                             dev, ruleSize, ruleIndex, action.redirect.data.routerLttIndex);
            }

            /*
                1.16. For xCat and above call with actionPtr->redirect.redirectCmd
                                    [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                               out of range actionPtr->redirect.data.routerLttIndex[32768]
                               and other params from 1.1.
                Expected: NOT GT_OK.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                action.redirect.data.routerLttIndex = PRV_CPSS_DXCH_PP_MAC(dev)->moduleCfg.ip.maxNumOfPbrEntries;
            }
            else
            {
                action.redirect.data.routerLttIndex = BIT_15;
            }

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                    dev, ruleSize, ruleIndex, action.redirect.data.routerLttIndex);
        }

        action.redirect.data.routerLttIndex = 0; /* restore valid value */

        /*
            1.17. For Ch3 and above call with actionPtr->redirect.redirectCmd
                                [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E],
                           out of range actionPtr->redirect.data.vrfId [4096]
                           and other params from 1.1.
            Expected: NOT GT_OK.
        */
        if ((devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
            && (devFamily != CPSS_PP_FAMILY_DXCH_XCAT2_E))
        {
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E;
            action.redirect.data.vrfId = BIT_12;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                            "%d, %d, %d, actionPtr->redirect.data.vrfId= %d",
                            dev, ruleSize, ruleIndex, action.redirect.data.vrfId);

            action.redirect.data.vrfId = 0; /* restore valid value */
        }

        if (devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
        {
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E;
        }

        /*
            1.18. Call with actionPtr->vlan.ingress.modifyVlan
                                [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
                           out of range actionPtr->vlan.ingress.vlanId [4096]
                           and other params from 1.1.
            Expected: NOT GT_OK.
        */
        action.vlan.ingress.modifyVlan = CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E;
        action.vlan.ingress.vlanId = UTF_CPSS_PP_MAX_VLAN_NUM_CNS(dev);

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->vlan.ingress.vlanId = %d",
                            dev, ruleSize, ruleIndex, action.vlan.ingress.vlanId);

        action.vlan.ingress.vlanId = 100; /* restore valid value */

        /*
            1.19. For Ch3 and above call with out of range
            actionPtr->sourceId.sourceIdValue [32] and other params from 1.1.
            Expected: NOT GT_OK.
        */
        if (devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
        {
            action.sourceId.assignSourceId = GT_TRUE;
            action.sourceId.sourceIdValue = UTF_CPSS_PP_MAX_SRC_ID_NUM_MAC(dev);

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                            "%d, %d, %d, actionPtr->sourceId.sourceIdValue = %d",
                            dev, ruleSize, ruleIndex, action.sourceId.sourceIdValue);

            action.sourceId.sourceIdValue = 0; /* restore valid value */
        }

        /*
            1.20. Call with out of range actionPtr->pktCmd
            Expected: GT_BAD_PARAM
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                            (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                            action.pktCmd);

        /*
            1.21. Call with not valid actionPtr->pktCmd
                                        [CPSS_PACKET_CMD_ROUTE_E
                                        CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E
                                        CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E
                                        CPSS_PACKET_CMD_BRIDGE_E ]
            Expected: NOT GT_OK
        */

        /* Call with CPSS_PACKET_CMD_ROUTE_E */
        action.pktCmd = CPSS_PACKET_CMD_ROUTE_E;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->action.pktCmd = %d",
                dev, ruleSize, ruleIndex, action.pktCmd);

        /* Call with CPSS_PACKET_CMD_ROUTE_E */
        action.pktCmd = CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->action.pktCmd = %d",
                dev, ruleSize, ruleIndex, action.pktCmd);

        /* Call with CPSS_PACKET_CMD_ROUTE_E */
        action.pktCmd = CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->action.pktCmd = %d",
                dev, ruleSize, ruleIndex, action.pktCmd);

        /* Call with CPSS_PACKET_CMD_ROUTE_E */
        action.pktCmd = CPSS_PACKET_CMD_BRIDGE_E;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->action.pktCmd = %d",
                dev, ruleSize, ruleIndex, action.pktCmd);

        /* restore valid value */
        action.pktCmd = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;

        /*
            1.22. Call with out of range actionPtr->lookupConfig.pcl0_1OverrideConfigIndex,
                  other parameters is the same as in 1.1.
            Expected: GT_BAD_PARAM for DxCh3 and above
        */
        action.egressPolicy = GT_TRUE;
        action.lookupConfig.ipclConfigIndex = 1;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                            (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                            action.lookupConfig.pcl0_1OverrideConfigIndex);

        /* restore valid value */
        action.egressPolicy = GT_FALSE;

        /*
            1.23. Call with out of range actionPtr->lookupConfig.pcl1OverrideConfigIndex,
                other parameters is the same as in 1.1.
            Expected: GT_BAD_PARAM
        */
        action.egressPolicy = GT_TRUE;
        action.lookupConfig.ipclConfigIndex = 1;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                            (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                            action.lookupConfig.pcl1OverrideConfigIndex);

        /* restore valid value */
        action.egressPolicy = GT_FALSE;
        action.lookupConfig.ipclConfigIndex = 0;

        /*
            1.24. Call with out of range actionPtr->mirror.cpuCode
            Expected: GT_BAD_PARAM
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                            (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                            action.mirror.cpuCode);

        /*
            1.25. Call with out of range actionPtr->mirror.ingressMirrorToAnalyzerIndex[7 / 8] (relevant for Bobcat2; Caelum; Bobcat3)
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3 and GT_OK for others.
        */
        action.egressPolicy = GT_FALSE;
        action.mirror.mirrorToRxAnalyzerPort = GT_TRUE;

        /* call with actionPtr->mirror.ingressMirrorToAnalyzerIndex[7] */
        action.mirror.ingressMirrorToAnalyzerIndex = 7;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                    dev, ruleSize, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
        }
        else
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                    dev, ruleSize, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
        }

        /* call with actionPtr->mirror.ingressMirrorToAnalyzerIndex[8] */
        action.mirror.ingressMirrorToAnalyzerIndex = 8;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                    dev, ruleSize, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
        }
        else
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                    dev, ruleSize, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
        }

        /* restore valid value */
        action.mirror.mirrorToRxAnalyzerPort = GT_FALSE;
        action.mirror.ingressMirrorToAnalyzerIndex = 0;

        if(PRV_CPSS_SIP_6_CHECK_MAC(dev))
        {
            /*
                Call with out of range actionPtr->mirror.egressMirrorToAnalyzerIndex[7 / 8] (relevant for Falcon)
                Expected: NOT GT_OK for Falcon and GT_OK for others.
            */
            action.egressPolicy = GT_TRUE;
            action.mirror.mirrorToTxAnalyzerPortEn = GT_TRUE;
            action.mirror.egressMirrorToAnalyzerMode = CPSS_DXCH_MIRROR_EGRESS_TAIL_DROP_E;

            /* call with actionPtr->mirror.egressMirrorToAnalyzerIndex[7] */
            action.mirror.egressMirrorToAnalyzerIndex = 7;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);

            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.egressMirrorToAnalyzerIndex = %d",
                    dev, ruleSize, ruleIndex, action.mirror.egressMirrorToAnalyzerIndex);

            /* call with actionPtr->mirror.ingressMirrorToAnalyzerIndex[8] */
            action.mirror.egressMirrorToAnalyzerIndex = 8;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->mirror.egressMirrorToAnalyzerIndex = %d",
                    dev, ruleSize, ruleIndex, action.mirror.egressMirrorToAnalyzerIndex);

            /* restore valid value */
            action.mirror.mirrorToTxAnalyzerPortEn = GT_FALSE;
            action.mirror.egressMirrorToAnalyzerIndex = 0;
            action.mirror.egressMirrorToAnalyzerMode = CPSS_DXCH_MIRROR_EGRESS_NOT_DROPPED_E;
        }

        /*
            1.26. Call with out of range actionPtr->qos.ingress.modifyDscp
            Expected: GT_BAD_PARAM
        */
        action.egressPolicy = GT_FALSE;
        action.qos.ingress.profileAssignIndex = GT_TRUE;
        action.qos.ingress.modifyUp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                            (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                            action.qos.ingress.modifyDscp);

        /* restore default value */
        action.qos.ingress.profileAssignIndex = GT_FALSE;

       /*
            1.27. Call with out of range actionPtr->qos.ingress.modifyUp
            Expected: GT_BAD_PARAM
        */
        action.egressPolicy = GT_FALSE;
        action.qos.ingress.profileAssignIndex = GT_TRUE;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                            (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                            action.qos.ingress.modifyUp);

        /* restore valid value */
        action.qos.ingress.profileAssignIndex = GT_FALSE;

        /*
            1.28. Call with out of range actionPtr->qos.ingress.profileIndex
                [72] for DxCh1
                [128] for Bobcat2; Caelum; Bobcat3
                [128] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2
            Expected: NOT GT_OK
        */
        action.qos.ingress.profileAssignIndex = GT_TRUE;
        action.qos.ingress.modifyUp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;
        action.qos.ingress.modifyDscp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.qos.ingress.profileIndex = BIT_10;
        }
        else
        {
            action.qos.ingress.profileIndex = 128;
        }

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                    dev, ruleSize, ruleIndex, action.qos.ingress.profileIndex);

        /* restore valid value */
        action.qos.ingress.profileIndex = 0;
        action.qos.ingress.profileAssignIndex = GT_FALSE;

        /*
            1.29. Call with valid actionPtr->qos.ingress.profileIndex
                    [0 / 15 / 36 / 71] for DxCh1
                    [0 / 127 / 128 / 255] for Bobcat2; Caelum; Bobcat3
                    [0 / / 45 / 64 / 127 ] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2
            Expected: GT_OK
        */
        action.qos.ingress.profileAssignIndex = GT_TRUE;
        action.qos.ingress.modifyUp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;
        action.qos.ingress.modifyDscp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;

        /* Call with valid actionPtr->qos.ingress.profileIndex [0] */
        action.qos.ingress.profileIndex = 0;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                    dev, ruleSize, ruleIndex, action.qos.ingress.profileIndex);

        /*  Call with valid actionPtr->qos.ingress.profileIndex
                [15] for DxCh1
                [127] for Bobcat2; Caelum; Bobcat3
                [45] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2 */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.qos.ingress.profileIndex = 444;
        }
        else
        {
            action.qos.ingress.profileIndex = 45;
        }
        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                    dev, ruleSize, ruleIndex, action.qos.ingress.profileIndex);

        /*  Call with valid actionPtr->qos.ingress.profileIndex
                [36] for DxCh1
                [64] for Bobcat2; Caelum; Bobcat3
                [64] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2 */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.qos.ingress.profileIndex = 999;
        }
        else
        {
            action.qos.ingress.profileIndex = 64;
        }
        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                    dev, ruleSize, ruleIndex, action.qos.ingress.profileIndex);

        /*  Call with valid actionPtr->qos.ingress.profileIndex
                [71] for DxCh1
                [127] for Bobcat2; Caelum; Bobcat3
                [127] for DxCh2, DxCh3, xCat, Lion, xCat2, Lion2 */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.qos.ingress.profileIndex = BIT_10 - 1;
        }
        else
        {
            action.qos.ingress.profileIndex = 127;
        }
        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                   "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                    dev, ruleSize, ruleIndex, action.qos.ingress.profileIndex);

        /* restore valid value */
        action.qos.ingress.profileIndex = 0;
        action.qos.ingress.profileAssignIndex = GT_FALSE;

        /*
            1.30. Call with out of range actionPtr->qos.ingress.up1Cmd (relevant for Lion2)
            Expected: GT_BAD_PARAM
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                            (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                                action.qos.ingress.up1Cmd);
        }

        /*
            1.31. Call with out of range actionPtr->qos.ingress.up1 [8] (relevant for Bobcat2; Caelum; Bobcat3)
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3 and GT_OK for others.
        */
        action.qos.ingress.up1 = 8;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->qos.ingress.up1 = %d",
                    dev, ruleSize, ruleIndex, action.qos.ingress.up1);
        }
        else
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->qos.ingress.up1 = %d",
                    dev, ruleSize, ruleIndex, action.qos.ingress.up1);
        }

        /* restore valid value */
        action.qos.ingress.up1 = 0;

        /*
            1.32. Call with out of range actionPtr->qos.egress.modifyUp
            Expected: GT_BAD_PARAM.
        */
        action.egressPolicy = GT_TRUE;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                        (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                            action.qos.egress.modifyUp);

        /* restore valid value */
        action.egressPolicy = GT_FALSE;

        /*
            1.33. Call with actionPtr->vlan.ingress.modifyVlan [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
                           out of range actionPtr->vlan.ingress.vlanId1 [4096]
                           and other params from 1.1. Applicable devices - Bobcat2; Caelum; Bobcat3; Aldrin; AC3X.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3 and GT_OK for others.
        */
        action.vlan.ingress.modifyVlan = CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E;
        action.vlan.ingress.vlanId1 = UTF_CPSS_PP_MAX_VLAN_NUM_CNS(dev);

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->vlan.ingress.vlanId1 = %d",
                                            dev, ruleSize, ruleIndex, action.vlan.ingress.vlanId1);

        }
        else
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->vlan.ingress.vlanId1 = %d",
                                            dev, ruleSize, ruleIndex, action.vlan.ingress.vlanId1);
        }

        action.vlan.ingress.vlanId1 = 100; /* restore valid value */

        /*
            1.34. Call with actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE] (relevant for non DxCh2, DxCh3),
                           out of range actionPtr->ipUcRoute.arpDaIndex [1024]
                           and other params from 1.1.
            Expected: NOT GT_OK
        */
        if (support_doIpUcRoute == GT_TRUE)
        {
            action.ipUcRoute.doIpUcRoute = GT_TRUE;
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E;
            action.policer.policerEnable = CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E;
            action.ipUcRoute.arpDaIndex = 1024;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                     dev, ruleSize, ruleIndex, action.ipUcRoute.arpDaIndex);

            action.ipUcRoute.doIpUcRoute = GT_FALSE; /* restore valid value */
        }

        /*
            1.35. Call with relevant actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE],
                           out of range actionPtr->ipUcRoute.arpDaIndex [0 / 512 / 1023]
                           and other params from 1.1.
            Expected: GT_OK for non DxCh2, DxCh3 devices.
        */
        action.ipUcRoute.doIpUcRoute = GT_TRUE;

        /* Call with arpDaIndex [0] */
        action.ipUcRoute.arpDaIndex = 0;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        if (support_doIpUcRoute == GT_TRUE)
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                        dev, ruleSize, ruleIndex, action.ipUcRoute.arpDaIndex);
        }
        else
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                             dev, ruleSize, ruleIndex, action.ipUcRoute.arpDaIndex);
        }

        /* Call with arpDaIndex [512] */
        action.ipUcRoute.arpDaIndex = 512;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        if (support_doIpUcRoute == GT_TRUE)
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                        dev, ruleSize, ruleIndex, action.ipUcRoute.arpDaIndex);
        }
        else
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                             dev, ruleSize, ruleIndex, action.ipUcRoute.arpDaIndex);
        }

        /* Call with arpDaIndex [1023] */
        action.ipUcRoute.arpDaIndex = 1023;

        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        if (support_doIpUcRoute == GT_TRUE)
        {
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                        dev, ruleSize, ruleIndex, action.ipUcRoute.arpDaIndex);
        }
        else
        {
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                             dev, ruleSize, ruleIndex, action.ipUcRoute.arpDaIndex);
        }

        action.ipUcRoute.doIpUcRoute = GT_FALSE; /* restore valid value */


        /*
            1.36. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_TRUE], out of range
                actionPtr->flowId[0x10000](not relevant) and other params same as 1.1.
            Expected: GT_OK.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            /* restore previous value */
            pclActionDefaultSet(&action);

            action.egressPolicy = GT_TRUE;
            action.flowId  = MAX_FLOW_ID(dev);
            action.actionStop = GT_FALSE;
            action.pktCmd = CPSS_PACKET_CMD_FORWARD_E;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);


        /*
            1.37. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], out of range
                actionPtr->flowId[0x100000](is relevant) and other params same as 1.1.
            Expected: NOT GT_OK.
        */

            action.egressPolicy = GT_FALSE;
            action.flowId  = MAX_FLOW_ID(dev);

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);

        /*
            1.38. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                actionPtr->oam.oamProcessEnable[GT_TRUE],
                actionPtr->oam.oamProfile[1], out of range actionPtr->oam.offsetIndex[16],
                and other params same as 1.1.
            Expected: NOT GT_OK.
        */
            action.oam.timeStampEnable = GT_TRUE;
            action.oam.offsetIndex  = BIT_7;
            action.oam.oamProcessEnable = GT_TRUE;
            action.oam.oamProfile = 1;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);


        /*
            1.39. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                actionPtr->oam.oamProcessEnable[GT_TRUE],
                actionPtr->oam.offsetIndex[15], out of range actionPtr->oam.oamProfile[2],
                and other params same as 1.1.
            Expected: NOT GT_OK.
        */

            action.oam.timeStampEnable = GT_TRUE;
            action.oam.offsetIndex  = BIT_7 - 1;
            action.oam.oamProcessEnable = GT_TRUE;
            action.oam.oamProfile = 2;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

            /* restore previous value */
            pclActionDefaultSet(&action);
        }

        /*
            1.40. Check for NULL pointer. Call with actionPtr [NULL],
            other parameters same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, NULL);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_PTR, st, "%d, %d, %d, NULL",
                                     dev, ruleSize, ruleIndex);

        /*
            1.41. Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[0 / 3 / 6]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E /
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_REPLACE_MAC_SA_E],
                           data { modifyMacSa {macSa [00:00:00:00:00:00 /
                                                      A5:A5:A5:A5:A5:A5 /
                                                      FF:FF:FF:FF:FF:FF],
                                               arpPtr[0 / 0xA5A5 / BIT_17-1]}}},
                        oam { timeStampEnable [GT_FALSE / GT_TRUE],
                              offsetIndex [0 / 0x5A / BIT_7-1],
                              oamProcessEnable [GT_FALSE / GT_TRUE],
                              oamProfile [0 / 1] },
                        sourcePort { assignSourcePortEnable [GT_FALSE / GT_TRUE]
                                 sourcePortValue [0 / 0x1A5A / BIT_13-1] }
                        qos { ingress { up1Cmd[
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_DO_NOT_MODIFY_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG1_UNTAGGED_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG0_UNTAGGED_E /
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_ALL_E],
                                       up1[0 / 5 / BIT_3-1]} }
                        vlan { ingress { vlanId1Cmd[
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_DO_NOT_MODIFY_E /
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_UNTAGGED_E /
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_ALL_E],
                                       vlanId1 [0 / 0xA5A / BIT_12-1]} },
                        flowId [0 / 0xA5A / BIT_12-1],
                        setMacToMe [GT_FALSE / GT_TRUE] }
                    and other params from 1.1.
            Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /*
                Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[0]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E],
                           data { modifyMacSa {macSa [00:00:00:00:00:00],
                                               arpPtr [0] } } },
                        oam { timeStampEnable [GT_FALSE],
                              offsetIndex [0],
                              oamProcessEnable [GT_FALSE],
                              oamProfile [0] },
                        sourcePort { assignSourcePortEnable [GT_FALSE]
                                 sourcePortValue [0] }
                        qos { ingress { up1Cmd[
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_DO_NOT_MODIFY_E],
                                       up1[0]} }
                        vlan { ingress { vlanId1Cmd[
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_DO_NOT_MODIFY_E],
                                       vlanId1 [0]} },
                        flowId [0],
                        setMacToMe [GT_FALSE] }
                    and other params from 1.1.
            */

            action.egressPolicy = GT_FALSE;
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            action.mirror.mirrorToRxAnalyzerPort = GT_TRUE;

            action.mirror.ingressMirrorToAnalyzerIndex = 0;
            action.redirect.redirectCmd =
                                       CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E;
            action.redirect.data.modifyMacSa.macSa = macSa1;
            action.redirect.data.modifyMacSa.arpPtr = 0;
            action.oam.timeStampEnable = GT_FALSE;
            action.oam.offsetIndex = 0;
            action.oam.oamProcessEnable = GT_FALSE;
            action.oam.oamProfile = 0;
            action.sourcePort.assignSourcePortEnable = GT_FALSE;
            action.sourcePort.sourcePortValue = 0;
            action.qos.ingress.up1Cmd =
                           CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_DO_NOT_MODIFY_E;
            action.qos.ingress.up1 = 0;
            action.vlan.ingress.vlanId1Cmd =
                      CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_DO_NOT_MODIFY_E;
            action.vlan.ingress.vlanId1 = 0;
            action.flowId = 0;
            action.setMacToMe = GT_FALSE;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* verify values */
            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction,
                                          &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                     "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                     dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
                UTF_VERIFY_EQUAL1_STRING_MAC(
                    action.mirror.ingressMirrorToAnalyzerIndex,
                    actionGet.mirror.ingressMirrorToAnalyzerIndex,
  "get another actionPtr->mirror.ingressMirrorToAnalyzerIndex than was set: %d",
                    dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.redirect.redirectCmd,
                                              actionGet.redirect.redirectCmd,
                 "get another actionPtr->redirect.redirectCmd than was set: %d",
                                              dev);
                isEqual = (0 == cpssOsMemCmp(
                          (GT_VOID*) &action.redirect.data.modifyMacSa.macSa,
                          (GT_VOID*) &actionGet.redirect.data.modifyMacSa.macSa,
                          sizeof(action.redirect.data.modifyMacSa.macSa)
                                            )
                           ) ? GT_TRUE : GT_FALSE;
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_TRUE, isEqual,
      "get another actionPtr->redirect.data.modifyMacSa.macSa than was set: %d",
                                         dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(
                                     action.redirect.data.modifyMacSa.arpPtr,
                                     actionGet.redirect.data.modifyMacSa.arpPtr,
     "get another actionPtr->redirect.data.modifyMacSa.arpPtr than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.oam.timeStampEnable,
                                              actionGet.oam.timeStampEnable,
                  "get another actionPtr->oam.timeStampEnable than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.oam.offsetIndex,
                                              actionGet.oam.offsetIndex,
                      "get another actionPtr->oam.offsetIndex than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.oam.oamProcessEnable,
                                              actionGet.oam.oamProcessEnable,
                 "get another actionPtr->oam.oamProcessEnable than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.oam.oamProfile,
                                              actionGet.oam.oamProfile,
                       "get another actionPtr->oam.oamProfile than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(
                                    action.sourcePort.assignSourcePortEnable,
                                    actionGet.sourcePort.assignSourcePortEnable,
    "get another actionPtr->sourcePort.assignSourcePortEnable than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.sourcePort.sourcePortValue,
                                           actionGet.sourcePort.sourcePortValue,
           "get another actionPtr->sourcePort.sourcePortValue than was set: %d",
                                              dev);
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.ingress.up1Cmd,
                                              actionGet.qos.ingress.up1Cmd,
                   "get another actionPtr->qos.ingress.up1Cmd than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.ingress.up1,
                                              actionGet.qos.ingress.up1,
                      "get another actionPtr->qos.ingress.up1 than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.ingress.vlanId1Cmd,
                                              actionGet.vlan.ingress.vlanId1Cmd,
              "get another actionPtr->vlan.ingress.vlanId1Cmd than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.ingress.vlanId1,
                                              actionGet.vlan.ingress.vlanId1,
                 "get another actionPtr->vlan.ingress.vlanId1 than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.flowId,
                                              actionGet.flowId,
                               "get another actionPtr->flowId than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.setMacToMe,
                                              actionGet.setMacToMe,
                           "get another actionPtr->setMacToMe than was set: %d",
                                              dev);
            }
            /*
                Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[3]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                           data { modifyMacSa {macSa [00:00:00:00:00:00],
                                               arpPtr [0] } } },
                        oam { timeStampEnable [GT_TRUE],
                              offsetIndex [0x5A],
                              oamProcessEnable [GT_TRUE],
                              oamProfile [1] },
                        sourcePort { assignSourcePortEnable [GT_TRUE]
                                 sourcePortValue [0x1A5A] }
                        qos { ingress { up1Cmd[
                          CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG1_UNTAGGED_E],
                                       up1[5]} }
                        vlan { ingress { vlanId1Cmd[
                     CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_UNTAGGED_E],
                                       vlanId1 [0xA5A]} },
                        flowId [0xA5A],
                        setMacToMe [GT_TRUE] }
                    and other params from 1.1.
            */

            action.mirror.ingressMirrorToAnalyzerIndex = 3;
            action.redirect.redirectCmd =
                                     CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E;
            action.oam.timeStampEnable = GT_TRUE;
            action.oam.offsetIndex = 0x5A;
            action.oam.oamProcessEnable = GT_TRUE;
            action.oam.oamProfile = 1;
            action.sourcePort.assignSourcePortEnable = GT_TRUE;
            action.sourcePort.sourcePortValue = 0x1A5A;
            action.qos.ingress.up1Cmd =
                           CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG1_UNTAGGED_E;
            action.qos.ingress.up1 = 5;
            action.vlan.ingress.vlanId1Cmd =
                           CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_UNTAGGED_E;
            action.vlan.ingress.vlanId1 = 0xA5A;
            action.flowId = 0xA5A;
            action.setMacToMe = GT_TRUE;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

             /* verify values */
            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction,
                                          &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                     "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                     dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
                UTF_VERIFY_EQUAL1_STRING_MAC(
                    action.mirror.ingressMirrorToAnalyzerIndex,
                    actionGet.mirror.ingressMirrorToAnalyzerIndex,
  "get another actionPtr->mirror.ingressMirrorToAnalyzerIndex than was set: %d",
                    dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.redirect.redirectCmd,
                                              actionGet.redirect.redirectCmd,
                 "get another actionPtr->redirect.redirectCmd than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.oam.timeStampEnable,
                                              actionGet.oam.timeStampEnable,
                  "get another actionPtr->oam.timeStampEnable than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.oam.offsetIndex,
                                              actionGet.oam.offsetIndex,
                      "get another actionPtr->oam.offsetIndex than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.oam.oamProcessEnable,
                                              actionGet.oam.oamProcessEnable,
                 "get another actionPtr->oam.oamProcessEnable than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.oam.oamProfile,
                                              actionGet.oam.oamProfile,
                       "get another actionPtr->oam.oamProfile than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(
                                    action.sourcePort.assignSourcePortEnable,
                                    actionGet.sourcePort.assignSourcePortEnable,
    "get another actionPtr->sourcePort.assignSourcePortEnable than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.sourcePort.sourcePortValue,
                                           actionGet.sourcePort.sourcePortValue,
           "get another actionPtr->sourcePort.sourcePortValue than was set: %d",
                                              dev);
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.ingress.up1Cmd,
                                              actionGet.qos.ingress.up1Cmd,
                   "get another actionPtr->qos.ingress.up1Cmd than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.ingress.up1,
                                              actionGet.qos.ingress.up1,
                      "get another actionPtr->qos.ingress.up1 than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.ingress.vlanId1Cmd,
                                              actionGet.vlan.ingress.vlanId1Cmd,
              "get another actionPtr->vlan.ingress.vlanId1Cmd than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.ingress.vlanId1,
                                              actionGet.vlan.ingress.vlanId1,
                 "get another actionPtr->vlan.ingress.vlanId1 than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.flowId,
                                              actionGet.flowId,
                               "get another actionPtr->flowId than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.setMacToMe,
                                              actionGet.setMacToMe,
                           "get another actionPtr->setMacToMe than was set: %d",
                                              dev);
            }
            /*
                Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[6]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E],
                           data { modifyMacSa {macSa [00:00:00:00:00:00],
                                               arpPtr [0] } } },
                        oam { timeStampEnable [GT_TRUE],
                              offsetIndex [BIT_7-1],
                              oamProcessEnable [GT_TRUE],
                              oamProfile [1] },
                        sourcePort { assignSourcePortEnable [GT_TRUE]
                                 sourcePortValue [BIT_13-1] }
                        qos { ingress { up1Cmd[
                         CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG0_UNTAGGED_E],
                                       up1[BIT_3-1]} }
                        vlan { ingress { vlanId1Cmd[
                               CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_ALL_E],
                                       vlanId1 [BIT_12-1]} },
                        flowId [BIT_12-1],
                        setMacToMe [GT_TRUE] }
                    and other params from 1.1.
            */

            action.mirror.ingressMirrorToAnalyzerIndex = 6;
            action.redirect.redirectCmd =
                                CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E;
            action.oam.offsetIndex = BIT_7-1;
            action.sourcePort.sourcePortValue = MAX_EPORT(dev)-1;
            action.qos.ingress.up1Cmd =
                           CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_TAG0_UNTAGGED_E;
            action.qos.ingress.up1 = BIT_3-1;
            action.vlan.ingress.vlanId1Cmd =
                                CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_ALL_E;
            action.vlan.ingress.vlanId1 = BIT_12-1;
            action.flowId = MAX_FLOW_ID(dev)-1;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* verify values */
            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction,
                                          &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                     "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                     dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
                UTF_VERIFY_EQUAL1_STRING_MAC(
                    action.mirror.ingressMirrorToAnalyzerIndex,
                    actionGet.mirror.ingressMirrorToAnalyzerIndex,
  "get another actionPtr->mirror.ingressMirrorToAnalyzerIndex than was set: %d",
                    dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.redirect.redirectCmd,
                                              actionGet.redirect.redirectCmd,
                 "get another actionPtr->redirect.redirectCmd than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.oam.offsetIndex,
                                              actionGet.oam.offsetIndex,
                      "get another actionPtr->oam.offsetIndex than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.sourcePort.sourcePortValue,
                                           actionGet.sourcePort.sourcePortValue,
           "get another actionPtr->sourcePort.sourcePortValue than was set: %d",
                                              dev);
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.ingress.up1Cmd,
                                              actionGet.qos.ingress.up1Cmd,
                   "get another actionPtr->qos.ingress.up1Cmd than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.ingress.up1,
                                              actionGet.qos.ingress.up1,
                      "get another actionPtr->qos.ingress.up1 than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.ingress.vlanId1Cmd,
                                              actionGet.vlan.ingress.vlanId1Cmd,
              "get another actionPtr->vlan.ingress.vlanId1Cmd than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.ingress.vlanId1,
                                              actionGet.vlan.ingress.vlanId1,
                 "get another actionPtr->vlan.ingress.vlanId1 than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.flowId,
                                              actionGet.flowId,
                               "get another actionPtr->flowId than was set: %d",
                                              dev);
            }

            /*
                Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        mirror { ingressMirrorToAnalyzerIndex[6]},
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_REPLACE_MAC_SA_E],
                           data { modifyMacSa {macSa [A5:A5:A5:A5:A5:A5],
                                               arpPtr [0xA5A5] } } },
                        oam { timeStampEnable [GT_TRUE],
                              offsetIndex [BIT_7-1],
                              oamProcessEnable [GT_TRUE],
                              oamProfile [1] },
                        sourcePort { assignSourcePortEnable [GT_TRUE]
                                 sourcePortValue [BIT_13-1] }
                        qos { ingress { up1Cmd[
                                    CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_ALL_E],
                                       up1[BIT_3-1]} }
                                vlan { ingress { vlanId1Cmd[
                               CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_ALL_E],
                                       vlanId1 [BIT_12-1]} },
                        flowId [BIT_12-1],
                        setMacToMe [GT_TRUE] }
                    and other params from 1.1.
            */

            action.redirect.redirectCmd =
                             CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_REPLACE_MAC_SA_E;
            action.redirect.data.modifyMacSa.macSa = macSa2;
            action.redirect.data.modifyMacSa.arpPtr = 0xA5A5 % (MAX_ARP_PTR(dev));
            action.qos.ingress.up1Cmd =
                                     CPSS_DXCH_PCL_ACTION_INGRESS_UP1_CMD_ALL_E;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* verify values */
            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction,
                                          &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                     "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                     dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
                UTF_VERIFY_EQUAL1_STRING_MAC( action.redirect.redirectCmd,
                                              actionGet.redirect.redirectCmd,
                 "get another actionPtr->redirect.redirectCmd than was set: %d",
                                              dev);
                isEqual = (0 == cpssOsMemCmp(
                          (GT_VOID*) &action.redirect.data.modifyMacSa.macSa,
                          (GT_VOID*) &actionGet.redirect.data.modifyMacSa.macSa,
                          sizeof(action.redirect.data.modifyMacSa.macSa)
                                            )
                           ) ? GT_TRUE : GT_FALSE;
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_TRUE, isEqual,
      "get another actionPtr->redirect.data.modifyMacSa.macSa than was set: %d",
                                         dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(
                                     action.redirect.data.modifyMacSa.arpPtr,
                                     actionGet.redirect.data.modifyMacSa.arpPtr,
     "get another actionPtr->redirect.data.modifyMacSa.arpPtr than was set: %d",
                                              dev);
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.ingress.up1Cmd,
                                              actionGet.qos.ingress.up1Cmd,
                   "get another actionPtr->qos.ingress.up1Cmd than was set: %d",
                                              dev);
            }

            /*
                Call function with
                    actionPtr { egressPolicy [GT_FALSE]
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_REPLACE_MAC_SA_E],
                           data { modifyMacSa {macSa [FF:FF:FF:FF:FF:FF],
                                               arpPtr [BIT17-1] } } } }
                    and other params from 1.48.
            */

            action.redirect.data.modifyMacSa.macSa = macSa3;
            action.redirect.data.modifyMacSa.arpPtr = MAX_ARP_PTR(dev)-1;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }
        /*
            1.42. Call cpssDxChPclRuleActionGet with params same as 1.1.
            Expected: GT_OK and same values in actionPtr as were written.
        */

            /* verify values */
            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction,
                                          &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                     "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                     dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
                isEqual = (0 == cpssOsMemCmp(
                          (GT_VOID*) &action.redirect.data.modifyMacSa.macSa,
                          (GT_VOID*) &actionGet.redirect.data.modifyMacSa.macSa,
                          sizeof(action.redirect.data.modifyMacSa.macSa)
                                            )
                           ) ? GT_TRUE : GT_FALSE;
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_TRUE, isEqual,
      "get another actionPtr->redirect.data.modifyMacSa.macSa than was set: %d",
                                         dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(
                                     action.redirect.data.modifyMacSa.arpPtr,
                                     actionGet.redirect.data.modifyMacSa.arpPtr,
     "get another actionPtr->redirect.data.modifyMacSa.arpPtr than was set: %d",
                                              dev);
            }

            if(PRV_CPSS_SIP_6_30_CHECK_MAC(dev))
            {
                action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ASSIGN_GENERIC_ACTION_E;
                action.redirect.data.genericActionInfo.genericAction = 0x812;
                st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                /* verify values */
                st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize,
                        ruleIndex, direction, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                        dev, ruleSize, ruleIndex, direction);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.redirect.data.genericActionInfo.genericAction,
                        actionGet.redirect.data.genericActionInfo.genericAction,
                        "get another actionPtr->genericAction than was set: %d", dev);

                action.redirect.data.genericActionInfo.genericAction = 0x811;
                st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                /* verify values */
                st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize,
                        ruleIndex, direction, &actionGet);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                        dev, ruleSize, ruleIndex, direction);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.redirect.data.genericActionInfo.genericAction,
                        actionGet.redirect.data.genericActionInfo.genericAction,
                        "get another actionPtr->genericAction than was set: %d", dev);

                action.redirect.data.genericActionInfo.genericAction = 0xFFF + 1;
                st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, dev);

                /* restore */
                action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_REPLACE_MAC_SA_E;
            }

        /*
            1.43. Call function with
                   out of range ingressMirrorToAnalyzerIndex [7]
                   and other parameters from 1.41.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.mirror.ingressMirrorToAnalyzerIndex = 7;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.mirror.ingressMirrorToAnalyzerIndex = 0;
        }
        /*
            1.44. Call function with out of range redirectCmd
                   and other parameters from 1.41.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                                (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                                action.redirect.redirectCmd);
        }
        /*
            1.45. Call function with out of range offsetIndex [BIT_7]
                   and other parameters from 1.41.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.oam.offsetIndex = BIT_7;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.oam.offsetIndex = 0;
        }
        /*
            1.46. Call function with out of range oamProfile [2]
                   and other parameters from 1.41.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.oam.oamProfile = 2;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.oam.oamProfile = 0;
        }
        /*
            1.47. Call function with out of range up1Cmd
                   and other parameters from 1.41.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                                (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                                action.qos.ingress.up1Cmd);
        }
        /*
            1.48. Call function with out of range up1 [BIT_3]
                   and other parameters from 1.41.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.qos.ingress.up1 = BIT_3;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.qos.ingress.up1 = 0;
        }
        /*
            1.49. Call function with out of range vlanId1Cmd
                   and other parameters from 1.41.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                                (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                                action.vlan.ingress.vlanId1Cmd);
        }
        /*
            1.50. Call function with out of range vlanId1 [BIT_12]
                   and other parameters from 1.41.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.vlan.ingress.vlanId1 = BIT_12;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.vlan.ingress.vlanId1 = 0;
        }
        /*
            1.51. Call function with out of range flowId [BIT_12]
                   and other parameters from 1.41.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.flowId = MAX_FLOW_ID(dev);

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.flowId = 0;
        }

        /*
            1.52. Call function with out of range sourcePortValue [BIT_13]
                   and other parameters from 1.41.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.sourcePort.sourcePortValue = MAX_EPORT(dev);

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.sourcePort.sourcePortValue = 0;
        }
        /*

            1.53. Call function with out of range arpPtr [BIT_17]
                   and other parameters from 1.41.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.redirect.data.modifyMacSa.arpPtr = MAX_ARP_PTR(dev);

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.redirect.data.modifyMacSa.arpPtr = 0;
        }
        /*
            1.54. Call function with
                    actionPtr { egressPolicy [GT_TRUE]
                        qos { egress { modifyDscp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_OUTER_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_INNER_E],
                                      modifyUp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                      up1ModifyEnable [GT_FALSE / GT_TRUE],
                                      up1[0 / 5 / BIT_3-1]} }
                        vlan { egress { vlanCmd[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E /
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                       vlanId1ModifyEnable [GT_FALSE / GT_TRUE],
                                       vlanId1 [0 / 0xA5A / BIT_12-1]} },
                        channelTypeToOpcodeMapEnable [GT_FALSE / GT_TRUE],
                        tmQueueId [0 / 0x2A5A / BIT_14-1] }
                    and other params from 1.41.
            Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {

            /*
                Call function with
                    actionPtr { egressPolicy [GT_TRUE]
                        qos { egress { modifyDscp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E],
                                      modifyUp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E],
                                      up1ModifyEnable [GT_TRUE],
                                      up1[0]} }
                        vlan { egress { vlanCmd[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E],
                                       vlanId1ModifyEnable [GT_FALSE],
                                       vlanId1 [0]} },
                        channelTypeToOpcodeMapEnable [GT_FALSE],
                        tmQueueId [0] }
                    and other params from 1.41.
            */

            action.egressPolicy = GT_TRUE;
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            action.pktCmd = CPSS_PACKET_CMD_FORWARD_E;
            action.actionStop = GT_FALSE;

            action.qos.egress.modifyDscp =
                                CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E;
            action.qos.egress.modifyUp =
                           CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E;
            action.qos.egress.up1ModifyEnable = GT_FALSE;
            action.qos.egress.up1 = 0;
            action.vlan.egress.vlanCmd =
                           CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E;
            action.vlan.egress.vlanId1ModifyEnable = GT_FALSE;
            action.vlan.egress.vlanId1 = 0;
            action.channelTypeToOpcodeMapEnable = GT_FALSE;
            action.tmQueueId = 0;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* verify values */
            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction,
                                          &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                     "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                     dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.egress.modifyDscp,
                                             actionGet.qos.egress.modifyDscp,
                "get another actionPtr->qos.egress.modifyDscp than was set: %d",
                                              dev);
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.egress.modifyUp,
                                             actionGet.qos.egress.modifyUp,
                  "get another actionPtr->qos.egress.modifyUp than was set: %d",
                                              dev);
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.egress.up1ModifyEnable,
                                           actionGet.qos.egress.up1ModifyEnable,
           "get another actionPtr->qos.egress.up1ModifyEnable than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.egress.up1,
                                              actionGet.qos.egress.up1,
                       "get another actionPtr->qos.egress.up1 than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.egress.vlanCmd,
                                              actionGet.vlan.egress.vlanCmd,
                  "get another actionPtr->vlan.egress.vlanCmd than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(
                                      action.vlan.egress.vlanId1ModifyEnable,
                                      actionGet.vlan.egress.vlanId1ModifyEnable,
 "get another actionPtr->vlan.vlan.egress.vlanId1ModifyEnable than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.egress.vlanId1,
                                              actionGet.vlan.egress.vlanId1,
                  "get another actionPtr->vlan.egress.vlanId1 than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(
                                         action.channelTypeToOpcodeMapEnable,
                                         actionGet.channelTypeToOpcodeMapEnable,
         "get another actionPtr->channelTypeToOpcodeMapEnable than was set: %d",
                                              dev);
                if(PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.trafficManager.supported)
                {
                    UTF_VERIFY_EQUAL1_STRING_MAC( action.tmQueueId,
                                                  actionGet.tmQueueId,
                                "get another actionPtr->tmQueueId than was set: %d",
                                                  dev);
                }
            }
            /*
                Call function with
                    actionPtr { egressPolicy [GT_TRUE]
                        qos { egress { modifyDscp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_OUTER_E],
                                      modifyUp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E],
                                      up1ModifyEnable [GT_TRUE],
                                      up1[5]} }
                        vlan { egress { vlanCmd[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E],
                                       vlanId1ModifyEnable [GT_TRUE],
                                       vlanId1 [0xA5A]} },
                        channelTypeToOpcodeMapEnable [GT_TRUE],
                        tmQueueId [0x2A5A] }
                    and other params from 1.41.
            */

            action.qos.egress.modifyDscp =
                        CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_OUTER_E;
            action.qos.egress.modifyUp =
                        CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E;
            action.qos.egress.up1ModifyEnable = GT_TRUE;
            action.qos.egress.up1 = 5;
            action.vlan.egress.vlanCmd =
                        CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_OUTER_TAG_E;
            action.vlan.egress.vlanId1ModifyEnable = GT_TRUE;
            action.vlan.egress.vlanId1 = 0xA5A;
            action.channelTypeToOpcodeMapEnable = GT_TRUE;
            action.tmQueueId = 0x2A5A;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* verify values */
            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction,
                                          &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                     "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                     dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.egress.modifyDscp,
                                             actionGet.qos.egress.modifyDscp,
                "get another actionPtr->qos.egress.modifyDscp than was set: %d",
                                              dev);
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.egress.modifyUp,
                                             actionGet.qos.egress.modifyUp,
                  "get another actionPtr->qos.egress.modifyUp than was set: %d",
                                              dev);
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.egress.up1ModifyEnable,
                                           actionGet.qos.egress.up1ModifyEnable,
           "get another actionPtr->qos.egress.up1ModifyEnable than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.egress.up1,
                                              actionGet.qos.egress.up1,
                       "get another actionPtr->qos.egress.up1 than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.egress.vlanCmd,
                                              actionGet.vlan.egress.vlanCmd,
                  "get another actionPtr->vlan.egress.vlanCmd than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(
                                      action.vlan.egress.vlanId1ModifyEnable,
                                      actionGet.vlan.egress.vlanId1ModifyEnable,
 "get another actionPtr->vlan.vlan.egress.vlanId1ModifyEnable than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.egress.vlanId1,
                                              actionGet.vlan.egress.vlanId1,
                  "get another actionPtr->vlan.egress.vlanId1 than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(
                                         action.channelTypeToOpcodeMapEnable,
                                         actionGet.channelTypeToOpcodeMapEnable,
         "get another actionPtr->channelTypeToOpcodeMapEnable than was set: %d",
                                              dev);
                if(PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.trafficManager.supported)
                {
                    UTF_VERIFY_EQUAL1_STRING_MAC( action.tmQueueId,
                                                  actionGet.tmQueueId,
                                "get another actionPtr->tmQueueId than was set: %d",
                                                  dev);
                }
            }

            /*
                Call function with
                    actionPtr { egressPolicy [GT_TRUE]
                        qos { egress { modifyDscp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_MODIFY_INNER_E],
                                      modifyUp[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                      up1ModifyEnable [GT_TRUE],
                                      up1[BIT_3-1]} }
                        vlan { egress { vlanCmd[
                       CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_MODIFY_TAG0_E],
                                       vlanId1ModifyEnable [GT_TRUE],
                                       vlanId1 [BIT_12-1]} },
                        channelTypeToOpcodeMapEnable [GT_TRUE],
                        tmQueueId [BIT_14-1] }
                    and other params from 1.41.
            */

            action.qos.egress.modifyDscp =
                                CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E;
            action.qos.egress.modifyUp =
                           CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E;
            action.qos.egress.up1 = BIT_3-1;
            action.vlan.egress.vlanCmd =
                      CPSS_DXCH_PCL_ACTION_INGRESS_VLAN_ID1_CMD_DO_NOT_MODIFY_E;
            action.vlan.egress.vlanId1 = BIT_12-1;
            action.tmQueueId = BIT_14-1;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        }
        /*
            1.55. Call cpssDxChPclRuleActionGet with params same as 1.54.
            Expected: GT_OK and same values in actionPtr as were written.
        */

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /* verify values */
            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction,
                                          &actionGet);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                     "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                     dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.egress.modifyDscp,
                                             actionGet.qos.egress.modifyDscp,
                "get another actionPtr->qos.egress.modifyDscp than was set: %d",
                                              dev);
               UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.egress.modifyUp,
                                             actionGet.qos.egress.modifyUp,
                  "get another actionPtr->qos.egress.modifyUp than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.qos.egress.up1,
                                              actionGet.qos.egress.up1,
                       "get another actionPtr->qos.egress.up1 than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.egress.vlanCmd,
                                              actionGet.vlan.egress.vlanCmd,
                  "get another actionPtr->vlan.egress.vlanCmd than was set: %d",
                                              dev);
                UTF_VERIFY_EQUAL1_STRING_MAC( action.vlan.egress.vlanId1,
                                              actionGet.vlan.egress.vlanId1,
                  "get another actionPtr->vlan.egress.vlanId1 than was set: %d",
                                              dev);
                if(PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.trafficManager.supported)
                {
                    UTF_VERIFY_EQUAL1_STRING_MAC( action.tmQueueId,
                                                  actionGet.tmQueueId,
                                "get another actionPtr->tmQueueId than was set: %d",
                                                  dev);
                }
            }
        }
        /*
            1.56. Call function with out of range modifyDscp
                   and other parameters from 1.54.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                                (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                                action.qos.egress.modifyDscp);
        }
        /*
            1.57. Call function with out of range modifyUp
                   and other parameters from 1.54.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                                (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                                action.qos.egress.modifyUp);
        }
        /*
            1.58. Call function with out of range up1 [BIT_3]
                   and other parameters from 1.54.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.qos.egress.up1 = BIT_3;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.qos.egress.up1 = 0;
        }
        /*
            1.59. Call function with out of range vlanCmd
                   and other parameters from 1.54.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                                (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                                action.vlan.egress.vlanCmd);
        }
        /*
            1.60. Call function with out of range vlanId1 [BIT_12]
                   and other parameters from 1.54.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.vlan.egress.vlanId1 = BIT_12;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.vlan.egress.vlanId1 = 0;
        }
        /*
            1.61. Call function with out of range tmQueueId [BIT_14]
                   and other parameters from 1.54.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            action.tmQueueId = BIT_14;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            if(PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.trafficManager.supported)
            {
                UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }
            else
            {
                /* tmQueueId ignored */
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }

            action.tmQueueId = 0;
        }
        /*
            1.62. Call function with
                    action{
                        redirect {
                           redirectCmd [
                            CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                           data {
                               logicalSourceInterface{
                                   logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                                     devPort {devNum=dev, portNum=0}]
                                   sourceMeshIdSetEnable[GT_TRUE/GT_FALSE]
                                   sourceMeshId[0/1/3]
                                   userTagAcEnable[GT_TRUE/GT_FALSE]
                               }}},
                        unknownSaCommandEnable[GT_TRUE/GT_FALSE]
                        unknownSaCommand[  CPSS_PACKET_CMD_FORWARD_E /
                                           CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                           CPSS_PACKET_CMD_TRAP_TO_CPU_E /
                                           CPSS_PACKET_CMD_DROP_HARD_E /
                                           CPSS_PACKET_CMD_DROP_SOFT_E]}
                    and other parameters from 1.54.
            Expected: GT_OK  for xCat C0; xCat3.
        */
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
        {
            /*
                Call function with
                        action{
                            redirect {
                               redirectCmd [
                                CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                               data {
                                   logicalSourceInterface{
                                       logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                                         devPort {devNum=0, portNum=0} ]
                                       sourceMeshIdSetEnable[GT_FALSE]
                                       sourceMeshId[0]
                                       userTagAcEnable[GT_FALSE]
                                   }}},
                            unknownSaCommandEnable[GT_FALSE]
                            unknownSaCommand[   CPSS_PACKET_CMD_FORWARD_E ]}
                        and other parameters from 1.54.
            */
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E;
            action.redirect.data.logicalSourceInterface.logicalInterface.type = CPSS_INTERFACE_PORT_E;
            action.redirect.data.logicalSourceInterface.logicalInterface.devPort.hwDevNum = dev;
            action.redirect.data.logicalSourceInterface.logicalInterface.devPort.portNum = 0;
            action.redirect.data.logicalSourceInterface.sourceMeshIdSetEnable = GT_FALSE;
            action.redirect.data.logicalSourceInterface.sourceMeshId = 0;
            action.redirect.data.logicalSourceInterface.userTagAcEnable = GT_FALSE;
            action.unknownSaCommandEnable = GT_FALSE;
            action.unknownSaCommand = CPSS_PACKET_CMD_FORWARD_E;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /*
                Call function with
                        action{
                            redirect {
                               data {
                                   logicalSourceInterface{
                                       sourceMeshIdSetEnable[GT_TRUE]
                                       sourceMeshId[1]
                                       userTagAcEnable[GT_TRUE]
                                   }}},
                            unknownSaCommandEnable[GT_TRUE]
                            unknownSaCommand[ CPSS_PACKET_CMD_MIRROR_TO_CPU_E ]}
                        and other parameters from 1.54.
            */
            action.redirect.data.logicalSourceInterface.sourceMeshIdSetEnable = GT_TRUE;
            action.redirect.data.logicalSourceInterface.sourceMeshId = 1;
            action.redirect.data.logicalSourceInterface.userTagAcEnable = GT_TRUE;
            action.unknownSaCommandEnable = GT_TRUE;
            action.unknownSaCommand = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            /*
                Call function with
                        action{
                            redirect {
                               data {
                                   logicalSourceInterface{
                                       sourceMeshId[3]
                                   }}},
                            unknownSaCommand[   CPSS_PACKET_CMD_TRAP_TO_CPU_E ]}
                        and other parameters from 1.54.
            */

            action.redirect.data.logicalSourceInterface.sourceMeshId = 3;
            action.unknownSaCommand = CPSS_PACKET_CMD_TRAP_TO_CPU_E;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            /*
                Call function with
                        action{
                            unknownSaCommand[   CPSS_PACKET_CMD_DROP_HARD_E ]}
                        and other parameters from 1.54.
            */
            action.unknownSaCommand = CPSS_PACKET_CMD_DROP_HARD_E;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            /*
                Call function with
                        action{
                            unknownSaCommand[   CPSS_PACKET_CMD_DROP_SOFT_E ]}
                        and other parameters from 1.54.
            */
            action.unknownSaCommand = CPSS_PACKET_CMD_DROP_SOFT_E;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }
        /*
            1.63. Call function with out of range sourceMeshId [4]
                   and other parameters from 1.54.
            Expected: GT_OK  for xCat C0; xCat3.
        */
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.redirect.data.logicalSourceInterface.sourceMeshId = 4;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            action.redirect.data.logicalSourceInterface.sourceMeshId = 0;
        }
        /*
            1.64. Call function with out of range unknownSaCommand
                   and other parameters from 1.54.
            Expected: GT_OK  for xCat C0; xCat3.
        */
        if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionUpdate
                                (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                                action.unknownSaCommand);
        }
        /*
            1.65. For bobCat2 and above call with out of range
            actionPtr->copyReserved.copyReserved and other params from 1.54
            Expected: GT_OUT_OF_RANGE.
        */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            action.copyReserved.assignEnable = GT_TRUE;
            action.copyReserved.copyReserved = PRV_CPSS_SIP_6_10_CHECK_MAC(dev) ? BIT_19 : BIT_18;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OUT_OF_RANGE, st,
                            "%d, %d, %d, actionPtr->copyReserved.copyReserved = %d",
                            dev, ruleSize, ruleIndex, action.copyReserved.copyReserved);

            action.copyReserved.copyReserved = 0; /* restore valid value */
        }

        /*
            1.66 Call function with action.pktcmd = CPSS_PACKET_CMD_MIRROR_TO_CPU_E
                                    action.mirror.cpuCode = CPSS_NET_CONTROL_SRC_DST_MAC_TRAP_E
         */
        if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
        {
            /*pclActionDefaultSet(&action);*/
            action.pktCmd = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
            action.mirror.cpuCode = CPSS_NET_ETH_BRIDGED_LLT_E;
            action.egressPolicy = GT_TRUE;
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->action.pktCmd = %d",
                dev, ruleSize, ruleIndex, action.pktCmd);

            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                         dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
                /* verifying values */
                /*pktCmd*/
                UTF_VERIFY_EQUAL1_STRING_MAC(action.pktCmd, retAction.pktCmd,
                     "cpssDxChPclRuleActionGet: "
                     "get another action.pktCmd than was set: dev = %d", dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(action.mirror.cpuCode, retAction.mirror.cpuCode,
                     "cpssDxChPclRuleActionGet: "
                     " action.mirror.cpuCode  = %d", retAction.mirror.cpuCode);
            }

            action.pktCmd = CPSS_PACKET_CMD_TRAP_TO_CPU_E;
            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->action.pktCmd = %d",
                dev, ruleSize, ruleIndex, action.pktCmd);

            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                         dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
                /* verifying values */
                /*pktCmd*/
                UTF_VERIFY_EQUAL1_STRING_MAC(action.pktCmd, retAction.pktCmd,
                     "cpssDxChPclRuleActionGet: "
                     "get another action.pktCmd than was set: dev = %d", dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(action.mirror.cpuCode, retAction.mirror.cpuCode,
                     "cpssDxChPclRuleActionGet: "
                     " action.mirror.cpuCode  = %d", retAction.mirror.cpuCode);
            }
        }

        if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
        {
            /*
                1.68 Call function with action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ECMP_E;
                                    action.redirect.data.routerLttIndex = 964;
                Expected: GT_OK and same values in actionPtr as were written for AC5P.
            */
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ECMP_E;
            action.redirect.data.routerLttIndex = 964;
            action.egressPolicy = GT_FALSE;
            direction = CPSS_PCL_DIRECTION_INGRESS_E;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "%d, %d, %d", dev, ruleSize, ruleIndex);

            /* Get PCL action */
            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                         dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
                /* verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(action.redirect.redirectCmd,
                                             retAction.redirect.redirectCmd,
                                             "action.redirect.redirectCmd didn't match: dev = %d",
                                             dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(action.redirect.data.routerLttIndex,
                                             retAction.redirect.data.routerLttIndex,
                                             "action.redirect.data.routerLttIndex didn't match: dev = %d",
                                             dev);
            }

            /*
                1.69 Call function with action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ECMP_E;
                                    action.redirect.data.routerLttIndex = 964;
                Expected: GT_OK and same values in actionPtr as were written for AC5P.
            */
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ECMP_AND_ASSIGN_VRF_ID_E;
            action.redirect.data.routeAndVrfId.routerLttIndex = 964;
            action.redirect.data.routeAndVrfId.vrfId = 0;

            st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, action.redirect.redirectCmd = %d",
                dev, ruleSize, ruleIndex, action.redirect.redirectCmd);

            /* Get PCL action */
            st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "cpssDxChPclRuleActionGet: %d, %d, %d, %d",
                                         dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
                /* verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(action.redirect.redirectCmd,
                                             retAction.redirect.redirectCmd,
                                             "action.redirect.redirectCmd didn't match: dev = %d",
                                             dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(action.redirect.data.routeAndVrfId.routerLttIndex,
                                             retAction.redirect.data.routeAndVrfId.routerLttIndex,
                                             "action.redirect.data.routeAndVrfId.routerLttIndex didn't match: dev = %d",
                                             dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(action.redirect.data.routeAndVrfId.vrfId,
                                             retAction.redirect.data.routeAndVrfId.vrfId,
                                             "action.redirect.data.routeAndVrfId.vrfId didn't match: dev = %d",
                                             dev);
            }

        }

        /*
            1.70. Call cpssDxChPclRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
            ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
            Expected: GT_OK.
        */
        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                "cpssDxChPclRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);
    }

    /* Set valid parameters. As soon as family of device can't be determined */
    /* - values valid for any family                                         */
    ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    ruleIndex = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclRuleActionUpdate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclRuleActionGet
(
    IN  GT_U8                              devNum,
    IN  CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN  GT_U32                             ruleIndex,
    IN CPSS_PCL_DIRECTION_ENT              direction,
    OUT CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclRuleActionGet)
{
/*
    ITERATE_DEVICES
    1.1. Set default rule for testing.
    Expected: GT_OK.
    1.2. Check with legal parameters. Call with ruleSize[CPSS_PCL_RULE_SIZE_STD_E],
    ruleIndex [PCL_TESTED_RULE_INDEX], direction [CPSS_PCL_DIRECTION_INGRESS_E],
    non-NULL actionPtr.
    Expected: GT_OK
    1.3. Check with rule size for other type of rule.
    Call with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], other params same as in 1.2.
    Expected: NOT GT_OK.
    1.4.  Call with ruleSize [wrong enum values], other params same as in 1.2.
    Expected: GT_BAD_PARAM.
    1.5.  Call with wrong ruleIndex, other parameters same as in 1.2.
    Expected: NON GT_OK.
    1.6.  Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
    other params same as in 1.2.
    Expected: GT_OK.
    1.7.  Call with direction [wrong enum values], other parameters same as in 1.2.
    Expected: GT_BAD_PARAM.
    1.8. Call with actionPtr [NULL], other parameters same as in 1.2.
    Expected: GT_BAD_PTR.
    1.9. Call cpssDxChPclRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
    ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
    Expected: GT_OK.
*/
    GT_STATUS       st = GT_OK;

    GT_U8                     dev;
    CPSS_PCL_RULE_SIZE_ENT    ruleSize;
    GT_U32                    ruleIndex;
    CPSS_PCL_DIRECTION_ENT    direction;
    CPSS_DXCH_PCL_ACTION_STC  retAction;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);
    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Set default rule for testing.
            Expected: GT_OK.
        */
        st = pclRuleTestingDefaultSet(dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclRuleSet: %d", dev);

        /*
            1.2. Check with legal parameters. Call with ruleSize[CPSS_PCL_RULE_SIZE_STD_E],
            ruleIndex [PCL_TESTED_RULE_INDEX], direction [CPSS_PCL_DIRECTION_INGRESS_E],
            non-NULL actionPtr.
            Expected: GT_OK
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
        ruleIndex = PCL_TCAM_RAWS(dev) - 1;
        direction = CPSS_PCL_DIRECTION_INGRESS_E;

        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction);
        if (st != GT_BAD_STATE)
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(
                GT_OK, st, dev, ruleSize, ruleIndex, direction);
        }

        /*
            1.3. Check with rule size for other type of rule.
            Call with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], other params same as in 1.2.
            Expected: NOT GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;
        /* maximal index of standard rule, invalid for exteded rule */
        /* RuleActionGet uses ruleIndex only for action HW index calculation */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_TRUE) {
            ruleIndex = (PCL_TCAM_RAWS(dev));
        }
        else
            ruleIndex = (PCL_TCAM_RAWS(dev) * 4) - 1;

        st = cpssDxChPclRuleActionGet(
            dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction);
        if (st != GT_BAD_STATE)
        {
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleSize);
        }

        ruleSize = CPSS_PCL_RULE_SIZE_STD_E; /* restore valid values */
        ruleIndex = PCL_TCAM_RAWS(dev) - 1;

        /*
            1.4.  Call with ruleSize [wrong enum values], other params same as in 1.2.
            Expected: GT_BAD_PARAM.
        */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_FALSE)
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionGet
                                (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction),
                                ruleSize);
        }

        /*
            1.5.  Call with wrong ruleIndex, other parameters same as in 1.2.
            Expected: NON GT_OK.
        */
        ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

        /*
            1.6.  Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
            other params same as in 1.2.
            Expected: GT_OK.
        */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;

        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction);
        if (st != GT_BAD_STATE)
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(
                GT_OK, st, dev, ruleSize, ruleIndex, direction);
        }

        direction = CPSS_PCL_DIRECTION_INGRESS_E; /* restore */

        /*
            1.7.  Call with direction [wrong enum values], other parameters same as in 1.2.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleActionGet
                            (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction),
                            direction);

        /*
            1.8. Call with actionPtr [NULL], other parameters same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, NULL);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_BAD_PTR, st, "%d, %d, %d, %d, NULL",
                                     dev, ruleSize, ruleIndex, direction);

        /*
            1.9. Call cpssDxChPclRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
            ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
            Expected: GT_OK.
        */
        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChPclRuleInvalidate: %d, %d, %d",
                                     dev, ruleSize, ruleIndex);
   }

    /* Set valid parameters. As soon as family of device can't be determined */
    /* - values valid for any family                                         */
    ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    ruleIndex = 0;
    direction = CPSS_PCL_DIRECTION_INGRESS_E;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclRuleActionGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, direction, &retAction);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclRuleInvalidate
(
    IN GT_U8                              devNum,
    IN CPSS_DXCH_PCL_RULE_SIZE_ENT        ruleSize,
    IN GT_U32                             ruleIndex
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclRuleInvalidate)
{
/*
    ITERATE_DEVICES
    1.1. Set rule for testing.
    Expected: GT_OK.
    1.2. Check for invalid ruleSize for rule which was written as standard rule.
    Call with invalid ruleSize [CPSS_DXCH_PCL_RULE_SIZE_EXT_E],
    ruleIndex [PCL_TESTED_RULE_INDEX].
    Expected: NOT GT_OK.
    1.3. Invalidate written rule with legal parameters.  Call with
        ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E],
        ruleIndex [PCL_TESTED_RULE_INDEX].
    Expected: GT_OK.
    1.4. Call with ruleSize [wrong enum values].
    Expected: GT_BAD_PARAM.
    1.5. Call with wrong ruleIndex.
    Expected: NON GT_OK.
*/
    GT_STATUS                       st = GT_OK;
    GT_U8                           dev;
    GT_U32                          ruleIndex;
    CPSS_PCL_RULE_SIZE_ENT          ruleSize;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Set rule for testing.
            Expected: GT_OK.
        */
        st = pclRuleTestingDefaultSet(dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclRuleSet: %d", dev);

        /*
            1.2. Check for invalid ruleSize for rule which was written as standard rule.
            Call with invalid ruleSize [CPSS_DXCH_PCL_RULE_SIZE_EXT_E],
            ruleIndex [PCL_TESTED_RULE_INDEX].
            Expected: NOT GT_OK.
        */

        /* The cpssDxChPclRuleValidStatusSet function ckecks the   */
        /* found rule state. The cpssDxChPclRuleInvalidate just    */
        /* sets the Y and Y "valid" bit in the position calculated */
        /* by ruleSize and ruleIndex                               */
        ruleSize      = CPSS_PCL_RULE_SIZE_EXT_E;

        /* index valid for STD but invalid for EXT rule  */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_TRUE) {
             ruleIndex = (PCL_TCAM_RAWS(dev));
        }
        else
            ruleIndex = (PCL_TCAM_RAWS(dev) * 4) - 1;


        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

        /*
            1.3. Invalidate written rule with legal parameters. Call with
                ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E],
                ruleIndex [PCL_TESTED_RULE_INDEX].
            Expected: GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

        /*
            1.4. Call with ruleSize [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_FALSE)
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleInvalidate
                                (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex),
                                ruleSize);
        }

        /*
            1.5. Call with wrong ruleIndex.
            Expected: NON GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
        ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);
    }

    ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    ruleIndex = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclRuleValidStatusSet
(
    IN GT_U8                              devNum,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN GT_BOOL                            valid
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclRuleValidStatusSet)
{
/*
    ITERATE_DEVICES (DxChx)
    1.1. Set rule for testing.
    Expected: GT_OK.
    1.2. Call with  ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                    ruleIndex [PCL_TESTED_RULE_INDEX ],
                    valid [GT_TRUE / GT_FALSE].
    Expected: GT_OK.
    1.3. Call with  ruleSize [CPSS_PCL_RULE_SIZE_EXT_E],
                    ruleIndex [PCL_TESTED_RULE_INDEX],
                    valid [GT_FALSE].
    Try to set status of created rule with another ruleSize.
    Expected: NOT GT_OK.
    1.4. Call with  ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                    ruleIndex [0],
                    valid [GT_FALSE].
    Try to set status of created rule with another ruleIndex.
    Expected: NOT GT_OK.
    1.5. Call with wrong enum values ruleSize, and other parameters from 1.2.
    Expected: NOT GT_OK.
    1.6. Call with out of range ruleIndex, and other parameters from 1.2.
    Expected: NOT GT_OK.
    1.7. Invalidate created rule.  Call cpssDxChPclRuleInvalidate with
        ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E],
        ruleIndex [PCL_TESTED_RULE_INDEX].
    Expected: GT_OK.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    CPSS_PCL_RULE_SIZE_ENT  ruleSize    = CPSS_PCL_RULE_SIZE_STD_E;
    GT_U32                  correctStdRuleIndex;
    GT_U32                  damagedStdRuleIndex;
    GT_U32                  damagedExtRuleIndex;
    GT_U32                  ruleIndex;
    GT_BOOL                 valid       = GT_FALSE;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Set rule for testing.
            Expected: GT_OK.
        */
        correctStdRuleIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);
        damagedStdRuleIndex = PCL_DAMAGED_STD_RULE_INDEX_MAC(dev);
        damagedExtRuleIndex = PCL_DAMAGED_EXT_RULE_INDEX_MAC(dev);
        ruleIndex           = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);

        st = pclRulesForCopyAndStatusTesting(dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(
            GT_OK, st, "pclRulesForCopyAndStatusTesting: %d", dev);

        /*
            1.2. Call with  ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                            ruleIndex [PCL_TESTED_RULE_INDEX],
                            valid [GT_TRUE / GT_FALSE].
            Expected: GT_OK.
        */
        /* call with valid = GT_TRUE */
        ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
        valid     = GT_TRUE;

        st = cpssDxChPclRuleValidStatusSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleSize, correctStdRuleIndex, valid);
        UTF_VERIFY_EQUAL4_PARAM_MAC(
            GT_OK, st, dev, ruleSize, correctStdRuleIndex, valid);

        /* call with valid = GT_FALSE */
        valid = GT_FALSE;

        st = cpssDxChPclRuleValidStatusSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleSize, correctStdRuleIndex, valid);
        UTF_VERIFY_EQUAL4_PARAM_MAC(
            GT_OK, st, dev, ruleSize, correctStdRuleIndex, valid);

        /*
            1.3. Call with  ruleSize [CPSS_PCL_RULE_SIZE_EXT_E],
                            ruleIndex [PCL_TESTED_RULE_INDEX],
                            valid [GT_FALSE].
            Try to set status of created rule with another ruleSize.
            Expected: NOT GT_OK.
        */
        /* call with ruleSize = CPSS_PCL_RULE_SIZE_EXT_E */
        ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;

        st = cpssDxChPclRuleValidStatusSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleSize, damagedExtRuleIndex, valid);

        /* in E_ARCH when changing validitiy ruleSize is ignored */
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev))
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(
                GT_OK, st, dev, ruleSize, damagedExtRuleIndex, valid);
        }
        else
        {
            UTF_VERIFY_NOT_EQUAL2_STRING_MAC(
                GT_OK, st, "%d, ruleSize = %d", dev, ruleSize);
        }

        /*
            1.4. Call with  ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                            ruleIndex [0],
                            valid [GT_FALSE].
            Try to set status of created rule with another ruleIndex.
            Expected: NOT GT_OK.
        */

        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;

        st = cpssDxChPclRuleValidStatusSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleSize, damagedStdRuleIndex, valid);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev))
        {
            UTF_VERIFY_EQUAL4_PARAM_MAC(
                GT_OK, st, dev, ruleSize, damagedStdRuleIndex, valid);
        }
        else
        {
            UTF_VERIFY_NOT_EQUAL2_STRING_MAC(
                GT_OK, st, "%d, ruleIndex = %d", dev, damagedStdRuleIndex);
        }


        /*
            1.5. Call with wrong enum values ruleSize, and other parameters from 1.2.
            Expected: NOT GT_OK.
        */
        ruleIndex = correctStdRuleIndex;
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_FALSE)
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleValidStatusSet
                                (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, valid),
                                ruleSize);
        }

        /*
            1.6. Call with out of range ruleIndex, and other parameters from 1.2.
            Expected: NOT GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
        ruleIndex = 0x00FFFFFF;

        st = cpssDxChPclRuleValidStatusSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, valid);
        UTF_VERIFY_NOT_EQUAL2_STRING_MAC(
            GT_OK, st, "%d, ruleIndex = %d", dev, ruleIndex);

        /*
            1.7. Invalidate created rule.  Call cpssDxChPclRuleInvalidate with
                ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E],
                ruleIndex [PCL_TESTED_RULE_INDEX].
            Expected: GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;

        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, correctStdRuleIndex);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, correctStdRuleIndex);
    }

    ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
    ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
    valid     = GT_TRUE;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclRuleValidStatusSet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, valid);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/

    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclRuleValidStatusSet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, valid);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclRuleCopy
(
    IN GT_U8                              devNum,
    IN CPSS_DXCH_PCL_RULE_SIZE_ENT        ruleSize,
    IN GT_U32                             ruleSrcIndex,
    IN GT_U32                             ruleDstIndex
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclRuleCopy)
{
/*
    ITERATE_DEVICES
    1.1. Set rule for testing.
    Expected: GT_OK.
    1.2.  Call with correct parameters. RuleSize [CPSS_PCL_RULE_SIZE_EXT_E],
            ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
    Expected: GT_OK.
    1.3. Try to copy with ruleSize which isn't applicable for standard rule.
        Call with ruleSize [CPSS_DXCH_PCL_RULE_SIZE_EXT_E],
        ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
    Expected: NON GT_OK.
    1.4. Call with ruleSize [wrong enum values],
    ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
    Expected: GT_BAD_PARAM.
    1.5. Call with wrong source rule index.
    Expected: NON GT_OK.
    1.6. Call with wrong destination rule index.
    Expected: NON GT_OK.
    1.7. Invalidate source rule. Call cpssDxChPclRuleInvalidate with
                ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E],
                ruleIndex [PCL_TESTED_RULE_INDEX].
    Expected: GT_OK.
    1.8. Invalidate source rule. Call cpssDxChPclRuleInvalidate with
                ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E],
                ruleIndex [0].
    Expected: GT_OK.
*/
    GT_STATUS                       st = GT_OK;
    GT_U8                           dev;
    GT_U32                          ruleSrcIndex;
    GT_U32                          ruleDstIndex;
    CPSS_PCL_RULE_SIZE_ENT          ruleSize;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);
    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Set rule for testing.
            Expected: GT_OK.
        */
        st = pclRulesForCopyAndStatusTesting(dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(
            GT_OK, st, "pclRulesForCopyAndStatusTesting: %d", dev);

        /*
            1.2.  Call with correct parameters. RuleSize [CPSS_PCL_RULE_SIZE_EXT_E],
                    ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
            Expected: GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
        ruleSrcIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);
        ruleDstIndex = 0;

        st = cpssDxChPclRuleCopy(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleSrcIndex, ruleDstIndex);

        /*
            1.3. Try to copy with ruleSize which isn't applicable for standard rule.
                Call with ruleSize [CPSS_DXCH_PCL_RULE_SIZE_EXT_E],
                ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
            Expected: NON GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;
        ruleSrcIndex = PCL_DAMAGED_EXT_RULE_INDEX_MAC(dev);
        ruleDstIndex = 0;

        st = cpssDxChPclRuleCopy(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex);
        UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, dev, ruleSize,
                                        ruleSrcIndex, ruleDstIndex);

        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;

        /*
            1.4. Call with ruleSize [wrong enum values],
            ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleCopy
                            (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex),
                            ruleSize);

        /*
            1.5. Call with wrong source rule index.
            Expected: NON GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
        ruleSrcIndex = PCL_INVALID_STD_RULE_INDEX(dev);
        ruleDstIndex = 0;

        st = cpssDxChPclRuleCopy(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleSrcIndex);

        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
        ruleSrcIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);

        /*
            1.6. Call with wrong destination rule index.
            Expected: NON GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
        ruleSrcIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);
        ruleDstIndex = PCL_INVALID_STD_RULE_INDEX(dev);

        st = cpssDxChPclRuleCopy(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex);
        UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, dev, ruleSize,
                                        ruleSrcIndex, ruleDstIndex);

        ruleDstIndex = 0;

        /*
            1.7. Invalidate source rule. Call cpssDxChPclRuleInvalidate with
                        ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E],
                        ruleIndex [PCL_TESTED_RULE_INDEX].
            Expected: GT_OK.
        */
        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleSrcIndex);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChPclRuleInvalidate: %d, %d, %d",
                           dev, ruleSize, ruleSrcIndex);

        /*
            1.8. Invalidate source rule. Call cpssDxChPclRuleInvalidate with
                        ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E],
                        ruleIndex [0].
            Expected: GT_OK.
        */
        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleDstIndex);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChPclRuleInvalidate: %d, %d, %d",
                           dev, ruleSize, ruleDstIndex);
    }

    ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    ruleSrcIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
    ruleDstIndex = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclRuleCopy(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclRuleCopy(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclRuleStateGet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        ruleIndex,
    OUT GT_BOOL                       *validPtr,
    OUT CPSS_PCL_RULE_SIZE_ENT        *ruleSizePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclRuleStateGet)
{
/*
    ITERATE_DEVICES
    1.1. Set rule for testing.
    Expected: GT_OK.
    1.2. For all devices check with legal parameters.
    Call with ruleIndex [PCL_TESTED_RULE_INDEX], non-NULL validPtr and ruleSizePtr.
    Expected: GT_OK, validPtr = GT_TRUE, ruleSizePtr = CPSS_PCL_RULE_SIZE_STD_E;
    1.3. Call with wrong ruleIndex, other parameters same as in 1.2.
    Expected: NON GT_OK.
    1.4. Call with validPtr [NULL], other parameters same as in 1.2.
    Expected: GT_BAD_PTR.
    1.5. Call with ruleSizePtr [NULL], other parameters same as in 1.2.
    Expected: GT_BAD_PTR.
    1.6. Call cpssDxChPclRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
    ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
    Expected: GT_OK.
    1.7. Get state for invalidated rule. Call with ruleIndex [PCL_TESTED_RULE_INDEX],
    non-NULL validPtr and ruleSizePtr.
    Expected: GT_OK and valid == GT_FALSE.
*/
    GT_STATUS       st = GT_OK;

    GT_U8                               dev;
    GT_U32                              ruleIndex;
    GT_BOOL                             valid;
    CPSS_PCL_RULE_SIZE_ENT              ruleSize;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Set rule for testing.
            Expected: GT_OK.
        */
        st = pclRuleTestingDefaultSet(dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclRuleSet: %d", dev);

        /*
            1.2. For all devices check with legal parameters.
            Call with ruleIndex [PCL_TESTED_RULE_INDEX], non-NULL validPtr and ruleSizePtr.
            Expected: GT_OK, validPtr = GT_TRUE, ruleSizePtr = CPSS_PCL_RULE_SIZE_STD_E;
        */
        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

        st = cpssDxChPclRuleStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleIndex, &valid, &ruleSize);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

        UTF_VERIFY_EQUAL2_STRING_MAC(GT_TRUE, valid,
                "get invalid rule: %d, %d", dev, ruleIndex);

        UTF_VERIFY_EQUAL2_STRING_MAC(CPSS_PCL_RULE_SIZE_STD_E, ruleSize,
                "get another rule size than was set: %d, %d", dev, ruleIndex);

        /*
            1.3. Call with wrong ruleIndex, other parameters same as in 1.2.
            Expected: NON GT_OK.
        */
        ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

        st = cpssDxChPclRuleStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleIndex, &valid, &ruleSize);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

        /*
            1.4. Call with validPtr [NULL], other parameters same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleIndex, NULL, &ruleSize);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PTR, st, "%d, %d, validPtr = NULL",
                                     dev, ruleIndex);

        /*
            1.5. Call with ruleSizePtr [NULL], other parameters same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleIndex, &valid, NULL);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PTR, st, "%d, %d, ruleSizePtr = NULL",
                                     dev, ruleIndex);

        /*
            1.6. Call cpssDxChPclRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
            ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
            Expected: GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;

        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "cpssDxChPclRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);

        /*
            1.7. Get state for invalidated rule. Call with ruleIndex [PCL_TESTED_RULE_INDEX],
            non-NULL validPtr and ruleSizePtr.
            Expected: GT_OK and valid == GT_FALSE.
        */
        st = cpssDxChPclRuleStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleIndex, &valid, &ruleSize);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "cpssDxChPclRuleStateGet: %d, %d", dev, ruleIndex);

        UTF_VERIFY_EQUAL2_STRING_MAC(GT_FALSE, valid,
                "get invalid rule: %d, %d", dev, ruleIndex);

        UTF_VERIFY_EQUAL2_STRING_MAC(CPSS_PCL_RULE_SIZE_STD_E, ruleSize,
                "get another rule size than was set: %d, %d", dev, ruleIndex);

    }

    /* Set valid parameters. As soon as family of device can't be determined */
    /* - values valid for any family                                         */
    ruleIndex = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclRuleStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleIndex, &valid, &ruleSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclRuleStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleIndex, &valid, &ruleSize);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclRuleAnyStateGet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_RULE_SIZE_ENT        ruleSize,
    IN  GT_U32                        ruleIndex,
    OUT GT_BOOL                       *validPtr,
    OUT CPSS_PCL_RULE_SIZE_ENT        *ruleSizePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclRuleAnyStateGet)
{
/*
    ITERATE_DEVICES (DxChx)
    1.1. Set rule for testing.
    Expected: GT_OK.
    1.2. Call with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                   ruleIndex [PCL_TESTED_RULE_INDEX],
                   non-NULL validPtr and non-NULL ruleSizePtr.
    Expected: GT_OK.
    1.3. Call with out of range ruleIndex, and other parameters same as in 1.2.
    Expected: NON GT_OK.
    1.4. Call with validPtr [NULL], and other parameters same as in 1.2.
    Expected: GT_BAD_PTR.
    1.5. Call with ruleSizePtr [NULL], and other parameters same as in 1.2.
    Expected: GT_BAD_PTR.
    1.6. Call cpssDxChPclRuleInvalidate with
            ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
            ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
    Expected: GT_OK.
    1.7. Get state for invalidated rule.
         Call with ruleIndex [PCL_TESTED_RULE_INDEX],
                   non-NULL validPtr
                   and non-NULL ruleSizePtr.
    Expected: GT_OK, validPtr = GT_FALSE.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    CPSS_PCL_RULE_SIZE_ENT  ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
    GT_U32                  ruleIndex = 0;
    GT_BOOL                 valid     = GT_FALSE;

    CPSS_PP_FAMILY_TYPE_ENT devFamily;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,"prvUtfDeviceFamilyGet: %d", dev);

        /*
            1.1. Set rule for testing.
            Expected: GT_OK.
        */
        st = pclRuleTestingDefaultSet(dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclRuleSet: %d", dev);

        /*
            1.2. Call with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                           ruleIndex [PCL_TESTED_RULE_INDEX],
                           non-NULL validPtr and non-NULL ruleSizePtr.
            Expected: GT_OK.
        */
        ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

        st = cpssDxChPclRuleAnyStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &valid, &ruleSize);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

        /*
            1.3. Call with out of range ruleIndex, and other parameters same as in 1.2.
            Expected: NON GT_OK.
        */
        ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

        st = cpssDxChPclRuleAnyStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &valid, &ruleSize);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

        /*
            1.4. Call with validPtr [NULL], and other parameters same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleAnyStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, NULL, &ruleSize);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PTR, st, "%d, %d, validPtr = NULL",
                                     dev, ruleIndex);

        /*
            1.5. Call with ruleSizePtr [NULL], and other parameters same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleAnyStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &valid, NULL);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PTR, st, "%d, %d, ruleSizePtr = NULL",
                                     dev, ruleIndex);

        /*
            1.6. Call cpssDxChPclRuleInvalidate with
                    ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                    ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
            Expected: GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;

        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "cpssDxChPclRuleInvalidate: %d, %d, %d",
                                     dev, ruleSize, ruleIndex);

        /*
            1.7. Get state for invalidated rule.
                 Call with ruleIndex [PCL_TESTED_RULE_INDEX],
                           non-NULL validPtr
                           and non-NULL ruleSizePtr.
            Expected: GT_OK, validPtr = GT_FALSE.
        */
        ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

        st = cpssDxChPclRuleAnyStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &valid, &ruleSize);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

        UTF_VERIFY_EQUAL2_STRING_MAC(GT_FALSE, valid,
                "get invalid rule: %d, %d", dev, ruleIndex);

        UTF_VERIFY_EQUAL2_STRING_MAC(CPSS_PCL_RULE_SIZE_STD_E, ruleSize,
                "get another rule size than was set: %d, %d", dev, ruleIndex);

    }

    /* Set valid parameters. As soon as family of device can't be determined */
    /* - values valid for any family                                         */
    ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
    ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclRuleAnyStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &valid, &ruleSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclRuleAnyStateGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &valid, &ruleSize);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclRuleGet
(
    IN  GT_U8                  devNum,
    IN  CPSS_PCL_RULE_SIZE_ENT ruleSize,
    IN  GT_U32                 ruleIndex,
    OUT GT_U32                 mask[],
    OUT GT_U32                 pattern[],
    OUT GT_U32                 action[]
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclRuleGet)
{
/*
    ITERATE_DEVICES
    1.1. Set rule for testing.
    Expected: GT_OK.
    1.2. For all devices check with legal parameters.
        Call with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                  ruleIndex [PCL_TESTED_RULE_INDEX],
                  non-NULL mask, pattern and action.
    Expected: GT_OK.
    1.3. Check for invalid ruleSize for rule which was written as standard rule.
    Call with invalid ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], other params same as in 1.2.
    Expected: NON GT_OK.
    1.4. Check for wrong enum values ruleSize and other params same as in 1.2.
    Expected: GT_BAD_PARAM.
    1.5. Call with wrong ruleIndex and other parameters same as in 1.2.
    Expected: NON GT_OK.
    1.6. Call with mask [NULL], other parameters same as in 1.2.
    Expected: GT_BAD_PTR.
    1.7. Call with pattern [NULL], other parameters same as in 1.2.
    Expected: GT_BAD_PTR.
    1.8. Call with action [NULL], other parameters same as in 1.2.
    Expected: GT_BAD_PTR.
    1.9. Call cpssDxChPclRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
    ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
    Expected: GT_OK.
*/
    GT_STATUS       st = GT_OK;

    GT_U8                               dev;
    GT_U32                              ruleIndex;
    CPSS_PCL_RULE_SIZE_ENT              ruleSize;
    GT_U32                              mask[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS];
    GT_U32                              pattern[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS];
    GT_U32                              action[CPSS_DXCH_PCL_ACTION_SIZE_IN_WORDS_CNS];

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Set rule for testing.
            Expected: GT_OK.
        */
        st = pclRulesForCopyAndStatusTesting(dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(
            GT_OK, st, "pclRulesForCopyAndStatusTesting: %d", dev);

        /*
            1.2. For all devices check with legal parameters.
                Call with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                          ruleIndex [PCL_TESTED_RULE_INDEX],
                          non-NULL mask, pattern and action.
            Expected: GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
        ruleIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);

        st = cpssDxChPclRuleGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, mask, pattern, action);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

        /*
            1.3. Check for invalid ruleSize for rule which was written as standard rule.
            Call with invalid ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], other params same as in 1.2.
            Expected: NON GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;
        ruleIndex = PCL_DAMAGED_EXT_RULE_INDEX_MAC(dev);

        st = cpssDxChPclRuleGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, mask, pattern, action);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleSize);

        ruleSize = CPSS_PCL_RULE_SIZE_STD_E; /* restore valid value */

        /*
            1.4. Check for wrong enum values ruleSize and other params same as in 1.2.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclRuleGet
                            (dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, mask, pattern, action),
                            ruleSize);

        /*
            1.5. Call with wrong ruleIndex and other parameters same as in 1.2.
            Expected: NON GT_OK.
        */
        ruleSize = CPSS_PCL_RULE_SIZE_STD_E; /* restore valid value */
        ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

        st = cpssDxChPclRuleGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, mask, pattern, action);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

        ruleSize = CPSS_PCL_RULE_SIZE_STD_E; /* restore valid value */
        ruleIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev); /* restore valid value */

        /*
            1.6. Call with mask [NULL], other parameters same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, NULL, pattern, action);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, mask = NULL", dev);

        /*
            1.7. Call with pattern [NULL], other parameters same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, mask, NULL, action);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, pattern = NULL", dev);

        /*
            1.8. Call with action [NULL], other parameters same as in 1.2.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclRuleGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, mask, pattern, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, action = NULL", dev);

        /*
            1.9. Call cpssDxChPclRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
            ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
            Expected: GT_OK.
        */
        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "cpssDxChPclRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);
    }

    /* Set valid parameters. As soon as family of device can't be determined */
    /* - values valid for any family                                         */
    ruleIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);
    ruleSize = CPSS_PCL_RULE_SIZE_STD_E;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclRuleGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, mask, pattern, action);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclRuleGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, mask, pattern, action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortIngressPolicyEnable
(
    IN GT_U8    devNum,
    IN GT_PORT_NUM    port,
    IN GT_BOOL  enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortIngressPolicyEnable)
{
/*
    ITERATE_DEVICES_PHY_CPU_PORTS
    1.1.1. Call with enable [GT_FALSE / GT_TRUE].
    Expected: GT_OK.
*/
    GT_STATUS st = GT_OK;

    GT_U8       dev;
    GT_PORT_NUM port;
    GT_BOOL     enable;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextVirtPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        while (GT_OK == prvUtfNextVirtPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1. Call with enable [GT_FALSE / GT_TRUE].
                Expected: GT_OK.
            */
            enable = GT_FALSE;

            st = cpssDxChPclPortIngressPolicyEnable(dev, port, enable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, enable);

            enable = GT_TRUE;

            st = cpssDxChPclPortIngressPolicyEnable(dev, port, enable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, enable);
        }

        /* 1.2. Check that function handles CPU port    */
        port = PRV_CPSS_DXCH_CPU_PORT_NUM_CNS;
        enable = GT_TRUE;

        /* 1.2.1. <Check other parameters for each active device id and CPU port>. */

        st = cpssDxChPclPortIngressPolicyEnable(dev, port, enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, enable);

        /* prepare physical port iterator */
        st = prvUtfNextVirtPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.3. Go over non configured ports */
        while (GT_OK == prvUtfNextVirtPortGet(&port, GT_FALSE))
        {
            /* 1.3.1. Call function for each non configured port.   */
            /* Expected: GT_BAD_PARAM                               */
            st = cpssDxChPclPortIngressPolicyEnable(dev, port, enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
        }

        /* 1.4. For active device check that function returns GT_BAD_PARAM  */
        /* for out of bound value for port number.                          */
        port = UTF_CPSS_PP_MAX_PORT_NUM_CNS(dev);

        st = cpssDxChPclPortIngressPolicyEnable(dev, port, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
    }

    /* 2. Go over not active devices    */
    /* Expected: GT_BAD_PARAM           */
    port = 0;
    enable = GT_TRUE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortIngressPolicyEnable(dev, port, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call function with out of bound value for device id    */
    /* Expected: GT_BAD_PARAM                                   */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortIngressPolicyEnable(dev, port, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortIngressPolicyEnableGet
(
    IN  GT_U8    devNum,
    IN  GT_PORT_NUM    port,
    OUT GT_BOOL  *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortIngressPolicyEnableGet)
{
/*
    ITERATE_DEVICES_PHY_CPU_PORTS
    1.1.1. Call with not null enablePtr.
    Expected: GT_OK.
    1.1.2. Call  with wrong enablePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;

    GT_U8       dev;
    GT_PORT_NUM port;
    GT_BOOL     enable;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextVirtPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        while (GT_OK == prvUtfNextVirtPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1. Call with not null enablePtr.
                Expected: GT_OK.
            */
            st = cpssDxChPclPortIngressPolicyEnableGet(dev, port, &enable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, enable);

            /*
                1.1.2. Call  with wrong enablePtr [NULL].
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortIngressPolicyEnableGet(dev, port, NULL);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_BAD_PTR, st, dev, port, enable);
        }

        /* 1.2. Check that function handles CPU port    */
        port = PRV_CPSS_DXCH_CPU_PORT_NUM_CNS;

        /* 1.2.1. <Check other parameters for each active device id and CPU port>. */

        st = cpssDxChPclPortIngressPolicyEnableGet(dev, port, &enable);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, enable);

        /* prepare physical port iterator */
        st = prvUtfNextVirtPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.3. Go over non configured ports */
        while (GT_OK == prvUtfNextVirtPortGet(&port, GT_FALSE))
        {
            /* 1.3.1. Call function for each non configured port.   */
            /* Expected: GT_BAD_PARAM                               */
            st = cpssDxChPclPortIngressPolicyEnableGet(dev, port, &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
        }

        /* 1.4. For active device check that function returns GT_BAD_PARAM  */
        /* for out of bound value for port number.                          */
        port = UTF_CPSS_PP_MAX_PORT_NUM_CNS(dev);

        st = cpssDxChPclPortIngressPolicyEnableGet(dev, port, &enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
    }

    /* 2. Go over not active devices    */
    /* Expected: GT_BAD_PARAM           */
    port = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortIngressPolicyEnableGet(dev, port, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call function with out of bound value for device id    */
    /* Expected: GT_BAD_PARAM                                   */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortIngressPolicyEnableGet(dev, port, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortLookupCfgTabAccessModeSet
(
    IN GT_U8                                          devNum,
    IN GT_PORT_NUM                                    port,
    IN CPSS_PCL_DIRECTION_ENT                         direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT                     lookupNum,
    IN GT_U32                                         subLookupNum,
    IN CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT mode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortLookupCfgTabAccessModeSet)
{
/*
    ITERATE_DEVICES_PHY_CPU_PORTS
    1.1.1. Check Ingress direction. For all devices call with
            direction [CPSS_PCL_DIRECTION_INGRESS_E],
            lookupNum [CPSS_PCL_LOOKUP_0_E],
            mode [CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E /
                  CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E /
                  CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E /
                  CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_SRC_TRG_E - Only for SIP_6_10].
    Expected: Verify by get
    1.1.2. Check Egress direction (not supported by Ch1).
    Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
    Expected: GT_OK for all dev except Cheetah.
    1.1.3. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E].
    Expected: GT_OK.
    1.1.4. Check wrong direction enum values.
    Expected: GT_BAD_PARAM.
    1.1.5. Check wrong lookupNum enum values.
    Expected: GT_BAD_PARAM.
    1.1.6. Call with subLookupNum [1],
    Expected: GT_OK for xCat and above and NOT GT_OK for other.
    1.1.7. Call with wrong subLookupNum [2],
    Expected: NOT GT_OK for xCat and above and GT_OK for other.
    1.1.8. Check out-of-range mode enum.
    Expected: GT_BAD_PARAM.
    1.1.9. Call with entryIndex[1] and other params as in 1.1.1.
    Expected: GT_OK
    1.1.10. For Bobcat2; Caelum; Bobcat3 call with direction[CPSS_PCL_DIRECTION_EGRESS_E],
        mode[CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E](is applicable)
        and other params as in 1.1.1.
    Expected: GT_OK.
    1.1.11. For Bobcat2; Caelum; Bobcat3 call with direction[CPSS_PCL_DIRECTION_INGRESS_E],
        mode[CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E](not applicable)
        and other params as in 1.1.1.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS st = GT_OK;

    GT_U8                                           dev;
    GT_PORT_NUM                                     port;
    CPSS_PCL_DIRECTION_ENT                          direction;
    CPSS_PCL_DIRECTION_ENT                          directionIterator;
    CPSS_PCL_LOOKUP_NUMBER_ENT                      lookupNum;
    GT_U32                                          subLookupNum = 0;
    CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT  mode, modeGet;
    GT_BOOL                                         iPcl0Bypass;

    /* used to test supported only by Cheetah2 values */
    CPSS_PP_FAMILY_TYPE_ENT                 devFamily;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        /* get device family */
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

        for(directionIterator = CPSS_PCL_DIRECTION_INGRESS_E ; directionIterator <= CPSS_PCL_DIRECTION_EGRESS_E; directionIterator++)
        {
            prvUtfNextGenericPortItaratorTypeSet(   directionIterator == CPSS_PCL_DIRECTION_INGRESS_E ?
                                                    UTF_GENERIC_PORT_ITERATOR_TYPE_DEFAULT_EPORT_E :
                                                    UTF_GENERIC_PORT_ITERATOR_TYPE_PHYSICAL_E);

            /* prepare physical port iterator */
            st = prvUtfNextGenericPortReset(&port, dev);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            while (GT_OK == prvUtfNextGenericPortGet(&port, GT_TRUE))
            {
                /*
                    1.1.1. Check Ingress direction. For all devices call with
                            direction [CPSS_PCL_DIRECTION_INGRESS_E],
                            lookupNum [CPSS_PCL_LOOKUP_0_E],
                            mode [CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E /
                                  CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E /
                                  CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E /
                                  CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_SRC_TRG_E].
                    Expected: GT_OK
                */
                direction = CPSS_PCL_DIRECTION_INGRESS_E;
                lookupNum = CPSS_PCL_LOOKUP_0_E;
                subLookupNum = 0;

                if(directionIterator == direction)
                {
                    for(mode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E;
                            mode <= CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_SRC_TRG_E; mode++)
                    {
                        st = cpssDxChPclPortLookupCfgTabAccessModeSet(
                                dev, port, direction, lookupNum,
                                subLookupNum, mode);

                        /* MODE_BY_EPORT - Only supported for E_ARCH devices */
                        if((mode == CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E) &&
                            (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == 0))
                        {
                            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, port, direction, lookupNum, mode);
                            continue;
                        }

                        /* MODE_BY_SRC_TRG - Only Supported - AC5P & AC5X */
                        if((mode == CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_SRC_TRG_E) &&
                                /*(!((PRV_CPSS_SIP_6_10_CHECK_MAC(dev)) && (!PRV_CPSS_SIP_6_20_CHECK_MAC(dev)))))*/
                                (!(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))))
                        {
                            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, port, direction, lookupNum, mode);
                            continue;
                        }
                        UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, port, direction, lookupNum, mode);

                        st = cpssDxChPclPortLookupCfgTabAccessModeGet(
                                dev, port, direction, lookupNum,
                                subLookupNum, &modeGet);
                        UTF_VERIFY_EQUAL5_PARAM_MAC(modeGet, mode, dev, port, direction, lookupNum, mode);
                    }
                    /* Restoring back to VLAN Mode - Below cases require this */
                    mode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E;
                }

                /*
                    1.1.2. Check Egress direction (not supported by Ch1).
                    Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
                    Expected: GT_OK for all dev except Cheetah.
                */
                direction = CPSS_PCL_DIRECTION_EGRESS_E;

                if(directionIterator == direction)
                {
                    st = cpssDxChPclPortLookupCfgTabAccessModeSet(
                        dev, port, direction, lookupNum,
                        subLookupNum, mode);
                    UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, port,
                                            direction, lookupNum, mode);
                }

                direction = CPSS_PCL_DIRECTION_INGRESS_E;

                /*
                    1.1.3. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E].
                    Expected: GT_OK.
                */
                lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;

                if(directionIterator == direction)
                {
                    st = cpssDxChPclPortLookupCfgTabAccessModeSet(
                        dev, port, direction, lookupNum,
                        subLookupNum, mode);
                    UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, port,
                                                direction, lookupNum, mode);
                }

                /*
                    1.1.4. Check wrong direction enum values.
                    Expected: GT_BAD_PARAM.
                */
                UTF_ENUMS_CHECK_MAC(cpssDxChPclPortLookupCfgTabAccessModeSet
                                    (dev, port, direction, lookupNum,
                                     subLookupNum, mode),
                                    direction);

                if(directionIterator == direction)
                {
                    /*
                        1.1.5. Check wrong lookupNum enum values.
                        Expected: GT_BAD_PARAM.
                    */
                    /* for CH1 the "lookupNum" ignored */
                    UTF_ENUMS_CHECK_MAC(cpssDxChPclPortLookupCfgTabAccessModeSet
                                        (dev, port, direction, lookupNum,
                                         subLookupNum, mode),
                                        lookupNum);
                }

                lookupNum = CPSS_PCL_LOOKUP_0_E; /* restore */

                /*
                    1.1.6. Call with subLookupNum [1],
                    Expected: GT_OK for xCat and above and NOT GT_OK for other.
                */
                subLookupNum = 1;

                if(directionIterator == direction)
                {
                    st = cpssDxChPclPortLookupCfgTabAccessModeSet(
                        dev, port, direction, lookupNum,
                        subLookupNum, mode);

                    if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
                    {
                        UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, port,
                                                        direction, lookupNum, mode);
                    }
                }

                subLookupNum = 0;

                /*
                    1.1.7. Call with wrong subLookupNum [2],
                    Expected: NOT GT_OK for xCat and above and GT_OK for other.
                */
                subLookupNum = 2;

                if(directionIterator == direction)
                {
                    st = cpssDxChPclPortLookupCfgTabAccessModeSet(
                        dev, port, direction, lookupNum,
                        subLookupNum, mode);

                    if (! PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
                    {
                        UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, port,
                                                        direction, lookupNum, mode);
                    }
                    else
                    {
                        UTF_VERIFY_NOT_EQUAL5_PARAM_MAC(GT_OK, st, dev, port,
                                                        direction, lookupNum, mode);
                    }
                }

                subLookupNum = 0;

                if(directionIterator == direction)
                {
                    /*
                        1.1.8. Check out-of-range mode enum.
                        Expected: GT_BAD_PARAM.
                    */
                    UTF_ENUMS_CHECK_MAC(cpssDxChPclPortLookupCfgTabAccessModeSet
                                        (dev, port, direction, lookupNum,
                                         subLookupNum, mode),
                                        mode);
                }

                /*
                    1.1.9. Call with entryIndex[1] and other params as in 1.1.1.
                    Expected: GT_OK
                */
                direction = CPSS_PCL_DIRECTION_INGRESS_E;
                lookupNum = CPSS_PCL_LOOKUP_0_E;
                subLookupNum = 0;
                mode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E;

                if(directionIterator == direction)
                {
                    st = cpssDxChPclPortLookupCfgTabAccessModeSet(
                        dev, port, direction, lookupNum,
                        subLookupNum, mode);
                    UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, port, direction, lookupNum, mode);
                }

                /*
                    1.1.10. For Bobcat2; Caelum; Bobcat3 call with direction[CPSS_PCL_DIRECTION_EGRESS_E],
                        mode[CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E](is applicable)
                        and other params as in 1.1.1.
                    Expected: GT_OK.
                */
                if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
                {
                    direction = CPSS_PCL_DIRECTION_EGRESS_E;
                    mode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E;

                    if(directionIterator == direction)
                    {
                        st = cpssDxChPclPortLookupCfgTabAccessModeSet(dev, port, direction, lookupNum,
                                                                      subLookupNum, mode);
                        UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, port, direction, lookupNum, mode);
                    }

                    /* restore previous value*/
                    direction = CPSS_PCL_DIRECTION_INGRESS_E;
                    mode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E;

                /*
                    1.1.11. For Bobcat2; Caelum; Bobcat3 call with direction[CPSS_PCL_DIRECTION_INGRESS_E],
                        mode[CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E](not applicable)
                        and other params as in 1.1.1.
                    Expected: GT_OK.
                */

                    direction = CPSS_PCL_DIRECTION_INGRESS_E;
                    mode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E;

                    if(directionIterator == direction)
                    {
                        st = cpssDxChPclPortLookupCfgTabAccessModeSet(dev, port, direction, lookupNum,
                                                                      subLookupNum, mode);
                        UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, port, direction, lookupNum, mode);
                    }

                    /* restore previous value*/
                    direction = CPSS_PCL_DIRECTION_INGRESS_E;
                    mode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E;
                }
            }/*prvUtfNextGenericPortGet(...)*/
        }/*for(directionIterator...)*/

        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum = CPSS_PCL_LOOKUP_0_E;
        mode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E;

        /* 1.2. Check that function handles CPU port    */
        port = PRV_CPSS_DXCH_CPU_PORT_NUM_CNS;

        /* 1.2.1. <Check other parameters for each active device id and CPU port>. */
        st = cpssDxChPclPortLookupCfgTabAccessModeSet(
            dev, port, direction, lookupNum,
            subLookupNum, mode);
        UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, port, direction, lookupNum, mode);


        for(directionIterator = CPSS_PCL_DIRECTION_INGRESS_E ; directionIterator <= CPSS_PCL_DIRECTION_EGRESS_E; directionIterator++)
        {
            prvUtfNextGenericPortItaratorTypeSet(   directionIterator == CPSS_PCL_DIRECTION_INGRESS_E ?
                                                    UTF_GENERIC_PORT_ITERATOR_TYPE_DEFAULT_EPORT_E :
                                                    UTF_GENERIC_PORT_ITERATOR_TYPE_PHYSICAL_E);

            direction = directionIterator;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            subLookupNum = 0;

            /* prepare physical port iterator */
            st = prvUtfNextGenericPortReset(&port, dev);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /* 1.3. Go over non configured ports */
            while (GT_OK == prvUtfNextGenericPortGet(&port, GT_FALSE))
            {
                /* 1.3.1. Call function for each non configured port.   */
                /* Expected: GT_BAD_PARAM                               */
                st = cpssDxChPclPortLookupCfgTabAccessModeSet(
                    dev, port, direction, lookupNum,
                    subLookupNum, mode);
                if(IS_E_ARCH_AND_PHYSICAL_PORT_IN_RANGE_MAC(dev,port))
                {
                    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);
                }
                else
                {
                    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
                }
            }
        }

        direction = CPSS_PCL_DIRECTION_INGRESS_E;

        /* 1.4. For active device check that function returns GT_BAD_PARAM  */
        /* for out of bound value for port number.                          */
        port = UTF_CPSS_PP_MAX_PORT_NUM_CNS(dev);

        st = cpssDxChPclPortLookupCfgTabAccessModeSet(
            dev, port, direction, lookupNum,
            subLookupNum, mode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
    }

    port = DXCH_PCL_VALID_PHY_PORT_CNS;
    lookupNum = CPSS_PCL_LOOKUP_0_E;
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    mode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E;

    /* 2. Go over not active devices    */
    /* Expected: GT_BAD_PARAM           */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortLookupCfgTabAccessModeSet(
            dev, port, direction, lookupNum,
            subLookupNum, mode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call function with out of bound value for device id    */
    /* Expected: GT_BAD_PARAM                                   */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortLookupCfgTabAccessModeSet(
        dev, port, direction, lookupNum,
        subLookupNum, mode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclCfgTblAccessModeSet
(
    IN GT_U8                                    devNum,
    IN CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   *accModePtr
)
*/

UTF_TEST_CASE_MAC(cpssDxChPclCfgTblAccessModeSet)
{
/*
    ITERATE_DEVICES
    1.1. Check with valid params. Call with accModePtr
            [ipclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E,
            ipclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E,
            ipclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E,
            epclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E,
            epclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E,
            epclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E ].
    Expected: GT_OK
    1.2. Call cpssDxChPclCfgTblAccessModeGet with non-NULL accModePtr.
    Expected: GT_OK and same values as were written.
    (for DxCh2 and above - all fields; for DxCh - only ipclAccMode)
    1.3. Check with valid params. Call with accModePtr
            [ipclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_NON_LOCAL_PORT_E,
            ipclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E,
            ipclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E,
            epclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_NON_LOCAL_PORT_E,
            epclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E,
            epclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E ].
    Expected: GT_OK
    1.2. Call cpssDxChPclCfgTblAccessModeGet with non-NULL accModePtr.
    Expected: GT_OK and same values as were written.
    (for DxCh2 and above - all fields; for DxCh - only ipclAccMode)
    1.4. Call with accModePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS       st = GT_OK;

    GT_U8                                   dev;
    CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   accMode;

    CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   retAccMode;
    GT_BOOL                                 failureWas;
    CPSS_PP_FAMILY_TYPE_ENT                 devFamily;

    cpssOsBzero((GT_VOID*)&accMode, sizeof(accMode));

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* get device family */
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

        /*
            1.1. Check with valid params. Call with accModePtr
                    [ipclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E,
                    ipclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E,
                    ipclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E,
                    epclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E,
                    epclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E,
                    epclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E ].
            Expected: GT_OK
        */
        accMode.ipclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E;
        accMode.ipclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
        accMode.ipclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
        accMode.epclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E;
        accMode.epclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
        accMode.epclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;

        st = cpssDxChPclCfgTblAccessModeSet(dev, &accMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPclCfgTblAccessModeGet with non-NULL accModePtr.
            Expected: GT_OK and same values as were written.
            (for DxCh2 and above - all fields; for DxCh - only ipclAccMode)
        */
        st = cpssDxChPclCfgTblAccessModeGet(dev, &retAccMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        if (GT_OK == st)
        {
            /* Verifying values */
            failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&accMode,
                                            (const GT_VOID*)&retAccMode,
                                            sizeof(accMode))) ? GT_FALSE : GT_TRUE;
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_FALSE, failureWas,
            "cpssDxChPclCfgTblAccessModeGet: get another accMode than was set: %d", dev);
        }

        /*
            1.3. Check with valid params. Call with accModePtr
                    [ipclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_NON_LOCAL_PORT_E,
                    ipclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E,
                    ipclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E,
                    epclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_NON_LOCAL_PORT_E,
                    epclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E,
                    epclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E ].
            Expected: GT_OK
        */
        accMode.ipclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_NON_LOCAL_PORT_E;
        accMode.ipclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E;
        accMode.ipclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E;
        accMode.epclAccMode = CPSS_DXCH_PCL_CFG_TBL_ACCESS_NON_LOCAL_PORT_E;
        accMode.epclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_64_E;
        accMode.epclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE2048_E;

        st = cpssDxChPclCfgTblAccessModeSet(dev, &accMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPclCfgTblAccessModeGet with non-NULL accModePtr.
            Expected: GT_OK and same values as were written.
            (for DxCh2 and above - all fields; for DxCh - only ipclAccMode)
        */
        st = cpssDxChPclCfgTblAccessModeGet(dev, &retAccMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        if (GT_OK == st)
        {
            /* Verifying values */
            failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&accMode,
                                            (const GT_VOID*)&retAccMode,
                                            sizeof(accMode))) ? GT_FALSE : GT_TRUE;
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_FALSE, failureWas,
            "cpssDxChPclCfgTblAccessModeGet: get another accMode than was set: %d", dev);
        }

        /*
            1.4. Call with accModePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclCfgTblAccessModeSet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, NULL", dev);
    }

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_CNS);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclCfgTblAccessModeSet(dev, &accMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclCfgTblAccessModeSet(dev, &accMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclCfgTblAccessModeGet
(
    IN  GT_U8                                   devNum,
    OUT CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   *accModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclCfgTblAccessModeGet)
{
/*
    ITERATE_DEVICES
    1.1. For all devices call with non-NULL accModePtr.
    Expected: GT_OK
    1.2. Check for NULL pointer support. Call with accModePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS       st = GT_OK;

    GT_U8                                   dev;
    CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   retAccMode;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. For all devices call with non-NULL accModePtr.
            Expected: GT_OK
        */
        st = cpssDxChPclCfgTblAccessModeGet(dev, &retAccMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Check for NULL pointer support. Call with accModePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclCfgTblAccessModeGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, NULL", dev);
    }

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_CNS);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclCfgTblAccessModeGet(dev, &retAccMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclCfgTblAccessModeGet(dev, &retAccMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclCfgTblSet
(
    IN GT_U8                           devNum,
    IN CPSS_INTERFACE_INFO_STC        *interfaceInfoPtr,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclCfgTblSet)
{
/*
    ITERATE_DEVICES
       1.1. Check Ingress direction. Call with
       interfaceInfoPtr [type = CPSS_INTERFACE_PORT_E,
                     devPort {devNum=0, portNum=0} ],
       direction [CPSS_PCL_DIRECTION_INGRESS_E],
       lookupNum [CPSS_PCL_LOOKUP_0_E],
       lookupCfgPtr [enableLookup = GT_TRUE,
                 pclId = 1023,
                 groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
                 groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
                 other fields zeroed } ].
    Expected: GT_OK
    1.2. Call cpssDxChPclCfgTblGet with interfaceInfoPtr,
    direction, lookupNum - same as in 1.1, non-NULL lookupCfgPtr.
    Expected: GT_OK and same lookupCfgPtr as was written.
    1.3. Check Egress direction (not supported by Ch1). Call with
    direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.1.
    Expected: GT_OK for all devices and non GT_OK for Ch1.
    1.4. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
    other params same as in 1.1.
    Expected: GT_OK.

       -- II - INTERFACE_TYPE - VLan (interfaceInfoPtr->type= CPSS_INTERFACE_VID_E) --

    1.5. Check Ingress direction. Call with interfaceInfoPtr [type = CPSS_INTERFACE_VID_E,
    vlanId = [100 / (PRV_CPSS_MAX_NUM_VLANS_CNS - 1) = 4095] ],
    direction [CPSS_PCL_DIRECTION_INGRESS_E],
    lookupNum [CPSS_PCL_LOOKUP_0_E],
    lookupCfgPtr [enableLookup = GT_TRUE,
                  pclId = 1023,
                  groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
                  other fields zeroed } ].
    Expected: GT_OK for all devices except ch1.
    1.6. Call cpssDxChPclCfgTblGet with interfaceInfoPtr,
    direction, lookupNum - same as in 1.5, non-NULL lookupCfgPtr.
    Expected: GT_OK and same lookupCfgPtr as was written.
    1.7. Check Egress direction (not supported by Ch1).
    Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.5.
    Expected: GT_OK for all devices except Ch1.
    1.8. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
    other params same as in 1.5.
    Expected: GT_OK.
    1.9. Check out-of-range direction enum. Call with direction [wrong enum values],
        other params same as in 1.5.
    Expected: GT_BAD_PARAM.
    1.10. Check out-of-range lookupNum enum. Call with lookupNum [wrong enum values],
    other params same as in 1.5.
    Expected: GT_BAD_PARAM.
    1.11. Call with lookupCfgPtr [NULL], other params same as in 1.5.
    Expected: GT_BAD_PTR.
    1.12. Call with interfaceInfoPtr [NULL], other params same as in 1.5.
    Expected: GT_BAD_PTR.
    1.13. Check out-of-range vlan id. call with interfaceInfoPtr
    [type = CPSS_INTERFACE_VID_E, vlanId [PRV_CPSS_MAX_NUM_VLANS_CNS = 4096] ],
    other params same as in 1.5.
    Expected: non GT_OK.

       -- III - INTERFACE_TYPE - TRUNK (interfaceInfoPtr->type= CPSS_INTERFACE_TRUNK_E) --
                                     Supported only in Non-Local mode

    1.14. Check trunk interface with valid params. Call with
            interfaceInfoPtr [type = CPSS_INTERFACE_TRUNK_E,
                              trunkId = 0 ],
            direction [CPSS_PCL_DIRECTION_INGRESS_E],
            lookupNum [CPSS_PCL_LOOKUP_0_E],
            lookupCfgPtr [enableLookup = GT_TRUE,
                          pclId = 1023,
                          groupKeyTypes
                            {nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
                             ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
                             ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E } ].
    Expected: NOT GT_OK.
    1.15. Check out-of-range trunk id. Call with interfaceInfoPtr
               [type = CPSS_INTERFACE_TRUNK_E,
                trunkId [UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev) = 128] ], other params same as in 1.14.
    Expected: non GT_OK.

       -- IV - INTERFACE_TYPE - Vidx (unsupported) (interfaceInfoPtr->type= CPSS_INTERFACE_VIDX_E) --

    1.16. Check Vidx interface (unsupported) with valid params.
            Call with interfaceInfoPtr [type = CPSS_INTERFACE_VIDX_E, vidx = 0 ],
            other params same as in 1.1.
    Expected: NOT GT_OK.
       -- V - INTERFACE_TYPE - out-of-range --

    1.17. Check out-of-range interface type enum.
    Expected: GT_BAD_PARAM.
    1.18. Check Ingress direction. Call function with
            direction [CPSS_PCL_DIRECTION_INGRESS_E]
            lookupCfgPtr {
                udbKeyBitmapEnable[GT_FALSE / GT_TRUE],
                tcamSegmentMode[
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_1_TCAM_E,
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_2_AND_2_E,
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_1_AND_3_E,
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_3_AND_1_E,
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_4_TCAMS_E]},
                and other params same as in 1.1.
    Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
    1.19. Call cpssDxChPclCfgTblGet with interfaceInfoPtr,
    direction, lookupNum - same as in 1.18, non-NULL lookupCfgPtr.
    Expected: GT_OK and same lookupCfgPtr as was written for Bobcat2; Caelum; Bobcat3.
    1.20. Check Egress direction. Call function with
            direction [CPSS_PCL_DIRECTION_EGRESS_E]
            lookupCfgPtr {
                udbKeyBitmapEnable[GT_FALSE / GT_TRUE],
                tcamSegmentMode[
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_1_TCAM_E,
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_2_AND_2_E,
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_1_AND_3_E,
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_3_AND_1_E,
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_4_TCAMS_E]},
                and other params same as in 1.1.
    Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
    1.21. Call cpssDxChPclCfgTblGet with interfaceInfoPtr,
    direction, lookupNum - same as in 1.20, non-NULL lookupCfgPtr.
    Expected: GT_OK and same lookupCfgPtr as was written for Bobcat2; Caelum; Bobcat3.
    1.22. Call function with out of range groupKeyTypes.nonIpKey
           and other parameters from 1.20.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.23. Call function with out of range groupKeyTypes.ipv4Key
           and other parameters from 1.20.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.24. Call function with out of range groupKeyTypes.ipv6Key
           and other parameters from 1.20.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.25. Call function with out of range tcamSegmentMode
           and other parameters from 1.20.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
*/

    GT_STATUS                       st = GT_OK;
    GT_U8                           dev;

    CPSS_INTERFACE_INFO_STC         interfaceInfo;
    CPSS_PCL_DIRECTION_ENT          direction;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum;
    CPSS_DXCH_PCL_LOOKUP_CFG_STC    lookupCfg;
    CPSS_DXCH_PCL_LOOKUP_CFG_STC    lookupCfgEgr;
    CPSS_DXCH_PCL_LOOKUP_CFG_STC    lookupCfgRet;

    CPSS_PP_FAMILY_TYPE_ENT         devFamily;
    GT_BOOL                         failureWas;
    /* access mode */
    CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   accMode;
    GT_BOOL                         iPcl0Bypass;

    GT_U32  ii,jj,kk;
    GT_U32  step;
    GT_U64  allBmp_ingress,allBmp_egress;/*bmp of keys for ingress and egress - general not 'device specific'*/
    GT_U64  specificRestrictedKeysBmp;/*bmp of RESTRICTED keys for ingress and egress - device specific */
    GT_U64  nonIpSupportedBmp_ingress,nonIpSupportedBmp_egress;/*bmp of keys for ingress,egress of 'non IP' keys - device specific */
    GT_U64  ipV4SupportedBmp_ingress,ipV4SupportedBmp_egress;  /*bmp of keys for ingress,egress of 'IPv4' keys - device specific */
    GT_U64  ipV6SupportedBmp_ingress,ipV6SupportedBmp_egress;  /*bmp of keys for ingress,egress of 'IPv6' keys - device specific */
    GT_U32  expectedError;/* indication if error is expected for a key in the setting*/
    GT_U32  pclIdL01;/*pclid 01 - relevant to ingress only */
    GT_U32  dualLookup;/*is dual lookup - relevant to ingress only */
    GT_U32  maxRuleFormat = CPSS_DXCH_PCL_RULE_FORMAT_LAST_E; /* maximum enum
                                                                        value */

    cpssOsBzero((GT_VOID*) &interfaceInfo, sizeof(interfaceInfo));
    cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));
    cpssOsBzero((GT_VOID*) &lookupCfgRet, sizeof(lookupCfgRet));

    allBmp_ingress.l[0] = 0;
    allBmp_ingress.l[1] = 0;
    add_bmp_value( allBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E );
    add_bmp_value( allBmp_ingress.l,
                            CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E );
    add_bmp_value( allBmp_ingress.l,
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E );
    add_bmp_value( allBmp_ingress.l,
                             CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E );
    add_bmp_value( allBmp_ingress.l,
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E);
    add_bmp_value( allBmp_ingress.l,
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E );
    add_bmp_value( allBmp_ingress.l,
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E );
    add_bmp_value( allBmp_ingress.l,
                                  CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E );
    add_bmp_value( allBmp_ingress.l,
                                  CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E );
    add_bmp_value( allBmp_ingress.l,
                  CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E );
    add_bmp_value( allBmp_ingress.l,
                   CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E );
    add_bmp_value( allBmp_ingress.l,
                 CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E );
    add_bmp_value( allBmp_ingress.l,
                CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E );
    add_bmp_value( allBmp_ingress.l,
                                   CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E );
    add_bmp_value( allBmp_ingress.l,
                                   CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E );
    add_bmp_value( allBmp_ingress.l,
                                   CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E );
    add_bmp_value( allBmp_ingress.l,
                                   CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E );
    add_bmp_value( allBmp_ingress.l,
                                   CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E );
    add_bmp_value( allBmp_ingress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E );
    add_bmp_value( allBmp_ingress.l,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E );
    add_bmp_value( allBmp_ingress.l, CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E );

    allBmp_egress.l[0] = 0;
    allBmp_egress.l[1] = 0;
    add_bmp_value( allBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E );
    add_bmp_value( allBmp_egress.l,
                             CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E );
    add_bmp_value( allBmp_egress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E );
    add_bmp_value( allBmp_egress.l,
                              CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E );
    add_bmp_value( allBmp_egress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E );
    add_bmp_value( allBmp_egress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E );
    add_bmp_value( allBmp_egress.l,
                        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E );
    add_bmp_value( allBmp_egress.l,
                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E );
    add_bmp_value( allBmp_egress.l, CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E );
    add_bmp_value( allBmp_egress.l, CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E );
    add_bmp_value( allBmp_egress.l, CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E );
    add_bmp_value( allBmp_egress.l, CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E );
    add_bmp_value( allBmp_egress.l, CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E );
    add_bmp_value( allBmp_egress.l, CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E );
    add_bmp_value( allBmp_egress.l, CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E );

    if(maxRuleFormat != (bitcount(allBmp_ingress.l[0]) +
                         bitcount(allBmp_ingress.l[1]) +
                         bitcount(allBmp_egress.l[0]) +
                         bitcount(allBmp_egress.l[1])))
    {
        /* not all key are covered */
        st = (GT_STATUS)GT_ERROR;
        UTF_VERIFY_EQUAL0_STRING_MAC(
            GT_OK, st, "cpssDxChPclCfgTblAccessModeSetUT: not all key are covered");
    }
    else if(BMP_COMPARE( allBmp_ingress.l, allBmp_egress.l ))
    {
        /* some keys are ingress and egress ?? */
        st = (GT_STATUS)GT_ERROR;
        UTF_VERIFY_EQUAL0_STRING_MAC(
            GT_OK, st, "cpssDxChPclCfgTblAccessModeSetUT: some keys are ingress and egress ??");
    }

    accMode.ipclAccMode     = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E;
    accMode.epclAccMode     = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E;
    accMode.ipclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
    accMode.epclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
    accMode.ipclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
    accMode.epclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        if (! PRV_CPSS_SIP_6_CHECK_MAC(dev))
        {
            /* for SIP6 devices hard-wired local-port-access */
            st = cpssDxChPclCfgTblAccessModeSet(
                dev, &accMode);
            UTF_VERIFY_EQUAL1_STRING_MAC(
                GT_OK, st, "cpssDxChPclCfgTblAccessModeSet: %d", dev);
        }

        /* get device family */
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d",
                                     dev);

        /* I - INTERFACE_TYPE - Port (interfaceInfoPtr->type= CPSS_INTERFACE_PORT_E) */

        /*
           1.1. Check Ingress direction. Call with
           interfaceInfoPtr [type = CPSS_INTERFACE_PORT_E,
                             devPort {devNum=0, portNum=0} ],
           direction [CPSS_PCL_DIRECTION_INGRESS_E],
           lookupNum [CPSS_PCL_LOOKUP_0_E],
           lookupCfgPtr [enableLookup = GT_TRUE,
                         pclId = 1023,
                         groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
                         groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
                         other fields zeroed } ].
            Expected: GT_OK
        */
        interfaceInfo.type = CPSS_INTERFACE_PORT_E; /* should be synhronized with 1.2*/
        interfaceInfo.devPort.hwDevNum = dev;
        interfaceInfo.devPort.portNum = 0;
        direction=CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum=CPSS_PCL_LOOKUP_0_E;

        cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));
        lookupCfg.enableLookup = GT_TRUE;
        lookupCfg.pclId                = 1023;
        lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
        lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

        cpssOsBzero((GT_VOID*) &lookupCfgEgr, sizeof(lookupCfgEgr));
        lookupCfgEgr.enableLookup = GT_TRUE;
        lookupCfgEgr.pclId = 1023;
        lookupCfgEgr.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
        lookupCfgEgr.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E;
        lookupCfgEgr.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E;

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {
            lookupCfg.dualLookup = GT_TRUE;
            lookupCfg.pclIdL01 = PRV_CPSS_SIP_6_10_CHECK_MAC(dev) ? 0xFFF : 1023;
        }

        /*according to the device type set the valid options that need to be supported*/

        /*prvCpssDxChSwKeyType_EPCL_NOT_IP*/
        nonIpSupportedBmp_egress.l[0] = 0;
        nonIpSupportedBmp_egress.l[1] = 0;
        add_bmp_value( nonIpSupportedBmp_egress.l,
                            CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E );
        add_bmp_value( nonIpSupportedBmp_egress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E );
        add_bmp_value( nonIpSupportedBmp_egress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E );

        /*prvCpssDxChSwKeyType_EPCL_IPV4*/
        ipV4SupportedBmp_egress.l[0] = 0;
        ipV4SupportedBmp_egress.l[1] = 0;
        add_bmp_value( ipV4SupportedBmp_egress.l,
                         CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E );
        add_bmp_value( ipV4SupportedBmp_egress.l,
                           CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E );
        add_bmp_value( ipV4SupportedBmp_egress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E );
        add_bmp_value( ipV4SupportedBmp_egress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E );

        ipV6SupportedBmp_egress.l[0] = 0;
        ipV6SupportedBmp_egress.l[1] = 0;
        add_bmp_value( ipV6SupportedBmp_egress.l,
                         CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E );
        add_bmp_value( ipV6SupportedBmp_egress.l,
                  CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E );
        add_bmp_value( ipV6SupportedBmp_egress.l,
                           CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E );
        add_bmp_value( ipV6SupportedBmp_egress.l,
                           CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E );

        /*prvCpssDxChXCatSwKeyType_IPCL_NOT_IP*/
        nonIpSupportedBmp_ingress.l[0] = 0;
        nonIpSupportedBmp_ingress.l[1] = 0;
        add_bmp_value( nonIpSupportedBmp_ingress.l,
                       CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E );
        add_bmp_value( nonIpSupportedBmp_ingress.l,
                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E );
        add_bmp_value( nonIpSupportedBmp_ingress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E );
        add_bmp_value( nonIpSupportedBmp_ingress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E );
        add_bmp_value( nonIpSupportedBmp_ingress.l,
           CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E );
        add_bmp_value( nonIpSupportedBmp_ingress.l,
         CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E );

        /*prvCpssDxChXCatSwKeyType_IPCL_IPV4*/
        ipV4SupportedBmp_ingress.l[0] = 0;
        ipV4SupportedBmp_ingress.l[1] = 0;
        add_bmp_value( ipV4SupportedBmp_ingress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E );
        add_bmp_value( ipV4SupportedBmp_ingress.l,
                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E );
        add_bmp_value( ipV4SupportedBmp_ingress.l,
                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E );
        add_bmp_value( ipV4SupportedBmp_ingress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E );
        add_bmp_value( ipV4SupportedBmp_ingress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E );
        add_bmp_value( ipV4SupportedBmp_ingress.l,
           CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E );
        add_bmp_value( ipV4SupportedBmp_ingress.l,
          CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E );

        /*prvCpssDxChXCatSwKeyType_IPCL_IPV6*/
        ipV6SupportedBmp_ingress.l[0] = 0;
        ipV6SupportedBmp_ingress.l[1] = 0;
        add_bmp_value( ipV6SupportedBmp_ingress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E );
        add_bmp_value( ipV6SupportedBmp_ingress.l,
                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E );
        add_bmp_value( ipV6SupportedBmp_ingress.l,
                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E );
        add_bmp_value( ipV6SupportedBmp_ingress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E );
        add_bmp_value( ipV6SupportedBmp_ingress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E );
        add_bmp_value( ipV6SupportedBmp_ingress.l,
         CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E );
        add_bmp_value( ipV6SupportedBmp_ingress.l,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E );
        add_bmp_value( ipV6SupportedBmp_ingress.l,
                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E );

       if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
       {
            /*prvCpssDxChSip5SwKeyType_IPCL_NOT_IP*/
            nonIpSupportedBmp_ingress.l[0] = 0;
            nonIpSupportedBmp_ingress.l[1] = 0;
            add_bmp_value( nonIpSupportedBmp_ingress.l,
                           CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E );
            add_bmp_value( nonIpSupportedBmp_ingress.l,
                         CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E );
            add_bmp_value( nonIpSupportedBmp_ingress.l,
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E );
            add_bmp_value( nonIpSupportedBmp_ingress.l,
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E );
            add_bmp_value( nonIpSupportedBmp_ingress.l,
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E );
            add_bmp_value( nonIpSupportedBmp_ingress.l,
             CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E );
            add_bmp_value( nonIpSupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E );
            add_bmp_value( nonIpSupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E );
            add_bmp_value( nonIpSupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E );
            add_bmp_value( nonIpSupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E );
            add_bmp_value( nonIpSupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E );
            add_bmp_value( nonIpSupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E );
            if(PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
            {
                add_bmp_value( nonIpSupportedBmp_ingress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E );
            }
            if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                add_bmp_value( nonIpSupportedBmp_ingress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E );
            }

            /*prvCpssDxChSip5SwKeyType_IPCL_IPV4*/
            ipV4SupportedBmp_ingress.l[0] = 0;
            ipV4SupportedBmp_ingress.l[1] = 0;
            add_bmp_value( ipV4SupportedBmp_ingress.l,
                        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
                         CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E );
            add_bmp_value( ipV4SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E );
            if(PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
            {
                add_bmp_value( ipV4SupportedBmp_ingress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E );
            }
            if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                add_bmp_value( ipV4SupportedBmp_ingress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E );
            }

            /*prvCpssDxChSip5SwKeyType_IPCL_IPV6*/
            ipV6SupportedBmp_ingress.l[0] = 0;
            ipV6SupportedBmp_ingress.l[1] = 0;
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
             CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
            CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                         CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E );
            add_bmp_value( ipV6SupportedBmp_ingress.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E );
            if(PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
            {
                add_bmp_value( ipV6SupportedBmp_ingress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E );
            }
            if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                add_bmp_value( ipV6SupportedBmp_ingress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E );
            }

            /*prvCpssDxChSip5SwKeyType_EPCL_NOT_IP*/
            nonIpSupportedBmp_egress.l[0] = 0;
            nonIpSupportedBmp_egress.l[1] = 0;
            add_bmp_value( nonIpSupportedBmp_egress.l,
                            CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E );
            add_bmp_value( nonIpSupportedBmp_egress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E );
            add_bmp_value( nonIpSupportedBmp_egress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E );
            add_bmp_value( nonIpSupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E );
            add_bmp_value( nonIpSupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E );
            add_bmp_value( nonIpSupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E );
            add_bmp_value( nonIpSupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E );
            add_bmp_value( nonIpSupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E );
            add_bmp_value( nonIpSupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E );
            if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                add_bmp_value( nonIpSupportedBmp_egress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E );
            }
            /*prvCpssDxChSip5SwKeyType_EPCL_IPV4*/
            ipV4SupportedBmp_egress.l[0] = 0;
            ipV4SupportedBmp_egress.l[1] = 0;
            add_bmp_value( ipV4SupportedBmp_egress.l,
                         CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E );
            add_bmp_value( ipV4SupportedBmp_egress.l,
                           CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E );
            add_bmp_value( ipV4SupportedBmp_egress.l,
                          CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E );
            add_bmp_value( ipV4SupportedBmp_egress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E );
            add_bmp_value( ipV4SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E );
            add_bmp_value( ipV4SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E );
            add_bmp_value( ipV4SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E );
            add_bmp_value( ipV4SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E );
            add_bmp_value( ipV4SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E );
            add_bmp_value( ipV4SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E );
            if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                add_bmp_value( ipV4SupportedBmp_egress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E );
            }
            /*prvCpssDxChSip5SwKeyType_EPCL_IPV6*/
            ipV6SupportedBmp_egress.l[0] = 0;
            ipV6SupportedBmp_egress.l[1] = 0;
            add_bmp_value( ipV6SupportedBmp_egress.l,
                         CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E );
            add_bmp_value( ipV6SupportedBmp_egress.l,
                  CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E );
            add_bmp_value( ipV6SupportedBmp_egress.l,
                           CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E );
            add_bmp_value( ipV6SupportedBmp_egress.l,
                           CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E );
            add_bmp_value( ipV6SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E );
            add_bmp_value( ipV6SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E );
            add_bmp_value( ipV6SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E );
            add_bmp_value( ipV6SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E );
            add_bmp_value( ipV6SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E );
            add_bmp_value( ipV6SupportedBmp_egress.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E );
            if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                add_bmp_value( ipV6SupportedBmp_egress.l,
                    CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E );
            }
       }

        /* make sure that not mix of ingress and egress keys */
        BMP_SUMM_AND( nonIpSupportedBmp_ingress.l, allBmp_ingress.l )
        BMP_SUMM_AND( ipV4SupportedBmp_ingress.l,  allBmp_ingress.l )
        BMP_SUMM_AND( ipV6SupportedBmp_ingress.l,  allBmp_ingress.l )

        BMP_SUMM_AND( nonIpSupportedBmp_egress.l, allBmp_egress.l )
        BMP_SUMM_AND( ipV4SupportedBmp_egress.l,  allBmp_egress.l )
        BMP_SUMM_AND( ipV6SupportedBmp_egress.l,  allBmp_egress.l )

        pclIdL01 = lookupCfg.pclIdL01;
        dualLookup = lookupCfg.dualLookup;

        specificRestrictedKeysBmp.l[0] = 0;
        specificRestrictedKeysBmp.l[1] = 0;
        if(!UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            add_bmp_value( specificRestrictedKeysBmp.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E );
            add_bmp_value( specificRestrictedKeysBmp.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E );
            add_bmp_value( specificRestrictedKeysBmp.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E );
            add_bmp_value( specificRestrictedKeysBmp.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E );
            add_bmp_value( specificRestrictedKeysBmp.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E );
            add_bmp_value( specificRestrictedKeysBmp.l,
                               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E );
            add_bmp_value( specificRestrictedKeysBmp.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E );
            add_bmp_value( specificRestrictedKeysBmp.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E );
            add_bmp_value( specificRestrictedKeysBmp.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E );
            add_bmp_value( specificRestrictedKeysBmp.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E );
            add_bmp_value( specificRestrictedKeysBmp.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E );
            add_bmp_value( specificRestrictedKeysBmp.l,
                                CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E );
        }
        else if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
        {
            add_bmp_value( specificRestrictedKeysBmp.l,
                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E );
        }

        /* remove the restricted keys from the 'good' options */
        BMP_SUMM_NAND( nonIpSupportedBmp_ingress.l,
                       specificRestrictedKeysBmp.l);
        BMP_SUMM_NAND( ipV4SupportedBmp_ingress.l,
                       specificRestrictedKeysBmp.l);
        BMP_SUMM_NAND( ipV6SupportedBmp_ingress.l,
                       specificRestrictedKeysBmp.l);

        BMP_SUMM_NAND( nonIpSupportedBmp_egress.l,
                       specificRestrictedKeysBmp.l);
        BMP_SUMM_NAND( ipV4SupportedBmp_egress.l,
                       specificRestrictedKeysBmp.l);
        BMP_SUMM_NAND( ipV6SupportedBmp_egress.l,
                       specificRestrictedKeysBmp.l);

        /* reduce iterations number to reduce log size */
        step = (GT_TRUE == prvUtfReduceLogSizeFlagGet()) ? 8 : 1;

        for(ii = 0 ; ii < maxRuleFormat; ii += step)
        {
            if(BMP_FIND( ii, allBmp_ingress.l ))
            {
                direction = CPSS_PCL_DIRECTION_INGRESS_E;
            }
            else
            {
                direction = CPSS_PCL_DIRECTION_EGRESS_E;
            }

            for(jj = 0 ; jj < maxRuleFormat; jj += step)
            {

                for(kk = 0 ; kk < maxRuleFormat; kk += step)
                {
                    expectedError = 0;

                    if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
                    {
                        if( (0 == (BMP_FIND( ii, nonIpSupportedBmp_ingress.l ))) ||
                            (0 == (BMP_FIND( jj, ipV4SupportedBmp_ingress.l )))  ||
                            (0 == (BMP_FIND( kk, ipV6SupportedBmp_ingress.l )))
                            )
                        {
                            expectedError = 1;
                        }
                    }
                    else /*egress*/
                    {
                        if( (0 == (BMP_FIND( ii, nonIpSupportedBmp_egress.l ))) ||
                            (0 == (BMP_FIND( jj, ipV4SupportedBmp_egress.l )))  ||
                            (0 == (BMP_FIND( kk, ipV6SupportedBmp_egress.l )))
                            )
                        {
                            expectedError = 1;
                        }
                    }


                    lookupCfg.groupKeyTypes.nonIpKey = ii;
                    lookupCfg.groupKeyTypes.ipv4Key = jj;
                    lookupCfg.groupKeyTypes.ipv6Key = kk;

                    lookupCfg.pclIdL01 = pclIdL01;
                    lookupCfg.dualLookup = dualLookup;

                    /* sip6_10 devices have 12 bits pcl id for ingress
                    * and 10 bits for egress */
                    if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
                    {
                        lookupCfg.pclId = (direction == CPSS_PCL_DIRECTION_EGRESS_E) ? 1023 : 0xFFF;
                    }
                    st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
                    if(expectedError == 0)
                    {
                        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                            "dev: %d, interfaceInfo [devNum= %d, portNum= %d], direction=%d, lookupNum=%d",
                            dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                                        direction, lookupNum);

                        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfgRet);

                        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                            "cpssDxChPclCfgTblGet: "
                            "dev: %d, intInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
                            dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                                        direction, lookupNum);

                        if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
                        {
                            /* do not compare values ... no meaning in that */
                            lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
                        }

                        if(direction == CPSS_PCL_DIRECTION_EGRESS_E)
                        {
                            /*the EPCL did not set the value that is not relevant to the IPCL only */
                            lookupCfg.pclIdL01 = 0;
                            lookupCfg.dualLookup = 0;
                        }

                        if (GT_OK == st)
                        {
                            failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&lookupCfg,
                                                            (const GT_VOID*)&lookupCfgRet,
                                                            sizeof(lookupCfg))) ? GT_FALSE : GT_TRUE;
                            UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                                "get another lookupCfg than was written "
                                "[dev = %d, direction=%d, lookupNum=%d]",
                                dev, direction, lookupNum);
                        }
                    }
                    else
                    {
                        if (st == GT_OK)
                        {
                            PRV_UTF_LOG0_MAC("cpssDxChPclCfgTblSet: should have failed\n");
                            PRV_UTF_LOG2_MAC("direction=%d, lookupNum=%d\n", direction, lookupNum);
                            PRV_UTF_LOG3_MAC(
                                "non_ip_key=%d, ipv4_key=%d, ipv6_key=%d\n",
                                lookupCfg.groupKeyTypes.nonIpKey,
                                lookupCfg.groupKeyTypes.ipv4Key,
                                lookupCfg.groupKeyTypes.ipv6Key);
                        }
                        UTF_VERIFY_NOT_EQUAL0_STRING_MAC(
                            GT_OK, st,"cpssDxChPclCfgTblSet: should have failed");
                    }
                }
            }
        }

        /* restore the values */
        lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
        lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        lookupCfg.pclIdL01 = pclIdL01;
        lookupCfg.dualLookup = dualLookup;
        /* sip6_10 devices have 12 bits pcl id for ingress
        * and 10 bits for egress as like legacy */
        if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
        {
            lookupCfg.pclId = 0xFFF;
        }

        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "dev: %d, interfaceInfo [devNum= %d, portNum= %d], direction=%d, lookupNum=%d",
            dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                        direction, lookupNum);

        /*
            1.2. Call cpssDxChPclCfgTblGet with interfaceInfoPtr,
            direction, lookupNum - same as in 1.1, non-NULL lookupCfgPtr.
            Expected: GT_OK and same lookupCfgPtr as was written.
        */
        cpssOsMemSet((GT_VOID*)&lookupCfgRet, 0, sizeof(CPSS_DXCH_PCL_LOOKUP_CFG_STC));

        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfgRet);

        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "cpssDxChPclCfgTblGet: "
            "dev: %d, intInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
            dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                        direction, lookupNum);

        if (GT_OK == st)
        {
            failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&lookupCfg,
                                            (const GT_VOID*)&lookupCfgRet,
                                            sizeof(lookupCfg))) ? GT_FALSE : GT_TRUE;
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                "get another lookupCfg than was written "
                "[dev = %d, direction=%d, lookupNum=%d]",
                dev, direction, lookupNum);
        }

        /*
            1.3. Check Egress direction (not supported by Ch1). Call with
            direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.1.
            Expected: GT_OK for all devices and non GT_OK for Ch1.
        */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;

        st = cpssDxChPclCfgTblSet(
            dev, &interfaceInfo, direction, lookupNum, &lookupCfgEgr);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "dev: %d, interfaceInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
            dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                        direction, lookupNum);

        direction = CPSS_PCL_DIRECTION_INGRESS_E;

        /*
            1.4. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
            other params same as in 1.1.
            Expected: GT_OK.
        */
        lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;

        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "dev: %d, interfaceInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
            dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                        direction, lookupNum);

        lookupNum = CPSS_PCL_LOOKUP_0_E;


        /*
           -- II - INTERFACE_TYPE - VLan (interfaceInfoPtr->type= CPSS_INTERFACE_VID_E) --

            1.5. Check Ingress direction. Call with interfaceInfoPtr [type = CPSS_INTERFACE_VID_E,
            vlanId = [100 / (PRV_CPSS_MAX_NUM_VLANS_CNS - 1) = 4095] ],
            direction [CPSS_PCL_DIRECTION_INGRESS_E],
            lookupNum [CPSS_PCL_LOOKUP_0_E],
            lookupCfgPtr [enableLookup = GT_TRUE,
                          pclId = 1023,
                          groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
                          other fields zeroed } ].
            Expected: GT_OK for all devices except ch1.
        */

        interfaceInfo.type = CPSS_INTERFACE_VID_E;
        interfaceInfo.vlanId = PRV_CPSS_MAX_NUM_VLANS_CNS - 1;
        direction=CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum=CPSS_PCL_LOOKUP_0_E;

        cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));
        lookupCfg.enableLookup = GT_TRUE;
        lookupCfg.pclId = 1023;
        lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
        lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "dev: %d, interfaceInfo [type=%d, vlanId=%d]",
                            dev, interfaceInfo.type, interfaceInfo.vlanId);

        interfaceInfo.vlanId = 100;

        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);

        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "dev: %d, interfaceInfo [type=%d, vlanId=%d], direction=%d, lookupNum=%d",
            dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);


        /*
            1.6. Call cpssDxChPclCfgTblGet with interfaceInfoPtr,
            direction, lookupNum - same as in 1.5, non-NULL lookupCfgPtr.
            Expected: GT_OK and same lookupCfgPtr as was written.
        */

        cpssOsMemSet((GT_VOID*)&lookupCfgRet, 0, sizeof(CPSS_DXCH_PCL_LOOKUP_CFG_STC));

        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfgRet);

        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "cpssDxChPclCfgTblGet:"
            "dev: %d, intInfo [type=%d, vlanId=%d], direction=%d, lookupNum=%d",
            dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

        if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
        {
            /* do not compare values ... no meaning in that */
            lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
        }

        if (GT_OK == st)
        {
            failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&lookupCfg,
                                            (const GT_VOID*)&lookupCfgRet,
                                            sizeof(lookupCfg))) ? GT_FALSE : GT_TRUE;
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                "get another lookupCfg than has been written [dev = %d, direction=%d, lookupNum=%d]",
                dev, direction, lookupNum);
        }

        /*
            1.7. Check Egress direction (not supported by Ch1).
            Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.5.
            Expected: GT_OK for all devices except Ch1.
        */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;

        cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));
        lookupCfg.enableLookup = GT_TRUE;
        lookupCfg.pclId = 1023;
        lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E;
        lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E;
        lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E;

        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
          "dev: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
              dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

        direction = CPSS_PCL_DIRECTION_INGRESS_E;

        /*
            1.8. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
            other params same as in 1.5.
            Expected: GT_OK.
        */
        lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;

        cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));
        lookupCfg.enableLookup = GT_TRUE;
        lookupCfg.pclId = 1023;
        lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
        lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
              "dev: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
              dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

        lookupNum = CPSS_PCL_LOOKUP_0_E;

        /*
            1.9. Check out-of-range direction enum. Call with direction [wrong enum values],
                other params same as in 1.5.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblSet
                            (dev, &interfaceInfo, direction, lookupNum, &lookupCfg),
                            direction);

        /*
            1.10. Check out-of-range lookupNum enum. Call with lookupNum [wrong enum values],
            other params same as in 1.5.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblSet
                            (dev, &interfaceInfo, direction, lookupNum, &lookupCfg),
                            lookupNum);

        /*
            1.11. Call with lookupCfgPtr [NULL], other params same as in 1.5.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "dev: %d, lookupCfgPtr=NULL", dev);

        /*
            1.12. Call with interfaceInfoPtr [NULL], other params same as in 1.5.
            Expected: GT_BAD_PTR.
        */

        st = cpssDxChPclCfgTblSet(dev, NULL, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "dev: %d, interfaceInfoPtr=NULL", dev);

        /*
            1.13. Check out-of-range vlan id. call with interfaceInfoPtr
            [type = CPSS_INTERFACE_VID_E, vlanId [PRV_CPSS_MAX_NUM_VLANS_CNS = 4096] ],
            other params same as in 1.5.
            Expected: non GT_OK.
        */
        interfaceInfo.vlanId = PRV_CPSS_MAX_NUM_VLANS_CNS;

        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st, "dev: %d, interfaceInfo.vlanId = %d",
                                         dev, interfaceInfo.vlanId);

        interfaceInfo.vlanId = 100;


        /*
           -- III - INTERFACE_TYPE - TRUNK (interfaceInfoPtr->type= CPSS_INTERFACE_TRUNK_E) --
                                             Supported only in Non-Local mode

            1.14. Check trunk interface with valid params. Call with
                    interfaceInfoPtr [type = CPSS_INTERFACE_TRUNK_E,
                                      trunkId = 0 ],
                    direction [CPSS_PCL_DIRECTION_INGRESS_E],
                    lookupNum [CPSS_PCL_LOOKUP_0_E],
                    lookupCfgPtr [enableLookup = GT_TRUE,
                                  pclId = 1023,
                                  groupKeyTypes
                                    {nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
                                     ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
                                     ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E } ].
            Expected: NOT GT_OK.
        */
        interfaceInfo.type = CPSS_INTERFACE_TRUNK_E;
        interfaceInfo.trunkId = 0;

        CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);
        direction=CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum=CPSS_PCL_LOOKUP_0_E;

        lookupCfg.enableLookup = GT_TRUE;
        lookupCfg.pclId = 1023;
        lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
        lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);

        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                  "dev: %d, interfaceInfo [trunkId=%d], direction=%d, lookupNum=%d",
                                   dev, interfaceInfo.trunkId, direction, lookupNum);

        /*
            1.15. Check out-of-range trunk id. Call with interfaceInfoPtr
                       [type = CPSS_INTERFACE_TRUNK_E,
                        trunkId [UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev) = 128] ], other params same as in 1.14.
            Expected: non GT_OK.
        */
        interfaceInfo.trunkId = UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev);
        CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);

        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
               "dev: %d, interfaceInfo.trunkId = %d", dev, interfaceInfo.trunkId);

        interfaceInfo.trunkId = 0;
        CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);


        /*
           -- IV - INTERFACE_TYPE - Vidx (unsupported) (interfaceInfoPtr->type= CPSS_INTERFACE_VIDX_E) --

            1.16. Check Vidx interface (unsupported) with valid params.
                    Call with interfaceInfoPtr [type = CPSS_INTERFACE_VIDX_E, vidx = 0 ],
                    other params same as in 1.1.
            Expected: NOT GT_OK.
        */
        interfaceInfo.type = CPSS_INTERFACE_VIDX_E;
        interfaceInfo.vidx = 0;

        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
                "dev: %d, interfaceInfo.type = %d", dev, interfaceInfo.type);

        interfaceInfo.type = CPSS_INTERFACE_PORT_E;
        interfaceInfo.devPort.hwDevNum = dev;
        interfaceInfo.devPort.portNum = 0;


        /*
           -- V - INTERFACE_TYPE - out-of-range --

            1.17. Check out-of-range interface type enum.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblSet
                            (dev, &interfaceInfo, direction, lookupNum, &lookupCfg),
                            interfaceInfo.type);

        /*
            1.18. Check Ingress direction. Call function with
                    direction [CPSS_PCL_DIRECTION_INGRESS_E]
                    lookupCfgPtr {
                        groupKeyTypes{
                          nonIpKey [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E
                                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E
                                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E],
                          ipv4Key  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E
                                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E
                                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E],
                          ipv6Key  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E
                                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E
                                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E],
                        },
                        udbKeyBitmapEnable[GT_FALSE / GT_TRUE],
                        tcamSegmentMode[
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_1_TCAM_E,
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_2_AND_2_E,
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_1_AND_3_E,
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_3_AND_1_E,
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_4_TCAMS_E]},
                    and other params same as in 1.1.
            Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /*
                Call with direction [CPSS_PCL_DIRECTION_INGRESS_E],
                    lookupCfgPtr {
                        groupKeyTypes{
                          nonIpKey [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E],
                          ipv4Key  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E],
                          ipv6Key  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E],
                        },
                        udbKeyBitmapEnable[GT_FALSE],
                        tcamSegmentMode[
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_1_TCAM_E]},
                    and other params same as in 1.1.
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            interfaceInfo.type = CPSS_INTERFACE_PORT_E;

            lookupCfg.groupKeyTypes.nonIpKey =
                                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E;
            lookupCfg.groupKeyTypes.ipv4Key  =
                                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E;
            lookupCfg.groupKeyTypes.ipv6Key  =
                                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E;
            lookupCfg.udbKeyBitmapEnable = GT_FALSE;

            lookupCfg.tcamSegmentMode = CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_1_TCAM_E;

            st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfg);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                                         "dev: %d, direction=%d, lookupNum=%d",
                                         dev, direction, lookupNum);
            /* Verify values */
            st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfgRet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclCfgTblGet",dev);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.udbKeyBitmapEnable,
                                          lookupCfgRet.udbKeyBitmapEnable,
                   "get another lookupCfg->udbKeyBitmapEnable than was set: %d",
                                          dev);
            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.tcamSegmentMode,
                                          lookupCfgRet.tcamSegmentMode,
                      "get another lookupCfg->tcamSegmentMode than was set: %d",
                                          dev);
            /*
                Call with direction [CPSS_PCL_DIRECTION_INGRESS_E],
                    lookupCfgPtr {
                        groupKeyTypes{
                          nonIpKey [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E],
                          ipv4Key  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E],
                          ipv6Key  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E],
                        },
                        udbKeyBitmapEnable[GT_TRUE],
                        tcamSegmentMode[
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_2_AND_2_E]},
                    and other params same as in 1.1.
            */
            lookupCfg.udbKeyBitmapEnable = GT_TRUE;
            lookupCfg.groupKeyTypes.nonIpKey =
                                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E;
            lookupCfg.groupKeyTypes.ipv4Key  =
                                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E;
            lookupCfg.groupKeyTypes.ipv6Key  =
                                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E;
            lookupCfg.tcamSegmentMode =
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_2_AND_2_E;

            st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfg);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                                         "dev: %d, direction=%d, lookupNum=%d",
                                         dev, direction, lookupNum);

            /* Verify values */
            st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfgRet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclCfgTblGet",dev);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.udbKeyBitmapEnable,
                                          lookupCfgRet.udbKeyBitmapEnable,
                   "get another lookupCfg->udbKeyBitmapEnable than was set: %d",
                                          dev);
            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.tcamSegmentMode,
                                          lookupCfgRet.tcamSegmentMode,
                      "get another lookupCfg->tcamSegmentMode than was set: %d",
                                          dev);
            /*
                Call with direction [CPSS_PCL_DIRECTION_INGRESS_E],
                    lookupCfgPtr {
                        groupKeyTypes{
                          nonIpKey [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E],
                          ipv4Key  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E],
                          ipv6Key  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E],
                        },
                        tcamSegmentMode[
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_1_AND_3_E]},
                    and other params same as in 1.1.
            */
            lookupCfg.groupKeyTypes.nonIpKey =
                                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E;
            lookupCfg.groupKeyTypes.ipv4Key  =
                                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E;
            lookupCfg.groupKeyTypes.ipv6Key  =
                                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E;
            lookupCfg.tcamSegmentMode =
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_1_AND_3_E;

            st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfg);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                                         "dev: %d, direction=%d, lookupNum=%d",
                                         dev, direction, lookupNum);

            /* Verify values */
            st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfgRet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclCfgTblGet",dev);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.tcamSegmentMode,
                                          lookupCfgRet.tcamSegmentMode,
                      "get another lookupCfg->tcamSegmentMode than was set: %d",
                                          dev);
            /*
                Call with direction [CPSS_PCL_DIRECTION_INGRESS_E],
                        lookupCfgPtr { tcamSegmentMode[
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_3_AND_1_E]},
                        and other params same as in 1.1.
            */
            lookupCfg.tcamSegmentMode =
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_3_AND_1_E;

            st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfg);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                                         "dev: %d, direction=%d, lookupNum=%d",
                                         dev, direction, lookupNum);

            /* Verify values */
            st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfgRet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclCfgTblGet",dev);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.tcamSegmentMode,
                                          lookupCfgRet.tcamSegmentMode,
                      "get another lookupCfg->tcamSegmentMode than was set: %d",
                                          dev);
            /*
                Call with direction [CPSS_PCL_DIRECTION_INGRESS_E],
                        lookupCfgPtr {
                            tcamSegmentMode[
                                CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_4_TCAMS_E]},
                        and other params same as in 1.1.
            */
            lookupCfg.tcamSegmentMode =
                                      CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_4_TCAMS_E;

            st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfg);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                                         "dev: %d, direction=%d, lookupNum=%d",
                                         dev, direction, lookupNum);
        }
        /*
            1.19. Call cpssDxChPclCfgTblGet with interfaceInfoPtr,
                  direction, lookupNum - same as in 1.18, non-NULL lookupCfgPtr.
            Expected: GT_OK and same lookupCfg as was written for Bobcat2; Caelum; Bobcat3
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /* Verify values */
            st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfgRet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclCfgTblGet",dev);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.tcamSegmentMode,
                                          lookupCfgRet.tcamSegmentMode,
                      "get another lookupCfg->tcamSegmentMode than was set: %d",
                                          dev);
        }
        /*
            1.20. Check Egress direction. Call function with
                direction [CPSS_PCL_DIRECTION_EGRESS_E]
                    lookupCfgPtr {
                        groupKeyTypes{
                          nonIpKey [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E
                                    CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E],
                          ipv4Key  [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E
                                    CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E],
                          ipv6Key  [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E
                                    CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E],
                        },
                        udbKeyBitmapEnable[GT_FALSE / GT_TRUE],
                        tcamSegmentMode[
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_1_TCAM_E,
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_2_AND_2_E,
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_1_AND_3_E,
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_3_AND_1_E,
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_4_TCAMS_E]},
                    and other params same as in 1.1.
            Expected: GT_OK  for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /*
                Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
                    lookupCfgPtr {
                        groupKeyTypes{
                          nonIpKey [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E],
                          ipv4Key  [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E],
                          ipv6Key  [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E],
                        },
                        udbKeyBitmapEnable[GT_FALSE],
                        tcamSegmentMode[
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_1_TCAM_E]},
                    and other params same as in 1.1.
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;

            lookupCfg.groupKeyTypes.nonIpKey =
                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E;
            lookupCfg.groupKeyTypes.ipv4Key  =
                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E;
            lookupCfg.groupKeyTypes.ipv6Key  =
                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E;
            lookupCfg.udbKeyBitmapEnable = GT_FALSE;

            lookupCfg.tcamSegmentMode =
                                       CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_1_TCAM_E;

            st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfg);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                                         "dev: %d, direction=%d, lookupNum=%d",
                                         dev, direction, lookupNum);

            /* Verify values */
            st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfgRet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclCfgTblGet",dev);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.udbKeyBitmapEnable,
                                          lookupCfgRet.udbKeyBitmapEnable,
                   "get another lookupCfg->udbKeyBitmapEnable than was set: %d",
                                          dev);
            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.tcamSegmentMode,
                                          lookupCfgRet.tcamSegmentMode,
                      "get another lookupCfg->tcamSegmentMode than was set: %d",
                                          dev);
            /*
                Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
                    lookupCfgPtr {
                        groupKeyTypes{
                          nonIpKey [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E],
                          ipv4Key  [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E],
                          ipv6Key  [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E],
                        },
                        udbKeyBitmapEnable[GT_TRUE],
                        tcamSegmentMode[
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_2_AND_2_E]},
                    and other params same as in 1.1.
            */
            lookupCfg.udbKeyBitmapEnable = GT_TRUE;
            lookupCfg.groupKeyTypes.nonIpKey =
                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E;
            lookupCfg.groupKeyTypes.ipv4Key  =
                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E;
            lookupCfg.groupKeyTypes.ipv6Key  =
                                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E;
            lookupCfg.tcamSegmentMode =
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_2_AND_2_E;

            st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfg);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                                         "dev: %d, direction=%d, lookupNum=%d",
                                         dev, direction, lookupNum);

            /* Verify values */
            st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfgRet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclCfgTblGet",dev);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.udbKeyBitmapEnable,
                                          lookupCfgRet.udbKeyBitmapEnable,
                   "get another lookupCfg->udbKeyBitmapEnable than was set: %d",
                                          dev);
            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.tcamSegmentMode,
                                          lookupCfgRet.tcamSegmentMode,
                      "get another lookupCfg->tcamSegmentMode than was set: %d",
                                          dev);
            /*
                Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
                    lookupCfgPtr {
                        groupKeyTypes{
                          nonIpKey [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E],
                          ipv4Key  [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E],
                          ipv6Key  [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E],
                        },
                        tcamSegmentMode[
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_1_AND_3_E]},
                    and other params same as in 1.1.
            */
            lookupCfg.tcamSegmentMode =
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_1_AND_3_E;

            st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfg);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                                         "dev: %d, direction=%d, lookupNum=%d",
                                         dev, direction, lookupNum);

            /* Verify values */
            st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfgRet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclCfgTblGet",dev);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.tcamSegmentMode,
                                          lookupCfgRet.tcamSegmentMode,
                      "get another lookupCfg->tcamSegmentMode than was set: %d",
                                          dev);
            /*
                Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
                        lookupCfgPtr { tcamSegmentMode[
                            CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_3_AND_1_E]},
                        and other params same as in 1.1.
            */
            lookupCfg.tcamSegmentMode =
                              CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_2_TCAMS_3_AND_1_E;
            if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                /* the range 0..15 */
                lookupCfg.exactMatchLookupSubProfileId = 0xA;
            }
            else
            {
                /* Falcon also supports it, but the range 0..7*/
                lookupCfg.exactMatchLookupSubProfileId = 0x5;
            }

            st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfg);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                                         "dev: %d, direction=%d, lookupNum=%d",
                                         dev, direction, lookupNum);

            /* Verify values */
            st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfgRet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclCfgTblGet",dev);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            if (! PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.exactMatchLookupSubProfileId = lookupCfgRet.exactMatchLookupSubProfileId;
            }

            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.tcamSegmentMode,
                                          lookupCfgRet.tcamSegmentMode,
                      "get another lookupCfg->tcamSegmentMode than was set: %d",
                                          dev);
            /*
                Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
                        lookupCfgPtr {
                            tcamSegmentMode[
                                CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_4_TCAMS_E]},
                        and other params same as in 1.1.
            */
            lookupCfg.tcamSegmentMode =
                                      CPSS_DXCH_PCL_TCAM_SEGMENT_MODE_4_TCAMS_E;

            st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfg);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                                         "dev: %d, direction=%d, lookupNum=%d",
                                         dev, direction, lookupNum);
        }
        /*
            1.21. Call cpssDxChPclCfgTblGet with interfaceInfoPtr,
            direction, lookupNum - same as in 1.20, non-NULL lookupCfgPtr.
            Expected: GT_OK and same lookupCfg as was written for Bobcat2; Caelum; Bobcat3
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            /* Verify values */
            st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum,
                                      &lookupCfgRet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclCfgTblGet",dev);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            UTF_VERIFY_EQUAL1_STRING_MAC( lookupCfg.tcamSegmentMode,
                                          lookupCfgRet.tcamSegmentMode,
                      "get another lookupCfg->tcamSegmentMode than was set: %d",
                                          dev);
        }
        /*
            1.22. Call function with out of range groupKeyTypes.nonIpKey
                   and other parameters from 1.20.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblSet
                                (dev, &interfaceInfo, direction, lookupNum,
                                 &lookupCfg),
                                lookupCfg.groupKeyTypes.nonIpKey);
        }
        /*
            1.23. Call function with out of range groupKeyTypes.ipv4Key
                   and other parameters from 1.20.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblSet
                                (dev, &interfaceInfo, direction, lookupNum,
                                 &lookupCfg),
                                lookupCfg.groupKeyTypes.ipv4Key);
        }
        /*
            1.24. Call function with out of range groupKeyTypes.ipv6Key
                   and other parameters from 1.20.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblSet
                                (dev, &interfaceInfo, direction, lookupNum,
                                 &lookupCfg),
                                lookupCfg.groupKeyTypes.ipv6Key);
        }
        /*
            1.25. Call function with out of range tcamSegmentMode
                   and other parameters from 1.20.
            Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.

        */
        if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
        {
            /* field is ignored */
        }
        else
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblSet
                                (dev, &interfaceInfo, direction, lookupNum,
                                 &lookupCfg),
                                lookupCfg.tcamSegmentMode);
        }
    }

    /* set correct values for all the parameters (except of device number) */
    interfaceInfo.type = CPSS_INTERFACE_VID_E;
    interfaceInfo.vlanId = 100;

    direction=CPSS_PCL_DIRECTION_INGRESS_E;

    lookupNum=CPSS_PCL_LOOKUP_0_E;
    lookupCfg.enableLookup = GT_TRUE;
    lookupCfg.pclId = 1023;
    lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
    lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclCfgTblSet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclCfgTblGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_INTERFACE_INFO_STC        *interfaceInfoPtr,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    OUT CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclCfgTblGet)
{
/*
    ITERATE_DEVICES

       I - INTERFACE_TYPE - Port (interfaceInfoPtr->type= CPSS_INTERFACE_PORT_E)

    1.1. Check Ingress direction. Call with
                interfaceInfoPtr [type = CPSS_INTERFACE_PORT_E,
                                  devPort {devNum=0, portNum=0} ],
                direction [CPSS_PCL_DIRECTION_INGRESS_E],
                lookupNum [CPSS_PCL_LOOKUP_0_E], non-NULL lookupCfgPtr.
    Expected: GT_OK
    1.2. Check Egress direction (not supported by Ch1).
    Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
    other params same as in 1.1.
    Expected: GT_OK for all devices except Ch1.
    1.3. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
    other params same as in 1.1.
    Expected: GT_OK.

       -- II - INTERFACE_TYPE - VLan (interfaceInfoPtr->type= CPSS_INTERFACE_VID_E) --

    1.4. Check Ingress direction. Call with
    interfaceInfoPtr [type = CPSS_INTERFACE_VID_E,
                      vlanId = [100  / (PRV_CPSS_MAX_NUM_VLANS_CNS - 1) = 4095] ],
    direction [CPSS_PCL_DIRECTION_INGRESS_E],
    lookupNum [CPSS_PCL_LOOKUP_0_E],
    lookupCfgPtr [enableLookup = GT_TRUE,
                  pclId = 1023,
                  groupKeyTypes
                   {nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
                    ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
                    ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E } ].
    Expected: GT_OK for all devices except ch1.
    1.5. Check Egress direction (not supported by Ch1). Call with direction
    [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.4.
    Expected: GT_OK for all devices except ch1.
    1.6. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
    other params same as in 1.4.
    Expected: GT_OK.
    1.7. Call with direction [wrong enum values], other params same as in 1.4.
    Expected: GT_BAD_PARAM.
    1.8. Call with lookupNum [wrong enum values], other params same as in 1.4.
    Expected: GT_BAD_PARAM.
    1.9.  Call with lookupCfgPtr [NULL], other params same as in 1.4.
    Expected: GT_BAD_PTR.
    1.10. Call with interfaceInfoPtr [NULL], other params same as in 1.4.
    Expected: GT_BAD_PTR.
    1.11. Check out-of-range vlan id. Call with
           interfaceInfoPtr [type = CPSS_INTERFACE_VID_E,
                             vlanId [PRV_CPSS_MAX_NUM_VLANS_CNS = 4096] ],
           other params same as in 1.4.
    Expected: non GT_OK.

       -- III - INTERFACE_TYPE - TRUNK (interfaceInfoPtr->type= CPSS_INTERFACE_TRUNK_E) --
                                    Supported only in Non-Local mode

    1.12. Check trunk interface with valid params. Call with
            interfaceInfoPtr [type = CPSS_INTERFACE_TRUNK_E,
                              trunkId = 0 ],
            direction [CPSS_PCL_DIRECTION_INGRESS_E],
            lookupNum [CPSS_PCL_LOOKUP_0_E],
            lookupCfgPtr [enableLookup = GT_TRUE,
                          pclId = 1023,
                          groupKeyTypes {
                              nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
                              ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
                              ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E } ].
    Expected: GT_OK.
    1.13. Check out-of-range trunk id. Call with interfaceInfoPtr
    [type = CPSS_INTERFACE_TRUNK_E, trunkId [UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev) = 128] ],
    other params same as in 1.12.
    Expected: NOT GT_OK.

       -- IV - INTERFACE_TYPE - Vidx (unsupported) (interfaceInfoPtr->type= CPSS_INTERFACE_VIDX_E) --

    1.14. Check Vidx interface (unsupported) with valid params.
            Call with interfaceInfoPtr [type = CPSS_INTERFACE_VIDX_E,
                                        vidx = 0 ],
            other params same as in 1.1.
    Expected: non GT_OK.

       -- V - INTERFACE_TYPE - out-of-range --

    1.15. Check out-of-range interface type enum. Call with
            interfaceInfoPtr [type = wrong enum values,
                              devPort {devNum=0, portNum=0},
                              trunkId = 0,
                              vidx = 0,
                              vlanId = 100 ],
            other params same as in 1.1.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                       st = GT_OK;
    GT_U8                           dev;

    CPSS_INTERFACE_INFO_STC         interfaceInfo;
    CPSS_PCL_DIRECTION_ENT          direction;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum;
    CPSS_DXCH_PCL_LOOKUP_CFG_STC    lookupCfg;

    CPSS_PP_FAMILY_TYPE_ENT         devFamily;
    /* access mode */
    CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   accMode;
    GT_BOOL                         iPcl0Bypass;

    accMode.ipclAccMode     = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E;
    accMode.epclAccMode     = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E;
    accMode.ipclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
    accMode.epclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
    accMode.ipclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
    accMode.epclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        if (! PRV_CPSS_SIP_6_CHECK_MAC(dev))
        {
            /* for SIP6 devices hard-wired local-port-access */
            st = cpssDxChPclCfgTblAccessModeSet(
                dev, &accMode);
            UTF_VERIFY_EQUAL1_STRING_MAC(
                GT_OK, st, "cpssDxChPclCfgTblAccessModeSet: %d", dev);
        }

        /* get device family */
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

        /*
           I - INTERFACE_TYPE - Port (interfaceInfoPtr->type= CPSS_INTERFACE_PORT_E)

            1.1. Check Ingress direction. Call with
                        interfaceInfoPtr [type = CPSS_INTERFACE_PORT_E,
                                          devPort {devNum=0, portNum=0} ],
                        direction [CPSS_PCL_DIRECTION_INGRESS_E],
                        lookupNum [CPSS_PCL_LOOKUP_0_E], non-NULL lookupCfgPtr.
            Expected: GT_OK
        */
        interfaceInfo.type = CPSS_INTERFACE_PORT_E;
        interfaceInfo.devPort.hwDevNum = dev;
        interfaceInfo.devPort.portNum = 0;

        direction=CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum=CPSS_PCL_LOOKUP_0_E;

        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);

        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "dev: %d, interfaceInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
            dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                      direction, lookupNum);

        /*
            1.2. Check Egress direction (not supported by Ch1).
            Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.1.
            Expected: GT_OK for all devices except Ch1.
        */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;
        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
           "dev: %d, interfaceInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
           dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                        direction, lookupNum);

        direction = CPSS_PCL_DIRECTION_INGRESS_E;

        /*
            1.3. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
            other params same as in 1.1.
            Expected: GT_OK.
        */
        lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;
        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);

        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
           "dev: %d, interfaceInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
                   dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                                direction, lookupNum);

        lookupNum = CPSS_PCL_LOOKUP_0_E;


        /*
           -- II - INTERFACE_TYPE - VLan (interfaceInfoPtr->type= CPSS_INTERFACE_VID_E) --

            1.4. Check Ingress direction. Call with
            interfaceInfoPtr [type = CPSS_INTERFACE_VID_E,
                              vlanId = [100  / (PRV_CPSS_MAX_NUM_VLANS_CNS - 1) = 4095] ],
            direction [CPSS_PCL_DIRECTION_INGRESS_E],
            lookupNum [CPSS_PCL_LOOKUP_0_E],
            lookupCfgPtr [enableLookup = GT_TRUE,
                          pclId = 1023,
                          groupKeyTypes
                           {nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
                            ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
                            ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E } ].
            Expected: GT_OK for all devices except ch1.
        */
        interfaceInfo.type = CPSS_INTERFACE_VID_E;
        interfaceInfo.vlanId = PRV_CPSS_MAX_NUM_VLANS_CNS - 1;

        direction=CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum=CPSS_PCL_LOOKUP_0_E;

        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                "dev: %d, interfaceInfo [type=%d, vlanId =%d]",
                            dev, interfaceInfo.type, interfaceInfo.vlanId);

        /*call with interfaceInfo.vlanId = 100;*/
        interfaceInfo.vlanId = 100;

        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);

        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "dev: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
                dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

        /*
            1.5. Check Egress direction (not supported by Ch1).
            Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.4.
            Expected: GT_OK for all devices except ch1.
        */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;
        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
          "dev: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
              dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

        direction = CPSS_PCL_DIRECTION_INGRESS_E;

        /*
            1.6. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
            other params same as in 1.4.
            Expected: GT_OK.
        */
        lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;

        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
              "dev: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
                  dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

        lookupNum = CPSS_PCL_LOOKUP_0_E;

        /*
            1.7. Call with direction [wrong enum values], other params same as in 1.4.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblGet
                            (dev, &interfaceInfo, direction, lookupNum, &lookupCfg),
                            direction);

        /*
            1.8. Call with lookupNum [wrong enum values], other params same as in 1.4.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblGet
                            (dev, &interfaceInfo, direction, lookupNum, &lookupCfg),
                            lookupNum);

        /*
            1.9.  Call with lookupCfgPtr [NULL], other params same as in 1.4.
            Expected: GT_BAD_PTR.
        */

        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "dev: %d, lookupCfgPtr=NULL", dev);

        /*
            1.10. Call with interfaceInfoPtr [NULL], other params same as in 1.4.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclCfgTblGet(dev, NULL, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "dev: %d, interfaceInfoPtr=NULL", dev);

        /*
            1.11. Check out-of-range vlan id. Call with
                   interfaceInfoPtr [type = CPSS_INTERFACE_VID_E,
                                     vlanId [PRV_CPSS_MAX_NUM_VLANS_CNS = 4096] ],
                   other params same as in 1.4.
            Expected: non GT_OK.
        */
        interfaceInfo.vlanId = PRV_CPSS_MAX_NUM_VLANS_CNS;

        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st, "dev: %d, interfaceInfo.vlanId = %d", dev,
                                          interfaceInfo.vlanId);

        interfaceInfo.vlanId = 100;


        /*
           -- III - INTERFACE_TYPE - TRUNK (interfaceInfoPtr->type= CPSS_INTERFACE_TRUNK_E) --
                                            Supported only in Non-Local mode

            1.12. Check trunk interface with valid params. Call with
                    interfaceInfoPtr [type = CPSS_INTERFACE_TRUNK_E,
                                      trunkId = 0 ],
                    direction [CPSS_PCL_DIRECTION_INGRESS_E],
                    lookupNum [CPSS_PCL_LOOKUP_0_E],
                    lookupCfgPtr [enableLookup = GT_TRUE,
                                  pclId = 1023,
                                  groupKeyTypes {
                                      nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
                                      ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
                                      ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E } ].
            Expected: GT_OK.
        */
        interfaceInfo.type = CPSS_INTERFACE_TRUNK_E;
        interfaceInfo.trunkId = 0;

        CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);

        direction=CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum=CPSS_PCL_LOOKUP_0_E;

        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);

        UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
          "dev: %d, interfaceInfo [trunkId=%d], direction=%d, lookupNum=%d",
                                   dev, interfaceInfo.trunkId, direction, lookupNum);

        /*
            1.13. Check out-of-range trunk id. Call with interfaceInfoPtr
            [type = CPSS_INTERFACE_TRUNK_E, trunkId [UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev) = 128] ],
            other params same as in 1.12.
            Expected: NOT GT_OK.
        */
        interfaceInfo.trunkId = UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev);
        CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);

        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
               "dev: %d, interfaceInfo.trunkId = %d", dev, interfaceInfo.trunkId);

        interfaceInfo.trunkId = 0;
        CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);


        /*
           -- IV - INTERFACE_TYPE - Vidx (unsupported) (interfaceInfoPtr->type= CPSS_INTERFACE_VIDX_E) --

            1.14. Check Vidx interface (unsupported) with valid params.
                    Call with interfaceInfoPtr [type = CPSS_INTERFACE_VIDX_E,
                                                vidx = 0 ],
                    other params same as in 1.1.
            Expected: non GT_OK.
        */
        interfaceInfo.type = CPSS_INTERFACE_VIDX_E;
        interfaceInfo.vidx = 0;

        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st, "dev: %d, interfaceInfo.type = %d",
                                         dev, interfaceInfo.type);

        interfaceInfo.type = CPSS_INTERFACE_PORT_E;
        interfaceInfo.vidx = 0;


        /*
           -- V - INTERFACE_TYPE - out-of-range --

            1.15. Check out-of-range interface type enum. Call with
                    interfaceInfoPtr [type = wrong enum values,
                                      devPort {devNum=0, portNum=0},
                                      trunkId = 0,
                                      vidx = 0,
                                      vlanId = 100 ],
                    other params same as in 1.1.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblGet
                            (dev, &interfaceInfo, direction, lookupNum, &lookupCfg),
                            interfaceInfo.type);
    }

    /* set correct values for all the parameters (except of device number) */
    interfaceInfo.type = CPSS_INTERFACE_VID_E;
    interfaceInfo.vlanId = 100;

    direction=CPSS_PCL_DIRECTION_INGRESS_E;
    lookupNum=CPSS_PCL_LOOKUP_0_E;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclCfgTblGet(dev, &interfaceInfo, direction, lookupNum, &lookupCfg);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclIngressPolicyEnable
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclIngressPolicyEnable)
{
/*
    ITERATE_DEVICES
    1.1. Call with enable [GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.2 Call cpssDxChPclIngressPolicyEnableGet
             with non-NULL enableGet.
    Expected: GT_OK and the same enable.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_BOOL     enable    = GT_FALSE;
    GT_BOOL     enableGet = GT_FALSE;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with enable [GT_FALSE / GT_TRUE].
            Expected: GT_OK.
        */
        /* call with enable = GT_FALSE;*/
        enable = GT_FALSE;

        st = cpssDxChPclIngressPolicyEnable(dev, enable);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st, "dev: %d, %d", dev, enable);

        /*
            1.2 Call cpssDxChPclIngressPolicyEnableGet
                     with non-NULL enableGet.
            Expected: GT_OK and the same enable.
        */
        st = cpssDxChPclIngressPolicyEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                "cpssDxChPclIngressPolicyEnableGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                "get another enable than was set: %d", dev);

        /* call with enable = GT_TRUE;*/
        enable = GT_TRUE;

        st = cpssDxChPclIngressPolicyEnable(dev, enable);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st, "dev: %d, %d", dev, enable);

        /*
            1.2 Call cpssDxChPclIngressPolicyEnableGet
                     with non-NULL enableGet.
            Expected: GT_OK and the same enable.
        */
        st = cpssDxChPclIngressPolicyEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                "cpssDxChPclIngressPolicyEnableGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                "get another enable than was set: %d", dev);
    }

    enable = GT_FALSE;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /*2. Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclIngressPolicyEnable(dev, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclIngressPolicyEnable(dev, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclIngressPolicyEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclIngressPolicyEnableGet)
{
/*
    ITERATE_DEVICES
    1.1. Call with non-NULL enablePtr
    Expected: GT_OK.
    1.2 Call with enablePtr [NULL];
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_BOOL     enable = GT_FALSE;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with non-NULL enablePtr
            Expected: GT_OK.
        */
        st = cpssDxChPclIngressPolicyEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2 Call with enablePtr [NULL];
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclIngressPolicyEnableGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enablePtr = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclIngressPolicyEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclIngressPolicyEnableGet(dev, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclTwoLookupsCpuCodeResolution
(
    IN GT_U8                       devNum,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclTwoLookupsCpuCodeResolution)
{
/*
    ITERATE_DEVICES
    1.1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E / CPSS_PCL_LOOKUP_1_E].
    Expected: GT_OK.
    1.2. Check for invalid enum value for lookupNum.
    Call with lookupNum [wrong enum values].
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st = GT_OK;
    GT_U8                                   dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT              lookupNum;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E / CPSS_PCL_LOOKUP_1_E].
            Expected: GT_OK.
        */
        /* call with lookupNum = CPSS_PCL_LOOKUP_0_E; */
        lookupNum = CPSS_PCL_LOOKUP_0_E;

        st = cpssDxChPclTwoLookupsCpuCodeResolution(dev, lookupNum);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st, "dev: %d, %d", dev, lookupNum);

        /* call with lookupNum = CPSS_PCL_LOOKUP_1_E; */
        lookupNum = CPSS_PCL_LOOKUP_1_E;

        st = cpssDxChPclTwoLookupsCpuCodeResolution(dev, lookupNum);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st, "dev: %d, %d", dev, lookupNum);

        /*
            1.2. Check for invalid enum value for lookupNum.
            Call with lookupNum [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclTwoLookupsCpuCodeResolution
                            (dev, lookupNum),
                            lookupNum);
    }

    lookupNum = CPSS_PCL_LOOKUP_1_E;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /*2. Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclTwoLookupsCpuCodeResolution(dev, lookupNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclTwoLookupsCpuCodeResolution(dev, lookupNum);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclInvalidUdbCmdSet
(
    IN GT_U8                        devNum,
    IN CPSS_DXCH_UDB_ERROR_CMD_ENT  udbErrorCmd
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclInvalidUdbCmdSet)
{
/*
    ITERATE_DEVICES
    1.1. Call with udbErrorCmd [CPSS_DXCH_UDB_ERROR_CMD_LOOKUP_E/
                                CPSS_DXCH_UDB_ERROR_CMD_DROP_SOFT_E].
    Expected: GT_OK
    1.2. Call cpssDxChPclInvalidUdbCmdGet
    Expected: GT_OK and same udbErrorCmd.
    1.3. Check for invalid enum value for udbErrorCmd.  Call with
    udbErrorCmd [wrong enum values].
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st = GT_OK;
    GT_U8                                   dev;
    CPSS_DXCH_UDB_ERROR_CMD_ENT             udbErrorCmd;
    CPSS_DXCH_UDB_ERROR_CMD_ENT             udbErrorCmdGet;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with udbErrorCmd [CPSS_DXCH_UDB_ERROR_CMD_LOOKUP_E/
                                        CPSS_DXCH_UDB_ERROR_CMD_DROP_SOFT_E].
            Expected: GT_OK
        */
        /* call with udbErrorCmd = CPSS_DXCH_UDB_ERROR_CMD_LOOKUP_E; */
        udbErrorCmd = CPSS_DXCH_UDB_ERROR_CMD_LOOKUP_E;

        st = cpssDxChPclInvalidUdbCmdSet(dev, udbErrorCmd);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st, "dev: %d, %d", dev, udbErrorCmd);

        /*  1.2.  */
        st = cpssDxChPclInvalidUdbCmdGet(dev, &udbErrorCmdGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "dev: %d, %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(udbErrorCmd, udbErrorCmdGet,
                                    "get another udbErrorCmd than was set: %d", dev);

        /* call with udbErrorCmd = CPSS_DXCH_UDB_ERROR_CMD_DROP_SOFT_E; */
        udbErrorCmd = CPSS_DXCH_UDB_ERROR_CMD_DROP_SOFT_E;

        st = cpssDxChPclInvalidUdbCmdSet(dev, udbErrorCmd);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st, "dev: %d, %d", dev, udbErrorCmd);

        /*  1.2.  */
        st = cpssDxChPclInvalidUdbCmdGet(dev, &udbErrorCmdGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "dev: %d, %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(udbErrorCmd, udbErrorCmdGet,
                                    "get another udbErrorCmd than was set: %d", dev);

        /*
            1.3. Check for invalid enum value for udbErrorCmd.  Call with
            udbErrorCmd [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclInvalidUdbCmdSet
                            (dev, udbErrorCmd),
                            udbErrorCmd);
    }

    udbErrorCmd = CPSS_DXCH_UDB_ERROR_CMD_LOOKUP_E;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /*2. Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclInvalidUdbCmdSet(dev, udbErrorCmd);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclInvalidUdbCmdSet(dev, udbErrorCmd);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
UTF_TEST_CASE_MAC(cpssDxChPclInvalidUdbCmdGet)
{
/*
    ITERATE_DEVICES
    1.1. Call with not NULL udbErrorCmdPtr.
    Expected: GT_OK
    1.2. Call with NULL udbErrorCmdPtr.
    Expected: GT_BAD_PTR
*/
    GT_STATUS                               st = GT_OK;
    GT_U8                                   dev;
    CPSS_DXCH_UDB_ERROR_CMD_ENT             udbErrorCmd;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*  1.1. */
        st = cpssDxChPclInvalidUdbCmdGet(dev, &udbErrorCmd);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "dev: %d", dev);

        /*  1.2. */
        st = cpssDxChPclInvalidUdbCmdGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "dev: %d", dev);
    }

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /*2. Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclInvalidUdbCmdGet(dev, &udbErrorCmd);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclInvalidUdbCmdGet(dev, &udbErrorCmd);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_ENT   udbValuesBmpMode
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet)
{
    GT_STATUS                                  st = GT_OK;
    GT_U8                                      dev;
    static CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_ENT   udbValuesBmpModeArr[] =
    {
        CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_8_BYTES_E,
        CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_16_BYTES_E,
        CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_32_BYTES_E
    };
    static GT_U32 udbValuesBmpModeNum =
        (sizeof(udbValuesBmpModeArr) / sizeof(udbValuesBmpModeArr[0]));
    CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_ENT   udbValuesBmpMode;
    CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_ENT   udbValuesBmpModeGet;
    GT_U32                                     i;

    /* this feature is on Falcon devices only */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_CNS ) ;

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        for (i = 0; (i < udbValuesBmpModeNum); i++)
        {
            udbValuesBmpMode = udbValuesBmpModeArr[i];
            st = cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet(dev, udbValuesBmpMode);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st, "Set dev: %d, %d", dev, udbValuesBmpMode);
            st = cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet(dev, &udbValuesBmpModeGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "Get dev: %d", dev);
            UTF_VERIFY_EQUAL0_STRING_MAC(udbValuesBmpMode, udbValuesBmpModeGet, "Set and Get");
        }
        /*
            Check for invalid enum value for udbValuesBmpMode.  Call with
            udbErrorCmd [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        udbValuesBmpMode = CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_32_BYTES_E;
        UTF_ENUMS_CHECK_MAC(
            cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet(dev, udbValuesBmpMode),
            udbValuesBmpMode);
    }

    udbValuesBmpMode = CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_32_BYTES_E;

    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_CNS ) ;
    /*2. Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet(dev, udbValuesBmpMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet(dev, udbValuesBmpMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet
(
    IN  GT_U8                                      devNum,
    OUT CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_ENT   *udbValuesBmpModePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet)
{
    GT_STATUS                                  st = GT_OK;
    GT_U8                                      dev;
    CPSS_DXCH_PCL_UDB_VALUES_BITMAP_MODE_ENT   udbValuesBmpMode;

    /* this feature is on Falcon devices only */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_CNS ) ;

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet(dev, &udbValuesBmpMode);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "Get dev: %d", dev);
        st = cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "Get dev: %d", dev);
    }

    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_CNS ) ;
    /*2. Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet(dev, &udbValuesBmpMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet(dev, &udbValuesBmpMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclIpLengthCheckModeSet
(
    IN GT_U8                                   devNum,
    IN CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_ENT  mode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclIpLengthCheckModeSet)
{
/*
    ITERATE_DEVICES
    1.1. Call with mode [CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L2_E /
                         CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L3_E]
    Expected: GT_OK
    1.2. Call cpssDxChPclIpLengthCheckModeGet
    Expected: GT_OK and same mode
    1.3. Check for invalid enum value for mode.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                               st = GT_OK;
    GT_U8                                   dev;
    CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_ENT  mode;
    CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_ENT  modeGet;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_E_ARCH_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with mode [CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L2_E /
                                 CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L3_E]
            Expected: GT_OK
        */
        /* call with mode = CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L2_E; */
        mode = CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L2_E;

        st = cpssDxChPclIpLengthCheckModeSet(dev, mode);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st, "dev: %d, %d", dev, mode);

        /*  1.2.  */
        st = cpssDxChPclIpLengthCheckModeGet(dev, &modeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "dev: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(mode, modeGet,
                                "get another mode than was set: %d", dev);

        /* call with mode = CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L3_E; */
        mode = CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L3_E;

        st = cpssDxChPclIpLengthCheckModeSet(dev, mode);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st, "dev: %d, %d", dev, mode);

        /*  1.2.  */
        st = cpssDxChPclIpLengthCheckModeGet(dev, &modeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "dev: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(mode, modeGet,
                                "get another mode than was set: %d", dev);

        /*
            1.3. Check for invalid enum value for mode.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclIpLengthCheckModeSet
                            (dev, mode),
                            mode);
    }

    mode = CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L2_E;

    /* SIP5 not supported */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_E_ARCH_CNS);

    /*2. Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclIpLengthCheckModeSet(dev, mode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclIpLengthCheckModeSet(dev, mode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
UTF_TEST_CASE_MAC(cpssDxChPclIpLengthCheckModeGet)
{
/*
    ITERATE_DEVICES
    1.1. Call with not NULL modePtr
    Expected: GT_OK
    1.2. Call with NULL modePtr
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                               st = GT_OK;
    GT_U8                                   dev;
    CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_ENT  mode;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_E_ARCH_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*  1.1.  */
        st = cpssDxChPclIpLengthCheckModeGet(dev, &mode);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "dev: %d", dev);

        /*  1.2.  */
        st = cpssDxChPclIpLengthCheckModeGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "dev: %d", dev);
    }

    mode = CPSS_DXCH_PCL_IP_LENGTH_CHECK_MODE_L2_E;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_E_ARCH_CNS);

    /*2. Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclIpLengthCheckModeGet(dev, &mode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclIpLengthCheckModeGet(dev, &mode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclCfgTblEntryGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN  GT_U32                          entryIndex,
    OUT GT_U32                          *pclCfgTblEntryPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclCfgTblEntryGet)
{
/*
    ITERATE_DEVICES
    1.1. Call with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                              CPSS_PCL_DIRECTION_EGRESS_E],
                   lookupNum [CPSS_PCL_LOOKUP_0_E /
                              CPSS_PCL_LOOKUP_1_E],
        entryIndex [0 / tableSize - 1] and non-NULL pclCfgTblEntryPtr.
    Expected: GT_OK
    1.2. Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
                   lookupNum [CPSS_PCL_LOOKUP_1_E],
        entryIndex [tableSize - 1] and non-NULL pclCfgTblEntryPtr.
    Expected: GT_OK for ch2/ch3 (egress not supported in ch1,
                                 ch2/ch3 lookupNum not relevant)
              and not GT_OK for ch1/xCat and above (wrong lookupNum for egress direction)
    1.2. Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], entryIndex [7]
            and non-NULL pclTblEntryPtr.
    Expected: NON GT_OK for DxCh devices (they don't support egress direction)
            and GT_OK for Cheetah2,3.
    1.3. Check for invalid enum value for direction.
    Expected: GT_BAD_PARAM.
        1.4. Check wrong enum values lookupNum.
        Expected: GT_BAD_PARAM for xCat and above.
    1.5. Call with pclCfgTblEntryPtr [NULL] and other parameters as in 1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st = GT_OK;
    GT_U8                             dev;
    CPSS_PCL_DIRECTION_ENT            direction;
    CPSS_PCL_LOOKUP_NUMBER_ENT        lookupNum = CPSS_PCL_RULE_SIZE_STD_E;
    GT_U32                            entryIndex;
    GT_BOOL                           iPcl0Bypass;

    /*!!! will pclCfgTblEntry fit in 4 bytes??? - answer - yes              */
    /*!!! (for now because of stubs we don't know memory size it consumes..)*/
    /*  CPSS_DXCH_TABLE_PCL_CONFIG_E          - 1 word of data  */
    /*  CPSS_DXCH2_TABLE_EGRESS_PCL_CONFIG_E  - 1 word of data  */
    GT_U32                            pclCfgTblEntry[4];
    CPSS_PP_FAMILY_TYPE_ENT           devFamily;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        /* get device family */
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

        /*
            1.1. Call with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                      CPSS_PCL_DIRECTION_EGRESS_E],
                           lookupNum [CPSS_PCL_LOOKUP_0_E /
                                      CPSS_PCL_LOOKUP_1_E],
                entryIndex [0 / tableSize - 1] and non-NULL pclCfgTblEntryPtr.
            Expected: GT_OK
        */
        /* call with direction = CPSS_PCL_DIRECTION_INGRESS_E; */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;

        /* call with lookupNum = CPSS_PCL_LOOKUP_0_E; */
        lookupNum = CPSS_PCL_LOOKUP_0_E;
        entryIndex = 0;

        st = cpssDxChPclCfgTblEntryGet(dev, direction, lookupNum, entryIndex, pclCfgTblEntry);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "dev: %d, %d, %d", dev, direction, entryIndex);

        /* call with lookupNum = CPSS_PCL_LOOKUP_1_E; */
        lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_TRUE)
            entryIndex = 4095;
        else
            entryIndex = PCL_TCAM_RAWS(dev) - 1;

        st = cpssDxChPclCfgTblEntryGet(dev, direction, lookupNum, entryIndex, pclCfgTblEntry);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st, "dev: %d, %d, %d", dev, direction, entryIndex);

        /* call with direction = CPSS_PCL_DIRECTION_EGRESS_E; */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;
        lookupNum = CPSS_PCL_LOOKUP_0_E;
        entryIndex = 0;

        st = cpssDxChPclCfgTblEntryGet(dev, direction, lookupNum, entryIndex, pclCfgTblEntry);
        UTF_VERIFY_EQUAL3_STRING_MAC(
                GT_OK, st, "dev: %d, %d, %d", dev, direction, entryIndex);

        /*
            1.2. Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
                           lookupNum [CPSS_PCL_LOOKUP_1_E],
                entryIndex [tableSize - 1] and non-NULL pclCfgTblEntryPtr.
            Expected: GT_OK for ch2/ch3 (egress not supported in ch1,
                                         ch2/ch3 lookupNum not relevant)
                      and not GT_OK for ch1/xCat and above (wrong lookupNum for egress direction)
        */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;
        lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;
        entryIndex = PCL_TCAM_RAWS(dev) - 1;

        st = cpssDxChPclCfgTblEntryGet(dev, direction, lookupNum, entryIndex, pclCfgTblEntry);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, direction);

        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum = CPSS_PCL_LOOKUP_0_E;
        entryIndex = 0;

        /*
            1.2. Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], entryIndex [7]
                    and non-NULL pclTblEntryPtr.
            Expected: NON GT_OK for DxCh devices (they don't support egress direction)
                    and GT_OK for Cheetah2,3.
        */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;
        entryIndex = 7;

        st = cpssDxChPclCfgTblEntryGet(dev, direction, lookupNum, entryIndex, pclCfgTblEntry);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, entryIndex);

        /*
            1.3. Check for invalid enum value for direction.
            Expected: GT_BAD_PARAM.
        */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum = CPSS_PCL_LOOKUP_0_E;
        entryIndex = 0;

        UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblEntryGet
                            (dev, direction, lookupNum, entryIndex, pclCfgTblEntry),
                            direction);

        if (devFamily >= CPSS_PP_FAMILY_DXCH_XCAT_E)
        {
            /*
                1.4. Check wrong enum values lookupNum.
                Expected: GT_BAD_PARAM for xCat and above.
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            entryIndex = 0;

            UTF_ENUMS_CHECK_MAC(cpssDxChPclCfgTblEntryGet
                                (dev, direction, lookupNum, entryIndex, pclCfgTblEntry),
                                lookupNum);
        }

        /*
            1.5. Call with pclCfgTblEntryPtr [NULL] and other parameters as in 1.1.
            Expected: GT_BAD_PTR.
        */

        st = cpssDxChPclCfgTblEntryGet( dev, direction, lookupNum, entryIndex, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                        "dev: %d, pclCfgTblEntryPtr = NULL", dev);
    }

    /* set correct values for all the parameters (except of device number) */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    entryIndex = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclCfgTblEntryGet(dev, direction, lookupNum,
                                        entryIndex, pclCfgTblEntry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclCfgTblEntryGet(dev, direction, lookupNum,
                                        entryIndex, pclCfgTblEntry);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxCh2PclEgressPolicyEnable
(
    IN GT_U8   devNum,
    IN GT_BOOL enable
)
*/
UTF_TEST_CASE_MAC(cpssDxCh2PclEgressPolicyEnable)
{
/*
    ITERATE_DEVICES
    1.1. Call with enable [GT_TRUE/ GT_FALSE].
    Expected: GT_OK
    1.2. Call cpssDxCh2PclEgressPolicyEnableGet.
    Expected: GT_OK and same enable
*/
    GT_STATUS                   st = GT_OK;
    GT_U8                       dev;
    GT_BOOL                     enable;
    GT_BOOL                     enableGet;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with enable [GT_TRUE/ GT_FALSE].
            Expected: GT_OK
        */
        /* call with enable = GT_TRUE; */
        enable = GT_TRUE;

        st = cpssDxCh2PclEgressPolicyEnable(dev, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /* 1.2. */
        st = cpssDxCh2PclEgressPolicyEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
            "get another mode than was set: %d", dev);


        /* call with enable = GT_FALSE; */
        enable = GT_FALSE;

        st = cpssDxCh2PclEgressPolicyEnable(dev, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /* 1.2. */
        st = cpssDxCh2PclEgressPolicyEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
            "get another mode than was set: %d", dev);
    }

    enable = GT_FALSE;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /*2. Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxCh2PclEgressPolicyEnable(dev, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxCh2PclEgressPolicyEnable(dev, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
UTF_TEST_CASE_MAC(cpssDxCh2PclEgressPolicyEnableGet)
{
/*
    ITERATE_DEVICES
    1.1. Call with not NULL enablePtr.
    Expected: GT_OK
    1.2. Call with NULL enablePtr.
    Expected: GT_OK
*/
    GT_STATUS                   st = GT_OK;
    GT_U8                       dev;
    GT_BOOL                     enable;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*  1.1.  */
        st = cpssDxCh2PclEgressPolicyEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*  1.2.  */
        st = cpssDxCh2PclEgressPolicyEnableGet(dev, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
    }

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /*2. Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxCh2PclEgressPolicyEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxCh2PclEgressPolicyEnableGet(dev, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressForRemoteTunnelStartEnableSet
(
    IN  GT_U8                         devNum,
    IN  GT_BOOL                       enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressForRemoteTunnelStartEnableSet)
{
/*
    ITERATE_DEVICES (DxCh2 and above)
    1.1. Call with  enable [GT_TRUE / GT_FALSE]
    Expected: GT_OK.
    1.2 Call cpssDxChPclEgressForRemoteTunnelStartEnableGet
        with non-NULL enableGet.
    Expected: GT_OK and the same enableGet.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_BOOL     enable    = GT_FALSE;
    GT_BOOL     enableGet = GT_FALSE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with  enable [GT_TRUE / GT_FALSE]
            Expected: GT_OK.
        */
        /* call with enable = GT_TRUE */
        enable = GT_TRUE;

        st = cpssDxChPclEgressForRemoteTunnelStartEnableSet(dev, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /*
            1.2 Call cpssDxChPclEgressForRemoteTunnelStartEnableGet
                with non-NULL enableGet.
            Expected: GT_OK and the same enableGet.
        */
        st = cpssDxChPclEgressForRemoteTunnelStartEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                "cpssDxChPclEgressForRemoteTunnelStartEnableGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                "get another enable than was set: %d", dev);

        /* call with enable = GT_FALSE */
        enable = GT_FALSE;

        st = cpssDxChPclEgressForRemoteTunnelStartEnableSet(dev, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /*
            1.2 Call cpssDxChPclEgressForRemoteTunnelStartEnableGet
                with non-NULL enableGet;
            Expected: GT_OK and the same enableGet.
        */
        st = cpssDxChPclEgressForRemoteTunnelStartEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                "cpssDxChPclEgressForRemoteTunnelStartEnableGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                "get another enable than was set: %d", dev);
    }

    enable = GT_TRUE;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressForRemoteTunnelStartEnableSet(dev, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/

    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressForRemoteTunnelStartEnableSet(dev, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressForRemoteTunnelStartEnableGet
(
    IN  GT_U8                         devNum,
    OUT GT_BOOL                       *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressForRemoteTunnelStartEnableGet)
{
/*
    ITERATE_DEVICES (DxCh2 and above)
    1.1. Call with non-NULL enablePtr
    Expected: GT_OK.
    1.2 Call with enablePtr [NULL];
    Expected: GT_BAD_PTR.
*/

    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_BOOL     enable    = GT_FALSE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with non-NULL enablePtr
            Expected: GT_OK.
        */
        st = cpssDxChPclEgressForRemoteTunnelStartEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2 Call with enablePtr [NULL];
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclEgressForRemoteTunnelStartEnableGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enablePtr = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressForRemoteTunnelStartEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/

    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressForRemoteTunnelStartEnableGet(dev, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxCh3PclTunnelTermForceVlanModeEnableSet
(
    IN  GT_U8                         devNum,
    IN  GT_BOOL                       enable
)
*/
UTF_TEST_CASE_MAC(cpssDxCh3PclTunnelTermForceVlanModeEnableSet)
{
/*
    ITERATE_DEVICES (DxCh3 and above)
    1.1. Call with enable [GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.2. Call cpssDxCh3PclTunnelTermForceVlanModeEnableGet with non-NULL enablePtr.
    Expected: GT_OK and the same enable.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_BOOL     enable    = GT_FALSE;
    GT_BOOL     enableGet = GT_FALSE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with  enable [GT_TRUE / GT_FALSE]
            Expected: GT_OK.
        */
        /* call with enable = GT_TRUE */
        enable = GT_TRUE;

        st = cpssDxCh3PclTunnelTermForceVlanModeEnableSet(dev, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /*
            1.2 Call cpssDxCh3PclTunnelTermForceVlanModeEnableGet with non-NULL enablePtr;
            Expected: GT_OK and the same enable.
        */
        st = cpssDxCh3PclTunnelTermForceVlanModeEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxCh3PclTunnelTermForceVlanModeEnableGet: %d", dev);

        /* Verifying values*/
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                   "get another enable than was set: %d", dev);

        /* call with enable = GT_FALSE */
        enable = GT_FALSE;

        st = cpssDxCh3PclTunnelTermForceVlanModeEnableSet(dev, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /*
            1.2 Call cpssDxCh3PclTunnelTermForceVlanModeEnableGet with non-NULL enablePtr;
            Expected: GT_OK and the same enable.
        */
        st = cpssDxCh3PclTunnelTermForceVlanModeEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxCh3PclTunnelTermForceVlanModeEnableGet: %d", dev);

        /* Verifying values*/
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                   "get another enable than was set: %d", dev);
    }

    enable = GT_TRUE;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxCh3PclTunnelTermForceVlanModeEnableSet(dev, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxCh3PclTunnelTermForceVlanModeEnableSet(dev, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxCh3PclTunnelTermForceVlanModeEnableGet
(
    IN  GT_U8                         devNum,
    OUT GT_BOOL                       *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxCh3PclTunnelTermForceVlanModeEnableGet)
{
/*
    ITERATE_DEVICES (DxCh3 and above)
    1.1. Call with non-NULL enablePtr.
    Expected: GT_OK.
    1.2. Call with enablePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_BOOL     enable = GT_FALSE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with non-NULL enablePtr
            Expected: GT_OK.
        */
        st = cpssDxCh3PclTunnelTermForceVlanModeEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2 Call with enablePtr [NULL];
            Expected: GT_BAD_PTR.
        */
        st = cpssDxCh3PclTunnelTermForceVlanModeEnableGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enablePtr = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxCh3PclTunnelTermForceVlanModeEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/

    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxCh3PclTunnelTermForceVlanModeEnableGet(dev, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxCh2EgressPclPacketTypesSet
(
    IN GT_U8                             devNum,
    IN GT_PORT_NUM                       port,
    IN CPSS_DXCH_PCL_EGRESS_PKT_TYPE_ENT pktType,
    IN GT_BOOL                           enable
)
*/
UTF_TEST_CASE_MAC(cpssDxCh2EgressPclPacketTypesSet)
{
/*
    ITERATE_DEVICES_PHY_CPU_PORTS (dxCh2 and above)
    1.1.1. Call with pktType
                    [CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E/
                    CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E/
                    CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E/
                    CPSS_DXCH_PCL_EGRESS_PKT_DROP_E/] and
                    enable [GT_FALSE / GT_TRUE].
    Expected: GT_OK
    1.1.2. Call cpssDxCh2EgressPclPacketTypesGet
    Expected: GT_OK and same enable.
    1.1.3. Check for invalid enum value for packet type.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS st = GT_OK;

    GT_U8                               dev;
    GT_PORT_NUM                         port;
    CPSS_DXCH_PCL_EGRESS_PKT_TYPE_ENT   pktType;
    GT_BOOL                             enable;
    GT_BOOL                             enableGet;
    GT_U16                              maxMcGroups;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports. */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            st = prvUtfMaxMcGroupsGet(dev, &maxMcGroups);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfMaxMcGroupsGet: %d", dev);

            /*
                1.1.1. Call with pktType
                                [CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E/
                                CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E/
                                CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E/
                                CPSS_DXCH_PCL_EGRESS_PKT_DROP_E] and
                                enable [GT_FALSE / GT_TRUE].
                Expected: GT_OK
            */
            /* call with enable = GT_FALSE; */
            enable = GT_FALSE;

            /* call with pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E; */
            pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E;

            st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, port, pktType, enable);

            /* 1.2. */
            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, pktType);

            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                                    "get another enable than was set: %d", dev);

            /* call with pktType = CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E; */
            pktType = CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E;

            st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, port, pktType, enable);

            /* 1.2. */
            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, pktType);

            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                                    "get another enable than was set: %d", dev);

            /* call with pktType = CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E; */
            pktType = CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E;

            st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, port, pktType, enable);

            /* 1.2. */
            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, pktType);

            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                                    "get another enable than was set: %d", dev);

            /* call with enable = GT_TRUE; */
            enable = GT_TRUE;

            /* call with pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E; */
            pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E;

            st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, port, pktType, enable);

            /* 1.2. */
            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, pktType);

            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                                    "get another enable than was set: %d", dev);

            /* call with pktType = CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E; */
            pktType = CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E;

            st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, port, pktType, enable);

            /* 1.2. */
            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, pktType);

            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                                    "get another enable than was set: %d", dev);

            /* call with pktType = CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E; */
            pktType = CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E;

            st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, port, pktType, enable);

            /* 1.2. */
            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enableGet);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, pktType);

            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                                    "get another enable than was set: %d", dev);

            /* call with pktType = CPSS_DXCH_PCL_EGRESS_PKT_DROP_E; */
            pktType = CPSS_DXCH_PCL_EGRESS_PKT_DROP_E;

            st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
            if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, port, pktType, enable);
            }
            else
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_BAD_PARAM, st, dev, port, pktType, enable);
            }
            /* 1.2. */
            if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enableGet);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, pktType);

                UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                                            "get another enable than was set: %d", dev);
            }
            /*
                1.1.3. Check for invalid enum value for packet type.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxCh2EgressPclPacketTypesSet
                                (dev, port, pktType, enable),
                                pktType);
        }

        /* 1.2. Check that function handles CPU port    */
        port = CPSS_CPU_PORT_NUM_CNS;

        /* 1.2.1. <Check other parameters for each active device id and CPU port>. */

        pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E;
        enable = GT_FALSE;

        st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
            "dev: %d, %d (CPU port), %d, %d", dev, port, pktType, enable);

        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.3. Go over non configured ports */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_FALSE))
        {
            /* 1.3.1. Call function for each non configured port.   */
            /* Expected: GT_BAD_PARAM                               */
            pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E;
            enable = GT_FALSE;

            st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
            if(IS_E_ARCH_AND_PHYSICAL_PORT_IN_RANGE_MAC(dev,port))
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);
            }
            else
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
            }
        }

        /* 1.4. For active device check that function returns GT_BAD_PARAM  */
        /* for out of bound value for port number.                          */
        port = UTF_CPSS_PP_MAX_PORT_NUM_CNS(dev);

        pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E;
        enable = GT_FALSE;

        st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PARAM, st, "dev: %d, %d", dev, port);
    }

    /* 2. Go over not active devices    */
    /* Expected: GT_BAD_PARAM           */
    port = DXCH_PCL_VALID_PHY_PORT_CNS;
    pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E;
    enable = GT_FALSE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id    */
    /* Expected: GT_BAD_PARAM                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxCh2EgressPclPacketTypesSet(dev, port, pktType, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
UTF_TEST_CASE_MAC(cpssDxCh2EgressPclPacketTypesGet)
{
/*
    ITERATE_DEVICES_PHY_CPU_PORTS (dxCh2 and above)
    1.1.1. Call with pktType
                    [CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E/
                    CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E/
                    CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E /
                    CPSS_DXCH_PCL_EGRESS_PKT_DROP_E] and
                    not NULL enablePtr.
    Expected: GT_OK
    1.1.2. Check for invalid enum value for packet type.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS st = GT_OK;

    GT_U8                               dev;
    GT_PORT_NUM                         port;
    CPSS_DXCH_PCL_EGRESS_PKT_TYPE_ENT   pktType;
    GT_BOOL                             enable;

    GT_U16                              maxMcGroups;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports. */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            st = prvUtfMaxMcGroupsGet(dev, &maxMcGroups);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfMaxMcGroupsGet: %d", dev);

            /*  1.1.1.  */
            pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E;

            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, pktType);

            pktType = CPSS_DXCH_PCL_EGRESS_PKT_TO_ANALYZER_E;

            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, pktType);

            pktType = CPSS_DXCH_PCL_EGRESS_PKT_NON_TS_E;

            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enable);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, pktType);

            pktType = CPSS_DXCH_PCL_EGRESS_PKT_DROP_E;

            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enable);
            if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, port, pktType);
            }
            else
            {
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_BAD_PARAM, st, dev, port, pktType);
            }
            /*  1.1.2.  */
            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, NULL);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_BAD_PTR, st, dev, port, pktType);
        }

        /* 1.2. Check that function handles CPU port    */
        port = CPSS_CPU_PORT_NUM_CNS;

        /* 1.2.1. <Check other parameters for each active device id and CPU port>. */

        pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E;
        enable = GT_FALSE;

        st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enable);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
            "dev: %d, %d (CPU port), %d, %d", dev, port, pktType, enable);

        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.3. Go over non configured ports */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_FALSE))
        {
            /* 1.3.1. Call function for each non configured port.   */
            /* Expected: GT_BAD_PARAM                               */
            pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E;
            enable = GT_FALSE;

            st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
        }

        /* 1.4. For active device check that function returns GT_BAD_PARAM  */
        /* for out of bound value for port number.                          */
        port = UTF_CPSS_PP_MAX_PORT_NUM_CNS(dev);

        pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E;
        enable = GT_FALSE;

        st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enable);
        UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PARAM, st, "dev: %d, %d", dev, port);
    }

    /* 2. Go over not active devices    */
    /* Expected: GT_BAD_PARAM           */
    port = DXCH_PCL_VALID_PHY_PORT_CNS;
    pktType = CPSS_DXCH_PCL_EGRESS_PKT_FROM_CPU_CONTROL_E;
    enable = GT_FALSE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id    */
    /* Expected: GT_BAD_PARAM                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxCh2EgressPclPacketTypesGet(dev, port, pktType, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxCh2PclTcpUdpPortComparatorSet
(
    IN GT_U8                             devNum,
    IN CPSS_PCL_DIRECTION_ENT            direction,
    IN CPSS_L4_PROTOCOL_ENT              l4Protocol,
    IN GT_U8                             entryIndex,
    IN CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortType,
    IN CPSS_COMPARE_OPERATOR_ENT         compareOperator,
    IN GT_U16                            value
)
*/
UTF_TEST_CASE_MAC(cpssDxCh2PclTcpUdpPortComparatorSet)
{
/*
    ITERATE_DEVICES
    1.1. Call with direction [CPSS_PCL_DIRECTION_INGRESS_E],
            l4Protocol [CPSS_L4_PROTOCOL_TCP_E], entryIndex [0],
            l4PortType [CPSS_L4_PROTOCOL_PORT_SRC_E],
            compareOperator [CPSS_COMPARE_OPERATOR_LTE], value [25].
    Expected: GT_OK
    1.2. Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
            l4Protocol [CPSS_L4_PROTOCOL_UDP_E], entryIndex [7],
            l4PortType [CPSS_L4_PROTOCOL_PORT_DST_E],
            compareOperator [CPSS_COMPARE_OPERATOR_NEQ], value [25].
    Expected: GT_OK
    1.3. Call cpssDxCh2PclTcpUdpPortComparatorGet
    Expected: GT_OK and same l4PortType, compareOperator, value
    1.4. Check for invalid enum value for direction.
    Expected: GT_BAD_PARAM.
    1.5. Check for invalid enum value for l4Protocol.
    Expected: GT_BAD_PARAM.
    1.6. Check for out of range entryIndex. Call
    function with entryIndex [8] and other parameters as in 1.2.
    Expected: NON GT_OK.
    1.7. Check for invalid enum value for l4Port.
    Expected: GT_BAD_PARAM.
    1.8. Check for invalid enum value for compareOperator.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                         st = GT_OK;
    GT_U8                             dev;
    CPSS_PCL_DIRECTION_ENT            direction;
    CPSS_L4_PROTOCOL_ENT              l4Protocol;
    GT_U8                             entryIndex;
    CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortType;
    CPSS_COMPARE_OPERATOR_ENT         compareOperator;
    GT_U16                            value;
    CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortTypeGet;
    CPSS_COMPARE_OPERATOR_ENT         compareOperatorGet;
    GT_U16                            valueGet;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with direction [CPSS_PCL_DIRECTION_INGRESS_E],
                    l4Protocol [CPSS_L4_PROTOCOL_TCP_E], entryIndex [0],
                    l4PortType [CPSS_L4_PROTOCOL_PORT_SRC_E],
                    compareOperator [CPSS_COMPARE_OPERATOR_LTE], value [25].
            Expected: GT_OK
        */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        l4Protocol = CPSS_L4_PROTOCOL_TCP_E;
        entryIndex = 0;
        l4PortType = CPSS_L4_PROTOCOL_PORT_SRC_E;
        compareOperator = CPSS_COMPARE_OPERATOR_LTE;
        value = 25;

        st = cpssDxCh2PclTcpUdpPortComparatorSet(dev, direction, l4Protocol,
                            entryIndex, l4PortType, compareOperator, value);

        UTF_VERIFY_EQUAL7_STRING_MAC(GT_OK, st, "dev: %d, %d, %d, %d, %d, %d, %d",
                        dev, direction, l4Protocol, entryIndex, l4PortType,
                        compareOperator, value);

        /*  1.3.  */
        st = cpssDxCh2PclTcpUdpPortComparatorGet(dev, direction, l4Protocol,
                            entryIndex, &l4PortTypeGet, &compareOperatorGet, &valueGet);

        UTF_VERIFY_EQUAL7_STRING_MAC(GT_OK, st, "dev: %d, %d, %d, %d, %d, %d, %d",
                        dev, direction, l4Protocol, entryIndex, l4PortType,
                        compareOperator, value);

        UTF_VERIFY_EQUAL1_STRING_MAC(l4PortType, l4PortTypeGet,
                                "get another l4PortType than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(compareOperator, compareOperatorGet,
                                "get another compareOperator than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(value, valueGet,
                                "get another value than was set: %d", dev);

        /*
            1.2. Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
                    l4Protocol [CPSS_L4_PROTOCOL_UDP_E], entryIndex [7],
                    l4PortType [CPSS_L4_PROTOCOL_PORT_DST_E],
                    compareOperator [CPSS_COMPARE_OPERATOR_NEQ], value [25].
            Expected: GT_OK
        */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;
        l4Protocol = CPSS_L4_PROTOCOL_UDP_E;
        entryIndex = 7;
        l4PortType = CPSS_L4_PROTOCOL_PORT_DST_E;
        compareOperator = CPSS_COMPARE_OPERATOR_NEQ;

        st = cpssDxCh2PclTcpUdpPortComparatorSet(dev, direction, l4Protocol,
                            entryIndex, l4PortType, compareOperator, value);

        UTF_VERIFY_EQUAL7_STRING_MAC(GT_OK, st, "dev: %d, %d, %d, %d, %d, %d, %d",
                        dev, direction, l4Protocol, entryIndex, l4PortType,
                        compareOperator, value);

        /*  1.3.  */
        st = cpssDxCh2PclTcpUdpPortComparatorGet(dev, direction, l4Protocol,
                            entryIndex, &l4PortTypeGet, &compareOperatorGet, &valueGet);

        UTF_VERIFY_EQUAL7_STRING_MAC(GT_OK, st, "dev: %d, %d, %d, %d, %d, %d, %d",
                        dev, direction, l4Protocol, entryIndex, l4PortType,
                        compareOperator, value);

        UTF_VERIFY_EQUAL1_STRING_MAC(l4PortType, l4PortTypeGet,
                                "get another l4PortType than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(compareOperator, compareOperatorGet,
                                "get another compareOperator than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(value, valueGet,
                                "get another value than was set: %d", dev);

        /*
            1.4. Check for invalid enum value for direction.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxCh2PclTcpUdpPortComparatorSet
                            (dev, direction, l4Protocol, entryIndex,
                             l4PortType, compareOperator, value),
                            direction);

        /*
            1.5. Check for invalid enum value for l4Protocol.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxCh2PclTcpUdpPortComparatorSet
                            (dev, direction, l4Protocol, entryIndex,
                             l4PortType, compareOperator, value),
                            l4Protocol);

        /*
            1.6. Check for out of range entryIndex. Call
            function with entryIndex [8] and other parameters as in 1.2.
            Expected: NON GT_OK.
        */
        entryIndex = PRV_CPSS_SIP_6_10_CHECK_MAC(dev) ? 64 : 8;

        st = cpssDxCh2PclTcpUdpPortComparatorSet(dev, direction, l4Protocol,
                            entryIndex, l4PortType, compareOperator, value);
        UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
                        "dev: %d, entryIndex = %d", dev, entryIndex);

        entryIndex = 7;

        /*
            1.7. Check for invalid enum value for l4Port.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxCh2PclTcpUdpPortComparatorSet
                            (dev, direction, l4Protocol, entryIndex,
                             l4PortType, compareOperator, value),
                            l4PortType);

        /*
            1.8. Check for invalid enum value for compareOperator.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxCh2PclTcpUdpPortComparatorSet
                            (dev, direction, l4Protocol, entryIndex,
                             l4PortType, compareOperator, value),
                            compareOperator);
    }

    /* set correct values for all the parameters (except of device number) */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    l4Protocol = CPSS_L4_PROTOCOL_TCP_E;
    entryIndex = 0;
    l4PortType = CPSS_L4_PROTOCOL_PORT_SRC_E;
    compareOperator = CPSS_COMPARE_OPERATOR_LTE;
    value = 25;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxCh2PclTcpUdpPortComparatorSet(dev, direction, l4Protocol,
                            entryIndex, l4PortType, compareOperator, value);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxCh2PclTcpUdpPortComparatorSet(dev, direction, l4Protocol,
                        entryIndex, l4PortType, compareOperator, value);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
UTF_TEST_CASE_MAC(cpssDxCh2PclTcpUdpPortComparatorGet)
{
/*
    ITERATE_DEVICES
    1.1. Call with direction  [CPSS_PCL_DIRECTION_INGRESS_E/
                               CPSS_PCL_DIRECTION_EGRESS_E],
                   l4Protocol [CPSS_L4_PROTOCOL_TCP_E/
                               CPSS_L4_PROTOCOL_UDP_E],
                               entryIndex [0/7],
            and not NULL l4PortTypePtr, compareOperatorPtr, valuePtr.
    Expected: GT_OK
    1.2. Check for invalid enum value for direction.
    Expected: GT_BAD_PARAM.
    1.3. Check for invalid enum value for l4Protocol.
    Expected: GT_BAD_PARAM.
    1.4. Check for out of range entryIndex. Call
    function with entryIndex [8] and other parameters as in 1.1.
    Expected: NON GT_OK.
    1.5. Call with NULL l4PortTypePtr
    Expected: GT_BAD_PTR.
    1.6. Call with NULL compareOperatorPtr
    Expected: GT_BAD_PTR.
    1.7. Call with NULL valuePtr
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st = GT_OK;
    GT_U8                             dev;
    CPSS_PCL_DIRECTION_ENT            direction;
    CPSS_L4_PROTOCOL_ENT              l4Protocol;
    GT_U8                             entryIndex;
    CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortType;
    CPSS_COMPARE_OPERATOR_ENT         compareOperator;
    GT_U16                            value;


    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*  1.1.  */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        l4Protocol = CPSS_L4_PROTOCOL_TCP_E;
        entryIndex = 0;

        st = cpssDxCh2PclTcpUdpPortComparatorGet(dev, direction, l4Protocol,
                            entryIndex, &l4PortType, &compareOperator, &value);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "dev: %d, %d, %d, %d",
                        dev, direction, l4Protocol, entryIndex);

        /*  1.1.  */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;
        l4Protocol = CPSS_L4_PROTOCOL_UDP_E;
        entryIndex = 7;

        st = cpssDxCh2PclTcpUdpPortComparatorGet(dev, direction, l4Protocol,
                            entryIndex, &l4PortType, &compareOperator, &value);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "dev: %d, %d, %d, %d",
                        dev, direction, l4Protocol, entryIndex);

        /*  1.2. */
        UTF_ENUMS_CHECK_MAC(cpssDxCh2PclTcpUdpPortComparatorGet
                            (dev, direction, l4Protocol, entryIndex,
                             &l4PortType, &compareOperator, &value),
                            direction);

        /*  1.3. */
        UTF_ENUMS_CHECK_MAC(cpssDxCh2PclTcpUdpPortComparatorGet
                            (dev, direction, l4Protocol, entryIndex,
                             &l4PortType, &compareOperator, &value),
                             l4Protocol);

        /*  1.4. */
        entryIndex = PRV_CPSS_SIP_6_10_CHECK_MAC(dev) ? 64 : 8;

        st = cpssDxCh2PclTcpUdpPortComparatorGet(dev, direction, l4Protocol,
                            entryIndex, &l4PortType, &compareOperator, &value);
        UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
                        "dev: %d, entryIndex = %d", dev, entryIndex);

        entryIndex = 0;

        /*  1.5.  */
        st = cpssDxCh2PclTcpUdpPortComparatorGet(dev, direction, l4Protocol,
                            entryIndex, NULL, &compareOperator, &value);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_BAD_PTR, st, "dev: %d, %d, %d, %d",
                        dev, direction, l4Protocol, entryIndex);

        /*  1.6.  */
        st = cpssDxCh2PclTcpUdpPortComparatorGet(dev, direction, l4Protocol,
                            entryIndex, &l4PortType, NULL, &value);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_BAD_PTR, st, "dev: %d, %d, %d, %d",
                        dev, direction, l4Protocol, entryIndex);

        /*  1.7.  */
        st = cpssDxCh2PclTcpUdpPortComparatorGet(dev, direction, l4Protocol,
                            entryIndex, &l4PortType, &compareOperator, NULL);
        UTF_VERIFY_EQUAL4_STRING_MAC(GT_BAD_PTR, st, "dev: %d, %d, %d, %d",
                        dev, direction, l4Protocol, entryIndex);
    }

    /* set correct values for all the parameters (except of device number) */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    l4Protocol = CPSS_L4_PROTOCOL_TCP_E;
    entryIndex = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxCh2PclTcpUdpPortComparatorGet(dev, direction, l4Protocol,
                            entryIndex, &l4PortType, &compareOperator, &value);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxCh2PclTcpUdpPortComparatorGet(dev, direction, l4Protocol,
                        entryIndex, &l4PortType, &compareOperator, &value);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet
(
    IN  GT_U8                                            devNum,
    OUT CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT   *cfgTabAccModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet)
{
/*
    ITERATE_DEVICES (dxCh3 and above)
    1.1. Call with non-NULL cfgTabAccModePtr
    Expected: GT_OK.
    1.2 Call with cfgTabAccModePtr [NULL];
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT   cfgTabAccModePtr;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with non-NULL cfgTabAccModePtr
            Expected: GT_OK.
        */
        st = cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet(dev, &cfgTabAccModePtr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2 Call with cfgTabAccModePtr [NULL];
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, cfgTabAccModePtr = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet(dev, &cfgTabAccModePtr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/

    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet(dev, &cfgTabAccModePtr);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet
(
    IN  GT_U8                                            devNum,
    IN  CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT   cfgTabAccMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet)
{
/*
    ITERATE_DEVICES
    1.1. Call with cfgTabAccMode [CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E/
                                  CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E]
    Expected: GT_OK.
    1.2. For Bobcat2; Caelum; Bobcat3 call with cfgTabAccMode [CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E].
    Expected: NOT GT_OK.
    1.3. Call with wrong enum values cfgTabAccMode.
    Expected: GT_BAD_PARAM.
    1.4. Call cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet
         with non-NULL cfgTabAccMode.
    Expected: GT_OK and the same cfgTabAccMode.
*/
    GT_STATUS                                       st              = GT_OK;
    GT_U8                                           dev;
    CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT  cfgTabAccMode;
    CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT  cfgTabAccModeGet;
    CPSS_PP_FAMILY_TYPE_ENT                         devFamily;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with cfgTabAccMode [CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E/
                                          CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E]
            Expected: GT_OK.
        */

        /* call with cfgTabAccMode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E */
        cfgTabAccMode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E;

        st = cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet(dev, cfgTabAccMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, cfgTabAccMode);

        /* call with cfgTabAccMode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E */
        cfgTabAccMode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E;

        st = cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet(dev, cfgTabAccMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, cfgTabAccMode);

        /*
            1.2. For Bobcat2; Caelum; Bobcat3 call with cfgTabAccMode[CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E].
            Expected: GT_OK.
        */

        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);


        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            cfgTabAccMode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_EPORT_E;

            st = cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet(dev, cfgTabAccMode);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, cfgTabAccMode);
        }

        /*
            1.3. Call with wrong enum values cfgTabAccMode.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet
                            (dev, cfgTabAccMode),
                            cfgTabAccMode);

        /*
            1.4. Call cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet
            with non-NULL cfgTabAccMode;
            Expected: GT_OK and the same cfgTabAccMode.
        */
        cfgTabAccMode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_VLAN_E;

        st = cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet(dev, &cfgTabAccModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxCh3PclTunnelTermForceVlanModecfgTabAccModeGet: %d", dev);

        /* Verifying values*/
        UTF_VERIFY_EQUAL1_STRING_MAC(cfgTabAccMode, cfgTabAccModeGet,
                   "get another cfgTabAccMode than was set: %d", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    cfgTabAccMode = CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_BY_PORT_E;

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet(dev, cfgTabAccMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet(dev, cfgTabAccMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclUserDefinedByteGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_DIRECTION_ENT               direction,
    IN  GT_U32                               udbIndex,
    OUT CPSS_DXCH_PCL_OFFSET_TYPE_ENT        *offsetTypePtr,
    OUT GT_U8                                *offsetPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclUserDefinedByteGet)
{
/*
    ITERATE_DEVICES
    1.1. Call with ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
         packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E, udbIndex [0].
    Expected: GT_OK.
    1.2. Call with wrong enum values ruleFormat.
    Expected: GT_BAD_PARAM.

    1.3. Call with out of range enum value packetType and
        direction[CPSS_PCL_DIRECTION_INGRESS_E].
    Expected: GT_BAD_PARAM.
    1.4. Call with out of range enum value packetType and
        direction[CPSS_PCL_DIRECTION_EGRESS_E].
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3 and GT_BAD_PARAM for others.
    1.5. Call with out of range enum value direction.
    Expected: GT_BAD_PARAM.



    1.6. Call with offsetType = NULL (null pointer).
    Expected: GT_BAD_PTR.
    1.7. Call with offset     = NULL (null pointer).
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                            st = GT_OK;
    GT_U8                                dev;

    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat;
    CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType;
    CPSS_PCL_DIRECTION_ENT               direction;
    GT_U32                               udbIndex;
    CPSS_DXCH_PCL_OFFSET_TYPE_ENT        offsetTypeGet;
    GT_U8                                offsetGet;

    CPSS_PP_FAMILY_TYPE_ENT              devFamily;
    CPSS_PP_DEVICE_TYPE                  devType;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

        st = prvUtfDeviceTypeGet(dev, &devType);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceTypeGet: %d", dev);

        /*
            1.1. Call with ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
                 packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E, udbIndex [0].
            Expected: GT_OK.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;
        udbIndex   = 0;

        st = cpssDxChPclUserDefinedByteGet(
            dev, ruleFormat,
            CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E,
            CPSS_PCL_DIRECTION_INGRESS_E,
            udbIndex, &offsetTypeGet, &offsetGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call with wrong enum values ruleFormat.
            Expected: GT_BAD_PARAM.
        */

        if (! PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclUserDefinedByteGet
                                (dev, ruleFormat, packetType,
                                 CPSS_PCL_DIRECTION_INGRESS_E,
                                 udbIndex, &offsetTypeGet, &offsetGet),
                                ruleFormat);
        }
        else
        {
            for(enumsIndex = 0; enumsIndex < utfInvalidEnumArrSize; enumsIndex++)
            {
                ruleFormat = utfInvalidEnumArr[enumsIndex];

                st = cpssDxChPclUserDefinedByteGet(
                    dev, ruleFormat, packetType, CPSS_PCL_DIRECTION_INGRESS_E,
                    udbIndex, &offsetTypeGet, &offsetGet);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, ruleFormat, udbIndex,
                                            offsetTypeGet, offsetGet);
            }
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        }


        /*
            1.3. Call with out of range enum value packetType and
                direction[CPSS_PCL_DIRECTION_INGRESS_E].
            Expected: GT_BAD_PARAM for xCat and above, GT_OK for others.
        */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        udbIndex   = 0;
        packetType = 0x5AAAAAA5;

        st = cpssDxChPclUserDefinedByteGet(dev, ruleFormat, packetType, direction,
                                           udbIndex, &offsetTypeGet, &offsetGet);

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {

            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }
        else
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }

        /* restore prvious value */
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;

        /*
            1.4. Call with out of range enum value packetType and
                direction[CPSS_PCL_DIRECTION_EGRESS_E].
            Expected: GT_OK for Bobcat2; Caelum; Bobcat3, GT_BAD_PARAM for xCat and above, GT_OK for others.
        */
        direction  = CPSS_PCL_DIRECTION_EGRESS_E;
        packetType = 0x5AAAAAA5;

        st = cpssDxChPclUserDefinedByteGet(dev, ruleFormat, packetType, direction,
                                           udbIndex, &offsetTypeGet, &offsetGet);

        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
        {

            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }
        else
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }

        /* restore prvious value */
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;

        /*
            1.5. Call with out of range enum value direction.
            Expected: GT_BAD_PARAM  for Bobcat2; Caelum; Bobcat3, GT_OK for others.
        */
        direction  = 0x5AAAAAA5;

        st = cpssDxChPclUserDefinedByteGet(dev, ruleFormat, packetType, direction,
                                           udbIndex, &offsetTypeGet, &offsetGet);

        if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }
        else
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }

        /* restore prvious value */
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;

        /*
            1.6. Call with offsetType = NULL (null pointer).
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclUserDefinedByteGet(
            dev, ruleFormat,
            CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E,
            CPSS_PCL_DIRECTION_INGRESS_E,
            udbIndex, NULL, &offsetGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

        /*
            1.7. Call with offset = NULL (null pointer).
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclUserDefinedByteGet(
            dev, ruleFormat,
            CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E,
            CPSS_PCL_DIRECTION_INGRESS_E,
            udbIndex, &offsetTypeGet, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    udbIndex   = 0;
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* go over all non active devices */

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclUserDefinedByteGet(
            dev, ruleFormat,
            CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E,
            CPSS_PCL_DIRECTION_INGRESS_E,
            udbIndex, &offsetTypeGet, &offsetGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st  = cpssDxChPclUserDefinedByteGet(
        dev, ruleFormat,
        CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E,
        CPSS_PCL_DIRECTION_INGRESS_E,
        udbIndex, &offsetTypeGet, &offsetGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclInit
(
    IN  GT_U8                            devNum,
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclInit)
{
/*
    ITERATE_DEVICES
    1.1. Call cpssDxChPclInit with correct dev.
    Expected: GT_OK.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call cpssDxChPclInit with correct dev.
            Expected: GT_OK.
        */
        st = cpssDxChPclInit(dev);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclInit(dev);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclInit(dev);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupCfgTblEntryGet
(
    IN  GT_U8                           devNum,
    IN  GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN  GT_U32                          entryIndex,
    OUT GT_U32                          *pclCfgTblEntryPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupCfgTblEntryGet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(dxChx)
    1.1. Call with portGroupsBmp[CPSS_PORT_GROUP_UNAWARE_MODE_CNS],
        direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_0_E],
        entryIndex [0] and non-NULL pclCfgTblEntryPtr.
    Expected: GT_OK.
    1.2. Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
        lookupNum [CPSS_PCL_LOOKUP_0_E], entryIndex [7] and non-NULL pclTblEntryPtr.
    Expected: GT_OK for all except cheetah1 (not support egress direction).
    1.3. Call with portGroupsBmp[CPSS_PORT_GROUP_UNAWARE_MODE_CNS],
        direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_1_E],
        entryIndex [3] and non-NULL pclCfgTblEntryPtr.
    Expected: GT_OK.
    1.4. Call with portGroupsBmp[CPSS_PORT_GROUP_UNAWARE_MODE_CNS],
        direction [CPSS_PCL_DIRECTION_EGRESS_E], lookupNum [CPSS_PCL_LOOKUP_1_E],
        entryIndex [10] and non-NULL pclCfgTblEntryPtr.
    Expected: GT_OK for ch1, ch2, ch3 (lookupNum not relevant)
    and NOT GT_OK for xCat and above.
    1.5. Check for invalid enum value for direction.
    Expected: GT_BAD_PARAM.
    1.6. Check for invalid enum value for lookupNum.
    Expected: GT_BAD_PARAM.
    1.7. Check NULL pointer processing. Call with pclCfgTblEntryPtr [NULL]
        and other parameters as in 1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st = GT_OK;
    GT_U8                             dev;
    GT_PORT_GROUPS_BMP                portGroupsBmp = 1;
    CPSS_PCL_DIRECTION_ENT            direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_PCL_LOOKUP_NUMBER_ENT        lookupNum = CPSS_PCL_LOOKUP_0_E;
    GT_U32                            entryIndex = 0;
    GT_U32                            pclCfgTblEntry[4];
    GT_BOOL                           iPcl0Bypass;

    CPSS_PP_FAMILY_TYPE_ENT           devFamily;

    GT_U32    portGroupId;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        /* get device family */
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);
            /*
                1.1. Call with portGroupsBmp,
                    direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_0_E],
                    entryIndex [0] and non-NULL pclCfgTblEntryPtr.
                Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            entryIndex = 0;

            st = cpssDxChPclPortGroupCfgTblEntryGet(dev, portGroupsBmp, direction,
                                                lookupNum, entryIndex, pclCfgTblEntry);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "Dev, direction, entryIndex: %d, %d, %d", dev, direction, entryIndex);

            /*
                1.2. Call with portGroupsBmp[CPSS_PORT_GROUP_UNAWARE_MODE_CNS],
                    direction [CPSS_PCL_DIRECTION_EGRESS_E], lookupNum [CPSS_PCL_LOOKUP_0_E],
                    entryIndex [7] and non-NULL pclCfgTblEntryPtr.
                Expected: GT_OK for all except cheetah1 (not support egress direction).
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            entryIndex = 7;

            st = cpssDxChPclPortGroupCfgTblEntryGet(dev, portGroupsBmp, direction,
                                                lookupNum, entryIndex, pclCfgTblEntry);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "dev, direction, entryIndex: %d, %d, %d", dev, direction, entryIndex);

            /*
                1.3. Call with portGroupsBmp[CPSS_PORT_GROUP_UNAWARE_MODE_CNS],
                    direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_1_E],
                    entryIndex [3] and non-NULL pclCfgTblEntryPtr.
                Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;
            entryIndex = 3;

            st = cpssDxChPclPortGroupCfgTblEntryGet(dev, portGroupsBmp, direction,
                                                lookupNum, entryIndex, pclCfgTblEntry);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "dev, direction, entryIndex: %d, %d, %d", dev, direction, entryIndex);

            /*
                1.4. Call with portGroupsBmp[CPSS_PORT_GROUP_UNAWARE_MODE_CNS],
                    direction [CPSS_PCL_DIRECTION_EGRESS_E], lookupNum [CPSS_PCL_LOOKUP_1_E],
                    entryIndex [10] and non-NULL pclCfgTblEntryPtr.
                Expected: GT_OK for ch1, ch2, ch3 (lookupNum not relevant)
                and NOT GT_OK for xCat and above.
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;
            entryIndex = 10;

            st = cpssDxChPclPortGroupCfgTblEntryGet(dev, portGroupsBmp, direction,
                                                lookupNum, entryIndex, pclCfgTblEntry);
            UTF_VERIFY_NOT_EQUAL3_STRING_MAC(GT_OK, st,
                    "dev, direction, entryIndex: %d, %d, %d", dev, direction, entryIndex);

            lookupNum = CPSS_PCL_LOOKUP_0_E;

            /*
                1.5. Check for invalid enum value for direction.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupCfgTblEntryGet
                                (dev, portGroupsBmp, direction, lookupNum,
                                 entryIndex, pclCfgTblEntry),
                                direction);

            /*
                1.6. Check wrong enum values lookupNum.
                Expected: GT_BAD_PARAM for xCat and above (not relevant for other).
            */
            if (devFamily >= CPSS_PP_FAMILY_DXCH_XCAT_E)
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupCfgTblEntryGet
                                (dev, portGroupsBmp, direction, lookupNum,
                                 entryIndex, pclCfgTblEntry),
                                 lookupNum);
            }

            /*
                1.6. Check wrong pclCfgTblEntryPtr[NULL].
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupCfgTblEntryGet(dev, portGroupsBmp, direction,
                                                lookupNum, entryIndex, NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                    "device: %d, pclCfgTblEntryPtr = NULL", dev);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupCfgTblEntryGet(dev, portGroupsBmp, direction,
                                                lookupNum, entryIndex, pclCfgTblEntry);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupCfgTblEntryGet(dev, portGroupsBmp, direction,
                                                lookupNum, entryIndex, pclCfgTblEntry);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* set correct values for all the parameters (except of device number) */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    entryIndex = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. Call function for non active device and valid parameters. */
        /* Expected: GT_BAD_PARAM.                                        */
        st = cpssDxChPclPortGroupCfgTblEntryGet(dev, portGroupsBmp, direction,
                                            lookupNum, entryIndex, pclCfgTblEntry);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupCfgTblEntryGet(dev, portGroupsBmp, direction,
                                        lookupNum, entryIndex, pclCfgTblEntry);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupCfgTblSet
(
    IN GT_U8                           devNum,
    IN GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN CPSS_INTERFACE_INFO_STC         *interfaceInfoPtr,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupCfgTblSet)
{
/*
I - INTERFACE_TYPE - Port (interfaceInfoPtr->type= CPSS_INTERFACE_PORT_E)

    ITERATE_DEVICES_PORT_GROUPS(dxChx)
    1.1. Check Ingress direction. For all devices call with
    portGroupsBmp [CPSS_PORT_GROUP_UNAWARE_MODE_CNS],
    interfaceInfoPtr [type = CPSS_INTERFACE_PORT_E, devPort {devNum=0, portNum=0} ],
    direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_0_E], lookupCfgPtr
    [enableLookup = GT_TRUE, groupKeyTypes.ipv4Key =
    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E , pclId = 1023, groupKeyTypes.ipv6Key
    = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E, other fields zeroed } ].
    Expected: GT_OK.

    1.2. Call cpssDxChPclPortGroupCfgTblGet with interfaceInfoPtr,
    direction, lookupNum - same as in 1.1, non-NULL lookupCfgPtr.
    Expected: GT_OK and same lookupCfgPtr as was written.

    1.3. Check Egress direction (not supported by Cheetah1).
    Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.1.
    Expected: GT_OK for all devices except Cheetah.

    1.4. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E], other params same as in 1.1.
    Expected: GT_OK.

II - INTERFACE_TYPE - VLan (interfaceInfoPtr->type= CPSS_INTERFACE_VID_E)

    1.5. Check Ingress direction. For all devices call with interfaceInfoPtr [type =
    CPSS_INTERFACE_VID_E, vlanId = [100  / (PRV_CPSS_MAX_NUM_VLANS_CNS - 1) = 4095]],
    direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_0_E],
    lookupCfgPtr [enableLookup = GT_TRUE, pclId = 1023, groupKeyTypes.ipv4Key =
    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E, groupKeyTypes.ipv6Key =
    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E, other fields zeroed } ].
    Expected: GT_OK for all devices except ch1.

    1.6. Call cpssDxChPclPortGroupCfgTblGet with interfaceInfoPtr,
    direction, lookupNum - same as in 1.5, non-NULL lookupCfgPtr.
    Expected: GT_OK and same lookupCfgPtr as was written.

    1.7. Check Egress direction (not supported by Cheetah1).
    call with direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.5.
    Expected: GT_OK for all devices except Cheetah.

    1.8. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
    other params same as in 1.5.
    Expected: GT_OK.

    1.9. Check wrong direction enum values. Other params same as in 1.5.
    Expected: GT_BAD_PARAM.

    1.10. Check wrong lookupNum enum values.  Other params same as in 1.5.
    Expected: GT_BAD_PARAM.

    1.11. Check for NULL pointer support. Call with
    lookupCfgPtr [NULL], other params same as in 1.5.
    Expected: GT_BAD_PTR.

    1.12. Check for NULL pointer support. Call with
    interfaceInfoPtr [NULL], other params same as in 1.5.
    Expected: GT_BAD_PTR.

    1.13. Check out-of-range vlan id. Call with interfaceInfoPtr [type =
    CPSS_INTERFACE_VID_E, vlanId [PRV_CPSS_MAX_NUM_VLANS_CNS = 4096] ],
    other params same as in 1.5.
    Expected: non GT_OK.

III - INTERFACE_TYPE - TRUNK (interfaceInfoPtr->type= CPSS_INTERFACE_TRUNK_E)

    1.14. Check trunk interface with valid params. For all devices call with
    interfaceInfoPtr [type = CPSS_INTERFACE_TRUNK_E, trunkId = 0 ], direction
    [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_0_E], lookupCfgPtr
    [enableLookup = GT_TRUE, pclId = 1023, groupKeyTypes {nonIpKey =
    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E, ipv4Key =
    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E, ipv6Key =
    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E } ].
    Expected: NOT GT_OK.

    1.15. Check out-of-range trunk id. Call with interfaceInfoPtr
    [type = CPSS_INTERFACE_TRUNK_E, trunkId [UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev) = 128] ],
    other params same as in 1.14.
    Expected: non GT_OK.

IV - INTERFACE_TYPE - Vidx (unsupported) (interfaceInfoPtr->type= CPSS_INTERFACE_VIDX_E)

    1.16. Check Vidx interface (unsupported) with valid params.
    Call with interfaceInfoPtr [type = CPSS_INTERFACE_VIDX_E, vidx = 0 ], other
    params same as in 1.1.
    Expected: non GT_OK.

V - INTERFACE_TYPE - out-of-range

    1.17. Check out-of-range interface type enum. Call with
    interfaceInfoPtr [type = wrong enum values, devPort {devNum=0, portNum=0}, trunkId =
    0, vidx = 0, vlanId = 100 ], other params same as in 1.1.
    Expected: GT_BAD_PARAM.

VI - additional checks

    1.18. Check Ingress direction. For all devices call with
    portGroupsBmp [CPSS_PORT_GROUP_UNAWARE_MODE_CNS],
    interfaceInfoPtr [type = CPSS_INTERFACE_PORT_E, devPort {devNum=0, portNum=0} ],
    direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_1_E], lookupCfgPtr
    [enableLookup = GT_TRUE, groupKeyTypes.ipv4Key =
    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E, pclId = 1023, groupKeyTypes.ipv6Key
    = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E, other fields zeroed } ].
    Expected: GT_OK for ch1 and not GT_OK for other (not supported STD IPV6 DIP).

    1.19. Check Ingress direction. For all devices call with
    portGroupsBmp [CPSS_PORT_GROUP_UNAWARE_MODE_CNS],
    interfaceInfoPtr [type = CPSS_INTERFACE_PORT_E, devPort {devNum=0, portNum=0} ],
    direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_1_E], lookupCfgPtr
    [enableLookup = GT_TRUE, groupKeyTypes.ipv4Key =
    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E, pclId = 1023, groupKeyTypes.ipv6Key
    = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E, other fields zeroed } ].
    Expected: NOT GT_OK for ch1 (different lookupCfg.groupKeyTypes sizes).
*/
    GT_STATUS                       st = GT_OK;
    GT_U8                           dev;

    GT_PORT_GROUPS_BMP              portGroupsBmp = 1;
    CPSS_INTERFACE_INFO_STC         interfaceInfo;
    CPSS_PCL_DIRECTION_ENT          direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum = CPSS_PCL_LOOKUP_0_E;
    CPSS_DXCH_PCL_LOOKUP_CFG_STC    lookupCfg;
    CPSS_DXCH_PCL_LOOKUP_CFG_STC    lookupCfgRet;

    CPSS_PP_FAMILY_TYPE_ENT         devFamily;
    GT_BOOL                         failureWas;

    GT_U32                          portGroupId;
    /* access mode */
    CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   accMode;
    GT_U32                          maxIndexAbove4K;/* number of indexes above 4K */
    GT_BOOL                         iPcl0Bypass;

    accMode.ipclAccMode     = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E;
    accMode.epclAccMode     = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E;
    accMode.ipclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
    accMode.epclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
    accMode.ipclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
    accMode.epclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;


    cpssOsBzero((GT_VOID*) &interfaceInfo, sizeof(interfaceInfo));
    cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));
    cpssOsBzero((GT_VOID*) &lookupCfgRet, sizeof(lookupCfgRet));

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        if (! PRV_CPSS_SIP_6_CHECK_MAC(dev))
        {
            /* for SIP6 devices hard-wired local-port-access */
            st = cpssDxChPclCfgTblAccessModeSet(
                dev, &accMode);
            UTF_VERIFY_EQUAL1_STRING_MAC(
                GT_OK, st, "cpssDxChPclCfgTblAccessModeSet: %d", dev);
        }

        /* get device family */
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d",
                                     dev);

        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);
            /* I - INTERFACE_TYPE - Port (interfaceInfoPtr->type= CPSS_INTERFACE_PORT_E) */

            /*
               1.1. Check Ingress direction. For all devices call with
               portGroupsBmp [CPSS_PORT_GROUP_UNAWARE_MODE_CNS],
               interfaceInfoPtr [type = CPSS_INTERFACE_PORT_E, devPort {devNum=0,
               portNum=0} ], direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum
               [CPSS_PCL_LOOKUP_0_E], lookupCfgPtr [enableLookup = GT_TRUE,
               pclId = 1023, groupKeyTypes.ipv4Key =
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
               groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
               other fields zeroed } ].
               Expected: GT_OK.
            */
            interfaceInfo.type = CPSS_INTERFACE_PORT_E; /* should be synhronized with 1.2*/
            interfaceInfo.devPort.hwDevNum = dev;
            interfaceInfo.devPort.portNum = 0;
            if (PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(dev) != 0)
            {
                interfaceInfo.devPort.portNum = UTF_GET_PORT_FOR_PORT_GROUP_MAC(portGroupId);
            }

            direction=CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum=CPSS_PCL_LOOKUP_0_E;

            cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));

            lookupCfg.enableLookup = GT_TRUE;
            lookupCfg.pclId = 1023;
            lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
            lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

            if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {
                lookupCfg.dualLookup = GT_TRUE;
                lookupCfg.pclIdL01 = 1023;
            }

            if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
            {
                lookupCfg.exactMatchLookupSubProfileId=7;
            }

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "device: %d, interfaceInfo [devNum= %d, portNum= %d], direction=%d, lookupNum=%d",
                dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                            direction, lookupNum);

            /*
               1.2. Call cpssDxChPclPortGroupCfgTblGet with interfaceInfoPtr,
               direction, lookupNum - same as in 1.1, non-NULL lookupCfgPtr.
               Expected: GT_OK and same lookupCfgPtr as was written.
            */
            cpssOsMemSet((GT_VOID*)&lookupCfgRet, 0, sizeof(CPSS_DXCH_PCL_LOOKUP_CFG_STC));

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfgRet);

            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "cpssDxChPclPortGroupCfgTblGet: "
                "dev: %d, intInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
                dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                                direction, lookupNum);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            if (GT_OK == st)
            {
                failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&lookupCfg,
                                                (const GT_VOID*)&lookupCfgRet,
                                                sizeof(lookupCfg))) ? GT_FALSE : GT_TRUE;
                UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                    "get another lookupCfg than was written [dev = %d, direction=%d, lookupNum=%d]",
                    dev, direction, lookupNum);
            }

            /*
               1.3. Check Egress direction (not supported by Cheetah1).
               Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.1.
               Expected: GT_OK for all devices except Cheetah.
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;

            cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));

            lookupCfg.enableLookup = GT_TRUE;
            lookupCfg.pclId = 1023;
            lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
            lookupCfg.groupKeyTypes.ipv4Key  = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E;
            lookupCfg.groupKeyTypes.ipv6Key  = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E;

            if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
            {
                lookupCfg.exactMatchLookupSubProfileId=4;
            }

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                "Cheetah device: %d, direction=%d", dev, direction);

            direction = CPSS_PCL_DIRECTION_INGRESS_E;

            /*
               1.4. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
               other params same as in 1.1.
               Expected: GT_OK.
            */
            cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));
            lookupCfg.enableLookup = GT_TRUE;
            lookupCfg.pclId = 1023;
            lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
            lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;

            if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
            {
                lookupCfg.exactMatchLookupSubProfileId=1;
            }

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
              "dev: %d, interfaceInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
              dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                        direction, lookupNum);

            lookupNum = CPSS_PCL_LOOKUP_0_E;

            /* -- II - INTERFACE_TYPE - VLan (interfaceInfoPtr->type= CPSS_INTERFACE_VID_E) --*/

            /*
               1.5. Check Ingress direction. For all devices call with
               interfaceInfoPtr [type = CPSS_INTERFACE_VID_E,
               vlanId = [100 / (PRV_CPSS_MAX_NUM_VLANS_CNS - 1) = 4095] ],
               direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum
               [CPSS_PCL_LOOKUP_0_E], lookupCfgPtr [enableLookup = GT_TRUE, pclId
               = 1023, groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
               other fields zeroed } ].
               Expected: GT_OK for all devices except ch1.
            */
            interfaceInfo.type = CPSS_INTERFACE_VID_E;
            interfaceInfo.vlanId = PRV_CPSS_MAX_NUM_VLANS_CNS - 1;

            direction=CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum=CPSS_PCL_LOOKUP_0_E;

            cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));

            lookupCfg.enableLookup = GT_TRUE;
            lookupCfg.pclId = 1023;
            lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
            lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "device: %d, interfaceInfo [type=%d, vlanId=%d]",
                        dev, interfaceInfo.type, interfaceInfo.vlanId);

            interfaceInfo.vlanId = 100;
            if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
            {
                lookupCfg.exactMatchLookupSubProfileId=4;
            }
            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "device: %d, interfaceInfo [type=%d, vlanId=%d], direction=%d, lookupNum=%d",
                dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

            /*
               1.6. Call cpssDxChPclPortGroupCfgTblGet with interfaceInfoPtr,
               direction, lookupNum - same as in 1.5, non-NULL lookupCfgPtr.
               Expected: GT_OK and same lookupCfgPtr as was written.
            */
            cpssOsMemSet((GT_VOID*)&lookupCfgRet, 0, sizeof(CPSS_DXCH_PCL_LOOKUP_CFG_STC));

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfgRet);

            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "cpssDxChPclPortGroupCfgTblGet: "
                "dev: %d, intInfo [type=%d, vlanId=%d], direction=%d, lookupNum=%d",
                dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

            if(!SUPPORT_TCAM_SEGMENT_MODE_MAC(dev))
            {
                /* do not compare values ... no meaning in that */
                lookupCfg.tcamSegmentMode =  lookupCfgRet.tcamSegmentMode;
            }

            if (GT_OK == st)
            {
                failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&lookupCfg,
                                                (const GT_VOID*)&lookupCfgRet,
                                                sizeof(lookupCfg))) ? GT_FALSE : GT_TRUE;
                UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                    "get another lookupCfg than has been written [dev = %d, direction=%d, lookupNum=%d]",
                                        dev, direction, lookupNum);
            }

            /*
               1.7. Check Egress direction (not supported by Cheetah1).
               call with direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.5.
               Expected: GT_OK for all devices except Cheetah.
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;

            cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));

            lookupCfg.enableLookup = GT_TRUE;
            lookupCfg.pclId = 1023;
            lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E;
            lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E;
            lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E;

            if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
            {
                lookupCfg.exactMatchLookupSubProfileId=3;
            }
            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
              "dev: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
                    dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

            direction = CPSS_PCL_DIRECTION_INGRESS_E;

            /*
               1.8. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
               other params same as in 1.5.
               Expected: GT_OK.
            */
            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;

            cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));

            lookupCfg.enableLookup = GT_TRUE;
            lookupCfg.pclId = 1023;
            lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
            lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

            if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
            {
                lookupCfg.exactMatchLookupSubProfileId=3;
            }

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                  "dev: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
                        dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

            lookupNum = CPSS_PCL_LOOKUP_0_E;

            /*
               1.8.1 Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
               other params same as in 1.5.
               Expected:GT_BAD_PARAM for sip 6 , GT_OK for others .
            */
            cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));
            lookupNum = CPSS_PCL_LOOKUP_1_E;
            lookupCfg.enableLookup = GT_TRUE;
            lookupCfg.pclId = 1023;
            lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
            lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
            if (PRV_CPSS_SIP_6_CHECK_MAC(dev))
            {
                lookupCfg.exactMatchLookupSubProfileId = 3;
            }
            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            if (iPcl0Bypass)
            {
                UTF_VERIFY_EQUAL5_STRING_MAC(GT_BAD_PARAM, st,
                  "dev: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
                        dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);
            }
            else
            {
                UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                  "dev: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
                        dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);
            }
            lookupNum = CPSS_PCL_LOOKUP_0_E;

            /*
                1.9. Check wrong direction enum values. Other params same as in 1.5.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupCfgTblSet
                                (dev, portGroupsBmp, &interfaceInfo,
                                 direction, lookupNum, &lookupCfg),
                                direction);

            /*
                1.10. Check wrong lookupNum enum values.  Other params same as in 1.5.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupCfgTblSet
                                (dev, portGroupsBmp, &interfaceInfo,
                                 direction, lookupNum, &lookupCfg),
                                lookupNum);

            /*
               1.11. Check for NULL pointer support. Call with lookupCfgPtr [NULL],
               other params same as in 1.5.
               Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "device: %d, lookupCfgPtr=NULL", dev);

            /*
               1.12. Check for NULL pointer support. Call with interfaceInfoPtr [NULL],
               other params same as in 1.5.
               Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, NULL, direction,
                                                lookupNum, &lookupCfg);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                        "device: %d, interfaceInfoPtr=NULL", dev);

            /*
               1.13. Check out-of-range vlan id.
               Call with interfaceInfoPtr [type = CPSS_INTERFACE_VID_E, vlanId
               [PRV_CPSS_MAX_NUM_VLANS_CNS = 4096] ], other params same as in 1.5.
               Expected: non GT_OK.
            */
            interfaceInfo.vlanId = PRV_CPSS_MAX_NUM_VLANS_CNS;

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
               "device: %d, interfaceInfo.vlanId = %d", dev, interfaceInfo.vlanId);

            interfaceInfo.vlanId = 100;

            /* -- III - INTERFACE_TYPE - TRUNK (interfaceInfoPtr->type= CPSS_INTERFACE_TRUNK_E) --
              Supported only in Non-Local mode */

            /*
               1.14. Check trunk interface with valid params. For all devices
               call with interfaceInfoPtr [type = CPSS_INTERFACE_TRUNK_E,
               trunkId = 0 ], direction [CPSS_PCL_DIRECTION_INGRESS_E],
               lookupNum [CPSS_PCL_LOOKUP_0_E], lookupCfgPtr [enableLookup =
               GT_TRUE, pclId = 1023, groupKeyTypes {nonIpKey =
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E, ipv4Key =
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E, ipv6Key =
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E } ].
               Expected: NOT GT_OK.
            */
            interfaceInfo.type = CPSS_INTERFACE_TRUNK_E;
            interfaceInfo.trunkId = 0;

            CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);

            direction=CPSS_PCL_DIRECTION_INGRESS_E;

            lookupNum=CPSS_PCL_LOOKUP_0_E;

            lookupCfg.enableLookup = GT_TRUE;
            lookupCfg.pclId = 1023;
            lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
            lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
              "device: %d, interfaceInfo [trunkId=%d], direction=%d, lookupNum=%d",
                                       dev, interfaceInfo.trunkId, direction, lookupNum);

            /*
               1.15. Check out-of-range trunk id.
               call with interfaceInfoPtr [type = CPSS_INTERFACE_TRUNK_E, trunkId
               [UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev) = 128] ], other params same as in 1.14.
               Expected: non GT_OK.
            */
            interfaceInfo.trunkId = UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev);
            CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
               "device: %d, interfaceInfo.trunkId = %d", dev, interfaceInfo.trunkId);

            if (PRV_CPSS_SIP_5_CHECK_MAC(dev) && (! PRV_CPSS_SIP_6_CHECK_MAC(dev)))
            {
                accMode.ipclAccMode     = CPSS_DXCH_PCL_CFG_TBL_ACCESS_NON_LOCAL_PORT_E;
                st = cpssDxChPclCfgTblAccessModeSet(
                    dev, &accMode);
                UTF_VERIFY_EQUAL1_STRING_MAC(
                    GT_OK, st, "cpssDxChPclCfgTblAccessModeSet: %d", dev);

                maxIndexAbove4K = PRV_CPSS_SIP_5_20_CHECK_MAC(dev) ?
                                  512 :
                                  PRV_CPSS_SIP_5_15_CHECK_MAC(dev) ?
                                  ((direction == CPSS_PCL_DIRECTION_INGRESS_E) ? 256 : 128) :
                                  256;

                lookupCfg.enableLookup = GT_TRUE;
                lookupCfg.pclId = 1023;
                lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
                lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
                lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
                interfaceInfo.trunkId = (GT_TRUNK_ID)(maxIndexAbove4K - 1);
                CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);

                st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                          direction, lookupNum, &lookupCfg);
                UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                   "device: %d, interfaceInfo.trunkId = %d", dev, interfaceInfo.trunkId);

                interfaceInfo.trunkId = (GT_TRUNK_ID)(maxIndexAbove4K);
                CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);

                st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                          direction, lookupNum, &lookupCfg);
                UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
                   "device: %d, interfaceInfo.trunkId = %d", dev, interfaceInfo.trunkId);


                lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
                lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E;
                lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E;

                direction = CPSS_PCL_DIRECTION_EGRESS_E;

                maxIndexAbove4K = PRV_CPSS_SIP_5_20_CHECK_MAC(dev) ?
                                  512 :
                                  PRV_CPSS_SIP_5_15_CHECK_MAC(dev) ?
                                  ((direction == CPSS_PCL_DIRECTION_INGRESS_E) ? 256 : 128) :
                                  256;

                interfaceInfo.type = CPSS_INTERFACE_PORT_E;
                interfaceInfo.devPort.hwDevNum = dev;
                interfaceInfo.devPort.portNum = maxIndexAbove4K - 1;

                st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                          direction, lookupNum, &lookupCfg);
                UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st,
                   "device: %d, interfaceInfo.trunkId = %d", dev, interfaceInfo.trunkId);

                interfaceInfo.devPort.portNum = maxIndexAbove4K;

                st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                          direction, lookupNum, &lookupCfg);
                UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
                   "device: %d, interfaceInfo.trunkId = %d", dev, interfaceInfo.trunkId);

                /* restore values */
                direction=CPSS_PCL_DIRECTION_INGRESS_E;

                lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
                lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
                lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

                accMode.ipclAccMode     = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E;
                if (! PRV_CPSS_SIP_6_CHECK_MAC(dev))
                {
                    /* for SIP6 devices hard-wired local-port-access */
                    st = cpssDxChPclCfgTblAccessModeSet(
                        dev, &accMode);
                    UTF_VERIFY_EQUAL1_STRING_MAC(
                        GT_OK, st, "cpssDxChPclCfgTblAccessModeSet: %d", dev);
                }
            }

            interfaceInfo.trunkId = 0;
            CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);

            /* -- IV - INTERFACE_TYPE - Vidx (unsupported) (interfaceInfoPtr->type= CPSS_INTERFACE_VIDX_E) -- */

            /*
               1.16. Check Vidx interface (unsupported) with valid params. For Cheetah/Cheetah2
               devices call with interfaceInfoPtr [type = CPSS_INTERFACE_VIDX_E,
               vidx = 0 ], other params same as in 1.1.
               Expected: non GT_OK.
            */
            interfaceInfo.type = CPSS_INTERFACE_VIDX_E;
            interfaceInfo.vidx = 0;

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
                "device: %d, interfaceInfo.type = %d", dev, interfaceInfo.type);

            interfaceInfo.type = CPSS_INTERFACE_PORT_E;
            interfaceInfo.vidx = 0;

            /* -- V - INTERFACE_TYPE - out-of-range -- */

            /*
                1.17. Check out-of-range interface type enum. Call with
                      interfaceInfoPtr [type = wrong enum values, devPort
                      {devNum=0, portNum=0}, trunkId = 0, vidx = 0, vlanId = 100 ],
                      other params same as in 1.1.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupCfgTblSet
                                (dev, portGroupsBmp, &interfaceInfo,
                                 direction, lookupNum, &lookupCfg),
                                interfaceInfo.type);

            /*
                1.18. Check Ingress direction. For all devices call with
                portGroupsBmp ,
                interfaceInfoPtr [type = CPSS_INTERFACE_PORT_E, devPort {devNum=0, portNum=0} ],
                direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_1_E], lookupCfgPtr
                [enableLookup = GT_TRUE, groupKeyTypes.ipv4Key =
                CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E, pclId = 1023, groupKeyTypes.ipv6Key
                = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E, other fields zeroed } ].
                Expected: not GT_OK (not supported STD IPV6 DIP).
            */
            interfaceInfo.type = CPSS_INTERFACE_PORT_E;
            interfaceInfo.devPort.hwDevNum = dev;
            interfaceInfo.devPort.portNum = 0;
            if (PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(dev) != 0)
            {
                interfaceInfo.devPort.portNum = UTF_GET_PORT_FOR_PORT_GROUP_MAC(portGroupId);
            }

            direction=CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum= iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;

            cpssOsBzero((GT_VOID*) &lookupCfg, sizeof(lookupCfg));

            lookupCfg.enableLookup = GT_TRUE;
            lookupCfg.pclId = 1023;
            lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E;
            lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E;
            lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E;

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_NOT_EQUAL5_STRING_MAC(GT_OK, st,
                    "dev: %d, interfaceInfo [devNum= %d, portNum= %d], direction=%d, lookupNum=%d",
                    dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                                direction, lookupNum);

            /*
                1.19. Check Ingress direction. For all devices call with
                portGroupsBmp [CPSS_PORT_GROUP_UNAWARE_MODE_CNS],
                interfaceInfoPtr [type = CPSS_INTERFACE_PORT_E, devPort {devNum=0, portNum=0} ],
                direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_1_E], lookupCfgPtr
                [enableLookup = GT_TRUE, groupKeyTypes.ipv4Key =
                CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E, pclId = 1023, groupKeyTypes.ipv6Key
                = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E, other fields zeroed } ].
                Expected: NOT GT_OK for ch1 (different lookupCfg.groupKeyTypes sizes).
            */

            lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E;
            lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E;
            lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E;

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
        lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                           direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* set correct values for all the parameters (except of device number) */
    interfaceInfo.type = CPSS_INTERFACE_VID_E;
    interfaceInfo.vlanId = 100;

    direction=CPSS_PCL_DIRECTION_INGRESS_E;

    lookupNum=CPSS_PCL_LOOKUP_0_E;

    lookupCfg.enableLookup = GT_TRUE;
    lookupCfg.pclId = 1023;
    lookupCfg.groupKeyTypes.nonIpKey = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    lookupCfg.groupKeyTypes.ipv4Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
    lookupCfg.groupKeyTypes.ipv6Key = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                          direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupCfgTblSet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupCfgTblGet
(
    IN  GT_U8                           devNum,
    IN  GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN  CPSS_INTERFACE_INFO_STC        *interfaceInfoPtr,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    OUT CPSS_DXCH_PCL_LOOKUP_CFG_STC    *lookupCfgPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupCfgTblGet)
{
/*
I - INTERFACE_TYPE - Port (interfaceInfoPtr->type= CPSS_INTERFACE_PORT_E)

    ITERATE_DEVICES_PORT_GROUPS

    1.1. Check Ingress direction. For all devices call with interfaceInfoPtr [type =
    CPSS_INTERFACE_PORT_E, devPort {devNum=0, portNum=0} ], direction
    [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_0_E], non-NULL lookupCfgPtr.
    Expected: GT_OK.

    1.2. Check Egress direction (not supported by cheetah1).
    Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.1.
    Expected: GT_OK for all except Cheetah.

    1.3. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E], other params same as in 1.1.
    Expected: GT_OK.

II - INTERFACE_TYPE - VLan (interfaceInfoPtr->type= CPSS_INTERFACE_VID_E)

    1.4. Check Ingress direction. For all devices call with interfaceInfoPtr [type =
    CPSS_INTERFACE_VID_E, vlanId = [100  / (PRV_CPSS_MAX_NUM_VLANS_CNS - 1) = 4095] ],
    direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_0_E], non-NULL lookupCfgPtr.
    Expected: GT_OK for all devices except cheetah.

    1.5. Check Egress direction (not supported by Cheetah1). Call with
    direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.4.
    Expected: GT_OK for all devices except Cheetah.

    1.6. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E], other params same as in 1.4.
    Expected: GT_OK.

    1.7. Check out-of-range direction enum. call with direction [wrong enum values],
    other params same as in 1.4.
    Expected: GT_BAD_PARAM.

    1.8. Check out-of-range lookupNum enum. call with lookupNum [wrong enum values],
    other params same as in 1.4.
    Expected: GT_BAD_PARAM.

    1.9. Check for NULL pointer support. call with lookupCfgPtr [NULL], other params
    same as in 1.4.
    Expected: GT_BAD_PTR.

    1.10. Check for NULL pointer support. call with interfaceInfoPtr [NULL], other
    params same as in 1.4.
    Expected: GT_BAD_PTR.

    1.11. Check out-of-range vlan id. call with interfaceInfoPtr [type =
    CPSS_INTERFACE_VID_E, vlanId [PRV_CPSS_MAX_NUM_VLANS_CNS = 4096] ], other params
    same as in 1.4.
    Expected: non GT_OK.

III - INTERFACE_TYPE - TRUNK (interfaceInfoPtr->type= CPSS_INTERFACE_TRUNK_E)

    1.12. Check trunk interface with valid params. For all devices call with
    interfaceInfoPtr [type = CPSS_INTERFACE_TRUNK_E, trunkId = 0 ], direction
    [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum [CPSS_PCL_LOOKUP_0_E], non-NULL lookupCfgPtr.
    Expected: GT_OK for all devices except ch1.

    1.13. Check out-of-range trunk id. call with interfaceInfoPtr [type =
    CPSS_INTERFACE_TRUNK_E, trunkId [UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev) = 128] ], other params same as in 1.12.
    Expected: non GT_OK.

IV - INTERFACE_TYPE - Vidx (unsupported) (interfaceInfoPtr->type= CPSS_INTERFACE_VIDX_E)

    1.14. Check Vidx interface (unsupported) with valid params. Call with
    interfaceInfoPtr [type = CPSS_INTERFACE_VIDX_E, vidx = 0 ], other params same as in 1.1.
    Expected: non GT_OK.

V - INTERFACE_TYPE - out-of-range

    1.15. Check out-of-range interface type enum. call with interfaceInfoPtr [type =
    wrong enum values, devPort {devNum=0, portNum=0}, trunkId = 0, vidx = 0, vlanId =
    100 ], other params same as in 1.1.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                       st = GT_OK;
    GT_U8                           dev;

    GT_PORT_GROUPS_BMP              portGroupsBmp = 1;
    CPSS_INTERFACE_INFO_STC         interfaceInfo;
    CPSS_PCL_DIRECTION_ENT          direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum = CPSS_PCL_LOOKUP_0_E;
    CPSS_DXCH_PCL_LOOKUP_CFG_STC    lookupCfg;

    CPSS_PP_FAMILY_TYPE_ENT         devFamily;

    GT_U32                          portGroupId;
    /* access mode */
    CPSS_DXCH_PCL_CFG_TBL_ACCESS_MODE_STC   accMode;
    GT_BOOL                         iPcl0Bypass;

    accMode.ipclAccMode     = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E;
    accMode.epclAccMode     = CPSS_DXCH_PCL_CFG_TBL_ACCESS_LOCAL_PORT_E;
    accMode.ipclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
    accMode.epclDevPortBase = CPSS_DXCH_PCL_CFG_TBL_DEV_PORT_BASE0_E;
    accMode.ipclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;
    accMode.epclMaxDevPorts = CPSS_DXCH_PCL_CFG_TBL_MAX_DEV_PORTS_32_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        if (! PRV_CPSS_SIP_6_CHECK_MAC(dev))
        {
            /* for SIP6 devices hard-wired local-port-access */
            st = cpssDxChPclCfgTblAccessModeSet(
                dev, &accMode);
            UTF_VERIFY_EQUAL1_STRING_MAC(
                GT_OK, st, "cpssDxChPclCfgTblAccessModeSet: %d", dev);
        }

        /* get device family */
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);
            /* I - INTERFACE_TYPE - Port (interfaceInfoPtr->type= CPSS_INTERFACE_PORT_E) */

            /*
               1.1. Check Ingress direction. For all devices call with
               interfaceInfoPtr [type = CPSS_INTERFACE_PORT_E, devPort {devNum=0,
               portNum=0} ], direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum
               [CPSS_PCL_LOOKUP_0_E], non-NULL lookupCfgPtr.
               Expected: GT_OK
           */
            interfaceInfo.type = CPSS_INTERFACE_PORT_E;
            interfaceInfo.devPort.hwDevNum = dev;
            interfaceInfo.devPort.portNum = 0;
            if (PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(dev) != 0)
            {
                interfaceInfo.devPort.portNum = UTF_GET_PORT_FOR_PORT_GROUP_MAC(portGroupId);
            }
            direction=CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum=CPSS_PCL_LOOKUP_0_E;

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                "device: %d, interfaceInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
                dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                            direction, lookupNum);

            /*
               1.2. Check Egress direction (not supported by cheetah1).
               Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.1.
               Expected: GT_OK for all except Cheetah.
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
             "device: %d, interfaceInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
             dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                        direction, lookupNum);

            direction = CPSS_PCL_DIRECTION_INGRESS_E;

            /*
               1.3. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
               other params same as in 1.1.
               Expected: GT_OK.
            */
            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
              "device: %d, interfaceInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
              dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                        direction, lookupNum);

            lookupNum = CPSS_PCL_LOOKUP_0_E;

                        /*
            1.3.1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
               other params same as in 1.1.
               Expected: GT_OK.
            */
            lookupNum = CPSS_PCL_LOOKUP_1_E;

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            if (iPcl0Bypass)
            {
                UTF_VERIFY_EQUAL5_STRING_MAC(GT_BAD_PARAM, st,
                  "device: %d, interfaceInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
                  dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                            direction, lookupNum);
            }
            else
            {
                UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
                  "device: %d, interfaceInfo [devNum=%d, portNum=%d], direction=%d, lookupNum=%d",
                  dev, interfaceInfo.devPort.hwDevNum, interfaceInfo.devPort.portNum,
                                                            direction, lookupNum);
            }
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            /* -- II - INTERFACE_TYPE - VLan (interfaceInfoPtr->type= CPSS_INTERFACE_VID_E) --*/

            /*
               1.4. Check Ingress direction. For all devices call with
               interfaceInfoPtr [type = CPSS_INTERFACE_VID_E,
               vlanId = [100  / (PRV_CPSS_MAX_NUM_VLANS_CNS - 1) = 4095] ],
               direction [CPSS_PCL_DIRECTION_INGRESS_E], lookupNum
               [CPSS_PCL_LOOKUP_0_E], lookupCfgPtr [enableLookup = GT_TRUE, pclId
               = 1023, groupKeyTypes {nonIpKey =
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E, ipv4Key =
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E, ipv6Key =
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E } ].
               Expected: GT_OK for all devices except cheetah.
            */

            interfaceInfo.type = CPSS_INTERFACE_VID_E;
            interfaceInfo.vlanId = PRV_CPSS_MAX_NUM_VLANS_CNS - 1;

            direction=CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum=CPSS_PCL_LOOKUP_0_E;

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_EQUAL3_STRING_MAC(
                GT_OK, st,
                "device: %d, interfaceInfo [type=%d, vlanId =%d]",
                dev, interfaceInfo.type, interfaceInfo.vlanId);

            interfaceInfo.vlanId = 100;

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
            "device: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
                      dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

            /*
               1.5. Check Egress direction (not supported by Cheetah1).
               Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.4.
               Expected: GT_OK for all devices except Cheetah.
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
              "dev: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
              dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

            direction = CPSS_PCL_DIRECTION_INGRESS_E;

            /*
               1.6. Check LOOKUP_1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E],
               other params same as in 1.4.
               Expected: GT_OK.
            */
            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                                  direction, lookupNum, &lookupCfg);

            UTF_VERIFY_EQUAL5_STRING_MAC(GT_OK, st,
             "dev: %d, interfaceInfo [type=%d, vlanId =%d], direction=%d, lookupNum=%d",
                dev, interfaceInfo.type, interfaceInfo.vlanId, direction, lookupNum);

            lookupNum = CPSS_PCL_LOOKUP_0_E;

            /*
                1.7. Check wrong direction enum value. Other params same as in 1.4.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupCfgTblGet
                                (dev, portGroupsBmp, &interfaceInfo,
                                direction, lookupNum, &lookupCfg),
                                direction);

            /*
                1.8. Check wrong lookupNum enum value. Other params same as in 1.4.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupCfgTblGet
                                (dev, portGroupsBmp, &interfaceInfo,
                                direction, lookupNum, &lookupCfg),
                                lookupNum);

            /*
               1.9. Check for NULL pointer support. Call with lookupCfgPtr [NULL],
               other params same as in 1.4.
               Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "device: %d, lookupCfgPtr=NULL", dev);

            /*
               1.10. Check for NULL pointer support. Call with interfaceInfoPtr [NULL],
               other params same as in 1.4.
               Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, NULL,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                    "device: %d, interfaceInfoPtr=NULL", dev);

            /*
               1.11. Check out-of-range vlan id. Call with interfaceInfoPtr
               [type = CPSS_INTERFACE_VID_E, vlanId
               [PRV_CPSS_MAX_NUM_VLANS_CNS = 4096] ], other params same as in 1.4.
               Expected: non GT_OK.
            */
            interfaceInfo.vlanId = PRV_CPSS_MAX_NUM_VLANS_CNS;

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
               "device: %d, interfaceInfo.vlanId = %d", dev, interfaceInfo.vlanId);

            interfaceInfo.vlanId = 100;

            /* -- III - INTERFACE_TYPE - TRUNK (interfaceInfoPtr->type= CPSS_INTERFACE_TRUNK_E) --
            Supported only in Non-Local mode */

            /*
               1.12. Check trunk interface with valid params. For all devices
               call with interfaceInfoPtr [type = CPSS_INTERFACE_TRUNK_E,
               trunkId = 0 ], direction [CPSS_PCL_DIRECTION_INGRESS_E],
               lookupNum [CPSS_PCL_LOOKUP_0_E], lookupCfgPtr [enableLookup =
               GT_TRUE, pclId = 1023, groupKeyTypes {nonIpKey =
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E, ipv4Key =
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E, ipv6Key =
               CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E } ].
               Expected: GT_OK.
            */
            interfaceInfo.type = CPSS_INTERFACE_TRUNK_E;
            interfaceInfo.trunkId = 0;

            CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);

            direction=CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum=CPSS_PCL_LOOKUP_0_E;

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
              "device: %d, interfaceInfo [trunkId=%d], direction=%d, lookupNum=%d",
                              dev, interfaceInfo.trunkId, direction, lookupNum);

            /*
               1.13. Check out-of-range trunk id. Call with interfaceInfoPtr
               [type = CPSS_INTERFACE_TRUNK_E, trunkId
               [UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev) = 128] ], other params same as in 1.12.
               Expected: non GT_OK.
            */
            interfaceInfo.trunkId = UTF_CPSS_PP_MAX_TRUNK_ID_MAC(dev);

            CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);
            UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
               "device: %d, interfaceInfo.trunkId = %d", dev,
                                              interfaceInfo.trunkId);
            interfaceInfo.trunkId = 0;

            CONVERT_TRUNK_ID_TEST_TO_CPSS_MAC(interfaceInfo.trunkId);

            /* -- IV - INTERFACE_TYPE - Vidx (unsupported) (interfaceInfoPtr->type= CPSS_INTERFACE_VIDX_E) -- */

            /*
               1.14. Check Vidx interface (unsupported) with valid params.
               Call with interfaceInfoPtr [type = CPSS_INTERFACE_VIDX_E, vidx = 0 ],
               other params same as in 1.1.
               Expected: non GT_OK.
            */
            interfaceInfo.type = CPSS_INTERFACE_VIDX_E;
            interfaceInfo.vidx = 0;

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                              direction, lookupNum, &lookupCfg);
            UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
                "dev: %d, interfaceInfo.type = %d", dev, interfaceInfo.type);

            interfaceInfo.type = CPSS_INTERFACE_PORT_E;
            interfaceInfo.vidx = 0;

            /* -- V - INTERFACE_TYPE - out-of-range -- */

            /*
                1.15. Check out-of-range interface type enum. Call with interfaceInfoPtr
                [type = wrong enum values, devPort {devNum=0, portNum=0}, trunkId = 0, vidx = 0,
                vlanId = 100 ], other params same as in 1.1.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupCfgTblGet
                                (dev, portGroupsBmp, &interfaceInfo,
                                 direction, lookupNum, &lookupCfg),
                                interfaceInfo.type);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        direction=CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum=CPSS_PCL_LOOKUP_0_E;
        interfaceInfo.type = CPSS_INTERFACE_PORT_E;
        interfaceInfo.devPort.hwDevNum = dev;
        interfaceInfo.devPort.portNum = 0;

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                      direction, lookupNum, &lookupCfg);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                           direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* set correct values for all the parameters (except of device number) */
    interfaceInfo.type = CPSS_INTERFACE_VID_E;
    interfaceInfo.vlanId = 100;
    direction=CPSS_PCL_DIRECTION_INGRESS_E;
    lookupNum=CPSS_PCL_LOOKUP_0_E;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                              direction, lookupNum, &lookupCfg);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupCfgTblGet(dev, portGroupsBmp, &interfaceInfo,
                                          direction, lookupNum, &lookupCfg);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/* check port group return: GT_TRUE - not valid group; GT_FALSE - valid */
static GT_BOOL  prvUtfPclActivePortGroupCheck(GT_U8 devNum, GT_U32 portGroupId, GT_U32 *portGroupsBmpPtr)
{
    GT_UNUSED_PARAM(portGroupsBmpPtr);

    if(PRV_CPSS_SIP_6_CHECK_MAC(devNum))
    {
        switch (portGroupId)
        {
            case 0:
            case 2:
            case 4:
            case 6:
                /* valid groups*/
                break;
            default:
                return GT_TRUE; /* skip other */
        }
    }
    /* all SIP_5 device ignores port group for PCL APIs.
       all port groups are valid for Lion2 devices */

    return GT_FALSE;
}
/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupRuleActionGet
(
    IN  GT_U8                              devNum,
    IN  GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN  CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN  GT_U32                             ruleIndex,
    IN CPSS_PCL_DIRECTION_ENT              direction,
    OUT CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleActionGet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(dxChx)

    1.1. Set rule for testing. Call cpssDxChPclPortGroupRuleSet with
    ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E], ruleIndex [PCL_TESTED_RULE_INDEX],
    maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ], patternPtr-> ruleStdNotIp [
    common[pclId=0; sourcePort=5; isTagged=1; vid=100; up=0; qosProfile=0; isIp=0;
    isL2Valid=1; isUdbValid =1], isIpv4 = 0; etherType=0; isArp=0; l2Encap=0;
    macDa=AB:CD:EF:00:00:02; macSa=AB:CD:EF:00:00:01; udb[10,20,30] ], actionPtr [ pktCmd
    = CPSS_PACKET_CMD_FORWARD_E, mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
    matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 }, qos {
    egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE , qos [
    ingress[profileIndex=0, profileAssignIndex=GT_FALSE, profilePrecedence=GT_FALSE] ] },
    redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E, data[routerLttIndex=0] },
    policer { policerEnable=GT_FALSE, policerId=0 }, vlan { egressTaggedModify=GT_FALSE,
    modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE, vlanId=100,
    precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E }, ipUcRoute {
    doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
    Expected: GT_OK.

    1.2. For all devices check with legal parameters. Call with
    ruleSize[CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX], direction
    [CPSS_PCL_DIRECTION_INGRESS_E], non-NULL actionPtr.
    Expected: GT_OK for all devices except cheetah1.

    1.3. Check with rule size for other type of rule. Call with ruleSize
    [CPSS_PCL_RULE_SIZE_EXT_E], other params same as in 1.2.
    Expected: NON GT_OK.

    1.4. Check invalid rule size value. Call with ruleSize [wrong enum values], other
    params same as in 1.2.
    Expected: GT_BAD_PARAM.

    1.5. Check out of range ruleIndex. Call with ruleIndex [1024], other parameters same as in 1.2.
    Expected: NON GT_OK.

    1.6. Check invalid direction value. Call with direction
    [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.2.
    Expected: NON GT_OK.

    1.7. Check out-of-range  enum. Call with direction [wrong enum values], other
    parameters same as in 1.2.
    Expected: GT_BAD_PARAM.

    1.8. Check for NULL pointer. Call with actionPtr [NULL], other parameters same as in 1.2.
    Expected: GT_BAD_PTR.

    1.9. Call cpssDxChPclPortGroupRuleInvalidate with ruleSize
    [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
    Expected: GT_OK.

    1.10. Try to get action from invalidated rule. Call with ruleIndex [PCL_TESTED_RULE_INDEX], other
    parameters same as in 1.2.
    Expected: NON GT_OK.
*/
    GT_STATUS  st = GT_OK;

    GT_U8                      dev;
    GT_PORT_GROUPS_BMP         portGroupsBmp = 1;
    CPSS_PCL_RULE_SIZE_ENT     ruleSize = CPSS_PCL_RULE_SIZE_STD_E ;
    GT_U32                     ruleIndex = 0;
    CPSS_PCL_DIRECTION_ENT     direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_DXCH_PCL_ACTION_STC   retAction;

    GT_U32    portGroupId;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /* check and skip not valid port groups */
            if (prvUtfPclActivePortGroupCheck(dev,portGroupId,&portGroupsBmp) == GT_TRUE)
            {
                continue;
            }

            /*
                1.1. For Set rule for testing.  Call cpssDxChPclPortGroupRuleSet with
                ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ],
                patternPtr-> ruleStdNotIp [ common[pclId=0; sourcePort=5; isTagged=1;
                vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1; isUdbValid =1],
                isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
                macSa=AB:CD:EF:00:00:01; udb[10,20,30] ],
                actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
                mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
                matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
                qos { egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE ,
                qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
                profilePrecedence=GT_FALSE] ] },
                redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                data[routerLttIndex=0] }, policer { policerEnable=GT_FALSE, policerId=0 },
                vlan { egressTaggedModify=GT_FALSE,
                modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
                vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
                ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
                Expected: GT_OK.
            */

            st = pclRuleTestingDefaultSet(dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                    "cpssDxChPclPortGroupRuleSet: device: %d", dev);

            /*
                1.2. For all devices check with legal parameters. Call with
                ruleSize[CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX],
                direction [CPSS_PCL_DIRECTION_INGRESS_E], non-NULL actionPtr.
                Expected: GT_OK
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_TCAM_RAWS(dev) - 1;
            direction = CPSS_PCL_DIRECTION_INGRESS_E;

            st = cpssDxChPclPortGroupRuleActionGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                        ruleSize, ruleIndex, direction, &retAction);
            if (st != GT_BAD_STATE)
            {
                UTF_VERIFY_EQUAL4_STRING_MAC(
                    GT_OK, st, "device: %d, %d, %d, %d",
                    dev, ruleSize, ruleIndex, direction);
            }

            /*
                1.3. Check with rule size for other type of rule.
                Call with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], other params same as in 1.2.
                Expected: GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;

            st = cpssDxChPclPortGroupRuleActionGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                    ruleSize, ruleIndex, direction, &retAction);
            if (st != GT_BAD_STATE)
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleSize);
            }

            ruleSize = CPSS_PCL_RULE_SIZE_STD_E; /* restore valid values */

            /*
                1.4. Check wrong enum rule size values.  Other params same as in 1.2.
                Expected: GT_BAD_PARAM.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_FALSE)
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleActionGet
                                    (dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                     ruleIndex, direction, &retAction),
                                    ruleSize);
            }

            /*
               1.5. Check out of range ruleIndex.
               Expected: NON GT_OK.
            */
            ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

            st = cpssDxChPclPortGroupRuleActionGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,  ruleSize,
                                                    ruleIndex, direction, &retAction);
            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

            /*
               1.6. Check invalid direction value.  Call with direction
               [CPSS_PCL_DIRECTION_EGRESS_E], other params same as in 1.2.
               Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;

            st = cpssDxChPclPortGroupRuleActionGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,  ruleSize,
                                                    ruleIndex, direction, &retAction);
            if (st != GT_BAD_STATE)
            {
                UTF_VERIFY_EQUAL4_PARAM_MAC(
                    GT_OK, st, dev, ruleSize, ruleIndex, direction);
            }

            direction = CPSS_PCL_DIRECTION_INGRESS_E; /* restore */

            /*
                1.7. Check with wrong enum values direction. Other parameters same as in 1.2.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleActionGet
                                (dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                 ruleIndex, direction, &retAction),
                                direction);

            /*
               1.8. Call with actionPtr [NULL], other parameters same as in 1.2.
               Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleActionGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,  ruleSize,
                                                    ruleIndex, direction, NULL);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_BAD_PTR, st, "%d, %d, %d, %d, NULL",
                                         dev, ruleSize, ruleIndex, direction);

            /*
               1.9. Call cpssDxChPclPortGroupRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
               ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
               Expected: GT_OK.
            */

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                "cpssDxChPclPortGroupRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupRuleActionGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                    ruleSize, ruleIndex, direction, &retAction);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupRuleActionGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                               ruleIndex, direction, &retAction);
        if (st != GT_BAD_STATE)
        {
            UTF_VERIFY_EQUAL2_PARAM_MAC(
                GT_OK, st, dev, portGroupsBmp);
        }
    }

    portGroupsBmp = 1;

    /* Set valid parameters. As soon as family of device can't be determined */
    /* - values valid for any family                                         */
    ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    ruleIndex = 0;
    direction = CPSS_PCL_DIRECTION_INGRESS_E;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclPortGroupRuleActionGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,  ruleSize,
                                        ruleIndex, direction, &retAction);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupRuleActionGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,  ruleSize,
                                       ruleIndex, direction, &retAction);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupRuleActionUpdate
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN CPSS_DXCH_PCL_ACTION_STC           *actionPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleActionUpdate)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(dxChx)
    1.1. set rule for testing. Call cpssDxChPclRuleSet with ruleFormat
    [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E], ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr->
    ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ], patternPtr-> ruleStdNotIp [
    common[pclId=0; sourcePort=5; isTagged=1; vid=100; up=0; qosProfile=0; isIp=0;
    isL2Valid=1; isUdbValid =1], isIpv4 = 0; etherType=0; isArp=0; l2Encap=0;
    macDa=AB:CD:EF:00:00:02; macSa=AB:CD:EF:00:00:01; udb[10,20,30] ], actionPtr [ pktCmd
    = CPSS_PACKET_CMD_FORWARD_E, mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
    matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 }, qos {
    egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE , qos [
    ingress[profileIndex=0, profileAssignIndex=GT_FALSE, profilePrecedence=GT_FALSE] ] },
    redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E, data[routerLttIndex=0] },
    policer { policerEnable=GT_FALSE, policerId=0 }, vlan { egressTaggedModify=GT_FALSE,
    modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE, vlanId=100,
    precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E }, ipUcRoute {
    doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
    Expected: GT_OK.

    1.2. For all devices update action with legal parameters. Call with ruleSize
    [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX], actionPtr is the same as in 1.1.
    Expected: GT_OK

    1.3. call cpssDxChPclPortGroupRuleActionGet with ruleSize[CPSS_PCL_RULE_SIZE_STD_E], ruleIndex
    [PCL_TESTED_RULE_INDEX], direction [CPSS_PCL_DIRECTION_INGRESS_E], non-NULL actionPtr.
    Expected: GT_OK and same values in actionPtr  as were written.

    1.4. Check with rule size for other type of rule. Call with ruleSize
    [CPSS_PCL_RULE_SIZE_EXT_E], ruleIndex [PCL_TESTED_RULE_INDEX], actionPtr is the same as in 1.1.
    Expected: NON GT_OK.

    1.5. For eArch devices call with ruleSize[CPSS_PCL_RULE_SIZE_ULTRA_E]
        and other params same as 1.1.
    Expected: GT_OK.

    1.6. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], valid
        actionPtr->flowId[100](is relevant) and other params same as 1.1.
    Expected: GT_OK.

    1.7. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
        actionPtr->oam.offsetIndex[15], actionPtr->oam.oamProcessEnable[GT_TRUE],
        actionPtr->oam.oamProfile[1] and other params same as 1.1.
    Expected: GT_OK.

    1.8. Check invalid rule size value. Call with ruleSize [wrong enum values], ruleIndex
    [PCL_TESTED_RULE_INDEX], actionPtr is the same as in 1.1.
    Expected: GT_BAD_PARAM.

    1.9. Check out of range ruleIndex. Call with ruleIndex [1024], other parameters is
    the same as in 1.2.
    Expected: NON GT_OK.

    1.10. Call with out of range actionPtr->matchCounter.matchCounterIndex [32]
                   and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.

    1.11. Call with out of range actionPtr->matchCounter.matchCounterIndex [16384]
                      and other params from 1.1.
    Expected: NOT GT_OK.

    1.12. Call with out of range actionPtr->policer.policerId [256]
                   and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.

    1.13. Call with out of range actionPtr->policer.policerId [4095]
                   and other params from 1.1.
    Expected: NOT GT_OK.

    1.14. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                   actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                   out of range actionPtr->redirect.outIf.tunnelPtr[1024]
                   and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.

    1.15. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                   actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                   out of range actionPtr->redirect.outIf.tunnelPtr[8192]
                   and other params from 1.1.
    Expected: NOT GT_OK.

    1.16. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                   out of range actionPtr->redirect.data.routerLttIndex[8192]
                   and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.

    1.17. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                   out of range actionPtr->redirect.data.routerLttIndex[32768]
                   and other params from 1.1.
    Expected: NOT GT_OK.

    1.18. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E],
                   out of range actionPtr->redirect.data.vrfId [4096]
                   and other params from 1.1.
    Expected: NOT GT_OK.

    1.19. Call with actionPtr->vlan.ingress.modifyVlan [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
                   out of range actionPtr->vlan.ingress.vlanId [4096]
                   and other params from 1.1.
    Expected: NOT GT_OK.

    1.20. Call with out of range actionPtr->sourceId.sourceIdValue [32]
                   and other params from 1.1.
    Expected: NOT GT_OK.

    1.21. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_TRUE], out of range
        actionPtr->flowId[0x10000](not relevant) and other params same as 1.1.
    Expected: GT_OK.

    1.22. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], out of range
        actionPtr->flowId[0x10000](is relevant) and other params same as 1.1.
    Expected: NOT GT_OK.

    1.23. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
        actionPtr->oam.oamProcessEnable[GT_TRUE],
        actionPtr->oam.oamProfile[1], out of range actionPtr->oam.offsetIndex[16],
        and other params same as 1.1.
    Expected: NOT GT_OK.

    1.24. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
        actionPtr->oam.oamProcessEnable[GT_TRUE],
        actionPtr->oam.offsetIndex[15], out of range actionPtr->oam.oamProfile[2],
        and other params same as 1.1.
    Expected: NOT GT_OK.

    1.25. Check for NULL pointer. For call with actionPtr [NULL], other parameters same as in 1.2.
    Expected: GT_BAD_PTR.

    1.26. Call function with
            action{
                redirect {
                   redirectCmd [
                    CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                   data {
                       logicalSourceInterface{
                           logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                             devPort {devNum=dev, portNum=0} ]
                           sourceMeshIdSetEnable[GT_TRUE/GT_FALSE]
                           sourceMeshId[0/1/3]
                           userTagAcEnable[GT_TRUE/GT_FALSE]
                       }}},
                unknownSaCommandEnable[GT_TRUE/GT_FALSE]
                unknownSaCommand[   CPSS_PACKET_CMD_FORWARD_E /
                                    CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                    CPSS_PACKET_CMD_TRAP_TO_CPU_E /
                                    CPSS_PACKET_CMD_DROP_HARD_E /
                                    CPSS_PACKET_CMD_DROP_SOFT_E]}
            and other parameters from 1.1.
    Expected: GT_OK  for xCat C0; xCat3.

    1.27. Call function with out of range sourceMeshId [4]
           and other parameters from 1.1.
    Expected: GT_OK  for xCat C0; xCat3.

    1.28. Call function with out of range unknownSaCommand
           and other parameters from 1.1.
    Expected: GT_OK  for xCat C0; xCat3.

    1.29. For bobCat2 and above call with out of range
                actionPtr->copyReserved.copyReserved and other params from 1.1
                Expected: GT_OUT_OF_RANGE.

    1.30. Call cpssDxChPclPortGroupRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
    ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
    Expected: GT_OK.
*/
    GT_STATUS st = GT_OK;

    GT_U8                      dev;
    GT_PORT_GROUPS_BMP         portGroupsBmp = 1;
    CPSS_PCL_RULE_SIZE_ENT     ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    GT_U32                     ruleIndex = 0;
    CPSS_DXCH_PCL_ACTION_STC   action;

    CPSS_PCL_DIRECTION_ENT     direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_DXCH_PCL_ACTION_STC   retAction;
    GT_BOOL                    failureWas;
    CPSS_PP_FAMILY_TYPE_ENT    devFamily;

    GT_U32    portGroupId;

    pclActionDefaultSet(&action);
    direction = CPSS_PCL_DIRECTION_INGRESS_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /* check and skip not valid port groups */
            if (prvUtfPclActivePortGroupCheck(dev,portGroupId,&portGroupsBmp) == GT_TRUE)
            {
                continue;
            }

            /* get device family */
            st = prvUtfDeviceFamilyGet(dev, &devFamily);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

            /* get max rule size */

            /*
                1.1. Set rule for testing.  Call cpssDxChPclRuleSet with
                ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ],
                patternPtr-> ruleStdNotIp [ common[pclId=0; sourcePort=5; isTagged=1;
                vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1; isUdbValid =1],
                isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
                macSa=AB:CD:EF:00:00:01; udb[10,20,30] ],
                actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
                mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
                matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
                qos { egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE ,
                qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
                profilePrecedence=GT_FALSE] ] },
                redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                data[routerLttIndex=0] }, policer { policerEnable=GT_FALSE, policerId=0 },
                vlan { egressTaggedModify=GT_FALSE,
                modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
                vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
                ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
                Expected: GT_OK
            */
            st = pclRuleTestingDefaultSet(dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclRuleSet: device: %d", dev);

            /*
                1.2. For all devices update action with legal parameters.
                Call with ruleSize [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX],
                actionPtr is the same as in 1.1.
                Expected: GT_OK
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                            ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                        "device: %d, %d, %d", dev, ruleSize, ruleIndex);

            /*
                1.3. call cpssDxChPclPortGroupRuleActionGet
                with ruleSize[CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX],
                direction [CPSS_PCL_DIRECTION_INGRESS_E], non-NULL actionPtr.
                Expected: GT_OK and same values in actionPtr as were written.
            */
            st = cpssDxChPclPortGroupRuleActionGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,  ruleSize,
                                                    ruleIndex, direction, &retAction);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "cpssDxChPclPortGroupRuleActionGet: %d, %d, %d, %d",
                                         dev, ruleSize, ruleIndex, direction);
            if (GT_OK == st)
            {
                /* verifying values */

                /*pktCmd*/
                UTF_VERIFY_EQUAL1_STRING_MAC(action.pktCmd, retAction.pktCmd,
                 "cpssDxChPclPortGroupRuleActionGet: "
                 "get another action.pktCmd than was set: dev = %d", dev);

                if (devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
                {
                    UTF_VERIFY_EQUAL1_STRING_MAC(action.actionStop, retAction.actionStop,
                     "cpssDxChPclPortGroupRuleActionGet: "
                     "get another action.actionStop than was set: dev = %d", dev);
                }

                /*mirror*/
                failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&action.mirror,
                    (const GT_VOID*)&retAction.mirror, sizeof(action.mirror))) ? GT_FALSE : GT_TRUE;
                UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                    "cpssDxChPclPortGroupRuleActionGet: "
                    "get another action.mirror than was set: %d, %d, %d",
                                             dev, ruleSize, ruleIndex);

                /*matchCounter*/
                failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&action.matchCounter,
                                                (const GT_VOID*)&retAction.matchCounter,
                                                sizeof(action.matchCounter))) ? GT_FALSE : GT_TRUE;
                UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                    "cpssDxChPclPortGroupRuleActionGet: "
                    "get another action.matchCounter than was set: %d, %d, %d",
                                             dev, ruleSize, ruleIndex);

                /*redirect*/
                if (devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
                {
                    UTF_VERIFY_EQUAL3_STRING_MAC(
                        action.redirect.redirectCmd, retAction.redirect.redirectCmd,
                        "cpssDxChPclPortGroupRuleActionGet: "
                        "get another actionPtr->redirect.redirectCmd than was set: %d, %d, %d",
                        dev, ruleSize, ruleIndex);
                    if (action.redirect.redirectCmd
                        == CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E)
                    {
                        UTF_VERIFY_EQUAL3_STRING_MAC(
                            action.redirect.data.outIf.tunnelPtr,
                            retAction.redirect.data.outIf.tunnelPtr,
                            "cpssDxChPclPortGroupRuleActionGet: get another "
                            "actionPtr->redirect.data.outIf.tunnelPtr than was set: %d, %d, %d",
                            dev, ruleSize, ruleIndex);
                        UTF_VERIFY_EQUAL3_STRING_MAC(
                            action.redirect.data.outIf.tunnelStart,
                            retAction.redirect.data.outIf.tunnelStart,
                            "cpssDxChPclPortGroupRuleActionGet: get another "
                            "actionPtr->redirect.data.outIf.tunnelStart than was set: %d, %d, %d",
                            dev, ruleSize, ruleIndex);
                        UTF_VERIFY_EQUAL3_STRING_MAC(
                            action.redirect.data.outIf.tunnelType,
                            retAction.redirect.data.outIf.tunnelType,
                            "cpssDxChPclPortGroupRuleActionGet: get another "
                            "actionPtr->redirect.data.outIf.tunnelType than was set: %d, %d, %d",
                            dev, ruleSize, ruleIndex);
                        UTF_VERIFY_EQUAL3_STRING_MAC(
                            action.redirect.data.outIf.vntL2Echo,
                            retAction.redirect.data.outIf.vntL2Echo,
                            "cpssDxChPclPortGroupRuleActionGet: get another "
                            "actionPtr->redirect.data.outIf.vntL2Echo than was set: %d, %d, %d",
                            dev, ruleSize, ruleIndex);
                    }
                }

                /*policer*/
                failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&action.policer,
                                                (const GT_VOID*)&retAction.policer,
                                                sizeof(action.policer))) ? GT_FALSE : GT_TRUE;
                UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                     "cpssDxChPclPortGroupRuleActionGet: get another action.policer than was set: %d, %d, %d",
                                             dev, ruleSize, ruleIndex);

                /*vlan*/
                failureWas = (0 == cpssOsMemCmp((const GT_VOID*)&action.vlan,
                                                (const GT_VOID*)&retAction.vlan,
                                                sizeof(action.vlan))) ? GT_FALSE : GT_TRUE;
                UTF_VERIFY_EQUAL3_STRING_MAC(GT_FALSE, failureWas,
                     "cpssDxChPclPortGroupRuleActionGet: get another action.vlan than was set: %d, %d, %d",
                                             dev, ruleSize, ruleIndex);

            }

            /*
                1.4. check with rule size for other type of rule.
                Call with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], ruleIndex [PCL_TESTED_RULE_INDEX],
                actionPtr is the same as in 1.1.
                Expected: GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;
            ruleIndex = PCL_TCAM_RAWS(dev) - 1;

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

            ruleSize = CPSS_PCL_RULE_SIZE_STD_E; /* restore valid values */

            /*
                1.5. For eArch devices call with ruleSize[CPSS_PCL_RULE_SIZE_ULTRA_E]
                    and other params same as 1.1.
                Expected: GT_OK.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                ruleSize = CPSS_PCL_RULE_SIZE_ULTRA_E;
                ruleIndex = PCL_TCAM_RAWS(dev) - 1;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                          ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

                ruleSize = CPSS_PCL_RULE_SIZE_STD_E; /* restore valid values */


            /*
                1.6. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], valid
                    actionPtr->flowId[100](is relevant) and other params same as 1.1.
                Expected: GT_OK.
            */
                action.egressPolicy = GT_FALSE;
                action.flowId  = 100;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                    ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);


            /*
                1.7. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                    actionPtr->oam.offsetIndex[15], actionPtr->oam.oamProcessEnable[GT_TRUE],
                    actionPtr->oam.oamProfile[1] and other params same as 1.1.
                Expected: GT_OK.
            */
                action.oam.timeStampEnable = GT_TRUE;
                action.oam.offsetIndex  = 15;
                action.oam.oamProcessEnable = GT_TRUE;
                action.oam.oamProfile = 1;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                    ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);
            }

            /*
                1.8.  Call with ruleSize [wrong enum values], ruleIndex [PCL_TESTED_RULE_INDEX],
                actionPtr is the same as in 1.1.
                Expected: GT_BAD_PARAM.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_FALSE)
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleActionUpdate
                                    (dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                                    ruleSize);
            }

            /*
                1.9. Check out of range ruleIndex.
                Call with ruleIndex [1024], other parameters is the same as in 1.2.
                Expected: NON GT_OK.
            */
            ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

            /*
                1.10. Call with out of range actionPtr->matchCounter.matchCounterIndex [32]
                   and other params from 1.1.
                Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.
            */
            action.matchCounter.enableMatchCount = GT_TRUE;
            action.matchCounter.matchCounterIndex = 32;

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->matchCounter.matchCounterIndex = %d",
                      dev, ruleSize, ruleIndex, action.matchCounter.matchCounterIndex);

            /*
                1.11. Call with out of range actionPtr->matchCounter.matchCounterIndex [16384/32768]
                                  and other params from 1.1.
                Expected: NOT GT_OK.
            */
            action.matchCounter.matchCounterIndex = 16384;
            if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                action.matchCounter.matchCounterIndex = 32768;
            }

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->matchCounter.matchCounterIndex = %d",
                     dev, ruleSize, ruleIndex, action.matchCounter.matchCounterIndex);

            action.matchCounter.matchCounterIndex = 0; /* restore valid value */

            /*
                1.12. Call with out of range actionPtr->policer.policerId [256]
                               and other params from 1.1.
                Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.
            */
            action.policer.policerEnable = GT_TRUE;
            action.policer.policerId = 256;

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->policer.policerId = %d",
                          dev, ruleSize, ruleIndex, action.policer.policerId);

            /*
                1.13. For Ch3 and above call with out of range actionPtr->policer.policerId [4096]
                               and other params from 1.1.
                Expected: NOT GT_OK.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.policer.policerId = BIT_16;
            }
            else
            {
                action.policer.policerId = BIT_12;
            }

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->policer.policerId = %d",
                      dev, ruleSize, ruleIndex, action.policer.policerId);

            action.policer.policerId = 0; /* restore valid value */

            /*
                1.14. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                               actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                               out of range actionPtr->redirect.outIf.tunnelPtr[1023]
                               and other params from 1.1.
                Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.
            */
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E;
            action.redirect.data.outIf.tunnelStart = GT_TRUE;
            action.redirect.data.outIf.tunnelPtr = MAX_TUNNEL_PTR(dev)-1;

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->redirect.data.outIf.tunnelPtr = %d",
                           dev, ruleSize, ruleIndex, action.redirect.data.outIf.tunnelPtr);

            /*
                1.15. Call with actionPtr->redirect.redirectCmd
                               [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                               actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                               out of range actionPtr->redirect.outIf.tunnelPtr[8192]
                               and other params from 1.1.
                Expected: NOT GT_OK.
            */
            action.redirect.data.outIf.tunnelPtr = MAX_TUNNEL_PTR(dev);

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->redirect.data.outIf.tunnelPtr = %d",
                             dev, ruleSize, ruleIndex, action.redirect.data.outIf.tunnelPtr);

            action.redirect.data.outIf.tunnelPtr = 0; /* restore valid value */

            /*
                1.16. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                               out of range actionPtr->redirect.data.routerLttIndex[8192]
                               and other params from 1.1.
                Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.
            */
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E;
            action.redirect.data.routerLttIndex = 8192;

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, &action);

            if ((devFamily <= CPSS_PP_FAMILY_CHEETAH3_E)
                || (devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E))
            {
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                          dev, ruleSize, ruleIndex, action.redirect.data.routerLttIndex);
                /* restore value */
                action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E;
            }
            else
            {
                if ((UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)&&
                    (action.redirect.data.routerLttIndex>=PRV_CPSS_DXCH_PP_MAC(dev)->moduleCfg.ip.maxNumOfPbrEntries))
                {
                    UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                                                     "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                                                     dev, ruleSize, ruleIndex, action.redirect.data.routerLttIndex);
                }
                else
                {
                    UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                                 "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                                                 dev, ruleSize, ruleIndex, action.redirect.data.routerLttIndex);
                }

                /*
                    1.17. Call with actionPtr->redirect.redirectCmd
                          [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                          out of range actionPtr->redirect.data.routerLttIndex[32768]
                          and other params from 1.1.
                    Expected: NOT GT_OK.
                */
                if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
                {
                    action.redirect.data.routerLttIndex = PRV_CPSS_DXCH_PP_MAC(dev)->moduleCfg.ip.maxNumOfPbrEntries;
                }
                else
                {
                    action.redirect.data.routerLttIndex = BIT_15;
                }

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                            ruleSize, ruleIndex, &action);
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                        "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                               dev, ruleSize, ruleIndex, action.redirect.data.routerLttIndex);
            }

            action.redirect.data.routerLttIndex = 0; /* restore valid value */

            /*
                1.18. Call with actionPtr->redirect.redirectCmd
                [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E],
                out of range actionPtr->redirect.data.vrfId [4096] and other params from 1.1.
                Expected: NOT GT_OK.
            */
            if ((devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
                && (devFamily != CPSS_PP_FAMILY_DXCH_XCAT2_E))
            {
                action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E;
                action.redirect.data.vrfId = BIT_12;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                            ruleSize, ruleIndex, &action);
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                        "%d, %d, %d, actionPtr->redirect.data.vrfId= %d",
                               dev, ruleSize, ruleIndex, action.redirect.data.vrfId);

                action.redirect.data.vrfId = 0; /* restore valid value */
            }

            if (devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
            {
                action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E;
            }

            /*
                1.19. Call with actionPtr->vlan.ingress.modifyVlan
                    [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
                               out of range actionPtr->vlan.ingress.vlanId [4096] and other params from 1.1.
                Expected: NOT GT_OK.
            */
            action.vlan.ingress.modifyVlan = CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E;
            action.vlan.ingress.vlanId = UTF_CPSS_PP_MAX_VLAN_NUM_CNS(dev);

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->vlan.ingress.vlanId = %d",
                            dev, ruleSize, ruleIndex, action.vlan.ingress.vlanId);

            action.vlan.ingress.vlanId = 100; /* restore valid value */

            /*
                1.20. Call with out of range actionPtr->sourceId.sourceIdValue [32]
                               and other params from 1.1.
                Expected: NOT GT_OK.
            */
            if (devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
            {
                action.sourceId.assignSourceId = GT_TRUE;
                action.sourceId.sourceIdValue = UTF_CPSS_PP_MAX_SRC_ID_NUM_MAC(dev);

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                            ruleSize, ruleIndex, &action);
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->sourceId.sourceIdValue = %d",
                             dev, ruleSize, ruleIndex, action.sourceId.sourceIdValue);

                action.sourceId.sourceIdValue = 0; /* restore valid value */
            }


            /*
                1.21. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_TRUE], out of range
                    actionPtr->flowId[0x10000](not relevant) and other params same as 1.1.
                Expected: GT_OK.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                /* restore previous value */
                pclActionDefaultSet(&action);

                action.egressPolicy = GT_TRUE;
                action.flowId  = MAX_FLOW_ID(dev);
                action.actionStop = GT_FALSE;
                action.pktCmd = CPSS_PACKET_CMD_FORWARD_E;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                          ruleSize, ruleIndex, &action);
                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);

            /*
                1.22. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], out of range
                    actionPtr->flowId[0x10000](is relevant) and other params same as 1.1.
                Expected: NOT GT_OK.
            */

                action.egressPolicy = GT_FALSE;
                action.flowId  = MAX_FLOW_ID(dev);

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                          ruleSize, ruleIndex, &action);
                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);

            /*
                1.23. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                    actionPtr->oam.oamProcessEnable[GT_TRUE],
                    actionPtr->oam.oamProfile[1], out of range actionPtr->oam.offsetIndex[16],
                    and other params same as 1.1.
                Expected: NOT GT_OK.
            */
                action.oam.timeStampEnable = GT_TRUE;
                action.oam.offsetIndex  = BIT_7;
                action.oam.oamProcessEnable = GT_TRUE;
                action.oam.oamProfile = 1;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                          ruleSize, ruleIndex, &action);
                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);

            /*
                1.24. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                    actionPtr->oam.oamProcessEnable[GT_TRUE],
                    actionPtr->oam.offsetIndex[15], out of range actionPtr->oam.oamProfile[2],
                    and other params same as 1.1.
                Expected: NOT GT_OK.
            */

                action.oam.timeStampEnable = GT_TRUE;
                action.oam.offsetIndex  = BIT_7 - 1;
                action.oam.oamProcessEnable = GT_TRUE;
                action.oam.oamProfile = 2;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                          ruleSize, ruleIndex, &action);
                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);
            }

            /*
                1.25. Check for NULL pointer. For call with actionPtr [NULL], other
                parameters same as in 1.2.
                Expected: GT_BAD_PTR.
            */

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                            ruleSize, ruleIndex, NULL);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_PTR, st,
                                    "%d, %d, %d, NULL", dev, ruleSize, ruleIndex);

            /*
                1.26. Call function with
                        action{
                            redirect {
                               redirectCmd [
                                CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                               data {
                                   logicalSourceInterface{
                                       logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                                         devPort {devNum=dev, portNum=0}]
                                       sourceMeshIdSetEnable[GT_TRUE/GT_FALSE]
                                       sourceMeshId[0/1/3]
                                       userTagAcEnable[GT_TRUE/GT_FALSE]
                                   }}},
                            unknownSaCommandEnable[GT_TRUE/GT_FALSE]
                            unknownSaCommand[  CPSS_PACKET_CMD_FORWARD_E /
                                               CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                               CPSS_PACKET_CMD_TRAP_TO_CPU_E /
                                               CPSS_PACKET_CMD_DROP_HARD_E /
                                               CPSS_PACKET_CMD_DROP_SOFT_E]}
                        and other parameters from 1.1.
                Expected: GT_OK  for xCat C0; xCat3.
            */
            if (PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
            {
                /*
                    Call function with
                            action{
                                redirect {
                                   redirectCmd [
                                    CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                                   data {
                                       logicalSourceInterface{
                                           logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                                             devPort {devNum=0, portNum=0} ]
                                           sourceMeshIdSetEnable[GT_FALSE]
                                           sourceMeshId[0]
                                           userTagAcEnable[GT_FALSE]
                                       }}},
                                unknownSaCommandEnable[GT_FALSE]
                                unknownSaCommand[   CPSS_PACKET_CMD_FORWARD_E ]}
                            and other parameters from 1.1.
                */
                action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E;
                action.redirect.data.logicalSourceInterface.logicalInterface.type = CPSS_INTERFACE_PORT_E;
                action.redirect.data.logicalSourceInterface.logicalInterface.devPort.hwDevNum = dev;
                action.redirect.data.logicalSourceInterface.logicalInterface.devPort.portNum = 0;
                action.redirect.data.logicalSourceInterface.sourceMeshIdSetEnable = GT_FALSE;
                action.redirect.data.logicalSourceInterface.sourceMeshId = 0;
                action.redirect.data.logicalSourceInterface.userTagAcEnable = GT_FALSE;
                action.unknownSaCommandEnable = GT_FALSE;
                action.unknownSaCommand = CPSS_PACKET_CMD_FORWARD_E;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                /*
                    Call function with
                            action{
                                redirect {
                                   data {
                                       logicalSourceInterface{
                                           sourceMeshIdSetEnable[GT_TRUE]
                                           sourceMeshId[1]
                                           userTagAcEnable[GT_TRUE]
                                       }}},
                                unknownSaCommandEnable[GT_TRUE]
                                unknownSaCommand[ CPSS_PACKET_CMD_MIRROR_TO_CPU_E ]}
                            and other parameters from 1.1.
                */
                action.redirect.data.logicalSourceInterface.sourceMeshIdSetEnable = GT_TRUE;
                action.redirect.data.logicalSourceInterface.sourceMeshId = 1;
                action.redirect.data.logicalSourceInterface.userTagAcEnable = GT_TRUE;
                action.unknownSaCommandEnable = GT_TRUE;
                action.unknownSaCommand = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                /*
                    Call function with
                            action{
                                redirect {
                                   data {
                                       logicalSourceInterface{
                                           sourceMeshId[3]
                                       }}},
                                unknownSaCommand[   CPSS_PACKET_CMD_TRAP_TO_CPU_E ]}
                            and other parameters from 1.1.
                */

                action.redirect.data.logicalSourceInterface.sourceMeshId = 3;
                action.unknownSaCommand = CPSS_PACKET_CMD_TRAP_TO_CPU_E;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                /*
                    Call function with
                            action{
                                unknownSaCommand[   CPSS_PACKET_CMD_DROP_HARD_E ]}
                            and other parameters from 1.1.
                */
                action.unknownSaCommand = CPSS_PACKET_CMD_DROP_HARD_E;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                /*
                    Call function with
                            action{
                                unknownSaCommand[   CPSS_PACKET_CMD_DROP_SOFT_E ]}
                            and other parameters from 1.1.
                */
                action.unknownSaCommand = CPSS_PACKET_CMD_DROP_SOFT_E;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }

            /*
                1.27. Call function with out of range sourceMeshId [4]
                       and other parameters from 1.1.
                Expected: GT_OK  for xCat C0; xCat3.
            */
            if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.redirect.data.logicalSourceInterface.sourceMeshId = 4;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                ruleSize, ruleIndex, &action);
                UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                action.redirect.data.logicalSourceInterface.sourceMeshId = 0;
            }

            /*
                1.28. Call function with out of range unknownSaCommand
                       and other parameters from 1.1.
                Expected: GT_OK  for xCat C0; xCat3.
            */
            if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleActionUpdate
                                    (dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, &action),
                                    action.unknownSaCommand);
            }

            /*
                1.29. For bobCat2 and above call with out of range
                actionPtr->copyReserved.copyReserved and other params from 1.1
                Expected: GT_OUT_OF_RANGE.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.copyReserved.assignEnable = GT_TRUE;
                action.copyReserved.copyReserved = PRV_CPSS_SIP_6_CHECK_MAC(dev) ? BIT_19 : BIT_18;

                st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                ruleSize, ruleIndex, &action);
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OUT_OF_RANGE, st,
                                "%d, %d, %d, actionPtr->copyReserved.copyReserved = %d",
                                dev, ruleSize, ruleIndex, action.copyReserved.copyReserved);

                action.copyReserved.copyReserved = 0; /* restore valid value */
            }
            /*
                1.30. call cpssDxChPclPortGroupRuleInvalidate with
                ruleSize [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX]
                to cleanup after testing.
                Expected: GT_OK.
            */
            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                "cpssDxChPclPortGroupRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                    ruleSize, ruleIndex, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,  ruleSize,
                                                  ruleIndex, &action);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* Set valid parameters. As soon as family of device can't be determined */
    /* - values valid for any family                                         */
    ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    ruleIndex = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                    ruleSize, ruleIndex, &action);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupRuleActionUpdate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                ruleSize, ruleIndex, &action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupRuleAnyStateGet
(
    IN  GT_U8                         devNum,
    IN  GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN  CPSS_PCL_RULE_SIZE_ENT        ruleSize,
    IN  GT_U32                        ruleIndex,
    OUT GT_BOOL                       *validPtr,
    OUT CPSS_PCL_RULE_SIZE_ENT        *ruleSizePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleAnyStateGet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS (DxChx)

    1.1. Set rule for testing.
    Expected: GT_OK.

    1.2. Call with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E],
                   ruleIndex [PCL_TESTED_RULE_INDEX],
                   non-NULL validPtr
                   and non-NULL ruleSizePtr.
    Expected: GT_OK.

    1.3. Call with out of range ruleIndex [1024], and other parameters same as in 1.2.
    Expected: NON GT_OK.

    1.4. Call with validPtr [NULL], and other parameters same as in 1.2.
    Expected: GT_BAD_PTR.

    1.5. Call with ruleSizePtr [NULL], and other parameters same as in 1.2.
    Expected: GT_BAD_PTR.

    1.6. Call cpssDxChPclPortGroupRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                                             ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
    Expected: GT_OK.

    1.7. Get state for invalidated rule.
         Call with ruleIndex [PCL_TESTED_RULE_INDEX], non-NULL validPtr and non-NULL ruleSizePtr.
    Expected: GT_OK, validPtr = GT_FALSE.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_PORT_GROUPS_BMP      portGroupsBmp = 1;

    CPSS_PCL_RULE_SIZE_ENT  ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
    GT_U32                  ruleIndex = 0;
    GT_BOOL                 valid     = GT_FALSE;

    CPSS_PP_FAMILY_TYPE_ENT devFamily;

    GT_U32    portGroupId;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /* check and skip not valid port groups */
            if (prvUtfPclActivePortGroupCheck(dev,portGroupId,&portGroupsBmp) == GT_TRUE)
            {
                continue;
            }

            st = prvUtfDeviceFamilyGet(dev, &devFamily);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,"prvUtfDeviceFamilyGet: %d", dev);
            /*
                1.1. Set rule for testing.
                Expected: GT_OK.
            */
            st = pclRuleTestingDefaultSet(dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChPclPortGroupRuleSet: %d", dev);

            /*
                1.2. Call with ruleSize [CPSS_PCL_RULE_SIZE_STD_E /
                                         CPSS_PCL_RULE_SIZE_EXT_E],
                               ruleIndex [PCL_TCAM_RAWS(dev) - 1],
                               non-NULL validPtr
                               and non-NULL ruleSizePtr.
                Expected: GT_OK.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_TRUE)
               ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
            else
                ruleIndex = PCL_TCAM_RAWS(dev) - 1;

            /*call with ruleSize  = CPSS_PCL_RULE_SIZE_EXT_E;*/
            ruleSize  = CPSS_PCL_RULE_SIZE_EXT_E;

            st = cpssDxChPclPortGroupRuleAnyStateGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                    ruleSize, ruleIndex, &valid, &ruleSize);
            if ((st == GT_BAD_STATE) && (devFamily >= CPSS_PP_FAMILY_CHEETAH3_E))
            {
                /* Ch3 and above inititial TCAM state */
                st = GT_OK;
            }
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);


            /*call with ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;*/
            ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;

            st = cpssDxChPclPortGroupRuleAnyStateGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                    ruleSize, ruleIndex, &valid, &ruleSize);

            if ((st == GT_BAD_STATE) && (devFamily >= CPSS_PP_FAMILY_CHEETAH3_E))
            {
                /* Ch3 and above inititial TCAM state */
                st = GT_OK;
            }
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);


            /*
                1.3. Call with out of range ruleIndex [1024], and other parameters same as in 1.2.
                Expected: NON GT_OK.
            */
            ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

            st = cpssDxChPclPortGroupRuleAnyStateGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                     ruleSize, ruleIndex, &valid, &ruleSize);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleIndex);

            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

            /*
                1.4. Call with validPtr [NULL], and other parameters same as in 1.2.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleAnyStateGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                     ruleSize, ruleIndex, NULL, &ruleSize);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PTR, st,
                                            "%d, %d, validPtr = NULL", dev, ruleIndex);

            /*
                1.5. Call with ruleSizePtr [NULL], and other parameters same as in 1.2.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleAnyStateGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                    ruleSize, ruleIndex, &valid, NULL);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PTR, st, "%d, %d, ruleSizePtr = NULL",
                                         dev, ruleIndex);

            /*
                1.6. Call cpssDxChPclPortGroupRuleInvalidate with
                    ruleSize [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX]
                    to cleanup after testing.
                Expected: GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "cpssDxChPclPortGroupRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);

            /*
                1.7. Get state for invalidated rule.
                     Call with ruleIndex [PCL_TESTED_RULE_INDEX],
                     non-NULL validPtr and non-NULL ruleSizePtr.
                Expected: GT_OK, validPtr = GT_FALSE.
            */
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            st = cpssDxChPclPortGroupRuleAnyStateGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                    ruleSize, ruleIndex, &valid, &ruleSize);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupRuleAnyStateGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                ruleSize, ruleIndex, &valid, &ruleSize);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupRuleAnyStateGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                                 ruleIndex, &valid, &ruleSize);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* Set valid parameters. As soon as family of device can't be determined */
    /* - values valid for any family                                         */
    ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
    ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclPortGroupRuleAnyStateGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                ruleSize, ruleIndex, &valid, &ruleSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupRuleAnyStateGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                            ruleSize, ruleIndex, &valid, &ruleSize);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupRuleCopy
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN CPSS_DXCH_PCL_RULE_SIZE_ENT        ruleSize,
    IN GT_U32                             ruleSrcIndex,
    IN GT_U32                             ruleDstIndex
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleCopy)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(dxChx)

    1.1. Set rule for testing. Call cpssDxChPclPortGroupRuleSet with ruleFormat
    [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E], ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr->
    ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00], patternPtr-> ruleStdNotIp [ common[pclId=0;
    sourcePort=5; isTagged=1; vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1;
    isUdbValid =1], isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
    macSa=AB:CD:EF:00:00:01; udb[10,20,30] ], actionPtr [ pktCmd =
    CPSS_PACKET_CMD_FORWARD_E, mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
    matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 }, qos {
    egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE , qos [
    ingress[profileIndex=0, profileAssignIndex=GT_FALSE, profilePrecedence=GT_FALSE] ] },
    redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E, data[routerLttIndex=0] },
    policer { policerEnable=GT_FALSE, policerId=0 }, vlan { egressTaggedModify=GT_FALSE,
    modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE, vlanId=100,
    precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E }, ipUcRoute {
    doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
    Expected: GT_OK.

    1.2. Try to copy with ruleSize which isn't applicable
    for standard rule. Call with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], ruleSrcIndex
    [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
    Expected: NON GT_OK.

    1.3. Try to copy with invalid enum value for ruleSize. Call with ruleSize [wrong enum
    values], ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
    Expected: GT_BAD_PARAM.

    1.4. Try to copy with out of range source rule index. Call with ruleSize
    [CPSS_PCL_RULE_SIZE_STD_E], ruleSrcIndex [1024], ruleDstIndex [0].
    Expected: NON GT_OK.

    1.5. Try to copy with out of range destination rule index. Call with ruleSize
    [CPSS_PCL_RULE_SIZE_STD_E], ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [1024].
    Expected: NON GT_OK.

    1.6. For all active devices try to copy with legal parameters. Call with ruleSize
    [CPSS_PCL_RULE_SIZE_STD_E], ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
    Expected: GT_OK

    1.7. Invalidate source rule. Call cpssDxChPclPortGroupRuleInvalidate with
    ruleSize [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX].
    Expected: GT_OK.

    1.8. Invalidate destination rule. Call cpssDxChPclPortGroupRuleInvalidate with
    ruleSize [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [0].
    Expected: GT_OK.
*/
    GT_STATUS               st = GT_OK;
    GT_U8                   dev;
    GT_PORT_GROUPS_BMP      portGroupsBmp = 1;
    GT_U32                  ruleSrcIndex = 0;
    GT_U32                  ruleDstIndex = 0;
    CPSS_PCL_RULE_SIZE_ENT  ruleSize = CPSS_PCL_RULE_SIZE_STD_E;

    GT_U32    portGroupId;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = pclRulesForCopyAndStatusTesting(dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(
            GT_OK, st, "pclRulesForCopyAndStatusTesting: %d", dev);

        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /* check and skip not valid port groups */
            if (prvUtfPclActivePortGroupCheck(dev,portGroupId,&portGroupsBmp) == GT_TRUE)
            {
                continue;
            }

            /*
                1.1. set rule for testing.
                Call cpssDxChPclPortGroupRuleSet with
                ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00],
                patternPtr-> ruleStdNotIp [ common[pclId=0; sourcePort=5; isTagged=1;
                vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1; isUdbValid =1],
                isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
                macSa=AB:CD:EF:00:00:01; udb[10,20,30] ],
                actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
                mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
                matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
                qos { egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE ,
                qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
                profilePrecedence=GT_FALSE] ] },
                redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                data[routerLttIndex=0] }, policer { policerEnable=GT_FALSE, policerId=0 },
                vlan { egressTaggedModify=GT_FALSE,
                modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
                vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
                ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
                Expected: GT_OK. */


            /*
                1.2. Try to copy with ruleSize which isn't applicable for standard rule.
                Call with ruleSize [CPSS_DXCH_PCL_RULE_SIZE_EXT_E],
                ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
                Expected: NON GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;
            ruleSrcIndex = PCL_DAMAGED_EXT_RULE_INDEX_MAC(dev);
            ruleDstIndex = 0;

            st = cpssDxChPclPortGroupRuleCopy(dev, portGroupsBmp,  mainUtCpssDxChPclTcamIndex,
                                            ruleSize, ruleSrcIndex, ruleDstIndex);
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, dev, ruleSize,
                                            ruleSrcIndex, ruleDstIndex);

            /*
                1.3. Try to copy with invalid enum value for ruleSize.
                Call with ruleSize [wrong enum values],
                ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleCopy
                                (dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleSrcIndex, ruleDstIndex),
                                ruleSize);

            /*
                1.4. Try to copy with out of range source rule index. Call with ruleSize
                [CPSS_DXCH_PCL_RULE_SIZE_STD_E], ruleSrcIndex [wrong value], ruleDstIndex [0].
                Expected: NON GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleSrcIndex = PCL_INVALID_STD_RULE_INDEX(dev);
            ruleDstIndex = 0;

            st = cpssDxChPclPortGroupRuleCopy(dev, portGroupsBmp,  mainUtCpssDxChPclTcamIndex,
                                            ruleSize, ruleSrcIndex, ruleDstIndex);
            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleSrcIndex);

            ruleSrcIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            /*
                1.5. For Cheetah devices try to copy with out of range
                destination rule index. Call with ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E],
                ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [wrong value].
                Expected: NON GT_OK.
            */
            ruleDstIndex = PCL_INVALID_STD_RULE_INDEX(dev);

            st = cpssDxChPclPortGroupRuleCopy(dev, portGroupsBmp,  mainUtCpssDxChPclTcamIndex,
                                            ruleSize, ruleSrcIndex, ruleDstIndex);
            UTF_VERIFY_NOT_EQUAL4_PARAM_MAC(GT_OK, st, dev, ruleSize,
                                            ruleSrcIndex, ruleDstIndex);
            ruleDstIndex = 0;

            /*
                1.6. For all active devices try to copy with legal parameters.
                Call with ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E],
                ruleSrcIndex [PCL_TESTED_RULE_INDEX], ruleDstIndex [0].
                Expected: GT_OK
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleSrcIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);
            ruleDstIndex = 0;

            st = cpssDxChPclPortGroupRuleCopy(dev, portGroupsBmp,  mainUtCpssDxChPclTcamIndex,
                                            ruleSize, ruleSrcIndex, ruleDstIndex);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                 "device: %d, %d, %d, %d", dev, ruleSize, ruleSrcIndex, ruleDstIndex);

            /*
                1.7. Invalidate source rule. Call cpssDxChPclPortGroupRuleInvalidate
                with ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX].
                Expected: GT_OK.
            */

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleSrcIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
               "cpssDxChPclPortGroupRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleSrcIndex);

            /*
                1.8. Invalidate destination rule. Call cpssDxChPclPortGroupRuleInvalidate
                with ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E], ruleIndex [0].
                Expected: GT_OK.
            */
            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleDstIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                "cpssDxChPclPortGroupRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleDstIndex);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupRuleCopy(dev, portGroupsBmp,  mainUtCpssDxChPclTcamIndex,
                                        ruleSize, ruleSrcIndex, ruleDstIndex);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupRuleCopy(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                          ruleSrcIndex, ruleDstIndex);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    ruleSrcIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);
    ruleDstIndex = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclPortGroupRuleCopy(dev, portGroupsBmp,  mainUtCpssDxChPclTcamIndex,
                                        ruleSize, ruleSrcIndex, ruleDstIndex);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupRuleCopy(dev, portGroupsBmp,  mainUtCpssDxChPclTcamIndex,
                                        ruleSize, ruleSrcIndex, ruleDstIndex);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupRuleGet
(
    IN  GT_U8                  devNum,
    IN  GT_PORT_GROUPS_BMP     portGroupsBmp,
    IN  CPSS_PCL_RULE_SIZE_ENT ruleSize,
    IN  GT_U32                 ruleIndex,
    OUT GT_U32                 mask[],
    OUT GT_U32                 pattern[],
    OUT GT_U32                 action[]
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleGet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(dxChx)

    1.1. Set rule for testing. Call cpssDxChPclPortGroupRuleSet with ruleFormat
    [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E], ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr->
    ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ], patternPtr-> ruleStdNotIp [ common[pclId=0;
    sourcePort=5; isTagged=1; vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1;
    isUdbValid =1], isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
    macSa=AB:CD:EF:00:00:01; udb[10,20,30] ], actionPtr [ pktCmd =
    CPSS_PACKET_CMD_FORWARD_E, mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
    matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 }, qos {
    egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE , qos [
    ingress[profileIndex=0, profileAssignIndex=GT_FALSE, profilePrecedence=GT_FALSE] ] },
    redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E, data[routerLttIndex=0] },
    policer { policerEnable=GT_FALSE, policerId=0 }, vlan { egressTaggedModify=GT_FALSE,
    modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE, vlanId=100,
    precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E }, ipUcRoute {
    doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
    Expected: GT_OK.

    1.2. Check with legal parameters. Call with ruleSize
    [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX], non-NULL mask, pattern and action.
    Expected: GT_OK

    1.3. Check for invalid ruleSize for rule which was written as standard rule. Call
    with invalid ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], other params same as in 1.2.
    Expected: NON GT_OK.

    1.4. Check for out-of-range enum ruleSize. call with ruleSize [wrong enum values],
    other params same as in 1.2.
    Expected: GT_BAD_PARAM.

    1.5. Check out of range ruleIndex. Call with ruleIndex [1024], other parameters same as in 1.2.
    Expected: NON GT_OK.

    1.6. Check for NULL pointer. For call with mask [NULL], other parameters same as in 1.2.
    Expected: GT_BAD_PTR.

    1.7. Check for NULL pointer. For call with pattern [NULL], other parameters same as in 1.2.
    Expected: GT_BAD_PTR.

    1.8. Check for NULL pointer. For call with action [NULL], other parameters same as in 1.2.
    Expected: GT_BAD_PTR.

    1.9. Call cpssDxChPclPortGroupRuleInvalidate with ruleSize
    [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
    Expected: GT_OK.

    1.10. Try to get invalidated rule. call with all params same as in 1.2. (ruleIndex [PCL_TESTED_RULE_INDEX])
    Expected: non GT_OK.
*/
    GT_STATUS st = GT_OK;

    GT_U8                   dev;
    GT_PORT_GROUPS_BMP      portGroupsBmp = 1;
    CPSS_PCL_RULE_SIZE_ENT  ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    GT_U32                  ruleIndex = 0;
    GT_U32                  mask[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS];
    GT_U32                  pattern[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS];
    GT_U32                  action[CPSS_DXCH_PCL_ACTION_SIZE_IN_WORDS_CNS];

    GT_U32    portGroupId;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = pclRulesForCopyAndStatusTesting(dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(
            GT_OK, st, "pclRulesForCopyAndStatusTesting: %d", dev);

       /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /* check and skip not valid port groups */
            if (prvUtfPclActivePortGroupCheck(dev,portGroupId,&portGroupsBmp) == GT_TRUE)
            {
                continue;
            }

            /*
                1.1. Set rule for testing.  Call cpssDxChPclPortGroupRuleSet with
                ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ],
                patternPtr-> ruleStdNotIp [ common[pclId=0; sourcePort=5; isTagged=1;
                vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1; isUdbValid =1],
                isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
                macSa=AB:CD:EF:00:00:01; udb[10,20,30] ],
                actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
                mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
                matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
                qos { egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE ,
                qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
                profilePrecedence=GT_FALSE] ] },
                redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                data[routerLttIndex=0] }, policer { policerEnable=GT_FALSE, policerId=0 },
                vlan { egressTaggedModify=GT_FALSE,
                modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
                vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
                ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
                Expected: GT_OK.
            */

            /*
                1.2. Check with legal parameters. Call with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                ruleIndex [PCL_TESTED_RULE_INDEX], non-NULL mask, pattern and action.
                Expected: GT_OK
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);

            st = cpssDxChPclPortGroupRuleGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                            ruleIndex, mask, pattern, action);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "device: %d, %d, %d", dev, ruleSize, ruleIndex);

            /*
                1.3. Check for invalid ruleSize for rule which was written as standard rule.
                Call with invalid ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], other params same as in 1.2.
                Expected: NON GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;
            ruleIndex = PCL_DAMAGED_EXT_RULE_INDEX_MAC(dev);

            st = cpssDxChPclPortGroupRuleGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                            ruleIndex, mask, pattern, action);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleSize);

            ruleSize = CPSS_PCL_RULE_SIZE_STD_E; /* restore valid value */

            /*
                1.4. Check for wrong enum values ruleSize and other params same as in 1.2.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleGet
                                (dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, mask, pattern, action),
                                ruleSize);

            /*
                1.5. check out of range ruleIndex.
                Call with ruleIndex [wrong value], other parameters same as in 1.2.
                Expected: NON GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

            st = cpssDxChPclPortGroupRuleGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                            ruleIndex, mask, pattern, action);
            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

            /*
                1.6. Call with mask [NULL], other parameters same as in 1.2.
                Expected: GT_BAD_PTR.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            st = cpssDxChPclPortGroupRuleGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                            ruleIndex, NULL, pattern, action);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, mask = NULL", dev);

            /*
                1.7. Call with pattern [NULL], other parameters same as in 1.2.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                            ruleIndex, mask, NULL, action);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, pattern = NULL", dev);

            /*
                1.8. Call with action [NULL], other parameters same as in 1.2.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                            ruleIndex, mask, pattern, NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, action = NULL", dev);

            /*
                1.9. Call cpssDxChPclPortGroupRuleInvalidate with
                        ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                        ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
                Expected: GT_OK.
            */

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                   "cpssDxChPclPortGroupRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupRuleGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                            ruleIndex, mask, pattern, action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupRuleGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex,
                                             mask, pattern, action);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    ruleIndex = 0;
    ruleSize = CPSS_PCL_RULE_SIZE_STD_E;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclPortGroupRuleGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                            ruleIndex, mask, pattern, action);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupRuleGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                        ruleIndex, mask, pattern, action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupRuleInvalidate
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN CPSS_DXCH_PCL_RULE_SIZE_ENT        ruleSize,
    IN GT_U32                             ruleIndex
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleInvalidate)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(dxChx)

    1.1. Set rule for testing. Call cpssDxChPclPortGroupRuleSet with ruleFormat
    [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E], ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr->
    ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ], patternPtr-> ruleStdNotIp [ common[pclId=0;
    sourcePort=5; isTagged=1; vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1;
    isUdbValid =1], isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
    macSa=AB:CD:EF:00:00:01; udb[10,20,30] ], actionPtr [ pktCmd =
    CPSS_PACKET_CMD_FORWARD_E, mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
    matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 }, qos {
    egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE , qos [
    ingress[profileIndex=0, profileAssignIndex=GT_FALSE, profilePrecedence=GT_FALSE] ] },
    redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E, data[routerLttIndex=0] },
    policer { policerEnable=GT_FALSE, policerId=0 }, vlan { egressTaggedModify=GT_FALSE,
    modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE, vlanId=100,
    precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E }, ipUcRoute {
    doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
    Expected: GT_OK.

    1.2. Check for invalid ruleSize for rule which was written as standard rule. Call
    with invalid ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], ruleIndex [PCL_TESTED_RULE_INDEX].
    Expected: NON GT_OK.

    1.3. Check for invalid enum value for ruleSize.
    Call with ruleSize [wrong enum values], ruleIndex [PCL_TESTED_RULE_INDEX].
    Expected: GT_BAD_PARAM.

    1.4. Check for out of range ruleIndex. Call with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
    ruleIndex [1024].
    Expected: NON GT_OK.

    1.5. Invalidate written rule with legal parameters. Call with ruleSize
    [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX].
    Expected: GT_OK.
*/
    GT_STATUS               st = GT_OK;
    GT_U8                   dev;
    GT_PORT_GROUPS_BMP      portGroupsBmp = 1;
    CPSS_PCL_RULE_SIZE_ENT  ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    GT_U32                  ruleIndex = 0;

    GT_U32    portGroupId;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /* check and skip not valid port groups */
            if (prvUtfPclActivePortGroupCheck(dev,portGroupId,&portGroupsBmp) == GT_TRUE)
            {
                continue;
            }

            /*
                1.1. Set rule for testing. Call cpssDxChPclPortGroupRuleSet with
                ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ],
                patternPtr-> ruleStdNotIp [ common[pclId=0; sourcePort=5; isTagged=1;
                vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1; isUdbValid =1],
                isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
                macSa=AB:CD:EF:00:00:01; udb[10,20,30] ],
                actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
                mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
                matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
                qos { egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE ,
                qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
                profilePrecedence=GT_FALSE] ] },
                redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                data[routerLttIndex=0] }, policer { policerEnable=GT_FALSE, policerId=0 },
                vlan { egressTaggedModify=GT_FALSE,
                modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
                vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
                ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
                Expected: GT_OK.
            */

            st = pclRuleTestingDefaultSet(dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPclPortGroupRuleSet: device: %d", dev);

            /*
                1.2. Check for invalid ruleSize for rule
                which was written as standard rule. Call with invalid
                ruleSize [CPSS_DXCH_PCL_RULE_SIZE_EXT_E], ruleIndex [PCL_TESTED_RULE_INDEX].
                Expected: GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;
            ruleIndex = PCL_TCAM_RAWS(dev) - 1;

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

            /*
                1.3. Invalidate written rule with legal parameters.
                Call with ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX].
                Expected: GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);

            /*
                1.4. Check for invalid enum value for
                ruleSize. Call with ruleSize [wrong enum values], ruleIndex [PCL_TESTED_RULE_INDEX].
                Expected: GT_BAD_PARAM.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_FALSE)
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleInvalidate
                                    (dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex),
                                    ruleSize);
            }

            /*
                1.5. Check for out of range ruleIndex.
                Call with ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E], ruleIndex [wrong value].
                Expected: NON GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
        ruleIndex = 0;

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    ruleIndex = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupRuleSet
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat,
    IN GT_U32                             ruleIndex,
    IN CPSS_DXCH_PCL_RULE_OPTION_ENT      ruleOptionsBmp,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT      *maskPtr,
    IN CPSS_DXCH_PCL_RULE_FORMAT_UNT      *patternPtr,
    IN CPSS_DXCH_PCL_ACTION_STC           *actionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleSet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(dxChx)

    1.1. Check standard rule for all active devices with legal parameters.
    Call with   ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                ruleIndex [PCL_TESTED_RULE_INDEX],
                maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ],
                patternPtr-> ruleStdNotIp [ common[pclId=0;
                                                    sourcePort=5;
                                                    isTagged=1;
                                                    vid=100;
                                                    up=0;
                                                    qosProfile=0;
                                                    isIp=0;
                                                    isL2Valid=1;
                                                    isUdbValid =1],
                                            isIpv4 = 0;
                                            etherType=0;
                                            isArp=0;
                                            l2Encap=0;
                                            macDa=AB:CD:EF:00:00:02;
                                            macSa=AB:CD:EF:00:00:01;
                                            udb[10,20,30] ],
                actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
                            mirror{cpuCode = 0,
                                   analyzerPortIndex = GT_FALSE},
                            matchCounter { enableMatchCount = GT_FALSE,
                                           matchCounterIndex = 0 },
                            qos { egressPolicy=GT_FALSE,
                                  modifyDscp=GT_FALSE,
                                  modifyUp=GT_FALSE ,
                            qos [ ingress[profileIndex=0,
                                  profileAssignIndex=GT_FALSE,
                                  profilePrecedence=GT_FALSE] ] },
                            redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                            data[routerLttIndex=0] },
                            policer { policerEnable=GT_FALSE, policerId=0 },
                            vlan {  egressTaggedModify=GT_FALSE,
                                    modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E,
                                    nestedVlan=GT_FALSE,
                                    vlanId=100,
                                    precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
                            ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
    Expected: GT_OK

    1.2. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], valid
        actionPtr->flowId[100](is relevant) and other params same as 1.1.
    Expected: GT_OK.

    1.3. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
        actionPtr->oam.offsetIndex[15], actionPtr->oam.oamProcessEnable[GT_TRUE],
        actionPtr->oam.oamProfile[1] and other params same as 1.1.
    Expected: GT_OK.

    1.4. Check for out of range ruleIndex for standard rule format.
    Call with ruleIndex [1024], other parameters is the same as in 1.1.
    Expected: NON GT_OK.

    1.5. Call with out of range actionPtr->matchCounter.matchCounterIndex [32]
    and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for other.

    1.6. For Ch3 and above call with out of range
    actionPtr->matchCounter.matchCounterIndex [16384] and other params from 1.1.
    Expected: NOT GT_OK.

    1.7. Call with out of range actionPtr->policer.policerId [256] and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for other.

    1.8. For non ch1/ch2 call with out of range actionPtr->policer.policerId [4096]
    and other params from 1.1.
    Expected: NOT GT_OK.

    1.9. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                   actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                   out of range actionPtr->redirect.outIf.tunnelPtr[1024]
                   and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.

    1.10. For Ch3 and above call with actionPtr->redirect.redirectCmd
                   [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                   actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                   out of range actionPtr->redirect.outIf.tunnelPtr[8192]
                   and other params from 1.1.
    Expected: NOT GT_OK.

    1.11. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                   out of range actionPtr->redirect.data.routerLttIndex[8192]
                   and other params from 1.1.
    Expected: NOT GT_OK for Ch1/Ch2/Ch3 and GT_OK for other.

    1.12. For xCat and above call with actionPtr->redirect.redirectCmd
                   [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                   out of range actionPtr->redirect.data.routerLttIndex[32768]
                   and other params from 1.1.
    Expected: NOT GT_OK.

    1.13. For Ch3  and above call with
          actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E],
          out of range actionPtr->redirect.data.vrfId [4096] and other params from 1.1.
    Expected: NOT GT_OK.

    1.14. Call with actionPtr->vlan.ingress.modifyVlan [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
                   out of range actionPtr->vlan.ingress.vlanId [4096]
                   and other params from 1.1.
    Expected: NOT GT_OK.

    1.15. For Ch3 and above call with out of range actionPtr->sourceId.sourceIdValue [32]
                   and other params from 1.1.
    Expected: NOT GT_OK.
    1.16. Call with out of range actionPtr->pktCmd
    Expected: GT_BAD_PARAM
    1.17. Call with not valid actionPtr->pktCmd
                                  [CPSS_PACKET_CMD_ROUTE_E
                                   CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E
                                   CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E
                                   CPSS_PACKET_CMD_BRIDGE_E ]
    Expected: NOT GT_OK
    1.18. Call with out of range actionPtr->lookupConfig.pcl0_1OverrideConfigIndex,
          other parameters is the same as in 1.1.
    Expected: GT_BAD_PARAM for DxCh3 and above
    1.19. Call with out of range actionPtr->lookupConfig.pcl1OverrideConfigIndex,
          other parameters is the same as in 1.1.
    Expected: GT_BAD_PARAM
    1.20. Call with out of range actionPtr->mirror.cpuCode
    Expected: GT_BAD_PARAM
    1.21. Call with out of range actionPtr->mirror.ingressMirrorToAnalyzerIndex[7 / 8] (relevant for Lion2)
    Expected: NOT GT_OK for Lion2 and GT_OK for others.
    1.22. Call with out of range actionPtr->qos.ingress.modifyDscp
    Expected: GT_BAD_PARAM
    1.23. Call with out of range actionPtr->qos.ingress.modifyUp
    Expected: GT_BAD_PARAM
    1.24. Call with out of range actionPtr->qos.ingress.profileIndex
                [72] for DxCh1
                [256] for Lion2
                [128] for others -- DxCh2, DxCh3, xCat, Lion, xCat2
    Expected: NOT GT_OK
    1.25. Call with valid actionPtr->qos.ingress.profileIndex
                [0 / 15 / 36 / 71] for DxCh1
                [0 / / 45 / 64 / 127 ] for DxCh2, DxCh3, xCat, Lion, xCat2
                [0 / 127 / 128 / 255] for Lion2
    Expected: GT_OK
    1.26. Call with out of range actionPtr->qos.ingress.up1Cmd
          relevant for lion2.
    Expected: GT_BAD_PARAM
    1.27. Call with out of range actionPtr->qos.ingress.up1 [8]
          relevant for lion2.
    Expected: NOT GT_OK and GT_OK for others.
    1.28. Call with out of range actionPtr->qos.egress.modifyUp
    Expected: GT_BAD_PARAM.
    1.29. Call with actionPtr->vlan.ingress.modifyVlan [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
           out of range actionPtr->vlan.ingress.vlanId1 [4096]
           and other params from 1.1.
    Expected: NOT GT_OK.
    1.30. Call with actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE],
          out of range actionPtr->ipUcRoute.arpDaIndex [1024]
          and other params from 1.1.
    Expected: NOT GT_OK.
    1.31. Call with relevant actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE],
           out of range actionPtr->ipUcRoute.arpDaIndex [0 / 512 / 1023]
           and other params from 1.1.
    Expected: NOT GT_OK.

    1.32. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_TRUE], out of range
        actionPtr->flowId[0x10000](not relevant) and other params same as 1.1.
    Expected: GT_OK.
    1.33. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], out of range
        actionPtr->flowId[0x10000](is relevant) and other params same as 1.1.
    Expected: NOT GT_OK.
    1.34. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
        actionPtr->oam.oamProcessEnable[GT_TRUE],
        actionPtr->oam.oamProfile[1], out of range actionPtr->oam.offsetIndex[16],
        and other params same as 1.1.
    Expected: NOT GT_OK.
    1.35. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
        actionPtr->oam.oamProcessEnable[GT_TRUE],
        actionPtr->oam.offsetIndex[15], out of range actionPtr->oam.oamProfile[2],
        and other params same as 1.1.
    Expected: NOT GT_OK.

    1.36. Check for NULL pointers. Call with maskPtr [NULL],
    other parameters is the same as in 1.1.
    Expected: GT_BAD_PTR.

    1.37. Check for NULL pointers. Call with patternPtr [NULL],
    other parameters is the same as in 1.1.
    Expected: GT_BAD_PTR.

    1.38. Check for NULL pointers. Call with actionPtr [NULL],
    other parameters is the same as in 1.1.
    Expected: GT_BAD_PTR.

    1.39. Check for invalid ruleFormat. Call with ruleFormat [wrong enum
    values], other parameters is the same as in 1.1.
    Expected: GT_BAD_PARAM.

    1.40. Call cpssDxChPclPortGroupRuleInvalidate with ruleSize
    [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
    Expected: GT_OK.

    1.41. Check extended rule.
    For all active device ids call with
                ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E],
                ruleIndex [511],
                maskPtr-> ruleExtNotIpv6.common is the same as in 1.1., other fileds are zeroed,
                patternPtr->ruleExtNotIpv6 [ common[the same as in 1.1],
                        commonExt[ isIpv6=0,
                                   ipProtocol=1,
                                   dscp=0,
                                   isL4Valid=1,
                                   l4Byte0=0,
                                   l4Byte1=0,
                                   l4Byte2=0,
                                   l4Byte3=0,
                                   l4Byte13=0,
                                   ipHeaderOk=1 ],
                        sip={ 64.233.167.1},
                        dip={ 213.180.204.1},
                        etherType=0,
                        l2Encap=1,
                        macDa=AB:CD:EF:00:00:02,
                        macSa=AB:CD:EF:00:00:01,
                        ipv4Fragmented=1,
                        udb[6]={10,20,30,40,50,60} ],
                 actionPtr is the same as in 1.1.
    Expected: GT_OK

    1.42. Check for out of range ruleIndex for extended rule format. Call with ruleIndex
    [512], other parameters is the same as 1.8.
    Expected: NON GT_OK.

    1.43. Set standard rule with ruleIndex which is not allowed because of extended rule
    consumes two spaces of standard rule. Call with ruleIndex [511+512], other parameters
    is the same as in 1.1.
    Expected: NON GT_OK.

    1.44. call cpssDxChPclPortGroupRuleInvalidate with ruleSize
    [CPSS_PCL_RULE_SIZE_EXT_E], ruleIndex [511] to cleanup after testing.
    Expected: GT_OK.

    1.45. Check standard EGRESS rule for all active devices with legal parameters.
    Call with   ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                ruleIndex [PCL_TESTED_RULE_INDEX],
                maskPtr-> ruleEgrStdNotIp [0xFF, , 0xFF],
                patternPtr-> ruleEgrStdNotIp [common[pclId=0;
                                                    sourcePort=5;
                                                    isTagged=1;
                                                    vid=100;
                                                    up=0;
                                                    isIp=0;
                                                    isL2Valid =1;
                                                    egrPacketType=0;
                                                    cpuCode=1;
                                                    srcTrg=1;
                                                    srcDev = 10;
                                                    sourceId = 1;
                                                    isVidx=0;
                                                    others -zeroid],
                                              isIpv4 = 0;
                                              etherType=0;
                                              isArp=0;
                                              l2Encap=0;
                                              macDa=AB:CD:EF:00:00:02;
                                              macSa=AB:CD:EF:00:00:01],
                actionPtr - the same as in 1.1.
    Expected: GT_OK for Cheetah2 and above devices.

    1.46. Check extended EGRESS rule for all active devices with legal parameters.
    Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E],
    ruleIndex [511], maskPtr-> ruleEgrExtIpv6L2 [0xFF, , 0xFF],
    patternPtr-> ruleEgrExtIpv6L2 [common [pclId=0; sourcePort=5;
                                              isTagged=1; vid=100; up=0; isIp=1; isL2Valid =1;  egrPacketType=0;
                                              cpuCode=1;srcTrg=1; srcDev = 10; sourceId = 1; isVidx=0;
                                              others -zeroid], commonExt [isIpv6=1; ipProtocol=1; dscp=2;
                                              isL4Valid=0; egrTcpUdpPortComparator=0; others- theroid]
                                                  sip[100; 1000; 10000; 100000]; dipBits127to120=0xAA;
                                              macDa=AB:CD:EF:00:00:02; macSa=AB:CD:EF:00:00:01],
                                                  actionPtr - the same as in 1.1.
                                                      Expected: GT_OK for Cheetah2 and above

    1.47. Call with ruleOptionsBmp [CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E],
        and other params as in 1.23.
    Expected: GT_OK for all devices except ch1.
    1.48. Call function with
                    ruleFormatArr [],
                    udb [10,20,30,40,...].
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.49. Call function with out of range isIpv6ExtHdrExist
          ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.50. Call function with out of range isIpv6HopByHop
          ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.51. Call function with out of range isIpv6ExtHdrExist
          ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.52. Call function with out of range isIpv6HopByHop
          ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.53. Call function with vrfId [0xA5A / BIT_12-1], isUdbValid [0]
          ruleFormat
           [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.54. Call function with out of range vrfId [BIT_8], isUdbValid [2]
          ruleFormat
           [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.55. Call function with tag1Exist [0],
                             vid1 [0 / BIT_12-1],
                             up1 [0 / 7],
                             cfi1 [0],
                             vrfId [0x5A / BIT_8-1],
                             trunkHash [0 / BIT_6-1]
          ruleFormat
           [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.56. Call function with out of range tag1Exist [2],
                                          vid1 [BIT_12],
                                          up1 [8],
                                          cfi1 [2],
                                          vrfId [BIT_12],
                                          trunkHash [BIT_6]
          ruleFormat
           [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.57. Call function with tag1Exist [0],
                             vid1 [0 / BIT_12-1],
                             up1 [0 / 7],
                             cfi1 [0],
                             vrfId [0xA5A / BIT_12-1],
                             trunkHash [0 / BIT_6-1],
                             srcPortOrTrunk [0xA5A / BIT_13-1],
                             srcIsTrunk [0]
          ruleFormat
          [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.58. Call function with out of range tag1Exist [2],
                                          vid1 [BIT_12],
                                          up1 [8],
                                          cfi1 [2],
                                          vrfId [BIT_12],
                                          trunkHash [BIT_6],
                                          srcPortOrTrunk [BIT_13],
                                          srcIsTrunk [2]
          ruleFormat
          [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.59. Call function with tag1Exist [0],
                             vid1 [0 / BIT_12-1],
                             up1 [0 / 7],
                             cfi1 [0],
                             vrfId [0xA5A / BIT_12-1],
                             trunkHash [0 / BIT_6-1],
                             srcPortOrTrunk [0xA5A / BIT_13-1],
                             srcIsTrunk [0]
          ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.60. Call function with out of range tag1Exist [2],
                                          vid1 [BIT_12],
                                          up1 [8],
                                          cfi1 [2],
                                          vrfId [BIT_12],
                                          trunkHash [BIT_6],
                                          srcPortOrTrunk [BIT_13],
                                          srcIsTrunk [2]
          ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.61. Call function with vid1 [0 / BIT_12-1],
                             up1 [0 / 7],
                             cfi1 [0]
          ruleFormat
               [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.62. Call function with out of range vid1 [BIT_12],
                                          up1 [8],
                                          cfi1 [2]
          ruleFormat
               [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.63. Call function with egressIpCommon.tag1Exist [0],
                             egressIpCommon.sourceId [10 / BIT_12-1],
                             vid1 [0 / BIT_12-1],
                             up1 [0 / 7],
                             cfi1 [0],
                             srcPort [0xA5A / BIT_13-1],
                             trgPort [0 / BIT_13-1]
          ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
          and other parameters from 1.67.
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
    1.64. Call function with out of range egressIpCommon.tag1Exist [2],
                                       egressIpCommon.sourceId [BIT_12],
                                          vid1 [BIT_12],
                                          up1 [8],
                                          cfi1 [2],
                                          srcPort [BIT_13],
                                          trgPort [BIT_13],
          ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
          and other parameters from 1.67.
    Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
    1.65. Call function with
            action{
                redirect {
                   redirectCmd [
                    CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                   data {
                       logicalSourceInterface{
                           logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                             devPort {devNum=dev, portNum=0} ]
                           sourceMeshIdSetEnable[GT_TRUE/GT_FALSE]
                           sourceMeshId[0/1/3]
                           userTagAcEnable[GT_TRUE/GT_FALSE]
                       }}},
                unknownSaCommandEnable[GT_TRUE/GT_FALSE]
                unknownSaCommand[   CPSS_PACKET_CMD_FORWARD_E /
                                    CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                    CPSS_PACKET_CMD_TRAP_TO_CPU_E /
                                    CPSS_PACKET_CMD_DROP_HARD_E /
                                    CPSS_PACKET_CMD_DROP_SOFT_E]}
            and other parameters from 1.67.
    Expected: GT_OK  for xCat C0; xCat3.

    1.66. Call function with out of range sourceMeshId [4]
           and other parameters from 1.67.
    Expected: GT_OK  for xCat C0; xCat3.

    1.67. Call function with out of range unknownSaCommand
           and other parameters from 1.67.
    Expected: GT_OK  for xCat C0; xCat3.

    1.68. For bobCat2 and above call with out of range
            actionPtr->copyReserved.copyReserved
            Expected: GT_OUT_OF_RANGE.
*/
    GT_STATUS  st = GT_OK;
    GT_U32     portGroupId;

    GT_U8                               dev;
    GT_PORT_GROUPS_BMP                  portGroupsBmp = 1;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat =
                                             CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    GT_U32                              ruleIndex = 0;
    CPSS_DXCH_PCL_RULE_OPTION_ENT       ruleOptionsBmp = 0;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT       mask;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT       pattern;
    CPSS_DXCH_PCL_ACTION_STC            action;
    GT_ETHERADDR                        mac1 = {{0xAB, 0xCD, 0xEF, 0x00, 0x00, 0x01}};
    GT_ETHERADDR                        mac2 = {{0xAB, 0xCD, 0xEF, 0x00, 0x00, 0x02}};

    CPSS_PP_FAMILY_TYPE_ENT             devFamily;
    CPSS_PCL_RULE_SIZE_ENT              ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
    GT_BOOL                     support_doIpUcRoute;/*indication that current device supports 'doIpUcRoute' */
    GT_U32                      ruleFlags = 0;
    GT_U32                      usePortsBmp = 0;
    static CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT        ruleFormatArr[] =
    {
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E,

    };
    GT_U32                              index = 0;
    pclActionDefaultSet(&action);

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {

        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,"prvUtfDeviceFamilyGet: %d", dev);

        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            support_doIpUcRoute = GT_FALSE;
        }
        else
        {
            support_doIpUcRoute = GT_TRUE;
        }

        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /* check and skip not valid port groups */
            if (prvUtfPclActivePortGroupCheck(dev,portGroupId,&portGroupsBmp) == GT_TRUE)
            {
                continue;
            }

            /* 1.1. Check standard rule for all active devices with legal
            parameters. Call with
            ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
            ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ],
            patternPtr-> ruleStdNotIp [ common[pclId=0; sourcePort=5; isTagged=1;
            vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1; isUdbValid =1],
            isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
            macSa=AB:CD:EF:00:00:01; udb[10,20,30] ],
            actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
            mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
            matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
            qos { egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE ,
            qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
            profilePrecedence=GT_FALSE] ] },
            redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
            data[routerLttIndex=0] }, policer { policerEnable=GT_FALSE, policerId=0 },
            vlan { egressTaggedModify=GT_FALSE,
            modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
            vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
            ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
            Expected: GT_OK for  devices and GT_BAD_PARAM for others. */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            action.egressPolicy = GT_FALSE;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
            ruleOptionsBmp = 0;

            cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
            pattern.ruleStdNotIp.common.pclId = 0;
            pattern.ruleStdNotIp.common.sourcePort = 5;
            pattern.ruleStdNotIp.common.isTagged = 1;
            pattern.ruleStdNotIp.common.vid = 100;
            pattern.ruleStdNotIp.common.up = 0;
            pattern.ruleStdNotIp.common.qosProfile = 0;
            pattern.ruleStdNotIp.common.isIp = 0;
            pattern.ruleStdNotIp.common.isL2Valid = 1;
            pattern.ruleStdNotIp.common.isUdbValid = 1;
            pattern.ruleStdNotIp.isIpv4 = 0;
            pattern.ruleStdNotIp.etherType = 0;
            pattern.ruleStdNotIp.isArp = 0;
            pattern.ruleStdNotIp.l2Encap = 0;
            pattern.ruleStdNotIp.macDa = mac2;
            pattern.ruleStdNotIp.macSa = mac1;
            pattern.ruleStdNotIp.udb15_17[0] = 10;
            pattern.ruleStdNotIp.udb15_17[1] = 20;
            pattern.ruleStdNotIp.udb15_17[2] = 30;

            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            mask.ruleStdNotIp = pattern.ruleStdNotIp;
            mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/
            mask.ruleStdNotIp.common.sourcePort = 0x3F;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "device: %d, %d, %d", dev, ruleFormat, ruleIndex);

            /*
                1.2. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], valid
                    actionPtr->flowId[100](is relevant) and other params same as 1.1.
                Expected: GT_OK.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.egressPolicy = GT_FALSE;
                action.flowId  = 100;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                 ruleIndex, ruleOptionsBmp,
                                                 &mask, &pattern, &action);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);

            /*
                1.3. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                    actionPtr->oam.offsetIndex[15], actionPtr->oam.oamProcessEnable[GT_TRUE],
                    actionPtr->oam.oamProfile[1] and other params same as 1.1.
                Expected: GT_OK.
            */

                action.oam.timeStampEnable = GT_TRUE;
                action.oam.offsetIndex  = 15;
                action.oam.oamProcessEnable = GT_TRUE;
                action.oam.oamProfile = 1;

                st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex,
                                        ruleOptionsBmp, &mask, &pattern, &action);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);
            }

            /*
                1.4. Check for out of range ruleIndex for standard rule format.
                Call with ruleIndex [1024], other parameters is the same as in 1.1.
                Expected: NON GT_OK.
            */
            ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

            /*
                1.5. Call with out of range actionPtr->matchCounter.matchCounterIndex [32]
                   and other params from 1.1.
                Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for other.
            */
            action.matchCounter.enableMatchCount = GT_TRUE;
            action.matchCounter.matchCounterIndex = 32;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->matchCounter.matchCounterIndex = %d",
                    dev, ruleFormat, ruleIndex, action.matchCounter.matchCounterIndex);

            /*
                1.6. For not ch1/ch2 call with out of range
                actionPtr->matchCounter.matchCounterIndex [32768] and other params from 1.1.
                Expected: NOT GT_OK.
            */
            action.matchCounter.matchCounterIndex = 16384;
            if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                action.matchCounter.matchCounterIndex = 32768;
            }

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->matchCounter.matchCounterIndex = %d",
                    dev, ruleFormat, ruleIndex, action.matchCounter.matchCounterIndex);

            action.matchCounter.matchCounterIndex = 0; /* restore valid value */

            /*
                1.7. Call with out of range actionPtr->policer.policerId [256]
                               and other params from 1.1.
                Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for other.
            */
            action.policer.policerEnable = GT_TRUE;
            action.policer.policerId = 256;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->policer.policerId = %d",
                            dev, ruleFormat, ruleIndex, action.policer.policerId);

            /*
                1.8. For non ch1/ch2 call with out of range
                actionPtr->policer.policerId [4096] and other params from 1.1.
                Expected: NOT GT_OK.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.policer.policerId = BIT_16;
            }
            else
            {
                action.policer.policerId = BIT_12;
            }

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->policer.policerId = %d",
                            dev, ruleFormat, ruleIndex, action.policer.policerId);

            action.policer.policerId = 0; /* restore valid value */

            /*
                1.9. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                               actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                               out of range actionPtr->redirect.outIf.tunnelPtr[1024]
                               and other params from 1.1.
                Expected: NOT GT_OK for Ch1/Ch2 and GT_OK for Ch3 and above.
            */
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E;
            action.redirect.data.outIf.tunnelStart = GT_TRUE;
            action.redirect.data.outIf.tunnelPtr = MAX_TUNNEL_PTR(dev) - 1;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern,&action);

            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->redirect.data.outIf.tunnelPtr = %d",
                      dev, ruleFormat, ruleIndex, action.redirect.data.outIf.tunnelPtr);

            /*
                1.10. For Ch3 and above call with actionPtr->redirect.redirectCmd
                                [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E],
                               actionPtr->redirect.outIf.tunnelStart[GT_TRUE],
                               out of range actionPtr->redirect.outIf.tunnelPtr[8192]
                               and other params from 1.1.
                Expected: NOT GT_OK.
            */
            action.redirect.data.outIf.tunnelPtr = MAX_TUNNEL_PTR(dev);

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern,&action);

            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                "%d, %d, %d, actionPtr->redirect.data.outIf.tunnelPtr = %d",
                      dev, ruleFormat, ruleIndex, action.redirect.data.outIf.tunnelPtr);

            action.redirect.data.outIf.tunnelPtr = 0; /* restore valid value */

            /* [TBD] The test must check PRV_CPSS_DXCH_PP_MAC(dev)->moduleCfg.ip.maxNumOfPbrEntries > 0 condition.
               In Ironman the default number of PBR entries is set to 0 */

            /*
                1.11. Call with actionPtr->redirect.redirectCmd [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                               out of range actionPtr->redirect.data.routerLttIndex[8192]
                               and other params from 1.1.
                Expected: NOT GT_OK for Ch1/Ch2/ch3.
            */
            action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E;
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                action.redirect.data.routerLttIndex = PRV_CPSS_DXCH_PP_MAC(dev)->moduleCfg.ip.maxNumOfPbrEntries-1;
            }
            else
            {
                action.redirect.data.routerLttIndex = 8192;
            }
            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            if ((devFamily <= CPSS_PP_FAMILY_CHEETAH3_E)
                || (devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E))
            {
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                          dev, ruleFormat, ruleIndex, action.redirect.data.routerLttIndex);
            }
            else
            {
                 UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                                                 "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                                                 dev, ruleSize, ruleIndex, action.redirect.data.routerLttIndex);

                /*
                    1.12. For xCat and above call with actionPtr->redirect.redirectCmd
                    [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_ROUTER_E],
                    out of range actionPtr->redirect.data.routerLttIndex[32768]
                    and other params from 1.1.
                    Expected: NOT GT_OK.
                */
                if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
                {
                    action.redirect.data.routerLttIndex = PRV_CPSS_DXCH_PP_MAC(dev)->moduleCfg.ip.maxNumOfPbrEntries;
                }
                else
                {
                    action.redirect.data.routerLttIndex = BIT_15;
                }

                st = cpssDxChPclPortGroupRuleSet(
                    dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                    ruleFormat, ruleIndex, ruleOptionsBmp,
                    &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->redirect.data.routerLttIndex = %d",
                           dev, ruleFormat, ruleIndex, action.redirect.data.routerLttIndex);
            }

            action.redirect.data.routerLttIndex = 0; /* restore valid value */

            /*
                1.13. For Ch3 and above call with actionPtr->redirect.redirectCmd
                [CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E],
                out of range actionPtr->redirect.data.vrfId [4096] and other params from 1.1.
                Expected: NOT GT_OK.
            */
            if ((devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
                && (devFamily != CPSS_PP_FAMILY_DXCH_XCAT2_E))
            {
                action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_VIRT_ROUTER_E;
                action.redirect.data.vrfId = BIT_12;

                st = cpssDxChPclPortGroupRuleSet(
                    dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                    ruleFormat, ruleIndex, ruleOptionsBmp,
                    &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                        "%d, %d, %d, actionPtr->redirect.data.vrfId= %d",
                               dev, ruleFormat, ruleIndex, action.redirect.data.vrfId);

                action.redirect.data.vrfId = 0; /* restore valid value */
            }

            if (devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
            {
                action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E;
            }

            /*
                1.14. Call with actionPtr->vlan.ingress.modifyVlan [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
                               out of range actionPtr->vlan.ingress.vlanId [4096]
                               and other params from 1.1.
                Expected: NOT GT_OK.
            */
            action.vlan.ingress.modifyVlan = CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E;
            action.vlan.ingress.vlanId = UTF_CPSS_PP_MAX_VLAN_NUM_CNS(dev);

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->vlan.ingress.vlanId = %d",
                           dev, ruleFormat, ruleIndex, action.vlan.ingress.vlanId);

            action.vlan.ingress.vlanId = 100; /* restore valid value */

            /*
                1.15. For Ch3 and above call with out of range
                actionPtr->sourceId.sourceIdValue [32] and other params from 1.1.
                Expected: NOT GT_OK.
            */
            if(devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
            {
                action.sourceId.assignSourceId = GT_TRUE;
                action.sourceId.sourceIdValue = UTF_CPSS_PP_MAX_SRC_ID_NUM_MAC(dev);

                st = cpssDxChPclPortGroupRuleSet(
                    dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                    ruleFormat, ruleIndex, ruleOptionsBmp,
                    &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                        "%d, %d, %d, actionPtr->sourceId.sourceIdValue = %d",
                                dev, ruleFormat, ruleIndex, action.sourceId.sourceIdValue);

                action.sourceId.sourceIdValue = 0; /* restore valid value */
            }

            /*
                1.16. Call with out of range actionPtr->pktCmd
                Expected: GT_BAD_PARAM
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleSet(
                                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action),
                                action.pktCmd);

            /*
                1.17. Call with not valid actionPtr->pktCmd
                                            [CPSS_PACKET_CMD_ROUTE_E
                                            CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E
                                            CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E
                                            CPSS_PACKET_CMD_BRIDGE_E ]
                Expected: NOT GT_OK
            */

            /* Call with CPSS_PACKET_CMD_ROUTE_E */
            action.pktCmd = CPSS_PACKET_CMD_ROUTE_E;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->action.pktCmd = %d",
                    dev, ruleFormat, ruleIndex, action.pktCmd);

            /* Call with CPSS_PACKET_CMD_ROUTE_E */
            action.pktCmd = CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->action.pktCmd = %d",
                    dev, ruleFormat, ruleIndex, action.pktCmd);

            /* Call with CPSS_PACKET_CMD_ROUTE_E */
            action.pktCmd = CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E;

            st = cpssDxChPclRuleSet(dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
                                        &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->action.pktCmd = %d",
                    dev, ruleFormat, ruleIndex, action.pktCmd);

            /* Call with CPSS_PACKET_CMD_ROUTE_E */
            action.pktCmd = CPSS_PACKET_CMD_BRIDGE_E;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                    "%d, %d, %d, actionPtr->action.pktCmd = %d",
                    dev, ruleFormat, ruleIndex, action.pktCmd);

            /* restore valid value */
            action.pktCmd = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;

            /*
                1.18. Call with out of range actionPtr->lookupConfig.pcl0_1OverrideConfigIndex,
                      other parameters is the same as in 1.1.
                Expected: GT_BAD_PARAM for DxCh3 and above
            */
            action.egressPolicy = GT_TRUE;
            action.lookupConfig.ipclConfigIndex = 1;

            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleSet(
                                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action),
                                action.lookupConfig.pcl0_1OverrideConfigIndex);

            /* restore valid value */
            action.egressPolicy = GT_FALSE;

            /*
                1.19. Call with out of range actionPtr->lookupConfig.pcl1OverrideConfigIndex,
                    other parameters is the same as in 1.1.
                Expected: GT_BAD_PARAM
            */
            action.egressPolicy = GT_TRUE;
            action.lookupConfig.ipclConfigIndex = 1;

            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleSet(
                                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action),
                                action.lookupConfig.pcl1OverrideConfigIndex);

            /* restore valid value */
            action.egressPolicy = GT_FALSE;
            action.lookupConfig.ipclConfigIndex = 0;

            /*
                1.20. Call with out of range actionPtr->mirror.cpuCode
                Expected: GT_BAD_PARAM
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleSet(
                                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action),
                                action.mirror.cpuCode);

            /*
                1.21. Call with out of range
                    actionPtr->mirror.ingressMirrorToAnalyzerIndex[7 / 8]
                    (relevant for Bobcat2; Caelum; Bobcat3)
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3 and GT_OK for others.
            */
            action.egressPolicy = GT_FALSE;
            action.mirror.mirrorToRxAnalyzerPort = GT_TRUE;

            /* call with actionPtr->mirror.ingressMirrorToAnalyzerIndex[7] */
            action.mirror.ingressMirrorToAnalyzerIndex = 7;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                        dev, ruleFormat, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
            }
            else
            {
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                        dev, ruleFormat, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
            }

            /* call with actionPtr->mirror.ingressMirrorToAnalyzerIndex[8] */
            action.mirror.ingressMirrorToAnalyzerIndex = 8;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                        dev, ruleFormat, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
            }
            else
            {
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->mirror.ingressMirrorToAnalyzerIndex = %d",
                        dev, ruleFormat, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);
            }

            /* restore valid value */
            action.mirror.mirrorToRxAnalyzerPort = GT_FALSE;
            action.mirror.ingressMirrorToAnalyzerIndex = 0;

            if(PRV_CPSS_SIP_6_CHECK_MAC(dev))
            {
                /*
                    Call with out of range
                        actionPtr->mirror.egressMirrorToAnalyzerIndex[7 / 8]
                        (relevant for Falcon)
                    Expected: NOT GT_OK for Falcon and GT_OK for others.
                */
                action.egressPolicy = GT_TRUE;
                action.mirror.mirrorToTxAnalyzerPortEn = GT_TRUE;
                action.mirror.egressMirrorToAnalyzerMode = CPSS_DXCH_MIRROR_EGRESS_TAIL_DROP_E;

                /* call with actionPtr->mirror.egressMirrorToAnalyzerIndex[7] */
                action.mirror.egressMirrorToAnalyzerIndex = 7;

                st = cpssDxChPclPortGroupRuleSet(
                    dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                    ruleFormat, ruleIndex, ruleOptionsBmp,
                    &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->mirror.egressMirrorToAnalyzerIndex = %d",
                        dev, ruleFormat, ruleIndex, action.mirror.ingressMirrorToAnalyzerIndex);

                /* call with actionPtr->mirror.egressMirrorToAnalyzerIndex[8] */
                action.mirror.egressMirrorToAnalyzerIndex = 8;

                st = cpssDxChPclPortGroupRuleSet(
                    dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                    ruleFormat, ruleIndex, ruleOptionsBmp,
                    &mask, &pattern, &action);
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->mirror.egressMirrorToAnalyzerIndex = %d",
                        dev, ruleFormat, ruleIndex, action.mirror.egressMirrorToAnalyzerIndex);

                /* restore valid value */
                action.egressPolicy = GT_FALSE;
                action.mirror.mirrorToTxAnalyzerPortEn = GT_TRUE;
                action.mirror.egressMirrorToAnalyzerIndex = 0;
                action.mirror.egressMirrorToAnalyzerMode = CPSS_DXCH_MIRROR_EGRESS_NOT_DROPPED_E;
            }

            /*
                1.22. Call with out of range actionPtr->qos.ingress.modifyDscp
                Expected: GT_BAD_PARAM
            */
            action.egressPolicy = GT_FALSE;
            action.qos.ingress.profileAssignIndex = GT_TRUE;
            action.qos.ingress.modifyUp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;

            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleSet(
                                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action),
                                action.qos.ingress.modifyDscp);

            /* restore default value */
            action.qos.ingress.profileAssignIndex = GT_FALSE;

           /*
                1.23. Call with out of range actionPtr->qos.ingress.modifyUp
                Expected: GT_BAD_PARAM
            */
            action.egressPolicy = GT_FALSE;
            action.qos.ingress.profileAssignIndex = GT_TRUE;

            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleSet(
                                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action),
                                action.qos.ingress.modifyUp);

            /* restore valid value */
            action.qos.ingress.profileAssignIndex = GT_FALSE;

            /*
                1.24. Call with out of range actionPtr->qos.ingress.profileIndex
                    [72] for DxCh1
                    [256] for Bobcat2; Caelum; Bobcat3
                    [128] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2
                Expected: NOT GT_OK
            */
            action.qos.ingress.profileAssignIndex = GT_TRUE;
            action.qos.ingress.modifyUp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;
            action.qos.ingress.modifyDscp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;

            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.qos.ingress.profileIndex = BIT_10;
            }
            else
            {
                action.qos.ingress.profileIndex = 128;
            }

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                        dev, ruleFormat, ruleIndex, action.qos.ingress.profileIndex);

            /* restore valid value */
            action.qos.ingress.profileIndex = 0;
            action.qos.ingress.profileAssignIndex = GT_FALSE;

            /*
                1.25. Call with valid actionPtr->qos.ingress.profileIndex
                        [0 / 15 / 36 / 71] for DxCh1
                        [0 / 127 / 128 / 255] for Bobcat2; Caelum; Bobcat3
                        [0 / / 45 / 64 / 127 ] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2
                Expected: GT_OK
            */
            action.qos.ingress.profileAssignIndex = GT_TRUE;
            action.qos.ingress.modifyUp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;
            action.qos.ingress.modifyDscp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;

            /* Call with valid actionPtr->qos.ingress.profileIndex [0] */
            action.qos.ingress.profileIndex = 0;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                        dev, ruleFormat, ruleIndex, action.qos.ingress.profileIndex);

            /*  Call with valid actionPtr->qos.ingress.profileIndex
                    [15] for DxCh1
                    [127] for Bobcat2; Caelum; Bobcat3
                    [45] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2 */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.qos.ingress.profileIndex = 987;
            }
            else
            {
                action.qos.ingress.profileIndex = 45;
            }

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                        dev, ruleFormat, ruleIndex, action.qos.ingress.profileIndex);

            /*  Call with valid actionPtr->qos.ingress.profileIndex
                    [36] for DxCh1
                    [64] for Bobcat2; Caelum; Bobcat3
                    [64] for others -- DxCh2, DxCh3, xCat, Lion, xCat2, Lion2 */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.qos.ingress.profileIndex = BIT_10 / 2;
            }
            else
            {
                action.qos.ingress.profileIndex = 64;
            }
            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                        dev, ruleFormat, ruleIndex, action.qos.ingress.profileIndex);

            /*  Call with valid actionPtr->qos.ingress.profileIndex
                    [71] for DxCh1
                    [255] for Bobcat2; Caelum; Bobcat3
                    [127] for DxCh2, DxCh3, xCat, Lion, xCat2, Lion2 */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.qos.ingress.profileIndex = BIT_10 - 1;
            }
            else
            {
                action.qos.ingress.profileIndex = 127;
            }
            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                       "%d, %d, %d, actionPtr->qos.ingress.profileIndex = %d",
                        dev, ruleFormat, ruleIndex, action.qos.ingress.profileIndex);

            /* restore valid value */
            action.qos.ingress.profileIndex = 0;
            action.qos.ingress.profileAssignIndex = GT_FALSE;

            /*
                1.26. Call with out of range actionPtr->qos.ingress.up1Cmd (relevant for Bobcat2; Caelum; Bobcat3)
                Expected: GT_BAD_PARAM
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleSet(
                                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action),
                                action.qos.ingress.up1Cmd);
            }

            /*
                1.27. Call with out of range actionPtr->qos.ingress.up1 [8] (relevant for Bobcat2; Caelum; Bobcat3)
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3 and GT_OK for others.
            */
            action.qos.ingress.up1 = 8;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st,
                        "%d, %d, %d, actionPtr->qos.ingress.up1 = %d",
                        dev, ruleFormat, ruleIndex, action.qos.ingress.up1);
            }
            else
            {
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st,
                        "%d, %d, %d, actionPtr->qos.ingress.up1 = %d",
                        dev, ruleFormat, ruleIndex, action.qos.ingress.up1);
            }

            /* restore valid value */
            action.qos.ingress.up1 = 0;

            /*
                1.28. Call with out of range actionPtr->qos.egress.modifyUp
                Expected: GT_BAD_PARAM.
            */
            action.egressPolicy = GT_TRUE;

            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleSet(
                                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                ruleFormat, ruleIndex, ruleOptionsBmp,
                                &mask, &pattern, &action),
                                action.qos.egress.modifyUp);

            /* restore valid value */
            action.egressPolicy = GT_FALSE;

            /*
                1.29. Call with actionPtr->vlan.ingress.modifyVlan [CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E],
                               out of range actionPtr->vlan.ingress.vlanId1 [4096]
                               and other params from 1.1. Applicable devices - Bobcat2; Caelum; Bobcat3; Aldrin; AC3X.
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3 and GT_OK for others.
            */
            action.vlan.ingress.modifyVlan = CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E;
            action.vlan.ingress.vlanId1 = UTF_CPSS_PP_MAX_VLAN_NUM_CNS(dev);

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->vlan.ingress.vlanId1 = %d",
                                                dev, ruleFormat, ruleIndex, action.vlan.ingress.vlanId1);

            }
            else
            {
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->vlan.ingress.vlanId1 = %d",
                                                dev, ruleFormat, ruleIndex, action.vlan.ingress.vlanId1);
            }

            action.vlan.ingress.vlanId1 = 100; /* restore valid value */

            /*
                1.30. Call with actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE] (relevant for non DxCh2, DxCh3),
                               out of range actionPtr->ipUcRoute.arpDaIndex [1024]
                               and other params from 1.1.
                Expected: NOT GT_OK
            */
            if (support_doIpUcRoute == GT_TRUE)
            {
                action.ipUcRoute.doIpUcRoute = GT_TRUE;
                action.ipUcRoute.arpDaIndex = 1024;

                st = cpssDxChPclPortGroupRuleSet(
                    dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                    ruleFormat, ruleIndex, ruleOptionsBmp,
                    &mask, &pattern, &action);
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                         dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);

                action.ipUcRoute.doIpUcRoute = GT_FALSE; /* restore valid value */
            }

            /*
                1.31. Call with relevant actionPtr->ipUcRoute.doIpUcRoute [GT_TRUE],
                               out of range actionPtr->ipUcRoute.arpDaIndex [0 / 512 / 1023]
                               and other params from 1.1.
                Expected: GT_OK for non DxCh2, DxCh3 devices.
            */
            action.ipUcRoute.doIpUcRoute = GT_TRUE;
            action.policer.policerEnable = CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E;

            /* Call with arpDaIndex [0] */
            action.ipUcRoute.arpDaIndex = 0;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            if (support_doIpUcRoute == GT_TRUE)
            {
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                            dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
            }
            else
            {
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                                 dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
            }

            /* Call with arpDaIndex [512] */
            action.ipUcRoute.arpDaIndex = 512;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            if (support_doIpUcRoute == GT_TRUE)
            {
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                            dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
            }
            else
            {
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                                 dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
            }

            /* Call with arpDaIndex [1023] */
            action.ipUcRoute.arpDaIndex = 1023;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            if (support_doIpUcRoute == GT_TRUE)
            {
                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                            dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
            }
            else
            {
                UTF_VERIFY_NOT_EQUAL4_STRING_MAC(GT_OK, st, "%d, %d, %d, actionPtr->ipUcRoute.arpDaIndex = %d",
                                                 dev, ruleFormat, ruleIndex, action.ipUcRoute.arpDaIndex);
            }

            action.ipUcRoute.doIpUcRoute = GT_FALSE; /* restore valid value */

            /*
                1.32. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_TRUE], out of range
                    actionPtr->flowId[0x10000](not relevant) and other params same as 1.1.
                Expected: GT_OK.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                /* restore previous value */
                pclActionDefaultSet(&action);

                action.egressPolicy = GT_TRUE;
                action.flowId  = MAX_FLOW_ID(dev);
                action.actionStop = GT_FALSE;
                action.pktCmd = CPSS_PACKET_CMD_FORWARD_E;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                 ruleIndex, ruleOptionsBmp,
                                                 &mask, &pattern, &action);
                UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);


            /*
                1.33. For Bobcat2; Caelum; Bobcat3 call with actionPtr->egressPolicy[GT_FALSE], out of range
                    actionPtr->flowId[0x10000](is relevant) and other params same as 1.1.
                Expected: NOT GT_OK.
            */

                action.egressPolicy = GT_FALSE;
                action.flowId  = MAX_FLOW_ID(dev);

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                 ruleIndex, ruleOptionsBmp,
                                                 &mask, &pattern, &action);
                UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);

            /*
                1.34. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                    actionPtr->oam.oamProcessEnable[GT_TRUE],
                    actionPtr->oam.oamProfile[1], out of range actionPtr->oam.offsetIndex[16],
                    and other params same as 1.1.
                Expected: NOT GT_OK.
            */

                action.oam.timeStampEnable = GT_TRUE;
                action.oam.offsetIndex  = BIT_7;
                action.oam.oamProcessEnable = GT_TRUE;
                action.oam.oamProfile = 1;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                 ruleIndex, ruleOptionsBmp,
                                                 &mask, &pattern, &action);
                UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);

            /*
                1.35. For Bobcat2; Caelum; Bobcat3 call with valid actionPtr->oam.timeStampEnable[GT_TRUE],
                    actionPtr->oam.oamProcessEnable[GT_TRUE],
                    actionPtr->oam.offsetIndex[15], out of range actionPtr->oam.oamProfile[2],
                    and other params same as 1.1.
                Expected: NOT GT_OK.
            */

                action.oam.timeStampEnable = GT_TRUE;
                action.oam.offsetIndex  = BIT_7 - 1;
                action.oam.oamProcessEnable = GT_TRUE;
                action.oam.oamProfile = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                 ruleIndex, ruleOptionsBmp,
                                                 &mask, &pattern, &action);
                UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

                /* restore previous value */
                pclActionDefaultSet(&action);
            }

            /*
                1.36. Check for NULL pointers.  Call with maskPtr [NULL],
                other parameters is the same as in 1.1.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                NULL, &pattern, &action);

            UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_PTR, st,
                  "%d, %d, %d, maskPtr = NULL", dev, ruleFormat, ruleIndex);

            /*
                1.37. Check for NULL pointers.  Call with patternPtr [NULL],
                other parameters is the same as in 1.1.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, NULL, &action);

            UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_PTR, st,
                     "%d, %d, %d, patternPtr = NULL", dev, ruleFormat, ruleIndex);

            /*
                1.38. Check for NULL pointers. Call with actionPtr [NULL],
                other parameters is the same as in 1.1.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, NULL);

            UTF_VERIFY_EQUAL3_STRING_MAC(GT_BAD_PTR, st,
                    "%d, %d, %d, actionPtr = NULL", dev, ruleFormat, ruleIndex);

            /*
                1.39. check for invalid ruleFormat.  Call with ruleFormat [wrong enum values],
                other parameters is the same as in 1.1.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleSet
                                (dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                 ruleIndex, ruleOptionsBmp,
                                 &mask, &pattern, &action),
                                ruleFormat);

            /*
                1.40. For  devices call cpssDxChPclPortGroupRuleInvalidate
                with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
                Expected: GT_OK.
            */
            ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                   "cpssDxChPclPortGroupRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);

            /*
                1.41. Check extended rule. For all active device ids call with
                ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E],
                ruleIndex [511], maskPtr-> ruleExtNotIpv6.common is the same as in 1.1.,
                other fileds are zeroed, patternPtr->ruleExtNotIpv6 [ common[the same as in 1.1],
                commonExt[ isIpv6=0, ipProtocol=1, dscp=0, isL4Valid=1, l4Byte0=0, l4Byte1=0,
                l4Byte2=0, l4Byte3=0, l4Byte13=0, ipHeaderOk=1 ], sip={ 64.233.167.1},
                dip={ 213.180.204.1},  etherType=0, l2Encap=1, macDa=AB:CD:EF:00:00:02,
                macSa=AB:CD:EF:00:00:01, ipv4Fragmented=1, udb[6]={10,20,30,40,50,60} ],
                actionPtr is the same as in 1.1.
                Expected: GT_OK
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            pattern.ruleExtNotIpv6.common.pclId = 0;
            pattern.ruleExtNotIpv6.common.sourcePort = 5;
            pattern.ruleExtNotIpv6.common.isTagged = 1;
            pattern.ruleExtNotIpv6.common.vid = 100;
            pattern.ruleExtNotIpv6.common.up = 0;
            pattern.ruleExtNotIpv6.common.qosProfile = 0;
            pattern.ruleExtNotIpv6.common.isIp = 0;
            pattern.ruleExtNotIpv6.common.isL2Valid = 1;
            pattern.ruleExtNotIpv6.common.isUdbValid = 1;

            pattern.ruleExtNotIpv6.commonExt.isIpv6 = 0;
            pattern.ruleExtNotIpv6.commonExt.ipProtocol = 1;
            pattern.ruleExtNotIpv6.commonExt.dscp = 0;
            pattern.ruleExtNotIpv6.commonExt.isL4Valid = 1;
            pattern.ruleExtNotIpv6.commonExt.l4Byte0 = 0;
            pattern.ruleExtNotIpv6.commonExt.l4Byte1 = 0;
            pattern.ruleExtNotIpv6.commonExt.l4Byte2 = 0;
            pattern.ruleExtNotIpv6.commonExt.l4Byte3 = 0;
            pattern.ruleExtNotIpv6.commonExt.l4Byte13 = 0;
            pattern.ruleExtNotIpv6.commonExt.ipHeaderOk = 1;

            pattern.ruleExtNotIpv6.sip.arIP[0]= 64;
            pattern.ruleExtNotIpv6.sip.arIP[1]= 233;
            pattern.ruleExtNotIpv6.sip.arIP[2]= 167;
            pattern.ruleExtNotIpv6.sip.arIP[3]= 1;

            pattern.ruleExtNotIpv6.dip.arIP[0]= 213;
            pattern.ruleExtNotIpv6.dip.arIP[1]= 180;
            pattern.ruleExtNotIpv6.dip.arIP[2]= 204;
            pattern.ruleExtNotIpv6.dip.arIP[3]= 1;

            pattern.ruleExtNotIpv6.etherType = 0;
            pattern.ruleExtNotIpv6.l2Encap = 1;
            pattern.ruleExtNotIpv6.macDa = mac2;
            pattern.ruleExtNotIpv6.macSa = mac1;
            pattern.ruleExtNotIpv6.ipv4Fragmented = 1;

            pattern.ruleExtNotIpv6.udb0_5[0] = 10;
            pattern.ruleExtNotIpv6.udb0_5[1] = 20;
            pattern.ruleExtNotIpv6.udb0_5[2] = 30;
            pattern.ruleExtNotIpv6.udb0_5[3] = 40;
            pattern.ruleExtNotIpv6.udb0_5[4] = 50;
            pattern.ruleExtNotIpv6.udb0_5[5] = 60;

            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            mask.ruleExtNotIpv6 = pattern.ruleExtNotIpv6;
            mask.ruleExtNotIpv6.common.pclId = 0x3FF;/*10 bits*/

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "device: %d, %d, %d", dev, ruleFormat, ruleIndex);


            /*
                1.42. Check for out of range ruleIndex for extended rule format.
                Call with ruleIndex [wrong value], other parameters is the same as 1.8.
                Expected: NON GT_OK.
            */
            ruleIndex = PCL_INVALID_EXT_RULE_INDEX(dev);

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev); /* restore valid value */

            /*
                1.43. set standard rule with ruleIndex which is not allowed because of extended
                rule consumes two spaces of standard rule. Call with ruleIndex [wrong value],
                other parameters is the same as in 1.1.
                Expected: NON GT_OK.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/
            cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
            mask.ruleStdNotIp.common.pclId = 0x1;

            /* pattern.ruleStdNotIp was set previously and wasn't cleaned */

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            /* restore valid values */
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E;

            /*
                1.44. call cpssDxChPclPortGroupRuleInvalidate
                with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E], ruleIndex [511] to cleanup after testing.
                Expected: GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                  "cpssDxChPclPortGroupRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);

            /*
                1.45. Check standard EGRESS rule for all active devices with legal parameters.
                Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                ruleIndex [PCL_TESTED_RULE_INDEX],
                maskPtr-> ruleEgrStdNotIp [0xFF, , 0xFF], patternPtr-> ruleEgrStdNotIp
                [ common[pclId=0; sourcePort=5; isTagged=1; vid=100; up=0;
                isIp=0; isL2Valid =1;  egrPacketType=0; cpuCode=1;srcTrg=1;
                srcDev = 10; sourceId = 1; isVidx=0; others -zeroid], isIpv4 = 0;
                etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
                macSa=AB:CD:EF:00:00:01], actionPtr - the same as in 1.1.
                Expected: GT_OK ch2 and above
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                /*set ruleFlags according to : usePortsBmp */
                RULE_FLAGS_SET_MAC(dev,ruleFlags,usePortsBmp);
                /*fill mask with values that not exceed field size*/
                pclRuleStructureTestFill(
                    dev,
                    ruleFormat, 1 /*fullFill*/, ruleFlags, &mask);
            }
            else
            {
                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                cpssOsMemSet((GT_VOID*)&(mask.ruleEgrStdNotIp), 0xFF, sizeof(mask.ruleEgrStdNotIp));
            }

            cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
            pattern.ruleEgrStdNotIp.common.pclId = 0;
            pattern.ruleEgrStdNotIp.common.sourcePort = 5;
            pattern.ruleEgrStdNotIp.common.isTagged = 1;
            pattern.ruleEgrStdNotIp.common.vid = 100;
            pattern.ruleEgrStdNotIp.common.up = 0;
            pattern.ruleEgrStdNotIp.common.isIp = 0;
            pattern.ruleEgrStdNotIp.common.isL2Valid = 1;
            pattern.ruleEgrStdNotIp.common.egrPacketType = 0;
            pattern.ruleEgrStdNotIp.common.toCpu.cpuCode = 1;
            pattern.ruleEgrStdNotIp.common.toCpu.srcTrg = 1;
            pattern.ruleEgrStdNotIp.common.srcHwDev = 10;
            pattern.ruleEgrStdNotIp.common.sourceId = 1;
            pattern.ruleEgrStdNotIp.common.isVidx = 0;

            pattern.ruleEgrStdNotIp.isIpv4 = 0;
            pattern.ruleEgrStdNotIp.etherType = 0;
            pattern.ruleEgrStdNotIp.isArp = 0;
            pattern.ruleEgrStdNotIp.l2Encap = 0;
            pattern.ruleEgrStdNotIp.macDa = mac2;
            pattern.ruleEgrStdNotIp.macSa = mac1;

            pclActionDefaultSet(&action);
            action.actionStop = GT_FALSE;
            action.pktCmd=CPSS_PACKET_CMD_FORWARD_E;
            action.egressPolicy = GT_TRUE;
            if(devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
            {   /* supported on CHEETAH 3 */
                action.qos.egress.modifyDscp = CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E;
                action.qos.egress.modifyUp = CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E;
            }

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            if(devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
            {
                UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "device: %d, %d, %d", dev, ruleFormat, ruleIndex);
            }
            else
            {
                /* for CH1 result ignored EPCL not supported     */
                /* but EPCL rule formats translated to HW format */
            }

            /*
                1.13. For Cheetah2 and above devices call cpssDxChPclPortGroupRuleInvalidate with
                ruleSize [CPSS_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX]
                to cleanup after testing.
                Expected: GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                "cpssDxChPclPortGroupRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);

            /*
                1.46. Check extended EGRESS rule for all active devices with legal parameters.
                Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E],
                ruleIndex [511], maskPtr-> ruleEgrExtIpv6L2 [0xFF, , 0xFF],
                patternPtr-> ruleEgrExtIpv6L2 [common [pclId=0; sourcePort=5;
                isTagged=1; vid=100; up=0; isIp=1; isL2Valid =1;  egrPacketType=0;
                cpuCode=1;srcTrg=1; srcDev = 10; sourceId = 1; isVidx=0;
                others -zeroid], commonExt [isIpv6=1; ipProtocol=1; dscp=2;
                isL4Valid=0; egrTcpUdpPortComparator=0; others- theroid]
                sip[100; 1000; 10000; 100000]; dipBits127to120=0xAA;
                macDa=AB:CD:EF:00:00:02; macSa=AB:CD:EF:00:00:01],
                actionPtr - the same as in 1.1.
                Expected: GT_OK for Cheetah2 and above
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                /*set ruleFlags according to : usePortsBmp */
                RULE_FLAGS_SET_MAC(dev,ruleFlags,usePortsBmp);
                /*fill mask with values that not exceed field size*/
                pclRuleStructureTestFill(
                    dev,
                    ruleFormat, 1 /*fullFill*/, ruleFlags, &mask);
            }
            else
            {
                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                cpssOsMemSet((GT_VOID*)&(mask.ruleEgrExtIpv6L2), 0xFF, sizeof(mask.ruleEgrExtIpv6L2));
            }

            cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
            pattern.ruleEgrExtIpv6L2.common.pclId = 0;
            pattern.ruleEgrExtIpv6L2.common.sourcePort = 5;
            pattern.ruleEgrExtIpv6L2.common.sourceId = 0;
            pattern.ruleEgrExtIpv6L2.common.isTagged = 1;
            pattern.ruleEgrExtIpv6L2.common.vid = 100;
            pattern.ruleEgrExtIpv6L2.common.up = 0;
            pattern.ruleEgrExtIpv6L2.common.isIp = 1;
            pattern.ruleEgrExtIpv6L2.common.egrPacketType = 0;
            pattern.ruleEgrExtIpv6L2.common.toCpu.cpuCode = 1;
            pattern.ruleEgrExtIpv6L2.common.toCpu.srcTrg = 1;
            pattern.ruleEgrExtIpv6L2.common.srcHwDev = 10;
            pattern.ruleEgrExtIpv6L2.common.isVidx = 0;

            pattern.ruleEgrExtIpv6L2.commonExt.isIpv6 = 1;
            pattern.ruleEgrExtIpv6L2.commonExt.ipProtocol = 1;
            pattern.ruleEgrExtIpv6L2.commonExt.dscp = 2;
            pattern.ruleEgrExtIpv6L2.commonExt.isL4Valid = 0;
            pattern.ruleEgrExtIpv6L2.commonExt.egrTcpUdpPortComparator = 0;

            pattern.ruleEgrExtIpv6L2.dipBits127to120 = 0xAA;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[0] = 100;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[1] = 1000;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[2] = 10000;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[3] = 100000;
            pattern.ruleEgrExtIpv6L2.macDa = mac2;
            pattern.ruleEgrExtIpv6L2.macSa = mac1;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "device: %d, %d, %d", dev, ruleFormat, ruleIndex);

            /*
                1.31. For Cheetah2 and above devices call cpssDxChPclPortGroupRuleInvalidate
                with ruleSize [CPSS_PCL_RULE_SIZE_EXT_E],
                ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
                Expected: GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "cpssDxChPclPortGroupRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);

            /*
            1.41. Call with ruleOptionsBmp [CPSS_DXCH_PCL_RULE_OPTION_KEY_EXTENSION_ENABLED_E],
                and other params as in 1.23.
            Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
            ruleOptionsBmp = 0;

            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                /*set ruleFlags according to : usePortsBmp */
                RULE_FLAGS_SET_MAC(dev,ruleFlags,usePortsBmp);
                /*fill mask with values that not exceed field size*/
                pclRuleStructureTestFill(
                    dev,
                    ruleFormat, 1 /*fullFill*/, ruleFlags, &mask);
            }
            else
            {
                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                cpssOsMemSet((GT_VOID*)&(mask.ruleEgrExtIpv6L2), 0xFF, sizeof(mask.ruleEgrExtIpv6L2));
                mask.ruleStdNotIp.common.sourcePort = 0x3F;
            }

            cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
            pattern.ruleEgrExtIpv6L2.common.pclId = 0;
            pattern.ruleEgrExtIpv6L2.common.sourcePort = 5;
            pattern.ruleEgrExtIpv6L2.common.sourceId = 0;
            pattern.ruleEgrExtIpv6L2.common.isTagged = 1;
            pattern.ruleEgrExtIpv6L2.common.vid = 100;
            pattern.ruleEgrExtIpv6L2.common.up = 0;
            pattern.ruleEgrExtIpv6L2.common.isIp = 1;
            pattern.ruleEgrExtIpv6L2.common.egrPacketType = 0;
            pattern.ruleEgrExtIpv6L2.common.toCpu.cpuCode = 1;
            pattern.ruleEgrExtIpv6L2.common.toCpu.srcTrg = 1;
            pattern.ruleEgrExtIpv6L2.common.srcHwDev = 10;
            pattern.ruleEgrExtIpv6L2.common.isVidx = 0;

            pattern.ruleEgrExtIpv6L2.commonExt.isIpv6 = 1;
            pattern.ruleEgrExtIpv6L2.commonExt.ipProtocol = 1;
            pattern.ruleEgrExtIpv6L2.commonExt.dscp = 2;
            pattern.ruleEgrExtIpv6L2.commonExt.isL4Valid = 0;
            pattern.ruleEgrExtIpv6L2.commonExt.egrTcpUdpPortComparator = 0;

            pattern.ruleEgrExtIpv6L2.dipBits127to120 = 0xAA;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[0] = 100;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[1] = 1000;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[2] = 10000;
            pattern.ruleEgrExtIpv6L2.sip.u32Ip[3] = 100000;
            pattern.ruleEgrExtIpv6L2.macDa = mac2;
            pattern.ruleEgrExtIpv6L2.macSa = mac1;

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, ruleIndex);

            /*
                1.48. Call function with
                        ruleFormat
                               [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                        sourceDevice [dev], udb [10,20,30,40,...].
                Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                ruleOptionsBmp = 0;
                ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

                for (index = 0;
                     index < (sizeof(ruleFormatArr) / sizeof(ruleFormatArr[0]));
                     index++) {
                  cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                  cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
                  cpssOsBzero((GT_VOID*)&action, sizeof(action));

                  switch (ruleFormatArr[index])
                  {
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleStdNotIp.common.sourceDevice = dev;
                        pattern.ruleStdNotIp.udb23_26[0] = 10;
                        pattern.ruleStdNotIp.udb23_26[1] = 20;
                        pattern.ruleStdNotIp.udb23_26[2] = 30;
                        pattern.ruleStdNotIp.udb23_26[3] = 40;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleStdIpL2Qos.common.sourceDevice = dev;
                        pattern.ruleStdIpL2Qos.udb27_30[0] = 10;
                        pattern.ruleStdIpL2Qos.udb27_30[1] = 20;
                        pattern.ruleStdIpL2Qos.udb27_30[2] = 30;
                        pattern.ruleStdIpL2Qos.udb27_30[3] = 40;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleStdIpv4L4.common.sourceDevice = dev;
                        pattern.ruleStdIpv4L4.udb31_34[0] = 10;
                        pattern.ruleStdIpv4L4.udb31_34[1] = 20;
                        pattern.ruleStdIpv4L4.udb31_34[2] = 30;
                        pattern.ruleStdIpv4L4.udb31_34[3] = 40;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleStdIpv6Dip.common.sourceDevice = dev;
                        pattern.ruleStdIpv6Dip.udb47_49[0] = 10;
                        pattern.ruleStdIpv6Dip.udb47_49[1] = 20;
                        pattern.ruleStdIpv6Dip.udb47_49[2] = 30;
                        pattern.ruleStdIpv6Dip.udb0        = 40;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleExtNotIpv6.common.sourceDevice = dev;
                        pattern.ruleExtNotIpv6.udb39_46[0] = 10;
                        pattern.ruleExtNotIpv6.udb39_46[1] = 20;
                        pattern.ruleExtNotIpv6.udb39_46[2] = 30;
                        pattern.ruleExtNotIpv6.udb39_46[3] = 40;
                        pattern.ruleExtNotIpv6.udb39_46[4] = 50;
                        pattern.ruleExtNotIpv6.udb39_46[5] = 60;
                        pattern.ruleExtNotIpv6.udb39_46[6] = 70;
                        pattern.ruleExtNotIpv6.udb39_46[7] = 80;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleExtIpv6L2.common.sourceDevice = dev;
                        pattern.ruleExtIpv6L2.udb47_49[0] = 10;
                        pattern.ruleExtIpv6L2.udb47_49[1] = 20;
                        pattern.ruleExtIpv6L2.udb47_49[2] = 30;
                        pattern.ruleExtIpv6L2.udb0_4[0]   = 40;
                        pattern.ruleExtIpv6L2.udb0_4[1]   = 50;
                        pattern.ruleExtIpv6L2.udb0_4[2]   = 60;
                        pattern.ruleExtIpv6L2.udb0_4[3]   = 70;
                        pattern.ruleExtIpv6L2.udb0_4[4]   = 80;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleExtIpv6L4.common.sourceDevice = dev;
                        pattern.ruleExtIpv6L4.udb15_22[0] = 10;
                        pattern.ruleExtIpv6L4.udb15_22[1] = 20;
                        pattern.ruleExtIpv6L4.udb15_22[2] = 30;
                        pattern.ruleExtIpv6L4.udb15_22[3] = 40;
                        pattern.ruleExtIpv6L4.udb15_22[4] = 50;
                        pattern.ruleExtIpv6L4.udb15_22[5] = 60;
                        pattern.ruleExtIpv6L4.udb15_22[6] = 70;
                        pattern.ruleExtIpv6L4.udb15_22[7] = 80;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E:
                        action.egressPolicy = GT_TRUE;
                        pattern.ruleEgrStdNotIp.udb0_3[0] = 10;
                        pattern.ruleEgrStdNotIp.udb0_3[1] = 20;
                        pattern.ruleEgrStdNotIp.udb0_3[2] = 30;
                        pattern.ruleEgrStdNotIp.udb0_3[3] = 40;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E:
                        action.egressPolicy = GT_TRUE;
                        pattern.ruleEgrStdIpL2Qos.udb4_7[0] = 10;
                        pattern.ruleEgrStdIpL2Qos.udb4_7[1] = 20;
                        pattern.ruleEgrStdIpL2Qos.udb4_7[2] = 30;
                        pattern.ruleEgrStdIpL2Qos.udb4_7[3] = 40;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E:
                        action.egressPolicy = GT_TRUE;
                        pattern.ruleEgrStdIpv4L4.udb8_11[0] = 10;
                        pattern.ruleEgrStdIpv4L4.udb8_11[1] = 20;
                        pattern.ruleEgrStdIpv4L4.udb8_11[2] = 30;
                        pattern.ruleEgrStdIpv4L4.udb8_11[3] = 40;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E:
                        action.egressPolicy = GT_TRUE;
                        pattern.ruleEgrExtNotIpv6.udb12_19[0] = 10;
                        pattern.ruleEgrExtNotIpv6.udb12_19[1] = 20;
                        pattern.ruleEgrExtNotIpv6.udb12_19[2] = 30;
                        pattern.ruleEgrExtNotIpv6.udb12_19[3] = 40;
                        pattern.ruleEgrExtNotIpv6.udb12_19[4] = 50;
                        pattern.ruleEgrExtNotIpv6.udb12_19[5] = 60;
                        pattern.ruleEgrExtNotIpv6.udb12_19[6] = 70;
                        pattern.ruleEgrExtNotIpv6.udb12_19[7] = 80;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E:
                        action.egressPolicy = GT_TRUE;
                        pattern.ruleEgrExtIpv6L2.udb20_27[0] = 10;
                        pattern.ruleEgrExtIpv6L2.udb20_27[1] = 20;
                        pattern.ruleEgrExtIpv6L2.udb20_27[2] = 30;
                        pattern.ruleEgrExtIpv6L2.udb20_27[3] = 40;
                        pattern.ruleEgrExtIpv6L2.udb20_27[4] = 50;
                        pattern.ruleEgrExtIpv6L2.udb20_27[5] = 60;
                        pattern.ruleEgrExtIpv6L2.udb20_27[6] = 70;
                        pattern.ruleEgrExtIpv6L2.udb20_27[7] = 80;
                    pattern.ruleEgrExtIpv6L2.isIpv6ExtHdrExist = 0;
                    pattern.ruleEgrExtIpv6L2.isIpv6HopByHop = 1;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E:
                        action.egressPolicy = GT_TRUE;
                        pattern.ruleEgrExtIpv6L4.udb28_35[0] = 10;
                        pattern.ruleEgrExtIpv6L4.udb28_35[1] = 20;
                        pattern.ruleEgrExtIpv6L4.udb28_35[2] = 30;
                        pattern.ruleEgrExtIpv6L4.udb28_35[3] = 40;
                        pattern.ruleEgrExtIpv6L4.udb28_35[4] = 50;
                        pattern.ruleEgrExtIpv6L4.udb28_35[5] = 60;
                        pattern.ruleEgrExtIpv6L4.udb28_35[6] = 70;
                        pattern.ruleEgrExtIpv6L4.udb28_35[7] = 80;
                    pattern.ruleEgrExtIpv6L4.isIpv6ExtHdrExist = 1;
                    pattern.ruleEgrExtIpv6L4.isIpv6HopByHop = 0;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleIngrStdUdb.commonIngrUdb.sourceDevice = dev;
                        pattern.ruleIngrStdUdb.udb35_38[0] = 10;
                        pattern.ruleIngrStdUdb.udb35_38[1] = 20;
                        pattern.ruleIngrStdUdb.udb35_38[2] = 30;
                        pattern.ruleIngrStdUdb.udb35_38[3] = 40;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleIngrExtUdb.commonIngrUdb.sourceDevice = dev;
                        pattern.ruleIngrExtUdb.udb23_30[0] = 10;
                        pattern.ruleIngrExtUdb.udb23_30[1] = 20;
                        pattern.ruleIngrExtUdb.udb23_30[2] = 30;
                        pattern.ruleIngrExtUdb.udb23_30[3] = 40;
                        pattern.ruleIngrExtUdb.udb23_30[4] = 50;
                        pattern.ruleIngrExtUdb.udb23_30[5] = 60;
                        pattern.ruleIngrExtUdb.udb23_30[6] = 70;
                        pattern.ruleIngrExtUdb.udb23_30[7] = 80;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleStdIpv4RoutedAclQos.ingressIpCommon.sourceDevice = dev;
                        pattern.ruleStdIpv4RoutedAclQos.udb41_44[0] = 10;
                        pattern.ruleStdIpv4RoutedAclQos.udb41_44[1] = 20;
                        pattern.ruleStdIpv4RoutedAclQos.udb41_44[2] = 30;
                        pattern.ruleStdIpv4RoutedAclQos.udb41_44[3] = 40;
                        pattern.ruleStdIpv4RoutedAclQos.vrfId = 0;
                        pattern.ruleStdIpv4RoutedAclQos.isUdbValid = 1;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleExtIpv4PortVlanQos.ingressIpCommon.sourceDevice = dev;
                        pattern.ruleExtIpv4PortVlanQos.udb31_38[0] = 10;
                        pattern.ruleExtIpv4PortVlanQos.udb31_38[1] = 20;
                        pattern.ruleExtIpv4PortVlanQos.udb31_38[2] = 30;
                        pattern.ruleExtIpv4PortVlanQos.udb31_38[3] = 40;
                        pattern.ruleExtIpv4PortVlanQos.udb31_38[4] = 50;
                        pattern.ruleExtIpv4PortVlanQos.udb31_38[5] = 60;
                        pattern.ruleExtIpv4PortVlanQos.udb31_38[6] = 70;
                        pattern.ruleExtIpv4PortVlanQos.udb31_38[7] = 80;
                        pattern.ruleExtIpv4PortVlanQos.tag1Exist = 1;
                        pattern.ruleExtIpv4PortVlanQos.vid1 = 100;
                        pattern.ruleExtIpv4PortVlanQos.up1 = 4;
                        pattern.ruleExtIpv4PortVlanQos.cfi1 = 1;
                        pattern.ruleExtIpv4PortVlanQos.vrfId = 0;
                        pattern.ruleExtIpv4PortVlanQos.trunkHash = 10;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleUltraIpv6PortVlanQos.ingressIpCommon.sourceDevice = dev;
                        pattern.ruleUltraIpv6PortVlanQos.udb39_40[0] = 10;
                        pattern.ruleUltraIpv6PortVlanQos.udb39_40[1] = 20;
                        pattern.ruleUltraIpv6PortVlanQos.tag1Exist = 1;
                        pattern.ruleUltraIpv6PortVlanQos.vid1 = 100;
                        pattern.ruleUltraIpv6PortVlanQos.up1 = 4;
                        pattern.ruleUltraIpv6PortVlanQos.cfi1 = 1;
                        pattern.ruleUltraIpv6PortVlanQos.vrfId = 0;
                        pattern.ruleUltraIpv6PortVlanQos.srcPortOrTrunk = 0;
                        pattern.ruleUltraIpv6PortVlanQos.srcIsTrunk = 1;
                        pattern.ruleUltraIpv6PortVlanQos.trunkHash = 10;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E:
                        action.egressPolicy = GT_FALSE;
                        pattern.ruleUltraIpv6RoutedAclQos.ingressIpCommon.sourceDevice = dev;
                        pattern.ruleUltraIpv6RoutedAclQos.udb45_46[0] = 10;
                        pattern.ruleUltraIpv6RoutedAclQos.udb45_46[1] = 20;
                        pattern.ruleUltraIpv6RoutedAclQos.tag1Exist = 1;
                        pattern.ruleUltraIpv6RoutedAclQos.vid1 = 100;
                        pattern.ruleUltraIpv6RoutedAclQos.up1 = 4;
                        pattern.ruleUltraIpv6RoutedAclQos.cfi1 = 1;
                        pattern.ruleUltraIpv6RoutedAclQos.vrfId = 0;
                        pattern.ruleUltraIpv6RoutedAclQos.srcPortOrTrunk = 0;
                        pattern.ruleUltraIpv6RoutedAclQos.srcIsTrunk = 1;
                        pattern.ruleUltraIpv6RoutedAclQos.trunkHash = 10;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E:
                        action.egressPolicy = GT_TRUE;
                        pattern.ruleEgrExtIpv4RaclVacl.egressIpCommon.srcHwDev = dev;
                        pattern.ruleEgrExtIpv4RaclVacl.egressIpCommon.tag1Exist = 1;
                        pattern.ruleEgrExtIpv4RaclVacl.egressIpCommon.sourceId  = 0;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[0] = 10;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[1] = 20;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[2] = 30;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[3] = 40;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[4] = 50;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[5] = 60;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[6] = 70;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[7] = 80;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[8] = 90;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[9] = 0xA0;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[10] = 0xB0;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[11] = 0xC0;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[12] = 0xD0;
                        pattern.ruleEgrExtIpv4RaclVacl.udb36_49[13] = 0xE0;
                        pattern.ruleEgrExtIpv4RaclVacl.udb0 = 80;
                        pattern.ruleEgrExtIpv4RaclVacl.vid1 = 100;
                        pattern.ruleEgrExtIpv4RaclVacl.up1 = 4;
                        pattern.ruleEgrExtIpv4RaclVacl.cfi1 = 1;
                        break;
                    case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E:
                        action.egressPolicy = GT_TRUE;
                        pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.srcHwDev = dev;
                        pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.tag1Exist = 1;
                        pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourceId = 0;
                        pattern.ruleEgrUltraIpv6RaclVacl.udb1_4[0] = 10;
                        pattern.ruleEgrUltraIpv6RaclVacl.udb1_4[1] = 20;
                        pattern.ruleEgrUltraIpv6RaclVacl.udb1_4[2] = 30;
                        pattern.ruleEgrUltraIpv6RaclVacl.udb1_4[3] = 40;
                        pattern.ruleEgrUltraIpv6RaclVacl.srcPort = 0;
                        pattern.ruleEgrUltraIpv6RaclVacl.trgPort = 0xA5A;
                        pattern.ruleEgrUltraIpv6RaclVacl.vid1 = 100;
                        pattern.ruleEgrUltraIpv6RaclVacl.up1 = 4;
                        pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 1;
                        break;
                    default:
                        break;
                  }
                  st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormatArr[index], ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);
                  if((CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E == ruleFormatArr[index]) &&
                     PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
                  {
                      UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev,
                                                  ruleFormatArr[index]);
                  }
                  else
                  {
                      UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev,
                                                  ruleFormatArr[index]);
                  }
                }
            }
            /*
                1.49. Call function with out of range isIpv6ExtHdrExist [2]
                     ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E]
                      and other parameters from 1.67.
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                ruleOptionsBmp = 0;
                ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
                cpssOsBzero((GT_VOID*)&action, sizeof(action));
                action.egressPolicy = GT_TRUE;

                ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E;
                pattern.ruleEgrExtIpv6L2.isIpv6ExtHdrExist = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrExtIpv6L2.isIpv6ExtHdrExist = 0;
            }
            /*
                1.50. Call function with out of range isIpv6HopByHop [2]
                     ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E]
                      and other parameters from 1.67.
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                pattern.ruleEgrExtIpv6L2.isIpv6HopByHop = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrExtIpv6L2.isIpv6HopByHop = 0;

            }
            /*
                1.51. Call function with out of range isIpv6ExtHdrExist [2]
                     ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E]
                      and other parameters from 1.67.
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E;
                pattern.ruleEgrExtIpv6L4.isIpv6ExtHdrExist = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrExtIpv6L4.isIpv6ExtHdrExist = 0;
            }
            /*
                1.52. Call function with out of range isIpv6HopByHop [2]
                     ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E]
                      and other parameters from 1.67.
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
            pattern.ruleEgrExtIpv6L4.isIpv6HopByHop = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrExtIpv6L4.isIpv6HopByHop = 0;

            }
            /*
                1.53. Call function with vrfId [0xA5A / BIT_12-1],
                                         isUdbValid [0]
                      ruleFormat
                   [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E]
                      and other parameters from 1.67.
                Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                action.egressPolicy = GT_FALSE;
                ruleFormat =
                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E;

                /* Call with vrfId [0x5A], isUdbValid [0] */
                pattern.ruleStdIpv4RoutedAclQos.vrfId = 0x5A;
                pattern.ruleStdIpv4RoutedAclQos.isUdbValid = 0;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                /* Call with vrfId [BIT_8-1] */
                pattern.ruleStdIpv4RoutedAclQos.vrfId = BIT_8-1;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            }
            /*
                1.54. Call function with out of range vrfId [BIT_8],
                                                      isUdbValid [2]
                      ruleFormat
                   [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E]
                      and other parameters from 1.67.
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                /* Call with out of range vrfId [BIT_8] */
                pattern.ruleStdIpv4RoutedAclQos.vrfId = BIT_8;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleStdIpv4RoutedAclQos.vrfId = 0;
                /* Call with out of range isUdbValid [2] */
                pattern.ruleStdIpv4RoutedAclQos.isUdbValid = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleStdIpv4RoutedAclQos.isUdbValid = 0;
            }
            /*
                1.55. Call function with tag1Exist [0],
                                         vid1 [0 / BIT_12-1],
                                         up1 [0 / 7],
                                         cfi1 [0],
                                         vrfId [0xA5A / BIT_12-1],
                                         trunkHash [0 / BIT_6-1]
                      ruleFormat
                    [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E]
                      and other parameters from 1.67.
                Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                ruleFormat =
                     CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E;

                /*
                    Call with tag1Exist [0],
                              vid1 [0],
                              up1 [0],
                              cfi1 [0],
                              vrfId [0xA5A],
                              trunkHash [0]
                */
                pattern.ruleExtIpv4PortVlanQos.tag1Exist = 0;
                pattern.ruleExtIpv4PortVlanQos.vid1 = 0;
                pattern.ruleExtIpv4PortVlanQos.up1 = 0;
                pattern.ruleExtIpv4PortVlanQos.cfi1 = 0;
                pattern.ruleExtIpv4PortVlanQos.vrfId = 0xA5A;
                pattern.ruleExtIpv4PortVlanQos.trunkHash = 0;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                /*
                    Call with vid1 [BIT_12-1],
                              up1 [7],
                              vrfId [BIT_12-1],
                              trunkHash [BIT_6-1]
                */
                pattern.ruleExtIpv4PortVlanQos.vid1 = BIT_12-1;
                pattern.ruleExtIpv4PortVlanQos.up1 = 7;
                pattern.ruleExtIpv4PortVlanQos.vrfId = BIT_12-1;
                pattern.ruleExtIpv4PortVlanQos.trunkHash = BIT_6-1;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
                /* Call with vrfId [BIT_8-1] */
                pattern.ruleStdIpv4RoutedAclQos.vrfId = BIT_8-1;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            }
            /*
                1.56. Call function with out of range tag1Exist [2],
                                                      vid1 [BIT_12],
                                                      up1 [8],
                                                      cfi1 [2],
                                                      vrfId [BIT_12],
                                                      trunkHash [BIT_6]
                      ruleFormat
                    [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E]
                      and other parameters from 1.67.
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                /* Call with out of range tag1Exist [2] */
                pattern.ruleExtIpv4PortVlanQos.tag1Exist = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleExtIpv4PortVlanQos.tag1Exist = 0;

                /* Call with out of range vid1 [BIT_12] */
                pattern.ruleExtIpv4PortVlanQos.vid1 = BIT_12;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleExtIpv4PortVlanQos.vid1 = 0;

                /* Call with out of range up1 [8] */
                pattern.ruleExtIpv4PortVlanQos.up1 = 8;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleExtIpv4PortVlanQos.up1 = 0;

                /* Call with out of range cfi1 [2] */
                pattern.ruleExtIpv4PortVlanQos.cfi1 = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleExtIpv4PortVlanQos.cfi1 = 0;

                /* Call with out of range vrfId [BIT_12] */
                pattern.ruleExtIpv4PortVlanQos.vrfId = BIT_12;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleExtIpv4PortVlanQos.vrfId = 0;

                /* Call with out of range trunkHash [BIT_6] */
                pattern.ruleExtIpv4PortVlanQos.trunkHash = BIT_6;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleExtIpv4PortVlanQos.trunkHash = 0;
            }
            /*
                1.57. Call function with tag1Exist [0],
                                         vid1 [0 / BIT_12-1],
                                         up1 [0 / 7],
                                         cfi1 [0],
                                         vrfId [0xA5A / BIT_12-1],
                                         trunkHash [0 / BIT_6-1],
                                         srcPortOrTrunk [0xA5A / BIT_13-1],
                                         srcIsTrunk [0]
                      ruleFormat
                  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E]
                      and other parameters from 1.67.
                Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                ruleFormat =
                   CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E;

                /*
                    Call with tag1Exist [0],
                              vid1 [0],
                              up1 [0],
                              cfi1 [0],
                              vrfId [0xA5A],
                              trunkHash [0],
                              srcPortOrTrunk [0xA5A / BIT_13-1],
                              srcIsTrunk [0]
                */
                pattern.ruleUltraIpv6PortVlanQos.tag1Exist = 0;
                pattern.ruleUltraIpv6PortVlanQos.vid1 = 0;
                pattern.ruleUltraIpv6PortVlanQos.up1 = 0;
                pattern.ruleUltraIpv6PortVlanQos.cfi1 = 0;
                pattern.ruleUltraIpv6PortVlanQos.vrfId = 0xA5A;
                pattern.ruleUltraIpv6PortVlanQos.trunkHash = 0;
                pattern.ruleUltraIpv6PortVlanQos.srcPortOrTrunk = 0xA5A;
                pattern.ruleUltraIpv6PortVlanQos.srcIsTrunk = 0;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                /*
                    Call with vid1 [BIT_12-1],
                              up1 [7],
                              vrfId [BIT_12-1],
                              trunkHash [BIT_6-1],
                              srcPortOrTrunk [BIT_13-1]
                */
                pattern.ruleUltraIpv6PortVlanQos.vid1 = BIT_12-1;
                pattern.ruleUltraIpv6PortVlanQos.up1 = 7;
                pattern.ruleUltraIpv6PortVlanQos.vrfId = BIT_12-1;
                pattern.ruleUltraIpv6PortVlanQos.trunkHash = BIT_6-1;
                pattern.ruleUltraIpv6PortVlanQos.srcPortOrTrunk = BIT_13-1;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
                /* Call with vrfId [BIT_8-1] */
                pattern.ruleStdIpv4RoutedAclQos.vrfId = BIT_8-1;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            }
            /*
                1.58. Call function with out of range tag1Exist [2],
                                                      vid1 [BIT_12],
                                                      up1 [8],
                                                      cfi1 [2],
                                                      vrfId [BIT_12],
                                                      trunkHash [BIT_6],
                                                      srcPortOrTrunk [BIT_13],
                                                      srcIsTrunk [2]
                      ruleFormat
                  [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E]
                      and other parameters from 1.67.
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                /* Call with out of range tag1Exist [2] */
                pattern.ruleUltraIpv6PortVlanQos.tag1Exist = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6PortVlanQos.tag1Exist = 0;

                /* Call with out of range vid1 [BIT_12] */
                pattern.ruleUltraIpv6PortVlanQos.vid1 = BIT_12;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6PortVlanQos.vid1 = 0;

                /* Call with out of range up1 [8] */
                pattern.ruleUltraIpv6PortVlanQos.up1 = 8;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6PortVlanQos.up1 = 0;

                /* Call with out of range cfi1 [2] */
                pattern.ruleUltraIpv6PortVlanQos.cfi1 = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6PortVlanQos.cfi1 = 0;

                /* Call with out of range vrfId [BIT_12] */
                pattern.ruleUltraIpv6PortVlanQos.vrfId = BIT_12;

                cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6PortVlanQos.vrfId = 0;

                /* Call with out of range trunkHash [BIT_6] */
                pattern.ruleUltraIpv6PortVlanQos.trunkHash = BIT_6;

                cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6PortVlanQos.trunkHash = 0;

                /* Call with out of range srcIsTrunk [2] */
                pattern.ruleUltraIpv6PortVlanQos.srcIsTrunk = 2;

                cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6PortVlanQos.srcIsTrunk = 0;

                /* Call with out of range srcPortOrTrunk [BIT_13] */
                pattern.ruleUltraIpv6PortVlanQos.srcPortOrTrunk = BIT_13;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6PortVlanQos.srcPortOrTrunk = 0;

            }
            /*
                1.59. Call function with tag1Exist [0],
                                         vid1 [0 / BIT_12-1],
                                         up1 [0 / 7],
                                         cfi1 [0],
                                         vrfId [0xA5A / BIT_12-1],
                                         trunkHash [0 / BIT_6-1],
                                         srcPortOrTrunk [0xA5A / BIT_13-1],
                                         srcIsTrunk [0]
                      ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E]
                      and other parameters from 1.67.
                Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                ruleFormat =
                  CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E;

                /*
                    Call with tag1Exist [0],
                              vid1 [0],
                              up1 [0],
                              cfi1 [0],
                              vrfId [0xA5A],
                              trunkHash [0],
                              srcPortOrTrunk [0xA5A / BIT_13-1],
                              srcIsTrunk [0]
                */
                pattern.ruleUltraIpv6RoutedAclQos.tag1Exist = 0;
                pattern.ruleUltraIpv6RoutedAclQos.vid1 = 0;
                pattern.ruleUltraIpv6RoutedAclQos.up1 = 0;
                pattern.ruleUltraIpv6RoutedAclQos.cfi1 = 0;
                pattern.ruleUltraIpv6RoutedAclQos.vrfId = 0xA5A;
                pattern.ruleUltraIpv6RoutedAclQos.trunkHash = 0;
                pattern.ruleUltraIpv6RoutedAclQos.srcPortOrTrunk = 0xA5A;
                pattern.ruleUltraIpv6RoutedAclQos.srcIsTrunk = 0;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                /*
                    Call with vid1 [BIT_12-1],
                              up1 [7],
                              vrfId [BIT_12-1],
                              trunkHash [BIT_6-1],
                              srcPortOrTrunk [BIT_13-1]
                */
                pattern.ruleUltraIpv6RoutedAclQos.vid1 = BIT_12-1;
                pattern.ruleUltraIpv6RoutedAclQos.up1 = 7;
                pattern.ruleUltraIpv6RoutedAclQos.vrfId = BIT_12-1;
                pattern.ruleUltraIpv6RoutedAclQos.trunkHash = BIT_6-1;
                pattern.ruleUltraIpv6RoutedAclQos.srcPortOrTrunk = BIT_13-1;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
                /* Call with vrfId [BIT_12-1] */
                pattern.ruleUltraIpv6RoutedAclQos.vrfId = BIT_12-1;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            }
            /*
                1.60. Call function with out of range tag1Exist [2],
                                                      vid1 [BIT_12],
                                                      up1 [8],
                                                      cfi1 [2],
                                                      vrfId [BIT_12],
                                                      trunkHash [BIT_6],
                                                      srcPortOrTrunk [BIT_13],
                                                      srcIsTrunk [2]
                      ruleFormat
                 [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E]
                      and other parameters from 1.67.
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                /* Call with out of range tag1Exist [2] */
                pattern.ruleUltraIpv6RoutedAclQos.tag1Exist = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6RoutedAclQos.tag1Exist = 0;

                /* Call with out of range vid1 [BIT_12] */
                pattern.ruleUltraIpv6RoutedAclQos.vid1 = BIT_12;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6RoutedAclQos.vid1 = 0;

                /* Call with out of range up1 [8] */
                pattern.ruleUltraIpv6RoutedAclQos.up1 = 8;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6RoutedAclQos.up1 = 0;

                /* Call with out of range cfi1 [2] */
                pattern.ruleUltraIpv6RoutedAclQos.cfi1 = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6RoutedAclQos.cfi1 = 0;

                /* Call with out of range vrfId [BIT_12] */
                pattern.ruleUltraIpv6RoutedAclQos.vrfId = BIT_12;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6RoutedAclQos.vrfId = 0;

                /* Call with out of range trunkHash [BIT_6] */
                pattern.ruleUltraIpv6RoutedAclQos.trunkHash = BIT_6;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6RoutedAclQos.trunkHash = 0;

                /* Call with out of range srcIsTrunk [2] */
                pattern.ruleUltraIpv6RoutedAclQos.srcIsTrunk = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6RoutedAclQos.srcIsTrunk = 0;

                /* Call with out of range srcPortOrTrunk [BIT_13] */
                pattern.ruleUltraIpv6RoutedAclQos.srcPortOrTrunk = BIT_13;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleUltraIpv6RoutedAclQos.srcPortOrTrunk = 0;

            }
            /*
                1.61. Call function with vid1 [0 / BIT_12-1],
                                         up1 [0 / 7],
                                         cfi1 [0]
                      ruleFormat
                       [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
                      and other parameters from 1.67.
                Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) &&
               !PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                ruleFormat =
                        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E;

                pclActionDefaultSet(&action);
                action.actionStop = GT_FALSE;
                action.pktCmd=CPSS_PACKET_CMD_FORWARD_E;
                action.egressPolicy = GT_TRUE;


                /*
                    Call with vid1 [0], up1 [0], cfi1 [0]
                */
                pattern.ruleEgrUltraIpv6RaclVacl.vid1 = 0;
                pattern.ruleEgrUltraIpv6RaclVacl.up1 = 0;
                pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 0;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                /*
                    Call with vid1 [BIT_12-1], up1 [7]
                */
                pattern.ruleEgrUltraIpv6RaclVacl.vid1 = BIT_12-1;
                pattern.ruleEgrUltraIpv6RaclVacl.up1 = 7;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            }
            /*
                1.62. Call function with out of range vid1 [BIT_12],
                                                      up1 [8],
                                                      cfi1 [2]
                      ruleFormat
                       [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
                      and other parameters from 1.67.
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) &&
               !PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {

                /* Call with out of range vid1 [BIT_12] */
                pattern.ruleEgrUltraIpv6RaclVacl.vid1 = BIT_12;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrUltraIpv6RaclVacl.vid1 = 0;

                /* Call with out of range up1 [8] */
                pattern.ruleEgrUltraIpv6RaclVacl.up1 = 8;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrUltraIpv6RaclVacl.up1 = 0;

                /* Call with out of range cfi1 [2] */
                pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 0;

            }
            /*
                1.63. Call function with egressIpCommon.tag1Exist [0],
                                        egressIpCommon.sourceId [10 / BIT_12-1],
                                        vid1 [0 / BIT_12-1],
                                        up1 [0 / 7],
                                        cfi1 [0],
                                        srcPort [0xA5A / BIT_13-1],
                                        trgPort [0 / BIT_13-1]
                      ruleFormat
                     [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
                      and other parameters from 1.67.
                Expected: GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) &&
               !PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                ruleFormat =
                      CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E;

                /*
                    Call with egressIpCommon.tag1Exist [0],
                              egressIpCommon.sourceId [10],
                              vid1 [0],
                              up1 [0],
                              cfi1 [0],
                              srcPort [0xA5A],
                              trgPort [BIT_13-1],
                              srcIsTrunk [0]
                */
                pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.tag1Exist = 0;
                pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourceId = 10;
                pattern.ruleEgrUltraIpv6RaclVacl.vid1 = 0;
                pattern.ruleEgrUltraIpv6RaclVacl.up1 = 0;
                pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 0;
                pattern.ruleEgrUltraIpv6RaclVacl.srcPort = 0xA5A;
                pattern.ruleEgrUltraIpv6RaclVacl.trgPort = BIT_13-1;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                /*
                    Call with egressIpCommon.sourceId [BIT_12-1],
                              vid1 [BIT_12-1],
                              up1 [7],
                              srcPort [BIT_13-1],
                              trgPort [0]
                */
                pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourceId =
                                                                       BIT_12-1;
                pattern.ruleEgrUltraIpv6RaclVacl.vid1 = BIT_12-1;
                pattern.ruleEgrUltraIpv6RaclVacl.up1 = 7;
                pattern.ruleEgrUltraIpv6RaclVacl.srcPort = BIT_13-1;
                pattern.ruleEgrUltraIpv6RaclVacl.trgPort = 0;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);
                /* Call with srcPort [BIT_13-1] */
                pattern.ruleEgrUltraIpv6RaclVacl.srcPort = BIT_13-1;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

            }
            /*
                1.64. Call function with out of range
                                                egressIpCommon.tag1Exist [2],
                                                egressIpCommon.sourceId [BIT_12],
                                                vid1 [BIT_12],
                                                up1 [8],
                                                cfi1 [2],
                                                srcPort [BIT_13],
                                                trgPort [BIT_13],
                      ruleFormat
                     [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E]
                      and other parameters from 1.67.
                Expected: NOT GT_OK for Bobcat2; Caelum; Bobcat3.
            */
            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) &&
               !PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                /* Call with out of range egressIpCommon.tag1Exist [2] */
                pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.tag1Exist = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.tag1Exist = 0;

                /* Call with out of range egressIpCommon.sourceId [BIT_12] */
                pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourceId =
                                                                         BIT_12;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourceId = 0;

                /* Call with out of range vid1 [BIT_12] */
                pattern.ruleEgrUltraIpv6RaclVacl.vid1 = BIT_12;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrUltraIpv6RaclVacl.vid1 = 0;

                /* Call with out of range up1 [8] */
                pattern.ruleEgrUltraIpv6RaclVacl.up1 = 8;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrUltraIpv6RaclVacl.up1 = 0;

                /* Call with out of range cfi1 [2] */
                pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 2;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrUltraIpv6RaclVacl.cfi1 = 0;

                /* Call with out of range srcPort [BIT_13] */
                pattern.ruleEgrUltraIpv6RaclVacl.srcPort = BIT_13;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrUltraIpv6RaclVacl.srcPort = 0;

                /* Call with out of range trgPort [BIT_13] */
                pattern.ruleEgrUltraIpv6RaclVacl.trgPort = BIT_13;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                            ruleFormat, ruleIndex, ruleOptionsBmp,
                            &mask, &pattern, &action);

                UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, ruleFormat);

                pattern.ruleEgrUltraIpv6RaclVacl.trgPort = 0;

            }
            /*
                1.65. Call function with
                        action{
                            redirect {
                               redirectCmd [
                                CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                               data {
                                   logicalSourceInterface{
                                       logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                                         devPort {devNum=dev, portNum=0}]
                                       sourceMeshIdSetEnable[GT_TRUE/GT_FALSE]
                                       sourceMeshId[0/1/3]
                                       userTagAcEnable[GT_TRUE/GT_FALSE]
                                   }}},
                            unknownSaCommandEnable[GT_TRUE/GT_FALSE]
                            unknownSaCommand[  CPSS_PACKET_CMD_FORWARD_E /
                                               CPSS_PACKET_CMD_MIRROR_TO_CPU_E /
                                               CPSS_PACKET_CMD_TRAP_TO_CPU_E /
                                               CPSS_PACKET_CMD_DROP_HARD_E /
                                               CPSS_PACKET_CMD_DROP_SOFT_E]}
                        and other parameters from 1.67.
                Expected: GT_OK  for xCat C0; xCat3.
            */
            if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
            {
                ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
                action.egressPolicy = GT_FALSE;
                ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
                ruleOptionsBmp = 0;

                cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
                pattern.ruleStdNotIp.common.pclId = 0;
                pattern.ruleStdNotIp.common.sourcePort = 5;
                pattern.ruleStdNotIp.common.isTagged = 1;
                pattern.ruleStdNotIp.common.vid = 100;
                pattern.ruleStdNotIp.common.up = 0;
                pattern.ruleStdNotIp.common.qosProfile = 0;
                pattern.ruleStdNotIp.common.isIp = 0;
                pattern.ruleStdNotIp.common.isL2Valid = 1;
                pattern.ruleStdNotIp.common.isUdbValid = 1;
                pattern.ruleStdNotIp.isIpv4 = 0;
                pattern.ruleStdNotIp.etherType = 0;
                pattern.ruleStdNotIp.isArp = 0;
                pattern.ruleStdNotIp.l2Encap = 0;
                pattern.ruleStdNotIp.macDa = mac2;
                pattern.ruleStdNotIp.macSa = mac1;
                pattern.ruleStdNotIp.udb15_17[0] = 10;
                pattern.ruleStdNotIp.udb15_17[1] = 20;
                pattern.ruleStdNotIp.udb15_17[2] = 30;

                cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
                mask.ruleStdNotIp = pattern.ruleStdNotIp;
                mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/
                mask.ruleStdNotIp.common.sourcePort = 0x3F;
                /*
                    Call function with
                            action{
                                redirect {
                                   redirectCmd [
                                    CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E],
                                   data {
                                       logicalSourceInterface{
                                           logicalInterface [type = CPSS_INTERFACE_PORT_E,
                                                             devPort {devNum=0, portNum=0} ]
                                           sourceMeshIdSetEnable[GT_FALSE]
                                           sourceMeshId[0]
                                           userTagAcEnable[GT_FALSE]
                                       }}},
                                unknownSaCommandEnable[GT_FALSE]
                                unknownSaCommand[   CPSS_PACKET_CMD_FORWARD_E ]}
                            and other parameters from 1.67.
                */
                action.redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_LOGICAL_PORT_ASSIGN_E;
                action.redirect.data.logicalSourceInterface.logicalInterface.type = CPSS_INTERFACE_PORT_E;
                action.redirect.data.logicalSourceInterface.logicalInterface.devPort.hwDevNum = dev;
                action.redirect.data.logicalSourceInterface.logicalInterface.devPort.portNum = 0;
                action.redirect.data.logicalSourceInterface.sourceMeshIdSetEnable = GT_FALSE;
                action.redirect.data.logicalSourceInterface.sourceMeshId = 0;
                action.redirect.data.logicalSourceInterface.userTagAcEnable = GT_FALSE;
                action.unknownSaCommandEnable = GT_FALSE;
                action.unknownSaCommand = CPSS_PACKET_CMD_FORWARD_E;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                     ruleIndex, ruleOptionsBmp,
                                                     &mask, &pattern, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                /*
                    Call function with
                            action{
                                redirect {
                                   data {
                                       logicalSourceInterface{
                                           sourceMeshIdSetEnable[GT_TRUE]
                                           sourceMeshId[1]
                                           userTagAcEnable[GT_TRUE]
                                       }}},
                                unknownSaCommandEnable[GT_TRUE]
                                unknownSaCommand[ CPSS_PACKET_CMD_MIRROR_TO_CPU_E ]}
                            and other parameters from 1.67.
                */
                action.redirect.data.logicalSourceInterface.sourceMeshIdSetEnable = GT_TRUE;
                action.redirect.data.logicalSourceInterface.sourceMeshId = 1;
                action.redirect.data.logicalSourceInterface.userTagAcEnable = GT_TRUE;
                action.unknownSaCommandEnable = GT_TRUE;
                action.unknownSaCommand = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                     ruleIndex, ruleOptionsBmp,
                                                     &mask, &pattern, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                /*
                    Call function with
                            action{
                                redirect {
                                   data {
                                       logicalSourceInterface{
                                           sourceMeshId[3]
                                       }}},
                                unknownSaCommand[   CPSS_PACKET_CMD_TRAP_TO_CPU_E ]}
                            and other parameters from 1.67.
                */

                action.redirect.data.logicalSourceInterface.sourceMeshId = 3;
                action.unknownSaCommand = CPSS_PACKET_CMD_TRAP_TO_CPU_E;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                     ruleIndex, ruleOptionsBmp,
                                                     &mask, &pattern, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                /*
                    Call function with
                            action{
                                unknownSaCommand[   CPSS_PACKET_CMD_DROP_HARD_E ]}
                            and other parameters from 1.67.
                */
                action.unknownSaCommand = CPSS_PACKET_CMD_DROP_HARD_E;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                     ruleIndex, ruleOptionsBmp,
                                                     &mask, &pattern, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                /*
                    Call function with
                            action{
                                unknownSaCommand[   CPSS_PACKET_CMD_DROP_SOFT_E ]}
                            and other parameters from 1.67.
                */
                action.unknownSaCommand = CPSS_PACKET_CMD_DROP_SOFT_E;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                     ruleIndex, ruleOptionsBmp,
                                                     &mask, &pattern, &action);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }
            /*
                1.66. Call function with out of range sourceMeshId [4]
                       and other parameters from 1.67.
                Expected: GT_OK  for xCat C0; xCat3.
            */
            if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.redirect.data.logicalSourceInterface.sourceMeshId = 4;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                     ruleIndex, ruleOptionsBmp,
                                                     &mask, &pattern, &action);
                UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                action.redirect.data.logicalSourceInterface.sourceMeshId = 0;
            }
            /*
                1.67. Call function with out of range unknownSaCommand
                       and other parameters from 1.67.
                Expected: GT_OK  for xCat C0; xCat3.
            */
            if(PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(dev) == GT_TRUE)
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleSet( dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                    ruleFormat, ruleIndex, ruleOptionsBmp,
                                    &mask, &pattern, &action),
                                    action.unknownSaCommand);
            }

            /*
                1.68. For bobCat2 and above call with out of range
                actionPtr->copyReserved.copyReserved.
                Expected: GT_OUT_OF_RANGE.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                action.copyReserved.assignEnable = GT_TRUE;
                action.copyReserved.copyReserved = PRV_CPSS_SIP_6_CHECK_MAC(dev) ? BIT_19 : BIT_18;

                st = cpssDxChPclPortGroupRuleSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat,
                                                     ruleIndex, ruleOptionsBmp,
                                                     &mask, &pattern, &action);

                UTF_VERIFY_EQUAL4_STRING_MAC(GT_OUT_OF_RANGE, st,
                                "%d, %d, %d, actionPtr->copyReserved.copyReserved = %d",
                                dev, ruleSize, ruleIndex, action.copyReserved.copyReserved);

                action.copyReserved.copyReserved = 0; /* restore valid value */
            }

            ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;

            st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                "cpssDxChPclRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);
        }



        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupRuleSet(
                dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                ruleFormat, ruleIndex, ruleOptionsBmp,
                &mask, &pattern, &action);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupRuleSet(
            dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* Set valid parameters. As soon as family of device can't be determined */
    /* - values valid for any family                                         */
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    ruleIndex = 0;

    cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
    cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclPortGroupRuleSet(
            dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
            ruleFormat, ruleIndex, ruleOptionsBmp,
            &mask, &pattern, &action);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupRuleSet(
        dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
        ruleFormat, ruleIndex, ruleOptionsBmp,
        &mask, &pattern, &action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupRuleValidStatusSet
(
    IN GT_U8                              devNum,
    IN GT_PORT_GROUPS_BMP                 portGroupsBmp,
    IN CPSS_PCL_RULE_SIZE_ENT             ruleSize,
    IN GT_U32                             ruleIndex,
    IN GT_BOOL                            valid
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleValidStatusSet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS (DxChx)

    1.1. Set rule for testing.
         Call cpssDxChPclPortGroupRuleSet with ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E], ruleIndex [PCL_TESTED_RULE_INDEX],
         maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ], patternPtr-> ruleStdNotIp
         [ common[pclId=0; sourcePort=5; isTagged=1; vid=100; up=0; qosProfile=0;
         isIp=0; isL2Valid=1; isUdbValid =1], isIpv4 = 0; etherType=0; isArp=0;
         l2Encap=0; macDa=AB:CD:EF:00:00:02; macSa=AB:CD:EF:00:00:01; udb[10,20,30]
         ], actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E, mirror{cpuCode = 0,
         analyzerPortIndex = GT_FALSE}, matchCounter { enableMatchCount =
         GT_FALSE, matchCounterIndex = 0 }, qos { egressPolicy=GT_FALSE,
         modifyDscp=GT_FALSE, modifyUp=GT_FALSE , qos [ ingress[profileIndex=0,
         profileAssignIndex=GT_FALSE, profilePrecedence=GT_FALSE] ] }, redirect {
         CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E, data[routerLttIndex=0] }, policer
         { policerEnable=GT_FALSE, policerId=0 }, vlan { egressTaggedModify=GT_FALSE,
         modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
         vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
         ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
    Expected: GT_OK.

    1.2. Call with  ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                    ruleIndex [PCL_TESTED_RULE_INDEX ],
                    valid [GT_TRUE / GT_FALSE].
    Expected: GT_OK.

    1.3. Call with  ruleSize [CPSS_PCL_RULE_SIZE_EXT_E],
                    ruleIndex [PCL_TESTED_RULE_INDEX],
                    valid [GT_FALSE].
    Try to set status of created rule with another ruleSize.
    Expected: NOT GT_OK.

    1.4. Call with  ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                    ruleIndex [0],
                    valid [GT_FALSE].
    Try to set status of created rule with another ruleIndex.
    Expected: NOT GT_OK.

    1.5. Call with wrong enum values ruleSize ,
                   and other parameters from 1.2.
    Expected: NOT GT_OK.

    1.6. Call with out of range ruleIndex [1024],
                   and other parameters from 1.2.
    Expected: NOT GT_OK.

    1.7. Invalidete created rule.
         Call cpssDxChPclPortGroupRuleInvalidate with
         ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E],
         ruleIndex [PCL_TESTED_RULE_INDEX].
    Expected: NON GT_OK.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      portGroupId;

    GT_PORT_GROUPS_BMP      portGroupsBmp = 1;
    CPSS_PCL_RULE_SIZE_ENT  ruleSize    = CPSS_PCL_RULE_SIZE_STD_E;
    GT_U32                  ruleIndex   = 0;
    GT_BOOL                 valid       = GT_FALSE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = pclRulesForCopyAndStatusTesting(dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(
            GT_OK, st, "pclRulesForCopyAndStatusTesting: %d", dev);
        /* 1.1. Go over all active port groups. */

        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /* check and skip not valid port groups */
            if (prvUtfPclActivePortGroupCheck(dev,portGroupId,&portGroupsBmp) == GT_TRUE)
            {
                continue;
            }

            /*
                1.1. Set rule for testing.  Call cpssDxChPclPortGroupRuleSet with
                ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ],
                patternPtr-> ruleStdNotIp [ common[pclId=0; sourcePort=5; isTagged=1;
                vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1; isUdbValid =1],
                isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
                macSa=AB:CD:EF:00:00:01; udb[10,20,30] ],
                actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
                mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
                matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
                qos { egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE ,
                qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
                profilePrecedence=GT_FALSE] ] },
                redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                data[routerLttIndex=0] }, policer { policerEnable=GT_FALSE, policerId=0 },
                vlan { egressTaggedModify=GT_FALSE,
                modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
                vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
                ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
                Expected: GT_OK.
            */

            /*
                1.2. Call with  ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                                ruleIndex [PCL_TESTED_RULE_INDEX ],
                                valid [GT_TRUE / GT_FALSE].
                Expected: GT_OK.
            */
            /* call with valid = GT_TRUE */
            ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);
            valid     = GT_TRUE;

            st = cpssDxChPclPortGroupRuleValidStatusSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex, valid);

            /* call with valid = GT_FALSE */
            valid = GT_FALSE;

            st = cpssDxChPclPortGroupRuleValidStatusSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, valid);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex, valid);

            /*
                1.3. Call with  ruleSize [CPSS_PCL_RULE_SIZE_EXT_E],
                                ruleIndex [PCL_TESTED_RULE_INDEX],
                                valid [GT_FALSE].
                Try to set status of created rule with another ruleSize.
                Expected: NOT GT_OK.
            */
            /* call with ruleSize = CPSS_PCL_RULE_SIZE_EXT_E */
            ruleSize = CPSS_PCL_RULE_SIZE_EXT_E;
            ruleIndex = PCL_DAMAGED_EXT_RULE_INDEX_MAC(dev);
            valid     = GT_TRUE;

            st = cpssDxChPclPortGroupRuleValidStatusSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, valid);
            /* in E_ARCH ruleSize is ignored */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_TRUE)
            {
                UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st, "%d, ruleSize = %d", dev, ruleSize);
            }
            else
            {
                UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st, "%d, ruleSize = %d", dev, ruleSize);
            }


            /*
                1.4. Call with  ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                                ruleIndex [0],
                                valid [GT_FALSE].
                Try to set status of created rule with another ruleIndex.
                Expected: NOT GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_DAMAGED_STD_RULE_INDEX_MAC(dev);
            valid     = GT_TRUE;

            st = cpssDxChPclPortGroupRuleValidStatusSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, valid);
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_TRUE)
            {
                UTF_VERIFY_EQUAL2_STRING_MAC(GT_OK, st, "%d, ruleIndex = %d", dev, ruleIndex);
            }
            else
            {
                UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st, "%d, ruleIndex = %d", dev, ruleIndex);
            }

            ruleIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);

            /*
                1.5. Call with wrong enum values ruleSize, and other parameters from 1.2.
                Expected: NOT GT_OK.
            */
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) == GT_FALSE)
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleValidStatusSet
                                    (dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex, valid),
                                    ruleSize);
            }

            /*
                1.6. Call with out of range ruleIndex [wrong value],
                               and other parameters from 1.2.
                Expected: NOT GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

            st = cpssDxChPclPortGroupRuleValidStatusSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                        ruleSize, ruleIndex, valid);
            UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st, "%d, ruleIndex = %d", dev, ruleIndex);

            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            /*
                1.7. Invalidete created rule.  Call cpssDxChPclPortGroupRuleInvalidate
                with ruleSize [CPSS_DXCH_PCL_RULE_SIZE_STD_E], ruleIndex [PCL_TESTED_RULE_INDEX].
                Expected: NON GT_OK.
            */
            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleSize, ruleIndex);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupRuleValidStatusSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                          ruleSize, ruleIndex, valid);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupRuleValidStatusSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize,
                                                    ruleIndex, valid);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
    ruleIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);
    valid     = GT_TRUE;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortGroupRuleValidStatusSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                           ruleSize, ruleIndex, valid);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPclPortGroupRuleValidStatusSet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                         ruleSize, ruleIndex, valid);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupTcpUdpPortComparatorSet
(
    IN GT_U8                             devNum,
    IN GT_PORT_GROUPS_BMP                portGroupsBmp,
    IN CPSS_PCL_DIRECTION_ENT            direction,
    IN CPSS_L4_PROTOCOL_ENT              l4Protocol,
    IN GT_U8                             entryIndex,
    IN CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortType,
    IN CPSS_COMPARE_OPERATOR_ENT         compareOperator,
    IN GT_U16                            value
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupTcpUdpPortComparatorSet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(dxCh2 and above)

    1.1. Call with direction [CPSS_PCL_DIRECTION_INGRESS_E], l4Protocol
    [CPSS_L4_PROTOCOL_TCP_E], entryIndex [0], l4PortType [CPSS_L4_PROTOCOL_PORT_SRC_E],
    compareOperator [CPSS_COMPARE_OPERATOR_LTE], value [25].
    Expected: GT_OK for devices and NON GT_OK for others.

    1.2. Call with direction [CPSS_PCL_DIRECTION_EGRESS_E], l4Protocol
    [CPSS_L4_PROTOCOL_UDP_E], entryIndex [7], l4PortType [CPSS_L4_PROTOCOL_PORT_DST_E],
    compareOperator [CPSS_COMPARE_OPERATOR_NEQ], value [25].
    Expected: GT_OK for devices and NON GT_OK for others.

    1.3. Call cpssDxChPclPortGroupTcpUdpPortComparatorGet
    Expected: GT_OK and same l4PortType, compareOperator, value.

    1.4. Check for invalid enum value for direction. call function
    with direction [wrong enum values] and other parameters as in 1.2.
    Expected: GT_BAD_PARAM.

    1.5. Check for invalid enum value for l4Protocol. call function
    with l4Protocol [wrong enum values] and other parameters as in 1.2.
    Expected: GT_BAD_PARAM.

    1.6. Check for out of range entryIndex. call function with
    entryIndex [8] and other parameters as in 1.2.
    Expected: NON GT_OK.

    1.7. Check for invalid enum value for l4Port. call function with
    l4Port [wrong enum values] and other parameters as in 1.2.
    Expected: GT_BAD_PARAM.

    1.8. Check for invalid enum value for compareOperator. call
    function with compareOperator [wrong enum values] and other parameters as in 1.2.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                         st = GT_OK;

    GT_U8                             dev;
    GT_PORT_GROUPS_BMP                portGroupsBmp = 1;
    CPSS_PCL_DIRECTION_ENT            direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_L4_PROTOCOL_ENT              l4Protocol = CPSS_L4_PROTOCOL_TCP_E;
    GT_U8                             entryIndex = 0;
    CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortType = CPSS_L4_PROTOCOL_PORT_SRC_E;
    CPSS_COMPARE_OPERATOR_ENT         compareOperator = CPSS_COMPARE_OPERATOR_LTE;
    GT_U16                            value = 0;
    CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortTypeGet = CPSS_L4_PROTOCOL_PORT_SRC_E;
    CPSS_COMPARE_OPERATOR_ENT         compareOperatorGet = CPSS_COMPARE_OPERATOR_LTE;
    GT_U16                            valueGet = 0;

    GT_U32    portGroupId;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);
            /*
                1.1. Call with direction [CPSS_PCL_DIRECTION_INGRESS_E],
                l4Protocol [CPSS_L4_PROTOCOL_TCP_E], entryIndex [0], l4PortType
                [CPSS_L4_PROTOCOL_PORT_SRC_E], compareOperator [CPSS_COMPARE_OPERATOR_LTE],
                value [25].
                Expected: GT_OK
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            l4Protocol = CPSS_L4_PROTOCOL_TCP_E;
            entryIndex = 0;
            l4PortType = CPSS_L4_PROTOCOL_PORT_SRC_E;
            compareOperator = CPSS_COMPARE_OPERATOR_LTE;
            value = 25;

            st = cpssDxChPclPortGroupTcpUdpPortComparatorSet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);

            UTF_VERIFY_EQUAL7_STRING_MAC(GT_OK, st, "device: %d, %d, %d, %d, %d, %d, %d",
               dev, direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);

            /*  1.3.  */
            st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, &l4PortTypeGet, &compareOperatorGet, &valueGet);

            UTF_VERIFY_EQUAL7_STRING_MAC(GT_OK, st, "device: %d, %d, %d, %d, %d, %d, %d",
               dev, direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);

            UTF_VERIFY_EQUAL1_STRING_MAC(l4PortType, l4PortTypeGet,
                                "get another l4PortType than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(compareOperator, compareOperatorGet,
                                "get another compareOperator than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(value, valueGet,
                                "get another value than was set: %d", dev);

            /*
                1.2. Call with direction [CPSS_PCL_DIRECTION_EGRESS_E],
                l4Protocol [CPSS_L4_PROTOCOL_UDP_E], entryIndex [7], l4PortType
                [CPSS_L4_PROTOCOL_PORT_DST_E], compareOperator
                [CPSS_COMPARE_OPERATOR_NEQ], value [25].
                Expected: GT_OK
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            l4Protocol = CPSS_L4_PROTOCOL_UDP_E;
            entryIndex = 7;
            l4PortType = CPSS_L4_PROTOCOL_PORT_DST_E;
            compareOperator = CPSS_COMPARE_OPERATOR_NEQ;

            st = cpssDxChPclPortGroupTcpUdpPortComparatorSet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);

            UTF_VERIFY_EQUAL7_STRING_MAC(GT_OK, st, "device: %d, %d, %d, %d, %d, %d, %d",
              dev, direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);

            /*  1.3.  */
            st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, &l4PortTypeGet, &compareOperatorGet, &valueGet);

            UTF_VERIFY_EQUAL7_STRING_MAC(GT_OK, st, "device: %d, %d, %d, %d, %d, %d, %d",
               dev, direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);

            UTF_VERIFY_EQUAL1_STRING_MAC(l4PortType, l4PortTypeGet,
                                "get another l4PortType than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(compareOperator, compareOperatorGet,
                                "get another compareOperator than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(value, valueGet,
                                "get another value than was set: %d", dev);

            /*
                1.4. Check for invalid enum value for direction. Call function
                with direction [wrong enum values] and other parameters as in 1.2.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupTcpUdpPortComparatorSet
                                (dev, portGroupsBmp, direction, l4Protocol, entryIndex,
                                 l4PortType, compareOperator, value),
                                direction);

            /*
                1.5. Check for invalid enum value for l4Protocol.
                    Call with l4Protocol [wrong enum values]
                    and other parameters as in 1.2.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupTcpUdpPortComparatorSet
                                (dev, portGroupsBmp, direction, l4Protocol, entryIndex,
                                 l4PortType, compareOperator, value),
                                l4Protocol);

            /*
               1.6. Check for out of range entryIndex. call
               function with entryIndex [8] and other parameters as in 1.2.
               Expected: NON GT_OK.
            */
            entryIndex = PRV_CPSS_SIP_6_10_CHECK_MAC(dev) ? 64 : 8;

            st = cpssDxChPclPortGroupTcpUdpPortComparatorSet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);

            UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
                            "device: %d, entryIndex = %d", dev, entryIndex);

            entryIndex = 7;

            /*
                1.7. Check for invalid enum value for l4Port. Call
                    function with l4Port [wrong enum values] and other parameters as in 1.2.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupTcpUdpPortComparatorSet
                                (dev, portGroupsBmp, direction, l4Protocol, entryIndex,
                                 l4PortType, compareOperator, value),
                                l4PortType);

            /*
                1.8. Check for invalid enum value for compareOperator.
                    Call with compareOperator [wrong enum values] and other
                    parameters as in 1.2.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupTcpUdpPortComparatorSet
                                (dev, portGroupsBmp, direction, l4Protocol, entryIndex,
                                 l4PortType, compareOperator, value),
                                compareOperator);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupTcpUdpPortComparatorSet(dev, portGroupsBmp,
                direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupTcpUdpPortComparatorSet(dev, portGroupsBmp, direction,
                                                         l4Protocol, entryIndex, l4PortType,
                                                         compareOperator, value);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* set correct values for all the parameters (except of device number) */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    l4Protocol = CPSS_L4_PROTOCOL_TCP_E;
    entryIndex = 0;
    l4PortType = CPSS_L4_PROTOCOL_PORT_SRC_E;
    compareOperator = CPSS_COMPARE_OPERATOR_LTE;
    value = 25;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclPortGroupTcpUdpPortComparatorSet(dev, portGroupsBmp,
                direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupTcpUdpPortComparatorSet(dev, portGroupsBmp,
            direction, l4Protocol, entryIndex, l4PortType, compareOperator, value);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupTcpUdpPortComparatorGet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(dxCh2 and above)
    1.1. Call with direction [CPSS_PCL_DIRECTION_INGRESS_E/
                              CPSS_PCL_DIRECTION_EGRESS_E],
                   l4Protocol[CPSS_L4_PROTOCOL_TCP_E/
                              CPSS_L4_PROTOCOL_UDP_E],
                   entryIndex [0/7],
          and not NULL l4PortTypePtr, compareOperatorPtr, valuePtr.
    Expected: GT_OK.
    1.2. Call with wrong enum value direction
    Expected: GT_BAD_PAPRAM.
    1.3. Call with wrong enum value l4Protocol
    Expected: GT_BAD_PAPRAM.
    1.4. Call with out of range entryIndex[8]
    Expected: not GT_OK.
    1.5. Call with NULL l4PortTypePtr
    Expected: GT_BAD_PTR.
    1.6. Call with NULL compareOperatorPtr
    Expected: GT_BAD_PTR.
    1.7. Call with NULL valuePtr
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                         st = GT_OK;

    GT_U8                             dev;
    GT_PORT_GROUPS_BMP                portGroupsBmp = 1;
    CPSS_PCL_DIRECTION_ENT            direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_L4_PROTOCOL_ENT              l4Protocol = CPSS_L4_PROTOCOL_TCP_E;
    GT_U8                             entryIndex = 0;
    CPSS_L4_PROTOCOL_PORT_TYPE_ENT    l4PortType = CPSS_L4_PROTOCOL_PORT_SRC_E;
    CPSS_COMPARE_OPERATOR_ENT         compareOperator = CPSS_COMPARE_OPERATOR_LTE;
    GT_U16                            value = 0;

    GT_U32    portGroupId;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /*  1.1.  */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            l4Protocol = CPSS_L4_PROTOCOL_TCP_E;
            entryIndex = 0;

            st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, &l4PortType, &compareOperator, &value);

            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "device: %d, %d, %d, %d",
               dev, direction, l4Protocol, entryIndex);

            /*  1.1. */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            l4Protocol = CPSS_L4_PROTOCOL_UDP_E;
            entryIndex = 7;
            l4PortType = CPSS_L4_PROTOCOL_PORT_DST_E;
            compareOperator = CPSS_COMPARE_OPERATOR_NEQ;

            st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, &l4PortType, &compareOperator, &value);

            UTF_VERIFY_EQUAL4_STRING_MAC(GT_OK, st, "device: %d, %d, %d, %d",
               dev, direction, l4Protocol, entryIndex);

            /*  1.2.  */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupTcpUdpPortComparatorGet
                                (dev, portGroupsBmp, direction, l4Protocol, entryIndex,
                                 &l4PortType, &compareOperator, &value),
                                direction);

            /*  1.3.  */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupTcpUdpPortComparatorGet
                                (dev, portGroupsBmp, direction, l4Protocol, entryIndex,
                                 &l4PortType, &compareOperator, &value),
                                l4Protocol);

            /*  1.4. */
            entryIndex = PRV_CPSS_SIP_6_10_CHECK_MAC(dev) ? 64 : 8;

            st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, &l4PortType, &compareOperator, &value);
            UTF_VERIFY_NOT_EQUAL2_STRING_MAC(GT_OK, st,
                            "device: %d, entryIndex = %d", dev, entryIndex);
            entryIndex = 7;

            /*  1.5. */
            st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, NULL, &compareOperator, &value);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_BAD_PTR, st, "device: %d, %d, %d, %d",
               dev, direction, l4Protocol, entryIndex);

            /*  1.6. */
            st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, &l4PortType, NULL, &value);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_BAD_PTR, st, "device: %d, %d, %d, %d",
               dev, direction, l4Protocol, entryIndex);

            /*  1.7. */
            st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, &l4PortType, &compareOperator, NULL);
            UTF_VERIFY_EQUAL4_STRING_MAC(GT_BAD_PTR, st, "device: %d, %d, %d, %d",
               dev, direction, l4Protocol, entryIndex);

        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
                    direction, l4Protocol, entryIndex, &l4PortType, &compareOperator, &value);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
                direction, l4Protocol, entryIndex, &l4PortType, &compareOperator, &value);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* set correct values for all the parameters (except of device number) */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    l4Protocol = CPSS_L4_PROTOCOL_TCP_E;
    entryIndex = 0;


    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_BAD_PARAM.                                          */
        st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
                direction, l4Protocol, entryIndex, &l4PortType, &compareOperator, &value);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupTcpUdpPortComparatorGet(dev, portGroupsBmp,
            direction, l4Protocol, entryIndex, &l4PortType, &compareOperator, &value);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupUserDefinedByteSet
(
    IN GT_U8                                devNum,
    IN GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN CPSS_PCL_DIRECTION_ENT               direction,
    IN GT_U32                               udbIndex,
    IN CPSS_DXCH_PCL_OFFSET_TYPE_ENT        offsetType,
    IN GT_U8                                offset
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupUserDefinedByteSet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(dxChx)

    1.1. Call with ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E], udbIndex [0],
         offsetType [CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
    Expected: GT_OK.

    1.2. Call with ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E], udbIndex [1],
         offsetType [CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E], offset [5].
    Expected: GT_OK for ch/ch2/ch3 devices, GT_BAD_PARAM for others.

    1.3. Call with ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E], udbIndex [2],
         offsetType [CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E], offset [5].
    Expected: GT_OK for ch/ch2/ch3 devices, GT_BAD_PARAM for others.

    1.4. Call with ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E],
         udbIndex [5], offsetType [CPSS_DXCH_PCL_OFFSET_L3_E], offset [5].
    Expected: GT_OK ch1/ch2/ch3 dev and NON GT_OK for others.

    1.5. Call with ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E], udbIndex [2],
         offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
    Expected: GT_OK

    1.6. Call with ruleFormat
         [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E], udbIndex [0],
         offsetType [CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E], offset [5].
    Expected: GT_OK Cheetah2 and above devices,  NOT GT_OK for others.

    1.7. Call with out of range enum value packetType and
        direction[CPSS_PCL_DIRECTION_INGRESS_E].
    Expected: GT_BAD_PARAM for xCat and above, GT_OK for others.

    1.8. Call with out of range enum value packetType and
        direction[CPSS_PCL_DIRECTION_EGRESS_E].
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3, GT_BAD_PARAM for xCat and above, GT_OK for others.

    1.9. Call with out of range enum value direction.
    Expected: GT_BAD_PARAM  for Bobcat2; Caelum; Bobcat3, GT_OK for others.

    1.10. Check for invalid udbIndex. Call with
         ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
         udbIndex [2], offsetType [CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
    Expected: NON GT_OK.

    1.11. Check for invalid udbIndex. Call with
         ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E],
         udbIndex [6], offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
    Expected: NON GT_OK.

    1.12. Check for invalid offsetType. Call with
    ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
    udbIndex [0], offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
    Expected: NON GT_OK.

    1.13. Check for invalid offsetType. Call with
    ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
    udbIndex [2], offsetType [CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
    Expected: NON GT_OK.

    1.14. Check out-of-range ruleFormat. Call with ruleFormat [wrong enum values],
          udbIndex [0], offsetType[CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
    Expected: GT_BAD_PARAM for ch, ch2, ch3 and GT_OK for xCat and above.

    1.15. Check out-of-range offsetType. Call with
          offsetType [wrong enum values], other params same as in 1.1.
    Expected: GT_BAD_PARAM.

    1.16. Check for big value for offset. Call with offset [0xFE] and other
          parameters the same as in 1.1.
    Expected: GT_OUT_OF_RANGE.
*/
    GT_STATUS                           st          = GT_OK;
    GT_U8                               dev         = 0;
    GT_PORT_GROUPS_BMP                  portGroupsBmp = 1;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat  = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    CPSS_DXCH_PCL_PACKET_TYPE_ENT       packetType  = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;
    GT_U32                              udbIndex    = 0;
    CPSS_DXCH_PCL_OFFSET_TYPE_ENT       offsetType  = CPSS_DXCH_PCL_OFFSET_L2_E;
    GT_U8                               offset      = 0;

    CPSS_DXCH_PCL_OFFSET_TYPE_ENT       offsetTypeGet   = 0;
    GT_U8                               offsetGet       = 0;
    CPSS_PP_FAMILY_TYPE_ENT             devFamily       = 0;
    CPSS_PP_DEVICE_TYPE                 devType         = 0;
    GT_U32                              portGroupId     = 0;
    CPSS_PCL_DIRECTION_ENT              direction       = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = prvUtfDeviceFamilyGet(dev, &devFamily);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

            st = prvUtfDeviceTypeGet(dev, &devType);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceTypeGet: %d", dev);

            /*
                1.1. Call with ruleFormat
                     [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E], udbIndex [0],
                     offsetType [CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
                Expected: GT_OK
            */
            offset     = 5;
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;
            udbIndex   = 0;
            offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;

            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);

            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex, offsetType, offset);

            if(st == GT_OK)
            {
                /* verifying values */
                st = cpssDxChPclPortGroupUserDefinedByteGet(
                    dev, portGroupsBmp, ruleFormat, packetType,
                    CPSS_PCL_DIRECTION_INGRESS_E,
                    udbIndex, &offsetTypeGet, &offsetGet);

                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

                UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                         "cpssDxChPclPortGroupUserDefinedByteGet: "
                         "get another offsetType than was set: dev = %d", dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                         "cpssDxChPclPortGroupUserDefinedByteGet: "
                         "get another offset than was set: dev = %d", dev);
            }

            /*
                1.2. Call with ruleFormat
                     [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E], udbIndex [1],
                     offsetType [CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E], offset [5].
                Expected: GT_OK for ch/ch2/ch3 devices, GT_BAD_PARAM for others.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
            udbIndex   = 1;
            offsetType = CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E;
            offset     = 5;

            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);

            if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {
                UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                            offsetType, offset);
            }
            else
            {
                UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                            offsetType, offset);
            }

            if(st == GT_OK)
            {
                /* verifying values */
                st = cpssDxChPclPortGroupUserDefinedByteGet(
                    dev, portGroupsBmp, ruleFormat, packetType,
                    CPSS_PCL_DIRECTION_INGRESS_E,
                    udbIndex, &offsetTypeGet, &offsetGet);

                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

                UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                         "cpssDxChPclPortGroupUserDefinedByteGet: "
                         "get another offsetType than was set: dev = %d", dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                         "cpssDxChPclPortGroupUserDefinedByteGet: "
                         "get another offset than was set: dev = %d", dev);
            }

            /*
                1.3. Call with ruleFormat
                     [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E], udbIndex [2],
                     offsetType [CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E], offset [5].
                Expected: GT_OK for ch/ch2/ch3 devices, GT_BAD_PARAM for others.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E;
            udbIndex   = 2;
            offsetType = CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E;
            offset     = 5;

            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);

            if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {
                UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                            offsetType, offset);
            }
            else
            {
                UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                            offsetType, offset);
            }

            if(st == GT_OK)
            {
                /* verifying values */
                st = cpssDxChPclPortGroupUserDefinedByteGet(
                    dev, portGroupsBmp, ruleFormat, packetType,
                    CPSS_PCL_DIRECTION_INGRESS_E,
                     udbIndex, &offsetTypeGet, &offsetGet);

                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

                UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                             "cpssDxChPclPortGroupUserDefinedByteGet: "
                             "get another offsetType than was set: dev = %d", dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(offset,     offsetGet,
                             "cpssDxChPclPortGroupUserDefinedByteGet: "
                             "get another offset than was set: dev = %d", dev);
            }

            /*
                1.4. Call with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                     udbIndex [2], offsetType [CPSS_DXCH_PCL_OFFSET_L3_E], offset [5]
                     and wrong enum values packetType.
                Expected: GT_OK ch1/ch2/ch3 dev and NON GT_OK for others.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            udbIndex   = 2;
            offsetType = CPSS_DXCH_PCL_OFFSET_L3_E;
            offset     = 5;

            if (! PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {
                for(enumsIndex = 0; enumsIndex < utfInvalidEnumArrSize; enumsIndex++)
                {
                    packetType = utfInvalidEnumArr[enumsIndex];

                    st = cpssDxChPclPortGroupUserDefinedByteSet(
                        dev, portGroupsBmp, ruleFormat, packetType,
                        CPSS_PCL_DIRECTION_INGRESS_E,
                        udbIndex, offsetType, offset);

                    UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                                offsetType, offset);
                    if (GT_OK == st)
                    {
                        /* verifying values */
                        st = cpssDxChPclPortGroupUserDefinedByteGet(
                            dev, portGroupsBmp, ruleFormat, packetType,
                            CPSS_PCL_DIRECTION_INGRESS_E,
                            udbIndex, &offsetTypeGet, &offsetGet);
                        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

                        UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                                         "cpssDxChPclPortGroupUserDefinedByteGet: "
                                         "get another offsetType than was set: dev = %d", dev);
                        UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                                         "cpssDxChPclPortGroupUserDefinedByteGet: "
                                         "get another offset than was set: dev = %d", dev);
                    }

                    packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;
                }
            }
            else
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupUserDefinedByteSet
                                    (dev, portGroupsBmp, ruleFormat, packetType,
                                     CPSS_PCL_DIRECTION_INGRESS_E,
                                     udbIndex, offsetType, offset),
                                     packetType);
            }

            /*
                1.5. Call with ruleFormat
                     [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E], udbIndex [2],
                     offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
                Expected: GT_OK
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
            udbIndex   = 2;
            offsetType = CPSS_DXCH_PCL_OFFSET_L4_E;
            offset     = 5;

            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);

            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
            if(st == GT_OK)
            {
                /* verifying values */
                st = cpssDxChPclPortGroupUserDefinedByteGet(
                    dev, portGroupsBmp, ruleFormat, packetType,
                    CPSS_PCL_DIRECTION_INGRESS_E,
                    udbIndex, &offsetTypeGet, &offsetGet);

                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

                UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                             "cpssDxChPclPortGroupUserDefinedByteGet: "
                             "get another offsetType than was set: dev = %d", dev);
                UTF_VERIFY_EQUAL1_STRING_MAC(offset,     offsetGet,
                             "cpssDxChPclPortGroupUserDefinedByteGet: "
                             "get another offset than was set: dev = %d", dev);
            }
            /*
                1.6. Call with ruleFormat
                     [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E], udbIndex [0],
                     offsetType [CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E], offset [5].
                Expected: GT_OK Cheetah2 and above devices,  NOT GT_OK for others.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
            udbIndex   = 0;
            offsetType = CPSS_DXCH_PCL_OFFSET_TCP_UDP_COMPARATOR_E;
            offset     = 5; /* offset is ignored for TCP_UDP_COMPARATOR */

            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);

            if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
            {
                /* TCP_UDP_COMPARATOR is not supported as anchor */
                UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, udbIndex,
                                                offsetType, offset);
            }
            else
            {
                UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                            offsetType, offset);

                /* verifying values */
                st = cpssDxChPclPortGroupUserDefinedByteGet(
                    dev, portGroupsBmp, ruleFormat, packetType,
                    CPSS_PCL_DIRECTION_INGRESS_E,
                    udbIndex, &offsetTypeGet, &offsetGet);

                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex);

                UTF_VERIFY_EQUAL1_STRING_MAC(offsetType, offsetTypeGet,
                                 "cpssDxChPclPortGroupUserDefinedByteGet: "
                                 "get another offsetType than was set: dev = %d", dev);
            }

            /*
                1.7. Call with out of range enum value packetType and
                    direction[CPSS_PCL_DIRECTION_INGRESS_E].
                Expected: GT_BAD_PARAM for xCat and above, GT_OK for others.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            direction  = CPSS_PCL_DIRECTION_INGRESS_E;
            udbIndex   = 0;
            offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
            offset     = 5;
            packetType = 0x5AAAAAA5;

            st = cpssDxChPclPortGroupUserDefinedByteSet(dev, portGroupsBmp, ruleFormat,
                                                        packetType, direction, udbIndex,
                                                        offsetType, offset);

            if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {

                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }

            /* restore prvious value */
            packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;

            /*
                1.8. Call with out of range enum value packetType and
                    direction[CPSS_PCL_DIRECTION_EGRESS_E].
                Expected: GT_OK for Bobcat2; Caelum; Bobcat3, GT_BAD_PARAM for xCat and above, GT_OK for others.
            */
            direction  = CPSS_PCL_DIRECTION_EGRESS_E;
            packetType = 0x5AAAAAA5;

            st = cpssDxChPclPortGroupUserDefinedByteSet(dev, portGroupsBmp, ruleFormat,
                                                        packetType, direction, udbIndex,
                                                        offsetType, offset);

            if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {

                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }

            /* restore prvious value */
            direction  = CPSS_PCL_DIRECTION_INGRESS_E;
            packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;

            /*
                1.9. Call with out of range enum value direction.
                Expected: GT_BAD_PARAM  for Bobcat2; Caelum; Bobcat3, GT_OK for others.
            */
            direction  = 0x5AAAAAA5;

            st = cpssDxChPclPortGroupUserDefinedByteSet(dev, portGroupsBmp, ruleFormat,
                                                        packetType, direction, udbIndex,
                                                        offsetType, offset);

            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }

            /* restore prvious value */
            direction  = CPSS_PCL_DIRECTION_INGRESS_E;


            /*
                1.10. Check for invalid udbIndex. Call with
                     ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                     udbIndex [2], offsetType [CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
                Expected: NON GT_OK.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
            udbIndex   = 2;
            offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
            offset     = 5;

            if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {
                udbIndex = 23;
            }

            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) != GT_FALSE)
            {
                udbIndex = PRV_CPSS_DXCH_PCL_UDBS_NUM_MAC(dev, CPSS_PCL_DIRECTION_EGRESS_E == direction);
            }

            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);

            UTF_VERIFY_NOT_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                             offsetType, offset);
            /*
                1.11. Check for invalid udbIndex. Call with
                     ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E],
                     udbIndex [6], offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
                Expected: NON GT_OK.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E;
            udbIndex   = 6;
            offsetType = CPSS_DXCH_PCL_OFFSET_L4_E;
            offset     = 5;

            if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {
                offsetType = CPSS_DXCH_PCL_OFFSET_L3_E;
            }

            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);

            UTF_VERIFY_NOT_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                            offsetType, offset);
            /*
                1.12. Check for invalid offsetType. Call with
                ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                udbIndex [0], offsetType [CPSS_DXCH_PCL_OFFSET_L4_E], offset [5].
                Expected: NON GT_OK.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            udbIndex   = 0;
            offsetType = CPSS_DXCH_PCL_OFFSET_L4_E;
            offset     = 5;

            if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {
                offsetType = CPSS_DXCH_PCL_OFFSET_IPV6_EXT_HDR_E;
            }

            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);

            UTF_VERIFY_NOT_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                            offsetType, offset);
            /*
                1.13. Check for invalid offsetType. Call with
                ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E],
                udbIndex [2], offsetType [CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
                Expected: NON GT_OK.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
            udbIndex   = 2;
            offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
            offset     = 5;

            if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {
                /* to cause "BAD_PARAM", for XCat the key type ignored */
                offsetType = CPSS_DXCH_PCL_OFFSET_L3_E;
            }

            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);

            UTF_VERIFY_NOT_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                             offsetType, offset);
            /*
                1.14. Check out-of-range ruleFormat. Call with ruleFormat [wrong enum values],
                      udbIndex [0], offsetType[CPSS_DXCH_PCL_OFFSET_L2_E], offset [5].
                Expected: GT_BAD_PARAM for ch, ch2, ch3 and GT_OK for xCat and above.
            */
            packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;
            udbIndex   = 0;
            offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
            offset     = 5;

            if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {
                /* to cause "BAD_PARAM", for XCat the key type ignored */
                offsetType = CPSS_DXCH_PCL_OFFSET_L3_E;
            }

            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupUserDefinedByteSet
                                (dev, portGroupsBmp, ruleFormat, packetType,
                                 CPSS_PCL_DIRECTION_INGRESS_E,
                                 udbIndex, offsetType, offset),
                                ruleFormat);

            /*
                1.15. Check out-of-range offsetType. Call with
                      offsetType [wrong enum values], other params same as in 1.1.
                Expected: GT_BAD_PARAM.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            udbIndex   = 0;
            offset     = 5;

            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupUserDefinedByteSet
                                (dev, portGroupsBmp, ruleFormat, packetType,
                                 CPSS_PCL_DIRECTION_INGRESS_E,
                                 udbIndex, offsetType, offset),
                                offsetType);

            /*
                1.16. Check for big value for offset. Call with offset [0xFE] and other
                      parameters the same as in 1.1.
                Expected: GT_OUT_OF_RANGE.
            */
            offset     = 0xFE;
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            udbIndex   = 0;
            offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;

            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);

            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, ruleFormat, udbIndex,
                                        offsetType, offset);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        offset     = 0;
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;
        udbIndex   = 0;
        offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupUserDefinedByteSet(
            dev, portGroupsBmp, ruleFormat, packetType,
            CPSS_PCL_DIRECTION_INGRESS_E,
            udbIndex, offsetType, offset);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* set correct values for all the parameters (except of device number) */
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    udbIndex   = 0;
    offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
    offset     = 5;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /*
            2.1. Call function for non active device and valid parameters.
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPclPortGroupUserDefinedByteSet(
            dev, portGroupsBmp, ruleFormat, packetType,
            CPSS_PCL_DIRECTION_INGRESS_E,
            udbIndex, offsetType, offset);

        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupUserDefinedByteSet(
        dev, portGroupsBmp, ruleFormat, packetType,
        CPSS_PCL_DIRECTION_INGRESS_E,
        udbIndex, offsetType, offset);

    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

    /* check that configuration replicated to all port groups */

    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    udbIndex   = 0;
    offsetType = CPSS_DXCH_PCL_OFFSET_L2_E;
    packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;

    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E);

    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* store configuration to all port groups */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        for (udbIndex = 0; (udbIndex < 23); udbIndex++)
        {
            offset     = (GT_U8)udbIndex;
            st = cpssDxChPclPortGroupUserDefinedByteSet(
                dev, portGroupsBmp, ruleFormat, packetType,
                CPSS_PCL_DIRECTION_INGRESS_E,
                udbIndex, offsetType, offset);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }


        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            for (udbIndex = 0; (udbIndex < 23); udbIndex++)
            {
                offset     = (GT_U8)udbIndex;
                st = cpssDxChPclPortGroupUserDefinedByteGet(
                    dev, portGroupsBmp, ruleFormat, packetType,
                    CPSS_PCL_DIRECTION_INGRESS_E,
                    udbIndex, &offsetTypeGet, &offsetGet);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                UTF_VERIFY_EQUAL0_PARAM_MAC(offsetGet, offset);
                UTF_VERIFY_EQUAL0_PARAM_MAC(offsetTypeGet, offsetType);
            }
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)
    }
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupUserDefinedByteGet
(
    IN  GT_U8                                devNum,
    IN  GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_DIRECTION_ENT               direction,
    IN  GT_U32                               udbIndex,
    OUT CPSS_DXCH_PCL_OFFSET_TYPE_ENT        *offsetTypePtr,
    OUT GT_U8                                *offsetPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupUserDefinedByteGet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(dxChx)
    1.1. Call with ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
         packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E, udbIndex [0].
    Expected: GT_OK.
    1.2. Call with wrong enum values ruleFormat.
    Expected: GT_BAD_PARAM.
    1.3. Call with out of range enum value packetType and
        direction[CPSS_PCL_DIRECTION_INGRESS_E].
    Expected: GT_BAD_PARAM for xCat and above, GT_OK for others.
    1.4. Call with out of range enum value packetType and
        direction[CPSS_PCL_DIRECTION_EGRESS_E].
    Expected: GT_OK for Bobcat2; Caelum; Bobcat3, GT_BAD_PARAM for xCat and above, GT_OK for others.
    1.5. Call with out of range enum value direction.
    Expected: GT_BAD_PARAM  for Bobcat2; Caelum; Bobcat3, GT_OK for others.
    1.6. Call with offsetType = NULL (null pointer).
    Expected: GT_BAD_PTR.
    1.7. Call with offset     = NULL (null pointer).
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                           st = GT_OK;

    GT_U8                               dev;
    GT_PORT_GROUPS_BMP                  portGroupsBmp = 1;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    CPSS_DXCH_PCL_PACKET_TYPE_ENT       packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;
    CPSS_PCL_DIRECTION_ENT              direction  = CPSS_PCL_DIRECTION_INGRESS_E;
    GT_U32                              udbIndex = 0;
    CPSS_DXCH_PCL_OFFSET_TYPE_ENT       offsetTypeGet;
    GT_U8                               offsetGet;

    CPSS_PP_FAMILY_TYPE_ENT             devFamily;
    CPSS_PP_DEVICE_TYPE                 devType;

    GT_U32    portGroupId;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceFamilyGet: %d", dev);

        st = prvUtfDeviceTypeGet(dev, &devType);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "prvUtfDeviceTypeGet: %d", dev);

        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);
            /*
                1.1. Call with ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
                     packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E, udbIndex [0].
                Expected: GT_OK.
            */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;
            direction  = CPSS_PCL_DIRECTION_INGRESS_E;
            udbIndex   = 0;

            st = cpssDxChPclPortGroupUserDefinedByteGet(
                dev, portGroupsBmp, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /*
                1.2. Call with wrong enum values ruleFormat.
                Expected: GT_BAD_PARAM.
            */

            if (! PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {
                UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupUserDefinedByteGet
                                    (dev, portGroupsBmp, ruleFormat, packetType, direction,
                                     udbIndex, &offsetTypeGet, &offsetGet),
                                    ruleFormat);
            }
            else
            {
                for(enumsIndex = 0; enumsIndex < utfInvalidEnumArrSize; enumsIndex++)
                {
                    ruleFormat = utfInvalidEnumArr[enumsIndex];

                    st = cpssDxChPclPortGroupUserDefinedByteGet(
                        dev, portGroupsBmp, ruleFormat, packetType, direction,
                        udbIndex, &offsetTypeGet, &offsetGet);

                    UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, ruleFormat, udbIndex,
                                                offsetTypeGet, offsetGet);
                }
                ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            }


            /*
                1.3. Call with out of range enum value packetType and
                    direction[CPSS_PCL_DIRECTION_INGRESS_E].
                Expected: GT_BAD_PARAM for xCat and above, GT_OK for others.
            */
            direction  = CPSS_PCL_DIRECTION_INGRESS_E;
            packetType = 0x5AAAAAA5;

            st = cpssDxChPclPortGroupUserDefinedByteGet(dev, portGroupsBmp, ruleFormat,
                                                        packetType, direction, udbIndex,
                                                        &offsetTypeGet, &offsetGet);

            if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {

                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }

            /* restore prvious value */
            packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;

            /*
                1.4. Call with out of range enum value packetType and
                    direction[CPSS_PCL_DIRECTION_EGRESS_E].
                Expected: GT_OK for Bobcat2; Caelum; Bobcat3, GT_BAD_PARAM for xCat and above, GT_OK for others.
            */
            direction  = CPSS_PCL_DIRECTION_EGRESS_E;
            packetType = 0x5AAAAAA5;

            st = cpssDxChPclPortGroupUserDefinedByteGet(dev, portGroupsBmp, ruleFormat,
                                                        packetType, direction, udbIndex,
                                                        &offsetTypeGet, &offsetGet);

            if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
            {

                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }

            /* restore prvious value */
            direction  = CPSS_PCL_DIRECTION_INGRESS_E;
            packetType = CPSS_DXCH_PCL_PACKET_TYPE_ETHERNET_OTHER_E;

            /*
                1.5. Call with out of range enum value direction.
                Expected: GT_BAD_PARAM  for Bobcat2; Caelum; Bobcat3, GT_OK for others.
            */
            direction  = 0x5AAAAAA5;

            st = cpssDxChPclPortGroupUserDefinedByteGet(dev, portGroupsBmp, ruleFormat,
                                                        packetType, direction, udbIndex,
                                                        &offsetTypeGet, &offsetGet);

            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
            }
            else
            {
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }

            /* restore prvious value */
            direction  = CPSS_PCL_DIRECTION_INGRESS_E;

            /*
                1.6. Call with offsetType = NULL (null pointer).
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupUserDefinedByteGet(
                dev, portGroupsBmp, ruleFormat, packetType, direction,
                udbIndex, NULL, &offsetGet);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

            /*
                1.7. Call with offset = NULL (null pointer).
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupUserDefinedByteGet(
                dev, portGroupsBmp, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupUserDefinedByteGet(
                dev, portGroupsBmp, ruleFormat, packetType, direction,
                udbIndex, &offsetTypeGet, &offsetGet);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupUserDefinedByteGet(
            dev, portGroupsBmp, ruleFormat, packetType, direction,
            udbIndex, &offsetTypeGet, &offsetGet);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    udbIndex   = 0;
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* go over all non active devices */

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortGroupUserDefinedByteGet(
            dev, portGroupsBmp, ruleFormat, packetType, direction,
            udbIndex, &offsetTypeGet, &offsetGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st  = cpssDxChPclPortGroupUserDefinedByteGet(
        dev, portGroupsBmp, ruleFormat, packetType, direction,
        udbIndex, &offsetTypeGet, &offsetGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclUdeEtherTypeSet
(
    IN  GT_U8           devNum,
    IN  GT_U32          index,
    IN  GT_U32          ethType
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclUdeEtherTypeSet)
{
/*
    ITERATE_DEVICES (Lion and above)
    1.1. Call with index [0..5], ethType [0..0xFFFF]
    Expected: GT_OK.
    1.2. Call cpssDxChPclUdeEtherTypeGet with non-NULL pointers
                                         other params same as in 1.1.
    Expected: GT_OK and the same values.
    1.3. Call with out of range index [6], other params same as in 1.1.
    Expected: NOT GT_OK.
    1.4. Call with out of range ethType [0x10000], other params same as in 1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_U32      index      = 0;
    GT_U32      ethType    = 0;
    GT_U32      ethTypeGet = 0;


    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with index [0..4], ethType [0..0xFFFF]
            Expected: GT_OK.
        */
        for (index = 0; (index < 5); index++)
        {
            ethType = 13107 * index;

            st = cpssDxChPclUdeEtherTypeSet(dev, index, ethType);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, index, ethType);

            /*
                1.2. Call cpssDxChPclUdeEtherTypeGet with non-NULL pointers
                                                     other params same as in 1.1.
                Expected: GT_OK and the same values.
            */
            if (GT_OK == st)
            {
                st = cpssDxChPclUdeEtherTypeGet(dev, index, &ethTypeGet);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                           "cpssDxChPclUdeEtherTypeGet: %d", dev);

                /* verifying values */
                UTF_VERIFY_EQUAL1_STRING_MAC(ethType, ethTypeGet,
                           "got another ethType then was set: %d", dev);
            }
        }

        /*
            1.3. Call with out of range index [5], other params same as in 1.1.
            Expected: NOT GT_OK.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev))
        {
            index = 8;
        }
        else
        {
            index = 5;
        }

        st = cpssDxChPclUdeEtherTypeSet(dev, index, ethType);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, index);

        index = 0;

        /*
            1.4. Call with out of range ethType [0x10000], other params same as in 1.1.
            Expected: NOT GT_OK.
        */
        ethType = 0x10000;

        st = cpssDxChPclUdeEtherTypeSet(dev, index, ethType);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, index);
    }

    index   = 0;
    ethType = 0;

    /* 2. For not active devices check that function returns non GT_OK.*/
    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclUdeEtherTypeSet(dev, index, ethType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclUdeEtherTypeSet(dev, index, ethType);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclUdeEtherTypeGet
(
    IN  GT_U8           devNum,
    IN  GT_U32          index,
    OUT GT_U32          *ethTypePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclUdeEtherTypeGet)
{
/*
    ITERATE_DEVICES (Lion and above)
    1.1. Call with index [0..5], non NULL ethTypePtr.
    Expected: GT_OK.
    1.2. Call with out of range index [6], other params same as in 1.1.
    Expected: NOT GT_OK.
    1.3. Call with ethTypePtr [NULL], other params same as in 1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_U32      index   = 0;
    GT_U32      ethType = 0;


    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with index [0..4], non NULL ethTypePtr.
            Expected: GT_OK.
        */
        for (index = 0; (index < 5); index++)
        {
            ethType = 13107 * index;

            st = cpssDxChPclUdeEtherTypeGet(dev, index, &ethType);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, index);
        }

        /*
            1.2. Call with out of range index [5], other params same as in 1.1.
            Expected: NOT GT_OK.
        */
        if(UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev))
        {
            index = 8;
        }
        else
        {
            index = 5;
        }

        st = cpssDxChPclUdeEtherTypeGet(dev, index, &ethType);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, index);

        index = 0;

        /*
            1.3. Call with ethTypePtr [NULL], other params same as in 1.1.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclUdeEtherTypeGet(dev, index, NULL);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, "%d, ethTypePtr = NULL", dev);
    }

    index = 0;

    /* 2. For not active devices check that function returns non GT_OK.*/
    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclUdeEtherTypeGet(dev, index, &ethType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclUdeEtherTypeGet(dev, index, &ethType);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet
(
    IN  GT_U8                                      devNum,
    IN  GT_PORT_GROUPS_BMP                         portGroupsBmp,
    IN  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   vidUpMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS (Lion and above)
    1.1.1. Call with vidUpMode [CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E /
                                CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG1_E]
    Expected: GT_OK.
    1.1.2. Call cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet with non-NULL pointers
                                                                     other params same as in 1.1.1.
    Expected: GT_OK and the same values.
    1.1.3. Call with out of range vidUpMode [wrong enum values],
                     other params same as in 1.1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS               st = GT_OK;
    GT_U8                   dev;
    GT_PORT_GROUPS_BMP      portGroupsBmp = 1;
    GT_U32                  portGroupId   = 0;

    CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT vidUpMode    =
                            CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E;
    CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT vidUpModeGet =
                            CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E | UTF_CPSS_PP_E_ARCH_CNS);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            /* set next active port */
            portGroupsBmp = (1 << portGroupId);

            /*
                1.1.1. Call with vidUpMode [CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E /
                                            CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG1_E]
                Expected: GT_OK.
            */
            vidUpMode = CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E;

            st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet(dev, portGroupsBmp, vidUpMode);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, portGroupsBmp, vidUpMode);

            /*
                1.1.2. Call cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet
                with non-NULL pointers other params same as in 1.1.1.
                Expected: GT_OK and the same values.
            */
            st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet(dev,
                                        portGroupsBmp ,&vidUpModeGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                       "cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet: %d", dev);

            /* validation values */
            UTF_VERIFY_EQUAL1_STRING_MAC(vidUpMode, vidUpModeGet,
                       "got another vidUpMode then was set: %d", dev);

            /*
                1.1.1. Call with vidUpMode [CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E /
                                            CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG1_E]
                Expected: GT_OK.
            */
            vidUpMode = CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG1_E;

            st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet(dev,
                                                portGroupsBmp, vidUpMode);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, portGroupsBmp, vidUpMode);

            /*
                1.1.2. Call cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet
                with non-NULL pointers other params same as in 1.1.1.
                Expected: GT_OK and the same values.
            */
            st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet(dev,
                                        portGroupsBmp ,&vidUpModeGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                       "cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet: %d", dev);

            /* validation values */
            UTF_VERIFY_EQUAL1_STRING_MAC(vidUpMode, vidUpModeGet,
                       "got another vidUpMode then was set: %d", dev);

            /*
                1.1.3. Call with out of range vidUpMode [wrong enum values],
                                 other params same as in 1.1.1.
                Expected: NOT GT_OK.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet
                                (dev, portGroupsBmp, vidUpMode),
                                vidUpMode);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev, portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev, portGroupId)
        {
            /* set next non-active port */
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet(dev,
                                            portGroupsBmp, vidUpMode);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev, portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet(dev, portGroupsBmp, vidUpMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    vidUpMode = CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E | UTF_CPSS_PP_E_ARCH_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet(dev, portGroupsBmp, vidUpMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet(dev, portGroupsBmp, vidUpMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet
(
    IN   GT_U8                                      devNum,
    IN   GT_PORT_GROUPS_BMP                         portGroupsBmp,
    OUT  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   *vidUpModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS (Lion and above)
    1.1.1. Call with non NULL vidUpModePtr.
    Expected: GT_OK.
    1.1.2. Call with vidUpModePtr [NULL],
                     other params same as in 1.1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS               st = GT_OK;
    GT_U8                   dev;
    GT_PORT_GROUPS_BMP      portGroupsBmp = 1;
    GT_U32                  portGroupId   = 0;

    CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT vidUpMode =
                            CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E | UTF_CPSS_PP_E_ARCH_CNS);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            /* set next active port */
            portGroupsBmp = (1 << portGroupId);

            /*
                1.1.1. Call with non NULL vidUpModePtr.
                Expected: GT_OK.
            */
            st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet(dev,
                                            portGroupsBmp, &vidUpMode);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, portGroupsBmp, vidUpMode);

            /*
                1.1.2. Call with vidUpModePtr [NULL],
                                 other params same as in 1.1.1.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet(dev, portGroupsBmp, NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, vidUpModePtr = NULL", dev);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev, portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev, portGroupId)
        {
            /* set next non-active port */
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet(dev,
                                            portGroupsBmp, &vidUpMode);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev, portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet(dev, portGroupsBmp, &vidUpMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E | UTF_CPSS_PP_E_ARCH_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet(dev, portGroupsBmp, &vidUpMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet(dev, portGroupsBmp, &vidUpMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressKeyFieldsVidUpModeSet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   vidUpMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressKeyFieldsVidUpModeSet)
{
/*
    ITERATE_DEVICES (Lion and above)
    1.1. Call with vidUpMode [CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E /
                              CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG1_E]
    Expected: GT_OK.
    1.2. Call cpssDxChPclEgressKeyFieldsVidUpModeGet with non-NULL pointers
                                                          other params same as in 1.1.
    Expected: GT_OK and the same values.
    1.3. Call with out of range vidUpMode [wrong enum values],
                     other params same as in 1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS               st = GT_OK;
    GT_U8                   dev;

    CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT vidUpMode    =
                                CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E;
    CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT vidUpModeGet =
                                CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E;


    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E | UTF_CPSS_PP_E_ARCH_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with vidUpMode [CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E /
                                      CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG1_E]
            Expected: GT_OK.
        */
        vidUpMode = CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E;

        st = cpssDxChPclEgressKeyFieldsVidUpModeSet(dev, vidUpMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, vidUpMode);

        /*
            1.2. Call cpssDxChPclEgressKeyFieldsVidUpModeGet
            with non-NULL pointers other params same as in 1.1.
            Expected: GT_OK and the same values.
        */
        st = cpssDxChPclEgressKeyFieldsVidUpModeGet(dev, &vidUpModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxChPclEgressKeyFieldsVidUpModeGet: %d", dev);

        /* validation values */
        UTF_VERIFY_EQUAL1_STRING_MAC(vidUpMode, vidUpModeGet,
                   "got another vidUpMode then was set: %d", dev);

        /*
            1.1. Call with vidUpMode [CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E /
                                      CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG1_E]
            Expected: GT_OK.
        */
        vidUpMode = CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG1_E;

        st = cpssDxChPclEgressKeyFieldsVidUpModeSet(dev, vidUpMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, vidUpMode);

        /*
            1.2. Call cpssDxChPclEgressKeyFieldsVidUpModeGet
                    with non-NULL pointers other params same as in 1.1.
            Expected: GT_OK and the same values.
        */
        st = cpssDxChPclEgressKeyFieldsVidUpModeGet(dev, &vidUpModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxChPclEgressKeyFieldsVidUpModeGet: %d", dev);

        /* validation values */
        UTF_VERIFY_EQUAL1_STRING_MAC(vidUpMode, vidUpModeGet,
                   "got another vidUpMode then was set: %d", dev);

        /*
            1.3. Call with out of range vidUpMode [wrong enum values],
                           other params same as in 1.1.
            Expected: NOT GT_OK.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclEgressKeyFieldsVidUpModeSet
                            (dev, vidUpMode),
                            vidUpMode);
    }

    vidUpMode = CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E;

    /* 2. For not active devices check that function returns non GT_OK.*/
    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E | UTF_CPSS_PP_E_ARCH_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressKeyFieldsVidUpModeSet(dev, vidUpMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressKeyFieldsVidUpModeSet(dev, vidUpMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressKeyFieldsVidUpModeGet
(
    IN   GT_U8                                      devNum,
    OUT  CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT   *vidUpModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressKeyFieldsVidUpModeGet)
{
/*
    ITERATE_DEVICES (Lion and above)
    1.1. Call with non NULL vidUpModePtr.
    Expected: GT_OK.
    1.2. Call with vidUpModePtr [NULL],
                   other params same as in 1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS               st = GT_OK;
    GT_U8                   dev;

    CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_MODE_ENT vidUpMode =
                            CPSS_DXCH_PCL_EGRESS_KEY_VID_UP_FROM_TAG0_E;


    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E | UTF_CPSS_PP_E_ARCH_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with non NULL vidUpModePtr.
            Expected: GT_OK.
        */
        st = cpssDxChPclEgressKeyFieldsVidUpModeGet(dev, &vidUpMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, vidUpMode);

        /*
            1.2. Call with vidUpModePtr [NULL],
                           other params same as in 1.1.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclEgressKeyFieldsVidUpModeGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, vidUpModePtr = NULL", dev);
    }

    /* 2. For not active devices check that function returns non GT_OK.*/
    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E | UTF_XCAT_E | UTF_XCAT3_E | UTF_AC5_E | UTF_CPSS_PP_E_ARCH_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressKeyFieldsVidUpModeGet(dev, &vidUpMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressKeyFieldsVidUpModeGet(dev, &vidUpMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}


/*----------------------------------------------------------------------------*/
/*
    Test function to Fill Rule table.
*/
UTF_TEST_CASE_MAC(cpssDxChPclFillRuleTable)
{
/*
    ITERATE_DEVICE (DxChx)
    1.1. Get table Size.
         Call cpssDxChCfgTableNumEntriesGet with table[CPSS_DXCH_CFG_TABLE_PCL_ACTION_E]
                                                 and not NULL numEntriesPtr.
    Expected: GT_OK.
    1.2. Fill all entries in Rule table.
         Call cpssDxChPclRuleSet with ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                ruleIndex [0 ... numEntries-1], maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ],
                patternPtr-> ruleStdNotIp [ common[pclId=0; sourcePort=5; isTagged=1;
                vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1; isUdbValid =1],
                isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
                macSa=AB:CD:EF:00:00:01; udb[10,20,30] ],
                actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
                mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
                matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
                qos { egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE ,
                qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
                profilePrecedence=GT_FALSE] ] },
                redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
                data[routerLttIndex=0] }, policer { policerEnable=GT_FALSE, policerId=0 },
                vlan { egressTaggedModify=GT_FALSE,
                modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
                vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
                ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
    Expected: GT_OK.
    1.3. Try to write entry with index out of range.
         Call cpssDxChPclRuleSet with ruleIndex [numEntries] and other params from 1.2.
    Expected: NOT GT_OK.
    1.4. Read all entries in Rule table and compare with original.
         Call cpssDxChPclRuleGet with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                                      ruleIndex [0 ... numEntries-1],
                                      non-NULL mask,
                                      pattern and action.
    Expected: GT_OK.
    1.5. Try to read entry with index out of range.
         Call cpssDxChPclRuleGet with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                                      ruleIndex [numEntries],

    Expected: NOT GT_OK.
    1.6. Delete all entries in Rule table.
         Call cpssDxChPclRuleInvalidate with ruleSize and ruleIndex from 1.2.
    Expected: GT_OK.
    1.7. Try to delete entry with index out of range.
         Call cpssDxChPclRuleInvalidate with ruleSize and ruleIndex [numEntries].
    Expected: NOT GT_OK.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_U32      numEntries = 0;
    GT_U32      iTemp      = 0;
    GT_U32               step = 1;
    GT_U32   gmFillMaxIterations = 128;

    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat =
                                    CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT       mask;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT       pattern;
    CPSS_DXCH_PCL_ACTION_STC            action;
    GT_U32                              maskGet[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS];
    GT_U32                              patternGet[CPSS_DXCH_PCL_RULE_SIZE_IN_WORDS_CNS];
    GT_U32                              actionGet[CPSS_DXCH_PCL_ACTION_SIZE_IN_WORDS_CNS];
    GT_ETHERADDR                        mac1 = {{0xAB, 0xCD, 0xEF, 0x00, 0x00, 0x01}};
    GT_ETHERADDR                        mac2 = {{0xAB, 0xCD, 0xEF, 0x00, 0x00, 0x02}};
    CPSS_PP_FAMILY_TYPE_ENT             devFamily = CPSS_PP_FAMILY_CHEETAH_E;
    CPSS_PCL_RULE_SIZE_ENT              ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;


    PRV_TGF_SKIP_TO_REDUCE_LOG_SIZE_MAC;

    cpssOsBzero((GT_VOID*) &mask, sizeof(mask));
    cpssOsBzero((GT_VOID*) &pattern, sizeof(pattern));
    cpssOsBzero((GT_VOID*) &action, sizeof(action));
    cpssOsBzero((GT_VOID*) &maskGet, sizeof(maskGet));
    cpssOsBzero((GT_VOID*) &patternGet, sizeof(patternGet));
    cpssOsBzero((GT_VOID*) &actionGet, sizeof(actionGet));

    /* Fill the entry for FDB table */
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;

    pattern.ruleStdNotIp.common.pclId = 0;
    pattern.ruleStdNotIp.common.sourcePort = 5;
    pattern.ruleStdNotIp.common.isTagged = 1;
    pattern.ruleStdNotIp.common.vid = 100;
    pattern.ruleStdNotIp.common.up = 0;
    pattern.ruleStdNotIp.common.qosProfile = 0;
    pattern.ruleStdNotIp.common.isIp = 0;
    pattern.ruleStdNotIp.common.isL2Valid = 1;
    pattern.ruleStdNotIp.common.isUdbValid = 1;
    pattern.ruleStdNotIp.isIpv4 = 0;
    pattern.ruleStdNotIp.etherType = 0;
    pattern.ruleStdNotIp.isArp = 0;
    pattern.ruleStdNotIp.l2Encap = 0;
    pattern.ruleStdNotIp.macDa = mac2;
    pattern.ruleStdNotIp.macSa = mac1;
    pattern.ruleStdNotIp.udb15_17[0] = 10;
    pattern.ruleStdNotIp.udb15_17[1] = 20;
    pattern.ruleStdNotIp.udb15_17[2] = 30;

    mask.ruleStdNotIp.common.pclId = 0x3FF;
    mask.ruleStdNotIp = pattern.ruleStdNotIp;
    mask.ruleStdNotIp.common.sourcePort = 0x3F;


    pclActionDefaultSet(&action);

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Get table Size */
        st = cpssDxChCfgTableNumEntriesGet(dev, CPSS_DXCH_CFG_TABLE_PCL_ACTION_E, &numEntries);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "cpssDxChCfgTableNumEntriesGet: %d", dev);

        if (IS_NEEDED_TO_REDUCE_ITERATIONS_DUE_TO_POOR_PERFORMANCE_MAC || GT_TRUE == prvUtfReduceLogSizeFlagGet())
        {
            /* get new step that will match 'max iterations' for GM*/
            step = prvUtfIterationReduce(dev,numEntries,gmFillMaxIterations,step);
        }

        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,"prvUtfDeviceFamilyGet: %d", dev);

        if (devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
        {   /* 'disable' not supported on CHEETAH 3 */
            action.qos.egress.modifyDscp = CPSS_DXCH_PCL_ACTION_EGRESS_DSCP_EXP_CMD_KEEP_E;
            action.qos.egress.modifyUp   = CPSS_DXCH_PCL_ACTION_EGRESS_TAG0_CMD_DO_NOT_MODIFY_E;
        }

        /* 1.2. Fill all entries in Rule table */
        for(iTemp = 0; iTemp < numEntries; iTemp+=step)
        {
            /* make every entry unique */
            pattern.ruleStdNotIp.common.up  = (GT_U8)(iTemp % 7);
            pattern.ruleStdNotIp.common.vid = (GT_U16)(iTemp % 4095);

            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                /* for E_ARCH check index validity */
                st = prvCpssDxChTcamRuleIndexCheck(dev,iTemp,CPSS_DXCH_TCAM_RULE_SIZE_30_B_E);
                if (st != GT_OK)
                    continue;
            }

            st = cpssDxChPclRuleSet(
                dev, mainUtCpssDxChPclTcamIndex, ruleFormat, iTemp, 0 /*ruleOptionsBmp*/,
                &mask, &pattern, &action);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                        "cpssDxChPclRuleSet: %d, %d, %d", dev, ruleFormat, iTemp);
        }

        /* 1.3. Try to write entry with index out of range. */


        st = cpssDxChPclRuleSet(
            dev, mainUtCpssDxChPclTcamIndex, ruleFormat, numEntries, 0 /*ruleOptionsBmp*/,
            &mask, &pattern, &action);
        UTF_VERIFY_NOT_EQUAL3_STRING_MAC(GT_OK, st,
                         "cpssDxChPclRuleSet: %d, %d, %d", dev, ruleFormat, numEntries);


        /* 1.4. Read all entries in Rule table and compare with original */
        for(iTemp = 0; iTemp < numEntries; iTemp+=step)
        {
            /* restore unique entry before compare */
            pattern.ruleStdNotIp.common.up  = (GT_U8)(iTemp % 7);
            pattern.ruleStdNotIp.common.vid = (GT_U16)(iTemp % 4095);

            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                /* for E_ARCH check index validity */
                st = prvCpssDxChTcamRuleIndexCheck(dev,iTemp,CPSS_DXCH_TCAM_RULE_SIZE_30_B_E);
                if (st != GT_OK)
                    continue;
            }

            st = cpssDxChPclRuleGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, iTemp,
                    maskGet, patternGet, actionGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "cpssDxChPclRuleGet: %d, %d, %d", dev, ruleSize, iTemp);
        }

        /* 1.5. Try to read entry with index out of range. */
        st = cpssDxChPclRuleGet(dev, mainUtCpssDxChPclTcamIndex, ruleSize, numEntries,
                    maskGet, patternGet, actionGet);
        UTF_VERIFY_NOT_EQUAL3_STRING_MAC(GT_OK, st,
                    "cpssDxChPclRuleGet: %d, %d, %d", dev, ruleSize, numEntries);

        /* 1.6. Delete all entries in Rule table */
        for(iTemp = 0; iTemp < numEntries; iTemp+=step)
        {
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                /* for E_ARCH check index validity */
                st = prvCpssDxChTcamRuleIndexCheck(dev,iTemp,CPSS_DXCH_TCAM_RULE_SIZE_30_B_E);
                if (st != GT_OK)
                    continue;
            }
            st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, iTemp);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "cpssDxChPclRuleInvalidate: %d, %d, %d", dev, ruleSize, iTemp);
        }

        /* 1.7. Try to delete entry with index out of range. */

        st = cpssDxChPclRuleInvalidate(dev, mainUtCpssDxChPclTcamIndex, ruleSize, numEntries);
        UTF_VERIFY_NOT_EQUAL3_STRING_MAC(GT_OK, st,
                "cpssDxChPclRuleInvalidate: %d, %d, %d", dev, ruleSize, numEntries);
    }
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclL3L4ParsingOverMplsEnableGet
(
    IN  GT_U8    dev,
    OUT GT_BOOL  *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclL3L4ParsingOverMplsEnableGet)
{
/*
    ITERATE_DEVICES(All DxChXcat and above devices)
    1.1. Call with not null enablePtr.
    Expected: GT_OK.
    1.2. Call api with wrong enablePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;

    GT_U8    dev;
    GT_BOOL  enable;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with not null enablePtr.
            Expected: GT_OK.
        */
        st = cpssDxChPclL3L4ParsingOverMplsEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call api with wrong enablePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclL3L4ParsingOverMplsEnableGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                   "%d, enablePtr = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclL3L4ParsingOverMplsEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclL3L4ParsingOverMplsEnableGet(dev, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclL3L4ParsingOverMplsEnableSet
(
    IN  GT_U8   dev,
    IN  GT_BOOL enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclL3L4ParsingOverMplsEnableSet)
{
/*
    ITERATE_DEVICES(All DxChXcat and above devices)
    1.1. Call with enable[GT_TRUE / GT_FALSE],
    Expected: GT_OK.
    1.2. Call cpssDxChPclL3L4ParsingOverMplsEnableGet
           with the same parameters.
    Expected: GT_OK and the same values than was set.
*/
    GT_STATUS st = GT_OK;

    GT_U8   dev;
    GT_BOOL enable = GT_FALSE;
    GT_BOOL enableGet = GT_FALSE;
    GT_BOOL deviceSupported = GT_TRUE;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        deviceSupported = GT_TRUE;

        /* we are aware that all DXCH GM devices not support it */
        if((prvUtfIsGmCompilation() == GT_TRUE))
        {
            /* note: since the GM not support the functionality of the field ,
              the cpss not allow to set it , but the 'get' API is operational (to return 'Feature is disabled' ...)
            */
            deviceSupported = GT_FALSE;
        }

        /*
            1.1. Call with enable[GT_TRUE / GT_FALSE],
            Expected: GT_OK.
        */
        /* call with enable[GT_TRUE] */
        enable = GT_TRUE;

        st = cpssDxChPclL3L4ParsingOverMplsEnableSet(dev, enable);
        if(deviceSupported == GT_TRUE)
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /*
                1.2. Call cpssDxChPclL3L4ParsingOverMplsEnableGet
                       with the same parameters.
                Expected: GT_OK and the same values than was set.
            */
            st = cpssDxChPclL3L4ParsingOverMplsEnableGet(dev, &enableGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                      "cpssDxChPclL3L4ParsingOverMplsEnableGet: %d ", dev);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                           "got another enable then was set: %d", dev);
        }
        else
        {
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }

        /* call with enable[GT_FALSE] */
        enable = GT_FALSE;

        st = cpssDxChPclL3L4ParsingOverMplsEnableSet(dev, enable);
        if(deviceSupported == GT_TRUE)
        {
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }
        else
        {
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }

        /* call get func again, 1.2. */
        st = cpssDxChPclL3L4ParsingOverMplsEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPclL3L4ParsingOverMplsEnableGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                       "got another enable then was set: %d", dev);
    }

    /* restore correct values */
    enable = GT_TRUE;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclL3L4ParsingOverMplsEnableSet(dev, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclL3L4ParsingOverMplsEnableSet(dev, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupLookupCfgPortListEnableGet
(
    IN  GT_U8                         devNum,
    IN  GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    OUT GT_BOOL                       *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupLookupCfgPortListEnableGet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(xCat2)
    1.1. Call direction [CPSS_PCL_DIRECTION_INGRESS_E /
                         CPSS_PCL_DIRECTION_EGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E /
                         CPSS_PCL_LOOKUP_1_E],
         subLookupNum [0] and non-NULL enablePtr.
    Expected: GT_OK.
    1.2. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E],
         subLookupNum [1] and non-NULL enablePtr.
    Expected: GT_OK.
    1.3. Call direction [CPSS_PCL_DIRECTION_EGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E],
              subLookupNum [2] (not relevant)
              and non-NULL enablePtr.
    Expected: GT_OK.
    1.4. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_1_E],
              subLookupNum [3] (not relevant)
              and non-NULL enablePtr.
    Expected: GT_OK.
    1.5. Check for invalid enum value for direction.
    Expected: GT_BAD_PARAM.
    1.6. Check wrong enum values lookupNum.
    Expected: GT_BAD_PARAM.
    1.7. Check wrong enablePtr[NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                    st = GT_OK;
    GT_U8                        dev;
    GT_PORT_GROUPS_BMP           portGroupsBmp = 1;
    CPSS_PCL_DIRECTION_ENT       direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_PCL_LOOKUP_NUMBER_ENT   lookupNum = CPSS_PCL_LOOKUP_0_E;
    GT_U32                       subLookupNum = 0;
    GT_BOOL                      enable = GT_FALSE;
    GT_BOOL                      iPcl0Bypass;
    CPSS_PP_FAMILY_TYPE_ENT      devFamily;
    GT_STATUS                    expectedRc;
    GT_U32                       portGroupId;

    /* prepare device iterator */
    /* AC5 applicable for ingress and not applicable for egress */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,"prvUtfDeviceFamilyGet: %d", dev);

        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /*
                1.1. Call direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                     CPSS_PCL_DIRECTION_EGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_0_E /
                                     CPSS_PCL_LOOKUP_1_E],
                     subLookupNum [0] and non-NULL enablePtr.
                Expected: GT_OK.
            */
            /* Call with direction [CPSS_PCL_DIRECTION_INGRESS_E] */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            subLookupNum = 0;

            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, &enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /* Call with direction [CPSS_PCL_DIRECTION_EGRESS_E] */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;

            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, &enable);
            expectedRc =
                (devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
                    ? GT_NOT_APPLICABLE_DEVICE : GT_OK;
            UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.2. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_0_E],
                     subLookupNum [1] and non-NULL enablePtr.
                Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            subLookupNum = 1;

            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, &enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.3. Call direction [CPSS_PCL_DIRECTION_EGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_0_E],
                          subLookupNum [2] (not relevant)
                          and non-NULL enablePtr.
                Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            subLookupNum = 2;

            expectedRc =
                (devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
                    ? GT_NOT_APPLICABLE_DEVICE : GT_OK;
            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, &enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.4. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_1_E],
                          subLookupNum [3] (not relevant)
                          and non-NULL enablePtr.
                Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;
            subLookupNum = 3;

            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, &enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.5. Check for invalid enum value for direction.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupLookupCfgPortListEnableGet
                                (dev, portGroupsBmp, direction, lookupNum,
                                 subLookupNum, &enable),
                                direction);

            /*
                1.6. Check wrong enum values lookupNum.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupLookupCfgPortListEnableGet
                            (dev, portGroupsBmp, direction, lookupNum,
                             subLookupNum, &enable),
                             lookupNum);

            /*
                1.7. Check wrong enablePtr[NULL].
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                    "device: %d, enable = NULL", dev);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, &enable);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                    direction, lookupNum, subLookupNum, &enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* set correct values for all the parameters (except of device number) */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    subLookupNum = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. Call function for non active device and valid parameters. */
        /* Expected: GT_BAD_PARAM.                                        */
        st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                    direction, lookupNum, subLookupNum, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                direction, lookupNum, subLookupNum, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupLookupCfgPortListEnableSet
(
    IN  GT_U8                         devNum,
    IN  GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    IN  GT_BOOL                       enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupLookupCfgPortListEnableSet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(xCat2)
    1.1. Call direction [CPSS_PCL_DIRECTION_INGRESS_E /
                         CPSS_PCL_DIRECTION_EGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E /
                         CPSS_PCL_LOOKUP_1_E],
         subLookupNum [0] and enable[GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.2. Call cpssDxChPclPortGroupLookupCfgPortListEnableGet
         with the same parameters.
    Expected: GT_OK and the same enable as was set.
    1.3. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E],
         subLookupNum [1] and enable[GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.4. Call direction [CPSS_PCL_DIRECTION_EGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E],
              subLookupNum [2] (not relevant)
              and enable[GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.5. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_1_E],
              subLookupNum [3] (not relevant)
              and enable[GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.6. Check for invalid enum value for direction.
    Expected: GT_BAD_PARAM.
    1.7. Check wrong enum values lookupNum.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                    st = GT_OK;
    GT_U8                        dev;
    GT_PORT_GROUPS_BMP           portGroupsBmp = 1;
    CPSS_PCL_DIRECTION_ENT       direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_PCL_LOOKUP_NUMBER_ENT   lookupNum = CPSS_PCL_LOOKUP_0_E;
    GT_U32                       subLookupNum = 0;
    GT_BOOL                      enable = GT_FALSE;
    GT_BOOL                      enableGet = GT_TRUE;
    GT_BOOL                      iPcl0Bypass;
    CPSS_PP_FAMILY_TYPE_ENT      devFamily;
    GT_STATUS                    expectedRc;
    GT_U32                       portGroupId;

    /* prepare device iterator */
    /* AC5 applicable for ingress and not applicable for egress */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,"prvUtfDeviceFamilyGet: %d", dev);

        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /*
                1.1. Call direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                     CPSS_PCL_DIRECTION_EGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_0_E /
                                     CPSS_PCL_LOOKUP_1_E],
                     subLookupNum [0] and enable[GT_FALSE / GT_TRUE].
                Expected: GT_OK.
            */
            /* Call with direction [CPSS_PCL_DIRECTION_INGRESS_E] */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            subLookupNum = 0;
            enable = GT_FALSE;

            st = cpssDxChPclPortGroupLookupCfgPortListEnableSet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.2. Call cpssDxChPclPortGroupLookupCfgPortListEnableGet
                     with the same parameters.
                Expected: GT_OK and the same enable as was set.
            */
            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, &enableGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "cpssDxChPclPortGroupLookupCfgPortListEnableGet: %d, %d, %d",
                                         dev, direction, subLookupNum);
            /* check value */
            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                 "cpssDxChPclPortGroupLookupCfgPortListEnableGet: "
                 "get another enable than was set: dev = %d", dev);

            /* Call with direction [CPSS_PCL_DIRECTION_EGRESS_E] */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;
            enable = GT_TRUE;

            expectedRc =
                (devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
                    ? GT_NOT_APPLICABLE_DEVICE : GT_OK;

            st = cpssDxChPclPortGroupLookupCfgPortListEnableSet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.2. Call cpssDxChPclPortGroupLookupCfgPortListEnableGet
                     with the same parameters.
                Expected: GT_OK and the same enable as was set.
            */
            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, &enableGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
                 "cpssDxChPclPortGroupLookupCfgPortListEnableGet: %d, %d, %d",
                                         dev, direction, subLookupNum);

            if (expectedRc == GT_OK)
            {
                /* check value */
                UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                     "cpssDxChPclPortGroupLookupCfgPortListEnableGet: "
                     "get another enable than was set: dev = %d", dev);
            }

            /*
                1.3. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_0_E],
                     subLookupNum [1] and enable[GT_FALSE / GT_TRUE].
                Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            subLookupNum = 1;

            st = cpssDxChPclPortGroupLookupCfgPortListEnableSet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.2. Call cpssDxChPclPortGroupLookupCfgPortListEnableGet
                     with the same parameters.
                Expected: GT_OK and the same enable as was set.
            */
            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, &enableGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "cpssDxChPclPortGroupLookupCfgPortListEnableGet: %d, %d, %d",
                                         dev, direction, subLookupNum);
            /* check value */
            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                 "cpssDxChPclPortGroupLookupCfgPortListEnableGet: "
                 "get another enable than was set: dev = %d", dev);

            /*
                1.4. Call direction [CPSS_PCL_DIRECTION_EGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_0_E],
                          subLookupNum [2] (not relevant)
                          and enable[GT_FALSE / GT_TRUE].
                Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            subLookupNum = 2;

            st = cpssDxChPclPortGroupLookupCfgPortListEnableSet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.2. Call cpssDxChPclPortGroupLookupCfgPortListEnableGet
                     with the same parameters.
                Expected: GT_OK and the same enable as was set.
            */
            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, &enableGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
                 "cpssDxChPclPortGroupLookupCfgPortListEnableGet: %d, %d, %d",
                                         dev, direction, subLookupNum);

            if (expectedRc == GT_OK)
            {
                /* check value */
                UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                     "cpssDxChPclPortGroupLookupCfgPortListEnableGet: "
                     "get another enable than was set: dev = %d", dev);
            }
            /*
                1.5. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_1_E],
                          subLookupNum [3] (not relevant)
                          and enable[GT_FALSE / GT_TRUE].
                Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;
            subLookupNum = 3;

            st = cpssDxChPclPortGroupLookupCfgPortListEnableSet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.2. Call cpssDxChPclPortGroupLookupCfgPortListEnableGet
                     with the same parameters.
                Expected: GT_OK and the same enable as was set.
            */
            st = cpssDxChPclPortGroupLookupCfgPortListEnableGet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, &enableGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "cpssDxChPclPortGroupLookupCfgPortListEnableGet: %d, %d, %d",
                                         dev, direction, subLookupNum);
            /* check value */
            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                 "cpssDxChPclPortGroupLookupCfgPortListEnableGet: "
                 "get another enable than was set: dev = %d", dev);

            /*
                1.6. Check for invalid enum value for direction.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupLookupCfgPortListEnableSet
                                (dev, portGroupsBmp, direction, lookupNum,
                                 subLookupNum, enable),
                                direction);

            /*
                1.7. Check wrong enum values lookupNum.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupLookupCfgPortListEnableSet
                            (dev, portGroupsBmp, direction, lookupNum,
                             subLookupNum, enable),
                             lookupNum);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupLookupCfgPortListEnableSet(dev, portGroupsBmp,
                                        direction, lookupNum, subLookupNum, enable);

            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupLookupCfgPortListEnableSet(dev, portGroupsBmp,
                                    direction, lookupNum, subLookupNum, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* set correct values for all the parameters (except of device number) */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    subLookupNum = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. Call function for non active device and valid parameters. */
        /* Expected: GT_BAD_PARAM.                                        */
        st = cpssDxChPclPortGroupLookupCfgPortListEnableSet(dev, portGroupsBmp,
                                    direction, lookupNum, subLookupNum, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupLookupCfgPortListEnableSet(dev, portGroupsBmp,
                                direction, lookupNum, subLookupNum, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclLookupCfgPortListEnableGet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    OUT GT_BOOL                       *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclLookupCfgPortListEnableGet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(xCat2)
    1.1. Call direction [CPSS_PCL_DIRECTION_INGRESS_E /
                         CPSS_PCL_DIRECTION_EGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E /
                         CPSS_PCL_LOOKUP_1_E],
         subLookupNum [0] and non-NULL enablePtr.
    Expected: GT_OK.
    1.2. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E],
         subLookupNum [1] and non-NULL enablePtr.
    Expected: GT_OK.
    1.3. Call direction [CPSS_PCL_DIRECTION_EGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E],
              subLookupNum [2] (not relevant)
              and non-NULL enablePtr.
    Expected: GT_OK.
    1.4. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_1_E],
              subLookupNum [3] (not relevant)
              and non-NULL enablePtr.
    Expected: GT_OK.
    1.5. Check for invalid enum value for direction.
    Expected: GT_BAD_PARAM.
    1.6. Check wrong enum values lookupNum.
    Expected: GT_BAD_PARAM.
    1.7. Check wrong enablePtr[NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                    st = GT_OK;
    GT_U8                        dev;
    CPSS_PCL_DIRECTION_ENT       direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_PCL_LOOKUP_NUMBER_ENT   lookupNum = CPSS_PCL_LOOKUP_0_E;
    GT_U32                       subLookupNum = 0;
    GT_BOOL                      enable = GT_FALSE;
    GT_BOOL                      iPcl0Bypass;
    CPSS_PP_FAMILY_TYPE_ENT      devFamily;
    GT_STATUS                    expectedRc;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,"prvUtfDeviceFamilyGet: %d", dev);

        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        /*
            1.1. Call direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                 CPSS_PCL_DIRECTION_EGRESS_E],
                      lookupNum [CPSS_PCL_LOOKUP_0_E /
                                 CPSS_PCL_LOOKUP_1_E],
                 subLookupNum [0] and non-NULL enablePtr.
            Expected: GT_OK.
        */
        /* Call with direction [CPSS_PCL_DIRECTION_INGRESS_E] */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum = CPSS_PCL_LOOKUP_0_E;
        subLookupNum = 0;

        st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                    direction, lookupNum, subLookupNum, &enable);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
             "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

        /* Call with direction [CPSS_PCL_DIRECTION_EGRESS_E] */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;
        lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;

        expectedRc =
            (devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
                ? GT_NOT_APPLICABLE_DEVICE : GT_OK;

        st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                    direction, lookupNum, subLookupNum, &enable);
        UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
             "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

        /*
            1.2. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
                      lookupNum [CPSS_PCL_LOOKUP_0_E],
                 subLookupNum [1] and non-NULL enablePtr.
            Expected: GT_OK.
        */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum = CPSS_PCL_LOOKUP_0_E;
        subLookupNum = 1;

        st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                    direction, lookupNum, subLookupNum, &enable);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
             "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

        /*
            1.3. Call direction [CPSS_PCL_DIRECTION_EGRESS_E],
                      lookupNum [CPSS_PCL_LOOKUP_0_E],
                      subLookupNum [2] (not relevant)
                      and non-NULL enablePtr.
            Expected: GT_OK.
        */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;
        lookupNum = CPSS_PCL_LOOKUP_0_E;
        subLookupNum = 2;

        st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                    direction, lookupNum, subLookupNum, &enable);
        UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
             "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

        /*
            1.4. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
                      lookupNum [CPSS_PCL_LOOKUP_1_E],
                      subLookupNum [3] (not relevant)
                      and non-NULL enablePtr.
            Expected: GT_OK.
        */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;
        subLookupNum = 3;

        st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                    direction, lookupNum, subLookupNum, &enable);
        UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
             "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

        /*
            1.5. Check for invalid enum value for direction.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclLookupCfgPortListEnableGet
                            (dev, direction, lookupNum,
                             subLookupNum, &enable),
                            direction);

        /*
            1.6. Check wrong enum values lookupNum.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclLookupCfgPortListEnableGet
                        (dev, direction, lookupNum,
                         subLookupNum, &enable),
                         lookupNum);

        /*
            1.7. Check wrong enablePtr[NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                    direction, lookupNum, subLookupNum, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                "device: %d, enable = NULL", dev);
    }

    /* set correct values for all the parameters (except of device number) */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    subLookupNum = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. Call function for non active device and valid parameters. */
        /* Expected: GT_BAD_PARAM.                                        */
        st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                    direction, lookupNum, subLookupNum, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                direction, lookupNum, subLookupNum, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclLookupCfgPortListEnableSet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN  GT_U32                        subLookupNum,
    IN  GT_BOOL                       enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclLookupCfgPortListEnableSet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(xCat2)
    1.1. Call direction [CPSS_PCL_DIRECTION_INGRESS_E /
                         CPSS_PCL_DIRECTION_EGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E /
                         CPSS_PCL_LOOKUP_1_E],
         subLookupNum [0] and enable[GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.2. Call cpssDxChPclLookupCfgPortListEnableGet
         with the same parameters.
    Expected: GT_OK and the same enable as was set.
    1.3. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E],
         subLookupNum [1] and enable[GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.4. Call direction [CPSS_PCL_DIRECTION_EGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_0_E],
              subLookupNum [2] (not relevant)
              and enable[GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.5. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
              lookupNum [CPSS_PCL_LOOKUP_1_E],
              subLookupNum [3] (not relevant)
              and enable[GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.6. Check for invalid enum value for direction.
    Expected: GT_BAD_PARAM.
    1.7. Check wrong enum values lookupNum.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS                    st = GT_OK;
    GT_U8                        dev;
    CPSS_PCL_DIRECTION_ENT       direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_PCL_LOOKUP_NUMBER_ENT   lookupNum = CPSS_PCL_LOOKUP_0_E;
    GT_U32                       subLookupNum = 0;
    GT_BOOL                      enable = GT_FALSE;
    GT_BOOL                      enableGet = GT_TRUE;
    GT_BOOL                      iPcl0Bypass;
    CPSS_PP_FAMILY_TYPE_ENT      devFamily;
    GT_STATUS                    expectedRc;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = prvUtfDeviceFamilyGet(dev, &devFamily);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,"prvUtfDeviceFamilyGet: %d", dev);

        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

            /*
                1.1. Call direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                     CPSS_PCL_DIRECTION_EGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_0_E /
                                     CPSS_PCL_LOOKUP_1_E],
                     subLookupNum [0] and enable[GT_FALSE / GT_TRUE].
                Expected: GT_OK.
            */
            /* Call with direction [CPSS_PCL_DIRECTION_INGRESS_E] */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            subLookupNum = 0;
            enable = GT_FALSE;

            st = cpssDxChPclLookupCfgPortListEnableSet(dev,
                                        direction, lookupNum, subLookupNum, enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.2. Call cpssDxChPclLookupCfgPortListEnableGet
                     with the same parameters.
                Expected: GT_OK and the same enable as was set.
            */
            st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                        direction, lookupNum, subLookupNum, &enableGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "cpssDxChPclLookupCfgPortListEnableGet: %d, %d, %d",
                                         dev, direction, subLookupNum);
            /* check value */
            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                 "cpssDxChPclLookupCfgPortListEnableGet: "
                 "get another enable than was set: dev = %d", dev);

            /* Call with direction [CPSS_PCL_DIRECTION_EGRESS_E] */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;
            enable = GT_TRUE;

            expectedRc =
                (devFamily == CPSS_PP_FAMILY_DXCH_AC5_E)
                    ? GT_NOT_APPLICABLE_DEVICE : GT_OK;

            st = cpssDxChPclLookupCfgPortListEnableSet(dev,
                                        direction, lookupNum, subLookupNum, enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.2. Call cpssDxChPclLookupCfgPortListEnableGet
                     with the same parameters.
                Expected: GT_OK and the same enable as was set.
            */
            st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                        direction, lookupNum, subLookupNum, &enableGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
                 "cpssDxChPclLookupCfgPortListEnableGet: %d, %d, %d",
                                         dev, direction, subLookupNum);
            if (expectedRc == GT_OK)
            {
                /* check value */
                UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                     "cpssDxChPclLookupCfgPortListEnableGet: "
                     "get another enable than was set: dev = %d", dev);
            }

            /*
                1.3. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_0_E],
                     subLookupNum [1] and enable[GT_FALSE / GT_TRUE].
                Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            subLookupNum = 1;

            st = cpssDxChPclLookupCfgPortListEnableSet(dev,
                                        direction, lookupNum, subLookupNum, enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.2. Call cpssDxChPclLookupCfgPortListEnableGet
                     with the same parameters.
                Expected: GT_OK and the same enable as was set.
            */
            st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                        direction, lookupNum, subLookupNum, &enableGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "cpssDxChPclLookupCfgPortListEnableGet: %d, %d, %d",
                                         dev, direction, subLookupNum);
            /* check value */
            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                 "cpssDxChPclLookupCfgPortListEnableGet: "
                 "get another enable than was set: dev = %d", dev);

            /*
                1.4. Call direction [CPSS_PCL_DIRECTION_EGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_0_E],
                          subLookupNum [2] (not relevant)
                          and enable[GT_FALSE / GT_TRUE].
                Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            subLookupNum = 2;

            st = cpssDxChPclLookupCfgPortListEnableSet(dev,
                                        direction, lookupNum, subLookupNum, enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.2. Call cpssDxChPclLookupCfgPortListEnableGet
                     with the same parameters.
                Expected: GT_OK and the same enable as was set.
            */
            st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                        direction, lookupNum, subLookupNum, &enableGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(expectedRc, st,
                 "cpssDxChPclLookupCfgPortListEnableGet: %d, %d, %d",
                                         dev, direction, subLookupNum);
            if (expectedRc == GT_OK)
            {
                /* check value */
                UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                     "cpssDxChPclLookupCfgPortListEnableGet: "
                     "get another enable than was set: dev = %d", dev);
            }

            /*
                1.5. Call direction [CPSS_PCL_DIRECTION_INGRESS_E],
                          lookupNum [CPSS_PCL_LOOKUP_1_E],
                          subLookupNum [3] (not relevant)
                          and enable[GT_FALSE / GT_TRUE].
                Expected: GT_OK.
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            lookupNum = iPcl0Bypass ? CPSS_PCL_LOOKUP_NUMBER_1_E : CPSS_PCL_LOOKUP_1_E;
            subLookupNum = 3;

            st = cpssDxChPclLookupCfgPortListEnableSet(dev,
                                        direction, lookupNum, subLookupNum, enable);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "Dev, direction, subLookupNum: %d, %d, %d", dev, direction, subLookupNum);

            /*
                1.2. Call cpssDxChPclLookupCfgPortListEnableGet
                     with the same parameters.
                Expected: GT_OK and the same enable as was set.
            */
            st = cpssDxChPclLookupCfgPortListEnableGet(dev,
                                        direction, lookupNum, subLookupNum, &enableGet);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                 "cpssDxChPclLookupCfgPortListEnableGet: %d, %d, %d",
                                         dev, direction, subLookupNum);
            /* check value */
            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                 "cpssDxChPclLookupCfgPortListEnableGet: "
                 "get another enable than was set: dev = %d", dev);

            /*
                1.6. Check for invalid enum value for direction.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclLookupCfgPortListEnableSet
                                (dev, direction, lookupNum,
                                 subLookupNum, enable),
                                direction);

            /*
                1.7. Check wrong enum values lookupNum.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclLookupCfgPortListEnableSet
                            (dev, direction, lookupNum,
                             subLookupNum, enable),
                             lookupNum);
    }

    /* set correct values for all the parameters (except of device number) */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    subLookupNum = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E);

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. Call function for non active device and valid parameters. */
        /* Expected: GT_BAD_PARAM.                                        */
        st = cpssDxChPclLookupCfgPortListEnableSet(dev,
                                    direction, lookupNum, subLookupNum, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclLookupCfgPortListEnableSet(dev,
                                direction, lookupNum, subLookupNum, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOverrideUserDefinedBytesEnableGet
(
    IN  GT_U8                                dev,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType,
    OUT GT_BOOL                              *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOverrideUserDefinedBytesEnableGet)
{
/*
    ITERATE_DEVICES(xCat; xCat3; Lion; xCat2; Lion2)
    1.1. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E /
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                   udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E /
                                   CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E].
    Expected: GT_OK.
    1.3. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E /
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E /
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E],
                   udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_QOS_PROFILE_E /
                                   CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TRUNK_HASH_E /
                                   CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TAG1_INFO_E],
    Expected: GT_BAD_PARAM.
    1.4. Call api with wrong ruleFormat [wrong enum values].
    Expected: GT_BAD_PARAM.
    1.5. Call api with wrong udbOverrideType [wrong enum values].
    Expected: GT_BAD_PARAM.
    1.6. Call api with wrong enablePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;

    GT_U8                                dev;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;
    GT_BOOL                              enable;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E /
                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                           udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E /
                                           CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E].
            Expected: GT_OK.
        */

        /* call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                     udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E] */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;

        st = cpssDxChPclOverrideUserDefinedBytesEnableGet(dev, ruleFormat,
                                     udbOverrideType, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                     udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E] */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
        udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E;

        st = cpssDxChPclOverrideUserDefinedBytesEnableGet(dev, ruleFormat,
                                     udbOverrideType, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.3. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E /
                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E /
                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E],
                           udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_QOS_PROFILE_E /
                                           CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TRUNK_HASH_E /
                                           CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TAG1_INFO_E],
            Expected: GT_BAD_PARAM.
        */

        /* call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E],
                     udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_QOS_PROFILE_E] */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E;
        udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_QOS_PROFILE_E;

        st = cpssDxChPclOverrideUserDefinedBytesEnableGet(dev, ruleFormat,
                                     udbOverrideType, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        /* call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E],
                     udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TRUNK_HASH_E] */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E;
        udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TRUNK_HASH_E;

        st = cpssDxChPclOverrideUserDefinedBytesEnableGet(dev, ruleFormat,
                                     udbOverrideType, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        /* call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E],
                     udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TAG1_INFO_E] */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E;
        udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TAG1_INFO_E;

        st = cpssDxChPclOverrideUserDefinedBytesEnableGet(dev, ruleFormat,
                                     udbOverrideType, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        /*
            1.4. Call api with wrong ruleFormat [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclOverrideUserDefinedBytesEnableGet
                            (dev, ruleFormat, udbOverrideType, &enable),
                            ruleFormat);

        /*
            1.5. Call api with wrong udbOverrideType [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclOverrideUserDefinedBytesEnableGet
                            (dev, ruleFormat, udbOverrideType, &enable),
                            udbOverrideType);

        /*
            1.6. Call api with wrong enablePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclOverrideUserDefinedBytesEnableGet(dev, ruleFormat,
                                     udbOverrideType, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                   "%d, enablePtr = NULL", dev);
    }

    /* restore correct values */
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOverrideUserDefinedBytesEnableGet(dev, ruleFormat,
                                     udbOverrideType, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOverrideUserDefinedBytesEnableGet(dev, ruleFormat,
                                     udbOverrideType, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOverrideUserDefinedBytesEnableSet
(
    IN  GT_U8                               dev,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT udbOverrideType,
    IN  GT_BOOL                             enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOverrideUserDefinedBytesEnableSet)
{
/*
    ITERATE_DEVICES(xCat; xCat3; Lion; xCat2; Lion2)
    1.1. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E /
                              CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                   udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E /
                                   CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E],
                   enable[GT_TRUE / GT_FALSE].
    Expected: GT_OK.
    1.2. Call cpssDxChPclOverrideUserDefinedBytesEnableGet
           with the same parameters.
    Expected: GT_OK and the same values than was set.
    1.4. Call api with wrong ruleFormat [wrong enum values].
    Expected: GT_BAD_PARAM.
    1.5. Call api with wrong udbOverrideType [wrong enum values].
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS st = GT_OK;

    GT_U8                               dev;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;
    GT_BOOL                             enable = GT_FALSE;
    GT_BOOL                             enableGet = GT_FALSE;
    GT_U32                              expectedError;/*is error expected ?*/

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E /
                                      CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                           udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E /
                                           CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E],
                           enable[GT_TRUE / GT_FALSE].
            Expected: GT_OK.
        */

        /* call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                     udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E],
                     enable[GT_TRUE] */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;
        enable = GT_TRUE;

        st = cpssDxChPclOverrideUserDefinedBytesEnableSet(dev, ruleFormat,
                                     udbOverrideType, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPclOverrideUserDefinedBytesEnableGet
                   with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPclOverrideUserDefinedBytesEnableGet(dev, ruleFormat,
                                     udbOverrideType, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPclOverrideUserDefinedBytesEnableGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                       "got another enable then was set: %d", dev);

        /* call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                     udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E],
                     enable[GT_FALSE] */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
        udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E;
        enable = GT_FALSE;

        st = cpssDxChPclOverrideUserDefinedBytesEnableSet(dev, ruleFormat,
                                     udbOverrideType, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* call get func again, 1.2. */
        st = cpssDxChPclOverrideUserDefinedBytesEnableGet(dev, ruleFormat,
                                     udbOverrideType, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPclOverrideUserDefinedBytesEnableGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                       "got another enable then was set: %d", dev);



        {
            CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT     udbOverrideTypeArr[]={
                CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E,
                CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E,
                CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TRUNK_HASH_E
            };
            CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT      ruleFormatArr[]={
                CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E,
                CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
                CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
                CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E
            };
            GT_U32  ii,jj;

            enable = GT_TRUE;

            for(ii = 0 ; ii < sizeof(udbOverrideTypeArr)/sizeof(udbOverrideTypeArr[0]); ii ++)
            {
                expectedError = 0;
                if(PRV_CPSS_DXCH_IS_AC3_BASED_DEVICE_MAC(dev))
                {
                    if(udbOverrideTypeArr[ii] == CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_TRUNK_HASH_E)
                    {
                        /* not supported by xcat devices */
                        expectedError = 1;
                    }
                }
                else if(PRV_CPSS_PP_MAC(dev)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
                {
                    /* all those keys not supported by xcat2 devices */
                    expectedError = 1;
                }

                for(jj = 0 ; jj < sizeof(ruleFormatArr)/sizeof(ruleFormatArr[0]); jj ++)
                {
                    st = cpssDxChPclOverrideUserDefinedBytesEnableSet(dev, ruleFormatArr[jj],
                                                 udbOverrideTypeArr[ii], enable);
                    if(expectedError == 0)
                    {
                        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                    }
                    else
                    {
                        UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                    }

                    st = cpssDxChPclOverrideUserDefinedBytesEnableGet(dev, ruleFormatArr[jj],
                                                 udbOverrideTypeArr[ii], &enableGet);
                    if(expectedError == 0)
                    {
                        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                  "cpssDxChPclOverrideUserDefinedBytesEnableGet: %d ", dev);

                        /* Verifying values */
                        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                                       "got another enable then was set: %d", dev);
                    }
                    else
                    {
                        UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                    }
                }
            }


        }


        /* restore previous values */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
        udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E;
        enable = GT_FALSE;

        /*
            1.4. Call api with wrong ruleFormat [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclOverrideUserDefinedBytesEnableSet
                            (dev, ruleFormat, udbOverrideType, enable),
                            ruleFormat);

        /*
            1.5. Call api with wrong udbOverrideType [wrong enum values].
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclOverrideUserDefinedBytesEnableSet
                            (dev, ruleFormat, udbOverrideType, enable),
                            udbOverrideType);
    }

    /* restore correct values */
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;
    enable = GT_TRUE;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOverrideUserDefinedBytesEnableSet(dev, ruleFormat,
                                     udbOverrideType, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOverrideUserDefinedBytesEnableSet(dev, ruleFormat,
                                     udbOverrideType, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet
(
    IN  GT_U8                                dev,
    IN  GT_PORT_GROUPS_BMP                   portGroupsBmp,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType,
    OUT GT_BOOL                              *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(xCat; xCat3; Lion; xCat2; Lion2)
    1.1.1. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E /
                                CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                   udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E /
                                   CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E].
    Expected: GT_OK.
    1.1.3. Call api with wrong ruleFormat [wrong enum values].
    Expected: GT_BAD_PARAM.
    1.1.4. Call api with wrong udbOverrideType [wrong enum values].
    Expected: GT_BAD_PARAM.
    1.1.5. Call api with wrong enablePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;
    GT_U32    portGroupId;

    GT_U8                                dev;
    GT_PORT_GROUPS_BMP                   portGroupsBmp = 1;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT  udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;
    GT_BOOL                              enable;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            /* set next active port */
            portGroupsBmp = (1 << portGroupId);

            /*
                1.1.1. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E /
                                            CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                               udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E /
                                               CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E].
                Expected: GT_OK.
            */

            /* call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                         udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E] */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;

            st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, &enable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                         udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E] */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
            udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E;

            st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, &enable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* restore previous values */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
            udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E;

            /*
                1.1.3. Call api with wrong ruleFormat [wrong enum values].
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet
                                (dev, portGroupsBmp, ruleFormat,
                                udbOverrideType, &enable),
                                ruleFormat);

            /*
                1.1.4. Call api with wrong udbOverrideType [wrong enum values].
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet
                                (dev, portGroupsBmp, ruleFormat,
                                udbOverrideType, &enable),
                                udbOverrideType);

            /*
                1.1.5. Call api with wrong enablePtr [NULL].
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                   "%d, enablePtr = NULL", dev);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            /* set next non-active port */
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, &enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, &enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    /* restore correct values */
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet
(
    IN  GT_U8                               dev,
    IN  GT_PORT_GROUPS_BMP                  portGroupsBmp,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT udbOverrideType,
    IN  GT_BOOL                             enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS(xCat; xCat3; Lion; xCat2; Lion2)
    1.1.1. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E /
                                CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                   udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E /
                                   CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E],
                   enable[GT_TRUE / GT_FALSE].
    Expected: GT_OK.
    1.1.2. Call cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet
           with the same parameters.
    Expected: GT_OK and the same values than was set.
    1.1.4. Call api with wrong ruleFormat [wrong enum values].
    Expected: GT_BAD_PARAM.
    1.1.5. Call api with wrong udbOverrideType [wrong enum values].
    Expected: GT_BAD_PARAM.
*/

    GT_STATUS st = GT_OK;
    GT_U32    portGroupId;

    GT_U8                               dev;
    GT_PORT_GROUPS_BMP                  portGroupsBmp = 1;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_ENT udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;
    GT_BOOL                             enable = GT_FALSE;
    GT_BOOL                             enableGet = GT_FALSE;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            /* set next active port */
            portGroupsBmp = (1 << portGroupId);

            /*
                1.1.1. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E /
                                            CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                               udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E /
                                               CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E],
                               enable[GT_TRUE / GT_FALSE].
                Expected: GT_OK.
            */

            /* call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                         udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E],
                         enable[GT_TRUE] */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;
            enable = GT_TRUE;

            st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, enable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /*
                1.1.2. Call cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet
                       with the same parameters.
                Expected: GT_OK and the same values than was set.
            */
            st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, &enableGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                      "cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet: %d ", dev);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                           "got another enable then was set: %d", dev);

            /* call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E],
                         udbOverrideType[CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E],
                         enable[GT_FALSE] */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
            udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E;
            enable = GT_FALSE;

            st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, enable);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* call get func again, 1.1.2. */
            st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, &enableGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                      "cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet: %d ", dev);

            /* Verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                           "got another enable then was set: %d", dev);

            /* restore previous values */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E;
            udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_LSB_E;
            enable = GT_FALSE;

            /*
                1.1.4. Call api with wrong ruleFormat [wrong enum values].
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet
                                (dev, portGroupsBmp, ruleFormat,
                                udbOverrideType, enable),
                                ruleFormat);

            /*
                1.1.5. Call api with wrong udbOverrideType [wrong enum values].
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet
                                (dev, portGroupsBmp, ruleFormat,
                                udbOverrideType, enable),
                                udbOverrideType);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)
        {
            /* set next non-active port */
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, enable);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev,portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    /* restore correct values */
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    udbOverrideType = CPSS_DXCH_PCL_UDB_OVERRIDE_TYPE_VRF_ID_MSB_E;
    enable = GT_TRUE;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet(dev,
                   portGroupsBmp, ruleFormat, udbOverrideType, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortLookupCfgTabAccessModeGet
(
    IN  GT_U8                                            dev,
    IN  GT_PORT_NUM                                      portNum,
    IN  CPSS_PCL_DIRECTION_ENT                           direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT                       lookupNum,
    IN  GT_U32                                           subLookupNum,
    OUT CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT   *modePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortLookupCfgTabAccessModeGet)
{
/*
    ITERATE_DEVICES_VIRT_PORTS (DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2)
    1.1.1. Call with direction[CPSS_PCL_DIRECTION_INGRESS_E /
                               CPSS_PCL_DIRECTION_EGRESS_E /
                               CPSS_PCL_DIRECTION_INGRESS_E /
                               CPSS_PCL_DIRECTION_INGRESS_E],
                     lookupNum[CPSS_PCL_LOOKUP_0_E /
                               CPSS_PCL_LOOKUP_1_E /
                               CPSS_PCL_LOOKUP_0_0_E /
                               CPSS_PCL_LOOKUP_0_1_E],
                     subLookupNum[1 / 100 / 1 / 0],
    Expected: GT_OK.
    1.1.2. Call api with wrong direction [wrong enum values].
    Expected: GT_BAD_PARAM.
    1.1.3. Call api with wrong lookupNum [wrong enum values].
    Expected: GT_BAD_PARAM.
    1.1.4. Call api with wrong modePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;

    GT_U8                                            dev;
    GT_PORT_NUM                                      portNum = DXCH_PCL_VALID_PHY_PORT_CNS;
    CPSS_PCL_DIRECTION_ENT                           direction = CPSS_PCL_DIRECTION_INGRESS_E;
    CPSS_PCL_LOOKUP_NUMBER_ENT                       lookupNum = CPSS_PCL_LOOKUP_0_E;
    GT_U32                                           subLookupNum = 0;
    CPSS_DXCH_PCL_PORT_LOOKUP_CFG_TAB_ACC_MODE_ENT   mode;
    CPSS_PCL_DIRECTION_ENT                          directionIterator;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        for(directionIterator = CPSS_PCL_DIRECTION_INGRESS_E ; directionIterator <= CPSS_PCL_DIRECTION_EGRESS_E; directionIterator++)
        {
            prvUtfNextGenericPortItaratorTypeSet(   directionIterator == CPSS_PCL_DIRECTION_INGRESS_E ?
                                                    UTF_GENERIC_PORT_ITERATOR_TYPE_DEFAULT_EPORT_E :
                                                    UTF_GENERIC_PORT_ITERATOR_TYPE_PHYSICAL_E);
            /* prepare physical port iterator */
            st = prvUtfNextGenericPortReset(&portNum, dev);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            while (GT_OK == prvUtfNextGenericPortGet(&portNum, GT_TRUE))
            {
                /*
                    1.1.1. Call with direction[CPSS_PCL_DIRECTION_INGRESS_E /
                                              CPSS_PCL_DIRECTION_EGRESS_E /
                                              CPSS_PCL_DIRECTION_INGRESS_E /
                                              CPSS_PCL_DIRECTION_INGRESS_E],
                                     lookupNum[CPSS_PCL_LOOKUP_0_E /
                                               CPSS_PCL_LOOKUP_1_E /
                                               CPSS_PCL_LOOKUP_0_0_E /
                                               CPSS_PCL_LOOKUP_0_1_E],
                                     subLookupNum[1 / 100 / 1 / 0],
                    Expected: GT_OK.
                */

                /* call with direction[CPSS_PCL_DIRECTION_INGRESS_E],
                             lookupNum[CPSS_PCL_LOOKUP_0_E],
                             subLookupNum[1] */
                if(directionIterator == CPSS_PCL_DIRECTION_INGRESS_E)
                {
                    direction = CPSS_PCL_DIRECTION_INGRESS_E;
                    lookupNum = CPSS_PCL_LOOKUP_0_E;
                    subLookupNum = 1;

                    st = cpssDxChPclPortLookupCfgTabAccessModeGet(dev, portNum,
                      direction, lookupNum, subLookupNum, &mode);
                    if(UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) &&
                       portNum >= UTF_GET_MAX_DEFAULT_EPORTS_NUM_MAC(dev))
                    {
                        /* the ingress direction supports default ePorts range and not full ePorts range */
                        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_BAD_PARAM, st, dev, portNum, direction);
                    }
                    else
                    {
                        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                    }
                }

                if(directionIterator == CPSS_PCL_DIRECTION_EGRESS_E)
                {
                    /* call with direction[CPSS_PCL_DIRECTION_EGRESS_E],
                                 lookupNum[CPSS_PCL_LOOKUP_1_E],
                                 subLookupNum[0] */
                    direction = CPSS_PCL_DIRECTION_EGRESS_E;
                    lookupNum = CPSS_PCL_LOOKUP_1_E;
                    subLookupNum = 0;

                    st = cpssDxChPclPortLookupCfgTabAccessModeGet(dev, portNum,
                      direction, lookupNum, subLookupNum, &mode);
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                }

                if(directionIterator == CPSS_PCL_DIRECTION_INGRESS_E)
                {
                    /* call with direction[CPSS_PCL_DIRECTION_INGRESS_E],
                                 lookupNum[CPSS_PCL_LOOKUP_0_0_E],
                                 subLookupNum[1] */
                    direction = CPSS_PCL_DIRECTION_INGRESS_E;
                    lookupNum = CPSS_PCL_LOOKUP_0_0_E;
                    subLookupNum = 0;

                    st = cpssDxChPclPortLookupCfgTabAccessModeGet(dev, portNum,
                      direction, lookupNum, subLookupNum, &mode);
                    if(UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) &&
                       portNum >= UTF_GET_MAX_DEFAULT_EPORTS_NUM_MAC(dev))
                    {
                        /* the ingress direction supports default ePorts range and not full ePorts range */
                        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_BAD_PARAM, st, dev, portNum, direction);
                    }
                    else
                    {
                        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev) )
                        {
                            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                        }
                        else
                        {
                            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
                        }
                    }

                    /* call with direction[CPSS_PCL_DIRECTION_INGRESS_E],
                                 lookupNum[CPSS_PCL_LOOKUP_0_1_E],
                                 subLookupNum[0] */
                    direction = CPSS_PCL_DIRECTION_INGRESS_E;
                    lookupNum = CPSS_PCL_LOOKUP_0_1_E;
                    subLookupNum = 0;

                    st = cpssDxChPclPortLookupCfgTabAccessModeGet(dev, portNum,
                      direction, lookupNum, subLookupNum, &mode);
                    if(UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev) &&
                       portNum >= UTF_GET_MAX_DEFAULT_EPORTS_NUM_MAC(dev))
                    {
                        /* the ingress direction supports default ePorts range and not full ePorts range */
                        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_BAD_PARAM, st, dev, portNum, direction);
                    }
                    else
                    {
                        if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(dev))
                        {
                            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
                        }
                        else
                        {
                            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
                        }
                    }

                    /*
                        1.1.2. Call api with wrong direction [wrong enum values].
                        Expected: GT_BAD_PARAM.
                    */
                    UTF_ENUMS_CHECK_MAC(cpssDxChPclPortLookupCfgTabAccessModeGet
                                        (dev, portNum, direction,
                                        lookupNum, subLookupNum, &mode),
                                        direction);

                    /*
                        1.1.3. Call api with wrong lookupNum [wrong enum values].
                        Expected: GT_BAD_PARAM.
                    */
                    UTF_ENUMS_CHECK_MAC(cpssDxChPclPortLookupCfgTabAccessModeGet
                                    (dev, portNum, direction,
                                    lookupNum, subLookupNum, &mode),
                                    lookupNum);
                }

                /*
                    1.1.4. Call api with wrong modePtr [NULL].
                    Expected: GT_BAD_PTR.
                */
                st = cpssDxChPclPortLookupCfgTabAccessModeGet(dev, portNum,
                  direction, lookupNum, subLookupNum, NULL);
                UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                           "%d, modePtr = NULL", dev);

            }

            direction = directionIterator;
            lookupNum = CPSS_PCL_LOOKUP_0_E;
            subLookupNum = directionIterator == CPSS_PCL_DIRECTION_INGRESS_E ? 1 : 0;

            st = prvUtfNextGenericPortReset(&portNum, dev);
            UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

            /* 1.2. For all active devices go over all non available virtual ports. */
            while (GT_OK == prvUtfNextGenericPortGet(&portNum, GT_FALSE))
            {
                /* 1.2.1. Call function for each non-active port */
                st = cpssDxChPclPortLookupCfgTabAccessModeGet(dev, portNum,
                      direction, lookupNum, subLookupNum, &mode);

                if(IS_E_ARCH_AND_PHYSICAL_PORT_IN_RANGE_MAC(dev,portNum))
                {
                    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portNum);
                }
                else
                {
                    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portNum);
                }
            }

            /* 1.3. For active device check that function returns GT_BAD_PARAM */
            /* for out of bound value for port number.                         */
            portNum = UTF_CPSS_PP_MAX_PORT_NUM_CNS(dev);

            st = cpssDxChPclPortLookupCfgTabAccessModeGet(dev, portNum,
                  direction, lookupNum, subLookupNum, &mode);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portNum);

            /* 1.4. For active device check that function returns GT_OK */
            /* for CPU port number.                                            */
            portNum = CPSS_CPU_PORT_NUM_CNS;

            st = cpssDxChPclPortLookupCfgTabAccessModeGet(dev, portNum,
                  direction, lookupNum, subLookupNum, &mode);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portNum);
        }
    }

    /* restore correct values */
    portNum = 0;
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    lookupNum = CPSS_PCL_LOOKUP_0_E;
    subLookupNum = 0;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_NONE_FAMILY_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortLookupCfgTabAccessModeGet(dev, portNum,
          direction, lookupNum, subLookupNum, &mode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortLookupCfgTabAccessModeGet(dev, portNum,
          direction, lookupNum, subLookupNum, &mode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortGroupRuleParsedGet
(
    IN GT_U8                                            devNum,
    IN GT_PORT_GROUPS_BMP                               portGroupsBmp,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               ruleFormat,
    IN GT_U32                                           ruleIndex,
    IN CPSS_DXCH_PCL_RULE_OPTION_ENT                    ruleOptionsBmp,
    OUT GT_BOOL                                         *isRuleValidPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                   *maskPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                   *patternPtr,
    OUT CPSS_DXCH_PCL_ACTION_STC                        *actionPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleParsedGet)
{
/*
    ITERATE_DEVICES_PORT_GROUPS (xCat, xCat2, Lion, Lion2, Bobcat2, Caelum, Bobcat3)

    1.1. Set rule for testing.
    Expected: GT_OK.

    1.2. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                   ruleIndex [PCL_TESTED_RULE_INDEX],
                   ruleOptionsBmp[CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E],
                   non-NULL isRuleValidPtr,
                   non-NULL maskPtr,
                   non-NULL patternPtr,
                   non-NULL actionPtr.
    Expected: GT_OK.

    1.3. Call with out of range ruleFormat, and other parameters same as in 1.2.
    Expected: GT_BAD_PARAM.

    1.4. Call with out of range ruleIndex[PCL_INVALID_STD_RULE_INDEX] and
        other parameters same as in 1.2.
    Expected: NON GT_OK.

    1.5. Call with out of range isRuleValidPtr[NULL], and other parameters same as in 1.2.
    Expected: GT_BAD_PTR.

    1.6. Call with out of range maskPtr[NULL], and other parameters same as in 1.2.
    Expected: GT_BAD_PTR.

    1.7. Call with out of range patternPtr[NULL], and other parameters same as in 1.2.
    Expected: GT_BAD_PTR.

    1.8. Call with out of range actionPtr[NULL], and other parameters same as in 1.2.
    Expected: GT_BAD_PTR.

    1.9. Call cpssDxChPclPortGroupRuleInvalidate with ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
        ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
    Expected: GT_OK.
*/
    GT_STATUS                               st              = GT_OK;
    GT_U8                                   dev             = 0;
    GT_PORT_GROUPS_BMP                      portGroupsBmp   = 1;

    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT      ruleFormat      = 0;
    GT_U32                                  ruleIndex       = 0;
    CPSS_DXCH_PCL_RULE_OPTION_ENT           ruleOptionsBmp  = 0;

    GT_BOOL                                 isRuleValid     = GT_FALSE;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT           mask            ;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT           pattern         ;
    CPSS_DXCH_PCL_ACTION_STC                action          ;

    CPSS_PP_FAMILY_TYPE_ENT                 devFamily       = 0;
    GT_U32                                  portGroupId     = 0;
    CPSS_PCL_RULE_SIZE_ENT                  ruleSize        = CPSS_PCL_RULE_SIZE_STD_E;


    cpssOsMemSet(&mask,0,sizeof(mask));
    cpssOsMemSet(&pattern,0,sizeof(pattern));
    cpssOsMemSet(&action,0,sizeof(action));

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                           UTF_CH2_E | UTF_CH3_E );

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. Go over all active port groups. */
        PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            /* check and skip not valid port groups */
            if (prvUtfPclActivePortGroupCheck(dev,portGroupId,&portGroupsBmp) == GT_TRUE)
            {
                continue;
            }

            st = prvUtfDeviceFamilyGet(dev, &devFamily);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,"prvUtfDeviceFamilyGet: %d", dev);
            /*
                1.1. Set rule for testing.
                Expected: GT_OK.
            */
            st = pclRuleTestingDefaultSet(dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st, "pclRuleTestingDefaultSet: %d", dev);

            /*
                1.2. Call with ruleFormat[CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
                               ruleIndex [PCL_TESTED_RULE_INDEX],
                               ruleOptionsBmp[CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E],
                               non-NULL isRuleValidPtr,
                               non-NULL maskPtr,
                               non-NULL patternPtr,
                               non-NULL actionPtr.
                Expected: GT_OK.
            */

            /* call with ruleOptionsBmp[CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E] */
            ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);
            ruleOptionsBmp = CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E;

            st = cpssDxChPclPortGroupRuleParsedGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                   ruleFormat, ruleIndex,
                                                   ruleOptionsBmp,
                                                   &isRuleValid, &mask,
                                                   &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /*
                1.3. Call with out of range ruleFormat, and other parameters
                    same as in 1.2.
                Expected: GT_BAD_PARAM.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortGroupRuleParsedGet
                                (dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,ruleFormat, ruleIndex,
                                ruleOptionsBmp, &isRuleValid, &mask, &pattern, &action),
                                ruleFormat);

            /*
                1.4. Call with out of range ruleIndex[PCL_INVALID_STD_RULE_INDEX]
                    and other parameters same as in 1.2.
                Expected: NON GT_OK.
            */
            ruleIndex = PCL_INVALID_STD_RULE_INDEX(dev);

            st = cpssDxChPclPortGroupRuleParsedGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                   ruleFormat, ruleIndex,
                                                   ruleOptionsBmp,
                                                   &isRuleValid, &mask,
                                                   &pattern, &action);
            UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            /* restore value */
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            /*
                1.5. Call with out of range isRuleValidPtr[NULL], and other
                    parameters same as in 1.2.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleParsedGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                   ruleFormat, ruleIndex,
                                                   ruleOptionsBmp,
                                                   NULL, &mask,
                                                   &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

            /*
                1.6. Call with out of range maskPtr[NULL], and other
                    parameters same as in 1.2.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleParsedGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                   ruleFormat, ruleIndex,
                                                   ruleOptionsBmp,
                                                   &isRuleValid, NULL,
                                                   &pattern, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

            /*
                1.7. Call with out of range patternPtr[NULL], and other
                    parameters same as in 1.2.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleParsedGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                   ruleFormat, ruleIndex,
                                                   ruleOptionsBmp,
                                                   &isRuleValid, &mask,
                                                   NULL, &action);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

            /*
                1.8. Call with out of range actionPtr[NULL], and other parameters
                    same as in 1.2.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortGroupRuleParsedGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                   ruleFormat, ruleIndex,
                                                   ruleOptionsBmp,
                                                   &isRuleValid, &mask,
                                                   &pattern, NULL);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

            /*
                1.9. Call cpssDxChPclPortGroupRuleInvalidate with
                    ruleSize [CPSS_PCL_RULE_SIZE_STD_E],
                    ruleIndex [PCL_TESTED_RULE_INDEX] to cleanup after testing.
                Expected: GT_OK.
            */

            ruleSize = CPSS_PCL_RULE_SIZE_STD_E;
            ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

            st = cpssDxChPclPortGroupRuleInvalidate(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex, ruleSize, ruleIndex);
            UTF_VERIFY_EQUAL3_STRING_MAC(GT_OK, st,
                    "cpssDxChPclPortGroupRuleInvalidate: %d, %d, %d", dev, ruleSize, ruleIndex);
        }
        PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(dev, portGroupId)

        /* 1.2. For not-active port groups check that function returns GT_BAD_PARAM. */
        PRV_TGF_PP_START_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev, portGroupId)
        {
            portGroupsBmp = (1 << portGroupId);

            st = cpssDxChPclPortGroupRuleParsedGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                                   ruleFormat, ruleIndex,
                                                   ruleOptionsBmp,
                                                   &isRuleValid, &mask,
                                                   &pattern, &action);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, portGroupsBmp);
        }
        PRV_TGF_PP_END_LOOP_NON_ACTIVE_PORT_GROUPS_MAC(dev, portGroupId)

        /* 1.3. For unaware port groups check that function returns GT_OK. */
        portGroupsBmp = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        st = cpssDxChPclPortGroupRuleParsedGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                               ruleFormat, ruleIndex,
                                               ruleOptionsBmp,
                                               &isRuleValid, &mask,
                                               &pattern, &action);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portGroupsBmp);
    }

    portGroupsBmp = 1;

    /* Set valid parameters. As soon as family of device can't be determined */
    /* - values valid for any family                                         */
    ruleSize  = CPSS_PCL_RULE_SIZE_STD_E;
    ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

    /*2. Go over all non active devices. */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E |
                                           UTF_CH2_E | UTF_CH3_E );

    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        /* 2.1. <Call function for non active device and valid parameters>. */
        /* Expected: GT_NOT_APPLICABLE_DEVICE                               */
        st = cpssDxChPclPortGroupRuleParsedGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                               ruleFormat, ruleIndex,
                                               ruleOptionsBmp,
                                               &isRuleValid, &mask,
                                               &pattern, &action);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                 */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPclPortGroupRuleParsedGet(dev, portGroupsBmp, mainUtCpssDxChPclTcamIndex,
                                           ruleFormat, ruleIndex,
                                           ruleOptionsBmp,
                                           &isRuleValid, &mask,
                                           &pattern, &action);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*
GT_STATUS prvRuleParsedGetVerfy
(
    IN  GT_U8                                            devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               ruleFormat,
    IN  GT_U32                                           ruleIndex,
    IN  CPSS_DXCH_PCL_RULE_OPTION_ENT                    ruleOptionsBmp,
    OUT GT_BOOL                                          *isRuleValidPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *maskPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT                    *patternPtr,
    OUT CPSS_DXCH_PCL_ACTION_STC                         *actionPtr
);
*/
static void prvRuleParsedGetVerfy
(
    IN  GT_U8                                            dev,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               ruleFormat,
    IN  GT_BOOL                                          valid,
    IN  GT_U32                                           ruleIndex,
    IN  GT_U32                                           patternIndex,
    IN  GT_BOOL                                          usePortsBmp,
    IN  GT_U32                                           iterationIndex

)
{
    GT_STATUS st = GT_OK;

    GT_BOOL                          isRuleValid;
    CPSS_DXCH_PCL_RULE_OPTION_ENT    ruleOptionsBmp;
    CPSS_DXCH_PCL_ACTION_STC         ingrAction;
    CPSS_DXCH_PCL_ACTION_STC         egrAction;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    mask;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    pattern;
    CPSS_DXCH_PCL_ACTION_STC         *actionPtr;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    maskGet;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    patternGet;
    CPSS_DXCH_PCL_ACTION_STC         actionGet;
    GT_U32                           i;
    GT_U32                           ruleSize;
    GT_U32                           *maskPtr;
    GT_U32                           *patternPtr;
    GT_U32                           *maskGetPtr;
    GT_U32                           *patternGetPtr;
    GT_U32                              expectedError;/*is error expected ?*/

    PRV_UTF_LOG5_MAC(
        "prvRuleParsedGetVerfy dev: %d \n"
        "ruleFormat: %d valid %d \n"
        "ruleIndex %d patternIndex %d \n",
        dev, ruleFormat, valid, ruleIndex, patternIndex);

    cpssOsBzero((GT_VOID*)&ingrAction, sizeof(ingrAction));
    cpssOsBzero((GT_VOID*)&egrAction, sizeof(egrAction));
    cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
    cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
    cpssOsBzero((GT_VOID*)&maskGet, sizeof(maskGet));
    cpssOsBzero((GT_VOID*)&patternGet, sizeof(patternGet));
    cpssOsBzero((GT_VOID*)&actionGet, sizeof(actionGet));

    switch (ruleFormat)
    {
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E:

        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E:

        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E:
            cpssOsMemSet(&egrAction, 0, sizeof(egrAction));
            egrAction.pktCmd = CPSS_PACKET_CMD_DROP_HARD_E;
            if (PRV_CPSS_SIP_6_CHECK_MAC(dev) == GT_TRUE)
            {
                /* the CPU_CODE is used as 'Drop code' for 'soft/hard' drop ,
                   and since action.mirror.cpuCode = 0 is not valid , we set DUMMY value.
                */
                egrAction.mirror.cpuCode = CPSS_NET_ETH_BRIDGED_LLT_E;
            }
            egrAction.egressPolicy = GT_TRUE;
            actionPtr = &egrAction;
            break;
        default:
            cpssOsMemSet(&ingrAction, 0, sizeof(ingrAction));
            ingrAction.pktCmd = CPSS_PACKET_CMD_DROP_HARD_E;
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                /* the CPU_CODE is used as 'Drop code' for 'soft/hard' drop ,
                   and since action.mirror.cpuCode = 0 is not valid , we set DUMMY value.
                */
                ingrAction.mirror.cpuCode = CPSS_NET_ETH_BRIDGED_LLT_E;
            }
            ingrAction.egressPolicy = GT_FALSE;
            actionPtr = &ingrAction;

            break;
    }

    ruleOptionsBmp = 0;
    if (valid == GT_FALSE)
    {
        ruleOptionsBmp |= CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E;
    }

    pclRuleTestFill(
        dev, ruleFormat, patternIndex,
        &mask, &pattern,usePortsBmp,iterationIndex);

    expectedError = 0;
    if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
    {
        switch(ruleFormat)
        {
            case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E:
                expectedError = 1;
                break;
            default:
                break;
        }
    }

    st = cpssDxChPclRuleSet(
        dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
        &mask, &pattern, actionPtr);
    if(expectedError == 0)
    {
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
    }
    else
    {
        UTF_VERIFY_NOT_EQUAL0_PARAM_MAC(GT_OK, st);
    }

    st = cpssDxChPclRuleParsedGet(
        dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
        &isRuleValid, &maskGet, &patternGet, &actionGet);
    if(expectedError == 0)
    {
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
    }
    else
    {
        UTF_VERIFY_NOT_EQUAL0_PARAM_MAC(GT_OK, st);
    }

    if(st == GT_OK)
    {
        UTF_VERIFY_EQUAL0_PARAM_MAC(valid, isRuleValid);

        ruleSize = sizeof(CPSS_DXCH_PCL_RULE_FORMAT_UNT) / sizeof(GT_U32);
        maskPtr       = (GT_U32*)&mask;
        patternPtr    = (GT_U32*)&pattern;
        maskGetPtr    = (GT_U32*)&maskGet;
        patternGetPtr = (GT_U32*)&patternGet;

        /* clear all muxed field in result */
        for (i = 0; (i < ruleSize); i++)
        {
            maskGetPtr[i]   &= maskPtr[i];
            patternGetPtr[i] &= maskPtr[i];
        }

        /* verify get==set */
        for (i = 0; (i < ruleSize); i++)
        {
            if (maskPtr[i] != maskGetPtr[i])
            {
                PRV_UTF_LOG1_MAC("Different word %d in masks\n", i);
            }
            if (patternPtr[i] != patternGetPtr[i])
            {
                PRV_UTF_LOG1_MAC("Different word %d in patterns\n", i);
            }
            UTF_VERIFY_EQUAL0_PARAM_MAC((maskPtr[i]), (maskGetPtr[i]));
            UTF_VERIFY_EQUAL0_PARAM_MAC((patternPtr[i]), (patternGetPtr[i]));
        }
    }
}

UTF_TEST_CASE_MAC(cpssDxChPclRuleParsedGet)
{
    GT_U8                                            dev;
    static CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT        commonRuleFormatArr[] =
    {
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E,

    };
    GT_U32                                    commonFormatsNum =
        sizeof(commonRuleFormatArr) / sizeof(commonRuleFormatArr[0]);

    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT       eArchRuleFormatArr[] =
    {
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E ,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E ,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E ,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E ,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E ,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E ,
    };

    GT_U32                                    eArchFormatsNum =
        sizeof(eArchRuleFormatArr) / sizeof(eArchRuleFormatArr[0]);

    GT_BOOL                                   validArr[] = {GT_TRUE, GT_FALSE};
    GT_U32                                           formatIdx;
    GT_U32                                           validIdx,validIdxMax;
    GT_U32                                           ruleIndex;
    GT_U32                                           patternIndex,patternIndexMax;
    GT_BOOL                                   usePortsBmpArr[]= {GT_FALSE, GT_TRUE};
    GT_U32                                           bmpIdx;
    GT_U32                                           bmpMaxNum;
    GT_U32                                           iterationIndex;/*iteration index*/
    GT_U32                                           formatsNum;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               format;

    GT_U32                                           fixedRuleIndex;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(
        &dev, (UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E));

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(dev))
        {
            ruleIndex = 0;
            formatsNum = commonFormatsNum + eArchFormatsNum;
        }
        else
        {
            ruleIndex = 1;
            formatsNum = commonFormatsNum;
        }


        if(PRV_CPSS_PP_MAC(dev)->devFamily < CPSS_PP_FAMILY_DXCH_XCAT2_E)
        {
            /*the device not supports 'ports bmp' */
            bmpMaxNum = 1;
        }
        else
        {
            bmpMaxNum = sizeof(usePortsBmpArr) / sizeof(usePortsBmpArr[0]);
        }

        patternIndexMax = PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(dev) ? 4 : 3;

        for(bmpIdx = 0 ; bmpIdx < bmpMaxNum; bmpIdx++)
        {
            for (formatIdx = 0; (formatIdx < formatsNum); formatIdx++)
            {
                iterationIndex = 0;

                for (patternIndex = 0; (patternIndex < patternIndexMax); patternIndex++)
                {
                    if(patternIndex == 3)
                    {
                        validIdxMax = 1;
                    }
                    else
                    {
                        validIdxMax = 2;
                    }

                    for (validIdx = 0; (validIdx < validIdxMax); validIdx++)
                    {
                        format = (formatIdx >= commonFormatsNum) ?
                            eArchRuleFormatArr[formatIdx - commonFormatsNum] :
                            commonRuleFormatArr[formatIdx];

                        fixedRuleIndex = ruleIndex;
                        if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev) &&
                            ((format == CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E)
                             || (format == CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E)))
                        {
                            fixedRuleIndex = ruleIndex | 1; /* make rule index odd */
                        }
                        prvRuleParsedGetVerfy(
                            dev, format,
                            validArr[validIdx], fixedRuleIndex, patternIndex,usePortsBmpArr[bmpIdx],
                            iterationIndex++);
                    }
                }
            }
        }
    }
}

static void prvRulePortGroupModifiedParsedGetVerfy
(
    IN  GT_U8                              dev,
    IN  GT_U32                             isEgress,
    IN  GT_U32                             ruleIndex,
    IN  GT_U32                             srcPortArr[2],
    IN  CPSS_PORTS_BMP_STC                 portListBmpArr[2]
)
{
    GT_STATUS st = GT_OK;

    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat;
    GT_BOOL                          isRuleValid;
    CPSS_DXCH_PCL_ACTION_STC         ingrAction;
    CPSS_DXCH_PCL_ACTION_STC         egrAction;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    mask;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    pattern;
    CPSS_DXCH_PCL_ACTION_STC         *actionPtr;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    maskGet;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    patternGet;
    CPSS_DXCH_PCL_ACTION_STC         actionGet;
    GT_U32                           i;
    GT_U32                           ruleSize;
    GT_U32                           *maskPtr;
    GT_U32                           *patternPtr;
    GT_U32                           *maskGetPtr;
    GT_U32                           *patternGetPtr;

    PRV_UTF_LOG3_MAC(
        "prvRulePortGroupModifiedParsedGetVerfy dev: %d \n"
        "isEgress: %d  ruleIndex \n",
        dev, isEgress, ruleIndex);

    cpssOsMemSet(&mask, 0, sizeof(mask));
    cpssOsMemSet(&pattern, 0, sizeof(pattern));
    cpssOsMemSet(&maskGet, 0, sizeof(maskGet));
    cpssOsMemSet(&patternGet, 0, sizeof(patternGet));

    if (isEgress)
    {
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E;
        cpssOsMemSet(&egrAction, 0, sizeof(egrAction));
        egrAction.pktCmd = CPSS_PACKET_CMD_DROP_HARD_E;
        egrAction.egressPolicy = GT_TRUE;
        actionPtr = &egrAction;
        if (portListBmpArr != NULL)
        {
            cpssOsMemCpy(
                &(mask.ruleEgrStdNotIp.common.portListBmp),
                &(portListBmpArr[0]),
                sizeof(CPSS_PORTS_BMP_STC));
            cpssOsMemCpy(
                &(pattern.ruleEgrStdNotIp.common.portListBmp),
                &(portListBmpArr[1]),
                sizeof(CPSS_PORTS_BMP_STC));
        }
    }
    else
    {
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
        cpssOsMemSet(&ingrAction, 0, sizeof(ingrAction));
        ingrAction.pktCmd = CPSS_PACKET_CMD_DROP_HARD_E;
        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
        {
            /* the CPU_CODE is used as 'Drop code' for 'soft/hard' drop ,
               and since action.mirror.cpuCode = 0 is not valid , we set DUMMY value.
            */
            ingrAction.mirror.cpuCode = CPSS_NET_ETH_BRIDGED_LLT_E;
        }

        ingrAction.egressPolicy = GT_FALSE;
        actionPtr = &ingrAction;
        if (srcPortArr != NULL)
        {
            mask.ruleStdNotIp.common.sourcePort = srcPortArr[0];
            pattern.ruleStdNotIp.common.sourcePort = srcPortArr[1];
        }
        if (portListBmpArr != NULL)
        {
            cpssOsMemCpy(
                &(mask.ruleStdNotIp.common.portListBmp),
                &(portListBmpArr[0]),
                sizeof(CPSS_PORTS_BMP_STC));
            cpssOsMemCpy(
                &(pattern.ruleStdNotIp.common.portListBmp),
                &(portListBmpArr[1]),
                sizeof(CPSS_PORTS_BMP_STC));
        }
    }

    st = cpssDxChPclRuleSet(
        dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, 0 /*ruleOptionsBmp*/,
        &mask, &pattern, actionPtr);
    UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

    st = cpssDxChPclRuleParsedGet(
        dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, 0 /*ruleOptionsBmp*/,
        &isRuleValid, &maskGet, &patternGet, &actionGet);
    UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

    if(st == GT_OK)
    {
        ruleSize = sizeof(CPSS_DXCH_PCL_RULE_FORMAT_UNT) / sizeof(GT_U32);
        maskPtr       = (GT_U32*)&mask;
        patternPtr    = (GT_U32*)&pattern;
        maskGetPtr    = (GT_U32*)&maskGet;
        patternGetPtr = (GT_U32*)&patternGet;

        /* clear all muxed field in result */
        for (i = 0; (i < ruleSize); i++)
        {
            maskGetPtr[i]   &= maskPtr[i];
            patternGetPtr[i] &= maskPtr[i];
        }

        /* verify get==set */
        for (i = 0; (i < ruleSize); i++)
        {
            if (maskPtr[i] != maskGetPtr[i])
            {
                PRV_UTF_LOG1_MAC("Different word %d in masks\n", i);
            }
            if (patternPtr[i] != patternGetPtr[i])
            {
                PRV_UTF_LOG1_MAC("Different word %d in patterns\n", i);
            }
            UTF_VERIFY_EQUAL0_PARAM_MAC((maskPtr[i]), (maskGetPtr[i]));
            UTF_VERIFY_EQUAL0_PARAM_MAC((patternPtr[i]), (patternGetPtr[i]));
        }
    }
    else
    {
        PRV_UTF_LOG1_MAC("cpssDxChPclRuleParsedGet : ruleFormat [%d] failed . case 2 \n", ruleFormat);
    }
}

UTF_TEST_CASE_MAC(cpssDxChPclRulePortGroupModifiedParsedGet)
{
    GT_U8         dev;
    GT_U32        directionArr[2] = {0, 1};
    GT_U32        dirIdx;
    GT_U32        patternIndex;
    GT_U32        testIndex;
    GT_U32        ruleIndex;
    static struct
    {
        GT_U32 maskAndPattern[2];
    } srcPortLionData[] =
    {
        {{0x3F, 0x3F}}, /* CPU port                        */
        {{0x0F, 0x02}}, /* local port 2 in each port group */
        {{0x3F, 0x03}}  /* glopal port 3                   */
    };
    static GT_U32 srcPortLionAmount =
        sizeof(srcPortLionData) / sizeof(srcPortLionData[0]);

    static struct
    {
        GT_U32 maskAndPattern[2];
    } srcPortLion2Data[] =
    {
        {{0xFF, 0x3F}}, /* CPU port         */
        {{0x0F, 0x05}}, /* local port 5 in each port group */
        {{0xFF, 0x73}}  /* glopal port 0x73 */
    };

    static GT_U32 srcPortLion2Amount =
        sizeof(srcPortLion2Data) / sizeof(srcPortLion2Data[0]);

    static struct
    {
        CPSS_PORTS_BMP_STC maskAndPattern[2];
    } portListLion2Data[] =
    {
        {{
            {{0x0FFF0FFF, 0x0FFF0FFF, 0x0FFF0FFF, 0x0FFF0FFF,
#if CPSS_MAX_PORTS_NUM_CNS > 128
            0, 0, 0, 0
#endif
        }},
            {{0x0CCC0333, 0x0AAA0555, 0x01110222, 0x04440888,
#if CPSS_MAX_PORTS_NUM_CNS > 128
            0, 0, 0, 0
#endif
            }}
        }}
    };

    static GT_U32 portListLion2Amount =
        sizeof(portListLion2Data) / sizeof(portListLion2Data[0]);

    GT_U32                             *srcPortArr;
    CPSS_PORTS_BMP_STC                 *portListBmpArr;
    CPSS_PP_FAMILY_TYPE_ENT            devFamily;
    GT_BOOL                            isHooper;

    ruleIndex = 1;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(
        &dev, (UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E));

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        if (PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(dev) == 0)
        {
            return;
        }

        prvUtfDeviceFamilyGet(dev, &devFamily);

        isHooper = GT_FALSE;
        if (devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
        {
            if (PRV_CPSS_PP_MAC(dev)->portGroupsInfo.numOfPortGroups <= 4)
            {
                isHooper = GT_TRUE;
            }
        }

        for (dirIdx = 0; (dirIdx < 2); dirIdx++)
        {
            for (patternIndex = 0; (1); patternIndex++)
            {
                if (isHooper != GT_FALSE)
                {
                    testIndex = patternIndex;
                    if (directionArr[dirIdx] != 0)
                    {
                        /* egress keys not relevant */
                        break;
                    }
                    if (testIndex >= srcPortLionAmount)
                    {
                        /* end of data */
                        break;
                    }
                    srcPortArr     =
                        srcPortLionData[testIndex].maskAndPattern;
                    portListBmpArr = NULL;
                }
                else if (devFamily == CPSS_PP_FAMILY_DXCH_LION2_E ||
                         UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
                {
                    if (directionArr[dirIdx] != 0)
                    {
                        /* egress  */
                        testIndex = patternIndex;
                        if (testIndex >= portListLion2Amount)
                        {
                            /* end of data */
                            break;
                        }
                        srcPortArr     = NULL;
                        portListBmpArr =
                            portListLion2Data[testIndex].maskAndPattern;
                    }
                    else
                    {
                        /* ingress  */
                        if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
                        {
                            /* Bobcat2; Caelum; Bobcat3 */
                            testIndex = patternIndex;
                            if (testIndex < srcPortLion2Amount)
                            {
                                srcPortArr    =
                                    srcPortLion2Data[testIndex].maskAndPattern;
                                portListBmpArr = NULL;
                            }
                            else
                            {
                                testIndex -= srcPortLion2Amount;
                                if (testIndex >= portListLion2Amount)
                                {
                                    /* end of data */
                                    break;
                                }
                                srcPortArr     = NULL;
                                portListBmpArr =
                                    portListLion2Data[testIndex].maskAndPattern;
                            }
                        }
                        else
                        {
                            /* Lion2A */
                            testIndex = patternIndex;
                            if (testIndex < srcPortLionAmount)
                            {
                                srcPortArr    =
                                    srcPortLionData[testIndex].maskAndPattern;
                                portListBmpArr = NULL;
                            }
                            else
                            {
                                testIndex -= srcPortLionAmount;
                                if (testIndex >= portListLion2Amount)
                                {
                                    /* end of data */
                                    break;
                                }
                                srcPortArr     = NULL;
                                portListBmpArr =
                                    portListLion2Data[testIndex].maskAndPattern;
                            }
                        }
                    }
                }
                else
                {
                    break;
                }

                prvRulePortGroupModifiedParsedGetVerfy(
                    dev, directionArr[dirIdx], ruleIndex,
                    srcPortArr, portListBmpArr);
            }
        }
    }
}

static GT_U32 pclRuleTestFieldValueCalc(
    IN  GT_U32    patternIndex,
    IN  GT_U32    iterationIndex,
    IN  GT_U32    fieldIdx,
    IN  GT_U32    maxValue
    )
{
    GT_U32 result;

    if (fieldIdx & 1)
    {
        if (patternIndex == 0)
        {
            result = maxValue;
        }
        else if (patternIndex == 1)
        {
            result = (maxValue / 2 + iterationIndex) % maxValue;
        }
        else
        {
            result = iterationIndex % maxValue;
        }
    }
    else
    {
        if (patternIndex == 2)
        {
            result = maxValue;
        }
        else if (patternIndex == 0)
        {
            result = (maxValue / 2 + iterationIndex) % maxValue;
        }
        else
        {
            result = iterationIndex % maxValue;
        }
    }
    return result;
}

static GT_U8 pclRuleTestBitFieldValueCalc(
    IN  GT_U32    patternIndex,
    IN  GT_U32    iterationIndex,
    IN  GT_U32    fieldIdx
    )
{
    GT_U8 result;

    if ((fieldIdx + iterationIndex) & 1)
    {
        if (patternIndex == 0)
        {
            result = 1;
        }
        else if (patternIndex == 1)
        {
            result = iterationIndex & 1;
        }
        else
        {
            result = 0;
        }
    }
    else
    {
        if (patternIndex == 2)
        {
            result = 1;
        }
        else if (patternIndex == 0)
        {
            result = iterationIndex & 1;
        }
        else
        {
            result = 0;
        }
    }
    return result;
}

static GT_VOID pclRuleTestIngressReplacementFill
(
    IN  GT_U8                              devNum,
    IN  GT_U32                             patternIndex,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT      *maskPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT      *patternPtr,
    IN  GT_U32                             iterationIndex,
    IN  GT_U32                             maxUdb
)
{
    GT_U32 fieldIdx;
    GT_U32 maxValue;

    fieldIdx = 0;

    maxValue = PRV_CPSS_SIP_6_10_CHECK_MAC(devNum) ? 0xFFF : 0x3FF;
    maskPtr->ruleIngrUdbOnly.replacedFld.pclId = maxValue;
    patternPtr->ruleIngrUdbOnly.replacedFld.pclId = pclRuleTestFieldValueCalc(patternIndex,iterationIndex, fieldIdx++, maxValue);

    maxValue = 0x1;
    maskPtr->ruleIngrUdbOnly.replacedFld.isUdbValid = maxValue;
    patternPtr->ruleIngrUdbOnly.replacedFld.isUdbValid = pclRuleTestBitFieldValueCalc(patternIndex,iterationIndex, fieldIdx++);

    maxValue = 0x1FFF;
    maskPtr->ruleIngrUdbOnly.replacedFld.vid = maxValue;
    patternPtr->ruleIngrUdbOnly.replacedFld.vid = pclRuleTestFieldValueCalc(patternIndex,iterationIndex, fieldIdx++, maxValue);

    maxValue = 0x7FFF;
    maskPtr->ruleIngrUdbOnly.replacedFld.srcPort = maxValue;
    patternPtr->ruleIngrUdbOnly.replacedFld.srcPort = pclRuleTestFieldValueCalc(patternIndex,iterationIndex, fieldIdx++, maxValue);

    maxValue = 0x1;
    maskPtr->ruleIngrUdbOnly.replacedFld.srcDevIsOwn = maxValue;
    patternPtr->ruleIngrUdbOnly.replacedFld.srcDevIsOwn = pclRuleTestBitFieldValueCalc(patternIndex,iterationIndex, fieldIdx++);

    maxValue = 0xFFF;
    maskPtr->ruleIngrUdbOnly.replacedFld.vid1 = maxValue;
    patternPtr->ruleIngrUdbOnly.replacedFld.vid1 = pclRuleTestFieldValueCalc(patternIndex,iterationIndex, fieldIdx++, maxValue);

    maxValue = 0x7;
    maskPtr->ruleIngrUdbOnly.replacedFld.up1 = maxValue;
    patternPtr->ruleIngrUdbOnly.replacedFld.up1 = pclRuleTestFieldValueCalc(patternIndex,iterationIndex, fieldIdx++, maxValue);

    maxValue = 0x1;
    maskPtr->ruleIngrUdbOnly.replacedFld.macToMe = maxValue;
    patternPtr->ruleIngrUdbOnly.replacedFld.macToMe = pclRuleTestBitFieldValueCalc(patternIndex,iterationIndex, fieldIdx++);

    maxValue = 0x3FF;
    maskPtr->ruleIngrUdbOnly.replacedFld.qosProfile = maxValue;
    patternPtr->ruleIngrUdbOnly.replacedFld.qosProfile = pclRuleTestFieldValueCalc(patternIndex,iterationIndex, fieldIdx++, maxValue);

    if (maxUdb > 10)
    {
        maxValue = 0xFFF;
        maskPtr->ruleIngrUdbOnly.replacedFld.flowId = maxValue;
        patternPtr->ruleIngrUdbOnly.replacedFld.flowId = pclRuleTestFieldValueCalc(patternIndex,iterationIndex, fieldIdx++, maxValue);

        if (PRV_CPSS_SIP_6_10_CHECK_MAC(devNum))
        {
            maxValue = 0xFFFFFF;
            maskPtr->ruleIngrUdbOnly.replacedFld.pclId2 = maxValue;
            patternPtr->ruleIngrUdbOnly.replacedFld.pclId2 = pclRuleTestFieldValueCalc(patternIndex,iterationIndex, fieldIdx++, maxValue);

            maxValue = 0xFFFFFFFF;
            maskPtr->ruleIngrUdbOnly.replacedFld.hash = maxValue;
            patternPtr->ruleIngrUdbOnly.replacedFld.hash = pclRuleTestFieldValueCalc(patternIndex,iterationIndex, fieldIdx++, maxValue);

        }
    }

    return;
}

static GT_VOID pclRuleTestEgressReplacementFill
(
    IN  GT_U32                             patternIndex,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT      *maskPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT      *patternPtr,
    IN  GT_U32                             iterationIndex
)
{
    GT_U32 fieldIdx;
    GT_U32 maxValue;

    fieldIdx = 0;

    maxValue = 0x3FF;
    maskPtr->ruleEgrUdbOnly.replacedFld.pclId = maxValue;
    patternPtr->ruleEgrUdbOnly.replacedFld.pclId = pclRuleTestFieldValueCalc(patternIndex,iterationIndex, fieldIdx++, maxValue);

    maxValue = 0x1;
    maskPtr->ruleEgrUdbOnly.replacedFld.isUdbValid = maxValue;
    patternPtr->ruleEgrUdbOnly.replacedFld.isUdbValid = pclRuleTestBitFieldValueCalc(patternIndex,iterationIndex, fieldIdx++);


    return;
}

static void prvRuleReplacedGetVerfy
(
    IN  GT_U8                                            dev,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               ruleFormat,
    IN  GT_U32                                           ruleIndex,
    IN  GT_U32                                           patternIndex,
    IN  GT_U32                                           iterationIndex
)
{
    GT_STATUS st = GT_OK;

    GT_BOOL                          isRuleValid;
    CPSS_DXCH_PCL_RULE_OPTION_ENT    ruleOptionsBmp;
    CPSS_DXCH_PCL_ACTION_STC         ingrAction;
    CPSS_DXCH_PCL_ACTION_STC         egrAction;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    mask;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    pattern;
    CPSS_DXCH_PCL_ACTION_STC         *actionPtr;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    maskGet;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT    patternGet;
    CPSS_DXCH_PCL_ACTION_STC         actionGet;
    GT_U32                           i;
    GT_U32                           maxUdb;
    GT_U32                           ruleSize;
    GT_U32                           *maskPtr;
    GT_U32                           *patternPtr;
    GT_U32                           *maskGetPtr;
    GT_U32                           *patternGetPtr;
    GT_U32                              expectedError;/*is error expected ?*/

    PRV_UTF_LOG4_MAC(
        "prvRuleReplacedGetVerfy dev: %d \n"
        "ruleFormat: %d \n"
        "ruleIndex %d patternIndex %d \n",
        dev, ruleFormat, ruleIndex, patternIndex);

    cpssOsBzero((GT_VOID*)&ingrAction, sizeof(ingrAction));
    cpssOsBzero((GT_VOID*)&egrAction, sizeof(egrAction));
    cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
    cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
    cpssOsBzero((GT_VOID*)&maskGet, sizeof(maskGet));
    cpssOsBzero((GT_VOID*)&patternGet, sizeof(patternGet));
    cpssOsBzero((GT_VOID*)&actionGet, sizeof(actionGet));

    switch (ruleFormat)
    {
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E:
            cpssOsMemSet(&egrAction, 0, sizeof(egrAction));
            egrAction.pktCmd = CPSS_PACKET_CMD_DROP_HARD_E;
            if (PRV_CPSS_SIP_6_CHECK_MAC(dev) == GT_TRUE)
            {
                /* the CPU_CODE is used as 'Drop code' for 'soft/hard' drop ,
                   and since action.mirror.cpuCode = 0 is not valid , we set DUMMY value.
                */
                egrAction.mirror.cpuCode = CPSS_NET_ETH_BRIDGED_LLT_E;
            }
            egrAction.egressPolicy = GT_TRUE;
            actionPtr = &egrAction;
            pclRuleTestEgressReplacementFill(patternIndex,
                                              &mask, &pattern, iterationIndex);
            break;
        default:
            cpssOsMemSet(&ingrAction, 0, sizeof(ingrAction));
            ingrAction.pktCmd = CPSS_PACKET_CMD_DROP_HARD_E;
            if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
            {
                /* the CPU_CODE is used as 'Drop code' for 'soft/hard' drop ,
                   and since action.mirror.cpuCode = 0 is not valid , we set DUMMY value.
                */
                ingrAction.mirror.cpuCode = CPSS_NET_ETH_BRIDGED_LLT_E;
            }
            ingrAction.egressPolicy = GT_FALSE;
            actionPtr = &ingrAction;

            maxUdb = (ruleFormat == CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E) ? 10 : 70;
            pclRuleTestIngressReplacementFill(dev,patternIndex,
                                              &mask, &pattern, iterationIndex, maxUdb);
            break;
    }

    ruleOptionsBmp = 0;

    expectedError = 0;
    if(PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
    {
        switch(ruleFormat)
        {
            case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E:
                expectedError = 1;
                break;
            default:
                break;
        }
    }

    st = cpssDxChPclRuleSet(
        dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
        &mask, &pattern, actionPtr);
    if(expectedError == 0)
    {
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
    }
    else
    {
        UTF_VERIFY_NOT_EQUAL0_PARAM_MAC(GT_OK, st);
    }

    st = cpssDxChPclRuleParsedGet(
        dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, ruleOptionsBmp,
        &isRuleValid, &maskGet, &patternGet, &actionGet);
    if(expectedError == 0)
    {
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);
    }
    else
    {
        UTF_VERIFY_NOT_EQUAL0_PARAM_MAC(GT_OK, st);
    }

    if(st == GT_OK)
    {
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_TRUE, isRuleValid);

        ruleSize = sizeof(CPSS_DXCH_PCL_RULE_FORMAT_UNT) / sizeof(GT_U32);
        maskPtr       = (GT_U32*)&mask;
        patternPtr    = (GT_U32*)&pattern;
        maskGetPtr    = (GT_U32*)&maskGet;
        patternGetPtr = (GT_U32*)&patternGet;

        /* clear all muxed field in result */
        for (i = 0; (i < ruleSize); i++)
        {
            maskGetPtr[i]   &= maskPtr[i];
            patternGetPtr[i] &= maskPtr[i];
        }

        /* verify get==set */
        for (i = 0; (i < ruleSize); i++)
        {
            if (maskPtr[i] != maskGetPtr[i])
            {
                PRV_UTF_LOG1_MAC("Different word %d in masks\n", i);
            }
            if (patternPtr[i] != patternGetPtr[i])
            {
                PRV_UTF_LOG1_MAC("Different word %d in patterns\n", i);
            }
            UTF_VERIFY_EQUAL0_PARAM_MAC((maskPtr[i]), (maskGetPtr[i]));
            UTF_VERIFY_EQUAL0_PARAM_MAC((patternPtr[i]), (patternGetPtr[i]));
        }
    }
}


UTF_TEST_CASE_MAC(cpssDxChPclRule_replacedTest)
{
    GT_U8                                    dev;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT       ruleFormatArr[] =
    {
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E,
        CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E ,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E ,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E ,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E ,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E ,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E ,
        CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E
    };

    GT_U32                                    formatsNum =
        sizeof(ruleFormatArr) / sizeof(ruleFormatArr[0]);

    GT_U32                                           formatIdx;
    GT_U32                                           ruleIndex;
    GT_U32                                           patternIndex,patternIndexMax;
    GT_U32                                           iterationIndex;/*iteration index*/
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT               format;
    GT_U32                                           fixedRuleIndex;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, (UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E));

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        ruleIndex = 0;

        patternIndexMax = 3;

        for (formatIdx = 0; (formatIdx < formatsNum); formatIdx++)
        {
            format = ruleFormatArr[formatIdx];

            if (!PRV_CPSS_SIP_6_10_CHECK_MAC(dev) &&
                (CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E == format ||
                 CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E == format))
            {
                continue;
            }

            iterationIndex = 0;

            for (patternIndex = 0; (patternIndex < patternIndexMax); patternIndex++)
            {
                fixedRuleIndex = ruleIndex;
                if (PRV_CPSS_SIP_6_10_CHECK_MAC(dev) &&
                    ((format == CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E)
                     || (format == CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E)))
                {
                    fixedRuleIndex = ruleIndex | 1; /* make rule index odd */
                }

                prvRuleReplacedGetVerfy(
                    dev, format, fixedRuleIndex, patternIndex,
                    iterationIndex++);
            }
        }
    }
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclLookup0ForRoutedPacketsEnableSet
(
    IN  GT_U8   devNum,
    IN  GT_BOOL enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclLookup0ForRoutedPacketsEnableSet)
{
/*
    ITERATE_DEVICES (DxCh3)
    1.1. Call function with enable [GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.2. Call cpssDxChPclLookup0ForRoutedPacketsEnableGet with not NULL enablePtr.
    Expected: GT_OK and same enable as was set.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_BOOL     enable    = GT_FALSE;
    GT_BOOL     enableGet = GT_FALSE;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with enable [GT_FALSE / GT_TRUE].
            Expected: GT_OK.
        */
        /* iterate with enable = GT_FALSE */
        enable = GT_FALSE;

        st = cpssDxChPclLookup0ForRoutedPacketsEnableSet(dev, /* temp*/dev,enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /*
            1.2. Call cpssDxChPclLookup0ForRoutedPacketsEnableGet with not NULL enablePtr.
            Expected: GT_OK and same enable as was set.
        */
        st = cpssDxChPclLookup0ForRoutedPacketsEnableGet(dev, /* temp*/dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxChPclLookup0ForRoutedPacketsEnableGet: %d", dev);

        /* verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                   "got another enable then was set: %d", dev);

        /* iterate with enable = GT_TRUE */
        enable = GT_TRUE;

        st = cpssDxChPclLookup0ForRoutedPacketsEnableSet(dev, /* temp*/dev, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /*
            1.2. Call cpssDxChPclLookup0ForRoutedPacketsEnableGet with not NULL enablePtr.
            Expected: GT_OK and same enable as was set.
        */
        st = cpssDxChPclLookup0ForRoutedPacketsEnableGet(dev,/* temp*/dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxChPclLookup0ForRoutedPacketsEnableGet: %d", dev);

        /* verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                   "got another enable then was set: %d", dev);
    }

    enable = GT_FALSE;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclLookup0ForRoutedPacketsEnableSet(dev, /* temp*/3, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclLookup0ForRoutedPacketsEnableSet(dev, /* temp*/3, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclLookup0ForRoutedPacketsEnableGet
(
    IN  GT_U8                              devNum,
    OUT GT_BOOL                            *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclLookup0ForRoutedPacketsEnableGet)
{
/*
    ITERATE_DEVICES (DxCh3)
    1.1. Call function with not NULL enablePtr.
    Expected: GT_OK.
    1.2. Call with enablePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_BOOL     enable = GT_FALSE;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with not NULL enablePtr.
            Expected: GT_OK.
        */
        st = cpssDxChPclLookup0ForRoutedPacketsEnableGet(dev, /* temp*/dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call with enablePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclLookup0ForRoutedPacketsEnableGet(dev, /* temp*/dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enablePtr = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclLookup0ForRoutedPacketsEnableGet(dev, /* temp*/2, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclLookup0ForRoutedPacketsEnableGet(dev, /* temp*/24, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclLookup1ForNotRoutedPacketsEnableSet
(
    IN  GT_U8                              devNum,
    IN  GT_BOOL                            enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclLookup1ForNotRoutedPacketsEnableSet)
{
/*
    ITERATE_DEVICES (DxCh3)
    1.1. Call function with enable [GT_FALSE / GT_TRUE].
    Expected: GT_OK.
    1.2. Call cpssDxChPclLookup1ForNotRoutedPacketsEnableGet with not NULL enablePtr.
    Expected: GT_OK and same enable as was set.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_BOOL     enable    = GT_FALSE;
    GT_BOOL     enableGet = GT_FALSE;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with enable [GT_FALSE / GT_TRUE].
            Expected: GT_OK.
        */
        /* iterate with enable = GT_FALSE */
        enable = GT_FALSE;

        st = cpssDxChPclLookup1ForNotRoutedPacketsEnableSet(dev, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /*
            1.2. Call cpssDxChPclLookup1ForNotRoutedPacketsEnableGet with not NULL enablePtr.
            Expected: GT_OK and same enable as was set.
        */
        st = cpssDxChPclLookup1ForNotRoutedPacketsEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxChPclLookup1ForNotRoutedPacketsEnableGet: %d", dev);

        /* verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                   "got another enable then was set: %d", dev);

        /* iterate with enable = GT_TRUE */
        enable = GT_TRUE;

        st = cpssDxChPclLookup1ForNotRoutedPacketsEnableSet(dev, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /*
            1.2. Call cpssDxChPclLookup1ForNotRoutedPacketsEnableGet with not NULL enablePtr.
            Expected: GT_OK and same enable as was set.
        */
        st = cpssDxChPclLookup1ForNotRoutedPacketsEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxChPclLookup1ForNotRoutedPacketsEnableGet: %d", dev);

        /* verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                   "got another enable then was set: %d", dev);
    }

    enable = GT_FALSE;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclLookup1ForNotRoutedPacketsEnableSet(dev, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclLookup1ForNotRoutedPacketsEnableSet(dev, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclLookup1ForNotRoutedPacketsEnableGet
(
    IN  GT_U8                              devNum,
    IN  GT_BOOL                            *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclLookup1ForNotRoutedPacketsEnableGet)
{
/*
    ITERATE_DEVICES (DxCh3)
    1.1. Call function with not NULL enablePtr.
    Expected: GT_OK.
    1.2. Call with enablePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_BOOL     enable = GT_FALSE;


    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with not NULL enablePtr.
            Expected: GT_OK.
        */
        st = cpssDxChPclLookup1ForNotRoutedPacketsEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call with enablePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclLookup1ForNotRoutedPacketsEnableGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enablePtr = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CPSS_PP_ALL_SIP6_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclLookup1ForNotRoutedPacketsEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclLookup1ForNotRoutedPacketsEnableGet(dev, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclIpMinOffsetGet
(
    IN  GT_U8   dev,
    OUT GT_U32  *ipMinOffsetPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclIpMinOffsetGet)
{
/*
    ITERATE_DEVICES(All DxChXcat and above devices)
    1.1. Call with not null ipMinOffsetPtr.
    Expected: GT_OK.
    1.2. Call api with wrong ipMinOffsetPtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;

    GT_U8   dev;
    GT_U32  ipMinOffset;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with not null ipMinOffsetPtr.
            Expected: GT_OK.
        */
        st = cpssDxChPclIpMinOffsetGet(dev, &ipMinOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call api with wrong ipMinOffsetPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclIpMinOffsetGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                   "%d, ipMinOffsetPtr = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclIpMinOffsetGet(dev, &ipMinOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclIpMinOffsetGet(dev, &ipMinOffset);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclIpMinOffsetSet
(
    IN  GT_U8  dev,
    IN  GT_U32 ipMinOffset
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclIpMinOffsetSet)
{
/*
    ITERATE_DEVICES(All DxChXcat and above devices)
    1.1. Call with ipMinOffset[0 / 100 / 0x1FFF],
    Expected: GT_OK.
    1.2. Call cpssDxChPclIpMinOffsetGet
           with the same parameters.
    Expected: GT_OK and the same values than was set.
    1.3. Call api with wrong ipMinOffset [0x1FFF + 1].
    Expected: NOT GT_OK.
*/
    GT_STATUS st = GT_OK;

    GT_U8  dev;
    GT_U32 ipMinOffset = 0;
    GT_U32 ipMinOffsetGet = 0;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with ipMinOffset[0 / 100 / 0x1FFF],
            Expected: GT_OK.
        */

        /* call with ipMinOffset[0] */
        ipMinOffset = 0;

        st = cpssDxChPclIpMinOffsetSet(dev, ipMinOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPclIpMinOffsetGet
                   with the same parameters.
            Expected: GT_OK and the same values than was set.
        */
        st = cpssDxChPclIpMinOffsetGet(dev, &ipMinOffsetGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPclIpMinOffsetGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(ipMinOffset, ipMinOffsetGet,
                       "got another ipMinOffset then was set: %d", dev);

        /* call with ipMinOffset[100] */
        ipMinOffset = 100;

        st = cpssDxChPclIpMinOffsetSet(dev, ipMinOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* call get func again, 1.2. */
        st = cpssDxChPclIpMinOffsetGet(dev, &ipMinOffsetGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPclIpMinOffsetGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(ipMinOffset, ipMinOffsetGet,
                       "got another ipMinOffset then was set: %d", dev);

        /* call with ipMinOffset[0x1FFF] */
        ipMinOffset = 0x1FFF;

        st = cpssDxChPclIpMinOffsetSet(dev, ipMinOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* call get func again, 1.2. */
        st = cpssDxChPclIpMinOffsetGet(dev, &ipMinOffsetGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPclIpMinOffsetGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(ipMinOffset, ipMinOffsetGet,
                       "got another ipMinOffset then was set: %d", dev);

        /*
            1.3. Call api with wrong ipMinOffset [0x1FFF + 1].
            Expected: NOT GT_OK.
        */
        ipMinOffset = 0x1FFF + 1;

        st = cpssDxChPclIpMinOffsetSet(dev, ipMinOffset);
        UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        ipMinOffset = 0;
    }

    /* restore correct values */
    ipMinOffset = 0;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclIpMinOffsetSet(dev, ipMinOffset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclIpMinOffsetSet(dev, ipMinOffset);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortIngressLookup0Sublookup1TypeGet
(
    IN  GT_U8                                     devNum,
    OUT CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_ENT *lookupTypePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortIngressLookup0Sublookup1TypeGet)
{
/*
    ITERATE_DEVICES
    1.1. Call with non-NULL lookupTypePtr.
    Expected: GT_OK.
    1.2 Call with lookupTypePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS  st = GT_OK;
    GT_U8      dev;
    CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_ENT lookupTypePtr;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with non-NULL lookupTypePtr
            Expected: GT_OK.
        */
        st = cpssDxChPclPortIngressLookup0Sublookup1TypeGet(dev, &lookupTypePtr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2 Call with lookupTypePtr [NULL];
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclPortIngressLookup0Sublookup1TypeGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, lookupTypePtr = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortIngressLookup0Sublookup1TypeGet(dev, &lookupTypePtr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortIngressLookup0Sublookup1TypeGet(dev, &lookupTypePtr);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}
/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortIngressLookup0Sublookup1TypeSet
(
    IN  GT_U8                                       devNum,
    IN  CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_ENT   lookupType
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortIngressLookup0Sublookup1TypeSet)
{
/*
    ITERATE_DEVICES
    1.1. Call lookupType = [CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_PARTIAL_E /
                            CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_FULL_E].
    Expected: GT_OK.
    1.2. Call lookupType = PCL_INVALID_ENUM_CNS.
    Expected: GT_BAD_PARAM.
    1.3. Call cpssDxChPclPortIngressLookup0Sublookup1TypeGet
         with non-NULL lookupType.
    Expected: GT_OK and the same lookupType.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_ENT lookupType;
    CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_ENT lookupTypeGet;
    GT_BOOL     iPcl0Bypass;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        /*
            1.1. Call lookupType = [CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_PARTIAL_E /
                                    CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_FULL_E].
            Expected: GT_OK.
        */

        /*call with lookupType = CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_PARTIAL_E */
        lookupType = CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_PARTIAL_E;

        st = cpssDxChPclPortIngressLookup0Sublookup1TypeSet(dev, lookupType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(iPcl0Bypass ? GT_BAD_PARAM : GT_OK, st, dev);

        /*call with lookupType = CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_FULL_E */
        lookupType = CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_FULL_E;

        st = cpssDxChPclPortIngressLookup0Sublookup1TypeSet(dev, lookupType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call lookupType = PCL_INVALID_ENUM_CNS.
            Expected: GT_BAD_PARAM.
        */
        lookupType = PCL_INVALID_ENUM_CNS;

        st = cpssDxChPclPortIngressLookup0Sublookup1TypeSet(dev, lookupType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        lookupType = CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_FULL_E;

        /*
            1.3. Call cpssDxChPclPortIngressLookup0Sublookup1TypeGet
                 with non-NULL lookupType.
            Expected: GT_OK and the same lookupType.
        */
        st = cpssDxChPclPortIngressLookup0Sublookup1TypeGet(dev, &lookupTypeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxChPclPortIngressLookup0Sublookup1TypeGet: %d", dev);

        /* Verifying values*/
        UTF_VERIFY_EQUAL1_STRING_MAC(lookupType, lookupTypeGet,
                          "get another lookupType than was set: %d", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    lookupType = CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_FULL_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_CH1_E | UTF_CH1_DIAMOND_E | UTF_CH2_E | UTF_CH3_E);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortIngressLookup0Sublookup1TypeSet(dev, lookupType);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortIngressLookup0Sublookup1TypeSet(dev, lookupType);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
UTF_TEST_CASE_MAC(cpssDxChPclPortListGroupingEnableSet)
{
/*
    ITERATE_DEVICES
    1.1. Call with enable[GT_TRUE / GT_FALSE],
    Expected: GT_OK.
    1.2. Call ccpssDxChPclPortListGroupingEnableGet
           with same enablePtr.
    Expected: GT_OK and the same enable than was set.
*/
    GT_STATUS st = GT_OK;

    GT_U8   dev;
    CPSS_PCL_DIRECTION_ENT    direction;
    GT_BOOL enable = GT_FALSE;
    GT_BOOL enableGet = GT_FALSE;


    GT_U32      notAppFamilyBmp;
    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*  1.1.  */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        enable = GT_TRUE;

        st = cpssDxChPclPortListGroupingEnableSet(dev, direction, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*  1.2.  */
        st = cpssDxChPclPortListGroupingEnableGet(dev, direction, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPclPortListGroupingEnableGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                       "got another enable then was set: %d", dev);

        /*  1.3.  */
        enable = GT_FALSE;

        st = cpssDxChPclPortListGroupingEnableSet(dev, direction, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* call get func again, 1.2. */
        st = cpssDxChPclPortListGroupingEnableGet(dev, direction, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPclPortListGroupingEnableGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                       "got another enable then was set: %d", dev);

        /*  1.4.  */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;
        enable = GT_TRUE;

        st = cpssDxChPclPortListGroupingEnableSet(dev, direction, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*  1.5.  */
        st = cpssDxChPclPortListGroupingEnableGet(dev, direction, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPclPortListGroupingEnableGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                       "got another enable then was set: %d", dev);

        /*  1.6.  */
        enable = GT_FALSE;

        st = cpssDxChPclPortListGroupingEnableSet(dev, direction, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* call get func again, 1.2. */
        st = cpssDxChPclPortListGroupingEnableGet(dev, direction, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                  "cpssDxChPclPortListGroupingEnableGet: %d ", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                       "got another enable then was set: %d", dev);

        /*
            1.7. Check for invalid enum value for direction.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclPortListGroupingEnableSet
                            (dev, direction, enable),
                            direction);
    }

    /* restore correct values */
    enable = GT_TRUE;
    direction = CPSS_PCL_DIRECTION_INGRESS_E;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortListGroupingEnableSet(dev, direction, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortListGroupingEnableSet(dev, direction, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
UTF_TEST_CASE_MAC(cpssDxChPclPortListGroupingEnableGet)
{
/*
    ITERATE_DEVICES
    1.1. Call with not null enablePtr.
    Expected: GT_OK.
    1.2. Call api with wrong enablePtr [NULL].
    Expected: GT_BAD_PTR.
*/
    GT_STATUS st = GT_OK;

    GT_U8    dev;
    CPSS_PCL_DIRECTION_ENT    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    GT_BOOL  enable;

    GT_U32      notAppFamilyBmp;
    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*  1.1.  */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        st = cpssDxChPclPortListGroupingEnableGet(dev, direction, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*  1.2.  */
        st = cpssDxChPclPortListGroupingEnableGet(dev, direction, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                   "%d, enablePtr = NULL", dev);

        /*  1.3.  */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;
        st = cpssDxChPclPortListGroupingEnableGet(dev, direction, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*  1.4.  */
        st = cpssDxChPclPortListGroupingEnableGet(dev, direction, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                   "%d, enablePtr = NULL", dev);

        /*
            1.5. Check for invalid enum value for direction.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclPortListGroupingEnableGet
                            (dev, direction, &enable),
                            direction);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortListGroupingEnableGet(dev, direction, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortListGroupingEnableGet(dev, direction, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet
(
    IN  GT_U8                     devNum,
    IN  GT_U32                    channelType,
    IN  GT_U32                    opcode,
    IN  GT_BOOL                   RBitAssignmentEnable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with channelType [1 / 0xA / BIT_4-1],
                            opcode [0 / 0xA5 / BIT_8-1] and
                            RBitAssignmentEnable [GT_FALSE / GT_TRUE]
    Expected: GT_OK.
    1.2. Call cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet with non-NULL pointers
    Expected: GT_OK and the same parameters.
    1.3. Call function with out of range channelType [BIT_4]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
    1.4. Call function with out of range opcode [BIT_8]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    GT_U32      channelType = 1;
    GT_U32      opcode = 0;
    GT_U32      opcodeGet;
    GT_BOOL     RBitAssignmentEnable = GT_FALSE;
    GT_BOOL     RBitAssignmentEnableGet;
    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with channelType [1 / 0xA / BIT_4-1],
                                    opcode [0 / 0xA5 / BIT_8-1] and
                                    RBitAssignmentEnable [GT_FALSE / GT_TRUE]
            Expected: GT_OK.
        */

        /*
            Call with channelType [1],
                      opcode [0],
                      RBitAssignmentEnable [GT_FALSE],
        */
        channelType = 1;
        opcode      = 0;
        RBitAssignmentEnable = GT_FALSE;

        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet(dev, channelType,
                                                  opcode, RBitAssignmentEnable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, channelType);

        /* Verifying values */
        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(dev, channelType,
                                          &opcodeGet, &RBitAssignmentEnableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(opcode, opcodeGet,
                                    "get another opcode than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(RBitAssignmentEnable,
                                     RBitAssignmentEnableGet,
                      "get another RBitAssignmentEnable than was set: %d", dev);

        /*
            Call with channelType [0xA],
                      opcode [0xA5],
                      RBitAssignmentEnable [GT_TRUE],
        */
        channelType = 0xA;
        opcode      = 0xA5;
        RBitAssignmentEnable = GT_TRUE;

        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet(dev, channelType,
                                                  opcode, RBitAssignmentEnable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, channelType);

        /* Verifying values */
        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(dev, channelType,
                                          &opcodeGet, &RBitAssignmentEnableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(opcode, opcodeGet,
                                    "get another opcode than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(RBitAssignmentEnable,
                                     RBitAssignmentEnableGet,
                      "get another RBitAssignmentEnable than was set: %d", dev);

        /*
            Call with channelType [BIT_4-1],
                      opcode [BIT_8-1],
                      RBitAssignmentEnable [GT_TRUE],
        */
        channelType = BIT_4-1;
        opcode      = BIT_8-1;

        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet(dev, channelType,
                                                  opcode, RBitAssignmentEnable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, channelType);

        /*
            1.2. Call cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet with
                 non-NULL pointers.
            Expected: GT_OK and the same parameters.
        */

        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(dev, channelType,
                                          &opcodeGet, &RBitAssignmentEnableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet: %d", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(opcode, opcodeGet,
                                    "get another opcode than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(RBitAssignmentEnable,
                                     RBitAssignmentEnableGet,
                      "get another RBitAssignmentEnable than was set: %d", dev);

        /*
            1.3. Call function with out of range channelType [BIT_4]
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */
        channelType = BIT_4;

        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet(dev, channelType,
                                                  opcode, RBitAssignmentEnable);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, channelType);

        channelType = 1;

        /*
            1.4. Call function with out of range opcode [BIT_8]
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */

        opcode = BIT_8;

        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet(dev, channelType,
                                                  opcode, RBitAssignmentEnable);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, channelType);

        opcode = 0;
    }

    /*
      2. For not-active devices and devices from non-applicable family
         check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet(dev, channelType,
                                                  opcode, RBitAssignmentEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet(dev, channelType,
                                                  opcode, RBitAssignmentEnable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet
(
    IN  GT_U8                     devNum,
    IN  GT_U32                    channelType,
    OUT GT_U32                    *opcodePtr,
    OUT GT_BOOL                   *RBitAssignmentEnablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with channelType [1 / 0xA / BIT_4-1] and
                            non-NULL pointers.
    Expected: GT_OK.
    1.2. Call function with out of range channelType [BIT_4]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
    1.3. Call function with opcodePtr [NULL].
    Expected: GT_BAD_PTR.
    1.4. Call function with RBitAssignmentEnablePtr [NULL].
    Expected: GT_BAD_PTR.

*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    GT_U32      channelType = 1;
    GT_U32      opcode;
    GT_BOOL     RBitAssignmentEnable;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with channelType [1 / 0xA / BIT_4-1] and
                                    non-NULL pointers.
            Expected: GT_OK.
        */

        /* Call with channelType [1] */
        channelType = 1;

        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(dev, channelType,
                                                &opcode, &RBitAssignmentEnable);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet: %d", dev);

        /* Call with channelType [0xA] */
        channelType = 0xA;

        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(dev, channelType,
                                                &opcode, &RBitAssignmentEnable);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet: %d", dev);

        /* Call with channelType [BIT_4-1] */
        channelType = BIT_4-1;

        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(dev, channelType,
                                                &opcode, &RBitAssignmentEnable);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                        "cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet: %d", dev);

        /*
            1.2. Call function with out of range channelType [BIT_4]
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */

        channelType = BIT_4;

        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(dev, channelType,
                                                &opcode, &RBitAssignmentEnable);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, channelType);

        channelType = 1;

        /*
            1.3. Call function with opcodePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(dev, channelType,
                                                   NULL, &RBitAssignmentEnable);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                                   "%d, opcodePtr = NULL", dev);

        /*
            1.4. Call function with RBitAssignmentEnablePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(dev, channelType,
                                                                 &opcode, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                     "%d, RBitAssignmentEnablePtr = NULL", dev);
    }

    /*
        2. For not-active devices and devices from non-applicable family
           check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(dev, channelType,
                                                &opcode, &RBitAssignmentEnable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet(dev, channelType,
                                                &opcode, &RBitAssignmentEnable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOamRdiMatchingSet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  GT_U32                        oamProfile,
    IN  GT_U32                        rdiMask,
    IN  GT_U32                        rdiPattern
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOamRdiMatchingSet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                       CPSS_PCL_DIRECTION_EGRESS_E],
                            oamProfile [0 / 1],
                            rdiMask    [0 / 0xA5 / BIT_8-1] and
                            rdiPattern [0 / 0xA5 / BIT_8-1].
    Expected: GT_OK.
    1.2. Call cpssDxChPclOamRdiMatchingGet with non-NULL pointers.
    Expected: GT_OK and the same parameters.
    1.3. Call function with out of range direction
         and other parameters from 1.1.
    Expected: GT_BAD_PARAM
    1.4. Call function with out of range oamProfile [2]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
    1.5. Call function with out of range rdiMask [BIT_8]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
    1.6. Call function with out of range rdiPattern [BIT_8]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    IN  CPSS_PCL_DIRECTION_ENT        direction = CPSS_PCL_DIRECTION_INGRESS_E;
    IN  GT_U32                        oamProfile = 0;
    IN  GT_U32                        rdiMask = 0;
    IN  GT_U32                        rdiMaskGet;
    IN  GT_U32                        rdiPattern = 0;
    IN  GT_U32                        rdiPatternGet;
    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                               CPSS_PCL_DIRECTION_EGRESS_E],
                                    oamProfile [0 / 1],
                                    rdiMask    [0 / 0xA5 / BIT_8-1] and
                                    rdiPattern [0 / 0xA5 / BIT_8-1]
            Expected: GT_OK.
        */

        /*
            Call with direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                      oamProfile [0],
                      rdiMask    [0],
                      rdiPattern [0].
        */
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        oamProfile = 0;
        rdiMask    = 0;
        rdiPattern = 0;

        st = cpssDxChPclOamRdiMatchingSet(dev, direction, oamProfile, rdiMask,
                                          rdiPattern);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile,
                                          &rdiMaskGet, &rdiPatternGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamRdiMatchingGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(rdiMask, rdiMaskGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(rdiPattern, rdiPatternGet,
                                "get another rdiPattern than was set: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                      oamProfile [1],
                      rdiMask    [0xA5],
                      rdiPattern [0xA5].
        */
        oamProfile = 1;
        rdiMask    = 0xA5;
        rdiPattern = 0xA5;

        st = cpssDxChPclOamRdiMatchingSet(dev, direction, oamProfile, rdiMask,
                                          rdiPattern);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile,
                                          &rdiMaskGet, &rdiPatternGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamRdiMatchingGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(rdiMask, rdiMaskGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(rdiPattern, rdiPatternGet,
                                "get another rdiPattern than was set: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                      oamProfile [1],
                      rdiMask    [BIT_8-1],
                      rdiPattern [BIT_8-1].
        */
        rdiMask    = BIT_8-1;
        rdiPattern = BIT_8-1;

        st = cpssDxChPclOamRdiMatchingSet(dev, direction, oamProfile, rdiMask,
                                          rdiPattern);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile,
                                          &rdiMaskGet, &rdiPatternGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamRdiMatchingGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(rdiMask, rdiMaskGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(rdiPattern, rdiPatternGet,
                                "get another rdiPattern than was set: %d", dev);
        /*
            Call with direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                      oamProfile [0],
                      rdiMask    [0],
                      rdiPattern [0].
        */
        direction  = CPSS_PCL_DIRECTION_EGRESS_E;
        oamProfile = 0;
        rdiMask    = 0;
        rdiPattern = 0;

        st = cpssDxChPclOamRdiMatchingSet(dev, direction, oamProfile, rdiMask,
                                          rdiPattern);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile,
                                          &rdiMaskGet, &rdiPatternGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamRdiMatchingGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(rdiMask, rdiMaskGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(rdiPattern, rdiPatternGet,
                                "get another rdiPattern than was set: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                      oamProfile [1],
                      rdiMask    [0xA5],
                      rdiPattern [0xA5].
        */
        oamProfile = 1;
        rdiMask    = 0xA5;
        rdiPattern = 0xA5;

        st = cpssDxChPclOamRdiMatchingSet(dev, direction, oamProfile, rdiMask,
                                          rdiPattern);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile,
                                          &rdiMaskGet, &rdiPatternGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamRdiMatchingGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(rdiMask, rdiMaskGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(rdiPattern, rdiPatternGet,
                                "get another rdiPattern than was set: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                      oamProfile [1],
                      rdiMask    [BIT_8-1],
                      rdiPattern [BIT_8-1].
        */
        rdiMask    = BIT_8-1;
        rdiPattern = BIT_8-1;

        st = cpssDxChPclOamRdiMatchingSet(dev, direction, oamProfile, rdiMask,
                                          rdiPattern);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /*
            1.2. Call cpssDxChPclOamRdiMatchingGet with non-NULL pointers.
            Expected: GT_OK and the same parameters.
        */

        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile,
                                          &rdiMaskGet, &rdiPatternGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamRdiMatchingGet: %d", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(rdiMask, rdiMaskGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(rdiPattern, rdiPatternGet,
                                "get another rdiPattern than was set: %d", dev);
        /*
            1.3. Call function with out of range direction
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */

        UTF_ENUMS_CHECK_MAC(cpssDxChPclOamRdiMatchingSet
                            (dev, direction, oamProfile, rdiMask, rdiPattern),
                            direction);

        /*
            1.4. Call function with out of range oamProfile [2]
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */
        oamProfile = 2;

        st = cpssDxChPclOamRdiMatchingSet(dev, direction, oamProfile, rdiMask,
                                          rdiPattern);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        oamProfile = 0;

        /*
            1.5. Call function with out of range rdiMask [BIT_8]
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */

        rdiMask = BIT_8;

        st = cpssDxChPclOamRdiMatchingSet(dev, direction, oamProfile, rdiMask,
                                          rdiPattern);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        rdiMask = 0;

        /*
            1.6. Call function with out of range rdiPattern [BIT_8]
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */

        rdiPattern = BIT_8;

        st = cpssDxChPclOamRdiMatchingSet(dev, direction, oamProfile, rdiMask,
                                          rdiPattern);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        rdiPattern = 0;
    }

    /*
      2. For not-active devices and devices from non-applicable family
         check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOamRdiMatchingSet(dev, direction, oamProfile, rdiMask,
                                          rdiPattern);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOamRdiMatchingSet(dev, direction, oamProfile, rdiMask,
                                      rdiPattern);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOamRdiMatchingGet
(
    IN  GT_U8                         devNum,
    IN  CPSS_PCL_DIRECTION_ENT        direction,
    IN  GT_U32                        oamProfile,
    OUT GT_U32                        *rdiMaskPtr,
    OUT GT_U32                        *rdiPatternPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOamRdiMatchingGet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                       CPSS_PCL_DIRECTION_EGRESS_E],
                            oamProfile [0 / 1] and
                            non-NULL pointers.
    Expected: GT_OK.
    1.2. Call function with out of range direction
         and other parameters from 1.1.
    Expected: GT_BAD_PARAM
    1.3. Call function with out of range oamProfile [2]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
    1.4. Call function with rdiMaskPtr [NULL].
    Expected: GT_BAD_PTR.
    1.5. Call function with rdiPatternPtr [NULL].
    Expected: GT_BAD_PTR.

*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    IN  CPSS_PCL_DIRECTION_ENT        direction = CPSS_PCL_DIRECTION_INGRESS_E;
    IN  GT_U32                        oamProfile = 0;
    IN  GT_U32                        rdiMask;
    IN  GT_U32                        rdiPattern;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                               CPSS_PCL_DIRECTION_EGRESS_E],
                                    oamProfile [0 / 1] and
                                    non-NULL pointer.
            Expected: GT_OK.
        */

        /*
            Call with direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                      oamProfile [0].
        */
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        oamProfile = 0;

        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile, &rdiMask,
                                          &rdiPattern);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                       "cpssDxChPclOamRdiMatchingGet: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                      oamProfile [1].
        */
        oamProfile = 1;

        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile, &rdiMask,
                                          &rdiPattern);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                       "cpssDxChPclOamRdiMatchingGet: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                      oamProfile [0].
        */
        direction  = CPSS_PCL_DIRECTION_EGRESS_E;
        oamProfile = 0;

        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile, &rdiMask,
                                          &rdiPattern);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                       "cpssDxChPclOamRdiMatchingGet: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                      oamProfile [1].
        */
        oamProfile = 1;

        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile, &rdiMask,
                                          &rdiPattern);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                       "cpssDxChPclOamRdiMatchingGet: %d", dev);

        /*
            1.2. Call function with out of range direction
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */

        UTF_ENUMS_CHECK_MAC(cpssDxChPclOamRdiMatchingGet
                            (dev, direction, oamProfile, &rdiMask, &rdiPattern),
                            direction);

        /*
            1.3. Call function with out of range oamProfile [2]
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */

        oamProfile = 2;

        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile, &rdiMask,
                                          &rdiPattern);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        oamProfile = 0;

        /*
            1.4. Call function with rdiMaskPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile, NULL,
                                          &rdiPattern);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                                  "%d, rdiMaskPtr = NULL", dev);

        /*
            1.5. Call function with rdiPatternPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile, &rdiMask,
                                          NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                               "%d, rdiPatternPtr = NULL", dev);
    }

    /*
        2. For not-active devices and devices from non-applicable family
           check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile, &rdiMask,
                                          &rdiPattern);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOamRdiMatchingGet(dev, direction, oamProfile, &rdiMask,
                                          &rdiPattern);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOamMegLevelModeSet
(
    IN  GT_U8                                     devNum,
    IN  CPSS_PCL_DIRECTION_ENT                    direction,
    IN  GT_U32                                    oamProfile,
    IN  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_ENT  megLevelMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOamMegLevelModeSet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                       CPSS_PCL_DIRECTION_EGRESS_E],
                            oamProfile [0 / 1],
                            megLevelMode [
                                  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E,
                                  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_MAC_DA_E,
                                  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_EXP_E,
                                  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_QOS_E].
    Expected: GT_OK.
    1.2. Call cpssDxChPclOamMegLevelModeGet with non-NULL pointers.
    Expected: GT_OK and the same parameters.
    1.3. Call function with out of range direction
         and other parameters from 1.1.
    Expected: GT_BAD_PARAM
    1.4. Call function with out of range oamProfile [2]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
    1.5. Call function with out of range megLevelMode
         and other parameters from 1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    IN  CPSS_PCL_DIRECTION_ENT        direction = CPSS_PCL_DIRECTION_INGRESS_E;
    IN  GT_U32                        oamProfile = 0;
    IN  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_ENT  megLevelMode =
                                     CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E;
    IN  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_ENT  megLevelModeGet =
                                     CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E;
    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                       CPSS_PCL_DIRECTION_EGRESS_E],
                                    oamProfile [0 / 1],
                                    megLevelMode [
                                  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E,
                                  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_MAC_DA_E,
                                  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_EXP_E,
                                  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_QOS_E].
            Expected: GT_OK.
        */

        /*
            Call with direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                      oamProfile [0],
                      megLevelMode [CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E].
        */
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        oamProfile = 0;
        megLevelMode = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E;

        st = cpssDxChPclOamMegLevelModeSet(dev, direction, oamProfile,
                                           megLevelMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                          &megLevelModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamMegLevelModeGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(megLevelMode, megLevelModeGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                   oamProfile [1],
                   megLevelMode [CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_MAC_DA_E].
        */
        oamProfile = 1;
        megLevelMode = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_MAC_DA_E;

        st = cpssDxChPclOamMegLevelModeSet(dev, direction, oamProfile,
                                           megLevelMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                          &megLevelModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamMegLevelModeGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(megLevelMode, megLevelModeGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                      oamProfile [1],
                      megLevelMode [CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_QOS_E].
        */
        megLevelMode = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_QOS_E;

        st = cpssDxChPclOamMegLevelModeSet(dev, direction, oamProfile,
                                           megLevelMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                          &megLevelModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamMegLevelModeGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(megLevelMode, megLevelModeGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                      oamProfile [0],
                      megLevelMode [CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E].
        */
        direction  = CPSS_PCL_DIRECTION_EGRESS_E;
        oamProfile = 0;
        megLevelMode = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E;

        st = cpssDxChPclOamMegLevelModeSet(dev, direction, oamProfile,
                                           megLevelMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                          &megLevelModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamMegLevelModeGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(megLevelMode, megLevelModeGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                   oamProfile [1],
                   megLevelMode [CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_MAC_DA_E].
        */
        oamProfile = 1;
        megLevelMode = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_MAC_DA_E;

        st = cpssDxChPclOamMegLevelModeSet(dev, direction, oamProfile,
                                           megLevelMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                          &megLevelModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamMegLevelModeGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(megLevelMode, megLevelModeGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                      oamProfile [1],
                      megLevelMode [CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_EXP_E].
        */
        megLevelMode = CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_EXP_E;

        st = cpssDxChPclOamMegLevelModeSet(dev, direction, oamProfile,
                                           megLevelMode);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        /*
            1.2. Call cpssDxChPclOamMegLevelModeGet with non-NULL pointers.
            Expected: GT_OK and the same parameters.
        */

        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                          &megLevelModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamMegLevelModeGet: %d", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(megLevelMode, megLevelModeGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            1.3. Call function with out of range direction
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */

        UTF_ENUMS_CHECK_MAC(cpssDxChPclOamMegLevelModeSet
                            (dev, direction, oamProfile, megLevelMode),
                            direction);

        /*
            1.4. Call function with out of range oamProfile [2]
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */
        oamProfile = 2;

        st = cpssDxChPclOamMegLevelModeSet(dev, direction, oamProfile,
                                           megLevelMode);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        oamProfile = 0;

        /*
            1.5. Call function with out of range megLevelMode
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */

        UTF_ENUMS_CHECK_MAC(cpssDxChPclOamMegLevelModeSet
                            (dev, direction, oamProfile, megLevelMode),
                            megLevelMode);
    }

    /*
      2. For not-active devices and devices from non-applicable family
         check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOamMegLevelModeSet(dev, direction, oamProfile,
                                           megLevelMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOamMegLevelModeSet(dev, direction, oamProfile,
                                       megLevelMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOamMegLevelModeGet
(
    IN  GT_U8                                     devNum,
    IN  CPSS_PCL_DIRECTION_ENT                    direction,
    IN  GT_U32                                    oamProfile,
    OUT CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_ENT  *megLevelModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOamMegLevelModeGet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                       CPSS_PCL_DIRECTION_EGRESS_E],
                            oamProfile [0 / 1] and
                            non-NULL pointer.
    Expected: GT_OK.
    1.2. Call function with out of range direction
         and other parameters from 1.1.
    Expected: GT_BAD_PARAM
    1.3. Call function with out of range oamProfile [2]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
    1.4. Call function with megLevelModePtr [NULL].
    Expected: GT_BAD_PTR.

*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    IN  CPSS_PCL_DIRECTION_ENT        direction = CPSS_PCL_DIRECTION_INGRESS_E;
    IN  GT_U32                        oamProfile = 0;
    IN  CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_ENT  megLevelMode =
                                     CPSS_DXCH_PCL_OAM_PKT_MEG_LEVEL_MODE_UDB_E;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                               CPSS_PCL_DIRECTION_EGRESS_E],
                                    oamProfile [0 / 1] and
                                    non-NULL pointer.
            Expected: GT_OK.
        */

        /*
            Call with direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                      oamProfile [0].
        */
        direction  = CPSS_PCL_DIRECTION_INGRESS_E;
        oamProfile = 0;

        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                           &megLevelMode);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                      "cpssDxChPclOamMegLevelModeGet: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_INGRESS_E],
                      oamProfile [1].
        */
        oamProfile = 1;

        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                           &megLevelMode);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                      "cpssDxChPclOamMegLevelModeGet: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                      oamProfile [0].
        */
        direction  = CPSS_PCL_DIRECTION_EGRESS_E;
        oamProfile = 0;

        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                           &megLevelMode);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                      "cpssDxChPclOamMegLevelModeGet: %d", dev);

        /*
            Call with direction  [CPSS_PCL_DIRECTION_EGRESS_E],
                      oamProfile [1].
        */
        oamProfile = 1;

        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                           &megLevelMode);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                      "cpssDxChPclOamMegLevelModeGet: %d", dev);

        /*
            1.2. Call function with out of range direction
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */

        UTF_ENUMS_CHECK_MAC(cpssDxChPclOamMegLevelModeGet
                            (dev, direction, oamProfile, &megLevelMode),
                            direction);

        /*
            1.3. Call function with out of range oamProfile [2]
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */

        oamProfile = 2;

        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                           &megLevelMode);
        UTF_VERIFY_NOT_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, oamProfile);

        oamProfile = 0;

        /*
            1.4. Call function with megLevelModePtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                             "%d, megLevelModePtr = NULL", dev);
    }

    /*
        2. For not-active devices and devices from non-applicable family
           check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                           &megLevelMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOamMegLevelModeGet(dev, direction, oamProfile,
                                       &megLevelMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOamRFlagMatchingSet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        oamProfile,
    IN  GT_U32                        rFlagMask,
    IN  GT_U32                        rFlagPattern
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOamRFlagMatchingSet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with oamProfile [0 / 1],
                            rFlagMask    [0 / 0xA5 / BIT_8-1] and
                            rFlagPattern [0 / 0xA5 / BIT_8-1].
    Expected: GT_OK.
    1.2. Call cpssDxChPclOamRFlagMatchingGet with non-NULL pointers.
    Expected: GT_OK and the same parameters.
    1.3. Call function with out of range oamProfile [2]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
    1.4. Call function with out of range rFlagMask [BIT_8]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
    1.5. Call function with out of range rFlagPattern [BIT_8]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    IN  GT_U32                        oamProfile = 0;
    IN  GT_U32                        rFlagMask = 0;
    IN  GT_U32                        rFlagMaskGet;
    IN  GT_U32                        rFlagPattern = 0;
    IN  GT_U32                        rFlagPatternGet;
    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with oamProfile [0 / 1],
                                    rFlagMask    [0 / 0xA5 / BIT_8-1] and
                                    rFlagPattern [0 / 0xA5 / BIT_8-1]
            Expected: GT_OK.
        */

        /*
            Call with oamProfile [0],
                      rFlagMask    [0],
                      rFlagPattern [0].
        */
        oamProfile = 0;
        rFlagMask    = 0;
        rFlagPattern = 0;

        st = cpssDxChPclOamRFlagMatchingSet(dev, oamProfile, rFlagMask,
                                            rFlagPattern);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamRFlagMatchingGet(dev, oamProfile,
                                            &rFlagMaskGet, &rFlagPatternGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamRFlagMatchingGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(rFlagMask, rFlagMaskGet,
                                 "get another rFlagMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(rFlagPattern, rFlagPatternGet,
                              "get another rFlagPattern than was set: %d", dev);

        /*
            Call with oamProfile [1],
                      rFlagMask    [0xA5],
                      rFlagPattern [0xA5].
        */
        oamProfile = 1;
        rFlagMask    = 0xA5;
        rFlagPattern = 0xA5;

        st = cpssDxChPclOamRFlagMatchingSet(dev, oamProfile, rFlagMask,
                                            rFlagPattern);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, oamProfile);

        /* Verifying values */
        st = cpssDxChPclOamRFlagMatchingGet(dev, oamProfile,
                                            &rFlagMaskGet, &rFlagPatternGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamRFlagMatchingGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(rFlagMask, rFlagMaskGet,
                                 "get another rFlagMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(rFlagPattern, rFlagPatternGet,
                              "get another rFlagPattern than was set: %d", dev);

        /*
            Call with oamProfile [1],
                      rFlagMask    [BIT_8-1],
                      rFlagPattern [BIT_8-1].
        */
        rFlagMask    = BIT_8-1;
        rFlagPattern = BIT_8-1;

        st = cpssDxChPclOamRFlagMatchingSet(dev, oamProfile, rFlagMask,
                                          rFlagPattern);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, oamProfile);

        /*
            1.2. Call cpssDxChPclOamRFlagMatchingGet with non-NULL pointers.
            Expected: GT_OK and the same parameters.
        */

        st = cpssDxChPclOamRFlagMatchingGet(dev, oamProfile,
                                            &rFlagMaskGet, &rFlagPatternGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                         "cpssDxChPclOamRFlagMatchingGet: %d", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(rFlagMask, rFlagMaskGet,
                                 "get another rFlagMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(rFlagPattern, rFlagPatternGet,
                              "get another rFlagPattern than was set: %d", dev);
        /*
            1.3. Call function with out of range oamProfile [2]
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */
        oamProfile = 2;

        st = cpssDxChPclOamRFlagMatchingSet(dev, oamProfile, rFlagMask,
                                          rFlagPattern);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, oamProfile);

        oamProfile = 0;

        /*
            1.4. Call function with out of range rFlagMask [BIT_8]
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */

        rFlagMask = BIT_8;

        st = cpssDxChPclOamRFlagMatchingSet(dev, oamProfile, rFlagMask,
                                          rFlagPattern);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, oamProfile);

        rFlagMask = 0;

        /*
            1.5. Call function with out of range rFlagPattern [BIT_8]
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */

        rFlagPattern = BIT_8;

        st = cpssDxChPclOamRFlagMatchingSet(dev, oamProfile, rFlagMask,
                                            rFlagPattern);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, oamProfile);

        rFlagPattern = 0;
    }

    /*
      2. For not-active devices and devices from non-applicable family
         check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOamRFlagMatchingSet(dev, oamProfile, rFlagMask,
                                            rFlagPattern);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOamRFlagMatchingSet(dev, oamProfile, rFlagMask,
                                        rFlagPattern);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOamRFlagMatchingGet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        oamProfile,
    OUT GT_U32                        *rFlagMaskPtr,
    OUT GT_U32                        *rFlagPatternPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOamRFlagMatchingGet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with oamProfile [0 / 1] and non-NULL pointers.
    Expected: GT_OK.
    1.2. Call function with out of range oamProfile [2]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
    1.3. Call function with rFlagMaskPtr [NULL].
    Expected: GT_BAD_PTR.
    1.4. Call function with rFlagPatternPtr [NULL].
    Expected: GT_BAD_PTR.

*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    IN  GT_U32                        oamProfile = 0;
    IN  GT_U32                        rFlagMask;
    IN  GT_U32                        rFlagPattern;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with oamProfile [0 / 1] and non-NULL pointer.
            Expected: GT_OK.
        */

        /* Call with oamProfile [0]. */
        oamProfile = 0;

        st = cpssDxChPclOamRFlagMatchingGet(dev, oamProfile, &rFlagMask,
                                            &rFlagPattern);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                     "cpssDxChPclOamRFlagMatchingGet: %d", dev);

        /* Call with oamProfile [1]. */
        oamProfile = 1;

        st = cpssDxChPclOamRFlagMatchingGet(dev, oamProfile, &rFlagMask,
                                            &rFlagPattern);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                                     "cpssDxChPclOamRFlagMatchingGet: %d", dev);

        /*
            1.2. Call function with out of range oamProfile [2]
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */

        oamProfile = 2;

        st = cpssDxChPclOamRFlagMatchingGet(dev, oamProfile, &rFlagMask,
                                          &rFlagPattern);
        UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, oamProfile);

        oamProfile = 0;

        /*
            1.3. Call function with rFlagMaskPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclOamRFlagMatchingGet(dev, oamProfile, NULL,
                                            &rFlagPattern);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                                "%d, rFlagMaskPtr = NULL", dev);

        /*
            1.4. Call function with rFlagPatternPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclOamRFlagMatchingGet(dev, oamProfile, &rFlagMask, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                             "%d, rFlagPatternPtr = NULL", dev);
    }

    /*
        2. For not-active devices and devices from non-applicable family
           check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOamRFlagMatchingGet(dev, oamProfile, &rFlagMask,
                                            &rFlagPattern);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOamRFlagMatchingGet(dev, oamProfile, &rFlagMask,
                                        &rFlagPattern);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOamEgressPacketDetectionSet
(
    IN  GT_U8                                     devNum,
    IN  CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_ENT  mode,
    IN  GT_U32                                    sourceId
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOamEgressPacketDetectionSet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with mode [
                              CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_STANDARD_E,
                              CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E],
                            sourceId [0 / 0xA5A / BIT_12-1].
    Expected: GT_OK.
    1.2. Call cpssDxChPclOamEgressPacketDetectionGet with non-NULL pointers.
    Expected: GT_OK and the same parameters.
    1.3. Call function with out of range mode
         and other parameters from 1.1.
    Expected: GT_BAD_PARAM
    1.4. Call function with out of range sourceId [BIT_12]
         and other parameters from 1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    IN  CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_ENT mode =
                                CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_STANDARD_E;
    IN  CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_ENT modeGet =
                                CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_STANDARD_E;
    IN  GT_U32 sourceId = 0;
    IN  GT_U32 sourceIdGet;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with mode [
                              CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_STANDARD_E,
                              CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E],
                                    sourceId [0 / 0xA5A / BIT_12-1].
            Expected: GT_OK.
        */

        /*
            Call with mode [ CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_STANDARD_E],
                      sourceId [0].
        */
        mode = CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_STANDARD_E;
        sourceId = 0;

        st = cpssDxChPclOamEgressPacketDetectionSet(dev, mode, sourceId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* Verifying values */
        st = cpssDxChPclOamEgressPacketDetectionGet(dev, &modeGet,&sourceIdGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                             "cpssDxChPclOamEgressPacketDetectionGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(mode, modeGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(sourceId, sourceIdGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            Call with mode [ CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_STANDARD_E],
                      sourceId [0xA5A].
        */
        sourceId = 0xA5A;

        st = cpssDxChPclOamEgressPacketDetectionSet(dev, mode, sourceId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* Verifying values */
        st = cpssDxChPclOamEgressPacketDetectionGet(dev, &modeGet,&sourceIdGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                             "cpssDxChPclOamEgressPacketDetectionGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(mode, modeGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(sourceId, sourceIdGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            Call with mode [ CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_STANDARD_E],
                      sourceId [BIT_12-1].
        */
        sourceId = BIT_12-1;

        st = cpssDxChPclOamEgressPacketDetectionSet(dev, mode, sourceId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* Verifying values */
        st = cpssDxChPclOamEgressPacketDetectionGet(dev, &modeGet,&sourceIdGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                             "cpssDxChPclOamEgressPacketDetectionGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(mode, modeGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(sourceId, sourceIdGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            Call with mode [ CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E],
                      sourceId [0].
        */
        mode = CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E;
        sourceId = 0;

        st = cpssDxChPclOamEgressPacketDetectionSet(dev, mode, sourceId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* Verifying values */
        st = cpssDxChPclOamEgressPacketDetectionGet(dev, &modeGet,&sourceIdGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                             "cpssDxChPclOamEgressPacketDetectionGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(mode, modeGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(sourceId, sourceIdGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            Call with mode [ CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E],
                      sourceId [0xA5A].
        */
        sourceId = 0xA5A;

        st = cpssDxChPclOamEgressPacketDetectionSet(dev, mode, sourceId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* Verifying values */
        st = cpssDxChPclOamEgressPacketDetectionGet(dev, &modeGet,&sourceIdGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                             "cpssDxChPclOamEgressPacketDetectionGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(mode, modeGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(sourceId, sourceIdGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            Call with mode [ CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_SOURCE_ID_E],
                      sourceId [BIT_12-1].
        */
        sourceId = BIT_12-1;

        st = cpssDxChPclOamEgressPacketDetectionSet(dev, mode, sourceId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*
            1.2. Call cpssDxChPclOamEgressPacketDetectionGet with
                      non-NULL pointers.
            Expected: GT_OK and the same parameters.
        */

        st = cpssDxChPclOamEgressPacketDetectionGet(dev, &modeGet,&sourceIdGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                             "cpssDxChPclOamEgressPacketDetectionGet: %d", dev);

        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(mode, modeGet,
                                   "get another rdiMask than was set: %d", dev);
        UTF_VERIFY_EQUAL1_STRING_MAC(sourceId, sourceIdGet,
                                   "get another rdiMask than was set: %d", dev);

        /*
            1.3. Call function with out of range mode
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */

        UTF_ENUMS_CHECK_MAC(cpssDxChPclOamEgressPacketDetectionSet
                            (dev, mode, sourceId),
                            mode);

        /*
            1.4. Call function with out of range sourceId [BIT_12]
                 and other parameters from 1.1.
            Expected: NOT GT_OK.
        */
        sourceId = BIT_12;

        st = cpssDxChPclOamEgressPacketDetectionSet(dev, mode, sourceId);
        UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        sourceId = 0;
    }

    /*
      2. For not-active devices and devices from non-applicable family
         check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOamEgressPacketDetectionSet(dev, mode, sourceId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOamEgressPacketDetectionSet(dev, mode, sourceId);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclOamEgressPacketDetectionGet
(
    IN  GT_U8                                     devNum,
    OUT CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_ENT  *modePtr,
    OUT GT_U32                                    *sourceIdPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclOamEgressPacketDetectionGet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with non-NULL pointer.
    Expected: GT_OK.
    1.2. Call function with modePtr [NULL].
    Expected: GT_BAD_PTR.
    Expected: NOT GT_OK.
    1.3. Call function with sourceIdPtr [NULL].
    Expected: GT_BAD_PTR.

*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    IN  CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_ENT mode =
                                CPSS_DXCH_PCL_OAM_EGRESS_DETECT_MODE_STANDARD_E;
    IN  GT_U32 sourceId;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call function with non-NULL pointer.
            Expected: GT_OK.
        */

        st = cpssDxChPclOamEgressPacketDetectionGet(dev, &mode, &sourceId);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                             "cpssDxChPclOamEgressPacketDetectionGet: %d", dev);
        /*
            1.2. Call function with modePtr [NULL].
            Expected: GT_BAD_PARAM.
        */
        st = cpssDxChPclOamEgressPacketDetectionGet(dev, NULL, &sourceId);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, modePtr = NULL", dev);

        /*
            1.3. Call function with sourceIdPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclOamEgressPacketDetectionGet(dev, &mode, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                                 "%d, sourceIdPtr = NULL", dev);
    }

    /*
        2. For not-active devices and devices from non-applicable family
           check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclOamEgressPacketDetectionGet(dev, &mode, &sourceId);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclOamEgressPacketDetectionGet(dev, &mode, &sourceId);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}
/*----------------------------------------------------------------------------*/
static GT_VOID prvUtfPclFillUdbSelect
(
    IN  GT_U8                                dev,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum,
    OUT  CPSS_DXCH_PCL_UDB_SELECT_STC         *udbSelectPtr
)
{
    GT_BOOL isEgress;
    GT_U32  udbSel, udbSelValue, replaceIdx;
    GT_BOOL enable;
    GT_U32  maxUDBs;
    GT_U32  maxUdbReplace;

    maxUdbReplace = (PRV_CPSS_SIP_6_10_CHECK_MAC(dev)) ? CPSS_DXCH_PCL_INGRESS_UDB_REPLACE_MAX_CNS : 12;

    if(ruleFormat == CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E)
    {
        isEgress = GT_TRUE;
        /* UDB_60_NO_FIXED_FIELDS shares same entry with UDB_60. Use same value for both. */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E;
    }
    else
    {
        isEgress = ((ruleFormat >= CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E) &&
                    (ruleFormat < CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E))?
                     GT_TRUE : GT_FALSE;
    }

    if (isEgress)
    {
        /* ignore lookup for EPCL. Because EPCL ignors this parameter */
        lookupNum = 0;
    }

    cpssOsMemSet(udbSelectPtr->udbSelectArr, 0, CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS);
    maxUDBs = PRV_CPSS_DXCH_PCL_UDBS_NUM_MAC(dev, isEgress);

    for (udbSel = 0; udbSel < maxUDBs; udbSel++)
    {
        udbSelValue = (ruleFormat + packetType + lookupNum + udbSel) % maxUDBs;
        if(PRV_CPSS_PP_MAC(prvTgfDevNum)->devFamily == CPSS_PP_FAMILY_DXCH_IRONMAN_E &&
           (isEgress || lookupNum == CPSS_PCL_LOOKUP_NUMBER_1_E) )
        {
            udbSelectPtr->udbSelectArr[udbSel] = udbSel;
        }
        else
        {
            udbSelectPtr->udbSelectArr[udbSel] = udbSelValue;
        }
    }

    if (isEgress == GT_FALSE)
    {
        /* ingress case */
        for (replaceIdx = 0; replaceIdx < maxUdbReplace; replaceIdx++)
        {
            udbSelValue = (ruleFormat + packetType + lookupNum + replaceIdx) & 1;
            enable = (udbSelValue)? GT_TRUE : GT_FALSE;
            if ((ruleFormat == CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E) &&
                (packetType == CPSS_DXCH_PCL_PACKET_TYPE_IPV6_UDP_E) &&
                (lookupNum == CPSS_PCL_LOOKUP_0_0_E) )
            {
                /* all bits are TRUE */
                enable = GT_TRUE;
            }
            udbSelectPtr->ingrUdbReplaceArr[replaceIdx] = enable;
        }

        /* configure Egress fields by not valid values */
        udbSelectPtr->egrUdb01Replace = 0x25;
        udbSelectPtr->egrUdbBit15Replace = 0x78;
        if(PRV_CPSS_SIP_6_30_CHECK_MAC(dev))
        {
            udbSelectPtr->keyByteReplacementMode = CPSS_DXCH_PCL_KEY_BYTE_REPLACEMENT_MODE_SRC_DST_EPG_E;
        }
    }
    else
    {
        /* egress case */
        udbSelValue = (ruleFormat + packetType) & 1;
        udbSelectPtr->egrUdb01Replace = (udbSelValue)? GT_TRUE : GT_FALSE;
        udbSelValue = (ruleFormat + packetType + 1) & 1;
        udbSelectPtr->egrUdbBit15Replace = (udbSelValue)? GT_TRUE : GT_FALSE;

        /* configure Ingress fields by not valid values */
        for (replaceIdx = 0; replaceIdx < maxUdbReplace; replaceIdx++)
        {
            udbSelectPtr->ingrUdbReplaceArr[replaceIdx] = 0x52;
        }
    }
}


static GT_BOOL prvUtfPclFillUdbSelectCompare
(
    IN  GT_U8                                dev,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_UDB_SELECT_STC         *udbSelectPtr1,
    IN  CPSS_DXCH_PCL_UDB_SELECT_STC         *udbSelectPtr2
)
{
    GT_BOOL isEgress;
    GT_32   cmpResult;
    GT_U32  ii;
    GT_U32  maxUDBs;
    GT_U32  maxUdbReplace;

    dev = dev;
    isEgress = GT_FALSE;

    maxUdbReplace = (PRV_CPSS_SIP_6_10_CHECK_MAC(dev)) ? CPSS_DXCH_PCL_INGRESS_UDB_REPLACE_MAX_CNS : 12;

    switch (ruleFormat)
    {
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E:
            maxUDBs = 60;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E:
            maxUDBs = 60;
            isEgress = GT_TRUE;
            break;

        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E:
            maxUDBs = ((ruleFormat-CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E)+1) * 10;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E:
            maxUDBs = ((ruleFormat-CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E)+1) * 10;
            isEgress = GT_TRUE;
            break;
        default:
            return GT_BAD_PARAM;
    }


    /* compare common UDB Select array */
    cmpResult = cpssOsMemCmp(udbSelectPtr1->udbSelectArr, udbSelectPtr2->udbSelectArr, maxUDBs);
    if (cmpResult != 0)
    {
        PRV_UTF_LOG0_MAC("FAILED : compare common UDB Select array");

        for(ii = 0 ; ii < (sizeof(udbSelectPtr1->udbSelectArr)/sizeof(udbSelectPtr1->udbSelectArr[0])) ; ii++)
        {
            if(udbSelectPtr1->udbSelectArr[ii] != udbSelectPtr2->udbSelectArr[ii])
            {
                PRV_UTF_LOG3_MAC("FAILED : udbSelectArr[%d] : arr1 value [0x%x] arr2 value [0x%x]",
                    ii,udbSelectPtr1->udbSelectArr[ii] ,udbSelectPtr2->udbSelectArr[ii]);
            }
        }

        return GT_FALSE;
    }

    if (isEgress == GT_FALSE)
    {
        /* ingress case - compare replace array */
        cmpResult = cpssOsMemCmp(udbSelectPtr1->ingrUdbReplaceArr, udbSelectPtr2->ingrUdbReplaceArr, maxUdbReplace);
        if (cmpResult != 0)
        {
            for(ii = 0 ; ii < (sizeof(udbSelectPtr1->ingrUdbReplaceArr)/sizeof(udbSelectPtr1->ingrUdbReplaceArr[0])) ; ii++)
            {
                if(udbSelectPtr1->ingrUdbReplaceArr[ii] != udbSelectPtr2->ingrUdbReplaceArr[ii])
                {
                    PRV_UTF_LOG3_MAC("FAILED : ingrUdbReplaceArr[%d] : arr1 value [0x%x] arr2 value [0x%x]",
                        ii,udbSelectPtr1->ingrUdbReplaceArr[ii] ,udbSelectPtr2->ingrUdbReplaceArr[ii]);
                }
            }


            PRV_UTF_LOG0_MAC("FAILED : ingress case - compare replace array");
            return GT_FALSE;
        }
        if(PRV_CPSS_SIP_6_30_CHECK_MAC(dev))
        {
            if(udbSelectPtr1->keyByteReplacementMode != udbSelectPtr2->keyByteReplacementMode)
            {
                PRV_UTF_LOG0_MAC("FAILED : egress case - compare keyByteReplacementMode");
                return GT_FALSE;
            }
        }
    }
    else
    {
        /* egress case - compare egrUdb01Replace and egrUdbBit15Replace */
        if (udbSelectPtr1->egrUdb01Replace != udbSelectPtr2->egrUdb01Replace)
        {
            PRV_UTF_LOG0_MAC("FAILED : egress case - compare egrUdb01Replace");
            return GT_FALSE;
        }

        if (udbSelectPtr1->egrUdbBit15Replace != udbSelectPtr2->egrUdbBit15Replace)
        {
            PRV_UTF_LOG0_MAC("FAILED : egress case - compare egrUdbBit15Replace");
            return GT_FALSE;
        }
    }
    return GT_TRUE;
}

/*
GT_STATUS cpssDxChPclUserDefinedBytesSelectSet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum,
    IN  CPSS_DXCH_PCL_UDB_SELECT_STC         *udbSelectPtr
);
*/

#define UTF_IPCL_LOOKUPS_CNS 3

UTF_TEST_CASE_MAC(cpssDxChPclUserDefinedBytesSelectSet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with all valid parameters. Fill in whole table.
    Expected: GT_OK.
    1.2. Call Get function and compare output values.
    Expected: GT_OK.
    1.3 Call function with packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E]
    Expected: GT_BAD_PARAM.
    1.4 Call function with udbSelect.udbSelectArr[n] out of range value CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS
    Expected: GT_OUT_OF_RANGE.
    1.5. Call function with out of range ruleFormat
         and other parameters from 1.1.
    Expected: GT_BAD_PARAM.
    1.6. Call function with out of range packetType
         and other parameters from 1.1.
    Expected: GT_BAD_PARAM.
    1.7. Call function with out of range lookupNum
         and other parameters from 1.1.
    Expected: GT_BAD_PARAM.
    1.8. Call function with udbSelectPtr [NULL].
    Expected: GT_BAD_PTR.
    2. For not-active devices and devices from non-applicable family
         check that function returns GT_BAD_PARAM.
    3. Call function with out of bound value for device id.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat;
    CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType;
    CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum;
    CPSS_DXCH_PCL_UDB_SELECT_STC         udbSelect, udbSelectGet;
    GT_U32                               lookupIdx;
    GT_U32                               lookupNumNum;
    CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNumArr[UTF_IPCL_LOOKUPS_CNS]={CPSS_PCL_LOOKUP_0_0_E, CPSS_PCL_LOOKUP_0_1_E, CPSS_PCL_LOOKUP_1_E};
    GT_BOOL                              cmpRes;
    GT_BOOL                              iPcl0Bypass;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;
        lookupNumNum = UTF_IPCL_LOOKUPS_CNS;
        if (iPcl0Bypass)
        {
            lookupNumNum--;
        }

        /*
            1.1. Call function with all valid parameters. Fill in whole table.
            Expected: GT_OK.
        */
        for (ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E;
              ruleFormat <= CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E;
              ruleFormat++)
        {
            if(!PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                if(CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E == ruleFormat || CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E == ruleFormat)
                {
                    continue;
                }
            }
            if(!PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
            {
                if(CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E == ruleFormat)
                {
                    continue;
                }
            }
            else
            {
                if(CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E == ruleFormat)
                {
                    continue;
                }
            }

            for (packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;
                  packetType < CPSS_DXCH_PCL_PACKET_TYPE_LAST_E;
                  packetType++)
            {
                if (packetType == CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E)
                {
                    /* skip not supported packet type */
                    continue;
                }
                for (lookupIdx = 0; lookupIdx < lookupNumNum; lookupIdx++)
                {
                    lookupNum = lookupNumArr[lookupIdx];
                    prvUtfPclFillUdbSelect(dev, ruleFormat, packetType, lookupNum, &udbSelect);
                    st = cpssDxChPclUserDefinedBytesSelectSet(dev,ruleFormat,packetType,lookupNum,&udbSelect);
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, ruleFormat, packetType, lookupNum);

                }
            }
        }

        /*
            1.2. Call Get function and compare output values.
            Expected: GT_OK.
        */
        for (ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E;
             ruleFormat <= CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E;
              ruleFormat++)
        {
            if(!PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                if(CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E == ruleFormat || CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E == ruleFormat)
                {
                    continue;
                }
            }
            if(!PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
            {
                if(CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E == ruleFormat)
                {
                    continue;
                }
            }
            else
            {
                if(CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E == ruleFormat)
                {
                    continue;
                }
            }

            for (packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;
                  packetType < CPSS_DXCH_PCL_PACKET_TYPE_LAST_E;
                  packetType++)
            {
                if (packetType == CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E)
                {
                    /* skip not supported packet type */
                    continue;
                }
                for (lookupIdx = 0; lookupIdx < lookupNumNum; lookupIdx++)
                {
                    lookupNum = lookupNumArr[lookupIdx];
                    prvUtfPclFillUdbSelect(dev, ruleFormat, packetType, lookupNum, &udbSelect);
                    st = cpssDxChPclUserDefinedBytesSelectGet(dev,ruleFormat,packetType,lookupNum,&udbSelectGet);
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, ruleFormat, packetType, lookupNum);


                    /* compare Set and Get parameters */
                    cmpRes = prvUtfPclFillUdbSelectCompare(dev, ruleFormat,&udbSelect, &udbSelectGet);
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_TRUE, cmpRes, dev, ruleFormat, packetType, lookupNum);
                }
            }
        }

        /*
            1.3 Call function with packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E]
            Expected: GT_BAD_PARAM.
        */

        /* set all valid parameters */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E;
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;
        lookupNum = lookupNumArr[0];
        prvUtfPclFillUdbSelect(dev, ruleFormat, packetType, lookupNum, &udbSelect);

        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E;

        st = cpssDxChPclUserDefinedBytesSelectSet(dev,ruleFormat,packetType,lookupNum,&udbSelect);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, packetType, lookupNum);
        /* restore packet type to valid value */
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;

        /*
            1.4 Call function with udbSelect.udbSelectArr[n] out of range value CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS
            Expected: GT_OUT_OF_RANGE.
        */
        udbSelect.udbSelectArr[1] = CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS;
        st = cpssDxChPclUserDefinedBytesSelectSet(dev,ruleFormat,packetType,lookupNum,&udbSelect);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, ruleFormat, packetType, lookupNum);
        /* restore value to acceptable */
        udbSelect.udbSelectArr[1] = 0;

        /*
            1.5. Call function with out of range ruleFormat
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclUserDefinedBytesSelectSet
                            (dev,ruleFormat,packetType,lookupNum,&udbSelect),
                            ruleFormat);

        /*
            1.6. Call function with out of range packetType
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclUserDefinedBytesSelectSet
                            (dev,ruleFormat,packetType,lookupNum,&udbSelect),
                            packetType);

        /*
            1.7. Call function with out of range lookupNum
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclUserDefinedBytesSelectSet
                            (dev,ruleFormat,packetType,lookupNum,&udbSelect),
                            lookupNum);

        /*
            1.8. Call function with udbSelectPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclUserDefinedBytesSelectSet(dev,ruleFormat,packetType,lookupNum,NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                                 "%d, udbSelectPtr = NULL", dev);
    }

    /*
      2. For not-active devices and devices from non-applicable family
         check that function returns GT_BAD_PARAM.
    */

    /* set all valid parameters */
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E;
    packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;
    lookupNum = lookupNumArr[0];

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        prvUtfPclFillUdbSelect(dev, ruleFormat, packetType, lookupNum, &udbSelect);

        st = cpssDxChPclUserDefinedBytesSelectSet(dev,ruleFormat,packetType,lookupNum,&udbSelect);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclUserDefinedBytesSelectSet(dev,ruleFormat,packetType,lookupNum,&udbSelect);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}
/*
GT_STATUS cpssDxChPclUserDefinedBytesSelectGet
(
    IN  GT_U8                                devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat,
    IN  CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum,
    OUT CPSS_DXCH_PCL_UDB_SELECT_STC         *udbSelectPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclUserDefinedBytesSelectGet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call function with all valid parameters. Fill in whole table.
    Expected: GT_OK.
    1.2 Call function with packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E]
    Expected: GT_BAD_PARAM.
    1.3. Call function with out of range ruleFormat
         and other parameters from 1.1.
    Expected: GT_BAD_PARAM.
    1.4. Call function with out of range packetType
         and other parameters from 1.1.
    Expected: GT_BAD_PARAM.
    1.5. Call function with out of range lookupNum
         and other parameters from 1.1.
    Expected: GT_BAD_PARAM.
    1.6. Call function with udbSelectPtr [NULL].
    Expected: GT_BAD_PTR.
    2. For not-active devices and devices from non-applicable family
         check that function returns GT_BAD_PARAM.
    3. Call function with out of bound value for device id.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp = 0;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT   ruleFormat;
    CPSS_DXCH_PCL_PACKET_TYPE_ENT        packetType;
    CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNum;
    CPSS_DXCH_PCL_UDB_SELECT_STC         udbSelectGet;
    GT_U32                               lookupIdx;
    GT_U32                               lookupNumNum;
    CPSS_PCL_LOOKUP_NUMBER_ENT           lookupNumArr[UTF_IPCL_LOOKUPS_CNS]={CPSS_PCL_LOOKUP_0_0_E, CPSS_PCL_LOOKUP_0_1_E, CPSS_PCL_LOOKUP_1_E};
    GT_BOOL                              iPcl0Bypass;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;
        lookupNumNum = UTF_IPCL_LOOKUPS_CNS;
        if (iPcl0Bypass)
        {
            lookupNumNum--;
        }

        /*
            1.1. Call function with all valid parameters. Check whole table.
            Expected: GT_OK.
        */
        for (ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E;
              ruleFormat <= CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E;
              ruleFormat++)
        {

            if(!PRV_CPSS_SIP_6_10_CHECK_MAC(dev))
            {
                if(CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_NO_FIXED_FIELDS_E == ruleFormat || CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E == ruleFormat)
                {
                    continue;
                }
            }
            if(!PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
            {
                if(CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E == ruleFormat)
                {
                    continue;
                }
            }

            for (packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;
                  packetType < CPSS_DXCH_PCL_PACKET_TYPE_LAST_E;
                  packetType++)
            {
                if (packetType == CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E)
                {
                    /* skip not supported packet type */
                    continue;
                }
                for (lookupIdx = 0; lookupIdx < lookupNumNum; lookupIdx++)
                {
                    lookupNum = lookupNumArr[lookupIdx];
                    st = cpssDxChPclUserDefinedBytesSelectGet(dev,ruleFormat,packetType,lookupNum,&udbSelectGet);
                    UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, ruleFormat, packetType, lookupNum);
                }
            }
        }

        /*
            1.2 Call function with packetType [CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E]
            Expected: GT_BAD_PARAM.
        */

        /* set all valid parameters */
        ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E;
        lookupNum = lookupNumArr[0];

        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E;

        st = cpssDxChPclUserDefinedBytesSelectGet(dev,ruleFormat,packetType,lookupNum,&udbSelectGet);
        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_BAD_PARAM, st, dev, ruleFormat, packetType, lookupNum);
        /* restore packet type to valid value */
        packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;

        /*
            1.3. Call function with out of range ruleFormat
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclUserDefinedBytesSelectGet
                            (dev,ruleFormat,packetType,lookupNum,&udbSelectGet),
                            ruleFormat);

        /*
            1.4. Call function with out of range packetType
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclUserDefinedBytesSelectGet
                            (dev,ruleFormat,packetType,lookupNum,&udbSelectGet),
                            packetType);

        /*
            1.5. Call function with out of range lookupNum
                 and other parameters from 1.1.
            Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclUserDefinedBytesSelectGet
                            (dev,ruleFormat,packetType,lookupNum,&udbSelectGet),
                            lookupNum);

        /*
            1.6. Call function with udbSelectPtr [NULL].
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclUserDefinedBytesSelectGet(dev,ruleFormat,packetType,lookupNum,NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st,
                                                 "%d, udbSelectPtr = NULL", dev);
    }

    /*
      2. For not-active devices and devices from non-applicable family
         check that function returns GT_BAD_PARAM.
    */

    /* set all valid parameters */
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E;
    packetType = CPSS_DXCH_PCL_PACKET_TYPE_IPV4_TCP_E;
    lookupNum = lookupNumArr[0];

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclUserDefinedBytesSelectGet(dev,ruleFormat,packetType,lookupNum,&udbSelectGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclUserDefinedBytesSelectGet(dev,ruleFormat,packetType,lookupNum,&udbSelectGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}
/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressSourcePortSelectionModeSet
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ENT portSelectionMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressSourcePortSelectionModeSet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call with portSelectionMode [CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ORIGINAL_E/
                                      CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_LOCAL_E]
    Expected: GT_OK.
    1.2. Call cpssDxChPclEgressSourcePortSelectionModeGet with non-NULL pointers
                                                          other params same as in 1.1.
    Expected: GT_OK and the same values.
    1.3. Call with out of range portSelectionMode [wrong enum values],
                     other params same as in 1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS               st;
    GT_U8                   dev;
    CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ENT portSelectionMode;
    CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ENT portSelectionModeGet;
    GT_U32                  notAppFamilyBmp;

    /* this feature is on eArch devices - SIP5, but not SIP6 */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);
    UTF_SIP6_ADD_TO_FAMILY_BMP_MAC(notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with portSelectionMode [CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ORIGINAL_E]
            Expected: GT_OK.
        */
        portSelectionMode = CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ORIGINAL_E;

        st = cpssDxChPclEgressSourcePortSelectionModeSet(dev, portSelectionMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portSelectionMode);

        /*
            1.2. Call cpssDxChPclEgressSourcePortSelectionModeGet
            with non-NULL pointers other params same as in 1.1.
            Expected: GT_OK and the same values.
        */
        st = cpssDxChPclEgressSourcePortSelectionModeGet(dev, &portSelectionModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxChPclEgressSourcePortSelectionModeGet: %d", dev);

        /* validation values */
        UTF_VERIFY_EQUAL1_STRING_MAC(portSelectionMode, portSelectionModeGet,
                   "got another portSelectionMode then was set: %d", dev);

        /*
            1.1. Call with portSelectionMode [CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_LOCAL_E]
            Expected: GT_OK.
        */
        portSelectionMode = CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_LOCAL_E;

        st = cpssDxChPclEgressSourcePortSelectionModeSet(dev, portSelectionMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portSelectionMode);

        /*
            1.2. Call cpssDxChPclEgressSourcePortSelectionModeGet
                    with non-NULL pointers other params same as in 1.1.
            Expected: GT_OK and the same values.
        */
        st = cpssDxChPclEgressSourcePortSelectionModeGet(dev, &portSelectionModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxChPclEgressSourcePortSelectionModeGet: %d", dev);

        /* validation values */
        UTF_VERIFY_EQUAL1_STRING_MAC(portSelectionMode, portSelectionModeGet,
                   "got another portSelectionMode then was set: %d", dev);

        /*
            1.3. Call with out of range portSelectionMode [wrong enum values],
                           other params same as in 1.1.
            Expected: NOT GT_OK.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclEgressSourcePortSelectionModeSet
                            (dev, portSelectionMode),
                            portSelectionMode);
    }

    portSelectionMode = CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ORIGINAL_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressSourcePortSelectionModeSet(dev, portSelectionMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressSourcePortSelectionModeSet(dev, portSelectionMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressSourcePortSelectionModeGet
(
    IN  GT_U8                                               devNum,
    OUT CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ENT *portSelectionModePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressSourcePortSelectionModeGet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call with non NULL portSelectionModePtr.
    Expected: GT_OK.
    1.2. Call with portSelectionModePtr [NULL],
                   other params same as in 1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS               st;
    GT_U8                   dev;
    CPSS_DXCH_PCL_EGRESS_SOURCE_PORT_SELECTION_MODE_ENT portSelectionMode;
    GT_U32                  notAppFamilyBmp;

    /* this feature is on eArch devices - SIP5, but not SIP6 */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);
    UTF_SIP6_ADD_TO_FAMILY_BMP_MAC(notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with non NULL portSelectionModePtr.
            Expected: GT_OK.
        */
        st = cpssDxChPclEgressSourcePortSelectionModeGet(dev, &portSelectionMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portSelectionMode);

        /*
            1.2. Call with portSelectionModePtr [NULL],
                           other params same as in 1.1.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclEgressSourcePortSelectionModeGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, portSelectionModePtr = NULL", dev);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressSourcePortSelectionModeGet(dev, &portSelectionMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressSourcePortSelectionModeGet(dev, &portSelectionMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}
/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressTargetPortSelectionModeSet
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_ENT portSelectionMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressTargetPortSelectionModeSet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call with portSelectionMode [CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_LOCAL_E/
                                       CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_FINAL_E]
    Expected: GT_OK.
    1.2. Call cpssDxChPclEgressTargetPortSelectionModeGet with non-NULL pointers
                                                          other params same as in 1.1.
    Expected: GT_OK and the same values.
    1.3. Call with out of range portSelectionMode [wrong enum values],
                     other params same as in 1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS               st;
    GT_U8                   dev;
    CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_ENT portSelectionMode;
    CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_ENT portSelectionModeGet;
    GT_U32                  notAppFamilyBmp;

    /* this feature is on eArch devices - SIP5, but not SIP6 */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);
    UTF_SIP6_ADD_TO_FAMILY_BMP_MAC(notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with portSelectionMode [CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_LOCAL_E]
            Expected: GT_OK.
        */
        portSelectionMode = CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_LOCAL_E;

        st = cpssDxChPclEgressTargetPortSelectionModeSet(dev, portSelectionMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portSelectionMode);

        /*
            1.2. Call cpssDxChPclEgressTargetPortSelectionModeGet
            with non-NULL pointers other params same as in 1.1.
            Expected: GT_OK and the same values.
        */
        st = cpssDxChPclEgressTargetPortSelectionModeGet(dev, &portSelectionModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxChPclEgressTargetPortSelectionModeGet: %d", dev);

        /* validation values */
        UTF_VERIFY_EQUAL1_STRING_MAC(portSelectionMode, portSelectionModeGet,
                   "got another portSelectionMode then was set: %d", dev);

        /*
            1.1. Call with portSelectionMode [CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_FINAL_E]
            Expected: GT_OK.
        */
        portSelectionMode = CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_FINAL_E;

        st = cpssDxChPclEgressTargetPortSelectionModeSet(dev, portSelectionMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portSelectionMode);

        /*
            1.2. Call cpssDxChPclEgressTargetPortSelectionModeGet
                    with non-NULL pointers other params same as in 1.1.
            Expected: GT_OK and the same values.
        */
        st = cpssDxChPclEgressTargetPortSelectionModeGet(dev, &portSelectionModeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                   "cpssDxChPclEgressTargetPortSelectionModeGet: %d", dev);

        /* validation values */
        UTF_VERIFY_EQUAL1_STRING_MAC(portSelectionMode, portSelectionModeGet,
                   "got another portSelectionMode then was set: %d", dev);

        /*
            1.3. Call with out of range portSelectionMode [wrong enum values],
                           other params same as in 1.1.
            Expected: NOT GT_OK.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclEgressTargetPortSelectionModeSet
                            (dev, portSelectionMode),
                            portSelectionMode);
    }

    portSelectionMode = CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_LOCAL_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressTargetPortSelectionModeSet(dev, portSelectionMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressTargetPortSelectionModeSet(dev, portSelectionMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressTargetPortSelectionModeGet
(
    IN  GT_U8                                           devNum,
    OUT CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_ENT
                                                        *portSelectionModePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressTargetPortSelectionModeGet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call with non NULL portSelectionModePtr.
    Expected: GT_OK.
    1.2. Call with portSelectionModePtr [NULL],
                   other params same as in 1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS               st;
    GT_U8                   dev;
    CPSS_DXCH_PCL_EGRESS_TARGET_PORT_SELECTION_MODE_ENT portSelectionMode;
    GT_U32                  notAppFamilyBmp;

    /* this feature is on eArch devices - SIP5, but not SIP6 */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);
    UTF_SIP6_ADD_TO_FAMILY_BMP_MAC(notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with non NULL portSelectionModePtr.
            Expected: GT_OK.
        */
        st = cpssDxChPclEgressTargetPortSelectionModeGet(dev, &portSelectionMode);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, portSelectionMode);

        /*
            1.2. Call with portSelectionModePtr [NULL],
                           other params same as in 1.1.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclEgressTargetPortSelectionModeGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, portSelectionModePtr = NULL", dev);
    }

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressTargetPortSelectionModeGet(dev, &portSelectionMode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressTargetPortSelectionModeGet(dev, &portSelectionMode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclSourceIdMaskSet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum,
    IN  GT_U32                      mask
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclSourceIdMaskSet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E/
                              CPSS_PCL_LOOKUP_0_0_E/
                              CPSS_PCL_LOOKUP_0_1_E]
               and mask[0, 15, 31, 32]
    Expected: GT_OK and GT_OUT_OF_RANGE
    1.2. Call cpssDxChPclSourceIdMaskGet with non-NULL pointers
                                     other params same as in 1.1.
    Expected: GT_OK and the same values.
    1.3. Call with out of range lookupNum [wrong enum values],
                     other params same as in 1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS               st;
    GT_U8                   dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNumArr[] = {CPSS_PCL_LOOKUP_1_E, CPSS_PCL_LOOKUP_0_0_E, CPSS_PCL_LOOKUP_0_1_E};
    GT_U32                  ii, kk;
    GT_U32                  maskArr[] =  {    0,    2111,    4095,              4096};
    GT_STATUS               expectRc[] = {GT_OK, GT_OK, GT_OK, GT_OUT_OF_RANGE};
    GT_U32                  maskGet;
    GT_U32                  notAppFamilyBmp;
    GT_U32                  iPcl0Bypass;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;

        /*
            1.1. Call with lookupNum [CPSS_PCL_LOOKUP_1_E/
                                      CPSS_PCL_LOOKUP_0_0_E/
                                      CPSS_PCL_LOOKUP_0_1_E]
                       and mask[0, 15, 31, 32]
            Expected: GT_OK and GT_OUT_OF_RANGE
        */
        for (ii = iPcl0Bypass; ii < sizeof(lookupNumArr)/sizeof(lookupNumArr[0]); ii++)
        {
            lookupNum = lookupNumArr[ii];
            for (kk = 0; kk < sizeof(maskArr)/sizeof(maskArr[0]); kk++)
            {
                st = cpssDxChPclSourceIdMaskSet(dev, lookupNum, maskArr[kk]);
                UTF_VERIFY_EQUAL3_PARAM_MAC(expectRc[kk], st, dev, lookupNum, maskArr[kk]);
                if (st == GT_OK)
                {
                    /*
                     1.2 Get value and compare with set one.
                    */
                    st = cpssDxChPclSourceIdMaskGet(dev, lookupNum, &maskGet);
                    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, lookupNum);

                    /* validation values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(maskArr[kk], maskGet,
                               "got another mask then was set: %d", maskArr[kk]);
                }
            }
        }

        /*
            1.3. Call with out of range lookupNum [wrong enum values],
                           other params same as in 1.1.
            Expected: NOT GT_OK.
        */
        kk = 0;
        lookupNum = lookupNumArr[0];
        UTF_ENUMS_CHECK_MAC(cpssDxChPclSourceIdMaskSet
                            (dev, lookupNum, maskArr[kk]),
                            lookupNum);
    }

    kk = 0;
    lookupNum = lookupNumArr[0];

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclSourceIdMaskSet(dev, lookupNum, maskArr[kk]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclSourceIdMaskSet(dev, lookupNum, maskArr[kk]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}
/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclSourceIdMaskGet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum,
    OUT GT_U32                      *maskPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclSourceIdMaskGet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call with non NULL maskPtr.
    Expected: GT_OK.
    1.2. Call with out of range lookupNum [wrong enum values],
                       other params same as in 1.1.
        Expected: NOT GT_OK.
    1.3. Call with maskPtr [NULL],
                   other params same as in 1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS               st;
    GT_U8                   dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum;
    GT_U32                  mask;
    GT_U32                  notAppFamilyBmp;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with non NULL maskPtr.
            Expected: GT_OK.
        */
        lookupNum = CPSS_PCL_LOOKUP_0_0_E;
        st = cpssDxChPclSourceIdMaskGet(dev, lookupNum, &mask);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, mask);

        /*
            1.2. Call with out of range lookupNum [wrong enum values],
                           other params same as in 1.1.
            Expected: NOT GT_OK.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclSourceIdMaskGet
                            (dev, lookupNum, &mask),
                            lookupNum);
        /*
            1.3. Call with maskPtr [NULL],
                           other params same as in 1.1.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclSourceIdMaskGet(dev, lookupNum, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, maskPtr = NULL", dev);
    }

    lookupNum = CPSS_PCL_LOOKUP_0_0_E;

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclSourceIdMaskGet(dev, lookupNum, &mask);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclSourceIdMaskGet(dev, lookupNum, &mask);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortListPortMappingSet
(
    IN  GT_U8                   devNum,
    IN  CPSS_PCL_DIRECTION_ENT  direction,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    IN  GT_BOOL                 enable,
    IN  GT_U32                  group,
    IN  GT_U32                  offset
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortListPortMappingSet)
{
/*
    ITERATE_DEVICES_PHY_PORTS (Bobcat2, Caelum, Bobcat3)
    1.1.1. Call with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                CPSS_PCL_DIRECTION_EGRESS_E],
                     enable [GT_FALSE / GT_TRUE],
                     group  [0 / 0xA / BIT_4-1],
                     offset [0 / 0x1A / 27].
    Expected: GT_OK
    1.1.2. Call cpssDxChPclPortListPortMappingGet with non-NULL pointers.
    Expected: GT_OK and the same parameters.
    1.1.3. Call function with out of range direction
           and other parameters from 1.1.
    Expected: NOT GT_OK.
    1.1.4. Call function with out of range group [BIT_4]
           and other parameters from 1.1.1.
    Expected: NOT GT_OK.
    1.1.5. Call function with out of range offset [28]
           and other parameters from 1.1.1.
    Expected: NOT GT_OK.
*/
    GT_STATUS               st = GT_OK;
    GT_U8                   dev;
    GT_U32                  notAppFamilyBmp = 0;
    GT_PORT_NUM             port = 0;
    CPSS_PCL_DIRECTION_ENT  direction = CPSS_PCL_DIRECTION_INGRESS_E;
    GT_BOOL                 enable = GT_FALSE;
    GT_BOOL                 enableGet;
    GT_U32                  group = 0;
    GT_U32                  groupGet;
    GT_U32                  offset = 0;
    GT_U32                  offsetGet;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports. */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1. Call with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                            CPSS_PCL_DIRECTION_EGRESS_E],
                                 enable [GT_FALSE / GT_TRUE],
                                 group  [0 / 0xA / BIT_4-1],
                                 offset [0 / 0x1A / 27].
                Expected: GT_OK
            */

            /*
               call with direction [CPSS_PCL_DIRECTION_INGRESS_E]
                         enable [GT_FALSE]
                         group  [0]
                         offset [0]
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            enable = GT_FALSE;
            group  = 0;
            offset = 0;

            st = cpssDxChPclPortListPortMappingSet(dev, direction, port, enable,
                                                   group, offset);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);

            /*
               call with direction [CPSS_PCL_DIRECTION_INGRESS_E]
                         enable [GT_FALSE]
                         group  [0]
                         offset [0]
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            enable = GT_TRUE;
            group  = 0;
            offset = 0;

            st = cpssDxChPclPortListPortMappingSet(dev, direction, port, enable,
                                                   group, offset);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);

            /* verify values */
            st = cpssDxChPclPortListPortMappingGet(dev, direction, port,
                                             &enableGet, &groupGet, &offsetGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);

            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                                    "get another enable than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(group, groupGet,
                                    "get another group than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                                    "get another offset than was set: %d", dev);
            /*
               call with direction [CPSS_PCL_DIRECTION_INGRESS_E]
                         enable [GT_TRUE]
                         group  [0xA]
                         offset [0x1A]
            */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            enable = GT_TRUE;
            group  = 0xA;
            offset = 0x1A;

            st = cpssDxChPclPortListPortMappingSet(dev, direction, port, enable,
                                                   group, offset);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);

            /* verify values */
            st = cpssDxChPclPortListPortMappingGet(dev, direction, port,
                                             &enableGet, &groupGet, &offsetGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);

            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                                    "get another enable than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(group, groupGet,
                                    "get another group than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                                    "get another offset than was set: %d", dev);
            /*
               call with direction [CPSS_PCL_DIRECTION_EGRESS_E]
                         enable [GT_TRUE]
                         group  [BIT_4-1]
                         offset [27]
            */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            enable = GT_TRUE;
            group  = BIT_4-1;
            offset = 27;

            st = cpssDxChPclPortListPortMappingSet(dev, direction, port, enable,
                                                   group, offset);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);

            /*
                1.1.2. Call cpssDxChPclPortListPortMappingGet with
                       non-NULL pointers.
                Expected: GT_OK and the same parameters.
            */

            /* verify values */
            st = cpssDxChPclPortListPortMappingGet(dev, direction, port,
                                             &enableGet, &groupGet, &offsetGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);

            UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                                    "get another enable than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(group, groupGet,
                                    "get another group than was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(offset, offsetGet,
                                    "get another offset than was set: %d", dev);

            /*
                1.1.3. Call function with out of range direction
                       and other parameters from 1.1.
                Expected: NOT GT_OK.
            */
                UTF_ENUMS_CHECK_MAC(cpssDxChPclPortListPortMappingSet
                                  (dev, direction, port, enable, group, offset),
                                    direction);

                direction = CPSS_PCL_DIRECTION_INGRESS_E;
            /*
                1.1.4. Call function with out of range group [BIT_4]
                       and other parameters from 1.1.
                Expected: NOT GT_OK.
            */
            group = BIT_4;

            st = cpssDxChPclPortListPortMappingSet(dev, direction, port, enable,
                                                   group, offset);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);

            group = 0;
            /*
                1.1.5. Call function with out of range offset [28]
                       and other parameters from 1.1.
                Expected: NOT GT_OK.
            */
            offset = 28;

            st = cpssDxChPclPortListPortMappingSet(dev, direction, port, enable,
                                                   group, offset);
            UTF_VERIFY_NOT_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);

            offset = 0;
        }

        /* restore valid values */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;

        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*
            1.2. For all active devices go over all non available physical ports
        */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_FALSE))
        {
            /* 1.2.1. Call function for each non-active port */
            st = cpssDxChPclPortListPortMappingSet(dev, direction, port, enable,
                                                   group, offset);
            if(IS_E_ARCH_AND_PHYSICAL_PORT_IN_RANGE_MAC(dev,port))
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);
            }
            else
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
            }
        }

        /*
            1.3. For active device check that function returns GT_BAD_PARAM
                 for out of bound value for port number.
        */
        port = UTF_CPSS_PP_MAX_PORT_NUM_CNS(dev);

        st = cpssDxChPclPortListPortMappingSet(dev, direction, port, enable,
                                               group, offset);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);

        /*
            1.4. For active device check that function returns GT_OK
                 for CPU port number.
        */
        port = CPSS_CPU_PORT_NUM_CNS;

        st = cpssDxChPclPortListPortMappingSet(dev, direction, port, enable,
                                               group, offset);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);
    }

    /* restore valid values */
    port = DXCH_PCL_VALID_PHY_PORT_CNS;
    direction = CPSS_PCL_DIRECTION_INGRESS_E;

    /*
        2. For not-active devices and devices from non-applicable family
           check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortListPortMappingSet(dev, direction, port, enable,
                                               group, offset);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortListPortMappingSet(dev, direction, port, enable, group,
                                           offset);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortListPortMappingGet
(
    IN  GT_U8                   devNum,
    IN  CPSS_PCL_DIRECTION_ENT  direction,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_BOOL                 *enablePtr,
    OUT GT_U32                  *groupPtr,
    OUT GT_U32                  *offsetPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortListPortMappingGet)
{
/*
    ITERATE_DEVICES_PHY_PORTS (Bobcat2, Caelum, Bobcat3)
    1.1.1. Call with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                CPSS_PCL_DIRECTION_EGRESS_E],
                     and non-NULL pointers.
    Expected: GT_OK
    1.1.2. Call function with out of range direction
           and other parameters from 1.1.
    1.1.3. Call function with enablePtr [NULL] and other non-NULL pointers.
    Expected: GT_BAD_PTR.
    1.1.4. Call function with groupPtr [NULL] and other non-NULL pointers.
    Expected: GT_BAD_PTR.
    1.1.5. Call function with offsetPtr [NULL] and other non-NULL pointers.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS               st = GT_OK;
    GT_U8                   dev;
    GT_U32                  notAppFamilyBmp = 0;
    GT_PORT_NUM             port = 0;
    CPSS_PCL_DIRECTION_ENT  direction = CPSS_PCL_DIRECTION_INGRESS_E;
    GT_BOOL                 enablePtr;
    GT_U32                  groupPtr;
    GT_U32                  offsetPtr;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports. */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1.1. Call with direction [CPSS_PCL_DIRECTION_INGRESS_E /
                                            CPSS_PCL_DIRECTION_EGRESS_E],
                                 and non-NULL pointers.
                Expected: GT_OK
            */
            /* call with direction [CPSS_PCL_DIRECTION_INGRESS_E] */
            direction = CPSS_PCL_DIRECTION_INGRESS_E;
            st = cpssDxChPclPortListPortMappingGet(dev, direction, port,
                                             &enablePtr, &groupPtr, &offsetPtr);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);

            /* call with direction [CPSS_PCL_DIRECTION_EGRESS_E] */
            direction = CPSS_PCL_DIRECTION_EGRESS_E;
            st = cpssDxChPclPortListPortMappingGet(dev, direction, port,
                                             &enablePtr, &groupPtr, &offsetPtr);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);

            /*
                1.1.2. Call function with out of range direction
                       and other parameters from 1.1.
                Expected: NOT GT_OK.
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortListPortMappingGet
                                (dev, direction, port, &enablePtr, &groupPtr,
                                &offsetPtr),
                                direction);
            direction = CPSS_PCL_DIRECTION_INGRESS_E;

            /*
                1.1.3. Call function with enablePtr [NULL]
                       and other non-NULL pointers.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortListPortMappingGet(dev, direction, port, NULL,
                                                   &groupPtr, &offsetPtr);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PTR, st,
                                         "%d, %d, enablePtr = NULL", dev, port);

            /*
                1.1.4. Call function with groupPtr [NULL]
                       and other non-NULL pointers.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortListPortMappingGet(dev, direction, port,
                                                  &enablePtr, NULL, &offsetPtr);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PTR, st,
                                          "%d, %d, groupPtr = NULL", dev, port);

            /*
                1.1.5. Call function with offsetPtr [NULL]
                       and other non-NULL pointers.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortListPortMappingGet(dev, direction, port,
                                                   &enablePtr, &groupPtr, NULL);
            UTF_VERIFY_EQUAL2_STRING_MAC(GT_BAD_PTR, st,
                                         "%d, %d, offsetPtr = NULL", dev, port);
        }

        /* restore valid values */
        direction = CPSS_PCL_DIRECTION_EGRESS_E;

        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /*
            1.2. For all active devices go over all non available physical ports
        */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_FALSE))
        {
            /* 1.2.1. Call function for each non-active port */
            st = cpssDxChPclPortListPortMappingGet(dev, direction, port,
                                             &enablePtr, &groupPtr, &offsetPtr);
            if(IS_E_ARCH_AND_PHYSICAL_PORT_IN_RANGE_MAC(dev,port))
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);
            }
            else
            {
                UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
            }
        }

        /*
            1.3. For active device check that function returns GT_BAD_PARAM
                 for out of bound value for port number.
        */
        port = UTF_CPSS_PP_MAX_PORT_NUM_CNS(dev);

        st = cpssDxChPclPortListPortMappingGet(dev, direction, port, &enablePtr,
                                               &groupPtr, &offsetPtr);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);

        /*
            1.4. For active device check that function returns GT_OK
                 for CPU port number.
        */
        port = CPSS_CPU_PORT_NUM_CNS;

        st = cpssDxChPclPortListPortMappingGet(dev, direction, port, &enablePtr,
                                               &groupPtr, &offsetPtr);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, port);
    }

    /* restore valid values */
    port = DXCH_PCL_VALID_PHY_PORT_CNS;
    direction = CPSS_PCL_DIRECTION_INGRESS_E;

    /*
        2. For not-active devices and devices from non-applicable family
           check that function returns GT_BAD_PARAM.
    */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* Go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortListPortMappingGet(dev, direction, port, &enablePtr,
                                               &groupPtr, &offsetPtr);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id    */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortListPortMappingGet(dev, direction, port, &enablePtr,
                                           &groupPtr, &offsetPtr);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}



/*----------------------------------------------------------------------------*/
UTF_TEST_CASE_MAC(cpssDxChPclIpPayloadMinSizeSet)
{
/*
    ITERATE_DEVICES
    1.1. Call cpssDxChPclSourceIdBitsOverrideSet with relevant value
              ipPayloadMinSize[0/8191/16383].
    Expected: GT_OK.
    1.2. Call cpssDxChPclSourceIdBitsOverrideGet.
    Expected: GT_OK and the same ipPayloadMinSize.
    1.3. Call with out of range ipPayloadMinSize[16384].
    Expected: NOT GT_OK.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;

    GT_U32      ipPayloadMinSize = 0;
    GT_U32      ipPayloadMinSizeGet = 0;


    GT_U32      notAppFamilyBmp;
    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*  1.1.  */
        ipPayloadMinSize = 0;

        st = cpssDxChPclIpPayloadMinSizeSet(dev, ipPayloadMinSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*  1.2.  */
        st = cpssDxChPclIpPayloadMinSizeGet(dev, &ipPayloadMinSizeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
        "cpssDxChPclIpPayloadMinSizeGet: %d", dev);
        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(ipPayloadMinSize, ipPayloadMinSizeGet,
                   "get another ipPayloadMinSize than was set: %d", dev);

        /*  1.1.  */
        ipPayloadMinSize = 8191;

        st = cpssDxChPclIpPayloadMinSizeSet(dev, ipPayloadMinSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*  1.2.  */
        st = cpssDxChPclIpPayloadMinSizeGet(dev, &ipPayloadMinSizeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
        "cpssDxChPclIpPayloadMinSizeGet: %d", dev);
        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(ipPayloadMinSize, ipPayloadMinSizeGet,
                   "get another ipPayloadMinSize than was set: %d", dev);

        /*  1.1.  */
        ipPayloadMinSize = 16383;

        st = cpssDxChPclIpPayloadMinSizeSet(dev, ipPayloadMinSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*  1.2.  */
        st = cpssDxChPclIpPayloadMinSizeGet(dev, &ipPayloadMinSizeGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
        "cpssDxChPclIpPayloadMinSizeGet: %d", dev);
        /* Verifying values */
        UTF_VERIFY_EQUAL1_STRING_MAC(ipPayloadMinSize, ipPayloadMinSizeGet,
                   "get another ipPayloadMinSize than was set: %d", dev);

        /*  1.3.  */
        ipPayloadMinSize = 16384;

        st = cpssDxChPclIpPayloadMinSizeSet(dev, ipPayloadMinSize);
        UTF_VERIFY_NOT_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        ipPayloadMinSize = 0;
    }

    ipPayloadMinSize = 0;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclIpPayloadMinSizeSet(dev, ipPayloadMinSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclIpPayloadMinSizeSet(dev, ipPayloadMinSize);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
UTF_TEST_CASE_MAC(cpssDxChPclIpPayloadMinSizeGet)
{
/*
    ITERATE_DEVICES
    1.1. Call cpssDxChPclIpPayloadMinSizeSet with not NULL ipPayloadMinSizePtr.
    Expected: GT_OK.
    1.3. Call with NULL ipPayloadMinSizePtr.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS   st = GT_OK;
    GT_U8       dev;
    GT_U32      ipPayloadMinSize = 0;

    GT_U32      notAppFamilyBmp;
    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. Go over all active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*  1.1.  */
        st = cpssDxChPclIpPayloadMinSizeGet(dev, &ipPayloadMinSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /*  1.2.  */
        st = cpssDxChPclIpPayloadMinSizeGet(dev, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclIpPayloadMinSizeGet(dev, &ipPayloadMinSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclIpPayloadMinSizeGet(dev, &ipPayloadMinSize);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet
(
    IN  GT_U8                         devNum,
    IN  GT_BOOL                       enable
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call with  enable [GT_TRUE / GT_FALSE]
    Expected: GT_OK.
    1.2 Call cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet
        with non-NULL enableGet.
    Expected: GT_OK and the same enableGet.
    2. Call for for not-active devices or devices from non-applicable family
    Expected: GT_NOT_APPLICABLE_DEVICE.
    3. Call with out of bound value for device id.
    Expected: GT_BAD_PARAM.
*/
    GT_STATUS   st;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp;
    GT_BOOL     enable    = GT_FALSE;
    GT_BOOL     enableGet = GT_FALSE;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* call with enable = GT_TRUE */

        /* 1.1.*/
        enable = GT_TRUE;

        st = cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet(dev, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /* 1.2 */
        st = cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                "cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                "get another enable than was set: %d", dev);

        /* call with enable = GT_FALSE */

        /* 1.1.*/
        enable = GT_FALSE;

        st = cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet(dev, enable);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, enable);

        /* 1.2 */
        st = cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet(dev, &enableGet);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                "cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet: %d", dev);

        UTF_VERIFY_EQUAL1_STRING_MAC(enable, enableGet,
                "get another enable than was set: %d", dev);
    }

    enable = GT_TRUE;

    /* 2. */
    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet(dev, enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet(dev, enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet
(
    IN  GT_U8                         devNum,
    OUT GT_BOOL                       *enablePtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet)
{
/*
    ITERATE_DEVICES (Bobcat2, Caelum, Bobcat3)
    1.1. Call with non-NULL enablePtr
    Expected: GT_OK.
    1.2 Call with enablePtr [NULL];
    Expected: GT_BAD_PTR.
    2. Call for for not-active devices or devices from non-applicable family
    Expected: GT_NOT_APPLICABLE_DEVICE.
    3. Call with out of bound value for device id.
    Expected: GT_BAD_PARAM.

*/

    GT_STATUS   st;
    GT_U8       dev;
    GT_U32      notAppFamilyBmp;
    GT_BOOL     enable    = GT_FALSE;

    /* this feature is on eArch devices */
    UTF_E_ARCH_NOT_SUPPORTED_FAMILY_GET_MAC(&notAppFamilyBmp);

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* 1. go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* 1.1. */
        st = cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* 1.2 */
        st = cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet(dev, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, enablePtr = NULL", dev);
    }

    /* 2. */
    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, notAppFamilyBmp);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet(dev, &enable);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet(dev, &enable);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*
GT_STATUS cpssDxChPclCopyReservedMaskSet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_DIRECTION_ENT      direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum,
    IN  GT_U32                      mask
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclCopyReservedMaskSet)
{
/*
    ITERATE_DEVICES
    1.1. Call with direction[ingress and egress]
                   lookupNum [CPSS_PCL_LOOKUP_1_E/
                              CPSS_PCL_LOOKUP_0_0_E/
                              CPSS_PCL_LOOKUP_0_1_E]
               and mask[0, 0x1FFFF, 0x3FFFF, 0x40000]
    Expected: GT_OK and GT_OUT_OF_RANGE
    1.2. Call cpssDxChPclCopyReservedMaskGet with non-NULL pointers
         other params same as in 1.1.
    Expected: GT_OK and the same values.
    1.3 Call with wrong enum value for lookupNum,
                     other params same as in 1.1.
    Expected: GT_BAD_PARAM
    1.4 Call with wrong enum value for direction,
                     other params same as in 1.1.
    Expected: GT_BAD_PARAM
*/
    GT_STATUS               st;
    GT_U8                   dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNumArr[] = {CPSS_PCL_LOOKUP_1_E, CPSS_PCL_LOOKUP_0_0_E, CPSS_PCL_LOOKUP_0_1_E};
    CPSS_PCL_DIRECTION_ENT  directionArr[]= {CPSS_PCL_DIRECTION_INGRESS_E, CPSS_PCL_DIRECTION_EGRESS_E};
    GT_U32                  ii, kk;
    GT_U32                  sip5MaskArr[] =  { 0, 0x1FFFF, 0x3FFFF, 0x40000};
    GT_U32                  sip610MaskArr[] =  { 0, 0x1FFFF, 0x7FFFF, 0x80000};
    GT_U32                  *maskArr = sip5MaskArr;
    GT_U32                  iterSize = 0;
    GT_STATUS               expectRc[] = {GT_OK, GT_OK, GT_OK, GT_OUT_OF_RANGE};
    GT_U32                  maskGet;
    GT_BOOL                 iPcl0Bypass;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {

        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;
        /*
            1.1. Call with direction[ingress and egress]
                        lookupNum [CPSS_PCL_LOOKUP_1_E/
                                   CPSS_PCL_LOOKUP_0_0_E/
                                   CPSS_PCL_LOOKUP_0_1_E]
                       and mask[0, 0x1FFFF, 0x3FFFF, 0x40000]
            Expected: GT_OK and GT_OUT_OF_RANGE
        */
        maskArr = PRV_CPSS_SIP_6_10_CHECK_MAC(dev) ? sip610MaskArr : sip5MaskArr;
        for (ii = 0; ii < sizeof(lookupNumArr)/sizeof(lookupNumArr[0]); ii++)
        {
            iterSize = PRV_CPSS_SIP_6_10_CHECK_MAC(dev) ? sizeof(sip610MaskArr) / sizeof(sip610MaskArr[0]) :
                                                          sizeof(sip5MaskArr) / sizeof(sip5MaskArr[0]);
            lookupNum = lookupNumArr[ii];
            if(iPcl0Bypass == GT_TRUE && lookupNum == CPSS_PCL_LOOKUP_1_E)
            {
                lookupNum = CPSS_PCL_LOOKUP_NUMBER_1_E;
            }

            for (kk = 0; kk < iterSize; kk++)
            {

                /* For Ingress direction */
                st = cpssDxChPclCopyReservedMaskSet(dev, directionArr[0], lookupNum, maskArr[kk]);
                UTF_VERIFY_EQUAL4_PARAM_MAC(expectRc[kk], st, dev, directionArr, lookupNum, maskArr[kk]);
                if (st == GT_OK)
                {
                    /*
                     1.2 Get value and compare with set one.
                    */
                    st = cpssDxChPclCopyReservedMaskGet(dev, directionArr[0], lookupNum, &maskGet);
                    UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, directionArr, lookupNum);

                    /* validation values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(maskArr[kk], maskGet,
                               "got another mask then was set: %d", maskArr[kk]);
                }

                /* For egress direction */
                st = cpssDxChPclCopyReservedMaskSet(dev, directionArr[1], lookupNum, maskArr[kk]);
                UTF_VERIFY_EQUAL4_PARAM_MAC(expectRc[kk], st, dev, directionArr, lookupNum, maskArr[kk]);
                if (st == GT_OK)
                {
                    /*
                     1.2 Get value and compare with set one.
                    */
                    st = cpssDxChPclCopyReservedMaskGet(dev, directionArr[1], lookupNum, &maskGet);
                    UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, directionArr, lookupNum);

                    /* validation values */
                    UTF_VERIFY_EQUAL1_STRING_MAC(maskArr[kk], maskGet,
                               "got another mask then was set: %d", maskArr[kk]);
                }
            }
        }

        /*
            1.3. Call with out of range lookupNum [wrong enum values],
                           other params same as in 1.1.
            Expected: GT_BAD_PARAM.
        */
        kk = 0;
        lookupNum = lookupNumArr[0];
        UTF_ENUMS_CHECK_MAC(cpssDxChPclCopyReservedMaskSet
                            (dev, directionArr[0], lookupNum, maskArr[kk]),
                            directionArr[0]);
        /*
            1.4. Call with out of range lookupNum [wrong enum values],
                           other params same as in 1.1.
            Expected: GT_BAD_PARAM.
        */
        kk = 0;
        lookupNum = lookupNumArr[0];
        UTF_ENUMS_CHECK_MAC(cpssDxChPclCopyReservedMaskSet
                            (dev, directionArr[0], lookupNum, maskArr[kk]),
                            lookupNum);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclCopyReservedMaskSet(dev, directionArr[0], lookupNumArr[0], maskArr[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclCopyReservedMaskSet(dev, directionArr[0], lookupNumArr[0], maskArr[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclCopyReservedMaskGet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_DIRECTION_ENT      direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum,
    OUT GT_U32                      *maskPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclCopyReservedMaskGet)
{
/*
    ITERATE_DEVICES
    1.1. Call with non NULL maskPtr.
    Expected: GT_OK.
    1.2. Call with out of range lookupNum [wrong enum values],
                       other params same as in 1.1.
        Expected: GT_BAD_PARAM
    1.3. Call with wrong enum value for direction,
                       other params same as in 1.1.
        Expected: GT_BAD_PARAM
    1.3. Call with maskPtr [NULL],
                   other params same as in 1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                   st;
    GT_U8                       dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum = CPSS_PCL_LOOKUP_0_0_E;
    CPSS_PCL_DIRECTION_ENT      direction = CPSS_PCL_DIRECTION_INGRESS_E;
    GT_U32                      mask;

    /* prepare iterator for go over all active devices */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with non NULL maskPtr.
            Expected: GT_OK.
        */
        st = cpssDxChPclCopyReservedMaskGet(dev, direction, lookupNum, &mask);
        UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction, mask);

        /*
            1.2. Call with out of range lookupNum [wrong enum values],
                       other params same as in 1.1.
            Expected: GT_BAD_PARAM
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclCopyReservedMaskGet
                            (dev, direction, lookupNum, &mask),
                            direction);

        /*
            1.3. Call with out of range lookupNum [wrong enum values],
                       other params same as in 1.1.
            Expected: GT_BAD_PARAM
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclCopyReservedMaskGet
                            (dev, direction, lookupNum, &mask),
                            lookupNum);
        /*
            1.3. Call with maskPtr [NULL],
                           other params same as in 1.1.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclCopyReservedMaskGet(dev, direction, lookupNum, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, maskPtr = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE             */

    /* prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_XCAT3_E | UTF_AC5_E | UTF_LION2_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclCopyReservedMaskGet(dev, direction, lookupNum, &mask);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclCopyReservedMaskGet(dev, direction, lookupNum, &mask);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

UTF_TEST_CASE_MAC(cpssDxChPclRuleSet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclRuleSet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclRuleActionUpdate_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclRuleActionUpdate);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclRuleActionGet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclRuleActionGet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclRuleInvalidate_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclRuleInvalidate);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclRuleValidStatusSet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclRuleValidStatusSet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclRuleCopy_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclRuleCopy);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclRuleStateGet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclRuleStateGet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclRuleAnyStateGet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclRuleAnyStateGet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclRuleGet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclRuleGet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleActionGet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclPortGroupRuleActionGet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleActionUpdate_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclPortGroupRuleActionUpdate);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleAnyStateGet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclPortGroupRuleAnyStateGet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleCopy_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclPortGroupRuleCopy);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleGet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclPortGroupRuleGet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleInvalidate_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclPortGroupRuleInvalidate);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleSet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclPortGroupRuleSet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleValidStatusSet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclPortGroupRuleValidStatusSet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclFillRuleTable_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclFillRuleTable);
    mainUtCpssDxChPclTcamIndexSet(0);
}

UTF_TEST_CASE_MAC(cpssDxChPclPortGroupRuleParsedGet_multiTcam)
{
    GT_U8                       dev;

    /* Skip test if not AC5 device found */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, UTF_AC5_E);
    if (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        SKIP_TEST_MAC
    }
    /* run the test below with tcamIndex==1*/
    mainUtCpssDxChPclTcamIndexSet(1);
    UTF_TEST_CALL_MAC(cpssDxChPclPortGroupRuleParsedGet);
    mainUtCpssDxChPclTcamIndexSet(0);
}

/*
GT_STATUS cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet
(
    IN   GT_U8                             devNum,
    IN   CPSS_PCL_DIRECTION_ENT            direction,
    IN   CPSS_DXCH_PCL_PACKET_TYPE_ENT     packetType,
    IN   GT_U32                            cfgTableEmProfileId,
    IN   GT_U32                            tcamProfileId
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet)
{
    GT_STATUS                           st = GT_OK;
    GT_U8                               dev;
    CPSS_DXCH_PCL_PACKET_TYPE_ENT       packetType;
    CPSS_PCL_DIRECTION_ENT              direction;
    GT_U32                              cfgTableEmProfileId;
    GT_U32                              tcamProfileId;
    GT_U32                              tcamProfileIdGet;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        tcamProfileId = 0;
        for (packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)0; (packetType < CPSS_DXCH_PCL_PACKET_TYPE_LAST_E); packetType++)
        {
            if (packetType == CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E)
            {
                continue; /* npt applicable for SIP5 and above */
            }
            for (direction = CPSS_PCL_DIRECTION_INGRESS_E; (direction <= CPSS_PCL_DIRECTION_EGRESS_E); direction++)
            {
                for (cfgTableEmProfileId = 0; (cfgTableEmProfileId < 16); cfgTableEmProfileId++)
                {
                    st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet(
                        dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);
                    UTF_VERIFY_EQUAL5_PARAM_MAC(
                        GT_OK, st, dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);
                    if (st == GT_OK)
                    {
                        st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet(
                            dev, direction, packetType, cfgTableEmProfileId, &tcamProfileIdGet);
                        UTF_VERIFY_EQUAL4_PARAM_MAC(
                            GT_OK, st, dev, direction, packetType, cfgTableEmProfileId);
                        UTF_VERIFY_EQUAL4_PARAM_MAC(
                            tcamProfileId, tcamProfileIdGet, dev, direction, packetType, cfgTableEmProfileId);
                    }
                }
                tcamProfileId = ((tcamProfileId + 1) % 64);
            }
        }

        direction = (CPSS_PCL_DIRECTION_ENT)100;
        packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)0;
        cfgTableEmProfileId = 0;
        tcamProfileId       = 0;
        st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet(
            dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);
        UTF_VERIFY_EQUAL5_PARAM_MAC(
            GT_BAD_PARAM, st, dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);

        direction = (CPSS_PCL_DIRECTION_ENT)0;
        packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)100;
        cfgTableEmProfileId = 0;
        tcamProfileId       = 0;
        st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet(
            dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);
        UTF_VERIFY_EQUAL5_PARAM_MAC(
            GT_BAD_PARAM, st, dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);

        direction = (CPSS_PCL_DIRECTION_ENT)0;
        packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)0;
        cfgTableEmProfileId = 16;
        tcamProfileId       = 0;
        st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet(
            dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);
        UTF_VERIFY_EQUAL5_PARAM_MAC(
            GT_BAD_PARAM, st, dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);

        direction = (CPSS_PCL_DIRECTION_ENT)0;
        packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)0;
        cfgTableEmProfileId = 0;
        tcamProfileId       = 64;
        st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet(
            dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);
        UTF_VERIFY_EQUAL5_PARAM_MAC(
            GT_OUT_OF_RANGE, st, dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);
    }

    direction = (CPSS_PCL_DIRECTION_ENT)0;
    packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)0;
    cfgTableEmProfileId = 0;
    tcamProfileId       = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS);

    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet(
            dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);
        UTF_VERIFY_EQUAL5_PARAM_MAC(
            GT_NOT_APPLICABLE_DEVICE, st, dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet(
        dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);
    UTF_VERIFY_EQUAL5_PARAM_MAC(
        GT_BAD_PARAM, st, dev, direction, packetType, cfgTableEmProfileId, tcamProfileId);
}

/*
GT_STATUS cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet
(
    IN   GT_U8                             devNum,
    IN   CPSS_PCL_DIRECTION_ENT            direction,
    IN   CPSS_DXCH_PCL_PACKET_TYPE_ENT     packetType,
    IN   GT_U32                            cfgTableEmProfileId,
    OUT  GT_U32                            *tcamProfileIdPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet)
{
    GT_STATUS                           st = GT_OK;
    GT_U8                               dev;
    CPSS_DXCH_PCL_PACKET_TYPE_ENT       packetType;
    CPSS_PCL_DIRECTION_ENT              direction;
    GT_U32                              cfgTableEmProfileId;
    GT_U32                              tcamProfileId;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        for (packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)0; (packetType < CPSS_DXCH_PCL_PACKET_TYPE_LAST_E); packetType++)
        {
            if (packetType == CPSS_DXCH_PCL_PACKET_TYPE_IPV6_E)
            {
                continue; /* npt applicable for SIP5 and above */
            }
            for (direction = CPSS_PCL_DIRECTION_INGRESS_E; (direction <= CPSS_PCL_DIRECTION_EGRESS_E); direction++)
            {
                for (cfgTableEmProfileId = 0; (cfgTableEmProfileId < 16); cfgTableEmProfileId++)
                {
                    st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet(
                        dev, direction, packetType, cfgTableEmProfileId, &tcamProfileId);
                    UTF_VERIFY_EQUAL4_PARAM_MAC(
                        GT_OK, st, dev, direction, packetType, cfgTableEmProfileId);
                }
            }
        }

        direction = (CPSS_PCL_DIRECTION_ENT)100;
        packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)0;
        cfgTableEmProfileId = 0;
        st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet(
            dev, direction, packetType, cfgTableEmProfileId, &tcamProfileId);
        UTF_VERIFY_EQUAL4_PARAM_MAC(
            GT_BAD_PARAM, st, dev, direction, packetType, cfgTableEmProfileId);

        direction = (CPSS_PCL_DIRECTION_ENT)0;
        packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)100;
        cfgTableEmProfileId = 0;
        st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet(
            dev, direction, packetType, cfgTableEmProfileId, &tcamProfileId);
        UTF_VERIFY_EQUAL4_PARAM_MAC(
            GT_BAD_PARAM, st, dev, direction, packetType, cfgTableEmProfileId);

        direction = (CPSS_PCL_DIRECTION_ENT)0;
        packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)0;
        cfgTableEmProfileId = 16;
        st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet(
            dev, direction, packetType, cfgTableEmProfileId, &tcamProfileId);
        UTF_VERIFY_EQUAL4_PARAM_MAC(
            GT_BAD_PARAM, st, dev, direction, packetType, cfgTableEmProfileId);

        direction = (CPSS_PCL_DIRECTION_ENT)0;
        packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)0;
        cfgTableEmProfileId = 0;
        st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet(
            dev, direction, packetType, cfgTableEmProfileId, NULL);
        UTF_VERIFY_EQUAL4_PARAM_MAC(
            GT_BAD_PTR, st, dev, direction, packetType, cfgTableEmProfileId);
    }

    direction = (CPSS_PCL_DIRECTION_ENT)0;
    packetType = (CPSS_DXCH_PCL_PACKET_TYPE_ENT)0;
    cfgTableEmProfileId = 0;

    /*2. Go over all non active devices. */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS);

    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet(
            dev, direction, packetType, cfgTableEmProfileId, &tcamProfileId);
        UTF_VERIFY_EQUAL4_PARAM_MAC(
            GT_NOT_APPLICABLE_DEVICE, st, dev, direction, packetType, cfgTableEmProfileId);
    }

    /* 3. Call function with out of range device id.    */
    /* Expected: GT_BAD_PARAM.                          */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;
    st = cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet(
        dev, direction, packetType, cfgTableEmProfileId, &tcamProfileId);
    UTF_VERIFY_EQUAL4_PARAM_MAC(
        GT_BAD_PARAM, st, dev, direction, packetType, cfgTableEmProfileId);
}

/*
GT_STATUS cpssDxChPclPortPclId2Set
(
    IN GT_U8                         devNum,
    IN GT_PHYSICAL_PORT_NUM          portNum,
    IN CPSS_PCL_DIRECTION_ENT        direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT    lookupNum,
    IN GT_U32                        portPclId2
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortPclId2Set)
{
/*
    ITERATE_DEVICES_PHY_PORTS (AC5P; AC5X)
    1.1. Call with direction[ingress and egress]
                   lookupNum [CPSS_PCL_LOOKUP_1_E/
                              CPSS_PCL_LOOKUP_0_0_E/
                              CPSS_PCL_LOOKUP_0_1_E]
               and portPclId2[0, 0x7FFFFF, 0xFFFFFF, 0x1000000]
    Expected: GT_OK and GT_OUT_OF_RANGE
    1.2. Call cpssDxChPclPortPclId2Get with non-NULL pointers
         other params same as in 1.1.
    Expected: GT_OK and the same values.
    1.3 Call with wrong enum value for lookupNum,
                     other params same as in 1.1.
    Expected: GT_BAD_PARAM
    1.4 Call with wrong enum value for direction,
                     other params same as in 1.1.
    Expected: GT_BAD_PARAM
*/
    GT_STATUS               st;
    GT_U8                   dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNumArr[3] = {CPSS_PCL_LOOKUP_0_E, CPSS_PCL_LOOKUP_1_E, CPSS_PCL_LOOKUP_0_1_E};
    CPSS_PCL_DIRECTION_ENT  directionArr[2]= {CPSS_PCL_DIRECTION_INGRESS_E, CPSS_PCL_DIRECTION_EGRESS_E};
    GT_U32                  portPclId2Arr[4] =  {0, 0x7FFFFF, 0xFFFFFF, 0x1000000};
    GT_STATUS               expectRc[4] = {GT_OK, GT_OK, GT_OK, GT_OUT_OF_RANGE};
    GT_U32                  ii, kk;
    GT_BOOL                 iPcl0Bypass;
    GT_PORT_NUM             port;
    GT_U32                  portPclId2Get;

    /* prepare iterator for go over all active devices */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS)

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. For all active devices go over all available physical ports. */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {

            iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;
            /*
                1.1. Call with direction[ingress and egress]
                            lookupNum [CPSS_PCL_LOOKUP_1_E/
                                       CPSS_PCL_LOOKUP_0_0_E/
                                       CPSS_PCL_LOOKUP_0_1_E]
                            and  portPclId2[0, 0x1FFFF, 0x3FFFF, 0x40000]
                Expected: GT_OK and GT_OUT_OF_RANGE
            */
            for (ii = 0; ii < sizeof(lookupNumArr)/sizeof(lookupNumArr[0]); ii++)
            {
                lookupNum = lookupNumArr[ii];
                if(iPcl0Bypass == GT_TRUE && lookupNum == CPSS_PCL_LOOKUP_1_E)
                {
                    lookupNum = CPSS_PCL_LOOKUP_NUMBER_1_E;
                }

                for (kk = 0; kk < sizeof(portPclId2Arr)/sizeof(portPclId2Arr[0]); kk++)
                {
                    /* For Ingress direction */
                    st = cpssDxChPclPortPclId2Set(dev, port, directionArr[0], lookupNum, portPclId2Arr[kk]);
                    UTF_VERIFY_EQUAL5_PARAM_MAC(expectRc[kk], st, dev, port, directionArr[0], lookupNum, portPclId2Arr[kk]);
                    if (st == GT_OK)
                    {
                        /*
                         1.2 Get value and compare with set one.
                        */
                        st = cpssDxChPclPortPclId2Get(dev, port, directionArr[0], lookupNum, &portPclId2Get);
                        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, port, directionArr[0], lookupNum);

                       /* validation values */
                        UTF_VERIFY_EQUAL1_STRING_MAC(portPclId2Arr[kk], portPclId2Get,
                                   "got another portPclId2 then was set: %d", portPclId2Get);
                    }

                    /* For egress direction */
                    st = cpssDxChPclPortPclId2Set(dev, port, directionArr[1], lookupNum, portPclId2Arr[kk]);
                    UTF_VERIFY_EQUAL5_PARAM_MAC(expectRc[kk], st, dev, port, directionArr[1], lookupNum, portPclId2Arr[kk]);
                    if (st == GT_OK)
                    {
                        /*
                         1.2 Get value and compare with set one.
                        */
                        st = cpssDxChPclPortPclId2Get(dev, port, directionArr[1], lookupNum, &portPclId2Get);
                        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, port, directionArr[1], lookupNum);

                        /* validation values */
                        UTF_VERIFY_EQUAL1_STRING_MAC(portPclId2Arr[kk], portPclId2Get,
                                   "got another portPclId2 then was set: %d", portPclId2Get);
                    }
                }
            }

            /*
                1.3. Call with out of range lookupNum [wrong enum values],
                               other params same as in 1.1.
                Expected: GT_BAD_PARAM.
            */
            kk = 0;
            lookupNum = lookupNumArr[0];
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortPclId2Set
                               (dev, port, directionArr[0], lookupNum, portPclId2Arr[kk]),
                                directionArr[0]);
            /*
                1.4. Call with out of range lookupNum [wrong enum values],
                               other params same as in 1.1.
                Expected: GT_BAD_PARAM.
            */
            kk = 0;
            lookupNum = lookupNumArr[0];
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortPclId2Set
                                (dev, port, directionArr[0], lookupNum, portPclId2Arr[kk]),
                                lookupNum);
        }
    }

    /* restore valid values */
    port = DXCH_PCL_VALID_PHY_PORT_CNS;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE */

    /* 2. Go over all non active devices. */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortPclId2Set(dev, port, directionArr[0], lookupNumArr[0], portPclId2Arr[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortPclId2Set(dev, port, directionArr[0], lookupNumArr[0], portPclId2Arr[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*
GT_STATUS cpssDxChPclPortPclId2Get
(
    IN GT_U8                           devNum,
    IN GT_PHYSICAL_PORT_NUM            portNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    OUT GT_U32                         *portPclId2Ptr
)
*/

UTF_TEST_CASE_MAC(cpssDxChPclPortPclId2Get)
{
/*
    ITERATE_DEVICES
    1.1. Call with non NULL maskPtr.
    Expected: GT_OK.
    1.2. Call with out of range lookupNum [wrong enum values],
                       other params same as in 1.1.
        Expected: GT_BAD_PARAM
    1.3. Call with wrong enum value for direction,
                       other params same as in 1.1.
        Expected: GT_BAD_PARAM
    1.3. Call with maskPtr [NULL],
                   other params same as in 1.1.
    Expected: GT_BAD_PTR.
*/
    GT_STATUS                   st;
    GT_U8                       dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum = CPSS_PCL_LOOKUP_0_0_E;
    CPSS_PCL_DIRECTION_ENT      direction = CPSS_PCL_DIRECTION_INGRESS_E;
    GT_U32                      portPclId2;
    GT_PORT_NUM                 port;

    /* prepare iterator for go over all active devices */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS)

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. for all active devices go over all available physical ports. */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /*
                1.1. Call with non NULL portPclId2Ptr.
                Expected: GT_OK.
            */
            st = cpssDxChPclPortPclId2Get(dev, port, direction, lookupNum, &portPclId2);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, port, direction, lookupNum);

            /*
                1.2. Call with out of range lookupNum [wrong enum values],
                           other params same as in 1.1.
                Expected: GT_BAD_PARAM
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortPclId2Get
                               (dev, port, direction, lookupNum, &portPclId2),
                                direction);

            /*
                1.3. Call with out of range lookupNum [wrong enum values],
                     other params same as in 1.1.
                Expected: GT_BAD_PARAM
            */
            UTF_ENUMS_CHECK_MAC(cpssDxChPclPortPclId2Get
                                (dev, port, direction, lookupNum, &portPclId2),
                                lookupNum);
            /*
                1.3. Call with maskPtr [NULL],
                     other params same as in 1.1.
                Expected: GT_BAD_PTR.
            */
            st = cpssDxChPclPortPclId2Get(dev, port, direction, lookupNum, NULL);
            UTF_VERIFY_EQUAL4_PARAM_MAC(GT_BAD_PTR, st, dev, port, direction, lookupNum);
        }

    }

    /* restore valid values */
    port = DXCH_PCL_VALID_PHY_PORT_CNS;
    direction = CPSS_PCL_DIRECTION_INGRESS_E;

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE             */

    /* 2. Go over all non active devices. */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortPclId2Get(dev, port, direction, lookupNum, &portPclId2);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortPclId2Get(dev, port, direction, lookupNum, &portPclId2);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}




/*
GT_STATUS cpssDxChPclTriggerHashCncClientMaskSet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum,
    IN  GT_BOOL                     maskEn
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclTriggerHashCncClientMaskSet)
{
/*
    ITERATE_DEVICES
    1.1. Call cpssDxChPclTriggerHashCncClientMaskSet API with valid values,
                      lookupNum [CPSS_PCL_LOOKUP_1_E/CPSS_PCL_LOOKUP_0_0_E/CPSS_PCL_LOOKUP_0_1_E]
                      maskEn[GT_TRUE/GT_FALSE]
         Expected: GT_OK

    1.2. Call cpssDxChPclTriggerHashCncClientMaskGet API with same parameters as in 1.1.
         Expected: GT_OK and the same values.

    1.3  Call with wrong enum value for lookupNum, other params same as in 1.1.
         Expected: GT_BAD_PARAM
*/
    GT_STATUS               st;
    GT_U8                   dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNumArr[] = {CPSS_PCL_LOOKUP_1_E, CPSS_PCL_LOOKUP_0_0_E, CPSS_PCL_LOOKUP_0_1_E};
    GT_U32                  ii, kk;
    GT_BOOL                 maskEnArr[] =  {GT_TRUE, GT_FALSE};
    GT_BOOL                 maskEnGet;
    GT_BOOL                 iPcl0Bypass;

    /* Prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, ~UTF_FALCON_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {

        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;
        /*
            1.1. Call API with valid values,
                               lookupNum [CPSS_PCL_LOOKUP_1_E/CPSS_PCL_LOOKUP_0_0_E/CPSS_PCL_LOOKUP_0_1_E]
                               maskEn[GT_TRUE/GT_FALSE]
            Expected: GT_OK
        */
        /* Loop over lookup tables lookupNumArr[] = {CPSS_PCL_LOOKUP_1_E, CPSS_PCL_LOOKUP_0_0_E, CPSS_PCL_LOOKUP_0_1_E} */
        for (ii = 0; ii < sizeof(lookupNumArr)/sizeof(lookupNumArr[0]); ii++)
        {
            lookupNum = lookupNumArr[ii];
            if(iPcl0Bypass == GT_TRUE && lookupNum == CPSS_PCL_LOOKUP_1_E)
            {
                lookupNum = CPSS_PCL_LOOKUP_NUMBER_1_E;
            }

            /* Loop over maskEnArr table maskArr[] =  {GT_TRUE, GT_FALSE}; */
            for (kk = 0; kk < 2; kk++)
            {
                st = cpssDxChPclTriggerHashCncClientMaskSet(dev, lookupNum, maskEnArr[kk]);
                UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, lookupNum, maskEnArr[kk]);
                if (st == GT_OK)
                {
                    /*
                     1.2 Get value and compare with set one.
                    */
                    st = cpssDxChPclTriggerHashCncClientMaskGet(dev, lookupNum, &maskEnGet);
                    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, lookupNum);

                    /* validation values */
                    UTF_VERIFY_EQUAL2_STRING_MAC(maskEnArr[kk], maskEnGet, "got different maskEnGet(%d) then was set(%d)",maskEnGet, maskEnArr[kk]);
                }
            }
        }

        /*
            1.3. Call with out of range lookupNum [wrong enum values],other params same as in 1.1.
            Expected: GT_BAD_PARAM.
        */
        kk = 1;
        lookupNum = lookupNumArr[0];
        UTF_ENUMS_CHECK_MAC(cpssDxChPclTriggerHashCncClientMaskSet(dev, lookupNum, maskEnArr[kk]), lookupNum);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE */

    /* Prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, ~UTF_FALCON_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclTriggerHashCncClientMaskSet(dev, lookupNumArr[0], maskEnArr[0]);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclTriggerHashCncClientMaskSet(dev, lookupNumArr[0], maskEnArr[0]);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}


/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclTriggerHashCncClientMaskGet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum,
    OUT GT_BOOL                     *maskEnPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclTriggerHashCncClientMaskGet)
{
/*
    ITERATE_DEVICES
    1.1. Call with valid values.
         Expected: GT_OK.

    1.2. Call with out of range lookupNum [wrong enum values], other params same as in 1.1.
         Expected: GT_BAD_PARAM

    1.3. Call with maskPtr [NULL],other params same as in 1.1.
         Expected: GT_BAD_PTR.
*/
    GT_STATUS                   st;
    GT_U8                       dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum = CPSS_PCL_LOOKUP_0_0_E;
    GT_BOOL                     maskEn;

    /* Prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, ~UTF_FALCON_E);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
            1.1. Call with valid values.
            Expected: GT_OK.
        */
        st = cpssDxChPclTriggerHashCncClientMaskGet(dev, lookupNum, &maskEn);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, maskEn);

        /*
            1.2. Call with out of range lookupNum [wrong enum values], other params same as in 1.1.
            Expected: GT_BAD_PARAM
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclTriggerHashCncClientMaskGet(dev, lookupNum, &maskEn), lookupNum);
        /*
            1.3. Call with maskEnPtr [NULL], other params same as in 1.1.
            Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclTriggerHashCncClientMaskGet(dev, lookupNum, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, maskEnPtr = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE             */

    /* Prepare device iterator */
    PRV_TGF_NOT_APPLIC_DEV_RESET_MAC(&dev, ~UTF_FALCON_E);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclTriggerHashCncClientMaskGet(dev, lookupNum, &maskEn);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclTriggerHashCncClientMaskGet(dev, lookupNum, &maskEn);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*
GT_STATUS cpssDxChPclFlowIdActionAssignModeSet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN GT_U32                          hitNum,
    IN CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_ENT mode
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclFlowIdActionAssignModeSet)
{
    GT_STATUS                       st = GT_OK;
    GT_U8                           dev;
    CPSS_PCL_DIRECTION_ENT          direction;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNumArr[3] =
                                    {CPSS_PCL_LOOKUP_NUMBER_0_E,
                                     CPSS_PCL_LOOKUP_NUMBER_1_E,
                                     CPSS_PCL_LOOKUP_NUMBER_2_E};
    GT_U32                          ii;
    GT_U32                          hitNum ,maxHitNum;
    GT_BOOL                         expectFail;
    CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_ENT mode , modeGet;

    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        if(PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.tcam.limitedNumOfParrallelLookups)
        {
           maxHitNum = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.tcam.limitedNumOfParrallelLookups;
        }
        else
        {
           maxHitNum = 4;
        }

        for(direction =  CPSS_PCL_DIRECTION_INGRESS_E;
            direction <= CPSS_PCL_DIRECTION_EGRESS_E;
            direction ++)
        {
            for (ii = 0; ii < sizeof(lookupNumArr)/sizeof(lookupNumArr[0]); ii++)
            {
                lookupNum = lookupNumArr[ii];

                for(hitNum = 0 ; hitNum <= maxHitNum ; hitNum ++)
                {
                    for(mode = CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_FLOW_ID_STREAM_ID_E ;
                        mode <= CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_STREAM_ID_ONLY_E ;
                        mode ++)
                    {
                        if(PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass &&
                           lookupNum == CPSS_PCL_LOOKUP_NUMBER_2_E &&
                           direction == CPSS_PCL_DIRECTION_INGRESS_E /*lookupNum ignored for egress direction*/)
                        {
                            /* expect fail - the device not hold 3 staged */
                            expectFail = GT_TRUE;
                        }
                        else
                        if(hitNum == maxHitNum)
                        {
                            /* expect fail - the device not hold 3 staged */
                            expectFail = GT_TRUE;
                        }
                        else
                        {
                            expectFail = GT_FALSE;
                        }

                        st = cpssDxChPclFlowIdActionAssignModeSet(
                            dev,direction,lookupNum,hitNum,mode);
                        if(expectFail == GT_FALSE)
                        {
                            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, direction,lookupNum,hitNum,mode);
                        }
                        else
                        {
                            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, direction,lookupNum,hitNum,mode);
                        }

                        st = cpssDxChPclFlowIdActionAssignModeGet(
                            dev,direction,lookupNum,hitNum,&modeGet);
                        if(expectFail == GT_FALSE)
                        {
                            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, direction,lookupNum,hitNum,mode);
                        }
                        else
                        {
                            UTF_VERIFY_EQUAL5_PARAM_MAC(GT_BAD_PARAM, st, dev, direction,lookupNum,hitNum,mode);
                        }

                        if(expectFail == GT_FALSE)
                        {
                            /* compare the 'modeGet' and the 'mode' that was set */
                            UTF_VERIFY_EQUAL5_PARAM_MAC(mode, modeGet, dev, direction,lookupNum,hitNum,mode);
                        }
                    }/* mode */
                    mode = 0;

                    /* mode : test invalid enum value */
                    UTF_ENUMS_CHECK_MAC(cpssDxChPclFlowIdActionAssignModeSet
                                       (dev,direction,lookupNum,hitNum,mode),
                                        mode);
                }/*hitNum*/
            }/*ii*/
            lookupNum = 0;
            hitNum = 0;
            mode   = 0;

            if(direction == CPSS_PCL_DIRECTION_INGRESS_E )
            {
                /* lookupNum : test invalid enum value */
                UTF_ENUMS_CHECK_MAC(cpssDxChPclFlowIdActionAssignModeSet
                                   (dev,direction,lookupNum,hitNum,mode),
                                    lookupNum);
            }
            else
            {
                lookupNum = 0x5a5a5a5a;  /*lookupNum ignored for egress direction*/

                st = cpssDxChPclFlowIdActionAssignModeSet(
                    dev,direction,lookupNum,hitNum,mode);
                UTF_VERIFY_EQUAL5_PARAM_MAC(GT_OK, st, dev, direction,lookupNum,hitNum,mode);
            }
        }/*direction*/
        lookupNum = 0;
        hitNum = 0;
        mode   = 0;
        /* direction : test invalid enum value */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclFlowIdActionAssignModeSet
                           (dev,direction,lookupNum,hitNum,mode),
                            direction);
    }/*dev*/


    direction = 0;
    lookupNum = 0;
    hitNum    = 0;
    mode      = 0;

    /* 2. Go over all non active devices. */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclFlowIdActionAssignModeSet(dev, direction,lookupNum,hitNum,mode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclFlowIdActionAssignModeSet(dev, direction,lookupNum,hitNum,mode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

}

/*
GT_STATUS cpssDxChPclFlowIdActionAssignModeGet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN GT_U32                          hitNum,
    OUT CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_ENT *modePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclFlowIdActionAssignModeGet)
{
    GT_STATUS                       st = GT_OK;
    GT_U8                           dev;
    CPSS_PCL_DIRECTION_ENT          direction;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNumArr[3] =
                                    {CPSS_PCL_LOOKUP_NUMBER_0_E,
                                     CPSS_PCL_LOOKUP_NUMBER_1_E,
                                     CPSS_PCL_LOOKUP_NUMBER_2_E};
    GT_U32                          ii;
    GT_U32                          hitNum ,maxHitNum;
    GT_BOOL                         expectFail;
    CPSS_DXCH_PCL_FLOW_ID_ACTION_ASSIGNMENT_MODE_ENT modeGet;

    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        if(PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.tcam.limitedNumOfParrallelLookups)
        {
           maxHitNum = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.tcam.limitedNumOfParrallelLookups;
        }
        else
        {
           maxHitNum = 4;
        }

        for(direction =  CPSS_PCL_DIRECTION_INGRESS_E;
            direction <= CPSS_PCL_DIRECTION_EGRESS_E;
            direction ++)
        {
            for (ii = 0; ii < sizeof(lookupNumArr)/sizeof(lookupNumArr[0]); ii++)
            {
                lookupNum = lookupNumArr[ii];

                for(hitNum = 0 ; hitNum <= maxHitNum ; hitNum ++)
                {
                    if(PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass &&
                       lookupNum == CPSS_PCL_LOOKUP_NUMBER_2_E &&
                       direction == CPSS_PCL_DIRECTION_INGRESS_E /*lookupNum ignored for egress direction*/)
                    {
                        /* expect fail - the device not hold 3 staged */
                        expectFail = GT_TRUE;
                    }
                    else
                    if(hitNum == maxHitNum)
                    {
                        /* expect fail - the device not hold 3 staged */
                        expectFail = GT_TRUE;
                    }
                    else
                    {
                        expectFail = GT_FALSE;
                    }

                    st = cpssDxChPclFlowIdActionAssignModeGet(
                        dev,direction,lookupNum,hitNum,&modeGet);
                    if(expectFail == GT_FALSE)
                    {
                        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, direction,lookupNum,hitNum);
                    }
                    else
                    {
                        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_BAD_PARAM, st, dev, direction,lookupNum,hitNum);
                    }

                    if(expectFail == GT_FALSE)
                    {
                        /* check with NULL pointer */
                        st = cpssDxChPclFlowIdActionAssignModeGet(
                            dev,direction,lookupNum,hitNum,NULL);
                        UTF_VERIFY_EQUAL4_PARAM_MAC(GT_BAD_PTR, st, dev, direction,lookupNum,hitNum);
                    }
                }/*hitNum*/
            }/*ii*/
            lookupNum = 0;
            hitNum = 0;

            if(direction == CPSS_PCL_DIRECTION_INGRESS_E)
            {
                /* lookupNum : test invalid enum value */
                UTF_ENUMS_CHECK_MAC(cpssDxChPclFlowIdActionAssignModeGet
                                   (dev,direction,lookupNum,hitNum,&modeGet),
                                    lookupNum);
            }
            else
            {
                lookupNum = 0x5a5a5a5a;  /*lookupNum ignored for egress direction*/

                st = cpssDxChPclFlowIdActionAssignModeGet(
                    dev,direction,lookupNum,hitNum,&modeGet);
                UTF_VERIFY_EQUAL4_PARAM_MAC(GT_OK, st, dev, direction,lookupNum,hitNum);
            }
        }/*direction*/
        lookupNum = 0;
        hitNum = 0;
        /* direction : test invalid enum value */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclFlowIdActionAssignModeGet
                           (dev,direction,lookupNum,hitNum,&modeGet),
                            direction);
    }/*dev*/


    direction = 0;
    lookupNum = 0;
    hitNum    = 0;

    /* 2. Go over all non active devices. */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclFlowIdActionAssignModeGet(dev, direction,lookupNum,hitNum,&modeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclFlowIdActionAssignModeGet(dev, direction,lookupNum,hitNum,&modeGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

}

/*
GT_STATUS cpssDxChPclNumberOfStreamIdsSet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    IN GT_U32                          maxNum
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclNumberOfStreamIdsSet)
{
    GT_STATUS                       st = GT_OK;
    GT_U8                           dev;
    CPSS_PCL_DIRECTION_ENT          direction;
    GT_U32                          maxNum,maxNumGet;

    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        for(direction =  CPSS_PCL_DIRECTION_INGRESS_E;
            direction <= CPSS_PCL_DIRECTION_EGRESS_E;
            direction ++)
        {
            maxNum = 0xFFFF - direction;

            st = cpssDxChPclNumberOfStreamIdsSet(
                dev,direction,maxNum);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, direction,maxNum);

            maxNum = 0xFFFF + 1 + direction;

            st = cpssDxChPclNumberOfStreamIdsSet(
                dev,direction,maxNum);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, direction,maxNum);

        }/*direction*/


        for(direction =  CPSS_PCL_DIRECTION_INGRESS_E;
            direction <= CPSS_PCL_DIRECTION_EGRESS_E;
            direction ++)
        {
            st = cpssDxChPclNumberOfStreamIdsGet(
                dev,direction,&maxNumGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, direction);

            /* compare the 'get; value with the 'set' value */
            UTF_VERIFY_EQUAL2_PARAM_MAC((0xFFFF - direction), maxNumGet, dev, direction);

        }/*direction*/

        maxNum = 1;
        /* direction : test invalid enum value */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclNumberOfStreamIdsSet
                           (dev,direction,maxNum),
                            direction);
    }/*dev*/

    maxNum    = 1;
    direction = 0;

    /* 2. Go over all non active devices. */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclNumberOfStreamIdsSet(dev, direction,maxNum);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclNumberOfStreamIdsSet(dev, direction,maxNum);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

}

/*
GT_STATUS cpssDxChPclNumberOfStreamIdsGet
(
    IN GT_U8                           devNum,
    IN CPSS_PCL_DIRECTION_ENT          direction,
    OUT GT_U32                         *maxNumPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclNumberOfStreamIdsGet)
{
    GT_STATUS                       st = GT_OK;
    GT_U8                           dev;
    CPSS_PCL_DIRECTION_ENT          direction;
    GT_U32                          maxNumGet;

    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        for(direction =  CPSS_PCL_DIRECTION_INGRESS_E;
            direction <= CPSS_PCL_DIRECTION_EGRESS_E;
            direction ++)
        {
            st = cpssDxChPclNumberOfStreamIdsGet(
                dev,direction,&maxNumGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, direction);

            st = cpssDxChPclNumberOfStreamIdsGet(
                dev,direction,NULL);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, dev, direction);

        }/*direction*/

        /* direction : test invalid enum value */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclNumberOfStreamIdsGet
                           (dev,direction,&maxNumGet),
                            direction);
    }/*dev*/

    direction = 0;

    /* 2. Go over all non active devices. */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclNumberOfStreamIdsGet(dev, direction,&maxNumGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclNumberOfStreamIdsGet(dev, direction,&maxNumGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortEpgConfigSet
(
    IN  GT_U8                                       devNum,
    IN  GT_PORT_NUM                                 portNum,
    IN  CPSS_DXCH_PCL_PORT_EPG_CONFIG_STC          *portEpgConfigPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortEpgConfigSet)
{
    GT_STATUS   st = GT_OK;
    GT_PORT_NUM port;
    GT_U8       dev;

    CPSS_DXCH_PCL_PORT_EPG_CONFIG_STC  portEpgConfig;
    CPSS_DXCH_PCL_PORT_EPG_CONFIG_STC  portEpgConfigGet;

    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextDefaultEPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        while (GT_OK == prvUtfNextDefaultEPortGet(&port, GT_TRUE))
        {
            /* Set the values */
            portEpgConfig.srcEpg                = 0x81F;
            portEpgConfig.copyTag1VidToSrcEpg   = GT_TRUE;
            st = cpssDxChPclPortEpgConfigSet(dev, port, &portEpgConfig);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, portEpgConfig.srcEpg, portEpgConfig.copyTag1VidToSrcEpg);

            /* Get the values */
            st = cpssDxChPclPortEpgConfigGet(dev, port, &portEpgConfigGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                    "cpssDxChPclLookup0ForRoutedPacketsEnableGet: %d", dev);

            /* verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(portEpgConfig.srcEpg, portEpgConfigGet.srcEpg,
                    "got another enable then was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(portEpgConfig.copyTag1VidToSrcEpg, portEpgConfigGet.copyTag1VidToSrcEpg,
                    "got another enable then was set: %d", dev);

            /* Update the values */
            portEpgConfig.srcEpg                = 0x80F;
            portEpgConfig.copyTag1VidToSrcEpg   = GT_FALSE;
            st = cpssDxChPclPortEpgConfigSet(dev, port, &portEpgConfig);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, portEpgConfig.srcEpg, portEpgConfig.copyTag1VidToSrcEpg);

            /* Get the values */
            st = cpssDxChPclPortEpgConfigGet(dev, port, &portEpgConfigGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                    "cpssDxChPclLookup0ForRoutedPacketsEnableGet: %d", dev);

            /* verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(portEpgConfig.srcEpg, portEpgConfigGet.srcEpg,
                    "got another enable then was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(portEpgConfig.copyTag1VidToSrcEpg, portEpgConfigGet.copyTag1VidToSrcEpg,
                    "got another enable then was set: %d", dev);

            /* verify out of range values */
            portEpgConfig.srcEpg                = 0xFFF + 1 + port;
            st = cpssDxChPclPortEpgConfigSet(dev, port, &portEpgConfig);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, portEpgConfig.srcEpg, portEpgConfig.copyTag1VidToSrcEpg);
        }

        /* prepare physical port iterator */
        st = prvUtfNextDefaultEPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.3. Go over non configured ports */
        while (GT_OK == prvUtfNextDefaultEPortGet(&port, GT_FALSE))
        {
            /* 1.3.1. Call function for each non configured port.   */
            /* Expected: GT_BAD_PARAM                               */
            st = cpssDxChPclPortEpgConfigSet(dev, port, &portEpgConfig);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
        }

        st = cpssDxChPclPortEpgConfigSet(dev, port, NULL);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, dev, port);
    }

    /* prepare physical port iterator */
    st = prvUtfNextDefaultEPortReset(&port, prvTgfDevNum);
    UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

    prvUtfNextDefaultEPortGet(&port, GT_TRUE);

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortEpgConfigSet(dev, port, &portEpgConfig);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortEpgConfigSet(dev, port, &portEpgConfig);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortEpgConfigGet
(
    IN   GT_U8                                       devNum,
    IN   GT_PORT_NUM                                 portNum,
    OUT  CPSS_DXCH_PCL_PORT_EPG_CONFIG_STC          *portEpgConfigPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortEpgConfigGet)
{
    GT_STATUS   st = GT_OK;
    GT_PORT_NUM port;
    GT_U8       dev;

    CPSS_DXCH_PCL_PORT_EPG_CONFIG_STC  portEpgConfig;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextDefaultEPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        while (GT_OK == prvUtfNextDefaultEPortGet(&port, GT_TRUE))
        {
            /* Set the values */
            st = cpssDxChPclPortEpgConfigGet(dev, port, &portEpgConfig);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            st = cpssDxChPclPortEpgConfigGet(dev, port, NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, portEpgConfig = NULL", dev);
        }

        /* prepare default port iterator */
        st = prvUtfNextDefaultEPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.3. Go over non configured ports */
        while (GT_OK == prvUtfNextDefaultEPortGet(&port, GT_FALSE))
        {
            /* 1.3.1. Call function for each non configured port.   */
            /* Expected: GT_BAD_PARAM                               */
            st = cpssDxChPclPortEpgConfigGet(dev, port, &portEpgConfig);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
        }

        st = cpssDxChPclPortEpgConfigGet(dev, port, NULL);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, dev, port);
    }

    /* prepare physical port iterator */
    st = prvUtfNextDefaultEPortReset(&port, prvTgfDevNum);
    UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

    prvUtfNextDefaultEPortGet(&port, GT_TRUE);

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortEpgConfigGet(dev, port, &portEpgConfig);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortEpgConfigGet(dev, port, &portEpgConfig);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*
GT_STATUS cpssDxChPclEpgConfigSet
(
    IN  GT_U8                           devNum,
    IN  CPSS_PCL_DIRECTION_ENT          direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum,
    IN  CPSS_DXCH_PCL_EPG_CONFIG_STC    *epgConfigPtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclEpgConfigSet)
{
/*
    ITERATE_DEVICES
    1.1. Call with direction[ingress and egress]
                   lookupNum [CPSS_PCL_LOOKUP_1_E/
                              CPSS_PCL_LOOKUP_0_0_E/
                              CPSS_PCL_LOOKUP_0_1_E]
               and useSrcTrgMode[ SRC_DST_EPG / COPY_RESERVED_SRC_ID ]
               and assignFromUdbsMode[ TAG1_DEST / SRC_EPG / TAG1_SRC_EPG ]
    Expected: GT_OK and GT_OUT_OF_RANGE
    1.2. Call cpssDxChPclEpgConfigSet with non-NULL pointers
         other params same as in 1.1.
    Expected: GT_OK and the same values.
    1.3 Call with wrong enum value for lookupNum,
                     other params same as in 1.1.
    Expected: GT_BAD_PARAM
    1.4 Call with wrong enum value for direction,
                     other params same as in 1.1.
    Expected: GT_BAD_PARAM
*/
    GT_STATUS                       st;
    GT_U8                           dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum;
    static const CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNumArrSip6_30[]  = 
            {CPSS_PCL_LOOKUP_1_E, CPSS_PCL_LOOKUP_0_0_E, CPSS_PCL_LOOKUP_0_1_E};
    static const CPSS_DXCH_PCL_USE_SRC_TRG_MODE_ENT  useSrcTrgModeArrSip6_30[] =
            { CPSS_DXCH_PCL_USE_SRC_TRG_MODE_SRC_DST_EPG_E,
              CPSS_DXCH_PCL_USE_SRC_TRG_MODE_COPY_RESERVED_SRC_ID_E };
    static const CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_ENT assignFromUdbsModeArrSip6_30[] =
            { CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_TAG1_DEST_E,
              CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_SRC_EPG_E,
              CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_TAG1_SRC_EPG_E};
    static const CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNumArrSip6_10[]  = 
            {CPSS_PCL_LOOKUP_0_0_E};
    static const CPSS_DXCH_PCL_USE_SRC_TRG_MODE_ENT  useSrcTrgModeArrSip6_10[] =
            { CPSS_DXCH_PCL_USE_SRC_TRG_MODE_SRC_DST_EPG_E};
    static const CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_ENT assignFromUdbsModeArrSip6_10[] =
            { CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_TAG1_DEST_E,
              CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_SRC_EPG_E};
    const CPSS_PCL_LOOKUP_NUMBER_ENT             *lookupNumArr;
    const CPSS_DXCH_PCL_USE_SRC_TRG_MODE_ENT     *useSrcTrgModeArr;
    const CPSS_DXCH_PCL_ASSIGN_FROM_UDB_MODE_ENT *assignFromUdbsModeArr;

    GT_U32                          numOfLookups;
    GT_U32                          numOfSrcTrgModes;
    GT_U32                          numOfAssignFromUdbsModes;
    GT_U32                          ii, jj, kk = 0;
    GT_BOOL                         iPcl0Bypass;
    CPSS_DXCH_PCL_EPG_CONFIG_STC    pclEpgConfig, pclEpgConfigGet;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {

        if (PRV_CPSS_SIP_6_30_CHECK_MAC(dev))
        {
            /* Ironman */
            lookupNumArr          = lookupNumArrSip6_30;
            useSrcTrgModeArr      = useSrcTrgModeArrSip6_30;
            assignFromUdbsModeArr = assignFromUdbsModeArrSip6_30;
            numOfLookups             = 
                sizeof(lookupNumArrSip6_30) / sizeof(lookupNumArrSip6_30[0]);
            numOfSrcTrgModes         = 
                sizeof(useSrcTrgModeArrSip6_30) / sizeof(useSrcTrgModeArrSip6_30[0]);
            numOfAssignFromUdbsModes = 
                sizeof(assignFromUdbsModeArrSip6_30) / sizeof(assignFromUdbsModeArrSip6_30[0]);
        }
        else
        {
            /* AC5P, AC5X, Harrier */
            lookupNumArr          = lookupNumArrSip6_10;
            useSrcTrgModeArr      = useSrcTrgModeArrSip6_10;
            assignFromUdbsModeArr = assignFromUdbsModeArrSip6_10;
            numOfLookups             = 
                sizeof(lookupNumArrSip6_10) / sizeof(lookupNumArrSip6_10[0]);
            numOfSrcTrgModes         = 
                sizeof(useSrcTrgModeArrSip6_10) / sizeof(useSrcTrgModeArrSip6_10[0]);
            numOfAssignFromUdbsModes = 
                sizeof(assignFromUdbsModeArrSip6_10) / sizeof(assignFromUdbsModeArrSip6_10[0]);
        }

        iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;
        /*
            1.1. Call with direction[ingress and egress]
                        lookupNum [CPSS_PCL_LOOKUP_1_E/
                                   CPSS_PCL_LOOKUP_0_0_E/
                                   CPSS_PCL_LOOKUP_0_1_E]
               and useSrcTrgMode[ SRC_DST_EPG / COPY_RESERVED_SRC_ID ]
               and assignFromUdbsMode[ TAG1_DEST / SRC_EPG / TAG1_SRC_EPG ]
            Expected: GT_OK
        */
        for (ii = 0; (ii < numOfLookups); ii++)
        {
            lookupNum = lookupNumArr[ii];
            if(iPcl0Bypass == GT_TRUE && lookupNum == CPSS_PCL_LOOKUP_1_E)
            {
                lookupNum = CPSS_PCL_LOOKUP_NUMBER_1_E;
            }

            for (jj = 0; (jj < numOfSrcTrgModes); jj++)
            {
                for (kk = 0; (kk < numOfAssignFromUdbsModes); kk++)
                {
                    /* For Ingress direction */
                    pclEpgConfig.useSrcTrgMode      = useSrcTrgModeArr[jj];
                    pclEpgConfig.assignFromUdbsMode = assignFromUdbsModeArr[kk];
                    st = cpssDxChPclEpgConfigSet(dev, lookupNum, &pclEpgConfig);
                    UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, lookupNum, &pclEpgConfig);

                    /* 1.2 Get value and compare with set one. */
                    st = cpssDxChPclEpgConfigGet(dev, lookupNum, &pclEpgConfigGet);
                    UTF_VERIFY_EQUAL2_PARAM_MAC(GT_OK, st, dev, lookupNum);

                    /* validation values */
                    if (PRV_CPSS_SIP_6_30_CHECK_MAC(dev))
                    {
                        /* this field ignored for AC5P, AC5X, Harrier */
                        UTF_VERIFY_EQUAL1_STRING_MAC(pclEpgConfigGet.useSrcTrgMode, pclEpgConfig.useSrcTrgMode,
                                "got another mask then was set: %d", pclEpgConfigGet.useSrcTrgMode);
                    }
                    UTF_VERIFY_EQUAL1_STRING_MAC(pclEpgConfigGet.assignFromUdbsMode, pclEpgConfig.assignFromUdbsMode,
                            "got another mask then was set: %d", pclEpgConfigGet.assignFromUdbsMode);
                }
            }
            /* mode : test invalid enum value */
            if (PRV_CPSS_SIP_6_30_CHECK_MAC(dev))
            {
                /* this field ignored for AC5P, AC5X, Harrier */
                UTF_ENUMS_CHECK_MAC(cpssDxChPclEpgConfigSet
                        (dev,lookupNum,&pclEpgConfig),
                        pclEpgConfig.useSrcTrgMode);
            }
            UTF_ENUMS_CHECK_MAC(cpssDxChPclEpgConfigSet
                    (dev,lookupNum,&pclEpgConfig),
                    pclEpgConfig.assignFromUdbsMode);

            st = cpssDxChPclEpgConfigSet(dev, lookupNum, NULL);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, dev, lookupNum);
        }
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEpgConfigSet(dev, CPSS_PCL_LOOKUP_0_0_E, &pclEpgConfig);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEpgConfigSet(dev, CPSS_PCL_LOOKUP_0_0_E, &pclEpgConfig);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclEpgConfigGet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_DIRECTION_ENT      direction,
    IN  CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum,
    OUT CPSS_DXCH_PCL_EPG_CONFIG_STC   *epgConfigPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclEpgConfigGet)
{
    GT_STATUS                   st;
    GT_U8                       dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum = CPSS_PCL_LOOKUP_0_0_E;
    CPSS_DXCH_PCL_EPG_CONFIG_STC epgConfig;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        st = cpssDxChPclEpgConfigGet(dev, lookupNum, &epgConfig);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        st = cpssDxChPclEpgConfigGet(dev, lookupNum, NULL);
        UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, epgConfig = NULL", dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE             */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_10_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclEpgConfigGet(dev, lookupNum, &epgConfig);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclEpgConfigGet(dev, lookupNum, &epgConfig);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*
GT_STATUS cpssDxChPclGenericActionModeSet
(
    IN GT_U8                                    devNum,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT               lookupNum,
    IN GT_U32                                   hitNum,
    IN CPSS_DXCH_PCL_GENERIC_ACTION_MODE_ENT    genericActionMode
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclGenericActionModeSet)
{
    GT_STATUS                       st, expRc;
    GT_U8                           dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNumArr[]  = {CPSS_PCL_LOOKUP_1_E, CPSS_PCL_LOOKUP_0_0_E, CPSS_PCL_LOOKUP_0_1_E};
    CPSS_PCL_DIRECTION_ENT          direction;
    GT_U32                          ii;
    GT_U32                          maxHitNum, hitNum;
    GT_BOOL                         iPcl0Bypass;
    CPSS_DXCH_PCL_GENERIC_ACTION_MODE_ENT    genericActionMode, genericActionModeGet;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        if(PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.tcam.limitedNumOfParrallelLookups)
        {
            maxHitNum = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.tcam.limitedNumOfParrallelLookups;
        }
        else
        {
            maxHitNum = 4;
        }

        for(direction =  CPSS_PCL_DIRECTION_INGRESS_E;
                direction <= CPSS_PCL_DIRECTION_EGRESS_E;
                direction ++)
        {
            for (ii = 0; ii < sizeof(lookupNumArr)/sizeof(lookupNumArr[0]); ii++)
            {
                lookupNum = lookupNumArr[ii];
                iPcl0Bypass = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.pcl.iPcl0Bypass;
                if(iPcl0Bypass == GT_TRUE && lookupNum == CPSS_PCL_LOOKUP_1_E)
                {
                    lookupNum = CPSS_PCL_LOOKUP_NUMBER_1_E;
                }

                for(hitNum = 0 ; hitNum <= maxHitNum ; hitNum ++)
                {
                    expRc = (hitNum == maxHitNum) ? GT_BAD_PARAM : GT_OK;
                    for(genericActionMode = CPSS_DXCH_PCL_GENERIC_ACTION_MODE_802_1_QCI_E ;
                            genericActionMode <= CPSS_DXCH_PCL_GENERIC_ACTION_MODE_SRC_EPG_E ;
                            genericActionMode ++)
                    {
                        st = cpssDxChPclGenericActionModeSet(dev, lookupNum, hitNum, genericActionMode);
                        UTF_VERIFY_EQUAL4_PARAM_MAC(expRc, st, dev, lookupNum, hitNum, genericActionMode);

                        /* 1.2 Get value and compare with set one. */
                        st = cpssDxChPclGenericActionModeGet(dev, lookupNum, hitNum, &genericActionModeGet);
                        UTF_VERIFY_EQUAL3_PARAM_MAC(expRc, st, dev, lookupNum, hitNum);

                        if(expRc == GT_OK)
                        {
                            /* validation values */
                            UTF_VERIFY_EQUAL1_STRING_MAC(genericActionMode, genericActionModeGet,
                                    "got another genericActionMode then was set: %d", genericActionMode);
                        }
                    }

                    UTF_ENUMS_CHECK_MAC(cpssDxChPclGenericActionModeSet
                            (dev,lookupNum,hitNum,genericActionMode),
                            genericActionMode);
                }
            }
        }
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclGenericActionModeSet(dev, lookupNumArr[0], 0/* hitNum */, CPSS_DXCH_PCL_GENERIC_ACTION_MODE_DST_EPG_E);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclGenericActionModeSet(dev, lookupNumArr[0], 0/* hitNum */, CPSS_DXCH_PCL_GENERIC_ACTION_MODE_DST_EPG_E);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclGenericActionModeGet
(
    IN  GT_U8                       devNum,
    IN CPSS_PCL_LOOKUP_NUMBER_ENT               lookupNum,
    IN GT_U32                                   hitNum,
    OUT CPSS_DXCH_PCL_GENERIC_ACTION_MODE_ENT   *genericActionMode
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclGenericActionModeGet)
{
    GT_STATUS                   st, expRc;
    GT_U8                       dev;
    CPSS_PCL_LOOKUP_NUMBER_ENT  lookupNum = CPSS_PCL_LOOKUP_0_0_E;
    CPSS_PCL_DIRECTION_ENT      direction = CPSS_PCL_DIRECTION_INGRESS_E;
    GT_U32                      maxHitNum, hitNum;
    CPSS_DXCH_PCL_GENERIC_ACTION_MODE_ENT genericActionModeGet;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        if(PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.tcam.limitedNumOfParrallelLookups)
        {
            maxHitNum = PRV_CPSS_DXCH_PP_MAC(dev)->hwInfo.tcam.limitedNumOfParrallelLookups;
        }
        else
        {
            maxHitNum = 4;
        }

        for(hitNum = 0 ; hitNum <= maxHitNum ; hitNum ++)
        {
            expRc = (hitNum == maxHitNum) ? GT_BAD_PARAM : GT_OK;
            st = cpssDxChPclGenericActionModeGet(dev, lookupNum, hitNum, &genericActionModeGet);
            UTF_VERIFY_EQUAL2_PARAM_MAC(expRc, st, dev, direction);

            st = cpssDxChPclGenericActionModeGet(dev, lookupNum, hitNum, NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, epgConfig = NULL", dev);
        }
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE             */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclGenericActionModeGet(dev, lookupNum, 0/*hitNum*/, &genericActionModeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclGenericActionModeGet(dev, lookupNum, 0/*hitNum*/, &genericActionModeGet);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortDestinationEpgConfigSet
(
    IN  GT_U8                                       devNum,
    IN  GT_PHYSICAL_PORT_NUM                        portNum,
    IN  CPSS_DXCH_PCL_PORT_DST_EPG_CONFIG_STC       *portDstEpgConfigPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortDestinationEpgConfigSet)
{
    GT_STATUS                            st = GT_OK;
    GT_PHYSICAL_PORT_NUM                 port;
    GT_U8                                dev;
    CPSS_DXCH_PCL_PORT_DST_EPG_CONFIG_STC portDstEpgConfig, portDstEpgConfigGet;

    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.1. for all active devices go over all available physical ports. */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /* Set the values */
            portDstEpgConfig.dstEpg                = 0x81F;
            portDstEpgConfig.setDstEpgEnable       = GT_TRUE;
            st = cpssDxChPclPortDestinationEpgConfigSet(dev, port, &portDstEpgConfig);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, portDstEpgConfig.dstEpg, portDstEpgConfig.setDstEpgEnable);

            /* Get the values */
            st = cpssDxChPclPortDestinationEpgConfigGet(dev, port, &portDstEpgConfigGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                    "cpssDxChPclLookup0ForRoutedPacketsEnableGet: %d", dev);

            /* verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(portDstEpgConfig.dstEpg, portDstEpgConfigGet.dstEpg,
                    "got another enable then was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(portDstEpgConfig.setDstEpgEnable, portDstEpgConfigGet.setDstEpgEnable,
                    "got another enable then was set: %d", dev);

            /* Set the values */
            portDstEpgConfig.dstEpg                = 0x80F;
            portDstEpgConfig.setDstEpgEnable       = GT_FALSE;
            st = cpssDxChPclPortDestinationEpgConfigSet(dev, port, &portDstEpgConfig);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OK, st, dev, portDstEpgConfig.dstEpg, portDstEpgConfig.setDstEpgEnable);

            /* Get the values */
            st = cpssDxChPclPortDestinationEpgConfigGet(dev, port, &portDstEpgConfigGet);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_OK, st,
                    "cpssDxChPclLookup0ForRoutedPacketsEnableGet: %d", dev);

            /* verifying values */
            UTF_VERIFY_EQUAL1_STRING_MAC(portDstEpgConfig.dstEpg, portDstEpgConfigGet.dstEpg,
                    "got another enable then was set: %d", dev);
            UTF_VERIFY_EQUAL1_STRING_MAC(portDstEpgConfig.setDstEpgEnable, portDstEpgConfigGet.setDstEpgEnable,
                    "got another enable then was set: %d", dev);

            /* Verify Out of range values */
            portDstEpgConfig.dstEpg                = 0xFFF + 1 + port;
            st = cpssDxChPclPortDestinationEpgConfigSet(dev, port, &portDstEpgConfig);
            UTF_VERIFY_EQUAL3_PARAM_MAC(GT_OUT_OF_RANGE, st, dev, portDstEpgConfig.dstEpg, portDstEpgConfig.setDstEpgEnable);
        }

        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.3. Go over non configured ports */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_FALSE))
        {
            /* 1.3.1. Call function for each non configured port.   */
            /* Expected: GT_BAD_PARAM                               */
            st = cpssDxChPclPortDestinationEpgConfigSet(dev, port, &portDstEpgConfig);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
        }

        st = cpssDxChPclPortDestinationEpgConfigSet(dev, port, NULL);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, dev, port);
    }

    /* prepare physical port iterator */
    st = prvUtfNextPhyPortReset(&port, prvTgfDevNum);
    UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

    prvUtfNextPhyPortGet(&port, GT_TRUE);

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclPortDestinationEpgConfigSet(dev, port, &portDstEpgConfig);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortDestinationEpgConfigSet(dev, port, &portDstEpgConfig);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*----------------------------------------------------------------------------*/
/*
GT_STATUS cpssDxChPclPortDestinationEpgConfigGet
(
    IN   GT_U8                                       devNum,
    IN   GT_PHYSICAL_PORT_NUM                        portNum,
    OUT  CPSS_DXCH_PCL_PORT_DST_EPG_CONFIG_STC       *portDstEpgConfigPtr
)
*/
UTF_TEST_CASE_MAC(cpssDxChPclPortDestinationEpgConfigGet)
{
    GT_STATUS               st = GT_OK;
    GT_PHYSICAL_PORT_NUM    port;
    GT_U8                   dev;

    CPSS_DXCH_PCL_PORT_DST_EPG_CONFIG_STC  portDstEpgConfig;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_TRUE))
        {
            /* Set the values */
            st = cpssDxChPclPortDestinationEpgConfigGet(dev, port, &portDstEpgConfig);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

            st = cpssDxChPclPortDestinationEpgConfigGet(dev, port, NULL);
            UTF_VERIFY_EQUAL1_STRING_MAC(GT_BAD_PTR, st, "%d, portDstEpgConfig = NULL", dev);
        }

        /* prepare physical port iterator */
        st = prvUtfNextPhyPortReset(&port, dev);
        UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

        /* 1.3. Go over non configured ports */
        while (GT_OK == prvUtfNextPhyPortGet(&port, GT_FALSE))
        {
            /* 1.3.1. Call function for each non configured port.   */
            /* Expected: GT_BAD_PARAM                               */
            st = cpssDxChPclPortDestinationEpgConfigGet(dev, port, &portDstEpgConfig);
            UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PARAM, st, dev, port);
        }

        st = cpssDxChPclPortDestinationEpgConfigGet(dev, port, NULL);
        UTF_VERIFY_EQUAL2_PARAM_MAC(GT_BAD_PTR, st, dev, port);
    }

    /* prepare physical port iterator */
    st = prvUtfNextPhyPortReset(&port, prvTgfDevNum);
    UTF_VERIFY_EQUAL0_PARAM_MAC(GT_OK, st);

    prvUtfNextPhyPortGet(&port, GT_TRUE);

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_BAD_PARAM.                        */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* go over all non active devices */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st =cpssDxChPclPortDestinationEpgConfigGet(dev, port, &portDstEpgConfig);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3. Call function with out of bound value for device id.*/
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclPortDestinationEpgConfigGet(dev, port, &portDstEpgConfig);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*
GT_STATUS cpssDxChPclMaxSduSizeProfileSet
(
    IN GT_U8                     devNum,
    IN CPSS_PCL_DIRECTION_ENT    direction,
    IN GT_U32                    profileNum,
    IN GT_U32                    maxSduSize
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclMaxSduSizeProfileSet)
{
    /*
        1.1.1 Set API with valid values
              Expected: GT_OK.

        1.1.2 Get API value and compare with set one
              Expected: GT_OK                               .

        1.1.3 Set API with invalid profileNum value
              Expected: GT_BAD_PARAM

        1.1.4 Set API with invalid maxSduSize value
              Expected: GT_OUT_OF_RANGE

        1.1.5 Call API with wrong direction [wrong enum values].
              Expected: GT_BAD_PARAM

        2.1. Call API for none active devices.
        Expected: GT_NOT_APPLICABLE_DEVICE.

        3.1. Call API with out of bound device id.
        Expected: GT_BAD_PARAM.
    */
    GT_STATUS                 st;
    GT_U8                     dev;
    CPSS_PCL_DIRECTION_ENT    direction;
    GT_U32                    profileNum;
    GT_U32                    maxSduSize = 100;
    GT_U32                    maxSduSizeGet = 0;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* Scan Ingress & Egress directions */
        for(direction = CPSS_PCL_DIRECTION_INGRESS_E; direction <= CPSS_PCL_DIRECTION_EGRESS_E; direction++)
        {   /* Scan all 4 profile indexes */
            for (profileNum = 0; profileNum < 4; profileNum++)
            {
                /*
                   1.1.1 Set API with valid values
                   Expected: GT_OK
                */
                st = cpssDxChPclMaxSduSizeProfileSet(dev, direction, profileNum, maxSduSize);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                /*
                   1.1.2 Get API value and compare with set one
                   Expected: GT_OK
                */
                st = cpssDxChPclMaxSduSizeProfileGet(dev, direction, profileNum, &maxSduSizeGet);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                /* Compare get vs set values */
                UTF_VERIFY_EQUAL2_STRING_MAC(maxSduSize, maxSduSizeGet,
                            "got different maxSduSize [%d] then was set [%d]", maxSduSize,maxSduSizeGet);
            }
        }

        /* Set valid values */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        profileNum = 0;

        /*
           1.1.3 Set API with invalid profileNum value
           Expected: GT_BAD_PARAM
        */
        st = cpssDxChPclMaxSduSizeProfileSet(dev, direction, 4, maxSduSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        /*
           1.1.4 Set API with invalid maxSduSize value
           Expected: GT_OUT_OF_RANGE
        */
        st = cpssDxChPclMaxSduSizeProfileSet(dev, direction, 0, BIT_16);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OUT_OF_RANGE, st, dev);

        /*
           1.1.5 Call API with wrong direction [wrong enum values].
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclMaxSduSizeProfileSet(dev, direction, profileNum, maxSduSize), direction);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* Set valid values */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    profileNum = 0;
    maxSduSize = 100;

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclMaxSduSizeProfileSet(dev, direction, profileNum, maxSduSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclMaxSduSizeProfileSet(dev, direction, profileNum, maxSduSize);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*
GT_STATUS cpssDxChPclMaxSduSizeProfileGet
(
    IN  GT_U8                     devNum,
    IN  CPSS_PCL_DIRECTION_ENT    direction,
    IN  GT_U32                    profileNum,
    OUT GT_U32                    maxSduSizePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclMaxSduSizeProfileGet)
{
    /*
        1.1.1 Set API with valid values
              Expected: GT_OK.

        1.1.2 Set API with invalid profileNum value
              Expected: GT_BAD_PARAM

        1.1.3 Call API with NULL pointer of maxSduSize
              Expected: GT_BAD_PTR

        1.1.4 Call API with wrong direction [wrong enum values].
              Expected: GT_BAD_PARAM

        2.1. Call API for none active devices.
        Expected: GT_NOT_APPLICABLE_DEVICE.

        3.1. Call API with out of bound device id.
        Expected: GT_BAD_PARAM.
    */
    GT_STATUS                 st;
    GT_U8                     dev;
    CPSS_PCL_DIRECTION_ENT    direction;
    GT_U32                    profileNum;
    GT_U32                    maxSduSize = 0;

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* Scan Ingress & Egress directions */
        for(direction = CPSS_PCL_DIRECTION_INGRESS_E; direction <= CPSS_PCL_DIRECTION_EGRESS_E; direction++)
        {   /* Scan all 4 profile indexes */
            for (profileNum = 0; profileNum < 4; profileNum++)
            {
                /*
                   1.1.1 Set API with valid values
                   Expected: GT_OK
                */
                st = cpssDxChPclMaxSduSizeProfileGet(dev, direction, profileNum, &maxSduSize);
                UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
            }
        }

        /* Set valid values */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        profileNum = 0;

        /*
           1.1.2 Set API with invalid profileNum value
           Expected: GT_BAD_PARAM
        */
        st = cpssDxChPclMaxSduSizeProfileGet(dev, direction, 4, &maxSduSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);

        /*
           1.1.3 Call API with NULL pointer of maxSduSize.
           Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclMaxSduSizeProfileGet(dev, direction, 0, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

        /*
           1.1.4 Call API with wrong direction [wrong enum values].
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclMaxSduSizeProfileGet(dev, direction, profileNum, &maxSduSize), direction);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* Set valid values */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    profileNum = 0;

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclMaxSduSizeProfileGet(dev, direction, profileNum, &maxSduSize);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclMaxSduSizeProfileGet(dev, direction, profileNum, &maxSduSize);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*
GT_STATUS cpssDxChPclMaxSduSizeExceptionSet
(
    IN GT_U8                       devNum,
    IN CPSS_PCL_DIRECTION_ENT      direction,
    IN CPSS_PACKET_CMD_ENT         command,
    IN CPSS_NET_RX_CPU_CODE_ENT    cpuCode
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclMaxSduSizeExceptionSet)
{
    /*
        1.1.1 Set API with valid values
              Expected: GT_OK.

        1.1.2 Get API value and compare with set one
              Expected: GT_OK                               .

        1.1.3 Call API with invalid command parameter
              Expected: GT_BAD_PARAM

        1.1.4 Verify previous API calls with invalid values didn't overrun last valid command set
              Expected: GT_OK

        1.1.5 Call API with wrong direction [wrong enum values].
              Expected: GT_BAD_PARAM

        1.1.6 Call API with wrong cpuCode [wrong enum values].
              Expected: GT_BAD_PARAM

        2.1. Call API for none active devices.
        Expected: GT_NOT_APPLICABLE_DEVICE.

        3.1. Call API with out of bound device id.
        Expected: GT_BAD_PARAM.
    */
    GT_STATUS                  st;
    GT_U8                      dev;
    CPSS_PCL_DIRECTION_ENT     direction;
    CPSS_NET_RX_CPU_CODE_ENT   cpuCode;
    CPSS_NET_RX_CPU_CODE_ENT   cpuCodeGet;
    GT_U32                     cmdIndx;
    CPSS_PACKET_CMD_ENT        command;
    CPSS_PACKET_CMD_ENT        commandGet;
    CPSS_PACKET_CMD_ENT        lastValidCommandGet = CPSS_PACKET_CMD_FORWARD_E;
    CPSS_PACKET_CMD_ENT        validNoneForwardCommandsArr[5] = { CPSS_PACKET_CMD_FORWARD_E
                                                                 ,CPSS_PACKET_CMD_MIRROR_TO_CPU_E
                                                                 ,CPSS_PACKET_CMD_TRAP_TO_CPU_E
                                                                 ,CPSS_PACKET_CMD_DROP_HARD_E
                                                                 ,CPSS_PACKET_CMD_DROP_SOFT_E };
    CPSS_PACKET_CMD_ENT        invalidCommandsArr[7] = { CPSS_PACKET_CMD_ROUTE_E
                                                        ,CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E
                                                        ,CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E
                                                        ,CPSS_PACKET_CMD_BRIDGE_E
                                                        ,CPSS_PACKET_CMD_NONE_E
                                                        ,CPSS_PACKET_CMD_LOOPBACK_E
                                                        ,CPSS_PACKET_CMD_DEFAULT_ROUTE_ENTRY_E };

    /* Prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /* Scan Ingress & Egress directions */
        for(direction = CPSS_PCL_DIRECTION_INGRESS_E; direction <= CPSS_PCL_DIRECTION_EGRESS_E; direction++)
        {   /* Scan all valid 5 commands */
            for (cmdIndx = 0; cmdIndx < 5; cmdIndx++)
            {   /* Scan user defined cpu codes */
                for(cpuCode = CPSS_NET_USER_DEFINED_0_E; cpuCode < CPSS_NET_LAST_USER_DEFINED_E; cpuCode++)
                {
                    /*
                       1.1.1 Call API with valid values
                       Expected: GT_OK
                    */
                    /* Call API with valid values */
                    st = cpssDxChPclMaxSduSizeExceptionSet(dev, direction, validNoneForwardCommandsArr[cmdIndx], cpuCode);
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                    /*
                       1.1.2 Get API value and compare with set one
                       Expected: GT_OK
                    */
                    /* Get command and cpu code */
                    st = cpssDxChPclMaxSduSizeExceptionGet(dev, direction ,&commandGet, &cpuCodeGet);
                    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

                    /* Compare command get vs set values */
                    UTF_VERIFY_EQUAL0_PARAM_MAC(validNoneForwardCommandsArr[cmdIndx],commandGet);

                    /* For none forward commands, compare cpu drop code get vs set values */
                    if ( validNoneForwardCommandsArr[cmdIndx] !=  CPSS_PACKET_CMD_FORWARD_E)
                    {
                        UTF_VERIFY_EQUAL0_PARAM_MAC(cpuCode, cpuCodeGet);
                    }
                }
            }
        }

        /* Set valid parameters */
        direction = CPSS_PCL_DIRECTION_INGRESS_E;
        command = CPSS_PACKET_CMD_DROP_HARD_E;
        cpuCode = CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E;

        /*
           1.1.3 Call API with invalid command parameter
           Expected: GT_BAD_PARAM
        */
        for(cmdIndx = 0; cmdIndx < 7; cmdIndx++)
        {
            st = cpssDxChPclMaxSduSizeExceptionSet(dev, direction, invalidCommandsArr[cmdIndx], cpuCode);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
        }

        /*
           1.1.4 Verify previous API calls with invalid values didn't overrun last valid command set
           Expected: GT_OK
        */
        /* Save last read of valid command */
        lastValidCommandGet = commandGet;

        /* Get current command value */
        st = cpssDxChPclMaxSduSizeExceptionGet(dev, direction ,&commandGet, &cpuCodeGet);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);

        /* Compare it to last valid command value */
        UTF_VERIFY_EQUAL0_PARAM_MAC(lastValidCommandGet,commandGet);

        /*
           1.1.5 Call API with wrong direction [wrong enum values].
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclMaxSduSizeExceptionSet(dev, direction, command, cpuCode), direction);

        /*
           1.1.6 Call API with wrong cpuCode [wrong enum values].
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclMaxSduSizeExceptionSet(dev, direction, command, cpuCode), cpuCode);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* Set valid parameters */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;
    command = CPSS_PACKET_CMD_DROP_HARD_E;
    cpuCode = CPSS_NET_FIRST_UNKNOWN_HW_CPU_CODE_E;

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclMaxSduSizeExceptionSet(dev, direction, command, cpuCode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclMaxSduSizeExceptionSet(dev, direction, command, cpuCode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}

/*
GT_STATUS cpssDxChPclMaxSduSizeExceptionGet
(
    IN  GT_U8                       devNum,
    IN  CPSS_PCL_DIRECTION_ENT      direction,
    OUT CPSS_PACKET_CMD_ENT         commandPtr,
    OUT CPSS_NET_RX_CPU_CODE_ENT    cpuCodePtr
);
*/
UTF_TEST_CASE_MAC(cpssDxChPclMaxSduSizeExceptionGet)
{
    /*
        1.1.1 Set API with valid values
              Expected: GT_OK.

        1.1.2 Call API with wrong direction [wrong enum values]
              Expected: GT_BAD_PARAM                               .

        1.1.3 Call API with NULL command pointer
              Expected: GT_BAD_PTR

        1.1.4 Call API with NULL cpuCode pointer
              Expected: GT_BAD_PTR

        2.1. Call API for none active devices.
        Expected: GT_NOT_APPLICABLE_DEVICE.

        3.1. Call API with out of bound device id.
        Expected: GT_BAD_PARAM.
    */
    GT_STATUS                  st;
    GT_U8                      dev;
    CPSS_PCL_DIRECTION_ENT     direction;
    CPSS_NET_RX_CPU_CODE_ENT   cpuCode;
    CPSS_PACKET_CMD_ENT        command;


    /* Prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* 1. Go over all active devices. */
    while (GT_OK == prvUtfNextDeviceGet(&dev, GT_TRUE))
    {
        /*
           1.1.1 Call API with valid values
           Expected: GT_OK
        */
        /* Scan Ingress & Egress directions */
        for(direction = CPSS_PCL_DIRECTION_INGRESS_E; direction <= CPSS_PCL_DIRECTION_EGRESS_E; direction++)
        {
            st = cpssDxChPclMaxSduSizeExceptionGet(dev, direction ,&command, &cpuCode);
            UTF_VERIFY_EQUAL1_PARAM_MAC(GT_OK, st, dev);
        }

        /*
           1.1.2 Call API with wrong direction [wrong enum values].
           Expected: GT_BAD_PARAM.
        */
        UTF_ENUMS_CHECK_MAC(cpssDxChPclMaxSduSizeExceptionGet(dev, direction, &command, &cpuCode), direction);

        /*
           1.1.3 Call API with NULL command pointer
           Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclMaxSduSizeExceptionGet(dev, direction, NULL, &cpuCode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);

        /*
           1.1.4 Call API with NULL cpuCode pointer
           Expected: GT_BAD_PTR.
        */
        st = cpssDxChPclMaxSduSizeExceptionGet(dev, direction, &command, NULL);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PTR, st, dev);
    }

    /* 2. For not-active devices and devices from non-applicable family */
    /* check that function returns GT_NOT_APPLICABLE_DEVICE */

    /* prepare device iterator */
    PRV_TGF_APPLIC_DEV_RESET_MAC(&dev, UTF_CPSS_PP_ALL_SIP6_30_CNS);

    /* Set valid parameters */
    direction = CPSS_PCL_DIRECTION_INGRESS_E;

    /* Go over all non active devices. */
    while(GT_OK == prvUtfNextDeviceGet(&dev, GT_FALSE))
    {
        st = cpssDxChPclMaxSduSizeExceptionGet(dev, direction, &command, &cpuCode);
        UTF_VERIFY_EQUAL1_PARAM_MAC(GT_NOT_APPLICABLE_DEVICE, st, dev);
    }

    /* 3.Call with out of bound value for device id */
    dev = PRV_CPSS_MAX_PP_DEVICES_CNS;

    st = cpssDxChPclMaxSduSizeExceptionGet(dev, direction, &command, &cpuCode);
    UTF_VERIFY_EQUAL1_PARAM_MAC(GT_BAD_PARAM, st, dev);
}


/*
 * Configuration of cpssDxChPcl suit
 */
UTF_SUIT_BEGIN_TESTS_MAC(cpssDxChPcl)

    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclUserDefinedByteSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleActionUpdate)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleActionGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleInvalidate)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleValidStatusSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleCopy)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleStateGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleAnyStateGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortIngressPolicyEnable)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortIngressPolicyEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortLookupCfgTabAccessModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclCfgTblAccessModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclCfgTblAccessModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclCfgTblSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclCfgTblGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclIngressPolicyEnable)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclIngressPolicyEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclTwoLookupsCpuCodeResolution)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclInvalidUdbCmdSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclInvalidUdbCmdGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclUserDefinedByteValuesBitmapExpansionModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclUserDefinedByteValuesBitmapExpansionModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclIpLengthCheckModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclIpLengthCheckModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclIpPayloadMinSizeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclIpPayloadMinSizeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclCfgTblEntryGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxCh2PclEgressPolicyEnable)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxCh2PclEgressPolicyEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressForRemoteTunnelStartEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressForRemoteTunnelStartEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxCh3PclTunnelTermForceVlanModeEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxCh3PclTunnelTermForceVlanModeEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxCh2EgressPclPacketTypesSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxCh2EgressPclPacketTypesGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxCh2PclTcpUdpPortComparatorSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxCh2PclTcpUdpPortComparatorGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressTunnelStartPacketsCfgTabAccessModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclUserDefinedByteGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclInit)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressKeyFieldsVidUpModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressKeyFieldsVidUpModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclUdeEtherTypeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclUdeEtherTypeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOverrideUserDefinedBytesEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOverrideUserDefinedBytesEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortLookupCfgTabAccessModeGet)

    /*port group api UT*/
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupOverrideUserDefinedBytesEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupOverrideUserDefinedBytesEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupCfgTblEntryGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupCfgTblSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupCfgTblGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleActionGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleActionUpdate)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleAnyStateGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleCopy)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleInvalidate)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleValidStatusSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupTcpUdpPortComparatorSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupTcpUdpPortComparatorGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupUserDefinedByteSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupUserDefinedByteGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupEgressKeyFieldsVidUpModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupEgressKeyFieldsVidUpModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclL3L4ParsingOverMplsEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclL3L4ParsingOverMplsEnableSet)

    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupLookupCfgPortListEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupLookupCfgPortListEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclLookupCfgPortListEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclLookupCfgPortListEnableSet)

    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclLookup0ForRoutedPacketsEnableSet    )
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclLookup0ForRoutedPacketsEnableGet    )
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclLookup1ForNotRoutedPacketsEnableSet )
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclLookup1ForNotRoutedPacketsEnableGet )
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclIpMinOffsetSet                      )
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclIpMinOffsetGet                      )
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortIngressLookup0Sublookup1TypeSet )
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortIngressLookup0Sublookup1TypeGet )
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortListGroupingEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortListGroupingEnableGet)
    /* Tests filling Tables */
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclFillRuleTable)
    /* Set + Get + Compare tests (all possible formats of rules) */
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleParsedGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRulePortGroupModifiedParsedGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRule_replacedTest)

    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleParsedGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOamChannelTypeProfileToOpcodeMappingSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOamChannelTypeProfileToOpcodeMappingGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOamMegLevelModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOamMegLevelModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOamRdiMatchingSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOamRdiMatchingGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOamEgressPacketDetectionSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOamEgressPacketDetectionGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOamRFlagMatchingSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclOamRFlagMatchingGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclUserDefinedBytesSelectSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclUserDefinedBytesSelectGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressSourcePortSelectionModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressSourcePortSelectionModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressTargetPortSelectionModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressTargetPortSelectionModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclSourceIdMaskSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclSourceIdMaskGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortListPortMappingSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortListPortMappingGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressRxAnalyzerUseOrigVidEnableSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEgressRxAnalyzerUseOrigVidEnableGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclCopyReservedMaskSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclCopyReservedMaskGet)

    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleSet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleActionUpdate_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleActionGet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleInvalidate_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleValidStatusSet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleCopy_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleStateGet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleAnyStateGet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclRuleGet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleActionGet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleActionUpdate_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleAnyStateGet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleCopy_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleGet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleInvalidate_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleSet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleValidStatusSet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclFillRuleTable_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortGroupRuleParsedGet_multiTcam)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclMapCfgTableProfileIdToTcamProfileIdSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclMapCfgTableProfileIdToTcamProfileIdGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortPclId2Set)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortPclId2Get)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclTriggerHashCncClientMaskSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclTriggerHashCncClientMaskGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclFlowIdActionAssignModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclFlowIdActionAssignModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclNumberOfStreamIdsSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclNumberOfStreamIdsGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortEpgConfigSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortEpgConfigGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEpgConfigSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclEpgConfigGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclGenericActionModeSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclGenericActionModeGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortDestinationEpgConfigSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclPortDestinationEpgConfigGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclMaxSduSizeProfileSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclMaxSduSizeProfileGet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclMaxSduSizeExceptionSet)
    UTF_SUIT_DECLARE_TEST_MAC(cpssDxChPclMaxSduSizeExceptionGet)


UTF_SUIT_END_TESTS_MAC(cpssDxChPcl)

/*----------------------------------------------------------------------------*/

/*  Internal function. Is used for filling PCL action structure     */
/*  with default values which are used for most of all tests.       */
static void pclActionDefaultSet
(
    IN CPSS_DXCH_PCL_ACTION_STC     *actionPtr
)
{
/*  actionPtr [ pktCmd = CPSS_PACKET_CMD_MIRROR_TO_CPU_E,
    mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
    matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
    qos { egressPolicy=GT_FALSE, modifyDscp=CPSS_PACKET_ATTRIBUTE_MODIFY_DISABLE_E,
    modifyUp=CPSS_PACKET_ATTRIBUTE_MODIFY_DISABLE_E,
    qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
    profilePrecedence=GT_FALSE] ] },
    redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
    data[routerLttIndex=0] }, policer { policerEnable=GT_FALSE, policerId=0 },
    vlan { egressTaggedModify=GT_FALSE,
    modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
    vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
    ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
*/
    cpssOsBzero((GT_VOID*)actionPtr, sizeof(CPSS_DXCH_PCL_ACTION_STC));

    actionPtr->pktCmd       = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
    actionPtr->actionStop   = GT_TRUE;
    actionPtr->egressPolicy = GT_FALSE;

    actionPtr->mirror.cpuCode = CPSS_NET_CONTROL_SRC_DST_MAC_TRAP_E;
    actionPtr->mirror.mirrorToRxAnalyzerPort = GT_FALSE;
    actionPtr->mirror.mirrorToTxAnalyzerPortEn = GT_FALSE;

    actionPtr->matchCounter.enableMatchCount = GT_FALSE;
    actionPtr->matchCounter.matchCounterIndex = 0;

    actionPtr->qos.ingress.modifyDscp = CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E;
    actionPtr->qos.ingress.modifyUp = CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E;
    actionPtr->qos.ingress.profileIndex = 0;
    actionPtr->qos.ingress.profileAssignIndex = GT_FALSE;
    actionPtr->qos.ingress.profilePrecedence =
                                CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E;

    actionPtr->redirect.redirectCmd = CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_OUT_IF_E;

    actionPtr->redirect.data.outIf.outInterface.type   = CPSS_INTERFACE_VID_E;
    actionPtr->redirect.data.outIf.outInterface.vlanId = 100;

    actionPtr->redirect.data.outIf.vntL2Echo     = GT_FALSE;
    actionPtr->redirect.data.outIf.tunnelStart   = GT_FALSE;
    actionPtr->redirect.data.outIf.tunnelType    =
                            CPSS_DXCH_PCL_ACTION_REDIRECT_TUNNEL_TYPE_ETHERNET_E;

    /* logical Source Port applicable only for xCat C0; xCat3 device */
    actionPtr->redirect.data.logicalSourceInterface.logicalInterface.type = CPSS_INTERFACE_PORT_E;
    actionPtr->redirect.data.logicalSourceInterface.logicalInterface.devPort.hwDevNum = 0;
    actionPtr->redirect.data.logicalSourceInterface.logicalInterface.devPort.portNum = 0;
    actionPtr->redirect.data.logicalSourceInterface.sourceMeshIdSetEnable = GT_FALSE;
    actionPtr->redirect.data.logicalSourceInterface.sourceMeshId = 0;
    actionPtr->redirect.data.logicalSourceInterface.userTagAcEnable = GT_FALSE;

    actionPtr->policer.policerEnable = GT_FALSE;
    actionPtr->policer.policerId     = 0;

    actionPtr->vlan.ingress.modifyVlan = CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E;
    actionPtr->vlan.ingress.nestedVlan = GT_FALSE;
    actionPtr->vlan.ingress.precedence = CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E;
    actionPtr->vlan.ingress.vlanId     = 100;

    actionPtr->ipUcRoute.doIpUcRoute       = GT_FALSE;
    actionPtr->ipUcRoute.arpDaIndex        = 0;
    actionPtr->ipUcRoute.decrementTTL      = GT_FALSE;
    actionPtr->ipUcRoute.bypassTTLCheck    = GT_FALSE;
    actionPtr->ipUcRoute.icmpRedirectCheck = GT_FALSE;

    actionPtr->sourceId.assignSourceId = GT_TRUE;
    actionPtr->sourceId.sourceIdValue  = 0;

    /* oam field applicable only for Bobcat2; Caelum; Bobcat3 device */
    actionPtr->oam.timeStampEnable = GT_FALSE;
    actionPtr->oam.offsetIndex = 0;
    actionPtr->oam.oamProcessEnable = GT_FALSE;
    actionPtr->oam.oamProfile = 0;

    /* flowId field applicable only for Bobcat2; Caelum; Bobcat3 device */
    actionPtr->flowId = 0;

    /* Assigns the unknown-SA-command applicable only for xCat C0; xCat3 device */
    actionPtr->unknownSaCommandEnable = GT_FALSE;
    actionPtr->unknownSaCommand = CPSS_PACKET_CMD_FORWARD_E;

    /* Egress actions related to maximum SDU check and CNC index mode. Applicable only for Ironman */
    actionPtr->egressCncIndexMode = CPSS_DXCH_PCL_ACTION_EGRESS_CNC_INDEX_MODE_HIT_COUNTER_E;
    actionPtr->egressMaxSduSizeProfile = 0;
    actionPtr->enableEgressMaxSduSizeCheck = GT_FALSE;

}

/*----------------------------------------------------------------------------*/

/*  Internal function. Is used to set rule for testing.             */
/*  Set default values for structures and call cpssDxChPclRuleSet.  */
/*  Returns result of  cpssDxChPclRuleSet function.                 */

/*   set rule for testing.
    Call cpssDxChPclRuleSet with
    ruleFormat [CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E],
    ruleIndex [PCL_TESTED_RULE_INDEX], maskPtr-> ruleStdNotIp [0xFF, 0xFF, 0x00, 0x00, ...],
    patternPtr-> ruleStdNotIp [ common[pclId=0; sourcePort=5; isTagged=1;
    vid=100; up=0; qosProfile=0; isIp=0; isL2Valid=1; isUdbValid =1],
    isIpv4 = 0; etherType=0; isArp=0; l2Encap=0; macDa=AB:CD:EF:00:00:02;
    macSa=AB:CD:EF:00:00:01; udb[10,20,30] ],
    actionPtr [ pktCmd = CPSS_PACKET_CMD_FORWARD_E,
    mirror{cpuCode = 0, analyzerPortIndex = GT_FALSE},
    matchCounter { enableMatchCount = GT_FALSE, matchCounterIndex = 0 },
    qos { egressPolicy=GT_FALSE, modifyDscp=GT_FALSE, modifyUp=GT_FALSE ,
    qos [ ingress[profileIndex=0, profileAssignIndex=GT_FALSE,
    profilePrecedence=GT_FALSE] ] },
    redirect { CPSS_DXCH_PCL_ACTION_REDIRECT_CMD_NONE_E,
    data[routerLttIndex=0] }, policer { policerEnable=GT_FALSE, policerId=0 },
    vlan { egressTaggedModify=GT_FALSE,
    modifyVlan=CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E, nestedVlan=GT_FALSE,
    vlanId=100, precedence=CPSS_PACKET_ATTRIBUTE_ASSIGN_PRECEDENCE_SOFT_E },
    ipUcRoute { doIpUcRoute=GT_FALSE, 0, GT_FALSE, GT_FALSE, GT_FALSE } ].
    Expected: GT_OK for Cheetah/Cheetah2  devices and GT_BAD_PARAM for others.
*/
static GT_STATUS pclRuleTestingDefaultSet
(
    IN GT_U8     dev
)
{
    GT_STATUS                           rc;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat;
    GT_U32                              ruleIndex;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT       mask;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT       pattern;
    CPSS_DXCH_PCL_ACTION_STC            action;
    GT_ETHERADDR                        mac1 = {{0xAB, 0xCD, 0xEF, 0x00, 0x00, 0x01}};
    GT_ETHERADDR                        mac2 = {{0xAB, 0xCD, 0xEF, 0x00, 0x00, 0x02}};
    CPSS_PP_FAMILY_TYPE_ENT             devFamily;

    /* check if dev active and Dx Cheetah*/
    PRV_CPSS_DXCH_DEV_CHECK_MAC(dev);

    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E;
    ruleIndex = PCL_TESTED_RULE_INDEX_MAC(dev);

    cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
    pattern.ruleStdNotIp.common.pclId = 0;
    pattern.ruleStdNotIp.common.sourcePort = 5;
    pattern.ruleStdNotIp.common.isTagged = 1;
    pattern.ruleStdNotIp.common.vid = 100;
    pattern.ruleStdNotIp.common.up = 0;
    pattern.ruleStdNotIp.common.qosProfile = 0;
    pattern.ruleStdNotIp.common.isIp = 0;
    pattern.ruleStdNotIp.common.isL2Valid = 1;
    pattern.ruleStdNotIp.common.isUdbValid = 1;
    pattern.ruleStdNotIp.isIpv4 = 0;
    pattern.ruleStdNotIp.etherType = 0;
    pattern.ruleStdNotIp.isArp = 0;
    pattern.ruleStdNotIp.l2Encap = 0;
    pattern.ruleStdNotIp.macDa = mac2;
    pattern.ruleStdNotIp.macSa = mac1;
    pattern.ruleStdNotIp.udb15_17[0] = 10;
    pattern.ruleStdNotIp.udb15_17[1] = 20;
    pattern.ruleStdNotIp.udb15_17[2] = 30;

    cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
    mask.ruleStdNotIp = pattern.ruleStdNotIp;
    mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/
    mask.ruleStdNotIp.common.sourcePort = 0x3F;


    pclActionDefaultSet(&action);

    prvUtfDeviceFamilyGet(dev, &devFamily);
    if (devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
    {   /* 'disable' not supported on CHEETAH 3 */
        action.qos.ingress.modifyDscp = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;
        action.qos.ingress.modifyUp   = CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E;
    }

    rc = cpssDxChPclRuleSet(
        dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, 0 /*ruleOptionsBmp*/,
        &mask, &pattern, &action);
    if (rc != GT_OK)
    {
        PRV_UTF_LOG3_MAC(
            "pclRuleTestingDefaultSet failed: dev %d, ruleFormat %d, ruleIndex %d",
            dev, ruleFormat, ruleIndex);
    }

    cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
    cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
    mask.ruleStdNotIp.common.pclId = 0x3FF;/*10 bits*/

    ruleIndex = 0;
    ruleFormat = CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E;
    rc = cpssDxChPclRuleSet(
        dev, mainUtCpssDxChPclTcamIndex, ruleFormat, ruleIndex, 0 /*ruleOptionsBmp*/,
        &mask, &pattern, &action);
    if (rc != GT_OK)
    {
        PRV_UTF_LOG3_MAC(
            "pclRuleTestingDefaultSet failed: dev %d, ruleFormat %d, ruleIndex %d",
            dev, ruleFormat, ruleIndex);
    }

    return GT_OK;
}

static GT_STATUS pclRuleOverride
(
    IN GT_U8     dev,
    IN GT_BOOL   oldRuleExt,
    IN GT_BOOL   newRuleExt,
    IN GT_BOOL   valid,
    IN GT_U32    oldRuleIndex
)
{
    GT_STATUS                           rc;
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT       mask;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT       pattern;
    CPSS_DXCH_PCL_ACTION_STC            action;
    CPSS_DXCH_PCL_RULE_OPTION_ENT       ruleOptionsBmp;
    GT_U32                              newRuleIndex;
    GT_U32                              oldRuleAlignment;
    GT_U32                              newRuleAlignment;
    GT_U32                              absRuleIndex;
    GT_U32                              tcamRowsAmount;
    CPSS_PP_FAMILY_TYPE_ENT             devFamily;

    rc = prvUtfDeviceFamilyGet(dev, &devFamily);
    if (rc != GT_OK)
    {
        PRV_UTF_LOG1_MAC(
            "pclRuleOverride failed: wrong dev %d,\n", dev);
        return rc;
    }

    if (oldRuleExt == newRuleExt)
    {
        newRuleIndex = oldRuleIndex;
    }
    else if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev))
    {
        newRuleAlignment = ((newRuleExt == GT_FALSE) ? 3 : 6);
        newRuleIndex = oldRuleIndex - (oldRuleIndex % newRuleAlignment);
    }
    else if (devFamily >= CPSS_PP_FAMILY_DXCH_XCAT_E)
    {
        oldRuleAlignment = ((oldRuleExt == GT_FALSE) ? 1 : 2);
        newRuleAlignment = ((newRuleExt == GT_FALSE) ? 1 : 2);
        newRuleIndex = (oldRuleIndex * oldRuleAlignment) / newRuleAlignment;
    }
    else if (devFamily == CPSS_PP_FAMILY_CHEETAH3_E)
    {
        tcamRowsAmount = PCL_TCAM_RAWS(dev);
        if (oldRuleExt == GT_FALSE)
        {
            absRuleIndex = oldRuleIndex;
        }
        else
        {
            absRuleIndex = oldRuleIndex;
            if (oldRuleIndex >= tcamRowsAmount)
            {
                absRuleIndex += tcamRowsAmount;
            }
        }
        if (newRuleExt == GT_FALSE)
        {
            newRuleIndex = absRuleIndex;
        }
        else
        {
            newRuleIndex = absRuleIndex % tcamRowsAmount;
            if (absRuleIndex >= (2 * tcamRowsAmount))
            {
                newRuleIndex += tcamRowsAmount;
            }
        }
    }
    else
    {
        /* CH1 and CH2 */
        absRuleIndex = oldRuleIndex; /* both STD and EXT */
        newRuleIndex =
            (newRuleExt == GT_FALSE)
                 ? absRuleIndex
                 : (absRuleIndex % 512);
    }

    ruleFormat =
        (newRuleExt == GT_FALSE)
            ? CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E
            : CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E;

    ruleOptionsBmp =
         ((valid != GT_FALSE) ? 0
            : CPSS_DXCH_PCL_RULE_OPTION_WRITE_INVALID_E);

    cpssOsBzero((GT_VOID*)&pattern, sizeof(pattern));
    cpssOsBzero((GT_VOID*)&mask, sizeof(mask));
    cpssOsBzero((GT_VOID*)&action, sizeof(action));
    action.pktCmd = CPSS_PACKET_CMD_DROP_HARD_E;

    if (UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(dev) == GT_TRUE)
    {
        /* the CPU_CODE is used as 'Drop code' for 'soft/hard' drop ,
           and since action.mirror.cpuCode = 0 is not valid , we set DUMMY value.
        */
        action.mirror.cpuCode = CPSS_NET_ETH_BRIDGED_LLT_E;
    }

    rc = cpssDxChPclRuleSet(
        dev, mainUtCpssDxChPclTcamIndex, ruleFormat, newRuleIndex, ruleOptionsBmp,
        &mask, &pattern, &action);

    if (rc != GT_OK)
    {
        PRV_UTF_LOG5_MAC(
            "pclRuleOverride failed: dev %d,\n"
            "oldRuleExt %d, newRuleExt %d \n"
            "valid %d oldRuleIndex %d\n",
            dev, oldRuleExt, newRuleExt,
            valid, oldRuleIndex);
        return rc;
    }

    return GT_OK;
}

static GT_STATUS pclRulesForCopyAndStatusTesting
(
    IN GT_U8     dev
)
{
    GT_STATUS st, st1;
    GT_U32 correctStdRuleIndex;
    GT_U32 correctExtRuleIndex;
    GT_U32 damagedStdRuleIndex;
    GT_U32 damagedExtRuleIndex;

    st = GT_OK;
    correctStdRuleIndex = PCL_CORRECT_STD_RULE_INDEX_MAC(dev);
    correctExtRuleIndex = PCL_CORRECT_EXT_RULE_INDEX_MAC(dev);
    damagedStdRuleIndex = PCL_DAMAGED_STD_RULE_INDEX_MAC(dev);
    damagedExtRuleIndex = PCL_DAMAGED_EXT_RULE_INDEX_MAC(dev);

    st1 = pclRuleOverride(
        dev, GT_FALSE /*oldRuleExt*/,
        GT_FALSE /*newRuleExt*/,
        GT_TRUE /*valid*/, correctStdRuleIndex);
    if (st1 != GT_OK) st = st1;

    st1 = pclRuleOverride(
        dev, GT_TRUE /*oldRuleExt*/,
        GT_TRUE /*newRuleExt*/,
        GT_TRUE /*valid*/, correctExtRuleIndex);
    if (st1 != GT_OK) st = st1;

    st1 = pclRuleOverride(
        dev, GT_FALSE /*oldRuleExt*/,
        GT_TRUE /*newRuleExt*/,
        GT_TRUE /*valid*/, damagedStdRuleIndex);
    if (st1 != GT_OK) st = st1;

    st1 = pclRuleOverride(
        dev, GT_TRUE /*oldRuleExt*/,
        GT_FALSE /*newRuleExt*/,
        GT_TRUE /*valid*/, damagedExtRuleIndex);
    if (st1 != GT_OK) st = st1;

    return st;
}


/* testing Rule filling functions               */
/* muxed fields bypassed                        */
/* All not muxed fields will got value:         */
/* params                                       */
/* fullFill == 0 - 1, otherwize - maxValue      */
/* ruleFlags                                    */
/*                                              */
/* Two rools to be tested                       */
/* Rule0 - mask0 - filled by max values         */
/* pattern0 filled by ones                      */
/* Rule1 - Mask1 = Mask0                        */
/* pattern1 = ((pattern0 ^ Mask0) & Mask0)      */

static GT_VOID pclRuleTestFill_IngrCommon
(
    IN  GT_U32                               fullFill,
    IN  GT_U32                               ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_COMMON_STC *commonPtr
)
{
    commonPtr->pclId           = fullFill ? 0x3FF : 1;
    commonPtr->macToMe         = 1;
    if ((ruleFlags & PRV_RF_NO_INGR_SRC_PORT_CNS) == 0)
    {
        commonPtr->sourcePort      =
            fullFill ? ((ruleFlags & PRV_RF_SIP5_CNS) ? 0xFF :
                PRV_CPSS_IS_DUAL_HW_DEVICE_MAC(PRV_CPSS_PP_MAC(currentTestedDevNum)->hwDevNum) ? 0x7F : 0x3F) : 1;


    }
    /* muxed and ommited - commonPtr->portListBmp     ;*/
    if (ruleFlags & PRV_RF_USE_PORTS_BMP_CNS)
    {
        /* use the ports bmp */
        PORTS_BMP_FILL_MAC(commonPtr->portListBmp);
       /* portListBmp[7:0] is muxed with pclId[7:0],
          portListBmp[15:8] is muxed with sourcePort[7:0]
          portListBmp[27:16] is muxed with sourceTrunkId.*/
       U32_SET_FIELD_MAC(commonPtr->sourcePort,0,8,0);
       if (ruleFlags & PRV_RF_SIP5_CNS)
       {
           U32_SET_FIELD_MAC(commonPtr->sourceDevice,0,10,0);
       }
       U32_SET_FIELD_MAC(commonPtr->pclId,0,8,0);
    }


    commonPtr->isTagged        = 1;
    commonPtr->vid             =
        fullFill ? 0xFFF : 1;
    commonPtr->up              = fullFill ? 0x7 : 1;
    commonPtr->qosProfile      = fullFill ? 0x7F : 1;
    commonPtr->isIp            = 1;
    commonPtr->isL2Valid       = 1;
    commonPtr->isUdbValid      = 1;
}

static GT_VOID pclRuleTestFill_IngrExtCommon
(
    IN  GT_U32                                   fullFill,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_COMMON_EXT_STC *comnonExtPtr
)
{
    comnonExtPtr->isIpv6       = 1;
    comnonExtPtr->ipProtocol   = fullFill ? 0xFF : 1;
    comnonExtPtr->dscp         = fullFill ? 0x3F : 1;
    comnonExtPtr->isL4Valid    = 1;
    comnonExtPtr->l4Byte0      = (GT_U8) (fullFill ? 0xFF : 1);
    comnonExtPtr->l4Byte1      = (GT_U8) (fullFill ? 0xFF : 1);
    comnonExtPtr->l4Byte2      = (GT_U8) (fullFill ? 0xFF : 1);
    comnonExtPtr->l4Byte3      = (GT_U8) (fullFill ? 0xFF : 1);
    comnonExtPtr->l4Byte13     = (GT_U8) (fullFill ? 0xFF : 1);
    comnonExtPtr->ipHeaderOk   = 1;
}

static GT_VOID pclRuleTestFill_IngrStdIpCommon
(
    IN  GT_U32                                      fullFill,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_COMMON_STD_IP_STC *comnonStdIpPtr
)
{
    comnonStdIpPtr->isIpv4           = 1;
    comnonStdIpPtr->ipProtocol       = fullFill ? 0xFF : 1;
    comnonStdIpPtr->dscp             = fullFill ? 0x3F : 1;
    comnonStdIpPtr->isL4Valid        = 1;
    comnonStdIpPtr->l4Byte2          = (GT_U8) (fullFill ? 0xFF : 1);
    comnonStdIpPtr->l4Byte3          = (GT_U8) (fullFill ? 0xFF : 1);
    comnonStdIpPtr->ipHeaderOk       = 1;
    comnonStdIpPtr->ipv4Fragmented   = 1;
}

static GT_VOID pclRuleTestFill_IngrStdNotIp
(
    IN  GT_U32                                   fullFill,
    IN  GT_U32                                   ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_STD_NOT_IP_STC *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_IngrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    rulePtr->isIpv4       = 1;
    rulePtr->etherType    = (GT_U16) (fullFill ? 0xFFFF : 1);
    rulePtr->isArp        = 1;
    rulePtr->l2Encap      =
        ((ruleFlags & PRV_RF_2BIT_L2ENCAP_CNS) && fullFill) ? 0x3 : 1;
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macDa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macSa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 3); i++)
    {
        rulePtr->udb15_17[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    /* muxed and ommited rulePtr->vrfId; */
    /* muxed and ommited rulePtr->trunkHash; */
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        /* drop UDB16 muxed with tag1Exist, vid1, cfi1 */
        rulePtr->udb15_17[1] = 0;
        rulePtr->tag1Exist  = 1;
        rulePtr->vid1       = fullFill ? 0xFFF : 1;
        rulePtr->up1        = fullFill ? 0x7 : 1;
        rulePtr->cfi1       = 1;
        for (i = 0; (i < 4); i++)
        {
            rulePtr->udb23_26[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
}

static GT_VOID pclRuleTestFill_IngrStdIpL2Qos
(
    IN  GT_U32                                      fullFill,
    IN  GT_U32                                      ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_STD_IP_L2_QOS_STC *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_IngrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    pclRuleTestFill_IngrStdIpCommon(
        fullFill, &(rulePtr->commonStdIp));
    rulePtr->isArp                = 1;
    rulePtr->isIpv6ExtHdrExist    = 1;
    rulePtr->isIpv6HopByHop       = 1;
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macDa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macSa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 2); i++)
    {
        rulePtr->udb18_19[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        for (i = 0; (i < 4); i++)
        {
            rulePtr->udb27_30[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
    /* muxed and ommited rulePtr->vrfId; */
}

static GT_VOID pclRuleTestFill_IngrStdIpv4L4
(
    IN  GT_U32                                      fullFill,
    IN  GT_U32                                      ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_STD_IPV4_L4_STC   *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_IngrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    pclRuleTestFill_IngrStdIpCommon(
        fullFill, &(rulePtr->commonStdIp));
    rulePtr->isArp                = 1;
    rulePtr->isBc                 = 1;
    for (i = 0; (i < 4); i++)
    {
        rulePtr->sip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 4); i++)
    {
        rulePtr->dip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    rulePtr->l4Byte0         = (GT_U8) (fullFill ? 0xFF : 1);
    rulePtr->l4Byte1         = (GT_U8) (fullFill ? 0xFF : 1);
    rulePtr->l4Byte13        = (GT_U8) (fullFill ? 0xFF : 1);
    for (i = 0; (i < 3); i++)
    {
        rulePtr->udb20_22[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        for (i = 0; (i < 4); i++)
        {
            rulePtr->udb31_34[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
    /* muxed and ommited rulePtr->vrfId; */
    /* muxed and ommited rulePtr->trunkHash; */
}

static GT_VOID pclRuleTestFill_IngrStdIpv6Dip
(
    IN  GT_U32                                      fullFill,
    IN  GT_U32                                      ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_STD_IPV6_DIP_STC  *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_IngrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    /* drop fields not relevant to STD_IPV6_DIP */
    rulePtr->common.isUdbValid = 0;
    pclRuleTestFill_IngrStdIpCommon(
        fullFill, &(rulePtr->commonStdIp));
    /* drop fields not relevant to STD_IPV6_DIP */
    rulePtr->commonStdIp.l4Byte2        = 0;
    rulePtr->commonStdIp.l4Byte3        = 0;
    rulePtr->commonStdIp.ipv4Fragmented = 0;
    rulePtr->isArp                = 1;
    rulePtr->isIpv6ExtHdrExist    = 1;
    rulePtr->isIpv6HopByHop       = 1;
    for (i = 0; (i < 16); i++)
    {
        rulePtr->dip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        for (i = 0; (i < 3); i++)
        {
            rulePtr->udb47_49[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
        rulePtr->udb0 = (GT_U8) (fullFill ? 0xFF : 1);
    }
}

static GT_VOID pclRuleTestFill_IngrExtNotIpv6
(
    IN  GT_U32                                     fullFill,
    IN  GT_U32                                     ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_IngrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    pclRuleTestFill_IngrExtCommon(
        fullFill, &(rulePtr->commonExt));
    for (i = 0; (i < 4); i++)
    {
        rulePtr->sip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 4); i++)
    {
        rulePtr->dip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    rulePtr->etherType    = (GT_U16) (fullFill ? 0xFFFF : 1);
    rulePtr->l2Encap      =
        ((ruleFlags & PRV_RF_2BIT_L2ENCAP_CNS) && fullFill) ? 0x3 : 1;
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macDa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macSa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    rulePtr->ipv4Fragmented      = 1;
    for (i = 0; (i < 6); i++)
    {
        rulePtr->udb0_5[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    /* muxed and ommited rulePtr->vrfId; */
    /* muxed and ommited rulePtr->trunkHash; */
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        rulePtr->tag1Exist  = 1;
        rulePtr->vid1       = fullFill ? 0xFFF : 1;
        rulePtr->up1        = fullFill ? 0x7 : 1;
        rulePtr->cfi1       = 1;
        for (i = 0; (i < 8); i++)
        {
            rulePtr->udb39_46[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }

    }
}

static GT_VOID pclRuleTestFill_IngrExtIpv6L2
(
    IN  GT_U32                                     fullFill,
    IN  GT_U32                                     ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L2_STC  *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_IngrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    pclRuleTestFill_IngrExtCommon(
        fullFill, &(rulePtr->commonExt));
    for (i = 0; (i < 16); i++)
    {
        rulePtr->sip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    rulePtr->dipBits127to120 = (GT_U8) (fullFill ? 0xFF : 1);
    rulePtr->isIpv6ExtHdrExist    = 1;
    rulePtr->isIpv6HopByHop       = 1;
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macDa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macSa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 6); i++)
    {
        rulePtr->udb6_11[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    /* muxed and ommited rulePtr->vrfId; */
    /* muxed and ommited rulePtr->trunkHash; */
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        rulePtr->tag1Exist  = 1;
        rulePtr->vid1       = fullFill ? 0xFFF : 1;
        rulePtr->up1        = fullFill ? 0x7 : 1;

        for (i = 0; (i < 3); i++)
        {
            rulePtr->udb47_49[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
        for (i = 0; (i < 5); i++)
        {
            rulePtr->udb0_4[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
}

static GT_VOID pclRuleTestFill_IngrExtIpv6L4
(
    IN  GT_U32                                     fullFill,
    IN  GT_U32                                     ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L4_STC  *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_IngrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    pclRuleTestFill_IngrExtCommon(
        fullFill, &(rulePtr->commonExt));
    for (i = 0; (i < 16); i++)
    {
        rulePtr->sip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 16); i++)
    {
        rulePtr->dip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    rulePtr->isIpv6ExtHdrExist    = 1;
    rulePtr->isIpv6HopByHop       = 1;
    for (i = 0; (i < 3); i++)
    {
        rulePtr->udb12_14[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    /* muxed and ommited rulePtr->vrfId; */
    /* muxed and ommited rulePtr->trunkHash; */
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        rulePtr->tag1Exist  = 1;
        rulePtr->vid1       = fullFill ? 0xFFF : 1;
        rulePtr->up1        = fullFill ? 0x7 : 1;

        for (i = 0; (i < 8); i++)
        {
            rulePtr->udb15_22[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
}

static GT_VOID pclRuleTestFill_IngrUdbCommon
(
    IN  GT_U32                                           fullFill,
    IN  GT_U32                                           ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_COMMON_STC *commonPtr
)
{
    commonPtr->pclId            = fullFill ? 0x3FF : 1;
    commonPtr->macToMe          = 1;
    if ((ruleFlags & PRV_RF_NO_INGR_SRC_PORT_CNS) == 0)
    {
        commonPtr->sourcePort      =
            fullFill ? ((ruleFlags & PRV_RF_SIP5_CNS) ? 0xFF :
                PRV_CPSS_IS_DUAL_HW_DEVICE_MAC(PRV_CPSS_PP_MAC(currentTestedDevNum)->hwDevNum) ? 0x7F : 0x3F) : 1;
    }

    /* muxed and ommited - commonPtr->portListBmp     ;*/
    if (ruleFlags & PRV_RF_USE_PORTS_BMP_CNS)
    {
        /* use the ports bmp */
        PORTS_BMP_FILL_MAC(commonPtr->portListBmp);
       /* portListBmp[7:0] is muxed with pclId[7:0],
          portListBmp[15:8] is muxed with sourcePort[7:0]
          portListBmp[27:16] is muxed with sourceTrunkId.*/
       U32_SET_FIELD_MAC(commonPtr->sourcePort,0,8,0);
       if (ruleFlags & PRV_RF_SIP5_CNS)
       {
           U32_SET_FIELD_MAC(commonPtr->sourceDevice,0,10,0);
       }
       U32_SET_FIELD_MAC(commonPtr->pclId,0,8,0);
    }

    commonPtr->vid              =
        fullFill ? 0xFFF : 1;
    commonPtr->up               = fullFill ? 0x7 : 1;
    commonPtr->isIp             = 1;
    commonPtr->dscpOrExp        = fullFill ? 0x3F : 1;
    commonPtr->isL2Valid        = 1;
    commonPtr->isUdbValid       = 1;
    commonPtr->pktTagging       = fullFill ? 0x3 : 1;
    commonPtr->l3OffsetInvalid  = 1;
    commonPtr->l4ProtocolType   = fullFill ? 0x3 : 1;
    commonPtr->pktType          = fullFill ? 0xFF : 1;
    commonPtr->ipHeaderOk       = 1;
    commonPtr->macDaType        = fullFill ? 0x3 : 1;
    commonPtr->l4OffsetInvalid  = 1;
    commonPtr->l2Encapsulation  = fullFill ? 0x3 : 1;
    commonPtr->isIpv6Eh         = 1;
    commonPtr->isIpv6HopByHop   = 1;
}

static GT_VOID pclRuleTestFill_IngrStdUdb
(
    IN  GT_U32                                              fullFill,
    IN  GT_U32                                              ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STANDARD_UDB_STC  *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_IngrUdbCommon(
        fullFill, ruleFlags, &(rulePtr->commonIngrUdb));
    rulePtr->isIpv4    = 1;
    for (i = 0; (i < 16); i++)
    {
        rulePtr->udb0_15[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    /* muxed and ommited rulePtr->vrfId;      */
    /* muxed and ommited rulePtr->qosProfile; */
    /* muxed and ommited rulePtr->trunkHash;  */
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        for (i = 0; (i < 4); i++)
        {
            rulePtr->udb35_38[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
}

static GT_VOID pclRuleTestFill_IngrUdbOnly
(
    IN GT_U8    dev,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT                  ruleFormat,
    IN  GT_U32                                              fullFill,
    IN  GT_U32                                              ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_ONLY_STC     *rulePtr
)
{
    GT_U32 i; /* loop index */
    GT_U32 udbNum; /* number of used UDBs */
    ruleFlags = ruleFlags; /* to aviod compilation warnings */

    dev = dev;/* currently unused */

    udbNum = (ruleFormat == CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E) ? 50 :
                (ruleFormat - CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E + 1) * 10;
    if((CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_NO_FIXED_FIELDS_E == ruleFormat)
       && PRV_CPSS_SIP_5_20_CHECK_MAC(dev))
    {
        udbNum = 50;
    }

    if (udbNum > CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS)
    {
        UTF_VERIFY_EQUAL1_STRING_MAC(0, udbNum, "udbNum [%d] overflow", udbNum);
        return;
    }

    for (i = 0; (i < udbNum); i++)
    {
        rulePtr->udb[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    /* muxed and ommited rulePtr->replacedFld;      */
    /* UDB60 fixed fields */
    if (ruleFormat == CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E)
    {
        rulePtr->udb60FixedFld.flowId     = (fullFill ? 0xFFF/*(MAX_FLOW_ID(dev)-1)*/ : 1);
        rulePtr->udb60FixedFld.isUdbValid = 1;
        rulePtr->udb60FixedFld.macToMe    = 1;
        rulePtr->udb60FixedFld.pclId      = (fullFill ? 0x3FF : 1);
        rulePtr->udb60FixedFld.qosProfile = (fullFill ? 0x3FF : 1);
        rulePtr->udb60FixedFld.srcDevIsOwn = 1;
        rulePtr->udb60FixedFld.srcPort    = (fullFill ? 0x1FFF : 1);
        rulePtr->udb60FixedFld.up1        = (fullFill ? 0x7 : 1);
        rulePtr->udb60FixedFld.vid        = (fullFill ? 0x1FFF : 1);
        rulePtr->udb60FixedFld.vid1       = (fullFill ? 0xFFF : 1);
    }
}

static GT_VOID pclRuleTestFill_EgrUdbOnly
(
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT                  ruleFormat,
    IN  GT_U32                                              fullFill,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_ONLY_STC      *rulePtr
)
{
    GT_U32 i; /* loop index */
    GT_U32 udbNum; /* number of used UDBs */

    udbNum = (ruleFormat == CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E) ? 50 :
                (ruleFormat - CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E + 1) * 10;

    if (udbNum > CPSS_DXCH_PCL_UDB_MAX_NUMBER_CNS)
    {
        UTF_VERIFY_EQUAL1_STRING_MAC(0, udbNum, "udbNum [%d] overflow", udbNum);
        return;
    }

    for (i = 0; (i < udbNum); i++)
    {
        rulePtr->udb[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    /* muxed and ommited rulePtr->replacedFld;      */
    /* UDB60 fixed fields */
    if (ruleFormat == CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E)
    {
        rulePtr->udb60FixedFld.isUdbValid = 1;
        rulePtr->udb60FixedFld.pclId      = (fullFill ? 0x3FF : 1);
        rulePtr->udb60FixedFld.srcPort    = (fullFill ? 0x1FFF : 1);
        rulePtr->udb60FixedFld.vid        = (fullFill ? 0x1FFF : 1);
        rulePtr->udb60FixedFld.trgPort    = (fullFill ? 0x1FFF : 1);
        rulePtr->udb60FixedFld.srcDev     = (fullFill ? 0x3FF : 1);
        rulePtr->udb60FixedFld.trgDev     = (fullFill ? 0x3FF : 1);
        rulePtr->udb60FixedFld.localDevTrgPhyPort = (fullFill ? 0xFF : 1);
    }
}

static GT_VOID pclRuleTestFill_IngrExtUdb
(
    IN  GT_U32                                              fullFill,
    IN  GT_U32                                              ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXTENDED_UDB_STC  *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_IngrUdbCommon(
        fullFill, ruleFlags, &(rulePtr->commonIngrUdb));
    rulePtr->isIpv6    = 1;
    rulePtr->ipProtocol    = fullFill ? 0xFF : 1;
    for (i = 0; (i < 4); i++)
    {
        rulePtr->sipBits31_0[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 6); i++)
    {
        rulePtr->sipBits79_32orMacSa[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 6); i++)
    {
        rulePtr->sipBits127_80orMacDa[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 2); i++)
    {
        rulePtr->dipBits127_112[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 4); i++)
    {
        rulePtr->dipBits31_0[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 16); i++)
    {
        rulePtr->udb0_15[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    /* muxed and ommited rulePtr->vrfId;      */
    /* muxed and ommited rulePtr->qosProfile; */
    /* muxed and ommited rulePtr->trunkHash;  */
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        rulePtr->tag1Exist  = 1;
        rulePtr->vid1       = fullFill ? 0xFFF : 1;
        rulePtr->up1        = fullFill ? 0x7 : 1;
        rulePtr->cfi1       = 1;

        for (i = 0; (i < 8); i++)
        {
            rulePtr->udb23_30[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
}

static GT_VOID pclRuleTestFill_EgrCommon
(
    IN  GT_U32                                       fullFill,
    IN  GT_U32                                       ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_COMMON_STC  *commonPtr
)
{
    if (ruleFlags & PRV_RF_EGR_VALID_CNS)
    {
        commonPtr->valid = 1;
    }
    commonPtr->pclId           = fullFill ? 0x3FF : 1;
    commonPtr->sourcePort      =
        fullFill ? ((ruleFlags & PRV_RF_SIP5_CNS) ? 0xFF : 0x3F) : 1;
    /* muxed and ommited - commonPtr->portListBmp     ;*/
    commonPtr->isTagged        = 1;
    commonPtr->vid             =
        fullFill ? 0xFFF : 1;
    commonPtr->up              = fullFill ? 0x7 : 1;
    commonPtr->isIp            = 1;
    commonPtr->isL2Valid       = 1;
    commonPtr->egrPacketType   = fullFill ? 0x3 : 1;
    /* muxed and ommited commonPtr-> */
    /* muxed and ommited commonPtr-> */
    /* muxed and ommited commonPtr-> */
    /* muxed and ommited commonPtr-> */
    /* muxed and ommited commonPtr-> */
    /* muxed and ommited commonPtr->toCpu.cpuCode */
    /* muxed and ommited commonPtr->toCpu.srcTrg */
    /* muxed and ommited commonPtr->fromCpu.tc */
    /* muxed and ommited commonPtr->fromCpu.dp */
    /* muxed and ommited commonPtr->fromCpu.egrFilterEnable */
    /* muxed and ommited commonPtr->toAnalyzer.rxSniff */
    commonPtr->fwdData.qosProfile      = fullFill ? 0x7F : 1;
    /* muxed and ommited commonPtr->fwdData.srcTrunkId */
    commonPtr->fwdData.srcIsTrunk     = 1;
    commonPtr->fwdData.isUnknown      = 1;
    commonPtr->fwdData.isRouted       = 1;
    commonPtr->srcHwDev       =
        fullFill ? 0x1F : 1;
    commonPtr->sourceId     =
        fullFill ? 0x1F : 1;
    commonPtr->isVidx       = 1;
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        commonPtr->tag1Exist  = 1;
    }
}

static GT_VOID pclRuleTestFill_EgrCommonExt
(
    IN  GT_U32                                           fullFill,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_COMMON_EXT_STC  *commonPtr
)
{
    commonPtr->isIpv6                   = 1;
    commonPtr->ipProtocol               = fullFill ? 0xFF : 1;
    commonPtr->dscp                     = fullFill ? 0x3F : 1;
    commonPtr->isL4Valid                = 1;
    commonPtr->l4Byte0                  = (GT_U8) (fullFill ? 0xFF : 1);
    commonPtr->l4Byte1                  = (GT_U8) (fullFill ? 0xFF : 1);
    commonPtr->l4Byte2                  = (GT_U8) (fullFill ? 0xFF : 1);
    commonPtr->l4Byte3                  = (GT_U8) (fullFill ? 0xFF : 1);
    commonPtr->l4Byte13                 = (GT_U8) (fullFill ? 0xFF : 1);
    commonPtr->egrTcpUdpPortComparator  = fullFill ? 0xFF : 1;
}

static GT_VOID pclRuleTestFill_EgrCommonStdIp
(
    IN  GT_U32                                              fullFill,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_COMMON_STD_IP_STC  *commonPtr
)
{
    commonPtr->isIpv4                   = 1;
    commonPtr->ipProtocol               = fullFill ? 0xFF : 1;
    commonPtr->dscp                     = fullFill ? 0x3F : 1;
    commonPtr->isL4Valid                = 1;
    commonPtr->l4Byte2                  = (GT_U8) (fullFill ? 0xFF : 1);
    commonPtr->l4Byte3                  = (GT_U8) (fullFill ? 0xFF : 1);
    commonPtr->ipv4Fragmented           = 1;
    commonPtr->egrTcpUdpPortComparator  = fullFill ? 0xFF : 1;
}

static GT_VOID pclRuleTestFill_EgrStdNotIp
(
    IN  GT_U32                                           fullFill,
    IN  GT_U32                                           ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_STC  *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_EgrCommon(
        fullFill, ruleFlags, &(rulePtr->common));

    rulePtr->common.sourcePort      &= 0x3f;/*limited to 6 bits*/

    rulePtr->isIpv4       = 1;
    rulePtr->etherType    = (GT_U16) (fullFill ? 0xFFFF : 1);
    rulePtr->isArp        = 1;
    rulePtr->l2Encap      = 1;
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macDa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macSa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        rulePtr->vid1       = fullFill ? 0xFFF : 1;
        rulePtr->up1        = fullFill ? 0x7 : 1;
        rulePtr->cfi1       = 1;
        for (i = 0; (i < 4); i++)
        {
            rulePtr->udb0_3[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
}

static GT_VOID pclRuleTestFill_EgrStdIpL2Qos
(
    IN  GT_U32                                              fullFill,
    IN  GT_U32                                              ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_STC  *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_EgrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    rulePtr->common.sourcePort      &= 0x3f;/*limited to 6 bits*/

    pclRuleTestFill_EgrCommonStdIp(
        fullFill, &(rulePtr->commonStdIp));
    rulePtr->isArp        = 1;
    for (i = 0; (i < 4); i++)
    {
        rulePtr->dipBits0to31[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    rulePtr->l4Byte13      = (GT_U8) (fullFill ? 0xFF : 1);
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macDa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        for (i = 0; (i < 4); i++)
        {
            rulePtr->udb4_7[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
}

static GT_VOID pclRuleTestFill_EgrStdIpv4L4
(
    IN  GT_U32                                            fullFill,
    IN  GT_U32                                            ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_STC  *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_EgrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    rulePtr->common.sourcePort      &= 0x3f;/*limited to 6 bits*/

    pclRuleTestFill_EgrCommonStdIp(
        fullFill, &(rulePtr->commonStdIp));
    rulePtr->isArp        = 1;
    rulePtr->isBc         = 1;
    for (i = 0; (i < 4); i++)
    {
        rulePtr->sip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 4); i++)
    {
        rulePtr->dip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    rulePtr->l4Byte0       = (GT_U8) (fullFill ? 0xFF : 1);
    rulePtr->l4Byte1       = (GT_U8) (fullFill ? 0xFF : 1);
    rulePtr->l4Byte13      = (GT_U8) (fullFill ? 0xFF : 1);
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        for (i = 0; (i < 4); i++)
        {
            rulePtr->udb8_11[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
}

static GT_VOID pclRuleTestFill_EgrExtNotIpv6
(
    IN  GT_U32                                             fullFill,
    IN  GT_U32                                             ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_STC  *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_EgrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    pclRuleTestFill_EgrCommonExt(
        fullFill, &(rulePtr->commonExt));
    for (i = 0; (i < 4); i++)
    {
        rulePtr->sip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 4); i++)
    {
        rulePtr->dip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    rulePtr->etherType    = (GT_U16) (fullFill ? 0xFFFF : 1);
    rulePtr->l2Encap      = 1;
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macDa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macSa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    rulePtr->ipv4Fragmented           = 1;
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        rulePtr->isMpls                   = 1;
        rulePtr->numOfMplsLabels          = fullFill ? 0x3 : 1;
        rulePtr->protocolTypeAfterMpls    = fullFill ? 0x3 : 1;
        rulePtr->vid1                     = fullFill ? 0xFFF : 1;
        rulePtr->up1                      = fullFill ? 0x7 : 1;
        rulePtr->cfi1                     = 1;
        rulePtr->mplsLabel0               = fullFill ? 0xFFFFF : 1;
        rulePtr->mplsExp0                 = fullFill ? 0x7 : 1;
        rulePtr->mplsLabel1               = fullFill ? 0xFFFFF : 1;
        rulePtr->mplsExp1                 = fullFill ? 0x7 : 1;
        for (i = 0; (i < 8); i++)
        {
            rulePtr->udb12_19[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
}

static GT_VOID pclRuleTestFill_EgrExtIpv6L2
(
    IN  GT_U32                                             fullFill,
    IN  GT_U32                                             ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_STC   *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_EgrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    pclRuleTestFill_EgrCommonExt(
        fullFill, &(rulePtr->commonExt));
    for (i = 0; (i < 16); i++)
    {
        rulePtr->sip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 4); i++)
    {
        rulePtr->dipBits127to120 = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macDa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 6); i++)
    {
        rulePtr->macSa.arEther[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        rulePtr->vid1               = fullFill ? 0xFFF : 1;
        rulePtr->up1                = fullFill ? 0x7 : 1;
        rulePtr->cfi1               = 1;
        rulePtr->isIpv6ExtHdrExist  = 1;
        rulePtr->isIpv6HopByHop     = 1;
        for (i = 0; (i < 8); i++)
        {
            rulePtr->udb20_27[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
}

static GT_VOID pclRuleTestFill_EgrExtIpv6L4
(
    IN  GT_U32                                            fullFill,
    IN  GT_U32                                            ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_STC  *rulePtr
)
{
    GT_U32 i; /* loop index */

    pclRuleTestFill_EgrCommon(
        fullFill, ruleFlags, &(rulePtr->common));
    pclRuleTestFill_EgrCommonExt(
        fullFill, &(rulePtr->commonExt));
    for (i = 0; (i < 16); i++)
    {
        rulePtr->sip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    for (i = 0; (i < 16); i++)
    {
        rulePtr->dip.arIP[i] = (GT_U8) (fullFill ? 0xFF : 1);
    }
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        rulePtr->isIpv6ExtHdrExist  = 1;
        rulePtr->isIpv6HopByHop     = 1;
        for (i = 0; (i < 8); i++)
        {
            rulePtr->udb28_35[i] = (GT_U8) (fullFill ? 0xFF : 1);
        }
    }
}


/* generic fill with type */
#define GEN_FILL_MAC(field,numBits,type)    \
    field = (type) (fullFill ? BIT_MASK_MAC(numBits) : 1)

/* fill single bit */
#define U1_FILL_MAC(field)    \
    field = 1

/* fill U8 */
#define U8_FILL_MAC(field)    \
    GEN_FILL_MAC(field,8,GT_U8)

/* fill U16 */
#define U16_FILL_MAC(field,numBits) \
    GEN_FILL_MAC(field,numBits,GT_U16)

/* fill U32 */
#define U32_FILL_MAC(field,numBits) \
    GEN_FILL_MAC(field,numBits,GT_U32)

/* fill array of U8 , the size of the array is known at compilation time */
#define U8_ARRAY_AUTO_SIZE_FILL_MAC(field) \
    {                                       \
        GT_U32  _ii;                        \
        GT_U32  _iiMax = sizeof(field)/sizeof(field[0]); \
        for (_ii = 0; (_ii < _iiMax); _ii++)  \
        {                                   \
            U8_FILL_MAC(field[_ii]);   \
        }                                   \
    }

/* fill ipv4 */
#define IPV4_FILL_MAC(field)        \
    U8_ARRAY_AUTO_SIZE_FILL_MAC(field.arIP)

/* fill ipv4 */
#define IPV6_FILL_MAC(field)         \
    U8_ARRAY_AUTO_SIZE_FILL_MAC(field.arIP)

/* fill mac address */
#define MAC_ADDR_FILL_MAC(field)         \
    U8_ARRAY_AUTO_SIZE_FILL_MAC(field.arEther)

static GT_VOID pclRuleTestFill_IpCommon
(
    IN  GT_U32                                             fullFill,
    IN  GT_U32                                             ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_IP_COMMON_STC   *rulePtr
)
{
    U32_FILL_MAC(rulePtr->pclId,10);
    U1_FILL_MAC(rulePtr->macToMe);
    /* muxed and ommited - rulePtr->portListBmp     ;*/

    if ((ruleFlags & PRV_RF_NO_INGR_SRC_PORT_CNS) == 0)
    {
        U32_FILL_MAC(rulePtr->sourcePort,((ruleFlags & PRV_RF_SIP5_CNS) ? 8 :
                PRV_CPSS_IS_DUAL_HW_DEVICE_MAC(PRV_CPSS_PP_MAC(currentTestedDevNum)->hwDevNum) ? 7 : 6));
    }

    if (ruleFlags & PRV_RF_USE_PORTS_BMP_CNS)
    {
        /* use the ports bmp */
        PORTS_BMP_FILL_MAC(rulePtr->portListBmp);
       /* portListBmp[7:0] is muxed with pclId[7:0],
          portListBmp[15:8] is muxed with sourcePort[7:0]
          portListBmp[27:16] is muxed with sourceTrunkId.*/
       U32_SET_FIELD_MAC(rulePtr->sourcePort,0,8,0);
       if (ruleFlags & PRV_RF_SIP5_CNS)
       {
           U32_SET_FIELD_MAC(rulePtr->sourceDevice,0,10,0);
       }
       U32_SET_FIELD_MAC(rulePtr->pclId,0,8,0);
    }

    /* L2 */
    U1_FILL_MAC(rulePtr->isTagged);
    U32_FILL_MAC(rulePtr->vid,12);
    U32_FILL_MAC(rulePtr->up,3);
    /* L3 */
    U32_FILL_MAC(rulePtr->tos,8);
    U32_FILL_MAC(rulePtr->ipProtocol,8);
    /* L4 */
    U1_FILL_MAC(rulePtr->isL4Valid);
    U8_FILL_MAC(rulePtr->l4Byte0);
    U8_FILL_MAC(rulePtr->l4Byte1);
    U8_FILL_MAC(rulePtr->l4Byte2);
    U8_FILL_MAC(rulePtr->l4Byte3);
    U8_FILL_MAC(rulePtr->l4Byte13);


}

static GT_VOID pclRuleTestFill_ruleStdIpv4RoutedAclQos
(
    IN  GT_U32                                             fullFill,
    IN  GT_U32                                             ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_STD_IPV4_ROUTED_ACL_QOS_STC   *rulePtr
)
{
    pclRuleTestFill_IpCommon(
        fullFill, ruleFlags, &(rulePtr->ingressIpCommon));

    U32_FILL_MAC(rulePtr->pktType,3);
    /* L3 */
    U1_FILL_MAC(rulePtr->ipFragmented);
    U32_FILL_MAC(rulePtr->ipHeaderInfo,2);
    U32_FILL_MAC(rulePtr->ipPacketLength,14);
    U32_FILL_MAC(rulePtr->ttl,8);
    IPV4_FILL_MAC(rulePtr->sip);
    IPV4_FILL_MAC(rulePtr->dip);
    /* L4 */
    if(PRV_CPSS_PP_MAC(currentTestedDevNum)->devFamily == CPSS_PP_FAMILY_CHEETAH3_E)
    {
        U32_FILL_MAC(rulePtr->tcpUdpPortComparators,8);
    }
    U8_FILL_MAC(rulePtr->udb5);
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->udb41_44);

        /* VRF is multiplexed with UDB5 - reset it */
        U32_SET_FIELD_MAC(rulePtr->vrfId,0,8,0);
        U1_FILL_MAC(rulePtr->isUdbValid);
    }

}
static GT_VOID pclRuleTestFill_ruleExtIpv4PortVlanQos
(
    IN  GT_U32                                             fullFill,
    IN  GT_U32                                             ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV4_PORT_VLAN_QOS_STC   *rulePtr
)
{
    pclRuleTestFill_IpCommon(
        fullFill, ruleFlags, &(rulePtr->ingressIpCommon));
    /* L2 */
    U1_FILL_MAC(rulePtr->isL2Valid);
    U1_FILL_MAC(rulePtr->isBc);
    U1_FILL_MAC(rulePtr->isIp);
    U1_FILL_MAC(rulePtr->isArp);
    U32_FILL_MAC(rulePtr->l2Encap,((ruleFlags & PRV_RF_2BIT_L2ENCAP_CNS) ? 2 : 1));
    U16_FILL_MAC(rulePtr->etherType,16);
    MAC_ADDR_FILL_MAC(rulePtr->macDa);
    MAC_ADDR_FILL_MAC(rulePtr->macSa);
    /* L3 */
    U1_FILL_MAC(rulePtr->ipFragmented);
    U32_FILL_MAC(rulePtr->ipHeaderInfo,2);
    IPV4_FILL_MAC(rulePtr->sip);
    IPV4_FILL_MAC(rulePtr->dip);
    /* UDB */
    U1_FILL_MAC(rulePtr->isUdbValid);
    if(PRV_CPSS_PP_MAC(currentTestedDevNum)->devFamily == CPSS_PP_FAMILY_CHEETAH3_E)
    {
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbStdIpL2Qos);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbStdIpL2Qos);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbStdIpV4L4);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbExtIpv6L2);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbExtIpv6L4);
    }
    else
    {
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->udb5_16);
    }

    if(UTF_CPSS_PP_HW_INFO_E_ARCH_ENABLED_MAC(currentTestedDevNum) == GT_TRUE)
    {
        U1_FILL_MAC(rulePtr->tag1Exist);
        U32_FILL_MAC(rulePtr->vid1,12);
        U32_FILL_MAC(rulePtr->up1,3);
        U1_FILL_MAC(rulePtr->cfi1);
        /* VRF is muxed field - reset it */
        U32_SET_FIELD_MAC(rulePtr->vrfId, 0, 12, 0);

        U32_FILL_MAC(rulePtr->trunkHash,6);
        /* trunk hash and UDB 15 are muxed - skip UDB15 from test */
        rulePtr->udb5_16[10] = 0;

        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->udb31_38);
    }


}
static GT_VOID pclRuleTestFill_ruleUltraIpv6PortVlanQos
(
    IN  GT_U32                                             fullFill,
    IN  GT_U32                                             ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_ULTRA_IPV6_PORT_VLAN_QOS_STC   *rulePtr
)
{
    pclRuleTestFill_IpCommon(
        fullFill, ruleFlags, &(rulePtr->ingressIpCommon));
    /* L2 */
    U1_FILL_MAC(rulePtr->isL2Valid);
    U1_FILL_MAC(rulePtr->isNd);
    U1_FILL_MAC(rulePtr->isBc);
    U1_FILL_MAC(rulePtr->isIp);
    U32_FILL_MAC(rulePtr->l2Encap,((ruleFlags & PRV_RF_2BIT_L2ENCAP_CNS) ? 2 : 1));
    U16_FILL_MAC(rulePtr->etherType,16);
    MAC_ADDR_FILL_MAC(rulePtr->macDa);
    MAC_ADDR_FILL_MAC(rulePtr->macSa);
    /* L3 */
    IPV6_FILL_MAC(rulePtr->sip);
    IPV6_FILL_MAC(rulePtr->dip);
    U1_FILL_MAC(rulePtr->isIpv6ExtHdrExist);
    U1_FILL_MAC(rulePtr->isIpv6HopByHop);
    U1_FILL_MAC(rulePtr->ipHeaderOk);
    /* UDB */
    U1_FILL_MAC(rulePtr->isUdbValid);
    if(PRV_CPSS_PP_MAC(currentTestedDevNum)->devFamily == CPSS_PP_FAMILY_CHEETAH3_E)
    {
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbExtNotIpv6);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbExtIpv6L2);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbExtIpv6L4);
    }
    else
    {
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->udb0_11);
    }
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        U1_FILL_MAC(rulePtr->tag1Exist);
        U32_FILL_MAC(rulePtr->vid1,12);
        U32_FILL_MAC(rulePtr->up1,3);
        U1_FILL_MAC(rulePtr->cfi1);
        /* VRF is muxed field - reset it */
        U32_SET_FIELD_MAC(rulePtr->vrfId, 0, 12, 0);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->udb39_40);
        U32_FILL_MAC(rulePtr->srcPortOrTrunk,12);
        U1_FILL_MAC(rulePtr->srcIsTrunk);
        U32_FILL_MAC(rulePtr->trunkHash,6);

        /* trunk hash and UDB 1 are muxed - skip UDB1 from test */
        rulePtr->udb0_11[1] = 0;
    }
}
static GT_VOID pclRuleTestFill_ruleUltraIpv6RoutedAclQos
(
    IN  GT_U32                                             fullFill,
    IN  GT_U32                                             ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_ULTRA_IPV6_ROUTED_ACL_QOS_STC   *rulePtr
)
{
    pclRuleTestFill_IpCommon(
        fullFill, ruleFlags, &(rulePtr->ingressIpCommon));
    U32_FILL_MAC(rulePtr->pktType,3);
    /* L2 */
    U1_FILL_MAC(rulePtr->isNd);
    /* MPLS */
    U32_FILL_MAC(rulePtr->mplsOuterLabel,20);
    U32_FILL_MAC(rulePtr->mplsOuterLabExp,3);
    U1_FILL_MAC(rulePtr->mplsOuterLabSBit);
    /* L3 */
    U32_FILL_MAC(rulePtr->ipPacketLength,14);
    U32_FILL_MAC(rulePtr->ipv6HdrFlowLabel,20);
    U32_FILL_MAC(rulePtr->ttl,8);
    IPV6_FILL_MAC(rulePtr->sip);
    IPV6_FILL_MAC(rulePtr->dip);
    U1_FILL_MAC(rulePtr->isIpv6ExtHdrExist);
    U1_FILL_MAC(rulePtr->isIpv6HopByHop);
    U1_FILL_MAC(rulePtr->isIpv6LinkLocal);
    U1_FILL_MAC(rulePtr->isIpv6Mld);
    U1_FILL_MAC(rulePtr->ipHeaderOk);
    /* UDB */
    U1_FILL_MAC(rulePtr->isUdbValid);
    if(PRV_CPSS_PP_MAC(currentTestedDevNum)->devFamily == CPSS_PP_FAMILY_CHEETAH3_E)
    {
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbStdNotIp);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbStdIpL2Qos);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbStdIpV4L4);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbExtNotIpv6);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbExtIpv6L2);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->UdbExtIpv6L4);
    }
    else
    {
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->udb0_11);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->udb17_22);
    }
    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        U1_FILL_MAC(rulePtr->tag1Exist);
        U32_FILL_MAC(rulePtr->vid1,12);
        U32_FILL_MAC(rulePtr->up1,3);
        U1_FILL_MAC(rulePtr->cfi1);
        /* VRF is muxed field - reset it */
        U32_SET_FIELD_MAC(rulePtr->vrfId, 0, 12, 0);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->udb45_46);
        U32_FILL_MAC(rulePtr->srcPortOrTrunk,13);
        U1_FILL_MAC(rulePtr->srcIsTrunk);

        /* trunk hash and UDB 20 are muxed - skip trunk hash from test */
        rulePtr->trunkHash = 0;
    }
}

static GT_VOID pclRuleTestFill_EgrIpCommon
(
    IN  GT_U32                                             fullFill,
    IN  GT_U32                                             ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_IP_COMMON_STC   *rulePtr
)
{
    U32_FILL_MAC(rulePtr->pclId,10);
    if ((ruleFlags & PRV_RF_NO_INGR_SRC_PORT_CNS) == 0)
    {
        /* use 6 bits for Lion2 too because CPSS do not support 7 bits port number yet for the keys */
        CPSS_TBD_BOOKMARK_LION2;
        U32_FILL_MAC(rulePtr->sourcePort,((ruleFlags & PRV_RF_SIP5_CNS) ? 8 :
                PRV_CPSS_IS_DUAL_HW_DEVICE_MAC(PRV_CPSS_PP_MAC(currentTestedDevNum)->hwDevNum) ? 6 : 6));
    }
    U32_FILL_MAC(rulePtr->qosProfile,7);
    /* L2 */
    U1_FILL_MAC(rulePtr->isL2Valid);
    U32_FILL_MAC(rulePtr->originalVid,12);
    U1_FILL_MAC(rulePtr->isSrcTrunk);
    U32_FILL_MAC(rulePtr->srcDevOrTrunkId,7);
    U1_FILL_MAC(rulePtr->isIp);
    U1_FILL_MAC(rulePtr->isArp);
    MAC_ADDR_FILL_MAC(rulePtr->macDa);
    MAC_ADDR_FILL_MAC(rulePtr->macSa);
    /* L3 */
    U32_FILL_MAC(rulePtr->tos,8);
    U32_FILL_MAC(rulePtr->ipProtocol,8);
    U32_FILL_MAC(rulePtr->ttl,8);
    /* L4 */
    U1_FILL_MAC(rulePtr->isL4Valid);
    U8_FILL_MAC(rulePtr->l4Byte0);
    U8_FILL_MAC(rulePtr->l4Byte1);
    U8_FILL_MAC(rulePtr->l4Byte2);
    U8_FILL_MAC(rulePtr->l4Byte3);
    U8_FILL_MAC(rulePtr->l4Byte13);
    U32_FILL_MAC(rulePtr->tcpUdpPortComparators,8);
    /* egress */
    U32_FILL_MAC(rulePtr->tc,3);
    U32_FILL_MAC(rulePtr->dp,2);
    U32_FILL_MAC(rulePtr->egrPacketType,2);
    U1_FILL_MAC(rulePtr->srcTrgOrTxMirror);
    U32_FILL_MAC(rulePtr->assignedUp,3);
    U32_FILL_MAC(rulePtr->trgPhysicalPort,
            ((ruleFlags & PRV_RF_SIP5_CNS) ? 8 : 6));
    /* rxSniff field skipped due to muxing with qosProfile field*/
    /* U1_FILL_MAC(rulePtr->rxSniff); */
    U1_FILL_MAC(rulePtr->isRouted);
    U1_FILL_MAC(rulePtr->isIpv6);

    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        /*srcDev is mused with srcDevOrTrunkId - skip srcDev */
        rulePtr->srcHwDev = 0;

        U1_FILL_MAC(rulePtr->tag1Exist);
        U32_FILL_MAC(rulePtr->sourceId,12);
    }
}

static GT_VOID pclRuleTestFill_ruleEgrExtIpv4RaclVacl
(
    IN  GT_U32                                             fullFill,
    IN  GT_U32                                             ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_STC   *rulePtr
)
{
    pclRuleTestFill_EgrIpCommon(
        fullFill, ruleFlags, &(rulePtr->egressIpCommon));

    IPV4_FILL_MAC(rulePtr->sip);
    IPV4_FILL_MAC(rulePtr->dip);
    U1_FILL_MAC(rulePtr->ipv4Options);
    U1_FILL_MAC(rulePtr->isVidx);

    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        U32_FILL_MAC(rulePtr->vid1,12);
        U32_FILL_MAC(rulePtr->up1,3);
        U1_FILL_MAC(rulePtr->cfi1);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->udb36_49);
        U1_FILL_MAC(rulePtr->udb0);
    }
}
static GT_VOID pclRuleTestFill_ruleEgrUltraIpv6RaclVacl
(
    IN  GT_U32                                             fullFill,
    IN  GT_U32                                             ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_STC   *rulePtr
)
{
    pclRuleTestFill_EgrIpCommon(
        fullFill, ruleFlags, &(rulePtr->egressIpCommon));

    IPV6_FILL_MAC(rulePtr->sip);
    IPV6_FILL_MAC(rulePtr->dip);
    U1_FILL_MAC(rulePtr->isNd);
    U1_FILL_MAC(rulePtr->isIpv6ExtHdrExist);
    U1_FILL_MAC(rulePtr->isIpv6HopByHop);
    U1_FILL_MAC(rulePtr->isVidx);

    if (ruleFlags & PRV_RF_SIP5_CNS)
    {
        U32_FILL_MAC(rulePtr->vid1,12);
        U32_FILL_MAC(rulePtr->up1,3);
        U1_FILL_MAC(rulePtr->cfi1);
        U32_FILL_MAC(rulePtr->trgPort,13);
        U8_ARRAY_AUTO_SIZE_FILL_MAC(rulePtr->udb1_4);
    }
}

static GT_VOID pclRuleStructureTestFill
(
    IN GT_U8    dev,
    IN CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat,
    IN  GT_U32                            fullFill,
    IN  GT_U32                            ruleFlags,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT     *rulePtr
)
{
    switch (ruleFormat)
    {
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E:
            pclRuleTestFill_IngrStdNotIp(
                fullFill, ruleFlags, &(rulePtr->ruleStdNotIp));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E:
            pclRuleTestFill_IngrStdIpL2Qos(
                fullFill, ruleFlags, &(rulePtr->ruleStdIpL2Qos));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E:
            pclRuleTestFill_IngrStdIpv4L4(
                fullFill, ruleFlags, &(rulePtr->ruleStdIpv4L4));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E:
            pclRuleTestFill_IngrStdIpv6Dip(
                fullFill, ruleFlags, &(rulePtr->ruleStdIpv6Dip));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E:
            pclRuleTestFill_IngrExtNotIpv6(
                fullFill, ruleFlags, &(rulePtr->ruleExtNotIpv6));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E:
            pclRuleTestFill_IngrExtIpv6L2(
                fullFill, ruleFlags, &(rulePtr->ruleExtIpv6L2));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E:
            pclRuleTestFill_IngrExtIpv6L4(
                fullFill, ruleFlags, &(rulePtr->ruleExtIpv6L4));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E:
            pclRuleTestFill_EgrStdNotIp(
                fullFill, ruleFlags, &(rulePtr->ruleEgrStdNotIp));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E:
            pclRuleTestFill_EgrStdIpL2Qos(
                fullFill, ruleFlags, &(rulePtr->ruleEgrStdIpL2Qos));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E:
            pclRuleTestFill_EgrStdIpv4L4(
                fullFill, ruleFlags, &(rulePtr->ruleEgrStdIpv4L4));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E:
            pclRuleTestFill_EgrExtNotIpv6(
                fullFill, ruleFlags, &(rulePtr->ruleEgrExtNotIpv6));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E:
            pclRuleTestFill_EgrExtIpv6L2(
                fullFill, ruleFlags, &(rulePtr->ruleEgrExtIpv6L2));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E:
            pclRuleTestFill_EgrExtIpv6L4(
                fullFill, ruleFlags, &(rulePtr->ruleEgrExtIpv6L4));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E:
            pclRuleTestFill_IngrStdUdb(
                fullFill, ruleFlags, &(rulePtr->ruleIngrStdUdb));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E:
            pclRuleTestFill_IngrExtUdb(
                fullFill, ruleFlags, &(rulePtr->ruleIngrExtUdb));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E    :
            pclRuleTestFill_ruleStdIpv4RoutedAclQos(
                fullFill, ruleFlags, &(rulePtr->ruleStdIpv4RoutedAclQos));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E     :
            pclRuleTestFill_ruleExtIpv4PortVlanQos(
                fullFill, ruleFlags, &(rulePtr->ruleExtIpv4PortVlanQos));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E   :
            pclRuleTestFill_ruleUltraIpv6PortVlanQos(
                fullFill, ruleFlags, &(rulePtr->ruleUltraIpv6PortVlanQos));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E  :
            pclRuleTestFill_ruleUltraIpv6RoutedAclQos(
                fullFill, ruleFlags, &(rulePtr->ruleUltraIpv6RoutedAclQos));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E          :
            pclRuleTestFill_ruleEgrExtIpv4RaclVacl(
                fullFill, ruleFlags, &(rulePtr->ruleEgrExtIpv4RaclVacl));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E        :
            pclRuleTestFill_ruleEgrUltraIpv6RaclVacl(
                fullFill, ruleFlags, &(rulePtr->ruleEgrUltraIpv6RaclVacl));
            break;

        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_10_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_20_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_30_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_40_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_50_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_60_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_UDB_80_E:
            pclRuleTestFill_IngrUdbOnly(
            dev,
                ruleFormat, fullFill, ruleFlags, &(rulePtr->ruleIngrUdbOnly));
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_10_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_20_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_30_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_40_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_50_E:
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_UDB_60_E:
            pclRuleTestFill_EgrUdbOnly(
                ruleFormat, fullFill, &(rulePtr->ruleEgrUdbOnly));
            break;
        default:
            cpssOsPrintf("ERROR : not supported case \n");
            break;
    }
}

/* help function for Rule Get testing                         */
/* Fill Mask and pattern of the rule                          */
/* All Port Group depended fields bypassed.                   */
/* All muxed fields bypassed.                                 */
/* All other fields get values:                               */
/* mask - maxvalues for all fields                            */
/* pattern:                                                   */
/* patternIndex == 0 - 1 for all fields                       */
/* patternIndex == 1 - (maxValue - 1) for all fields          */
/* patternIndex == 2 - (maxValue & byte index) for all fields */
/* patternIndex == 3 - relevant to multi-port group device
                       the srcPort field is tested for
                       mask.srcPort = 0..max
                       pattern.srcPort = changed */
static GT_VOID pclRuleTestFill
(
    IN  GT_U8                              devNum,
    IN  CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat,
    IN  GT_U32                             patternIndex,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT      *maskPtr,
    OUT CPSS_DXCH_PCL_RULE_FORMAT_UNT      *patternPtr,
    IN  GT_BOOL                            usePortsBmp,
    IN  GT_U32                             iterationIndex
)
{
    GT_U32 i;
    GT_U32 *wordMaskPtr;
    GT_U32 *wordPatternPtr;
    GT_U32 ruleSize;
    GT_U32 ruleFlags = 0;
    GT_U8  *bytePtr;
    GT_PHYSICAL_PORT_NUM              *patternSrcPortPtr;/*pointer to the physical src port in the pattern*/
    GT_PHYSICAL_PORT_NUM              *maskSrcPortPtr;/*pointer to the physical src port in the mask*/
    /*GT_PHYSICAL_PORT_NUM              *patternTrgPortPtr; */ /*pointer to the physical src port in the pattern*/
    /*GT_PHYSICAL_PORT_NUM              *maskTrgPortPtr;*/ /*pointer to the physical src port in the mask*/
    CPSS_PORTS_BMP_STC                *patternPortListBmpPtr;/*pointer to the port list bmp in the pattern*/
    CPSS_PORTS_BMP_STC                *maskPortListBmpPtr;/*pointer to the port list bmp in the mask*/
    GT_U8                             *patternEgressIsSrcTrunkPtr;/*pointer to the <isSrcTrunkPtr> in egress key in the pattern*/
    GT_U8                             *maskEgressIsSrcTrunkPtr;/*pointer to the <isSrcTrunkPtr> in egress key in the mask*/
    GT_U32                            *patternEgressSrcDevOrTrunkIdPtr;/*pointer to the <srcDevOrTrunkId> in egress key in the pattern*/
    GT_U32                            *maskEgressSrcDevOrTrunkIdPtr;/*pointer to the <srcDevOrTrunkId> in egress key in the mask*/
    GT_U32                            *patternEgrPacketTypePtr;/*pointer to the <egrPacketType> in egress key in the pattern*/
    GT_U32                            *maskEgrPacketTypePtr;/*pointer to the <egrPacketType> in egress key in the mask*/

    currentTestedDevNum = devNum;

    CPSS_PORTS_BMP_PORT_CLEAR_ALL_MAC(&sip5Support28PortsInPortListBmp);
    sip5Support28PortsInPortListBmp.ports[0] = (1<<28)-1;

    /*set ruleFlags according to : usePortsBmp */
    RULE_FLAGS_SET_MAC(devNum,ruleFlags,usePortsBmp);

    cpssOsMemSet(maskPtr, 0, sizeof(CPSS_DXCH_PCL_RULE_FORMAT_UNT));
    cpssOsMemSet(patternPtr, 0, sizeof(CPSS_DXCH_PCL_RULE_FORMAT_UNT));
    pclRuleStructureTestFill(
        devNum,
        ruleFormat, 1 /*fullFill*/, ruleFlags, maskPtr);
    pclRuleStructureTestFill(
        devNum,
        ruleFormat, 0 /*fullFill*/, ruleFlags, patternPtr);
    if (patternIndex == 1 || patternIndex == 3)
    {
        ruleSize = sizeof(CPSS_DXCH_PCL_RULE_FORMAT_UNT) / sizeof(GT_U32);
        wordMaskPtr    = (GT_U32*)maskPtr;
        wordPatternPtr = (GT_U32*)patternPtr;
        for (i = 0; (i < ruleSize); i++)
        {
            /* set to (maxVaslue - 1) */
            wordPatternPtr[i] = (~ wordPatternPtr[i]) & wordMaskPtr[i];
        }
    }
    if (patternIndex == 2)
    {
        cpssOsMemCpy(
            patternPtr, maskPtr,
            sizeof(CPSS_DXCH_PCL_RULE_FORMAT_UNT));
        bytePtr = (GT_U8*)patternPtr;
        ruleSize = sizeof(CPSS_DXCH_PCL_RULE_FORMAT_UNT) / sizeof(GT_U8);
        for (i = 0; (i < ruleSize); i++)
        {
            bytePtr[i] &= (GT_U8)(i & 0xFF);
        }
    }

    patternSrcPortPtr = NULL;
    maskSrcPortPtr    = NULL;
    patternPortListBmpPtr = NULL;
    maskPortListBmpPtr = NULL;
  /*  patternTrgPortPtr = NULL; */
/*    maskTrgPortPtr = NULL; */
    patternEgressIsSrcTrunkPtr = NULL;
    maskEgressIsSrcTrunkPtr = NULL;
    patternEgressSrcDevOrTrunkIdPtr = NULL;
    maskEgressSrcDevOrTrunkIdPtr = NULL;
    patternEgrPacketTypePtr = NULL;
    maskEgrPacketTypePtr = NULL;

    switch(ruleFormat)
    {
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_NOT_IP_E                     /*0*/ :
            patternSrcPortPtr = &patternPtr->ruleStdNotIp.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleStdNotIp.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleStdNotIp.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleStdNotIp.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IP_L2_QOS_E                  /*1*/ :
            patternSrcPortPtr = &patternPtr->ruleStdIpL2Qos.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleStdIpL2Qos.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleStdIpL2Qos.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleStdIpL2Qos.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_L4_E                    /*2*/ :
            patternSrcPortPtr = &patternPtr->ruleStdIpv4L4.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleStdIpv4L4.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleStdIpv4L4.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleStdIpv4L4.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV6_DIP_E                   /*3*/ :
            patternSrcPortPtr = &patternPtr->ruleStdIpv6Dip.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleStdIpv6Dip.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleStdIpv6Dip.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleStdIpv6Dip.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_NOT_IPV6_E                   /*4*/ :
            patternSrcPortPtr = &patternPtr->ruleExtNotIpv6.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleExtNotIpv6.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleExtNotIpv6.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleExtNotIpv6.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L2_E                    /*5*/ :
            patternSrcPortPtr = &patternPtr->ruleExtIpv6L2.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleExtIpv6L2.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleExtIpv6L2.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV6_L4_E                    /*6*/ :
            patternSrcPortPtr = &patternPtr->ruleExtIpv6L4.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleExtIpv6L4.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleExtIpv6L4.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleExtIpv6L4.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_NOT_IP_E                      /*7*/   :
            patternSrcPortPtr = &patternPtr->ruleEgrStdNotIp.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleEgrStdNotIp.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleEgrStdNotIp.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleEgrStdNotIp.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IP_L2_QOS_E                   /*8*/   :
            patternSrcPortPtr = &patternPtr->ruleEgrStdIpL2Qos.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleEgrStdIpL2Qos.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleEgrStdIpL2Qos.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleEgrStdIpL2Qos.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_STD_IPV4_L4_E                     /*9*/   :
            patternSrcPortPtr = &patternPtr->ruleEgrStdIpv4L4.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleEgrStdIpv4L4.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleEgrStdIpv4L4.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleEgrStdIpv4L4.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_NOT_IPV6_E                    /*10*/  :
            patternSrcPortPtr = &patternPtr->ruleEgrExtNotIpv6.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleEgrExtNotIpv6.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleEgrExtNotIpv6.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleEgrExtNotIpv6.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L2_E                     /*11*/  :
            patternSrcPortPtr = &patternPtr->ruleEgrExtIpv6L2.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleEgrExtIpv6L2.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleEgrExtIpv6L2.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleEgrExtIpv6L2.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV6_L4_E                     /*12*/  :
            patternSrcPortPtr = &patternPtr->ruleEgrExtIpv6L4.common.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleEgrExtIpv6L4.common.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleEgrExtIpv6L4.common.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleEgrExtIpv6L4.common.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_UDB_E                        /*13*/:
            patternSrcPortPtr = &patternPtr->ruleIngrStdUdb.commonIngrUdb.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleIngrStdUdb.commonIngrUdb.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleIngrStdUdb.commonIngrUdb.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleIngrStdUdb.commonIngrUdb.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_UDB_E                        /*14*/:
            patternSrcPortPtr = &patternPtr->ruleIngrExtUdb.commonIngrUdb.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleIngrExtUdb.commonIngrUdb.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleIngrExtUdb.commonIngrUdb.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleIngrExtUdb.commonIngrUdb.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_STD_IPV4_ROUTED_ACL_QOS_E        /*15*/:
            patternSrcPortPtr = &patternPtr->ruleStdIpv4RoutedAclQos.ingressIpCommon.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleStdIpv4RoutedAclQos.ingressIpCommon.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleStdIpv4RoutedAclQos.ingressIpCommon.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleStdIpv4RoutedAclQos.ingressIpCommon.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_EXT_IPV4_PORT_VLAN_QOS_E         /*16*/:
            patternSrcPortPtr = &patternPtr->ruleExtIpv4PortVlanQos.ingressIpCommon.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleExtIpv4PortVlanQos.ingressIpCommon.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleExtIpv4PortVlanQos.ingressIpCommon.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleExtIpv4PortVlanQos.ingressIpCommon.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_PORT_VLAN_QOS_E       /*17*/:
            patternSrcPortPtr = &patternPtr->ruleUltraIpv6PortVlanQos.ingressIpCommon.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleUltraIpv6PortVlanQos.ingressIpCommon.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleUltraIpv6PortVlanQos.ingressIpCommon.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleUltraIpv6PortVlanQos.ingressIpCommon.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_INGRESS_ULTRA_IPV6_ROUTED_ACL_QOS_E      /*18*/:
            patternSrcPortPtr = &patternPtr->ruleUltraIpv6RoutedAclQos.ingressIpCommon.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleUltraIpv6RoutedAclQos.ingressIpCommon.sourcePort;
            patternPortListBmpPtr = &patternPtr->ruleUltraIpv6RoutedAclQos.ingressIpCommon.portListBmp;
            maskPortListBmpPtr = &maskPtr->ruleUltraIpv6RoutedAclQos.ingressIpCommon.portListBmp;
            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_EXT_IPV4_RACL_VACL_E              /*19*/  :
            patternSrcPortPtr = &patternPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.sourcePort;
            patternEgressSrcDevOrTrunkIdPtr = &patternPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.srcDevOrTrunkId;
            maskEgressSrcDevOrTrunkIdPtr = &maskPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.srcDevOrTrunkId;
            patternEgressIsSrcTrunkPtr = &patternPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.isSrcTrunk;
            maskEgressIsSrcTrunkPtr = &maskPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.isSrcTrunk;
            patternEgrPacketTypePtr = &patternPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.egrPacketType;
            maskEgrPacketTypePtr = &maskPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.egrPacketType;
            /*  the target port not comes with 'trgDev' so we cant convert it to local port.
            patternTrgPortPtr = &patternPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.trgPhysicalPort;
            maskTrgPortPtr = &maskPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.trgPhysicalPort;
            */

            break;
        case CPSS_DXCH_PCL_RULE_FORMAT_EGRESS_ULTRA_IPV6_RACL_VACL_E            /*20*/  :
            patternSrcPortPtr = &patternPtr->ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourcePort;
            maskSrcPortPtr = &maskPtr->ruleEgrUltraIpv6RaclVacl.egressIpCommon.sourcePort;
            patternEgressSrcDevOrTrunkIdPtr = &patternPtr->ruleEgrUltraIpv6RaclVacl.egressIpCommon.srcDevOrTrunkId;
            maskEgressSrcDevOrTrunkIdPtr = &maskPtr->ruleEgrUltraIpv6RaclVacl.egressIpCommon.srcDevOrTrunkId;
            patternEgressIsSrcTrunkPtr = &patternPtr->ruleEgrUltraIpv6RaclVacl.egressIpCommon.isSrcTrunk;
            maskEgressIsSrcTrunkPtr = &maskPtr->ruleEgrUltraIpv6RaclVacl.egressIpCommon.isSrcTrunk;
            patternEgrPacketTypePtr = &patternPtr->ruleEgrUltraIpv6RaclVacl.egressIpCommon.egrPacketType;
            maskEgrPacketTypePtr = &maskPtr->ruleEgrUltraIpv6RaclVacl.egressIpCommon.egrPacketType;
            /*  the target port not comes with 'trgDev' so we cant convert it to local port.
            patternTrgPortPtr = &patternPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.trgPhysicalPort;
            maskTrgPortPtr = &maskPtr->ruleEgrExtIpv4RaclVacl.egressIpCommon.trgPhysicalPort;
            */
            break;
        default:
            break;
    }

    if(
        (  0 == (ruleFlags & PRV_RF_USE_PORTS_BMP_CNS) || (patternPortListBmpPtr == NULL && maskPortListBmpPtr == NULL )))
    {
/*
        if(patternSrcPortPtr == NULL && patternTrgPortPtr != NULL)
        {
            patternSrcPortPtr = patternTrgPortPtr;
            maskSrcPortPtr    = maskTrgPortPtr;
        }
*/

        /* check <sourcePort> with special values */
        if(patternSrcPortPtr)
        {
            if(iterationIndex == 0)
            {
                /* check CPU port */
                *patternSrcPortPtr = CPSS_CPU_PORT_NUM_CNS;
            }
            else
            if (iterationIndex == 1)
            {
                /* check NULL port */
                *patternSrcPortPtr = CPSS_NULL_PORT_NUM_CNS;
            }
            else
            if(PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
            {
                *patternSrcPortPtr = PRV_CPSS_LOCAL_PORT_TO_GLOBAL_PORT_CONVERT_MAC(devNum,
                    (iterationIndex % PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.numOfPortGroups),
                    ((iterationIndex + 5) % 16));
            }
            else
            {
                *patternSrcPortPtr = (iterationIndex % PRV_CPSS_PP_MAC(devNum)->numOfPorts) ;
            }
/*
            if(patternTrgPortPtr)
            {
                *patternTrgPortPtr = *patternSrcPortPtr;*/
                /* make sure that the pattern not exceed the mask */
               /* *patternTrgPortPtr &= (*maskTrgPortPtr);
            }
*/

            /* make sure that the pattern not exceed the mask */
            *patternSrcPortPtr &= (*maskSrcPortPtr);

        }

        if(patternIndex == 3 && maskSrcPortPtr && patternSrcPortPtr)
        {
            GT_U32  maxSourcePort = *maskSrcPortPtr;

            *maskSrcPortPtr = maxSourcePort - (iterationIndex % maxSourcePort);

            /* make sure that the pattern not exceed the mask */
            *patternSrcPortPtr &= (*maskSrcPortPtr);
            /*
            cpssOsPrintf("pclRuleTestFill : patternIndex == [%d] ,iterationIndex[%d] , maxSourcePort[0x%2.2x], maskSourcePort[0x%2.2x] , patternSourcePort[0x%2.2x] \n",
                patternIndex,iterationIndex,maxSourcePort,*maskSrcPortPtr,*patternSrcPortPtr);
            */

        }

        if(maskSrcPortPtr && patternSrcPortPtr &&
           patternEgressSrcDevOrTrunkIdPtr && maskEgressSrcDevOrTrunkIdPtr &&
           patternEgressIsSrcTrunkPtr && maskEgressIsSrcTrunkPtr &&
           patternEgrPacketTypePtr && maskEgrPacketTypePtr)
        {
            if(iterationIndex & 1)
            {
                *patternEgrPacketTypePtr = 0;/*forward*/
                *maskEgrPacketTypePtr = 1;

                *patternEgressIsSrcTrunkPtr = 0;/*not trunk*/
                *maskEgressIsSrcTrunkPtr = 1;
            }
            else
            {
                (*maskSrcPortPtr)    &= ~BIT_6;
                (*patternSrcPortPtr) &= ~BIT_6;
            }
        }


    }
    else
    {
        /* check <portListBmp> with special values */
        if(patternPortListBmpPtr && maskPortListBmpPtr)
        {
            CPSS_PORTS_BMP_PORT_CLEAR_ALL_MAC(patternPortListBmpPtr);

            if((iterationIndex & 7) == 4)
            {
                if(GT_FALSE == UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                {
                    CPSS_PORTS_BMP_BITWISE_AND_MAC(
                        patternPortListBmpPtr,
                        &testedPortListBmpMask,
                        &PRV_CPSS_PP_MAC(devNum)->existingPorts);
                }
                else
                {
                    CPSS_PORTS_BMP_BITWISE_AND_MAC(
                        patternPortListBmpPtr,
                        &testedPortListBmpMask,
                        &sip5Support28PortsInPortListBmp);
                }
            }
            else if(PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
            {
                PRV_TGF_PP_START_LOOP_PORT_GROUPS_MAC(devNum,i)
                {
                    CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr, PRV_CPSS_LOCAL_PORT_TO_GLOBAL_PORT_CONVERT_MAC(devNum,i,(iterationIndex + i + 0)%12));
                    CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr, PRV_CPSS_LOCAL_PORT_TO_GLOBAL_PORT_CONVERT_MAC(devNum,i,(iterationIndex + i + 5)%12));
                    CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr, PRV_CPSS_LOCAL_PORT_TO_GLOBAL_PORT_CONVERT_MAC(devNum,i,(iterationIndex + i + 7)%12));
                }
                PRV_TGF_PP_END_LOOP_PORT_GROUPS_MAC(devNum,i)
            }
            else
            {
                GT_U32  maxPortsInBmp;

                if(UTF_CPSS_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum))
                {
                    maxPortsInBmp = 28;
                }
                else
                {
                    maxPortsInBmp = PRV_CPSS_PP_MAC(devNum)->numOfPorts;
                }

                CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr, ((iterationIndex +  0)%maxPortsInBmp) );
                CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr, ((iterationIndex +  5)%maxPortsInBmp) );
                CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr, ((iterationIndex +  7)%maxPortsInBmp) );
                CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr, ((iterationIndex + 12)%maxPortsInBmp) );
                CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr, ((iterationIndex + 17)%maxPortsInBmp) );
                CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr, ((iterationIndex + 23)%maxPortsInBmp) );
                CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr, ((iterationIndex + 31)%maxPortsInBmp) );
                CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr, ((iterationIndex + 56)%maxPortsInBmp) );
            }

            if(PRV_CPSS_IS_LION_STYLE_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
            {
                /* check CPU port */
                CPSS_PORTS_BMP_PORT_SET_MAC(patternPortListBmpPtr,CPSS_CPU_PORT_NUM_CNS);
            }

            /* make sure that the pattern not exceed the mask */
            CPSS_PORTS_BMP_BITWISE_AND_MAC(patternPortListBmpPtr,patternPortListBmpPtr,maskPortListBmpPtr);
        }
    }

}
static GT_U32 bitcount(GT_U32 value) {
    return prvCpssPpConfigBitmapNumBitsGet(value);
}
static GT_VOID add_bmp_value
(
    IN GT_U32  *bmp,
    IN GT_U32  value
)
{
    bmp[value>>5] |= 1 << (value & 0x1f);
}

